<script id='generatorScript' type='javascript/worker'>
'use strict';




const generatorVersion = 114;


const MAX_INT32        = 2147483647;
  
const NULL             = '';
  
const TAB              = '  ';
const NL               = '\n';
  
const GENERATOR_LOGO   = '◦ G •';
const OBJECT_PREFIX    = 'G.';
  
const nodeTag          = 'G_NODE';
const connTag          = 'G_CONN';


const smallScrollGap   =  6;
const largeScrollGap   = 14;
  
const menuBarHeight    = 40;



function toInt(f) { return Math.floor(f) | 0; }



function nextPow2(x)
{
    x = toInt(x);

    x--;

    x |= x >> 1;
    x |= x >> 2;
    x |= x >> 4;
    x |= x >> 8;
    x |= x >> 16;
    x |= x >> 32;

    return ++x;
}



function gcd(a, b)
{
    let temp;
    while (1)
    {
        temp = a % b;

        if (temp == 0)
          return b;

        a = b;
        b = temp;
    }
}



function toUtf8(str) 
{
    return decodeURI(encodeURIComponent(str));
}



function fromUtf8(str) 
{
    return decodeURIComponent(encodeURI(str));
}



function arrayToString(bytes) 
{
    let str = '';

    for (let i = 0; i < bytes.length; i++)
        str += String.fromCharCode(bytes[i]);

    return str;
}



function stringToArray(str)
{
    return Array.from(fromUtf8(str), c => c.charCodeAt(0));
}



function newSizeArrayFrom(array, size) // resizes an array and returns a new array
{
    const newArray = new Uint8Array(size);
    copyArray(array, newArray);
    return newArray;
}



function copyArray(src, dst)
{
    copyArrayAt(
        src, 0, src.length,
        dst, 0, dst.length);
}



function copyArrayAt(src, srcStart, srcSize, dst, dstStart, dstSize)
{
    const size = Math.min(srcSize, dstSize);

    for (let i = 0; i < size; i++)
        dst[dstStart + i] = src[srcStart + i];
}



function arraysAreEqual(arr1, arr2)
{
    if (arr1.length != arr2.length)
        return false;

    for (let i = 0; i < arr1.length; i++)
    {
        if (arr1[i] != arr2[i])
            return false;
    }

    return true;
}



function arraysIntersect(array1, array2)
{
    return array1.findIndex(i => array2.includes(i)) > -1;
}



function  leftArrowChar(list) { return list ? '⟸' : '⟵'; }
function rightArrowChar(list) { return list ? '⟹' : '⟶'; }

function nodeNameForStorage(nodeId) { return nodeTag + ' ' + nodeId; }
function connNameForStorage(name)   { return connTag + ' ' + name;   }



function parseBool(str) 
{ 
    return str.toLowerCase() == 'true'
        || str == '1';
}



function connToString(_conn, logSpace = false)
{
    return getConnectionString(
        _conn.outputNodeId,
        _conn.outputId,
        _conn.outputOrder,
        _conn.inputNodeId,
        _conn.inputId,
        _conn.list,
        logSpace);
}



function getConnectionKey(outputNodeId, outputId, outputOrder, inputNodeId, inputId)
{
    return connNameForStorage(
          outputNodeId + ' '
        + outputId     + ' '
        + outputOrder  + ' '
        + inputNodeId  + ' '
        + inputId);
}



function getConnKey(conn)
{
    return getConnectionKey(
        conn.output.node.id,
        conn.output.id,
        conn.outputOrder,
        conn.input.node.id,
        conn.input.id);
}



function getConnString(conn, logSpace = false)
{
    return getConnectionString(
        conn.output.node.id,
        conn.output.id,
        conn.outputOrder,
        conn.input.node.id,
        conn.input.id,
        conn.list,
        logSpace);
}



function getConnectionString(outputNodeId, outputId, outputOrder, inputNodeId, inputId, list, logSpace = false)
{
    const  sp   = logSpace ? ' ' : '  '; 
    const jsp   = logSpace ? ''  : ' '; 

    const arrow = sp + subscriptNumber(parseInt(outputOrder)) + rightArrowChar(parseBool(list)) + sp;
    const join  = jsp + '.' + jsp;

    return outputNodeId + join + outputId
         + arrow
         + inputNodeId  + join + inputId;
}



function superscriptNumber(num)
{
    const str = num.toString();

    let sup = '';

    for (const c of str)
        sup += superscriptChar(c);

    return sup;
}



function superscriptChar(c)
{
    switch (c)
    {
        case '0': return '⁰';
        case '1': return '¹';
        case '2': return '²';
        case '3': return '³';
        case '4': return '⁴';
        case '5': return '⁵';
        case '6': return '⁶';
        case '7': return '⁷';
        case '8': return '⁸';
        case '9': return '⁹';
        case '.': return '·';
    }
}



function subscriptNumber(num)
{
    const str = num.toString();

    let sup = '';

    for (const c of str)
        sup += subscriptChar(c);

    return sup;
}



function subscriptChar(c)
{
    switch (c)
    {
        case '0': return '₀';
        case '1': return '₁';
        case '2': return '₂';
        case '3': return '₃';
        case '4': return '₄';
        case '5': return '₅';
        case '6': return '₆';
        case '7': return '₇';
        case '8': return '₈';
        case '9': return '₉';
        case '.': return ' ';
    }
}



function boolToString(bool)
{
    return bool ? 'true' : 'false';
}



function isValid(val)
{
    return val != undefined
        && val != null;
}



function isEmpty(array)
{
    return array.length == 0;
}



function removeFrom(array, item)
{
    removeAt(array, array.indexOf(item));
}



function removeAt(array, index)
{
    if (   index > -1 
        && index < array.length)
        array.splice(index, 1)
}



function removeLast(array)
{
    if (isEmpty(array))
        return null;

    let last = lastOf(array);
    array.splice(array.length-1, 1)

    return last;
}



function beforeLastOf(array)
{
    return array.length > 1 
         ? array[array.length-2]
         : null;
}



function lastOf(array)
{
    return array[array.length-1];
}



function firstOf(array)
{
    return array[0];
}



function moveInArray(array, from, to) 
{
    const item = array[from];
    array.splice(from, 1);
    array.splice(to, 0, item);
}



function removeFromArray(array, item)
{
    const index = array.indexOf(item);
    
    if (index > -1)
        array.splice(index, 1);
}



function removeArrayFromArray(fromArray, array)
{
    for (const item of array)
    {
        const index = fromArray.indexOf(item);
        
        if (index > -1)
            fromArray.splice(index, 1);
    }
}



function removeFromArrayWhere(array, where)
{
    const index = array.findIndex(where);
    
    if (index > -1)
        array.splice(index, 1);
}



function cleanStyleId(styleId)
{
    return styleId.split(',')[0] + ',';
}



function rgbHeaderFromType(type, active)
{
    if (FLOW_TYPES.includes(type))
        return active 
        ? (darkMode ? rgbActiveFlowDark : rgbActiveFlowLight)
        : (darkMode ? rgbFlowDark       : rgbFlowLight      );

    if (NUMBER_TYPES.includes(type))
        return active 
        ? (darkMode ? rgbActiveNumberDark : rgbActiveNumberLight)
        : (darkMode ? rgbNumberDark       : rgbNumberLight      );

    if (STRING_TYPES.includes(type))
        return active 
        ? (darkMode ? rgbActiveStringDark : rgbActiveStringLight)
        : (darkMode ? rgbStringDark       : rgbStringLight      );

    if (SHAPE_TYPES.includes(type))
        return active 
        ? (darkMode ? rgbActiveShapeDark : rgbActiveShapeLight)
        : (darkMode ? rgbShapeDark       : rgbShapeLight      );

    if (type == COLOR_STYLE)//COLOR_STYLE_TYPES.includes(type))
        return active 
        ? (darkMode ? rgbActiveFlowDark : rgbActiveFlowLight)
        : (darkMode ? rgbFlowDark       : rgbFlowLight      );

        
    switch (type)
    {
        case COLOR_VALUE:           

        case COLOR:           
        case COLOR_INTERPOLATE:
        case CORRECT_COLOR:
        case COLOR_CONTRAST:
        case COLORBLIND:
            return active 
                 ? rgbActiveColor  
                 : rgbColor;
    }

    return 'magenta';
}



function isDataColorNaN(color)
{
    return isNaN(color[1])
        || isNaN(color[2])
        || isNaN(color[3]);
}


const Epsilon = 0.0000001;



function nozero(x)
{
    return x != 0 ? x : Epsilon;
}



function noNaN(x, replace)
{
    return !isNaN(x) ? x : replace;
}



function isSimpleLatinLetter(c)
{
    return c >= 'a' && c <= 'z'
        || c >= 'A' && c <= 'Z';
}


function getDigitCount(i)
{
    let l = Math.floor(Math.log10(Math.abs(i))); // the minus sign doesn't count as a digit;
    return l + 1;
}



function isDigit(c)
{
    return c >= '0' 
        && c <= '9';
}



function isHexDigit(c)
{
    return c.length == 1
        && (   c >= 'A' && c <= 'F'
            || c >= 'a' && c <= 'f');
}



function isArrowKey(code)
{
    return code == 'ArrowLeft'
        || code == 'ArrowRight'
        || code == 'ArrowUp'
        || code == 'ArrowDown';
}



function numToString(num, dec, showHex = false)
{
    if (showHex)
    {
        const _num = Number(num);
        let str = Math.round(Math.abs(_num)).toString(16);

        if (str.length % 2 > 0) str = '0' + str;
        if (_num < 0)           str = '-' + str;

        return str;
    }

    
    const _dec = Math.abs(dec);
    let    str = Number(num).toFixed(_dec).toString(showHex ? 16 : 10);
    

    let i = 0;

    // find decimal place

    while (i < str.length 
        && str[i] !== '.' 
        && str[i] !== ',')
        i++;

    if (i >= str.length) // if no decimal place
        return str;

        
    i = str.length-1;

    if (dec < 0)
    {
        while (i >= 0 && str[i] === '0')
            str = str.substring(0, i--);
        
         if (   str[i] === '.' 
             || str[i] === ',') // hack because JavaScript has shit support for locales
            str = str.substring(0, i--);
    }    

    return str;
}



// function numToString(num, dec)
// {
//     lst str = Number(num).toFixed(dec).toString();

//     let i = 0;

//     // find decimal place

//     while (   i < str.length 
//            && str[i] !== '.' 
//            && str[i] !== ',')
//         i++;

//     if (i >= str.length) // if no decimal place
//         return str;

//     i = str.length-1;

//     while (i >= 0 && str[i] === '0')
//         str = str.substring(0, i--);

//     if (str[i] === '.' || str[i] === ',') // hack because JavaScript has shit support for locales
//         str = str.substring(0, i--);

//     return str;
// }



function capitalize(str)
{
    let cap = "";

    if (str.length > 0)
        cap += str[0].toUpperCase();

    if (str.length > 1)
        cap += str.substring(1).toLowerCase();

    return cap;
}



function getQueryVariable(strVar)
{
    const query = window.location.search.substring(1);
    const vars  = query.split('&');

    for (let i = 0; i < vars.length; i++) 
    {
        let pair = vars[i].split('=');

        if (pair[0] == strVar)
            return pair[1];
    }

    return false;
}


const Tau = Math.PI * 2;
const phi = (Math.sqrt(5) - 1) / 2; // 0.618
const Phi = (Math.sqrt(5) + 1) / 2; // 1.618



function equal(a, b, eps = Epsilon)
{
    return Math.abs(b - a) < eps;
}



function floorTo(x, dec)
{
    const div = Math.round(Math.pow(10, dec));
    return Math.floor((x + Number.EPSILON) * div) / div;    
}



function roundTo(x, dec)
{
    const div = Math.round(Math.pow(10, dec));
    return Math.round((x + Number.EPSILON) * div) / div;    
}



function ceilTo(x, dec)
{
    const div = Math.ceil(Math.pow(10, dec));
    return Math.ceil((x + Number.EPSILON) * div) / div;    
}



function sqr (x) { return x*x;   };
function cube(x) { return x*x*x; };



function distance(p1, p2)
{
    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;

    return Math.sqrt(dx*dx + dy*dy);
}



function distance_(x1, y1, x2, y2)
{
    const dx = x2 - x1;
    const dy = y2 - y1;

    return Math.sqrt(dx*dx + dy*dy);
}



function vector(angle, dist)
{
    return point( 
        dist * Math.cos(angle), 
        dist * Math.sin(angle));
}



function equalv(v1, v2)
{
    return v1.x == v2.x
        && v1.y == v2.y;
}



function lengthv(v)
{
    return Math.sqrt(v.x*v.x + v.y*v.y);
}



function unitv(v)
{
    return point(
        v.x == 0 ? 0 : v.x / lengthv(v),
        v.y == 0 ? 0 : v.y / lengthv(v));
}



function addv(v1, v2)
{
    return point(
        v1.x + v2.x,
        v1.y + v2.y);
}	



function subv(v1, v2)
{
    return point(
        v1.x - v2.x,
        v1.y - v2.y);
}	



function mulv(v1, v2)
{
    return point(
        v1.x * v2.x,
        v1.y * v2.y);
}	



function mulvs(v, s)
{
    return point(
        v.x * s,
        v.y * s);
}	



function divvs(v, s)
{
    return point(
        v.x / s,
        v.y / s);
}	



function crossv(v)
{
    // returns a cross product of v and the unit vector pointing up the Z axis

    return point(v.y, -v.x);
}



function crossv2(v1, v2)
{
    // returns the magnitude of v1×v2 = ‖v1‖‖v2‖sinθ "perpendicular dot product",
    // equivalent to dot(v1, cross(v2)) (same as in 3D with a Z component of 0)
    // also the area of the parallelogram between the two vectors
    // also determinant of 2×2 matrix built from the two vectors
    // positive if turn from v1 to v2 is clockwise

    return (v1.x * v2.y 
          - v1.y * v2.x);
}	



function angle(v)
{
    let angle = Math.atan2(v.y, v.x);
    if (angle < 0) angle += Tau;

    return angle;
}



function anglev(v1, v2)
{
    return anglev_(v1.x, v1.y, v2.x, v2.y);
}



function anglev_(x1, y1, x2, y2)
{
    const dx = x2 - x1;
    const dy = y2 - y1;

    let angle = Math.atan2(dy, dx);
    if (angle < 0) angle += Tau;

    return angle;
}



function clipEdge(p, q, t0, t1)
{
    if (p == 0 && q < 0)
    {
        return null;
    }
    else if (p < 0)
    {
        let r = q/p;

             if (r > t1) return null;
        else if (r > t0) t0 = r;
    }
    else if (p > 0)
    {
        let r = q/p;

             if (r < t0) return null;
        else if (r < t1) t1 = r;
    }

    return [t0, t1];
}



function clipLine(x1, y1, x2, y2, left, top, right, bottom)
{
    let t0 = 0;
    let t1 = 1;

    let dx = x2 - x1;
    let dy = y2 - y1;

    let cl = clipEdge(-dx, -(left - x1), t0, t1); if (cl != null) { t0 = cl[0]; t1 = cl[1]; } else return null;
    let cr = clipEdge( dx, right - x1,   t0, t1); if (cr != null) { t0 = cr[0]; t1 = cr[1]; } else return null;
    let ct = clipEdge(-dy, -(top - y1),  t0, t1); if (ct != null) { t0 = ct[0]; t1 = ct[1]; } else return null;
    let cb = clipEdge( dy, bottom - y1,  t0, t1); if (cb != null) { t0 = cb[0]; t1 = cb[1]; } else return null;

    if (t1 < 1)
    {
        x2 = x1 + t1*dx;
        y2 = y1 + t1*dy;
    }

    if (t0 > 0)
    {
        x1 = x1 + t0*dx;
        y1 = y1 + t0*dy;
    }

    return [
        point(x1, y1), 
        point(x2, y2) ];
}



function intersect(p1, p2, q1, q2, segment)
{
    if (   equalv(p1, p2) 
        || equalv(q1, q2)) 
        return point_NaN; // undefined line

    let v1 = subv(p2, p1);
    let v2 = subv(q2, q1);

    if (crossv2(v1, v2) == 0) 
        return point_NaN; // parallel lines

    let t1 = crossv2(subv(q1, p1), v2) / crossv2(v1, v2);
    let t2 = crossv2(subv(q1, p1), v1) / crossv2(v1, v2);

    if ((  0 <= t1 && t1 <= 1
        && 0 <= t2 && t2 <= 1)
        || !segment)
        return addv(p1, mulvs(v1, t1));
        
    return point_NaN;
}



function closestPointOnLine(l0, l1, p, segment)
{
    if (equalv(p, l0))
        return l0;
        
    let d = mulvs(
        unitv(crossv(subv(l1, l0))), // perpendicular unit vector from p towards the line
        distance(p, l0));            // the distance to any of the two points guarantees intersection with the line

    return intersect(l0, l1, p, subv(p, d), segment);
}



function signedPosOnLine(p0, p1, p)
{
    let cp = closestPointOnLine(p0, p1, p, false);

    let xform = mulm3m3(
        xmove(negv(p0)),
        xrotate(-anglev(p0, p1)));
        
    p0 = transform(p0, xform);
    p1 = transform(p1, xform);
    cp = transform(cp, xform);

    return (cp.x - p0.x) / nozero(p1.x - p0.x);
}



function mulv3m3(v, m)
{
    let r = [0, 0, 0];

    for (let i = 0; i < 3; i++)
        for (let j = 0; j < 3; j++)
            r[i] += v[j] * m[i][j];

    return r;
}



function mulv2m3(v, m)
{
    let v3 = [v.x, v.y, 1];
    let r  = mulv3m3(v3, m);

    return point(r[0], r[1]);
}



function mulm3m3(m1, m2)
{
    const m = [[0, 0, 0],
               [0, 0, 0],
               [0, 0, 0]];

    for (let i = 0; i < 3; i++)
    {
        for (let j = 0; j < 3; j++)
        {
            /*	calculate the dot product of ith row 
                of this and jth column of m  */
            for (let k = 0; k < 3; k++)
                m[i][j] += m1[i][k] * m2[k][j];
        }
    }

    return m;
}



function divm3s(m, s)
{
    for (let i = 0; i < 3; i++)
        for (let j = 0; j < 3; j++)
            m[i][j] /= s;

    return m;
}



function cofactor(m)
{
    return [[  m[1][1] * m[2][2] - m[2][1] * m[1][2], -(m[1][0] * m[2][2] - m[2][0] * m[1][2]),  m[1][0] * m[2][1] - m[2][0] * m[1][1] ],
            [-(m[0][1] * m[2][2] - m[2][1] * m[0][2]),  m[0][0] * m[2][2] - m[2][0] * m[0][2], -(m[0][0] * m[2][1] - m[2][0] * m[0][1])],
            [  m[0][1] * m[1][2] - m[1][1] * m[0][2], -(m[0][0] * m[1][2] - m[1][0] * m[0][2]),  m[0][0] * m[1][1] - m[1][0] * m[0][1] ]]; 
}



function adjugate(m)
{
    return cofactor(transpose(m));
}



function determinant(m)
{
    return   m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1])
           - m[0][1] * (m[1][0] * m[2][2] - m[2][0] * m[1][2])
           + m[0][2] * (m[1][0] * m[2][1] - m[2][0] * m[1][1]);
}



function inverse(m)
{
    return divm3s(adjugate(m), determinant(m));
}



function transpose(m)
{
    return [[m[0][0], m[1][0], m[2][0]],
            [m[0][1], m[1][1], m[2][1]],
            [m[0][2], m[1][2], m[2][2]]];
}



function transform(p, xform)
{
    return mulv2m3(p, xform);
}



function xmove(v)
{
    return [[1, 0, v.x],
            [0, 1, v.y],
            [0, 0, 1  ]];
}



function xrotate(angle)
{
    return [[Math.cos(angle), -Math.sin(angle), 0],
            [Math.sin(angle),  Math.cos(angle), 0],
            [0,                0,               1]];
}



// function ipow(n, e)
// {
//     let res = 1;

//     for (;;)
//     {
//         if (e & 1 != 0)
//             res *= n;

//         e >>= 1;

//         if (e == 0)
//             break;

//         n *= n;
//     }

//     return res;
// }



const MaxDigits = 100000;
 
function multRes(x, res, resSize)
{
    let carry = 0n;
    
    // multiply individual digits of res[] by n
    for (let i = 0; i < resSize; i++) 
    {
        const prod = res[i] * x + carry;
    
        res[i] = prod % 10n; // store last digit of prod in res[]
        carry  = prod / 10n; // put rest in carry
    }
    
    // put carry in res and
    // increase result size
    while (carry)
    {
        res[resSize] = carry % 10n;
        carry        = carry / 10n;
        resSize++;
    }

    return resSize;
}



function randomPrime(max = Number.MAX_SAFE_INTEGER/2)
{
    const num = Math.floor(Math.random() * max);
    return nextPrime(num);
}



function nextPrime(x) 
{
    while (!isPrime(++x));
    return x;
}



function isPrime(n, k = millerRabinIterations) // Miller-Rabin
{
    if (n <= 1) return false; 
    if (n <= 3) return true; // prime
    
    if (n % 2 == 0) 
        return false; // composite
    
    
    let d = n - 1;     // find d      
    while (d % 2 == 0) // so that x = 2^d * r + 1 
        d /= 2;        // for r >= 1
    
    
    for (let i = 0; i < k; i++)    
        if (!millerTest(d, n))
            return false; // composite
    
    
    return true; // maybe prime        
}    



function millerTest(d, n)
{
    return bigMillerTest(
        BigInt(d),
        BigInt(n));
}        



function uintFromBuffer(buffer, size)
{
    return uintFromBufferAt(buffer, 0, size);
}



function uintFromBufferAt(buffer, start, size)
{
    let val = 0;
    let mul = 1;

    for (let i = start+size-1; i >= start; i--) // little-endian
    {
        val += mul * buffer[i];
        mul <<= 8;
    }

    return val;
}



function uintToBuffer(val, buffer, bufferSize)
{
    uintToBufferAt(val, buffer, 0, bufferSize);
}



function uintToBufferAt(val, buffer, start, bufferSize)
{
    let size = Math.ceil(bigBitCount(val) / 8);
    
    size = Math.min(size, buffer.length - start);

    start += bufferSize - size;

    for (let i = start+size-1; i >= start; i--) // little-endian
    {
        buffer[i] = val & 0xFF; 
        val >>= 8;
    }
}



function lerp(a, b, t)
{
    return a + (b - a) * t;
}



function lerp3(f0, f1, f2, f3, t)
{
    const c0  = lerp(f0, f1, t);
    const c1  = lerp(f1, f2, t);
    const c2  = lerp(f2, f3, t);

    const c01 = lerp(c0, c1, t);
    const c12 = lerp(c1, c2, t);

    return lerp(c01, c12, t);
}



function normalAngle(angle)
{
    while (angle <  0  ) angle += Tau;
    while (angle >= Tau) angle -= Tau;

    return angle; // [0, Tau|
}



function angleDiff(a1, a2)
{
    let diff = a2 - a1;

    while (diff <= -Tau/2) diff += Tau;
    while (diff >   Tau/2) diff -= Tau;

    return diff; // |-Tau/2, Tau/2]
}


const point_NaN = point(Number.NaN, Number.NaN);



function point(x, y) { return {x: x, y: y}; }

function pointIsNaN(p) { return isNaN(p.x) || isNaN(p.y); }



function unit(v)
{
    return v.X != 0 
        || v.Y != 0
        ? mulvs(v, 1 / lengthv(v))
        : point(0, 0);
}



function lerpv(p0, p1, t)
{
    return point(
        lerp(p0.x, p1.x, t),
        lerp(p0.y, p1.y, t));
}



function lerpv3(p0, p1, p2, p3, t)
{
    return point(
        lerp3(p0.x, p1.x, p2.x, p3.x, t),
        lerp3(p0.y, p1.y, p2.y, p3.y, t));
}



function clipEdge(p, q, t0, t1)
{
    if (p == 0 && q < 0)
    {
        return null;
    }
    else if (p < 0)
    {
        const r = q/p;

             if (r > t1) return null;
        else if (r > t0) t0 = r;
    }
    else if (p > 0)
    {
        const r = q/p;

             if (r < t0) return null;
        else if (r < t1) t1 = r;
    }

    return [t0, t1];
}



function clipLine(x1, y1, x2, y2, left, top, right, bottom)
{
    const t0 = 0;
    const t1 = 1;

    const dx = x2 - x1;
    const dy = y2 - y1;

    const cl = clipEdge(-dx, -(left - x1), t0, t1); if (cl != null) { t0 = cl[0]; t1 = cl[1]; } else return null;
    const cr = clipEdge( dx,  right - x1,  t0, t1); if (cr != null) { t0 = cr[0]; t1 = cr[1]; } else return null;
    const ct = clipEdge(-dy,  -(top - y1), t0, t1); if (ct != null) { t0 = ct[0]; t1 = ct[1]; } else return null;
    const cb = clipEdge( dy,  bottom - y1, t0, t1); if (cb != null) { t0 = cb[0]; t1 = cb[1]; } else return null;

    if (t1 < 1)
    {
        x2 = x1 + t1*dx;
        y2 = y1 + t1*dy;
    }

    if (t0 > 0)
    {
        x1 = x1 + t0*dx;
        y1 = y1 + t0*dy;
    }

    return [
        point(x1, y1), 
        point(x2, y2) ];
}



function intersectLines(p1, p2, q1, q2, segment)
{
    if (   equalv(p1, p2) 
        || equalv(q1, q2)) 
        return point_NaN; // undefined line

    const v1 = subv(p2, p1);
    const v2 = subv(q2, q1);

    if (crossv2(v1, v2) == 0) 
        return point_NaN; // parallel lines

    const t1 = crossv2(subv(q1, p1), v2) / crossv2(v1, v2);
    const t2 = crossv2(subv(q1, p1), v1) / crossv2(v1, v2);

    if ((  0 <= t1 && t1 <= 1
        && 0 <= t2 && t2 <= 1)
        || !segment)
        return addv(p1, mulvs(v1, t1));
        
    return point_NaN;
}



function closestPointOnLine(l0, l1, p, segment)
{
    if (equalv(p, l0))
        return l0;
        
    const d = mulvs(
        unitv(crossv(subv(l1, l0))), // perpendicular unit vector from p towards the line
        distance(p, l0));            // the distance to any of the two points guarantees intersection with the line

    return intersectLines(l0, l1, p, subv(p, d), segment);
}



function signedPosOnLine(p0, p1, p)
{
    let cp = closestPointOnLine(p0, p1, p, false);

    const xform = mulm3m3(
        xmove(-p0),
        xrotate(-anglev(p0, p1)));

    p0 = transform(p0, xform);
    p1 = transform(p1, xform);
    cp = transform(cp, xform);

    return (cp.X - p0.X) / nozero(p1.X - p0.X);
}



function rectsIntersect(rect1, rect2)
{
    return !(
           rect1.l >= rect2.r
        || rect1.r <= rect2.l
        || rect1.t >= rect2.b
        || rect1.b <= rect2.t); 
}



function clipRect(rect, clip)
{
    if (!rectsIntersect(rect, clip))
        return Rect.NaN;

    return new AbsRect(
        Math.max(rect.l, clip.l),
        Math.max(rect.t, clip.t),
        Math.min(rect.r, clip.r),
        Math.min(rect.b, clip.b));
}



function validateRect(rect)
{
    return new Rect(
        rect.x + Math.min(rect.w, 0),
        rect.y + Math.min(rect.h, 0),
        Math.abs(rect.w),
        Math.abs(rect.h));
}



function validateRect_(x, y, w, h)
{
    return [
        x + Math.min(w, 0),
        y + Math.min(h, 0),
        Math.abs(w),
        Math.abs(h) ];
}



function transform(p, xform)
{
    return mulv2m3(p, xform);
}



function xmove(v)
{
    return [[1, 0, v.x],
            [0, 1, v.y],
            [0, 0, 1  ]];
}



function xrotate(angle)
{
    return [[Math.cos(angle), -Math.sin(angle), 0],
            [Math.sin(angle),  Math.cos(angle), 0],
            [0,                0,               1]];
}



function offsetRect(elem)
{
    return new Rect(
        elem.offsetLeft,
        elem.offsetTop,
        elem.offsetWidth,
        elem.offsetHeight);
}



function boundingRect(elem)
{
    const bounds = elem.getBoundingClientRect();

    return new Rect(
        bounds.x,
        bounds.y,
        bounds.width,
        bounds.height);
}


function bezierTangent(x0, y0, x1, y1, x2, y2, x3, y3, t)
{
    const p0 = point(x0, y0);
    const p1 = point(x1, y1);
    const p2 = point(x2, y2);
    const p3 = point(x3, y3);

    return unit(addv(addv(
        mulvs(subv(p1, p0), 3*sqr(1-t)),
        mulvs(subv(p2, p1), 6*(1-t)*t)),
        mulvs(subv(p3, p2), 3*sqr(t))));
}



function positionOnSegment(p0, p1, p2, p3, arcLen, error = 0.001)
{
    const hullLength = 
          distance(p0, p1) 
        + distance(p1, p2)
        + distance(p2, p3);

    if (hullLength == 0)
        return Number.NAN;


    let t = arcLen / hullLength;

    if (t < 0 || t > 1)
        return Number.NAN;

        
    let halves = splitSeg(p0, p1, p2, p3, t);
    let l      = halves[0];

    let length = arcLength(l[0], l[1], l[2], l[3], error);


    let loopProtect = 1000;

    while (Math.abs(arcLen - length) > error
        && loopProtect-- > 0)
    {
        t += (arcLen - length) / hullLength;

        halves = splitSeg(p0, p1, p2, p3, t);
        l      = halves[0];

        length = arcLength(l[0], l[1], l[2], l[3], error);
    }

    if (loopProtect == 0)
        console.log('endless loop in positionOnSegment()');


    return t;
}



function splitSeg(p0, p1, p2, p3, t)
{
    const c0   = lerpv(p0, p1, t);
    const c1   = lerpv(p1, p2, t);
    const c2   = lerpv(p2, p3, t);
                
    const c01  = lerpv(c0, c1, t);
    const c12  = lerpv(c1, c2, t);

    const c012 = lerpv(c01, c12, t);

    return [
        [p0, c0, c01, c012],
        [c012, c12, c2, p3] ];
}



// function splitSegments(_p0, _p1, _p2, _p3, ts)
// {
//     const segments = [];


//     let p0 = _p0, 
//         p1 = _p1,
//         p2 = _p2,
//         p3 = _p3;

//     for (let i = 0; i < ts.length; i++)
//     {
//         const parts = split(p0, p1, p2, p3, ts[i]);
//         const l     = parts[0];
//         const r     = parts[1];


//         segments.push(l);


//         if (i < ts.length-1)
//         {
//             p0 = r[0];
//             p1 = r[1];
//             p2 = r[2];
//             p3 = r[3];

//             for (let j = i+1; j < ts.length; j++)
//                 ts[j] = 1 - (1 - ts[j]) / (1 - ts[i]);
//         }
//         else segments.push(r);
//     }


//     return segments;
// }



function arcLength(p0, p1, p2, p3, error = 0.0000001)
{
    const arcLen = 
          distance(p0, p1)
        + distance(p1, p2)
        + distance(p2, p3);

    const chord = distance(p0, p3);

    if ((arcLen - chord) > error)
    {
        const halves = splitSeg(p0, p1, p2, p3, 0.5);
        const l      = halves[0];
        const r      = halves[1];
            
        return arcLength(l[0], l[1], l[2], l[3], error)
             + arcLength(r[0], r[1], r[2], r[3], error);
    }

    return arcLen;
}


var bigBuffer = new Uint8Array(2048);



function bigRandom(max = 0)
{
    const size = 
        max > 0
        ? Math.max(1, Math.floor(bigBitCount(max)/8))
        : bigBuffer.length;
    
    if (size > bigBuffer.length)
        bigBuffer = new Uint8Array(nextPow2(size));
        
    for (let i = 0; i < size; i++)
        bigBuffer[i] = toInt(Math.random() * 0x100);

    let rnd = bigFromBufferAt(bigBuffer, 0, size);

    if (max > 0)
        rnd = rnd % max;
        
    return rnd;
}



function bigPowMod(n, e, m) // n^e % mod
{
    let c = 1n;

    while (e > 0n)
    {
        if ((e & 1n) != 0n)
        {
            c *= n;
            c %= m;
        }

        e  >>= 1n;
        
        n *= n;
        n %= m;
    }
    
    return c;
}



function bigNextPrime(n) 
{
    while (!bigIsPrime(++n));
    return n;
}



function bigIsPrime(x, k = millerRabinIterations) // Miller-Rabin
{
    if (x <= 1n) return false; 
    if (x <= 3n) return true;
    
    if (x % 2n == 0n) 
        return false;
        
        
    let d = x - 1n;
    let s = 0n; 
                
    while (d % 2n == 0n) 
    {
        d /= 2n;         
        s++;
    }
        

    for (let i = 0; i < k; i++)    
    {
        const a = 2n + bigRandom(x - 1n);//bigMult(n - 3n, Math.random()); // -3 = -4 + 1 because random() doesn't include 1.0

        if (!bigIsWitness(a, s, d, x))
            return false;        
    }
        

    return true; 
}    

    

function bigIsWitness(a, s, d, n)
{
    let x = bigPowMod(a, d, n);
        
    if (x == 1n)
        return true;

    for (let j = 0n; j < s-1n; j++)
    {
        if (x == n-1n)
            return true;
        
        x = bigPowMod(x, 2n, n);
    }

    return x == n-1n;
}



function bigFromBuffer(buffer)
{
    return bigFromBufferAt(buffer, 0, buffer.length);
}



function bigFromBufferAt(buffer, start, size)
{
    size = Math.min(size, buffer.length - start);
    
    let val = 0n;
    let mul = 1n;

    for (let i = start+size-1; i >= start; i--) // little-endian
    {
        val += mul * BigInt(buffer[i]);
        mul <<= 8n;
    }

    return val;
}



function bigToBuffer(n, buffer, bufferSize)
{
    bigToBufferAt(n, buffer, 0, bufferSize);
}



function bigToBufferAt(n, buffer, start, bufferSize)
{
    let size = Math.ceil(bigBitCount(n) / 8);
    
    size = Math.min(size, buffer.length - start);

    start += bufferSize - size;

    for (let i = start+size-1; i >= start; i--) // little-endian
    {
        buffer[i] = Number(n & 0xFFn); 
        n >>= 8n;
    }
}



function bigBitCount(n)
{
    return n.toString(2).length;
}



function bigModInvert(n, m)
{
    const gcd = bigGcdExtended(n, m);

    if (gcd[0] != 1n) return undefined; // inverse doesn't exist
    else              return (gcd[1] % m + m) % m;
}



function bigGcdExtended(n, m)
{
    if (n == 0n)
        return [m, 0n, 1n];

    const gcd = bigGcdExtended(m % n, n);

    const x   = gcd[1];
    const y   = gcd[2];

    return [
        gcd[0], 
        y - (m/n)*x,
        x ];
}


class Point
{
    x;
    y;

    constructor(x, y)
    {
        this.x = x;
        this.y = y;
    }
}


class Rect
{
    x;
    y;
    w;
    h;


    get l()            { return this.x;            }
    get c()            { return this.x + this.w/2; }
    get r()            { return this.x + this.w;   }
           
    get t()            { return this.y;            }
    get m()            { return this.y + this.h/2  }
    get b()            { return this.y + this.h;   }
          
    get tl()           { return point(this.l, this.t); }
    get tc()           { return point(this.c, this.t); }
    get tr()           { return point(this.r, this.t); }
    get ml()           { return point(this.l, this.m); }
    get mc()           { return point(this.c, this.m); }
    get cm()           { return point(this.c, this.m); }
    get mr()           { return point(this.r, this.m); }
    get bl()           { return point(this.l, this.b); }
    get bc()           { return point(this.c, this.b); }
    get br()           { return point(this.r, this.b); }
      
      
    get width()        { return this.w; }
    get height()       { return this.h; }
      
    get left()         { return this.l; }
    get center()       { return this.c; }
    get right()        { return this.r; }
          
    get top()          { return this.t; }
    get middle()       { return this.m; }
    get bottom()       { return this.b; }

    get topLeft()      { return this.tl; }
    get topCenter()    { return this.tc; }
    get topRight()     { return this.tr; }
    get middleLeft()   { return this.ml; }
    get middleCenter() { return this.mc; }
    get centerMiddle() { return this.cm; }
    get middleRight()  { return this.mr; }
    get bottomLeft()   { return this.bl; }
    get bottomCenter() { return this.bc; }
    get bottomRight()  { return this.br; }



    constructor(x, y, w, h)
    {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
    }



    static fromTypical(typ)
    {
        return new Rect(typ.x, typ.y, typ.width, typ.height); 
    }



    // w & h are kept 0 so that isEmpty() works logically on NaN rects
    static get NaN() { return new Rect(Number.NaN, Number.NaN, 0, 0) };
    static get Zero() { return new Rect(0, 0, 0, 0); }



    get isNaN()
    {
        return isNaN(this.x)
            || isNaN(this.y)
            || isNaN(this.w)
            || isNaN(this.h);
    }



	get isEmpty()
	{
		return (this.w == 0
			 || this.h == 0);
	}



    assign(rect)
    {
        this.x = rect.x;
        this.y = rect.y;
        this.w = rect.w;
        this.h = rect.h;
    }
}


class   AbsRect
extends Rect
{
    constructor(l, t, r, b)
    {
        super(l, t, r-l, b-t);
    }
}



function expandRect(rect1, rect2)
{
    if (rect1.isNaN  ) return rect2;
    if (rect1.isEmpty) return rect2;

    if (rect2.isNaN  ) return rect1;
    if (rect2.isEmpty) return rect1;
    
    return new AbsRect(
        Math.min(rect2.l, rect1.l),
        Math.min(rect2.t, rect1.t),
        Math.max(rect2.r, rect1.r),
        Math.max(rect2.b, rect1.b));
}



class Random
{
    seed;
    last;



    constructor(seed = 0, last = seed)//(seed = 0xb9ef7ca4, last = seed)
    { 
        this.seed = seed; 
        this.last = last;
    }



    copy()
    {
        return new Random(this.seed, this.last);
    }



    next()
    {
        this.last = this.seed;
        
        this.seed = (this.seed + 0x7ed55d16) + (this.seed << 12);
        this.seed = (this.seed ^ 0xc761c23c) ^ (this.seed >> 19);
        this.seed = (this.seed + 0x165667b1) + (this.seed <<  5);
        this.seed = (this.seed + 0xd3a2646c) ^ (this.seed <<  9);
        this.seed = (this.seed + 0xfd7046c5) + (this.seed <<  3);
        this.seed = (this.seed ^ 0xb55a4f09) ^ (this.seed >> 16);

        return this.seed / -0x7fffffff;
    }

}


const isMac = navigator.platform.toLowerCase().indexOf('mac') >= 0;



var utilCanvas;
var utilContext;
    


function initUtilContext()
{
    utilCanvas  = document.createElement('canvas');
    utilContext = utilCanvas.getContext('2d');
}



function indexOfChild(parent, child)
{
    return Array.prototype.indexOf.call(parent.children, child);
}



function pluralString(count, pluralChar = 's')
{
    return count == 1 ? '' : pluralChar;
}



function countString(itemName, count)
{
    const lastChar   = lastOf(itemName);
    const pluralChar = lastChar == lastChar.toUpperCase() ? 'S' : 's';

    return itemName + pluralString(count, pluralChar);
}



function decCount(strValue)
{
    const dotIndex   = strValue.indexOf('.');//getUserDecimalSeparator());
    const commaIndex = strValue.indexOf(',');//getUserDecimalSeparator());

    return dotIndex >= 0
         ? strValue.length-1 - dotIndex
         : (commaIndex >= 0
            ? strValue.length-1 - commaIndex
            : 0);
}



function getUserDecimalSeparator()
{
    const num = 1.1;

    return num
        .toLocaleString(navigator.language)
        .substring(1, 2);
}



function isEmptyObject(obj)
{
    if (obj == null)
        return false;
        
    return (
           Object.keys(obj).length === 0 
        && obj.constructor === Object);
}



function shallowCopy(obj)
{
    return Object.assign(Object.create(Object.getPrototypeOf(obj)), obj);
}



function deepCopy(obj)
{
    return JSON.parse(JSON.stringify(obj));
}



function clone(val) 
{
    const type = typeof val;
    
    if (val === null) 
      return null;

    else if (type === 'undefined' 
          || type === 'number' 
          || type === 'string' 
          || type === 'boolean') 
        return val;

    else if (type === 'object') 
    {
        if (val instanceof Array) 
            return val.map(x => clone(x));

        else if (val instanceof Uint8Array) 
            return new Uint8Array(val);

        else 
        {
            let obj = {};

            for (const key in val) 
                obj[key] = clone(val[key]);

            return obj;
        }
    }

    throw 'unknown';
}



function filterUnique(array)
{
    return array.filter((value, index) => 
        array.indexOf(value) === index);
}



function createSvg(element)
{
    const svg = document.createElementNS('http://www.w3.org/2000/svg', element);
    svg.style.pointerEvents = 'none';
    return svg;
}



function isVisible(element)
{ 
    return element.style.visibility == 'visible'; 
}



function isLastInArray(array, item)
{
    return array.indexOf(item) == array.length-1;
}



function pushUnique(array, item)
{
    if (Array.isArray(item))
        item.forEach(i => pushUnique(array, i));
    else if (!array.includes(item))
        array.push(item);
}



function pushUniqueExcept(array, item, except)
{
    if (Array.isArray(item))
        item.forEach(i => pushUniqueExcept(array, i, except));
    else if (!array.find(except))
        array.push(item);
}



function clearChildren(parent) 
{
    while (parent.firstChild)
        parent.removeChild(parent.firstChild);
}



function replaceInStringAt(str, index, replace)
{
    return str.substring(0, index) 
         + replace 
         + str.substring(index + replace.length);
}



function strFromData(data)
{
    let str = '';

    for (let i = 0; i < data.length; i++)
        str += String.fromCharCode(data[si]);

    return str;
}



function clearConsole()
{
    setTimeout(console.clear.bind(console));
}



function log(...params)
{
    setTimeout(console.log.bind(console, ...params)); // doesn't show log source, which makes logs cleaner
}



function logTrace()
{
    setTimeout(console.trace.bind(console));
}



function printNum(num)
{
    return !isNaN(num) ? num : NAN_CHAR;
}



function parseNum(str)
{
    return str == NAN_CHAR
         ? Number.NaN 
         : parseFloat(str);
}



function isTrue(strBool)
{
    return strBool == 'true';
}



function strIsNum(str) 
{
    if (typeof str != 'string') 
        return false; // only process strings

    if (str == 'NaN') // explicitly support NaN
        return true;

    return !isNaN(str) // use type coercion to parse the whole string
        && !isNaN(parseFloat(str)); // ensure strings of whitespace fail
}



function reflow(elem)
{
    void(elem.offsetHeight);
}


function readonly(target, name, descriptor)
{
    descriptor.writable = false;
    return descriptor;
}



function osCtrl()  { return isMac ? '⌘' : 'Ctrl+';  }
function osAlt()   { return isMac ? '⌥' : 'Alt+';   }
function osShift() { return isMac ? '⇧'  : 'Shift+'; }



function isMultiplier(node)
{
    return node instanceof OpRepeat;
}



function getCreateNodeAction(type, creatingButton, options)
{
    return !!options.insert
           ? new CreateInsertNodeAction(type, creatingButton, options)
           : new CreateNodeAction      (type, creatingButton, options, settings.autoConnectNewNodes);
}



function isPanning(e)
{
    if (panMode)
    {
        e.preventDefault();
        setCursor(panCursor);
        return true;
    }

    if (graphView.spaceDown)
    {
        e.preventDefault();
        return true;
    }

    return false;
}



function point2screen(p)
{
    return point(
        (p.x + graphView.pan.x / graphView.zoom) * graphView.zoom,
        (p.y + graphView.pan.y / graphView.zoom) * graphView.zoom);
}



function screen2point(p)
{
    return point(
        p.x / graphView.zoom - graphView.pan.x / graphView.zoom,
        p.y / graphView.zoom - graphView.pan.y / graphView.zoom);
}



function rect2screen(rect)
{
    return new Rect(
        (rect.x + graphView.pan.x / graphView.zoom) * graphView.zoom,
        (rect.y + graphView.pan.y / graphView.zoom) * graphView.zoom,
        rect.width  * graphView.zoom,
        rect.height * graphView.zoom);
}



function screen2rect(rect)
{
    return new Rect(
        rect.x / graphView.zoom - graphView.pan.x / graphView.zoom,
        rect.y / graphView.zoom - graphView.pan.y / graphView.zoom,
        rect.width  / graphView.zoom,
        rect.height / graphView.zoom);
}


"use strict";

// Base64 / binary data / UTF-8 strings utilities
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding


// byte array to Base64 string decoding

function base64toUint6(c) 
{
    return    c > 64 
           && c < 91 
           ? c - 65 
           :    c > 96 
             && c < 123 
             ? c - 71
             :    c > 47 
               && c < 58 
               ? c + 4
               : c === 43 
                 ? 62
                 : c === 47 ? 63 : 0;
}



function base64toArray(str, blocksSize) 
{
    const base64 = str.replace(/[^A-Za-z0-9\+\/]/g, "");
    const inLen  = base64.length;

    const outLen = 
        blocksSize 
        ? Math.ceil((inLen * 3 + 1 >> 2) / blocksSize) * blocksSize 
        : inLen * 3 + 1 >> 2;
        
    const bytes = new Uint8Array(outLen);

    for (let mod3, 
             mod4, 
             uint24 = 0, 
             out    = 0, 
        i = 0; 
        i < inLen; 
        i++) 
    {
        mod4 = i & 3;
        uint24 |= base64toUint6(base64.charCodeAt(i)) << 6 * (3 - mod4);

        if (   mod4 === 3 
            || inLen - i === 1) 
        {
            for (mod3 = 0; mod3 < 3 && out < outLen; mod3++, out++) 
                bytes[out] = uint24 >>> (16 >>> mod3 & 24) & 255;

            uint24 = 0;
        }
    }

    return bytes;
}



// Base64 string to array encoding

function uint6toBase64(i) 
{
    return i < 26 
           ? i + 65
           : i < 52 
             ? i + 71
             : i < 62 
               ? i - 4
               : i === 62 
                 ? 43
                 : i === 63 ? 47 : 65;
}



function arrayToBase64(bytes)
{
    let mod3   = 2, 
        base64 = "";

    const length = bytes.length;

    for (let i = 0, uint24 = 0; i < length; i++) 
    {
        mod3 = i % 3;

        if (i > 0 && (i * 4 / 3) % 76 === 0) 
            base64 += "\r\n";

        uint24 |= bytes[i] << (16 >>> mod3 & 24);

        if (   mod3 === 2 
            || bytes.length - i === 1) 
        {
            base64 += String.fromCharCode(
                uint6toBase64(uint24 >>> 18 & 0x3F), 
                uint6toBase64(uint24 >>> 12 & 0x3F), 
                uint6toBase64(uint24 >>>  6 & 0x3F), 
                uint6toBase64(uint24        & 0x3F));
                
            uint24 = 0;
        }
    }

    return base64.substr(0, base64.length - 2 + mod3) + (mod3 === 2 ? '' : mod3 === 1 ? '=' : '==');
}



// UTF-8 array to DOMString and vice versa

function UTF8ArrToStr(bytes) 
{
    let   str    = "";

    const length = bytes.length;

    for (let i = 0; i < length; i++) 
    {
        const byte = bytes[i];

        str += String.fromCharCode(
               byte > 251 
            && byte < 254 
            && i + 5 < length // six bytes
            ? (byte - 252) * 1073741824 + (bytes[++i] - 128 << 24) + (bytes[++i] - 128 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
            :    byte > 247 
              && byte < 252 
              && i + 4 < length // five bytes
              ? (byte - 248 << 24) + (bytes[++i] - 128 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
              :    byte > 239 
                && byte < 248 
                && i + 3 < length // four bytes
                ? (byte - 240 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
                :    byte > 223 
                  && byte < 240 
                  && i + 2 < length // three bytes
                  ? (byte - 224 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
                  :    byte > 191 
                    && byte < 224 
                    && i + 1 < length // two bytes
                    ? (byte - 192 << 6) + bytes[++i] - 128 /* nPart < 127 ? */ // one byte
                    : byte);
    }

    return str;
}



function strToUTF8Arr(str) 
{
    let strLen = str.length, 
        arrLen = 0;


    // mapping

    for (let i = 0; i < strLen; i++) 
    {
        chr = str.charCodeAt(i);
        arrLen += chr < 0x80 ? 1 : chr < 0x800 ? 2 : chr < 0x10000 ? 3 : chr < 0x200000 ? 4 : chr < 0x4000000 ? 5 : 6;
    }

    const bytes = new Uint8Array(arrLen);


    // transcription

    for (let i = 0, iChr = 0; i < arrLen; iChr++) 
    {
        const chr = str.charCodeAt(iChr);
     
        if (chr < 0x80) // one byte
        {
            bytes[i++] = chr;
        } 
        else if (chr < 0x800) // two bytes
        {
            bytes[i++] = 192 + (chr >>> 6);
            bytes[i++] = 128 + (chr        & 0x3F);
        } 
        else if (chr < 0x10000) // three bytes
        {
            bytes[i++] = 224 + (chr >>> 12);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        }
        else if (chr < 0x200000) // four bytes
        {
            bytes[i++] = 240 + (chr >>> 18);
            bytes[i++] = 128 + (chr >>> 12 & 0x3F);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        } 
        else if (chr < 0x4000000) // five bytes
        {
            bytes[i++] = 248 + (chr >>> 24);
            bytes[i++] = 128 + (chr >>> 18 & 0x3F);
            bytes[i++] = 128 + (chr >>> 12 & 0x3F);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        } 
        else //if (nChr <= 0x7fffffff) // six bytes
        {
            bytes[i++] = 252 + (chr >>> 30);
            bytes[i++] = 128 + (chr >>> 24 & 0x3F);
            bytes[i++] = 128 + (chr >>> 18 & 0x3F);
            bytes[i++] = 128 + (chr >>> 12 & 0x3F);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        }
    }


    return bytes;
}


function position(e)
{
    return point(e.clientX, e.clientY);
}



function getStyleValue(obj, style)
{
    return window.getComputedStyle(obj).getPropertyValue(style);
}



function getCtrlKey(e)
{
    return  isMac && e.metaKey
        || !isMac && e.ctrlKey;
}



function dispatchNewEvent(target, proto)
{
    target.dispatchEvent(new proto.constructor(proto.type, proto));
}



function createDiv(className = '', id = '')
{
    const div = document.createElement('div');
    
    if (className != '')
        div.className = className;
    
    if (id != '')
        div.id = id;

    return div;
}



function appendDivTo(div, to)
{
    if (!to.contains(div))
        to.appendChild(div);
}



function removeDivFrom(div, from)
{
    if (from.contains(div))
        from.removeChild(div);
}



function createTextbox(className = '')
{
    const textbox = document.createElement('INPUT');
    textbox.setAttribute('type', 'text'); 

    if (className.trim() != '')
        textbox.className = className;
    
    return textbox;
}



function enableElementText(elem, enable)
{
    elem.style.fontStyle  = enable ? 'normal' : 'italic'; 
    elem.style.fontWeight = enable ? 'normal' : 'bold';
}



function hasFocus(elem)
{
    return elem == document.activeElement;
}



function setStyle(id, properties)
{
    const elem = document.getElementById(id);

    for (const property of properties)
        elem.style[property] = properties[property];
}



function containsChild(parent, child)
{
    return child.parentNode == parent;
}



function forwardEvent(event, element)
{
    const e = new event.constructor(event.type, event);
    element.dispatchEvent(e);
}



function offsetRect(element)
{
    return new Rect(
        element.offsetLeft,
        element.offsetTop,
        element.offsetWidth,
        element.offsetHeight);
}



function clientRect(element)
{
    return new Rect(
        element.clientLeft,
        element.clientTop,
        element.clientWidth,
        element.clientHeight);
}



// function triggerMouseEvent(element, event, px, py, button = 0)
// {
//     const e = new MouseEvent(event, 
//     {
//         clientX: px,
//         clientY: py,
//         button:  button
//     });
//
//     element.dispatchEvent(e);
// }



function selectElementText(elementId)
{
    if (document.selection) // IE
    {
        var range = document.body.createTextRange();
        range.moveToElementText(document.getElementById(elementId));
        range.select();
    }
    else if (window.getSelection) 
    {
        var range = document.createRange();
        range.selectNode(document.getElementById(elementId));
        window.getSelection().removeAllRanges();
        window.getSelection().addRange(range);
    }
}



function isTouchpad(e)
{
    return Math.abs(e.deltaX) < 100
        && Math.abs(e.deltaY) < 100;
}



function showElement(element, show = true) 
{
    const showStyle = 'block';
    const hideStyle = 'none';

    if (  !show
        && element.style.display != hideStyle)
        element.oldDisplay = element.style.display;

    element.style.display = 
        show 
        ? (   element.style.oldDisplay 
           && element.style.oldDisplay != hideStyle
           ? element.style.oldDsplay
           : showStyle)
        : hideStyle; 
}


function hideElement(element)              
{ 
    showElement(element, false); 
}


const webColors = [
    {name: 'AliceBlue',            color: 'f0f8ff'},
    {name: 'AntiqueWhite',         color: 'faebd7'},
    {name: 'Aqua',                 color: '00ffff'},
    {name: 'Aquamarine',           color: '7fffd4'},
    {name: 'Azure',                color: 'f0ffff'},
    {name: 'Beige',                color: 'f5f5dc'},
    {name: 'Bisque',               color: 'ffe4c4'},
    {name: 'Black',                color: '000000'},
    {name: 'BlanchedAlmond',       color: 'ffebcd'},
    {name: 'Blue',                 color: '0000ff'},
    {name: 'BlueViolet',           color: '8a2be2'},
    {name: 'Brown',                color: 'a52a2a'},
    {name: 'BurlyWood',            color: 'deb887'},
    {name: 'CadetBlue',            color: '5f9ea0'},
    {name: 'Chartreuse',           color: '7fff00'},
    {name: 'Chocolate',            color: 'd2691e'},
    {name: 'Coral',                color: 'ff7f50'},
    {name: 'CornflowerBlue',       color: '6495ed'},
    {name: 'Cornsilk',             color: 'fff8dc'},
    {name: 'Crimson',              color: 'dc143c'},
    {name: 'Cyan',                 color: '00ffff'},
    {name: 'DarkBlue',             color: '00008b'},
    {name: 'DarkCyan',             color: '008b8b'},
    {name: 'DarkGoldenRod',        color: 'b8860b'},
    {name: 'DarkGray',             color: 'a9a9a9'},
    {name: 'DarkGrey',             color: 'a9a9a9'},
    {name: 'DarkGreen',            color: '006400'},
    {name: 'DarkKhaki',            color: 'bdb76b'},
    {name: 'DarkMagenta',          color: '8b008b'},
    {name: 'DarkOliveGreen',       color: '556b2f'},
    {name: 'DarkOrange',           color: 'ff8c00'},
    {name: 'DarkOrchid',           color: '9932cc'},
    {name: 'DarkRed',              color: '8b0000'},
    {name: 'DarkSalmon',           color: 'e9967a'},
    {name: 'DarkSeaGreen',         color: '8fbc8f'},
    {name: 'DarkSlateBlue',        color: '483d8b'},
    {name: 'DarkSlateGray',        color: '2f4f4f'},
    {name: 'DarkSlateGrey',        color: '2f4f4f'},
    {name: 'DarkTurquoise',        color: '00ced1'},
    {name: 'DarkViolet',           color: '9400d3'},
    {name: 'DeepPink',             color: 'ff1493'},
    {name: 'DeepSkyBlue',          color: '00bfff'},
    {name: 'DimGray',              color: '696969'},
    {name: 'DimGrey',              color: '696969'},
    {name: 'DodgerBlue',           color: '1e90ff'},
    {name: 'FireBrick',            color: 'b22222'},
    {name: 'FloralWhite',          color: 'fffaf0'},
    {name: 'ForestGreen',          color: '228b22'},
    {name: 'Fuchsia',              color: 'ff00ff'},
    {name: 'Gainsboro',            color: 'dcdcdc'},
    {name: 'GhostWhite',           color: 'f8f8ff'},
    {name: 'Gold',                 color: 'ffd700'},
    {name: 'GoldenRod',            color: 'daa520'},
    {name: 'Gray',                 color: '808080'},
    {name: 'Grey',                 color: '808080'},
    {name: 'Green',                color: '008000'},
    {name: 'GreenYellow',          color: 'adff2f'},
    {name: 'HoneyDew',             color: 'f0fff0'},
    {name: 'HotPink',              color: 'ff69b4'},
    {name: 'IndianRed',            color: 'cd5c5c'},
    {name: 'Indigo',               color: '4b0082'},
    {name: 'Ivory',                color: 'fffff0'},
    {name: 'Khaki',                color: 'f0e68c'},
    {name: 'Lavender',             color: 'e6e6fa'},
    {name: 'LavenderBlush',        color: 'fff0f5'},
    {name: 'LawnGreen',            color: '7cfc00'},
    {name: 'LemonChiffon',         color: 'fffacd'},
    {name: 'LightBlue',            color: 'add8e6'},
    {name: 'LightCoral',           color: 'f08080'},
    {name: 'LightCyan',            color: 'e0ffff'},
    {name: 'LightGoldenRodYellow', color: 'fafad2'},
    {name: 'LightGray',            color: 'd3d3d3'},
    {name: 'LightGrey',            color: 'd3d3d3'},
    {name: 'LightGreen',           color: '90ee90'},
    {name: 'LightPink',            color: 'ffb6c1'},
    {name: 'LightSalmon',          color: 'ffa07a'},
    {name: 'LightSeaGreen',        color: '20b2aa'},
    {name: 'LightSkyBlue',         color: '87cefa'},
    {name: 'LightSlateGray',       color: '778899'},
    {name: 'LightSlateGrey',       color: '778899'},
    {name: 'LightSteelBlue',       color: 'b0c4de'},
    {name: 'LightYellow',          color: 'ffffe0'},
    {name: 'Lime',                 color: '00ff00'},
    {name: 'LimeGreen',            color: '32cd32'},
    {name: 'Linen',                color: 'faf0e6'},
    {name: 'Magenta',              color: 'ff00ff'},
    {name: 'Maroon',               color: '800000'},
    {name: 'MediumAquaMarine',     color: '66cdaa'},
    {name: 'MediumBlue',           color: '0000cd'},
    {name: 'MediumOrchid',         color: 'ba55d3'},
    {name: 'MediumPurple',         color: '9370db'},
    {name: 'MediumSeaGreen',       color: '3cb371'},
    {name: 'MediumSlateBlue',      color: '7b68ee'},
    {name: 'MediumSpringGreen',    color: '00fa9a'},
    {name: 'MediumTurquoise',      color: '48d1cc'},
    {name: 'MediumVioletRed',      color: 'c71585'},
    {name: 'MidnightBlue',         color: '191970'},
    {name: 'MintCream',            color: 'f5fffa'},
    {name: 'MistyRose',            color: 'ffe4e1'},
    {name: 'Moccasin',             color: 'ffe4b5'},
    {name: 'NavajoWhite',          color: 'ffdead'},
    {name: 'Navy',                 color: '000080'},
    {name: 'OldLace',              color: 'fdf5e6'},
    {name: 'Olive',                color: '808000'},
    {name: 'OliveDrab',            color: '6b8e23'},
    {name: 'Orange',               color: 'ffa500'},
    {name: 'OrangeRed',            color: 'ff4500'},
    {name: 'Orchid',               color: 'da70d6'},
    {name: 'PaleGoldenRod',        color: 'eee8aa'},
    {name: 'PaleGreen',            color: '98fb98'},
    {name: 'PaleTurquoise',        color: 'afeeee'},
    {name: 'PaleVioletRed',        color: 'db7093'},
    {name: 'PapayaWhip',           color: 'ffefd5'},
    {name: 'PeachPuff',            color: 'ffdab9'},
    {name: 'Peru',                 color: 'cd853f'},
    {name: 'Pink',                 color: 'ffc0cb'},
    {name: 'Plum',                 color: 'dda0dd'},
    {name: 'PowderBlue',           color: 'b0e0e6'},
    {name: 'Purple',               color: '800080'},
    {name: 'RebeccaPurple',        color: '663399'},
    {name: 'Red',                  color: 'ff0000'},
    {name: 'RosyBrown',            color: 'bc8f8f'},
    {name: 'RoyalBlue',            color: '4169e1'},
    {name: 'SaddleBrown',          color: '8b4513'},
    {name: 'Salmon',               color: 'fa8072'},
    {name: 'SandyBrown',           color: 'f4a460'},
    {name: 'SeaGreen',             color: '2e8b57'},
    {name: 'SeaShell',             color: 'fff5ee'},
    {name: 'Sienna',               color: 'a0522d'},
    {name: 'Silver',               color: 'c0c0c0'},
    {name: 'SkyBlue',              color: '87ceeb'},
    {name: 'SlateBlue',            color: '6a5acd'},
    {name: 'SlateGray',            color: '708090'},
    {name: 'SlateGrey',            color: '708090'},
    {name: 'Snow',                 color: 'fffafa'},
    {name: 'SpringGreen',          color: '00ff7f'},
    {name: 'SteelBlue',            color: '4682b4'},
    {name: 'Tan',                  color: 'd2b48c'},
    {name: 'Teal',                 color: '008080'},
    {name: 'Thistle',              color: 'd8bfd8'},
    {name: 'Tomato',               color: 'ff6347'},
    {name: 'Turquoise',            color: '40e0d0'},
    {name: 'Violet',               color: 'ee82ee'},
    {name: 'Wheat',                color: 'f5deb3'},
    {name: 'White',                color: 'ffffff'},
    {name: 'WhiteSmoke',           color: 'f5f5f5'},
    {name: 'Yellow',               color: 'ffff00'},
    {name: 'YellowGreen',          color: '9acd32'}
];


function writeTextToClipboard(str) 
{
    if (   navigator.clipboard 
        && window.isSecureContext) 
        return navigator.clipboard.writeText(str);

    else 
    {
        let textArea = document.createElement('textarea');

        textArea.value = str;

        textArea.style.position = 'fixed';
        textArea.style.left     = '-999999px';
        textArea.style.top      = '-999999px';
        
        document.body.appendChild(textArea);
        
        textArea.focus();
        textArea.select();
        
        return new Promise((res, rej) => 
        {
            document.execCommand('copy') ? res() : rej();
            textArea.remove();
        });
    }
}



function readTextFromClipboard() 
{
    if (   navigator.clipboard 
        && window.isSecureContext) 
        return navigator.clipboard.readText();

    else 
    {
        let textArea = document.createElement('textarea');

        textArea.style.position = 'fixed';
        textArea.style.left     = '-999999px';
        textArea.style.top      = '-999999px';
        
        document.body.appendChild(textArea);
        
        textArea.focus();
        textArea.select();
        
        return new Promise((res, rej) => 
        {
            document.execCommand('paste') ? res(textArea.value) : rej();
            textArea.remove();
        });
    }
}


function isTagKey(key, tag) 
{
    return key.substring(0, tag.length+1) == tag + ' ';
}



function noTag(key, tag)
{
    return key.substring(tag.length+1);
}



function isNodeKey(key) { return isTagKey(key, nodeTag); }
function isConnKey(key) { return isTagKey(key, connTag); }



function noNodeTag(key) { return noTag(key, nodeTag); }
function noConnTag(key) { return noTag(key, connTag); }


function nodeIdArrayToString(nodeIds)
{
    let str = '';

    for (let i = 0; i < nodeIds.length; i++)
    {
        if (i > 0) str += ', ';
        str += nodeIds[i];
    }

    return str;
}



function nodeArrayToString(nodes)
{
    let str = '';

    for (let i = 0; i < nodes.length; i++)
    {
        if (i > 0) str += ', ';
        str += nodes[i] ? nodes[i].id : 'undefined';
    }

    return str;
}


const INTER_STEP   = 0,
      INTER_LINEAR = 1,
      INTER_COSINE = 2,
      INTER_CUBIC  = 3;



class NoiseSeed
{
    initial;
    current;

    

    constructor()
    {
        this.reset();
    }
    


    set(seed)
    {
        this.initial = seed;
        this.current = seed;
    }    
    


    rotate()
    {
        this.current = (this.current + 0x7ed55d16) + (this.current << 12);
        this.current = (this.current ^ 0xc761c23c) ^ (this.current >> 19);
        this.current = (this.current + 0x165667b1) + (this.current <<  5);
        this.current = (this.current + 0xd3a2646c) ^ (this.current <<  9);
        this.current = (this.current + 0xfd7046c5) + (this.current <<  3);
        this.current = (this.current ^ 0xb55a4f09) ^ (this.current >> 16);
    }    
    


    next()
    {
        const seed = this.current;
        this.rotate();
        return seed;
    }



    reset()
    {
        this.current = this.initial;
    }
};



class Noise
{
	interpolation = INTER_CUBIC;
	clip = false;

	seed = new NoiseSeed();

	v0;
	v1;
	v2;
	v3;

	step = 0;


    constructor(seed = 0)
    {
        this.seed.set(seed);
        this.reset();
    }


    next(scale = 1)
    {
        //scale = Math.pow(Phi, scale) / Phi;
        scale = Math.max(1, scale);

        let next = this.v1;

        if (this.step >= 1)
        {
            // get the next random value
        
            this.seed.rotate();

            this.v0 = this.v1;
        //------------------------
            this.v1 = this.v2;
            this.v2 = this.v3;
        //------------------------
            this.v3 = normalizeSeed(this.seed.current);

            this.step -= 1;
        }

        // get the next 'noise' value

        switch (this.interpolation)
        {
            case INTER_STEP:
            {
                next = this.v1;
                break;
            }
            case INTER_LINEAR:
            {
                next = this.v1 + this.step * (this.v2 - this.v1);
                break;
            }
            case INTER_COSINE:
            {
                const ft = this.step * Math.PI;
                const f  = (1 - Math.cos(ft)) * 0.5;
                
                next = this.v1 + f * (this.v2 - this.v1);
                break;
            }
            case INTER_CUBIC:
            {
                const p = (this.v3 - this.v2) - (this.v0 - this.v1);
                const q = (this.v0 - this.v1) - p;
                const r =  this.v2 - this.v0;
                const s =  this.v1;

                const val = 
                      p * cube(this.step) 
                    + q * sqr(this.step) 
                    + r * this.step 
                    + s;

                next = this.clip 
                    ? Math.max(0, Math.min(val, 1)) 
                    : val;

                break;
            }
        }

        this.step += 1 / scale;

        return next;
    }

   
    reset()
    {
        this.seed.reset();

        this.v0 = normalizeSeed(this.seed.current); this.seed.rotate();
        this.v1 = normalizeSeed(this.seed.current); this.seed.rotate();
        this.v2 = normalizeSeed(this.seed.current); this.seed.rotate();
        this.v3 = normalizeSeed(this.seed.current); this.seed.rotate();

        this.step = 0;
    }
}


function normalizeSeed(x)
{
    return x / -0x7fffffff;
}


const NAN_CHAR                = '?';
const NAN_DISPLAY             = '?';
    
const UNKNOWN_CHAR            = '?';
const UNKNOWN_DISPLAY         = UNKNOWN_CHAR;//'🤷‍♂️';
    
const TRUE_DISPLAY            = '✓';//'true';
const FALSE_DISPLAY           = '❌';//'false';
    
const LIST_VALUE              = 'LIST#';
const LIST                    = 'LIST';
    
const ITEMS                   = 'ITEMS';
const SELECT                  = 'SEL';
const IF_ELSE                 = 'IF';
    
const START                   = 'START';
const REPEAT                  = 'REPT';
    
const CACHE                   = 'CACHE';
const COPY                    = 'COPY';


const LIST_TYPES =
[
    LIST_VALUE,
    LIST,
    ITEMS,
    REPEAT
];


const FOREACH                 = 'FOR';


const FLOW_TYPES =
[
    ...LIST_TYPES,
    ITEMS,
    SELECT,
    IF_ELSE,
    START,
    REPEAT,
    FOREACH,
    CACHE,
    COPY
];


const NUMBER_VALUE            = 'NUM#';  
const NUMBER                  = 'NUM';   
const NUMBER_ABSOLUTE         = 'ABS';   
const NUMBER_ROUND            = 'ROUND';   
const NUMBER_LIMITS           = 'LIM';   
const NUMBER_SERIES           = 'SER';  
const NUMBER_RANDOM           = 'RAND';  
const NUMBER_INTERPOLATE      = 'LERP';  

const NUMBER_MATH             = 'MATH';  
const NUMBER_ADD              = 'ADD';   
const NUMBER_SUBTRACT         = 'SUB';   
const NUMBER_MULTIPLY         = 'MUL';   
const NUMBER_DIVIDE           = 'DIV';   
const NUMBER_MODULO           = 'MOD';   
const NUMBER_EXPONENT         = 'EXP';

const NUMBER_BOOLEAN          = 'BOOL';  
const NUMBER_NOT              = 'NOT';
const NUMBER_AND              = 'AND';
const NUMBER_OR               = 'OR';
const NUMBER_XOR              = 'XOR';

const NUMBER_CONDITION        = 'COND';
const NUMBER_EQUAL            = 'EQ';
const NUMBER_NOT_EQUAL        = 'NE';
const NUMBER_LESS             = 'LT';
const NUMBER_LESS_OR_EQUAL    = 'LE';
const NUMBER_GREATER          = 'GT';
const NUMBER_GREATER_OR_EQUAL = 'GE';


const MATH_TYPES =
[
    NUMBER_MATH,
    NUMBER_ADD,
    NUMBER_SUBTRACT,
    NUMBER_MULTIPLY,
    NUMBER_DIVIDE,
    NUMBER_MODULO,
    NUMBER_EXPONENT
];


const BOOLEAN_TYPES =
[
    NUMBER_BOOLEAN,
    NUMBER_NOT,
    NUMBER_AND,
    NUMBER_OR,
    NUMBER_XOR
];


const CONDITION_TYPES =
[
    NUMBER_CONDITION,
    NUMBER_EQUAL,
    NUMBER_NOT_EQUAL,
    NUMBER_LESS,
    NUMBER_LESS_OR_EQUAL,
    NUMBER_GREATER,
    NUMBER_GREATER_OR_EQUAL
];


const NUMBER_TYPES =
[
    NUMBER_VALUE,
    NUMBER,
    NUMBER_ABSOLUTE,
    NUMBER_ROUND,
    NUMBER_LIMITS,
    NUMBER_SERIES,
    NUMBER_RANDOM,
    NUMBER_INTERPOLATE,

    ...MATH_TYPES,
    ...BOOLEAN_TYPES,
    ...CONDITION_TYPES
];


const STRING_VALUE   = 'STR#';  
const STRING         = 'STR';   
const STRING_ADD     = 'SADD';  
const STRING_REPLACE = 'SREPL'; 


const STRING_TYPES =
[
    STRING_VALUE,
    STRING,
    STRING_ADD,
    STRING_REPLACE
];


const COLOR_VALUE       = 'COL#';  
const COLOR             = 'COL';   
const VALID_COLOR       = 'CVAL';  
const CORRECT_COLOR     = 'CCOR';  
const COLOR_CONTRAST    = 'CCNT';  
const COLORBLIND        = 'BLND';  
const COLOR_INTERPOLATE = 'CLERP'; 


const COLOR_TYPES =
[
    COLOR_VALUE,
    COLOR,
    COLOR_INTERPOLATE,
    CORRECT_COLOR,
    COLORBLIND
];


const FILL_VALUE       = 'FILL#';
const FILL             = 'FILL';
const FILL_TYPES       = [FILL_VALUE, FILL];

const STROKE_VALUE     = 'STRK#';
const STROKE           = 'STRK';
const STROKE_TYPES     = [STROKE_VALUE, STROKE];

const COLOR_STOP_VALUE = 'CSTOP#';
const COLOR_STOP       = 'CSTOP';

const GRADIENT_VALUE   = 'GRAD#';
const GRADIENT         = 'GRAD';
const GRADIENT_TYPES   = [GRADIENT_VALUE, GRADIENT];

//const COLOR_STYLE_VALUE = 'CSTL#';
const COLOR_STYLE       = 'CSTL';
//const COLOR_STYLE_TYPES = [COLOR_STYLE_VALUE, COLOR_STYLE];


const SHAPE_VALUE      = 'SHP#'; // abstract placeholder

const RECTANGLE_VALUE  = 'RECT#';
const RECTANGLE        = 'RECT'; 
const RECTANGLE_TYPES  = [RECTANGLE_VALUE, RECTANGLE];

const LINE_VALUE       = 'LINE#';
const LINE             = 'LINE'; 
const LINE_TYPES       = [LINE_VALUE, LINE];

const ELLIPSE_VALUE    = 'ELPS#';
const ELLIPSE          = 'ELPS'; 
const ELLIPSE_TYPES    = [ELLIPSE_VALUE, ELLIPSE];

const POLYGON_VALUE    = 'POLY#';
const POLYGON          = 'POLY'; 
const POLYGON_TYPES    = [POLYGON_VALUE, POLYGON];

const STAR_VALUE       = 'STAR#';
const STAR             = 'STAR'; 
const STAR_TYPES       = [STAR_VALUE, STAR];


const SHAPE_VALUES =
[
    SHAPE_VALUE,

    RECTANGLE_VALUE,
    LINE_VALUE,
    ELLIPSE_VALUE,
    POLYGON_VALUE,
    STAR_VALUE
];


const SHAPE_TYPES =
[
    ...SHAPE_VALUES,

    ...RECTANGLE_TYPES,
    ...LINE_TYPES,
    ...ELLIPSE_TYPES,
    ...POLYGON_TYPES,
    ...STAR_TYPES//,
    //TEXT
];


const ALL_TYPES =
[
    ...FLOW_TYPES,
    ...NUMBER_TYPES,
    ...STRING_TYPES,
    ...COLOR_TYPES,
    ...FILL_TYPES,
    ...STROKE_TYPES,
    ...GRADIENT_TYPES,
    //...COLOR_STYLE_TYPES,
    COLOR_STYLE,
    ...SHAPE_TYPES
];


const GROUP         = 'GRP';   // ???? count O...


const COMMENT       = 'CMNT';


const ACTIVE        = 'ACT';
const BEFORE_ACTIVE = 'BEF';
const DISABLED      = 'DIS';
const NOCACHE       = 'NOC';

const PARAM         = 'PARAM'; // nodeId paramId


const LOG           = 'LOG';



const MATH_OPS = 
[   // the order is important for logical keyboard value changes
    [NUMBER_SUBTRACT, '−' ],
    [NUMBER_ADD,      '+' ],
    [NUMBER_MODULO,   '%' ],
    [NUMBER_DIVIDE,   '/' ], //'÷' ],
    [NUMBER_MULTIPLY, '×' ],
    [NUMBER_EXPONENT, 'e<sup>x</sup>'] 
];



const BOOLEAN_NOT = 0;
const BOOLEAN_AND = 1;
const BOOLEAN_OR  = 2;
const BOOLEAN_XOR = 3;

const BOOLEAN_OPS = 
[   
    [BOOLEAN_NOT, 'not'],
    [BOOLEAN_AND, 'and'],
    [BOOLEAN_OR,  'or' ],
    [BOOLEAN_XOR, 'xor'] 
];



const CONDITION_LESS             = 0;
const CONDITION_LESS_OR_EQUAL    = 1;
const CONDITION_NOT_EQUAL        = 2;
const CONDITION_EQUAL            = 3;
const CONDITION_GREATER_OR_EQUAL = 4;
const CONDITION_GREATER          = 5;

const CONDITION_OPS = 
[   
    [CONDITION_LESS,             '<'],
    [CONDITION_LESS_OR_EQUAL,    '≤'],
    [CONDITION_NOT_EQUAL,        '≠'],
    [CONDITION_EQUAL,            '='],
    [CONDITION_GREATER_OR_EQUAL, '≥'],
    [CONDITION_GREATER,          '>']
];



/*

FRAME       F
IMAGE       I
SLICE       /
TEXT        T
VECTOR      V

*/


class FigmaObject
{
    type;

    nodeId   = '';
    nodeName = '';


    constructor(type, nodeId, nodeName)
    {
        this.type     = type;

        this.nodeId   = nodeId;
        this.nodeName = nodeName;
    }



    copyBase(base)
    {
        this.fills        = clone(base.fills);
        this.strokeFills  = clone(base.strokeFills);

        this.strokeWeight = base.strokeWeight;
        this.strokeFit    = base.strokeFit;
        this.strokeJoin   = base.strokeJoin;
        this.strokeMiter  = base.strokeMiter;
    }
}


class FigmaShape
extends FigmaObject
{
    objectId    = -1;

    fills       = [];
    strokeFills = [];

    strokeWeight;
    strokeFit;
    strokeJoin;
    strokeMiter;



    constructor(type, nodeId, nodeName, objectId)
    {
        super(type, nodeId, nodeName);

        this.objectId = objectId;
    }



    copyBase(base)
    {
        this.fills        = clone(base.fills);
        this.strokeFills  = clone(base.strokeFills);

        this.strokeWeight = base.strokeWeight;
        this.strokeFit    = base.strokeFit;
        this.strokeJoin   = base.strokeJoin;
        this.strokeMiter  = base.strokeMiter;
    }
}


class FigmaRectangle
extends FigmaShape
{
    x;
    y;
    width;
    height;
    angle;
    round;



    constructor(nodeId, nodeName, objectId, x, y, width, height, angle, round)
    {
        super(RECTANGLE, nodeId, nodeName, objectId);
        
        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;
        this.angle  = angle;
        this.round  = round;
    }



    copy()
    {
        const copy = new FigmaRectangle(
            this.nodeId,
            this.nodeName,
            this.objectId,
            this.x,
            this.y,
            this.width,
            this.height,
            this.angle,
            this.round);

        copy.copyBase(this);

        return copy;
    }
}


class FigmaLine
extends FigmaShape
{
    x;
    y;
    width;
    angle;



    constructor(nodeId, nodeName, objectId, x, y, width, angle)
    {
        super(LINE, nodeId, nodeName, objectId);
        
        this.x     = x;
        this.y     = y;
        this.width = width;
        this.angle = angle;
    }



    copy()
    {
        const copy = new FigmaLine(
            this.nodeId,
            this.nodeName,
            this.objectId,
            this.x,
            this.y,
            this.width,
            this.angle);

        copy.copyBase(this);

        return copy;
    }
}


class FigmaEllipse
extends FigmaShape
{
    x;
    y;
    width;
    height;
    angle;



    constructor(nodeId, nodeName, objectId, x, y, width, height, angle)
    {
        super(ELLIPSE, nodeId, nodeName, objectId);
        
        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;
        this.angle  = angle;
    }



    copy()
    {
        const copy = new FigmaEllipse(
            this.nodeId,
            this.nodeName,
            this.objectId,
            this.x,
            this.y,
            this.width,
            this.height,
            this.angle);

        copy.copyBase(this);

        return copy;
    }
}


class FigmaPolygon
extends FigmaShape
{
    x;
    y;
    width;
    height;
    angle;
    round;
    corners;



    constructor(nodeId, nodeName, objectId, x, y, width, height, angle, round, corners)
    {
        super(POLYGON, nodeId, nodeName, objectId);
        
        this.x       = x;
        this.y       = y;
        this.width   = width;
        this.height  = height;
        this.angle   = angle;
        this.round   = round;
        this.corners = corners;
    }



    copy()
    {
        const copy = new FigmaPolygon(
            this.nodeId,
            this.nodeName,
            this.objectId,
            this.x,
            this.y,
            this.width,
            this.height,
            this.angle,
            this.round,
            this.corners);

        copy.copyBase(this);

        return copy;
    }
}


class FigmaStar
extends FigmaShape
{
    x;
    y;
    width;
    height;
    angle;
    round;
    points;
    convex;



    constructor(nodeId, nodeName, objectId, x, y, width, height, angle, round, points, convex)
    {
        super(STAR, nodeId, nodeName, objectId);
        
        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;
        this.angle  = angle;
        this.round  = round;
        this.points = points;
        this.convex = convex;
    }



    copy()
    {
        const copy = new FigmaStar(
            this.nodeId,
            this.nodeName,
            this.objectId,
            this.x,
            this.y,
            this.width,
            this.height,
            this.angle,
            this.round,
            this.points,
            this.convex);

        copy.copyBase(this);

        return copy;
    }
}


class FigmaColorStyle
extends FigmaObject
{
    styleName;
    existing;



    constructor(nodeId, nodeName)
    {
        super(COLOR_STYLE, nodeId, nodeName);

        this.styleName = nodeName;
    }



    copy()
    {
        const copy = new FigmaColorStyle(
            this.nodeId,
            this.nodeName);

        copy.copyBase(this);

        copy.existing = this.existing;

        return copy;
    }
}


class GNode
{
    type;

    options = {};
    data    = {}; // for type conversion info



    constructor(type, options) 
    {
        this.type    = type;
        this.options = options;
    }



    copy()
    {
        console.assert(false, 'abstract type GNode cannot be copied');
        return null;
    }



    copyBase(src)
    {
        this.options  = clone(src.options);
        this.data     = clone(src.data);
    }



    validate()
    {
        this.valid = true;
    }



    isValid() // is a valid value
    {
        return false;
    }



    toValue()
    {
        return null;
    }



    toString() 
    { 
        return this.type; 
    }
}



class GValue
extends GNode
{
    constructor(type, options) 
    {
        super(type, options);
    }



    copy()
    {
        console.assert(false, 'abstract class GValue cannot be copied');
        return null;
    }



    toValue()
    {
        return this.copy();
    }



    toString() 
    { 
        return this.type; 
    }
}



function displayValue(type, value)
{
    if (   type == NUMBER_VALUE
        && value.indexOf(',') < 0)
        return value;


    switch (type)
    {
        //case      LIST_VALUE: return parseListValue     (value)[0].toDisplayString();
        case    NUMBER_VALUE: return parseNumberValue   (value)[0].toDisplayString();
        case     COLOR_VALUE: return parseColorValue    (value)[0].toDisplayString();
        // case RECTANGLE_VALUE: return parseRectangleValue(value)[0].toDisplayString();
        // case      LINE_VALUE: return parseLineValue     (value)[0].toDisplayString();
        // case   ELLIPSE_VALUE: return parseEllipseValue  (value)[0].toDisplayString();
        // case   POLYGON_VALUE: return parsePolygonValue  (value)[0].toDisplayString();
        // case      STAR_VALUE: return parseStarValue     (value)[0].toDisplayString();
        //case      FILL_VALUE: return parseFillValue     (value)[0].toDisplayString();
        //case    STROKE_VALUE: return parseStrokeValue   (value)[0].toDisplayString();
    }


    console.assert(false, 'cannot display value of type \'' + type + '\'');
}


class GOperator
extends GNode
{
    nodeId;
    nodeName;

    valid; // has been evaluated
    topLevel;

    value;

   
    
    constructor(type, nodeId, options)
    {
        super(type, options);

        this.nodeId       = nodeId;
        this.nodeName     = options.nodeName;

        this.valid        = false;
        this.topLevel     = false;

        this.value        = null;
    }



    copyBase(src)
    {
        super.copyBase(src);
        
        this.nodeId   = src.nodeId;
        this.nodeName = src.nodeName;

        this.valid    = src.valid;
        this.topLevel = src.topLevel;
    }



    getParamFromId(paramId)
    {
        return this[paramId];
    }



    isCached()
    {
        return this.options.cached
            && this.valid;
    }



    eval(parse)
    {
        // calculate and add value update here

        return this;
    }



    toValue()
    {
        return null;
    }
}


class GParam
extends GOperator
{
    paramId;
    
    node;
    param;
    


    constructor(nodeId, paramId)
    {
        super(PARAM, nodeId, false);

        this.paramId = paramId;
    }



    copy()
    {
        const copy = new GParam(this.nodeId, this.paramId);

        copy.copyBase(this);

        copy.node = this.node;
    
        return copy;
    }



    eval(parse)
    {
        this.node = parse.parsedNodes.find(v => v.nodeId == this.nodeId);
        console.assert(this.node, 'can\'t find parameter node \'' + this.nodeId + '\'');

        this.node.eval(parse);

        this.param = this.node.getParamFromId(this.paramId);

        if (isValid(this.param)) // could have been deleted from OpRepeat for example
            return this.param.eval(parse).toValue();
        else
            return NullValue;
    }
}


class ListValue
extends GValue
{
    items;



    constructor(items = [])
    {
        super(LIST_VALUE);

        if (items)
        {
            this.items = [];
            
            for (const item of items)
                this.items.push(item.copy());
        }
    }



    copy()
    {
        const copy = new ListValue(this.items);

        copy.copyBase(this);

        return copy;
    }



    equals(list)
    {
        if (!list)                                  return false;
        if (!(list instanceof ListValue))           return false;
        if (this.items.length != list.items.length) return false;
            
        for (let i = 0; i < this.items.length; i++)
            if (!this.items[i].equals(list.items[i]))
                return false;

        return true;
    }



    eval(parse)
    {
        return this;
    }



    isValid()
    {
        return this.items
            && !this.items.find(i => !i.isValid());
    }



    toValue()
    {
        return this.copy();
    }



    toString()
    {
        if (!this.items)
            return '';


        let str = '';
        
        
        str += this.items.length;

        for (let i = 0; i < this.items.length; i++)
        {
            const item = this.items[i];

            str += ' ' + item.type + ' ';
            str += item.toString();
        }


        return str;
    }



    toDisplayString()
    {
        if (!this.items)
            return '';


        let str = '';
        
        
        str += this.items.length;

        for (let i = 0; i < this.items.length; i++)
        {
            const item = this.items[i];

            str += ' ' + item.type + ' ';
            str += item.toDisplayString();
        }


        return str;
    }



    static NaN = Object.freeze(new ListValue(null));
}



function parseListValue(str, i = -1)
{
    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }
        

    const iStart = i;

    const list = new ListValue();
    

    const nInputs = parseInt(str[i++]);


    for (let j = 0; j < nInputs; j++)
    {
        const type = str[i++];
        
        switch (type)
        {
            case NUMBER_VALUE:      { const num    = parseNumberValue(str[i]); i += num   [1]; list.items.push(num   [0]); break; }
            case COLOR_VALUE:       { const col    = parseColorValue (str, i); i += col   [1]; list.items.push(col   [0]); break; }
            case FILL_VALUE:        { const fill   = parseFillValue  (str, i); i += fill  [1]; list.items.push(fill  [0]); break; }
            case STROKE_VALUE:      { const stroke = parseStrokeValue(str, i); i += stroke[1]; list.items.push(stroke[0]); break; }
            //case COLOR_STYLE_VALUE: { const style  = parseStyleValue (str, i); i += style [1]; list.items.push(style [0]); break; }
            case LIST_VALUE:        { const _list  = parseListValue  (str, i); i += _list [1]; list.items.push(_list [0]); break; }
        }
    }
 

    return [
        list, 
        i - iStart];
}


class NumberValue
extends GValue
{
    value;
    decimals;



    constructor(val = Number.NaN, dec = 0)
    {
        super(NUMBER_VALUE);

        if (typeof val !== 'number')
            console.assert(false, 'NumberValue(value) is ' + typeof val + ', must be a number');


        this.value    = val;
        this.decimals = dec;
    }



    static fromString(str)
    {
        return new NumberValue(
            parseFloat(str),
            decCount(str));
    }



    copy()
    {
        const copy = new NumberValue(
            this.value, 
            this.decimals);

        copy.copyBase(this);

        return copy;
    }



    equals(num)
    {
        return num
            && this.value    == num.value
            && this.decimals == num.decimals;
    }



    eval(parse)
    {
        return this;
    }



    isValid()
    {
        return !isNaN(this.value)
            && !isNaN(this.decimals);
    }



    toInteger()
    {
        return new NumberValue(Math.round(this.value));
    }



    toNumber()
    {
        return roundTo(this.value, this.decimals);
    }



    toString()
    {
        return printNum(this.value) + ',' + printNum(this.decimals); // only NumberValue can do this, other _Values have to list all members
    }



    toSimpleString()
    {
        return !isNaN(this.value)
              ? numToString(this.value, this.decimals)
              : NAN_CHAR; // only NumberValue can do this, other _Values have to list all members
    }



    toDisplayString()
    {
        return printNum(this.value) 
             + (!isNaN(this.decimals)
                ? subscriptNumber(this.decimals)
                : '');
    }



    static NaN = Object.freeze(new NumberValue(
        Number.NaN, 
        Number.NaN));
}



const NullValue = Object.freeze(NumberValue.NaN);



function parseNumberValue(str)
{
    if (str.indexOf(',') < 0)
        console.assert(false, 'number value missing \',\'');
    
    const parts = str.split(',');

    const num = new NumberValue(
        parseNum(parts[0]),
        parseNum(parts[1]));

    return [num, 1];
}



function parseSimpleNumberValue(str)
{
    const num = 
        str == NAN_CHAR
        ? NumberValue.NaN
        : NumberValue.fromString(str);

    return [num, 1];
}


class ColorValue
extends GValue
{
    space;
    c1;
    c2;
    c3;



    constructor(space = NumberValue.NaN, 
                c1    = NumberValue.NaN, 
                c2    = NumberValue.NaN, 
                c3    = NumberValue.NaN)
    {
        super(COLOR_VALUE);

        this.space  = space.copy();
        this.c1     = c1   .copy();
        this.c2     = c2   .copy();
        this.c3     = c3   .copy();

        this.valid  = true;
    }



    static create(space, c1, c2, c3)
    {
        console.assert(typeof space == 'number', 'ColorValue.create() space must be a number');
        console.assert(typeof c1    == 'number', 'ColorValue.create() c1 must be a number');
        console.assert(typeof c2    == 'number', 'ColorValue.create() c2 must be a number');
        console.assert(typeof c3    == 'number', 'ColorValue.create() c3 must be a number');

        return new ColorValue(
            new NumberValue(space),
            new NumberValue(c1   ),
            new NumberValue(c2   ),
            new NumberValue(c3   ));
    }



    static fromRgb(rgb)
    {
        return ColorValue.create(1, rgb[0], rgb[1], rgb[2]);
    }



    static fromDataColor(_color, spaceIndex = -1)
    {
        if (spaceIndex < 0)
            spaceIndex = colorSpaceIndex (_color[0]);

        const space  = colorSpace(spaceIndex);
        const factor = colorSpaceFactor(space);

        return ColorValue.create(
            spaceIndex,
            _color[1] * factor[0],
            _color[2] * factor[1],
            _color[3] * factor[2]);
    }



    copy()
    {
        const copy = new ColorValue(
            this.space.copy(), 
            this.c1   .copy(), 
            this.c2   .copy(), 
            this.c3   .copy());

        copy.copyBase(this);

        return copy;
    }



    isValid()
    {
        return this.space.isValid()
            && this.c1   .isValid()
            && this.c2   .isValid()
            && this.c3   .isValid();
    }



    equals(col)
    {
        return col
            && this.space.equals(col.space)
            && this.c1   .equals(col.c1   )
            && this.c2   .equals(col.c2   )
            && this.c3   .equals(col.c3   );
    }



    eval(parse)
    {
        return this;
    }



    toDataColor()
    {
        if (!this.isValid())
            return dataColor_NaN;

        const space = this.space.copy();

        space.value = Math.round(Math.min(Math.max(0, space.value), OpColorSpaces.length-1));

        return makeDataColor(
            space,
            this.c1,
            this.c2,
            this.c3);
    }



    toRgb()
    {
        return dataColor2rgb(this.toDataColor());
    }



    toString()
    {
        return      this.space.toString()
            + ' ' + this.c1   .toString()
            + ' ' + this.c2   .toString()
            + ' ' + this.c3   .toString();
    }



    toDisplayString()
    {
        return      this.space.toDisplayString()
            + ' ' + this.c1   .toDisplayString()
            + ' ' + this.c2   .toDisplayString()
            + ' ' + this.c3   .toDisplayString();
    }



    toRgbString()
    {
        if (!this.isValid())
            return UNKNOWN_DISPLAY;

        const rgb = this.toRgb();

        return      rgb[0].toString()
            + ' ' + rgb[1].toString()
            + ' ' + rgb[2].toString();
    }



    static NaN = Object.freeze(new ColorValue(
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN));
}



function parseColorValue(str, i = -1)
{
    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }
        

    const iStart = i;

    const space = parseNumberValue(str[i]); i += space[1];
    const c1    = parseNumberValue(str[i]); i += c1   [1];
    const c2    = parseNumberValue(str[i]); i += c2   [1];
    const c3    = parseNumberValue(str[i]); i += c3   [1];


    return [
        new ColorValue(space[0], c1[0], c2[0], c3[0]), 
        i - iStart ];
}


class FillValue
extends GValue
{
    color;
    opacity;



    constructor(color   = ColorValue.NaN, 
                opacity = new NumberValue(100))
    {
        super(FILL_VALUE);

        this.color   = color  .copy();
        this.opacity = opacity.copy();

        this.valid   = true;
    }


    
    static create(r, g, b, opacity)
    {
        console.assert(
            typeof opacity == 'number',
            'opacity must be a number');

        return new FillValue(
            ColorValue.create(1, r, g, b),
            new NumberValue(opacity));
    }



    static fromRgb(rgb, opacity)
    {
        console.assert(
            typeof opacity == 'number',
            'opacity must be a number');

        return new FillValue(
            ColorValue.fromRgb(rgb),
            new NumberValue(opacity));
    }



    copy()
    {
        const copy = new FillValue(
            this.color  .copy(),
            this.opacity.copy());

        copy.copyBase(this);

        return copy;
    }



    equals(fill)
    {
        return fill
            && this.color  .equals(fill.color  )
            && this.opacity.equals(fill.opacity);
    }



    eval(parse)
    {
        return this;
    }



    toRgba()
    {
        return [
            ...this.color.toRgb(),
            this.opacity.value / 100 ];
    }



    // toFigma()
    // {
    //     return [['SOLID', this.toString()]];
    // }



    toString()
    {
        const rgb = scaleRgb(this.color.toRgb());

        return        new NumberValue(rgb[0]).toString()
              + ' ' + new NumberValue(rgb[1]).toString()
              + ' ' + new NumberValue(rgb[2]).toString()
              + ' ' + this.opacity           .toString();
    }



    toDisplayString()
    {
        const rgb = scaleRgb(this.color.toRgb());

        return        new NumberValue(rgb[0]).toDisplayString()
              + ' ' + new NumberValue(rgb[1]).toDisplayString()
              + ' ' + new NumberValue(rgb[2]).toDisplayString()
              + ' ' + this.opacity           .toDisplayString();
    }



    isValid()
    {
        return this.color  .isValid()
            && this.opacity.isValid();
    }



    static NaN = Object.freeze(new FillValue(
        ColorValue .NaN,
        NumberValue.NaN));



    static default = Object.freeze(FillValue.create(217, 217, 217, 100));
}



function parseFillValue(str, i = -1)
{
    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const r = parseNumberValue(str[i]); i += r[1];
    const g = parseNumberValue(str[i]); i += g[1];
    const b = parseNumberValue(str[i]); i += b[1];
    const a = parseNumberValue(str[i]); i += a[1];

    const color = new ColorValue(new NumberValue(1), r[0], g[0], b[0]);

    
    return [
        new FillValue(color, a[0]),
        i - iStart ];
}






// function evalFillValue(fillValue, parse)
// {
//     fillValue.eval(parse);

//          if ( FILL_TYPES.includes(fillValue.type)) return fill;
//     else if (COLOR_TYPES.includes(fillValue.type)) return new FillValue(fill, fillValue.data.opacity);

//     else console.assert(false, 'fill must have type');
// }


class StrokeValue
extends GValue
{
    fill;
    weight;
    fit;
    join;
    miter;



    constructor(fill   = FillValue.NaN, 
                weight = new NumberValue(1),
                fit    = new NumberValue(0),
                join   = new NumberValue(0),
                miter  = new NumberValue(28.96, 2))
    {
        if (fill.type != FILL_VALUE)
            console.assert(false, 'fill.type must be FILL_VALUE');


        super(STROKE_VALUE);

        this.fill   = fill  .copy();
        this.weight = weight.copy();
        this.fit    = fit   .copy();
        this.join   = join  .copy();
        this.miter  = miter .copy();

        this.valid   = true;
    }


    
    // static create(r, g, b, opacity)
    // {
    //     console.assert(
    //         typeof opacity == 'number',
    //         'opacity must be a number');

    //     return new FillValue(
    //         ColorValue.create(1, r, g, b),
    //         new NumberValue(opacity));
    // }



    // static fromRgb(rgb, opacity)
    // {
    //     console.assert(
    //         typeof opacity == 'number',
    //         'opacity must be a number');

    //     return new FillValue(
    //         ColorValue.fromRgb(rgb),
    //         new NumberValue(opacity));
    // }



    copy()
    {
        const copy = new StrokeValue(
            this.fill  .copy(),
            this.weight.copy(),
            this.fit   .copy(),
            this.join  .copy(),
            this.miter .copy());

        copy.copyBase(this);

        return copy;
    }



    isValid()
    {
        return this.fill  .isValid()
            && this.weight.isValid()
            && this.fit   .isValid()
            && this.join  .isValid()
            && this.miter .isValid();
    }



    equals(stroke)
    {
        return stroke
            && this.fill  .equals(stroke.fill  )
            && this.weight.equals(stroke.weight)
            && this.fit   .equals(stroke.fit   )
            && this.join  .equals(stroke.join  )
            && this.miter .equals(stroke.miter );
    }



    eval(parse)
    {
        return this;
    }



    // toFigma()
    // {
    //     let align, join;

        
    //     switch (this.fit.value)
    //     {
    //         case 0: align = 'INSIDE';  break;
    //         case 1: align = 'CENTER';  break;
    //         case 2: align = 'OUTSIDE'; break;
    //     }
        
    //     switch (this.join.value)
    //     {
    //         case 0: join = 'MITER'; break;
    //         case 1: join = 'BEVEL'; break;
    //         case 2: join = 'ROUND'; break;
    //     }

        
    //     return this.isValid()
    //         ? {
    //               strokes:          this.fill.toFigma(),
    //               strokeWeight:     this.weight.value,
    //               strokeAlign:      align,
    //               strokeJoin:       join,
    //               strokeMiterLimit: this.miter.value
    //           }
    //         : {
    //               strokes: []
    //           };
    // }



    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.fill  .toString()
            + ' ' + this.weight.toString()
            + ' ' + this.fit   .toString()
            + ' ' + this.join  .toString()
            + ' ' + this.miter .toString();
    }



    toDisplayString()
    {
        return      this.fill  .toDisplayString()
            + ' ' + this.weight.toDisplayString()
            + ' ' + this.fit   .toDisplayString()
            + ' ' + this.join  .toDisplayString()
            + ' ' + this.miter .toDisplayString();
    }



    static NaN = Object.freeze(new StrokeValue(
        FillValue  .NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN));



    static default = Object.freeze(new StrokeValue(
        FillValue.create(0, 0, 0, 100),
        new NumberValue(1),
        new NumberValue(0),
        new NumberValue(0),
        new NumberValue(28.96)));
}



function parseStrokeValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_CHAR
        || i >= 0 && str[i] == NAN_CHAR)
        return [StrokeValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const fill   = parseFillValue  (str, i); i += fill  [1];
    const weight = parseNumberValue(str[i]); i += weight[1];
    const fit    = parseNumberValue(str[i]); i += fit   [1];
    const join   = parseNumberValue(str[i]); i += join  [1];
    const miter  = parseNumberValue(str[i]); i += miter [1];


    return [
        new StrokeValue(fill[0], weight[0], fit[0], join[0], miter[0]),
        i - iStart ];
}



function evalStrokeValue(value, parse)
{
    const stroke = value.eval(parse).copy();

         if (STROKE_TYPES.includes(stroke.type)) return stroke;
    else if (  FILL_TYPES.includes(stroke.type)) return new StrokeValue(stroke, value.data.weight);
    else if ( COLOR_TYPES.includes(stroke.type)) return new StrokeValue(new FillValue(stroke), value.data.weight);

    else console.assert(false, 'stroke must have type');
}


/*
    This is getting closer to Figma now, so here the format changes,
    and objects hold stroke values directly, which incoming stroke values just set.
*/

class ShapeBaseValue
extends GValue
{
    nodeId;

    // fill;
    // stroke;



    constructor(type, nodeId)
    {
        super(type);

        this.nodeId = nodeId; 

        // this.fill   = FillValue.default.copy();
        // this.stroke = StrokeValue.NaN  .copy();
    }



    copyBase(base)
    {
        this.nodeId = base.nodeId;

        // this.fill   = base.fill  .copy();
        // this.stroke = base.stroke.copy();
    }



    isValid()
    {
        return true;
        // return this.fill  .isValid()
        //    && !this.stroke.isValid();
    }



    // toString()
    // {
    //     return      this.fill  .toString()
    //         + ' ' + this.stroke.toString();
    // }



    // toDisplayString()
    // {
    //     return      this.fill  .toDisplayString()
    //         + ' ' + this.stroke.toDisplayString();
    // }
}



// function parseShapeBaseValue(str, i, obj)
// {
//     const fill   = parseFillValue  (str, i); i += fill  [1];
//     const stroke = parseStrokeValue(str, i); i += stroke[1];

//     obj.fill   = fill  [0];
//     obj.stroke = stroke[0];

//     return i;
// }


class RectangleValue
extends ShapeBaseValue
{
    x;
    y;
    width;
    height;
    angle;
    round;



    constructor(nodeId,
                x      = new NumberValue(0), 
                y      = new NumberValue(0), 
                width  = new NumberValue(0), 
                height = new NumberValue(0), 
                angle  = new NumberValue(0), 
                round  = new NumberValue(0))
    {
        super(RECTANGLE_VALUE, nodeId);

        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;
        this.angle  = angle;
        this.round  = round;
    }



    copy()
    {
        const copy = new RectangleValue(
            this.nodeId,
            this.x     .copy(), 
            this.y     .copy(), 
            this.width .copy(), 
            this.height.copy(), 
            this.angle .copy(), 
            this.round .copy());

        copy.copyBase(this);

        return copy;
    }



    eval(parse)
    {
        return this;
    }



    isValid()
    {
        return this.x     .isValid()
            && this.y     .isValid()
            && this.width .isValid()
            && this.height.isValid()
            && this.angle .isValid()
            && this.round .isValid();
    }


    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.x     .toString()
            + ' ' + this.y     .toString()
            + ' ' + this.width .toString()
            + ' ' + this.height.toString()
            + ' ' + this.angle .toString()
            + ' ' + this.round .toString();
    }



    toDisplayString()
    {
        return      this.x     .toDisplayString()
            + ' ' + this.y     .toDisplayString()
            + ' ' + this.width .toDisplayString()
            + ' ' + this.height.toDisplayString()
            + ' ' + this.angle .toDisplayString()
            + ' ' + this.round .toDisplayString();
    }



    static NaN = new RectangleValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseRectangleValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_CHAR
        || i >= 0 && str[i] == NAN_CHAR)
        return [RectangleValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x      = parseNumberValue(str[i]); i += x     [1];
    const y      = parseNumberValue(str[i]); i += y     [1];
    const width  = parseNumberValue(str[i]); i += width [1];
    const height = parseNumberValue(str[i]); i += height[1];
    const angle  = parseNumberValue(str[i]); i += angle [1];
    const round  = parseNumberValue(str[i]); i += round [1];


    const rect = new RectangleValue(
        '', // set node ID elsewhere
        x     [0],
        y     [0],
        width [0],
        height[0],
        angle [0],
        round [0]);


    // i = parseShapeBaseValue(str, i, rect);

    
    return [rect, i - iStart];
}



class LineValue
extends ShapeBaseValue
{
    x;
    y;
    width;
    angle;



    constructor(nodeId,
                x      = new NumberValue(0), 
                y      = new NumberValue(0), 
                width  = new NumberValue(0), 
                angle  = new NumberValue(0))
    {
        super(LINE_VALUE, nodeId);

        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.angle  = angle;
    }



    copy()
    {
        const copy = new LineValue(
            this.x    .copy(), 
            this.y    .copy(), 
            this.width.copy(), 
            this.angle.copy());

        copy.copyBase(this);

        return copy;
    }



    eval(parse)
    {
        return this;
    }



    isValid()
    {
        return !isNaN(this.x    )
            && !isNaN(this.y    )
            && !isNaN(this.width)
            && !isNaN(this.angle);
    }



    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.x     .toString()
            + ' ' + this.y     .toString()
            + ' ' + this.width .toString()
            + ' ' + this.angle .toString();
    }



    toDisplayString()
    {
        return      this.x     .toDisplayString()
            + ' ' + this.y     .toDisplayString()
            + ' ' + this.width .toDisplayString()
            + ' ' + this.angle .toDisplayString();
    }



    static NaN = new LineValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseLineValue(str)
{
    if (str == NAN_CHAE)
        return LineValue.NaN;

    const rect = str.split(' ');

    return new LineValue(
        new NumberValue(parseNumberValue(rect[0])),
        new NumberValue(parseNumberValue(rect[1])),
        new NumberValue(parseNumberValue(rect[2])),
        new NumberValue(parseNumberValue(rect[3])));
}



class EllipseValue
extends ShapeBaseValue
{
    x;
    y;
    width;
    height;
    angle;



    constructor(nodeId,
                x      = new NumberValue(0), 
                y      = new NumberValue(0), 
                width  = new NumberValue(0), 
                height = new NumberValue(0), 
                angle  = new NumberValue(0))
    {
        super(ELLIPSE_VALUE, nodeId);

        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;
        this.angle  = angle;
    }



    copy()
    {
        const copy = new EllipseValue(
            this.x     .copy(), 
            this.y     .copy(), 
            this.width .copy(), 
            this.height.copy(), 
            this.angle .copy());

        copy.copyBase(this);

        return copy;
    }



    isValid()
    {
        return !isNaN(this.x     )
            && !isNaN(this.y     )
            && !isNaN(this.width )
            && !isNaN(this.height)
            && !isNaN(this.angle );
    }



    eval(parse)
    {
        return this;
    }



    toString()
    {
        return      this.x     .toString()
            + ' ' + this.y     .toString()
            + ' ' + this.width .toString()
            + ' ' + this.height.toString()
            + ' ' + this.angle .toString();
    }



    toDisplayString()
    {
        return      this.x     .toDisplayString()
            + ' ' + this.y     .toDisplayString()
            + ' ' + this.width .toDisplayString()
            + ' ' + this.height.toDisplayString()
            + ' ' + this.angle .toDisplayString();
    }



    static NaN = new EllipseValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseEllipseValue(str)
{
    if (str == NAN_CHAR)
        return EllipseValue.NaN;

    const rect = str.split(' ');

    return new EllipseValue(
        new NumberValue(parseNumberValue(rect[0])[0]),
        new NumberValue(parseNumberValue(rect[1])[0]),
        new NumberValue(parseNumberValue(rect[2])[0]),
        new NumberValue(parseNumberValue(rect[3])[0]),
        new NumberValue(parseNumberValue(rect[4])[0]));
}



class PolygonValue
extends ShapeBaseValue
{
    x;
    y;
    width;
    height;
    angle;
    round;
    corners;



    constructor(nodeId,
                x       = new NumberValue(0), 
                y       = new NumberValue(0), 
                width   = new NumberValue(0), 
                height  = new NumberValue(0), 
                angle   = new NumberValue(0), 
                round   = new NumberValue(0), 
                corners = new NumberValue(0))
    {
        super(POLYGON_VALUE, nodeId);

        this.x       = x;
        this.y       = y;
        this.width   = width;
        this.height  = height;
        this.angle   = angle;
        this.round   = round;
        this.corners = corners;
    }



    copy()
    {
        const copy = new PolygonValue(
            this.x      .copy(), 
            this.y      .copy(), 
            this.width  .copy(), 
            this.height .copy(), 
            this.angle  .copy(), 
            this.round  .copy(), 
            this.corners.copy());
    
        copy.copyBase(this);

        return copy;
    }



    eval(parse)
    {
        return this;
    }



    isValid()
    {
        return !isNaN(this.x      )
            && !isNaN(this.y      )
            && !isNaN(this.width  )
            && !isNaN(this.height )
            && !isNaN(this.angle  )
            && !isNaN(this.round  )
            && !isNaN(this.corners);
    }



    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.x      .toString()
            + ' ' + this.y      .toString()
            + ' ' + this.width  .toString()
            + ' ' + this.height .toString()
            + ' ' + this.angle  .toString()
            + ' ' + this.round  .toString()
            + ' ' + this.corners.toString();
    }



    toDisplayString()
    {
        return      this.x      .toDisplayString()
            + ' ' + this.y      .toDisplayString()
            + ' ' + this.width  .toDisplayString()
            + ' ' + this.height .toDisplayString()
            + ' ' + this.angle  .toDisplayString()
            + ' ' + this.round  .toDisplayString()
            + ' ' + this.corners.toDisplayString();
    }



    static NaN = new PolygonValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parsePolygonValue(str)
{
    if (str == NAN_CHAR)
        return PolygonValue.NaN;

    const poly = str.split(' ');

    return new PolygonValue(
        '',
        new NumberValue(parseNumberValue(poly[0])),
        new NumberValue(parseNumberValue(poly[1])),
        new NumberValue(parseNumberValue(poly[2])),
        new NumberValue(parseNumberValue(poly[3])),
        new NumberValue(parseNumberValue(poly[4])),
        new NumberValue(parseNumberValue(poly[5])),
        new NumberValue(parseNumberValue(poly[6])));
}



class StarValue
extends ShapeBaseValue
{
    x;
    y;
    width;
    height;
    angle;
    round;
    points;
    convex;



    constructor(nodeId,
                x      = new NumberValue(0), 
                y      = new NumberValue(0), 
                width  = new NumberValue(0), 
                height = new NumberValue(0), 
                angle  = new NumberValue(0), 
                round  = new NumberValue(0), 
                points = new NumberValue(0),
                convex = new NumberValue(0))
    {
        super(STAR_VALUE, nodeId);

        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;
        this.angle  = angle;
        this.round  = round;
        this.points = points;
        this.convex = convex;
    }



    copy()
    {
        const copy = new StarValue(
            this.x     .copy(), 
            this.y     .copy(), 
            this.width .copy(), 
            this.height.copy(), 
            this.angle .copy(), 
            this.round .copy(), 
            this.points.copy(),
            this.convex.copy());

        copy.copyBase(this);

        return copy;
    }



    eval(parse)
    {
        return this;
    }



    isValid()
    {
        return !isNaN(this.x     )
            && !isNaN(this.y     )
            && !isNaN(this.width )
            && !isNaN(this.height)
            && !isNaN(this.angle )
            && !isNaN(this.round )
            && !isNaN(this.points)
            && !isNaN(this.convex);
    }


    
    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.x     .toString()
            + ' ' + this.y     .toString()
            + ' ' + this.width .toString()
            + ' ' + this.height.toString()
            + ' ' + this.angle .toString()
            + ' ' + this.round .toString()
            + ' ' + this.points.toString()
            + ' ' + this.convex.toString();
    }



    toDisplayString()
    {
        return      this.x     .toDisplayString()
            + ' ' + this.y     .toDisplayString()
            + ' ' + this.width .toDisplayString()
            + ' ' + this.height.toDisplayString()
            + ' ' + this.angle .toDisplayString()
            + ' ' + this.round .toDisplayString()
            + ' ' + this.points.toDisplayString()
            + ' ' + this.convex.toDisplayString();
    }



    static NaN = new StarValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseStarValue(str)
{
    if (str == NAN_CHAR)
        return StarValue.NaN;

    const star = str.split(' ');

    return new StarValue(
        new NumberValue(parseNumberValue(star[0])),
        new NumberValue(parseNumberValue(star[1])),
        new NumberValue(parseNumberValue(star[2])),
        new NumberValue(parseNumberValue(star[3])),
        new NumberValue(parseNumberValue(star[4])),
        new NumberValue(parseNumberValue(star[5])),
        new NumberValue(parseNumberValue(star[6])),
        new NumberValue(parseNumberValue(star[7])));
}



class GComment
extends GOperator
{
    constructor(nodeId, options)
    {
        super(COMMENT, nodeId, options);
    }


    
    copy()
    {
        const copy = new GComment(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = NullValue;


        genPushUpdateValue(parse, this.nodeId, 'value', this.value);
        
        
        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy() 
             : null;
    }
}



class GList
extends GOperator
{
    inputs = [];

    value;



    constructor(nodeId, options)
    {
        super(LIST, nodeId, options);
    }


    
    copy()
    {
        const copy = new GList(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());
        copy.value  = this.value.copy();

        return copy;
    }



    eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = new ListValue();

        for (let i = 0; i < this.inputs.length; i++)
        {
            const input = this.inputs[i].eval(parse).toValue();

            if (input.type == LIST_VALUE)
            {
                for (const item of input.items)
                    this.value.items.push(item);   
            }
            else
                this.value.items.push(input);
        }
    

        genPushUpdateValue(parse, this.nodeId, 'value', this.value);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value.copy();
    }
}



class GItems
extends GOperator
{
    input = null;

    //item0
    //item1
    //item2
    //...



    constructor(nodeId, options)
    {
        super(ITEMS, nodeId, options);
    }



    copy()
    {
        const copy = new GItems(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();
        
        for (const key of this.keys())
        {
            if (   key.length > 4
                && key.substring(0, 4) == 'item')
                Object.assign(copy, {[key]: this[key]});
        }

        return copy;
    }



    eval(parse)
    {
        if (this.isCached())
            return this;


        if (this.input)
        {
            if (!this.input.value)
                this.input.eval(parse);

            this.value = this.input.toValue();
        }
        else
            this.value = ListValue.NaN;


        if (    this.value.isValid()
            && !isEmpty(this.value.items))
        {
            for (let i = 0; i < this.value.items.length; i++)
            {
                const item = this.value.items[i];

                Object.assign(this, {['item' + i]: item});
                genPushUpdateValue(parse, this.nodeId, 'item' + i, item);
            }
        }
        else
            genPushUpdateValue(parse, this.nodeId, '', NullValue);


        this.validate();

        return this;
    }



    getParamFromId(paramId)
    {
        if (   paramId.length > 4
            && paramId.substring(0, 4) == 'item'
            && strIsNum(paramId.substring(4)))
            return this[paramId];

        return null;
    }



    toValue()
    {
        return this.value.copy();
    }
}


class GSelect
extends GOperator
{
    input = null;
    
    index;



    constructor(nodeId, options)
    {
        super(SELECT, nodeId, options);
    }



    copy()
    {
        const copy = new GSelect(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();
        
        copy.index = this.index.copy();

        return copy;
    }



    eval(parse)
    {
        if (this.isCached())
            return this;


        let index = this.index.eval(parse).toValue();
        index = new NumberValue(Math.round(index.value));


        let length = 0;


        if (this.input)
        {
            if (!this.input.value)
                this.input.eval(parse);

            const input = this.input.toValue();
            length = input.items.length;

            index.value = Math.min(index.value, input.items.length-1);

            this.value = input.items[index.value];
        }
        else
        {
            this.value = null;
        }


        if (this.value)
            genPushUpdateValue(parse, this.nodeId, 'value', this.value);
            

        genPushUpdateValue(parse, this.nodeId, 'index',  index);
        genPushUpdateValue(parse, this.nodeId, 'length', new NumberValue(length));


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value.copy();
    }
}


class GIfElse
extends GOperator
{
    input0 = null;
    input1 = null;

    condition;



    constructor(nodeId, options)
    {
        super(IF_ELSE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GIfElse(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input    ) copy.input     = this.input    .copy();
        if (this.condition) copy.condition = this.condition.copy();
        if (this.value    ) copy.value     = this.value    .copy();

        return copy;
    }



    eval(parse)
    {
        if (this.isCached())
            return this;

        
        const cond = this.condition.eval(parse).toValue();


        if (   this.input0 
            && this.input1)
        {
            const val0 = this.input0.eval(parse).toValue();
            const val1 = this.input1.eval(parse).toValue();

            this.value = cond.value != 0 ? val0 : val1;
        }
        else if (this.input0
              && cond.value != 0)
            this.value = this.input0.eval(parse).toValue();

        else if (this.input1
              && cond.value == 0) 
            this.value = this.input1.eval(parse).toValue();

        else                  
            this.value = NumberValue.NaN;


        genPushUpdateValue(parse, this.nodeId, 'condition', cond);
        genPushUpdateValue(parse, this.nodeId, 'value',     this.value);
        
        
        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy() 
             : null;
    }
}



class GStart
extends GOperator
{
    input = null;



    constructor(nodeId, options)
    {
        super(START, nodeId, options);
    }


    
    copy()
    {
        const copy = new GStart(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) copy.input = this.input.copy();
        if (this.value) copy.value = this.value.copy();

        return copy;
    }



    eval(parse)
    {
        if (this.input)
        {
            this.input = this.input.eval(parse).copy();
            this.value = this.input.toValue();
        }
        else
            this.value = null;

        
        this.validate();

        return this;
    }



    toValue()
    {
        return this.value ? this.value.copy() : null;
    }
}



class GRepeat
extends GOperator
{
    input = null;

    count;



    constructor(nodeId, options)
    {
        super(REPEAT, nodeId, options);
    }


    
    copy()
    {
        const copy = new GRepeat(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) copy.input = this.input.copy();

        copy.count = this.count.copy();
        copy.value = this.value.copy();

        return copy;
    }



    eval(parse)
    {
        if (this.isCached())
            return this;


        let count = this.count.eval(parse).toValue();
        count = new NumberValue(Math.round(count.value));

       
        this.value = new ListValue();

        if (this.input)
        {
            for (let i = 0; i < count.value; i++)
            {
                const input = this.input.eval(parse).toValue();

                if (input)
                {
                    if (input.type == LIST_VALUE)
                    {
                        for (const item of input.items)
                            this.value.items.push(item);
                    }
                    else
                        this.value.items.push(input);
                }
            }
        }

        
        genPushUpdateValue(parse, this.nodeId, 'count', count);
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value.copy();
    }
}



class GCache
extends GOperator
{
    input = null;



    constructor(nodeId, options)
    {
        super(CACHE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GCache(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) copy.input = this.input.copy();
        if (this.value) copy.value = this.value.copy();

        return copy;
    }



    eval(parse)
    {
        if (this.valid)//isCached())
            return this;


        this.value = 
            this.input
            ? this.input.eval(parse).toValue()
            : NullValue;


        genPushUpdateValue(parse, this.nodeId, 'value', this.value);
        
        
        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy() 
             : null;
    }
}



class GCopy
extends GOperator
{
    input = null;

    copy;


    constructor(nodeId, options)
    {
        super(COPY, nodeId, options);
    }


    
    copy()
    {
        const copy = new GCopy(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) copy.input = this.input.copy();
        if (this.value) copy.value = this.value.copy();
        if (this.copy)  copy.copy  = this.copy .copy();

        return copy;
    }



    eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = this.input ? this.input.eval(parse).toValue() : NullValue;
        this.copy  = this.value ? this.value.copy()                : NullValue;


        genPushUpdateValue(parse, this.nodeId, 'value', this.value);
        genPushUpdateValue(parse, this.nodeId, 'copy',  this.copy);

        
        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy() 
             : null;
    }
}



class GNumberType
extends GOperator
{
    value;
    


    copyBase(src)
    {
        super.copyBase(src);

        if (src.value) this.value = src.value.copy();
    }



    toValue()
    {
        return this.value.copy();
    }
}


class GArithmetic
extends GNumberType
{
    inputs = [];
}



class GMath
extends GArithmetic
{
    operation;



    constructor(nodeId, options)
    {
        super(NUMBER_MATH, nodeId, options);
    }


    
    copy()
    {
        const copy = new GMath(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs    = this.inputs.map(i => i.copy());
        copy.operation = this.operation.copy();

        return copy;
    }



    eval(parse)
    {
        if (this.isCached())
            return this;


        const op = this.operation.eval(parse).toValue().toInteger();

        op.value = Math.min(Math.max(0, op.value), MATH_OPS.length-1);

        switch (op.value)
        {
            case 0: this.value = evalSubtractInputs(this.inputs, parse); break;
            case 1: this.value = evalAddInputs     (this.inputs, parse); break;
            case 2: this.value = evalModuloInputs  (this.inputs, parse); break;
            case 3: this.value = evalDivideInputs  (this.inputs, parse); break;
            case 4: this.value = evalMultiplyInputs(this.inputs, parse); break;
            case 5: this.value = evalExponentInputs(this.inputs, parse); break;
        }

        
        genPushUpdateValue(parse, this.nodeId, 'operation', op);
        genPushUpdateValue(parse, this.nodeId, 'value',     this.value);



        this.validate();

        return this;
    }
}



class GAdd
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_ADD, nodeId, options);
    }


    
    copy()
    {
        const copy = new GAdd(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    eval(parse)
    {
        if (this.isCached())
            return this;

        this.value = evalAddInputs(this.inputs, parse);
        
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}



function evalAddInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    const value = new NumberValue(0);


    for (let i = 0; i < inputs.length; i++)
    {
        const val = inputs[i].eval(parse).toValue();

        console.assert(
            val.type == NUMBER_VALUE, 
            'val.type must belong to NUMBER_VALUE');

        value.value   += val.value;
        value.decimals = Math.max(value.decimals, val.decimals);
    }


    return value;
}


class GSubtract
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_SUBTRACT, nodeId, options);
    }


    
    copy()
    {
        const copy = new GSubtract(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    eval(parse)
    {
        if (this.isCached())
            return this;

        this.value = evalSubtractInputs(this.inputs, parse);

        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}



function evalSubtractInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    const value = new NumberValue(0);


    if (!isEmpty(inputs))
    {
        const val0 = inputs[0].eval(parse).toValue();

        value.value    = val0.value;
        value.decimals = val0.decimals;


        for (let i = 1; i < inputs.length; i++)
        {
            const val = inputs[i].eval(parse).toValue();

            console.assert(
                val.type == NUMBER_VALUE, 
                'val.type must be NUMBER_VALUE');
                
            value.value   -= val.value;
            value.decimals = Math.max(value.decimals, val.decimals);
        }
    }


    return value;
}


class GMultiply
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_MULTIPLY, nodeId, options);
    }



    copy()
    {
        const copy = new GMultiply(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }

    

    eval(parse)
    {
        if (this.isCached())
            return this;

        this.value = evalMultiplyInputs(this.inputs, parse);

        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}



function evalMultiplyInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    const value = new NumberValue(0);


    if (!isEmpty(inputs))
    {
        value.value = 1;

        for (let i = 0; i < inputs.length; i++)
        {
            const val = inputs[i].eval(parse).toValue();

            console.assert(
                val.type == NUMBER_VALUE, 
                'val.type must be NUMBER_VALUE');

            value.value   *= val.value;
            value.decimals = Math.max(value.decimals, val.decimals);
        }
    }


    return value;
}


class GDivide
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_DIVIDE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GDivide(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    eval(parse)
    {
        if (this.isCached())
            return this;

        this.value = evalDivideInputs(this.inputs, parse);
        
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}



function evalDivideInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;

        
    const value = new NumberValue(0);

        
    if (!isEmpty(inputs))
    {
        const val0 = inputs[0].eval(parse).toValue();

        value.value    = val0.value;
        value.decimals = val0.decimals;


        for (let i = 1; i < inputs.length; i++)
        {
            const val = inputs[i].eval(parse).toValue();

            console.assert(
                val.type == NUMBER_VALUE, 
                'val.type must be NUMBER_VALUE');

            if (val.value == 0) 
            { 
                value.value    = Number.NaN; 
                value.decimals = 0;
                break; 
            }

            value.decimals = Math.max(value.decimals, val.decimals);
            value.value    = floorTo(value.value / val.value, value.decimals);
        }
    }


    return value;
}


class GModulo
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_MODULO, nodeId, options);
    }


    
    copy()
    {
        const copy = new GModulo(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    eval(parse)
    {
        if (this.isCached())
            return this;

        this.value = evalModuloInputs(this.inputs, parse);

        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}



function evalModuloInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;

        
    const value = new NumberValue(0);

        
    if (!isEmpty(inputs))
    {
        const val0 = inputs[0].eval(parse).toValue();

        value.value    = val0.value;
        value.decimals = val0.decimals;


        for (let i = 1; i < inputs.length; i++)
        {
            const val = inputs[i].eval(parse).toValue();

            console.assert(
                val.type == NUMBER_VALUE, 
                'val.type must be NUMBER_VALUE');

            if (val.value == 0) 
            { 
                value.value    = Number.NaN; 
                value.decimals = 0;
                break; 
            }

            value.decimals = Math.max(value.decimals, val.decimals);
            value.value    = floorTo(value.value % val.value, value.decimals);
        }
    }


    return value;
}


class GExponent
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_EXPONENT, nodeId, options);
    }


    
    copy()
    {
        const copy = new GExponent(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    eval(parse)
    {
        if (this.isCached())
            return this;

        this.value = evalExponentInputs(this.inputs, parse);

        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}



function evalExponentInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    const value = new NumberValue(0);


    if (!isEmpty(inputs))
    {
        const val0 = inputs[0].eval(parse).toValue();

        value.value    = val0.value;
        value.decimals = val0.decimals;


        for (let i = 1; i < inputs.length; i++)
        {
            const val = inputs[i].eval(parse).toValue();

            console.assert(
                val.type == NUMBER_VALUE, 
                'val.type must be NUMBER_VALUE');
                
            value.value    = Math.pow(value.value,    val.value);
            value.decimals = Math.max(value.decimals, val.decimals);
        }
    }


    return value;
}


class GBoolean
extends GArithmetic
{
    operation;



    constructor(nodeId, options)
    {
        super(NUMBER_BOOLEAN, nodeId, options);
    }


    
    copy()
    {
        const copy = new GBoolean(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs    = this.inputs.map(i => i.copy());
        copy.operation = this.operation.copy();

        return copy;
    }



    eval(parse)
    {
        if (this.isCached())
            return this;


        const op = this.operation.eval(parse).toValue().toInteger();

        op.value = Math.min(Math.max(0, op.value), BOOLEAN_OPS.length-1);

        
        switch (op.value)
        {
            case BOOLEAN_NOT: this.value = evalNandInputs(this.inputs, parse); break;
            case BOOLEAN_AND: this.value = evalAndInputs (this.inputs, parse); break;
            case BOOLEAN_OR:  this.value = evalOrInputs  (this.inputs, parse); break;
            case BOOLEAN_XOR: this.value = evalXorInputs (this.inputs, parse); break;
        }

        
        genPushUpdateValue(parse, this.nodeId, 'operation', op);
        genPushUpdateValue(parse, this.nodeId, 'value',     this.value);


        this.validate();

        return this;
    }
}


class GNot
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_NOT, nodeId, options);
    }


    
    copy()
    {
        const copy = new GNot(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    eval(parse)
    {
        if (this.isCached())
            return this;

        this.value = evalNandInputs(this.inputs, parse);
        
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}



function evalNandInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    const value = new NumberValue();


    if (!isEmpty(inputs))
    {
        const val0 = inputs[0].eval(parse).toValue();
        if (!val0.isValid()) return NumberValue.NaN;

        value.value = val0.toNumber() != 0 ? 0 : 1;


        for (let i = 1; i < inputs.length; i++)
        {
            const val = inputs[i].eval(parse).toValue();
            if (!val.isValid()) return NumberValue.NaN;

            console.assert(
                val.type == NUMBER_VALUE, 
                'val.type must belong to NUMBER_VALUE');

            if (val.toNumber() == 0)
                value.value = 1;
        }
    }


    return value;
}



class GAnd
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_AND, nodeId, options);
    }


    
    copy()
    {
        const copy = new GAnd(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    eval(parse)
    {
        if (this.isCached())
            return this;

        this.value = evalAndInputs(this.inputs, parse);
        
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}



function evalAndInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    const value = new NumberValue();


    if (!isEmpty(inputs))
    {
        const val0 = inputs[0].eval(parse).toValue();
        if (!val0.isValid()) return NumberValue.NaN;

        value.value = val0.toNumber();


        for (let i = 1; i < inputs.length; i++)
        {
            const val = inputs[i].eval(parse).toValue();
            if (!val.isValid()) return NumberValue.NaN;

            console.assert(
                val.type == NUMBER_VALUE, 
                'val.type must be NUMBER_VALUE');
                
            value.value = Math.min(value.value, val.toNumber());
        }

        
        if (value.value != 0)
            value.value = 1;
    }


    return value;
}


class GOr
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_OR, nodeId, options);
    }


    
    copy()
    {
        const copy = new GOr(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    eval(parse)
    {
        if (this.isCached())
            return this;

        this.value = evalOrInputs(this.inputs, parse);
        
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}



function evalOrInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    const value = new NumberValue();


    if (!isEmpty(inputs))
    {
        const val0 = inputs[0].eval(parse).toValue();
        if (!val0.isValid()) return NumberValue.NaN;

        value.value = val0.toNumber();


        for (let i = 1; i < inputs.length; i++)
        {
            const val = inputs[i].eval(parse).toValue();
            if (!val.isValid()) return NumberValue.NaN;

            console.assert(
                val.type == NUMBER_VALUE, 
                'val.type must be NUMBER_VALUE');
                
            value.value = Math.max(value.value, val.toNumber());
        }


        if (value.value != 0)
            value.value = 1;
    }


    return value;
}


class GXor
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_XOR, nodeId, options);
    }


    
    copy()
    {
        const copy = new GXor(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    eval(parse)
    {
        if (this.isCached())
            return this;

        this.value = evalXorInputs(this.inputs, parse);
        
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}



function evalXorInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    const value = new NumberValue();


    let flipped;

    if (!isEmpty(inputs))
    {
        const val0 = inputs[0].eval(parse).toValue();
        if (!val0.isValid()) return NumberValue.NaN;

        flipped = val0.toNumber() != 0;


        for (let i = 1; i < inputs.length; i++)
        {
            const val = inputs[i].eval(parse).toValue();
            if (!val.isValid()) return NumberValue.NaN;

            console.assert(
                val.type == NUMBER_VALUE, 
                'val.type must be NUMBER_VALUE');
                
            if (val.toNumber() != 0)
                flipped++;
        }


        value.value = flipped == 1 ? 1 : 0;
    }


    return value;
}


class GConditionBase
extends GNumberType
{
    input0 = null;
    input1 = null;
}



function evalConditionInputs(input0, input1, op, parse) 
{
    const val0 = input0 ? input0.eval(parse).toValue() : NumberValue.NaN;
    const val1 = input1 ? input1.eval(parse).toValue() : NumberValue.NaN;

    if (   input0 
        && input1)
        return new NumberValue(op(val0.toNumber(), val1.toNumber()) ? 1 : 0);
    else                  
        return NumberValue.NaN;
}


class GCondition
extends GNumberType
{
    input0 = null;
    input1 = null;

    operation;



    constructor(nodeId, options)
    {
        super(NUMBER_CONDITION, nodeId, options);
    }


    
    copy()
    {
        const copy = new GCondition(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input0) copy.input0 = this.input0.copy();
        if (this.input1) copy.input1 = this.input1.copy();

        copy.operation = this.operation.copy();

        return copy;
    }



    eval(parse)
    {
        if (this.isCached())
            return this;


        const op = this.operation.eval(parse).toValue().toInteger();

        op.value = Math.min(Math.max(0, op.value), CONDITION_OPS.length-1);

        
        switch (op.value)
        {
            case CONDITION_LESS:              this.value = evalConditionInputs(this.input0, this.input1, ((a, b) => a <  b), parse);  break;
            case CONDITION_LESS_OR_EQUAL:     this.value = evalConditionInputs(this.input0, this.input1, ((a, b) => a <= b), parse);  break;
            case CONDITION_NOT_EQUAL:         this.value = evalConditionInputs(this.input0, this.input1, ((a, b) => a != b), parse);  break;
            case CONDITION_EQUAL:             this.value = evalConditionInputs(this.input0, this.input1, ((a, b) => a == b), parse);  break;
            case CONDITION_GREATER_OR_EQUAL:  this.value = evalConditionInputs(this.input0, this.input1, ((a, b) => a >= b), parse);  break;
            case CONDITION_GREATER:           this.value = evalConditionInputs(this.input0, this.input1, ((a, b) => a >  b), parse);  break;
        }


        genPushUpdateValue(parse, this.nodeId, 'operation', op);
        genPushUpdateValue(parse, this.nodeId, 'value',     this.value);


        this.validate();

        return this;
    }
}


class GEqual
extends GConditionBase
{
    constructor(nodeId, options)
    {
        super(NUMBER_EQUAL, nodeId, options);
    }


    
    copy()
    {
        const copy = new GEqual(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    eval(parse)
    {
        if (this.isCached())
            return this;

        this.value = evalConditionInputs(
            this.input0, 
            this.input1, 
            (a, b) => a == b, 
            parse);
            
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}



class GNotEqual
extends GConditionBase
{
    constructor(nodeId, options)
    {
        super(NUMBER_NOT_EQUAL, nodeId, options);
    }


    
    copy()
    {
        const copy = new GNotEqual(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    eval(parse)
    {
        if (this.isCached())
            return this;

        this.value = evalConditionInputs(
            this.input0, 
            this.input1, 
            (a, b) => a != b, 
            parse);
        
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}


class GLess
extends GConditionBase
{
    constructor(nodeId, options)
    {
        super(NUMBER_LESS, nodeId, options);
    }


    
    copy()
    {
        const copy = new GLess(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    eval(parse)
    {
        if (this.isCached())
            return this;

            this.value = evalConditionInputs(
                this.input0, 
                this.input1, 
                (a, b) => a < b, 
                parse);
            
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}


class GLessOrEqual
extends GConditionBase
{
    constructor(nodeId, options)
    {
        super(NUMBER_LESS_OR_EQUAL, nodeId, options);
    }


    
    copy()
    {
        const copy = new GLessOrEqual(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    eval(parse)
    {
        if (this.isCached())
            return this;

            this.value = evalConditionInputs(
                this.input0, 
                this.input1, 
                (a, b) => a <= b, 
                parse);
            
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}



class GGreater
extends GConditionBase
{
    constructor(nodeId, options)
    {
        super(NUMBER_GREATER, nodeId, options);
    }


    
    copy()
    {
        const copy = new GGreater(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    eval(parse)
    {
        if (this.isCached())
            return this;

        this.value = evalConditionInputs(
            this.input0, 
            this.input1, 
            (a, b) => a > b, 
            parse);
        
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}


class GGreaterOrEqual
extends GConditionBase
{
    constructor(nodeId, options)
    {
        super(NUMBER_GREATER_OR_EQUAL, nodeId, options);
    }


    
    copy()
    {
        const copy = new GGreaterOrEqual(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        return copy;
    }



    eval(parse)
    {
        if (this.isCached())
            return this;

        this.value = evalConditionInputs(
            this.input0, 
            this.input1, 
            (a, b) => a >= b, 
            parse);
            
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}



class GNumber
extends GNumberType
{
    input = null;
    


    constructor(nodeId, options)
    {
        super(NUMBER, nodeId, options);
    }



    copy()
    {
        const copy = new GNumber(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();
        
        copy.value = this.value;

        return copy;
    }



    eval(parse)
    {
        if (this.isCached())
            return this;

            
        if (this.input)
            this.value = this.input.eval(parse).toValue();
        else if (this.value)
            this.value.eval(parse);
        else
            this.value = NumberValue.NaN;


        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        
        this.validate();

        return this;
    }



    isValid()
    {
        return !isNaN(this.value)
            && !isNaN(this.decimals);
    }
}


class GRound
extends GNumberType
{
    input = null;

    type;
    decimals;



    constructor(nodeId, options)
    {
        super(NUMBER_ROUND, nodeId, options);
    }


    
    copy()
    {
        const copy = new GRound(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        copy.type     = this.type    .copy();
        copy.decimals = this.decimals.copy();

        return copy;
    }



    eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = new NumberValue(0);

        
        const type = this.type    .eval(parse).toValue();
        const dec  = this.decimals.eval(parse).toValue();


        if (this.input)
        {
            this.value = this.input.eval(parse).toValue();

            console.assert(
                this.value.type == NUMBER_VALUE, 
                'this.value.type must belong to NUMBER_VALUE');

            switch (type.value)
            {
                case 0: this.value.value = floorTo(this.value.value, dec.value); break;
                case 1: this.value.value = roundTo(this.value.value, dec.value); break;
                case 2: this.value.value =  ceilTo(this.value.value, dec.value); break;
            }

            this.value.decimals = dec.value;
        }
        else
            this.value = NumberValue.NaN;


        genPushUpdateValue(parse, this.nodeId, 'type',     type);
        genPushUpdateValue(parse, this.nodeId, 'decimals', dec );
        genPushUpdateValue(parse, this.nodeId, 'value',    this.value);


        this.validate();

        return this;
    }
}



class GAbsolute
extends GNumberType
{
    input = null;



    constructor(nodeId, options)
    {
        super(NUMBER_ABSOLUTE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GAbsolute(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        return copy;
    }



    eval(parse)
    {
        if (this.isCached())
            return this;


        if (this.input)
        {
            this.value = this.input.eval(parse).toValue();

            console.assert(
                this.value.type == NUMBER_VALUE, 
                'this.value.type must belong to NUMBER_VALUE');

            this.value.value = Math.abs(this.value.value);
        }
        else
            this.value = NumberValue.NaN;


        genPushUpdateValue(parse, this.nodeId, 'value', this.value);


        this.validate();

        return this;
    }
}



class GLimits
extends GNumberType
{
    input = null;

    min;
    max;

    //minMaxPriority = -1; 


    constructor(nodeId, options)
    {
        super(NUMBER_LIMITS, nodeId, options);
    }


    
    copy()
    {
        const copy = new GLimits(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        copy.min = this.min.copy();
        copy.max = this.max.copy();

        //lim.minMaxPriority = this.minMaxPriority;

        return copy;
    }



    eval(parse)
    {
        if (this.isCached())
            return this;


        const min = this.min.eval(parse).toValue();
        const max = this.max.eval(parse).toValue();


        if (this.input)
        {
            this.value = this.input.eval(parse).toValue();

            console.assert(
                this.value.type == NUMBER_VALUE, 
                'this.value.type must belong to NUMBER_VALUE');

            this.value.value = Math.min(Math.max(
                min.value,
                this.value.value),
                max.value);
        }
        else
            this.value = NumberValue.NaN;


        genPushUpdateValue(parse, this.nodeId, 'min',   min);
        genPushUpdateValue(parse, this.nodeId, 'max',   max);
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);


        this.validate();

        return this;
    }
}



class GSeries
extends GNumberType
{
    start;
    step;

    current;



    constructor(nodeId, options)
    {
        super(NUMBER_SERIES, nodeId, options);
    }


    
    copy()
    {
        const copy = new GSeries(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.start  ) copy.start   = this.start  .copy();
        if (this.step   ) copy.step    = this.step   .copy();

        if (this.current) copy.current = this.current.copy();

        return copy;
    }



    eval(parse)
    {
        //logString('GSeries.eval()');

        if (!this.valid)
        {
            this.start.eval(parse);
            this.step .eval(parse);
        }


        const start = this.start.toValue();
        const step  = this.step .toValue();
    

        if (!this.valid)
            this.current = start.copy();

        
        this.value = new NumberValue(
            this.current.value,
            Math.max(start.decimals, step.decimals));

        this.current.value += step.value;


        //if (!this.valid)
        //{
            genPushUpdateValue(parse, this.nodeId, 'start', start);
            genPushUpdateValue(parse, this.nodeId, 'step',  step );
        //}
        

        this.validate();

        return this;
    }
}



class GRandom
extends GNumberType
{
    seed;
    min;
    max;

    random = null;



    constructor(nodeId, options)
    {
        super(NUMBER_RANDOM, nodeId, options);
    }


    
    copy()
    {
        const copy = new GRandom(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.seed  ) copy.seed   = this.seed  .copy();
        if (this.min   ) copy.min    = this.min   .copy();
        if (this.max   ) copy.max    = this.max   .copy();

        if (this.random) copy.random = this.random.copy();

        return copy;
    }



    eval(parse)
    {
        if (this.isCached())
            return this;

            
        const seed = this.seed.eval(parse).toValue();
        const min  = this.min .eval(parse).toValue();
        const max  = this.max .eval(parse).toValue();
    

        if (!this.valid)
            this.random = new Random(seed.value);

        
        this.value = new NumberValue(
            min.value + this.random.next() * (max.value - min.value),
            Math.max(min.decimals, max.decimals));


        if (!this.valid)
        {
            genPushUpdateValue(parse, this.nodeId, 'seed', seed);
            genPushUpdateValue(parse, this.nodeId, 'min',  min );
            genPushUpdateValue(parse, this.nodeId, 'max',  max );
        }
        

        this.validate();

        return this;
    }
}



class GInterpolate
extends GNumberType
{
    input0 = null;
    input1 = null;

    amount;


    constructor(nodeId, options)
    {
        super(NUMBER_INTERPOLATE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GInterpolate(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input0) copy.input0 = this.input0.copy();
        if (this.input1) copy.input1 = this.input1.copy();

        copy.amount = this.amount.copy();

        return copy;
    }



    eval(parse)
    {
        if (this.isCached())
            return this;


        const amount = this.amount.eval(parse).toValue();


        if (   this.input0 
            && this.input1)
        {
            const val0 = this.input0.eval(parse).toValue();
            const val1 = this.input1.eval(parse).toValue();

            const maxDec = Math.max(val0.decimals, val1.decimals);

            this.value = new NumberValue(
                floorTo(val0.value + amount.value * (val1.value - val0.value) / 100, maxDec),
                maxDec);
        }
        else if (this.input0)
            this.value = this.input0.eval(parse).toValue();

        else if (this.input1) 
            this.value = this.input1.eval(parse).toValue();

        else                  
            this.value = NumberValue.NaN;


        genPushUpdateValue(parse, this.nodeId, 'amount', amount);
        genPushUpdateValue(parse, this.nodeId, 'value',  this.value);


        this.validate();

        return this;
    }
}



class ColorCorrection
{
    name; // 'H', 'C', or 'L'
    max;
    value;
    
    constructor(name = '', max = 0, value = 0)//, locked = false)
    {
        this.name  = name;
        this.max   = max;
        this.value = value;
    }
}



function findCorrection(nodeId,
                        color,
                        order,       margin1, margin2, margin3,
                        lockedOrder, locked1, locked2, locked3) 
{
    const refOklab = dataColor2array(dataColor2oklab(color));

    
    let closestColor = [...color],
        closestOklab = null, 
        closestOrder = order ? order.value : -1,
        closest1     = -1,
        closest2     = -1,
        closest3     = -1;


    let progress = 0,
        total    = 6 * Math.pow(2, Tau);


    let d = 1;

    //dLoop:
    while (d > 1/1024)
    {
        //if (stopGenerate) break dLoop;

        let _closestColor = [...closestColor];


        for (let _order = 0; _order < 6; _order++)
        {
            //if (stopGenerate) break dLoop;

            closestColor = [..._closestColor];

            const [min1, min2, min3] = getMinCorrections(color[0], _order);
            const [max1, max2, max3] = getMaxCorrections(color[0], _order);

            let start1 = lerp(min1, closest1, 1-d),  end1 = lerp(max1, closest1, 1-d),
                start2 = lerp(min2, closest2, 1-d),  end2 = lerp(max2, closest2, 1-d),
                start3 = lerp(min3, closest3, 1-d),  end3 = lerp(max3, closest3, 1-d);
               
                
            if (locked1) { closest1 = margin1.toNumber(); start1 = closest1; end1 = closest1+Epsilon; }
            if (locked2) { closest2 = margin2.toNumber(); start2 = closest2; end2 = closest2+Epsilon; }
            if (locked3) { closest3 = margin3.toNumber(); start3 = closest3; end3 = closest3+Epsilon; }
            

          [ closestColor,
            closestOklab,
            closestOrder,
            closest1,
            closest2,
            closest3,
            progress ] = findCorrectionInOrder(
                nodeId,
                refOklab,
                _order, 
                lockedOrder, 
                locked1,  locked2,  locked3,
                closest1, closest2, closest3,
                start1,   start2,   start3, 
                end1,     end2,     end3,
                [...closestColor],
                closestOklab, 
                closestOrder,
                progress,
                total);
        }

        
        d /= 2;
    }


    //if (!stopGenerate)
    //{
        // reduce closest to necessary minimums

        const closestRgb = getCorrectedColor(color, closestOrder, closest1, closest2, closest3)[2];

        let c1 = closest1;
        let c2 = closest2;
        let c3 = closest3;

        while (c1 >= 0 && rgbEqual(getCorrectedColor(color, closestOrder, c1-1, closest2, closest3)[2], closestRgb)) c1--;
        while (c2 >= 0 && rgbEqual(getCorrectedColor(color, closestOrder, closest1, c2-1, closest3)[2], closestRgb)) c2--;
        while (c3 >= 0 && rgbEqual(getCorrectedColor(color, closestOrder, closest1, closest2, c3-1)[2], closestRgb)) c3--;

        closest1 = Math.max(0, c1);
        closest2 = Math.max(0, c2);
        closest3 = Math.max(0, c3);
    //}

    
    //stopGenerate = false;


    return [
        closestOrder,
        closest1,
        closest2,
        closest3 ];
}



function findCorrectionInOrder(nodeId,
                               refOklab,
                               order, 
                               lockedOrder, 
                               locked1,  locked2,  locked3,
                               closest1, closest2, closest3,
                               start1,   start2,   start3, 
                               end1,     end2,     end3,
                               closestColor,
                               closestOklab,
                               closestOrder,
                               progress,
                               total)
{
    const color = [...closestColor];
    
    let nSteps1 = locked1 ? 1 : 2;
    let nSteps2 = locked2 ? 1 : 2;
    let nSteps3 = locked3 ? 1 : 2;


    cLoop:
    for (let m1 = start1; m1 < end1; m1 += (end1-start1)/nSteps1)
    {
        //if (stopGenerate) break cLoop;

        for (let m2 = start2; m2 < end2; m2 += (end2-start2)/nSteps2)
        {
            //if (stopGenerate) break cLoop;

            for (let m3 = start3; m3 < end3; m3 += (end3-start3)/nSteps3)
            {
                //if (stopGenerate) break cLoop;

                const [_color, _oklab, _rgb] = getCorrectedColor(color, order, m1, m2, m3);

                if (   rgbIsOk(_rgb)
                    && (  !closestOklab
                        || rgbDistance(refOklab, _oklab) < rgbDistance(refOklab, closestOklab)))
                {
                    closestColor = _color;
                    closestOklab = _oklab;
                    
                    if (!lockedOrder)
                        closestOrder = order;

                    closest1     = m1;
                    closest2     = m2;
                    closest3     = m3;
                }

                progress++;
            }
        }

        //if (!stopGenerate)
            genQueueMessageToUI(
            {
                cmd:     'uiUpdateNodeProgress',
                nodeId:   nodeId,
                progress: progress / total
            });
    }

    
    return [
        closestColor,
        closestOklab,
        closestOrder,
        closest1,
        closest2,
        closest3,
        progress ];
}



function getCorrectedColor(color, order, m1, m2, m3)
{
    const _color = correctColor(color, order, m1, m2, m3);
    const oklab  = dataColor2array(dataColor2oklab(_color));
    const rgb    = oklab2rgb(oklab);

    return [_color, oklab, rgb];
}



function correctColor(color, order, margin1, margin2, margin3)
{
    if (order < 0)
        return color;


    const [i1, i2, i3] = getCorrectionsInOrder(order);

                               color = correctChannel(color, i1, margin1);
    if (!dataColorIsOk(color)) color = correctChannel(color, i2, margin2);
    if (!dataColorIsOk(color)) color = correctChannel(color, i3, margin3);


    // clip colors that are reasonably valid but stick over the fence
    
    let rgb = dataColor2rgb(color);

    if (rgbIsOk(rgb))
        rgb = invalid2validRgb(rgb);

    color = rgb2dataColor(rgb);

    
    return color;
}



function correctChannel(color, iChan, margin)
{
    const factor = colorSpaceFactor(color[0]);

    margin /= factor[iChan];


    const savedColor = [...color];
    const savedValue = color[iChan+1];

    const d = 0.001;


    let _c  = savedValue,
         c_ = savedValue;

    let _valid  = dataColorIsOk(color);
    let  valid_ = _valid;


    let stackOverflowProtect = 1/d;


    while (   !_valid
           && ! valid_
           && stackOverflowProtect-- > 0)
    {
        _c  -= d;  _valid  = isColorOk(_c , iChan, savedColor);
         c_ += d;   valid_ = isColorOk( c_, iChan, savedColor);
    }


    stackOverflowProtect = 1/d;
    color = [...savedColor];


    if (_valid) 
    { 
        _valid = dataColorIsOk(color);
        _c     = savedValue;

        while (   !_valid
               && margin > 0
               && stackOverflowProtect-- > 0)
        {
            _c -= d; 
            _valid = isColorOk(_c, iChan, savedColor);
            margin -= d;
        }

        color[iChan+1] = _c;
    }
    else if (valid_)
    { 
        valid_ = dataColorIsOk(color);
        c_     = savedValue;

        while (   !valid_
               && margin > 0
               && stackOverflowProtect-- > 0)
        {
            c_ += d; 
            valid_ = isColorOk(c_, iChan, savedColor);
            margin -= d;
        }

        color[iChan+1] = c_;
    }


    return color;
}



function isColorOk(c, iChan, savedColor)
{
    let color = [...savedColor];
    color[iChan+1] = c; 
    return dataColorIsOk(color);
}



function getCorrectionsInOrder(order)
{
    switch (order)
    {
        case 0: return [0, 1, 2];
        case 1: return [1, 0, 2];
        case 2: return [1, 2, 0];
        case 3: return [0, 2, 1];
        case 4: return [2, 0, 1];
        case 5: return [2, 1, 0];
    }

    // should never get here
    console.assert(false, 'invalid correction order ' + order);
    return [0, 0, 0];
}



function getMinCorrections(space, order)
{
    const [c1, c2, c3] = getCorrectionsInOrder(order);

    let min;

    switch (space)
    {
        case 'hex':
        case 'rgb':    min = [0, 0, 0]; break

        case 'hsv': 
        case 'hsl':    min = [0, 0, 0]; break;

        case 'hclok':
        case 'hclab':
        case 'hcluv': min = [0, 0, 0]; break;

        case 'oklab':
        case 'lab':
        case 'luv':    min = [0, -oppFactor[1]/2, -oppFactor[2]/2]; break;
        
        default:
            // should never get here
            console.assert(false, 'invalid validation order ' + order);
            return [0, 0, 0];
    }

    return [min[c1], min[c2], min[c3]];
}



function getMaxCorrections(space, order)
{
    const [c1, c2, c3] = getCorrectionsInOrder(order);

    let max;

    switch (space)
    {
        case 'hex':
        case 'rgb':    max = [...rgbFactor]; break;

        case 'hsv': 
        case 'hsl':    max = [hs_Factor[0]/2, hs_Factor[1], hs_Factor[2]]; break;

        case 'hclok':
        case 'hclab':
        case 'hcluv': max = [hclFactor[0]/2, hclFactor[1], hclFactor[2]]; break;

        case 'oklab':
        case 'lab':
        case 'luv':    max = [...oppFactor]; break;
        
        default:
            // should never get here
            console.assert(false, 'invalid validation order ' + order);
            return [0, 0, 0];
    }

    return [max[c1], max[c2], max[c3]];
}



function reorderCorrection(closestOrder,
                           closest1, closest2, closest3,
                           locked1,  locked2,  locked3)
{
    let c1 = { closest: closest1, locked: locked1 };
    let c2 = { closest: closest2, locked: locked2 };
    let c3 = { closest: closest3, locked: locked3 };

    if (   c1.closest <  Epsilon
        && c2.closest <  Epsilon
        && c3.closest >= Epsilon)
    {
        switch (closestOrder)
        {
            case 0: closestOrder = 4; break;
            case 1: closestOrder = 5; break;
            case 2: closestOrder = 0; break;
            case 3: closestOrder = 1; break;
            case 4: closestOrder = 2; break;
            case 5: closestOrder = 3; break;
        }

        const tmp = c2;
        c1 = c3;
        c2 = c1;
        c3 = tmp;
    }
    else if (c1.closest >= Epsilon
          && c2.closest <  Epsilon)
    {
        switch (closestOrder)
        {
            case 0: closestOrder = 3; break;
            case 1: closestOrder = 2; break;
            case 2: closestOrder = 1; break;
            case 3: closestOrder = 0; break;
            case 4: closestOrder = 5; break;
            case 5: closestOrder = 4; break;
        }

        const tmp = c2;
        c2 = c3;
        c3 = tmp;
    }
    else if (c1.closest < Epsilon)
    {
        switch (closestOrder)
        {
            case 0: closestOrder = 2; break;
            case 1: closestOrder = 3; break;
            case 2: closestOrder = 4; break;
            case 3: closestOrder = 5; break;
            case 4: closestOrder = 0; break;
            case 5: closestOrder = 1; break;
        }

        const tmp = c1;
        c1 = c2;
        c2 = c3;
        c3 = tmp;
    }


    return [
        closestOrder,
        c1.closest, c2.closest, c3.closest,
        c1.locked,  c2.locked,  c3.locked ];
}



function getColorCorrections(colorSpace)
{
    switch (colorSpace)
    {
    case 'hex':
    case 'rgb':
        return [
            new ColorCorrection('R', rgbFactor[0]),
            new ColorCorrection('G', rgbFactor[1]),
            new ColorCorrection('B', rgbFactor[2]) ];

    case 'hsv':
        return [
            new ColorCorrection('H', hs_Factor[0]/2),
            new ColorCorrection('S', hs_Factor[1]),
            new ColorCorrection('V', hs_Factor[2]) ];

    case 'hsl':
        return [
            new ColorCorrection('H', hs_Factor[0]/2),
            new ColorCorrection('S', hs_Factor[1]),
            new ColorCorrection('L', hs_Factor[2]) ];

    case 'hclok':
    case 'hclab':
    case 'hcluv':
        return [
            new ColorCorrection('H', hclFactor[0]/2),
            new ColorCorrection('C', hclFactor[1]),
            new ColorCorrection('L', hclFactor[2]) ];

    case 'oklab': 
    case 'lab':
        return [
            new ColorCorrection('L', oppFactor[0]),
            new ColorCorrection('a', oppFactor[1]),
            new ColorCorrection('b', oppFactor[2]) ];

    case 'luv':
        return [
            new ColorCorrection('L', oppFactor[0]),
            new ColorCorrection('u', oppFactor[1]),
            new ColorCorrection('v', oppFactor[2]) ];
    }


    console.assert(false, 'invalid color space ' + colorSpace);
    return [
        new ColorCorrection(),
        new ColorCorrection(),
        new ColorCorrection() ];
}


class GColorType
extends GOperator
{
    value;
    


    copyBase(src)
    {
        super.copyBase(src);

        if (src.value) this.value = src.value.copy();
    }



    toValue()
    {
        return this.value.copy();
    }
}


class GColor
extends GColorType
{
    input   = null;

    space   = null;
    c1      = null;
    c2      = null;
    c3      = null;

    convert = null;

    hasInputs;



    constructor(nodeId, options)
    {
        super(COLOR, nodeId, options);
    }


    
    copy()
    {
        const copy = new GColor(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        copy.space = this.space.copy();

        if (this.c1) copy.c1 = this.c1.copy();
        if (this.c2) copy.c2 = this.c2.copy();
        if (this.c3) copy.c3 = this.c3.copy();

        if (this.convert) 
            copy.convert = this.convert.copy();

        return copy;
    }



    eval(parse)
    {
        if (this.valid)//this.isCached())
            return this;

            
        const space   = this.space   ? this.space  .eval(parse).toValue().toInteger() : null; 
        let   c1      = this.c1      ? this.c1     .eval(parse).toValue()             : null;
        let   c2      = this.c2      ? this.c2     .eval(parse).toValue()             : null;
        let   c3      = this.c3      ? this.c3     .eval(parse).toValue()             : null;


        if (this.input)
        {
            const input = this.input.eval(parse).toValue();

            
            if (input.isValid())
            {
                this.value = new ColorValue(
                    input.space,
                    input.c1, 
                    input.c2, 
                    input.c3);
                    
                const fromSpaceIndex = input.space.value;

                const toSpaceIndex = Math.min(Math.max(
                    0,
                    Math.round(space.value)), // round because a value can come in with decimals (TODO fix this)
                    colorSpaceCount(parse)-1);


                this.convertColor(
                    this.value,
                    colorSpace(fromSpaceIndex), 
                    colorSpace(  toSpaceIndex));

                this.value.space.value = toSpaceIndex;

                
                // fake disabled status by checking for it during param eval (easiest way to do it)

                if (this.options.enabled)
                {
                    if (!this.c1) { this.c1 = this.value.c1.copy(); c1 = this.c1.toValue(); }
                    if (!this.c2) { this.c2 = this.value.c2.copy(); c1 = this.c1.toValue(); }
                    if (!this.c3) { this.c3 = this.value.c3.copy(); c1 = this.c1.toValue(); }

                    if (c1) this.value.c1 = c1;
                    if (c2) this.value.c2 = c2;
                    if (c3) this.value.c3 = c3;
                }
            }
            else
                this.value = ColorValue.NaN;


            if (!this.convert)
                this.convert = NumberValue.NaN;
        }
        else
        {
            this.value = new ColorValue(space, c1, c2, c3);

            const toSpaceIndex = Math.min(Math.max(
                0,
                Math.round(this.value.space.value)), // round because a value can come in with decimals (TODO fix this)
                colorSpaceCount(parse)-1);

            this.value.space.value = toSpaceIndex;

            if (    this.convert
                &&  this.convert.isValid()
                &&  this.convert.value > -1
                &&  this.value.isValid()
                && !this.hasInputs)
            {
                this.convert.eval(parse);

                this.convertColor(
                    this.value,
                    colorSpace(this.convert.value), 
                    colorSpace(toSpaceIndex));
            }
        }


        if (!this.value.space.isValid())
            this.value = new ColorValue(
                this.space.toValue(),
                NumberValue.NaN,
                NumberValue.NaN,
                NumberValue.NaN);

            
        // if (this.options.enabled)
        // {
            genPushUpdateValue(parse, this.nodeId, 'convert', this.convert          );
            genPushUpdateValue(parse, this.nodeId, 'space',   this.value.space, true);
            genPushUpdateValue(parse, this.nodeId, 'c1',      this.value.c1         );
            genPushUpdateValue(parse, this.nodeId, 'c2',      this.value.c2         );
            genPushUpdateValue(parse, this.nodeId, 'c3',      this.value.c3         );
        // }


        this.validate();

        return this;
    }



    convertColor(color, fromSpace, toSpace)
    {
        let col = [
            fromSpace, 
            getNormalColorValue(color.c1.value, fromSpace, 0),
            getNormalColorValue(color.c2.value, fromSpace, 1),
            getNormalColorValue(color.c3.value, fromSpace, 2)];

        col = getScaledDataColor(convertDataColorToSpace(col, toSpace));

        color.c1.value = col[1];
        color.c2.value = col[2];
        color.c3.value = col[3];
    }



    isValid()
    {
        return this.space.isValid()
            && this.c1   .isValid()
            && this.c2   .isValid()
            && this.c3   .isValid();
    }



    // toValue()
    // {
    //     return new ColorValue(
    //         this.space ? this.space.toValue() : NumberValue.NaN,
    //         this.c1    ? this.c1   .toValue() : NumberValue.NaN,
    //         this.c2    ? this.c2   .toValue() : NumberValue.NaN,
    //         this.c3    ? this.c3   .toValue() : NumberValue.NaN);
    // }
}


class GValidColor
extends GColorType
{
    input        = null;
     
    quality      = null;

    corrections  = [];



    constructor(nodeId, options)
    {
        super(VALID_COLOR, nodeId, options);
    }


    
    copy()
    {
        const copy = new GValidColor(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        if (this.quality) copy.quality = this.quality.copy();

        return copy;
    }



    eval(parse)
    {
        if (this.isCached())
            return this;


        const quality = this.quality ? this.quality.eval(parse).toValue().toInteger() : null;


        if (this.input)
        {
            const input = this.input.eval(parse).toValue();


            if (   !isValid(this.value) 
                || !this.value.isValid()) 
            {
                let rgb = input.toRgb();

                if (quality.value == 0) // clip sRGB
                {
                    rgb[0] = Math.round(Math.min(Math.max(0, rgb[0]), 1) * 0xff);   
                    rgb[1] = Math.round(Math.min(Math.max(0, rgb[1]), 1) * 0xff);   
                    rgb[2] = Math.round(Math.min(Math.max(0, rgb[2]), 1) * 0xff); 
                    
                    this.value = ColorValue.fromRgb(rgb);
                }
                else if (quality.value == 1) // clip chroma
                {
                    let hcl = rgb2hclok(rgb);

                    let loopProtect = 10000;

                    while (  !rgbIsValid(hclok2rgb(hcl))
                           && hcl[1] > 0.001
                           && loopProtect-- > 0)
                        hcl[1] -= 0.001;

                    rgb = hclok2rgb(hcl);

                    rgb[0] = Math.round(Math.min(Math.max(0, rgb[0]), 1) * 0xff);   
                    rgb[1] = Math.round(Math.min(Math.max(0, rgb[1]), 1) * 0xff);   
                    rgb[2] = Math.round(Math.min(Math.max(0, rgb[2]), 1) * 0xff); 
                    
                    this.value = ColorValue.fromRgb(rgb);
                }
                else // find corrections
                {
                    if (!rgbIsOk(rgb))
                    {
                        genQueueMessageToUI(
                        {
                            cmd:   'uiInitNodeProgress',
                            nodeId: this.nodeId
                        });
                    }
                    

                    const inputColor = input.toDataColor();


                    const
                [ closestOrder,
                    closest1,
                    closest2,
                    closest3 ] = findCorrection(
                        this.nodeId,
                        inputColor, 
                        quality, null,  null,  null, 
                        false,   false, false, false); 

                        
                    //if (!stopGenerate)
                    //{
                        if (   closestOrder >= 0 
                            && closestOrder <  6)
                        {
                            this._color = correctColor(
                                inputColor,
                                closestOrder,
                                closest1,
                                closest2,
                                closest3);

                            this.value = ColorValue.fromDataColor(this._color);
                        }
                        else
                        {
                            this.value = ColorValue.NaN;
                        }
                    //}
                }
            }
        }
        else
        {
            this.value = ColorValue.NaN;
        }


        genPushUpdateValue(parse, this.nodeId, 'quality', quality);
        genPushUpdateValue(parse, this.nodeId, 'value',   this.value);


        this.validate();

        return this;
    }
}



class GCorrectColor
extends GColorType
{
    input        = null;
     
    order        = null;
    margin1      = null;
    margin2      = null;
    margin3      = null;

    corrections  = [];



    constructor(nodeId, options)
    {
        super(CORRECT_COLOR, nodeId, options);
    }


    
    copy()
    {
        const copy = new GCorrectColor(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        if (this.order  ) copy.order   = this.order  .copy();
        if (this.margin1) copy.margin1 = this.margin1.copy();
        if (this.margin2) copy.margin2 = this.margin2.copy();
        if (this.margin3) copy.margin3 = this.margin3.copy();
        if (this.value  ) copy.value   = this.value  .copy();

        return copy;
    }



    eval(parse)
    {
        if (this.isCached())
            return this;


        const order   = this.order   ? this.order  .eval(parse).toValue().toInteger() : null;
        const margin1 = this.margin1 ? this.margin1.eval(parse).toValue()             : null;
        const margin2 = this.margin2 ? this.margin2.eval(parse).toValue()             : null;
        const margin3 = this.margin3 ? this.margin3.eval(parse).toValue()             : null;


        if (this.input)
        {
            const input = this.input.eval(parse).toValue();

            if (   isValid(this.order  ) && this.order  .isValid()
                && isValid(this.margin1) && this.margin1.isValid()
                && isValid(this.margin2) && this.margin2.isValid()
                && isValid(this.margin3) && this.margin3.isValid()
                && isValid(this.value  ) && this.value  .isValid())
            {
                genPushUpdateValue(parse, this.nodeId, 'order'  , this.order     );
                genPushUpdateValue(parse, this.nodeId, 'margin1', this.margin1   );
                genPushUpdateValue(parse, this.nodeId, 'margin2', this.margin2   );
                genPushUpdateValue(parse, this.nodeId, 'margin3', this.margin3   );
                genPushUpdateValue(parse, this.nodeId, 'value'  , this.value);
            }
            else
            {
                const rgb = input.toRgb();
                
                if (!rgbIsOk(rgb))
                    genQueueMessageToUI(
                    {
                        cmd:   'uiInitNodeProgress',
                        nodeId: this.nodeId
                    });


                const inputColor = input.toDataColor();


                const
              [ closestOrder,
                closest1,
                closest2,
                closest3 ] = findCorrection(
                    this.nodeId,
                    inputColor, 
                    order, margin1, margin2, margin3, 
                    this.order   != null,
                    this.margin1 != null, 
                    this.margin2 != null, 
                    this.margin3 != null); 

                     
                //if (!stopGenerate)
                //{
                    if (   closestOrder >= 0 
                        && closestOrder <  6)
                    {
                        this._color = correctColor(
                            inputColor,
                            closestOrder,
                            closest1,
                            closest2,
                            closest3);

                        this.value = ColorValue.fromDataColor(this._color);

                        genPushUpdateValue(parse, this.nodeId, 'order',   new NumberValue(closestOrder));
                        genPushUpdateValue(parse, this.nodeId, 'margin1', new NumberValue(closest1    ));
                        genPushUpdateValue(parse, this.nodeId, 'margin2', new NumberValue(closest2    ));
                        genPushUpdateValue(parse, this.nodeId, 'margin3', new NumberValue(closest3    ));
                        genPushUpdateValue(parse, this.nodeId, 'value',   this.value);
                    }
                    else
                    {
                        this.value = ColorValue.NaN;

                        genPushUpdateValue(parse, this.nodeId, 'order',   NumberValue.NaN);
                        genPushUpdateValue(parse, this.nodeId, 'margin1', NumberValue.NaN);
                        genPushUpdateValue(parse, this.nodeId, 'margin2', NumberValue.NaN);
                        genPushUpdateValue(parse, this.nodeId, 'margin3', NumberValue.NaN);
                        genPushUpdateValue(parse, this.nodeId, 'value',   ColorValue .NaN);
                    }
                //}
            }
        }
        else
        {
            this.value = ColorValue.NaN;

            genPushUpdateValue(parse, this.nodeId, 'order',   NumberValue.NaN);
            genPushUpdateValue(parse, this.nodeId, 'margin1', NumberValue.NaN);
            genPushUpdateValue(parse, this.nodeId, 'margin2', NumberValue.NaN);
            genPushUpdateValue(parse, this.nodeId, 'margin3', NumberValue.NaN);
            genPushUpdateValue(parse, this.nodeId, 'value',   ColorValue .NaN);
        }


        this.validate();

        return this;
    }
}



class GColorContrast
extends GColorType
{
    input0 = null;
    input1 = null;

    standard;
    contrast;


    constructor(nodeId, options)
    {
        super(COLOR_CONTRAST, nodeId, options);
    }


    
    copy()
    {
        const copy = new GColorContrast(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input0) copy.input0 = this.input0.copy();
        if (this.input1) copy.input1 = this.input1.copy();

        copy.standard = this.standard.copy();
        copy.contrast = this.contrast.copy();

        return copy;
    }



    eval(parse)
    {
        if (this.isCached())
            return this;


        const standard = this.standard.eval(parse).toValue().toInteger();

        
        if (standard.isValid())
            standard.value = Math.min(Math.max(0, standard.value), 1);


        if (   this.input0 
            && this.input1)
        {
            const input0 = this.input0.eval(parse).toValue();
            const input1 = this.input1.eval(parse).toValue();


            if (   input0.isValid()
                && input1.isValid())
            {
                this.value = input1;
                
                if (   dataColorIsValid(input0.toDataColor())
                    && dataColorIsValid(input1.toDataColor()))
                {
                    if (standard.value == 0)
                    {
                        const value = getContrastRatio2(input0.toRgb(), input1.toRgb());
                        this.contrast = new NumberValue(value, 2);
                    }
                    else
                    {
                        const value = getContrastRatio3(input0.toRgb(), input1.toRgb());
                        this.contrast = new NumberValue(value, 1);
                    }
                }
                else
                    this.contrast = NumberValue.NaN;
            }
            else
            {
                this.value    = ColorValue.NaN;
                this.contrast = NumberValue.NaN;
            }


            genPushUpdateValue(parse, this.nodeId, 'text', input0);
            genPushUpdateValue(parse, this.nodeId, 'back', input1);
        }

        else if (this.input0) 
        {
            const input0 = this.input0.eval(parse).toValue();

            genPushUpdateValue(parse, this.nodeId, 'text', input0.isValid() ? input0 : ColorValue.NaN);
            genPushUpdateValue(parse, this.nodeId, 'back', ColorValue.NaN);

            this.value    = ColorValue.NaN;
            this.contrast = NumberValue.NaN;
        }

        else if (this.input1) 
        {
            const input1 = this.input1.eval(parse).toValue();

            genPushUpdateValue(parse, this.nodeId, 'text', ColorValue.NaN);
            genPushUpdateValue(parse, this.nodeId, 'back', input1.isValid() ? input1 : ColorValue.NaN);

            this.value    = input1.isValid() ? input1 : ColorValue.NaN;
            this.contrast = NumberValue.NaN;
        }

        else
        {
            this.value    = ColorValue.NaN;
            this.contrast = NumberValue.NaN;

            genPushUpdateValue(parse, this.nodeId, 'text', ColorValue.NaN);
            genPushUpdateValue(parse, this.nodeId, 'back', ColorValue.NaN);
        }
        


        genPushUpdateValue(parse, this.nodeId, 'standard', standard);
        genPushUpdateValue(parse, this.nodeId, 'contrast', this.contrast);


        this.validate();

        return this;
    }
}



class GColorBlind
extends GColorType
{
    input = null;

    l;
    m;
    s;


    constructor(nodeId, options)
    {
        super(COLORBLIND, nodeId, options);
    }


    
    copy()
    {
        const copy = new GColorBlind(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        copy.l = this.l.copy();
        copy.m = this.m.copy();
        copy.s = this.s.copy();

        return copy;
    }



    eval(parse)
    {
        if (this.isCached())
            return this;


        const l = this.l.eval(parse).toValue();        
        const m = this.m.eval(parse).toValue();
        const s = this.s.eval(parse).toValue();


        if (this.input)
        {
            const input = this.input.eval(parse).toValue();
            const rgb   = input.toRgb();

            const rgbCb = rgb2colorblind(
                rgb,
                l.value / 2,
                m.value / 2,
                s.value / 2);

            if (   !rgbIsNaN(rgb)
                && !rgbIsNaN(rgbCb))
            {
                const validRgbCb = rgbCb;
            
                const validCol = convertDataColorToSpace(
                    rgb2dataColor(validRgbCb), 
                    colorSpace(input.space.value));

                this.value = ColorValue.fromDataColor(validCol);
            }
            else
                this.value = ColorValue.NaN;
        }
        else
            this.value = ColorValue.NaN;


        genPushUpdateValue(parse, this.nodeId, 'l',     l);
        genPushUpdateValue(parse, this.nodeId, 'm',     m);
        genPushUpdateValue(parse, this.nodeId, 's',     s);
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);


        this.validate();

        return this;
    }
}



class GColorInterpolate
extends GColorType
{
    input0 = null;
    input1 = null;

    space;
    amount;
    gamma;


    constructor(nodeId, options)
    {
        super(COLOR_INTERPOLATE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GColorInterpolate(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input0) copy.input0 = this.input0.copy();
        if (this.input1) copy.input1 = this.input1.copy();

        copy.space  = this.space .copy();
        copy.amount = this.amount.copy();
        copy.gamma  = this.gamma .copy();

        return copy;
    }



    eval(parse)
    {
        if (this.isCached())
            return this;


        const space  = this.space .eval(parse).toValue().toInteger();
        const amount = this.amount.eval(parse).toValue();
        const gamma  = this.gamma .eval(parse).toValue();


        if (   this.input0 
            && this.input1)
        {
            const input0 = this.input0.eval(parse).toValue();
            const input1 = this.input1.eval(parse).toValue();

            console.assert(
                amount.type == NUMBER_VALUE, 
                'this.result.type must be NUMBER_VALUE');

            const f = amount.value / 100;


            const spaceIndex = Math.min(Math.max(0, space.value), colorSpaceCount()-1);
            const gammaValue = Math.max(0.0001, gamma.value);

            const _space = colorSpace(spaceIndex);

            const col = this.interpolate(
                spaceIndex,
                convertDataColorToSpace(input0.toDataColor(), _space),
                convertDataColorToSpace(input1.toDataColor(), _space),
                f,
                gammaValue);


            // allow interpolating invalid colors,
            // so no valid color check here

            this.value = ColorValue.fromDataColor(col, spaceIndex);
        }

        else if (this.input0) 
            this.value = this.input0.eval(parse).toValue();

        else if (this.input1) 
            this.value = this.input1.eval(parse).toValue();
            
        else 
            this.value = ColorValue.NaN;


        genPushUpdateValue(parse, this.nodeId, 'space',  space );
        genPushUpdateValue(parse, this.nodeId, 'amount', amount);
        genPushUpdateValue(parse, this.nodeId, 'gamma',  gamma );
        genPushUpdateValue(parse, this.nodeId, 'value',  this.value);


        this.validate();
        
        return this;
    }



    interpolate(space, col0, col1, f, gamma)
    {
        if (   space <= 1
            || space >  6) // hex, rgb, okLab, lab, luv
        {
            const r0 = Math.pow(col0[1], gamma);  const r1 = Math.pow(col1[1], gamma);
            const g0 = Math.pow(col0[2], gamma);  const g1 = Math.pow(col1[2], gamma);
            const b0 = Math.pow(col0[3], gamma);  const b1 = Math.pow(col1[3], gamma);

            gamma = Math.max(0.01, gamma);

            return [
                colorSpace(space),
                Math.pow(lerp(r0, r1, f), 1/gamma),
                Math.pow(lerp(g0, g1, f), 1/gamma),
                Math.pow(lerp(b0, b1, f), 1/gamma) ];
        }
        else // hsv/hsl/hcl
        {
            const h0 = col0[1] * Tau;  const h1 = col1[1] * Tau;
            const c0 = col0[2];        const c1 = col1[2];
            const l0 = col0[3];        const l1 = col1[3];

            return [
                colorSpace(space),
                normalAngle(h0 + angleDiff(h0, h1) * f) / Tau,
                lerp(c0, c1, f),
                lerp(l0, l1, f) ];
        }
    }
}



class GColorStop
extends GOperator
{
    input    = null;

    fill     = null;
    position = null;



    constructor(nodeId, options)
    {
        super(COLOR_STOP, nodeId, options);
    }


    
    copy()
    {
        const copy = new GColorStop(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        if (this.fill    ) copy.fill     = this.fill    .copy();
        if (this.position) copy.position = this.position.copy();

        return copy;
    }



    eval(parse)
    {
        if (!this.valid)
        {
            this.result = new ColorStopValue();


            if (this.input)
            {
                this.result = this.input.eval(parse).copy();

                console.assert(
                    this.result.type == COLOR_STOP_VALUE, 
                    'this.result.type must be COLOR_STOP_VALUE');

                if (this.result.isValid())
                {
                    if (this.fill    ) this.result.fill     = this.fill    .eval(parse).copy();
                    if (this.position) this.result.position = this.position.eval(parse).copy();
                }
            }
            else
            {
                this.result.fill     = this.fill    .eval(parse).copy();
                this.result.position = this.position.eval(parse).copy();
            }


            this.result.valid = true;
            this.valid        = true;


            genPushUpdateValue(parse, this.nodeId, 'value', this.result);
        }


        return this;
    }
}


class GObjectBase
extends GOperator
{
    // fill    = null;
    // stroke  = null;
    

    objects = [];
    styles  = [];



    constructor(type, nodeId, options)
    {
        super(type, nodeId, options);
    }



    copyBase(base)
    {
        // if (base.fill  ) this.fill   = base.fill  .copy();
        // if (base.stroke) this.stroke = base.stroke.copy();

        this.copyObjects(base.objects);
        this.copyStyles (base.styles );
    }



    copyObjects(objects)
    {
        this.objects = objects.map(o => o.copy());
    }



    copyStyles(styles)
    {
        this.styles = styles.map(s => s.copy());
    }



    // addUpdateObject(parse, nodeId, objects)
    // {
    //     if (this.options.active) 
    //         genPushUpdateObject(parse, nodeId, objects);
    //     else 
    //         this.objects.push(...objects);
    // }



    evalBase(parse, input)
    {
    //     if (!this.valid)
    //     {
    //         const fill   = evalFillValue  (this.fill,   parse);
    //         const stroke = evalStrokeValue(this.stroke, parse);
            
    //         if (input)
    //         {
    //             if (this.fill  ) this.result.fill   = fill;
    //             if (this.stroke) this.result.stroke = stroke;
    //         }
    //         else
    //         {
    //             this.result.fill   = fill;
    //             this.result.stroke = stroke;
    //         }


    //         genPushUpdateValue(parse, this.nodeId, 'fill',   this.result.fill  );
    //         genPushUpdateValue(parse, this.nodeId, 'stroke', this.result.stroke);
    //     }
    }



    evalObjects(options = {})
    {
        // for (const obj of this.objects)
        //     obj.nodeId = this.nodeId;
    }



    
    evalStyle(options = {})
    {
        // for (const style of this.styles)
        //     style.nodeId = this.nodeId;
    }
}


class GRectangle
extends GObjectBase
{
    input  = null;

    x      = null;
    y      = null;
    width  = null;
    height = null;
    angle  = null;
    round  = null;



    constructor(nodeId, options)
    {
        super(RECTANGLE, nodeId, options);
    }



    copy()
    {
        const copy = new GRectangle(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        if (this.x     ) copy.x      = this.x     .copy();
        if (this.y     ) copy.y      = this.y     .copy();
        if (this.width ) copy.width  = this.width .copy();
        if (this.height) copy.height = this.height.copy();
        if (this.angle ) copy.angle  = this.angle .copy();
        if (this.round ) copy.round  = this.round .copy();

        return copy;
    }



    eval(parse)
    {
        if (this.isCached())
            return this;

            
        if (this.input)
            this.input = this.input.eval(parse).copy();

        const hasInput =     
               this.input 
            && RECTANGLE_TYPES.includes(this.input.type);   

            
        if (this.x     ) this.x      = this.x     .eval(parse).copy(); else if (hasInput) this.x      = this.input.x     .copy();
        if (this.y     ) this.y      = this.y     .eval(parse).copy(); else if (hasInput) this.y      = this.input.y     .copy();
        if (this.width ) this.width  = this.width .eval(parse).copy(); else if (hasInput) this.width  = this.input.width .copy();
        if (this.height) this.height = this.height.eval(parse).copy(); else if (hasInput) this.height = this.input.height.copy();
        if (this.angle ) this.angle  = this.angle .eval(parse).copy(); else if (hasInput) this.angle  = this.input.angle .copy();
        if (this.round ) this.round  = this.round .eval(parse).copy(); else if (hasInput) this.round  = this.input.round .copy();

        
        if (this.x     ) genPushUpdateValue(parse, this.nodeId, 'x',      this.x     .toValue());
        if (this.y     ) genPushUpdateValue(parse, this.nodeId, 'y',      this.y     .toValue());
        if (this.width ) genPushUpdateValue(parse, this.nodeId, 'width',  this.width .toValue());
        if (this.height) genPushUpdateValue(parse, this.nodeId, 'height', this.height.toValue());
        if (this.angle ) genPushUpdateValue(parse, this.nodeId, 'angle',  this.angle .toValue());
        if (this.round ) genPushUpdateValue(parse, this.nodeId, 'round',  this.round .toValue());


        if (    hasInput
            && !this.options) this.objects = this.input.objects;
        else                  this.evalObjects();


        this.validate();

        return this;
    }



    evalObjects(options = {})
    {
        if (!this.options.enabled)
            return;
            
            
        if (   this.x 
            && this.y 
            && this.width 
            && this.height 
            && this.angle 
            && this.round)
        {
            this.objects = 
            [
                new FigmaRectangle(
                                this.nodeId,
                                this.nodeName,
                                0,
                                this.x     .toValue().value,
                                this.y     .toValue().value,
                                this.width .toValue().value,
                                this.height.toValue().value,
                                this.angle .toValue().value,
                    Math.max(0, this.round .toValue().value))
            ];
        }

        
        super.evalObjects();
    }



    isValid()
    {
        return this.x     .isValid()
            && this.y     .isValid()
            && this.width .isValid()
            && this.height.isValid()
            && this.angle .isValid()
            && this.round .isValid();
    }



    toValue()
    {
        return new RectangleValue(
            this.nodeId,
            this.x     .toValue(),
            this.y     .toValue(),
            this.width .toValue(),
            this.height.toValue(),
            this.angle .toValue(),
            this.round .toValue());
    }
}


class GLine
extends GObjectBase
{
    input  = null;

    x      = null;
    y      = null;
    width  = null;
    angle  = null;



    constructor(nodeId, options)
    {
        super(LINE, nodeId, options);
    }



    copy()
    {
        const copy = new GLine(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        if (this.x     ) copy.x      = this.x     .copy();
        if (this.y     ) copy.y      = this.y     .copy();
        if (this.width ) copy.width  = this.width .copy();
        if (this.angle ) copy.angle  = this.angle .copy();

        return copy;
    }



    eval(parse)
    {
        if (this.isCached())
            return this;


        if (this.input)
            this.input.eval(parse);

        const hasInput =     
               this.input 
            && LINE_TYPES.includes(this.input.type);   

            
        if (this.x     ) this.x     .eval(parse); else if (hasInput) this.x     = this.input.x    ;
        if (this.y     ) this.y     .eval(parse); else if (hasInput) this.y     = this.input.y    ;
        if (this.width ) this.width .eval(parse); else if (hasInput) this.width = this.input.width;
        if (this.angle ) this.angle .eval(parse); else if (hasInput) this.angle = this.input.angle;

        
        if (this.x     ) genPushUpdateValue(parse, this.nodeId, 'x',      this.x     .toValue());
        if (this.y     ) genPushUpdateValue(parse, this.nodeId, 'y',      this.y     .toValue());
        if (this.width ) genPushUpdateValue(parse, this.nodeId, 'width',  this.width .toValue());
        if (this.angle ) genPushUpdateValue(parse, this.nodeId, 'angle',  this.angle .toValue());


        if (    hasInput
            && !this.options) this.objects = this.input.objects;
        else                  this.evalObjects();


        this.validate();

        return this;
    }



    evalObjects(options = {})
    {
        if (!this.options.enabled)
            return;
            
            
        if (   this.x 
            && this.y 
            && this.width 
            && this.angle)
        {
            this.objects = 
            [
                new FigmaLine(
                    this.nodeId,
                    this.nodeName,
                    0,
                    this.x    .toValue().value,
                    this.y    .toValue().value,
                    this.width.toValue().value,
                    this.angle.toValue().value)
            ];
        }

        
        super.evalObjects();
    }



    isValid()
    {
        return this.x    .isValid()
            && this.y    .isValid()
            && this.width.isValid()
            && this.angle.isValid();
    }



    toValue()
    {
        return new LineValue(
            this.nodeId,
            this.x     .toValue(),
            this.y     .toValue(),
            this.width .toValue(),
            this.angle .toValue());
    }
}


class GEllipse
extends GObjectBase
{
    input  = null;

    x      = null;
    y      = null;
    width  = null;
    height = null;
    angle  = null;



    constructor(nodeId, options)
    {
        super(ELLIPSE, nodeId, options);
    }



    copy()
    {
        const copy = new GEllipse(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        if (this.x     ) copy.x      = this.x     .copy();
        if (this.y     ) copy.y      = this.y     .copy();
        if (this.width ) copy.width  = this.width .copy();
        if (this.height) copy.height = this.height.copy();
        if (this.angle ) copy.angle  = this.angle .copy();

        return copy;
    }


    eval(parse)
    {
        if (this.isCached())
            return this;

            
        if (this.input)
            this.input.eval(parse);

        const hasInput =     
               this.input 
            && ELLIPSE_TYPES.includes(this.input.type);   

            
        if (this.x     ) this.x     .eval(parse); else if (hasInput) this.x      = this.input.x     ;
        if (this.y     ) this.y     .eval(parse); else if (hasInput) this.y      = this.input.y     ;
        if (this.width ) this.width .eval(parse); else if (hasInput) this.width  = this.input.width ;
        if (this.height) this.height.eval(parse); else if (hasInput) this.height = this.input.height;
        if (this.angle ) this.angle .eval(parse); else if (hasInput) this.angle  = this.input.angle ;

        
        if (this.x     ) genPushUpdateValue(parse, this.nodeId, 'x',      this.x     .toValue());
        if (this.y     ) genPushUpdateValue(parse, this.nodeId, 'y',      this.y     .toValue());
        if (this.width ) genPushUpdateValue(parse, this.nodeId, 'width',  this.width .toValue());
        if (this.height) genPushUpdateValue(parse, this.nodeId, 'height', this.height.toValue());
        if (this.angle ) genPushUpdateValue(parse, this.nodeId, 'angle',  this.angle .toValue());


        if (    hasInput
            && !this.options) this.objects = this.input.objects;
        else                  this.evalObjects();


        this.validate();

        return this;
   }



   evalObjects(options = {})
   {
       if (!this.options.enabled)
           return;
           
           
       if (   this.x 
           && this.y 
           && this.width 
           && this.height 
           && this.angle)
       {
           this.objects = 
           [
               new FigmaEllipse(
                               this.nodeId,
                               this.nodeName,
                               0,
                               this.x     .toValue().value,
                               this.y     .toValue().value,
                               this.width .toValue().value,
                               this.height.toValue().value,
                               this.angle .toValue().value)
           ];
       }

       
       super.evalObjects();
   }



   isValid()
   {
       return this.x     .isValid()
           && this.y     .isValid()
           && this.width .isValid()
           && this.height.isValid()
           && this.angle .isValid();
   }



   toValue()
   {
       return new EllipseValue(
           this.nodeId,
           this.x     .toValue(),
           this.y     .toValue(),
           this.width .toValue(),
           this.height.toValue(),
           this.angle .toValue());
   }
}


class GPolygon
extends GObjectBase
{
    input   = null;

    x       = null;
    y       = null;
    width   = null;
    height  = null;
    angle   = null;
    round   = null;
    corners = null;



    constructor(nodeId, options)
    {
        super(POLYGON, nodeId, options);
    }



    copy()
    {
        const copy = new GPolygon(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        if (this.x      ) copy.x       = this.x      .copy();
        if (this.y      ) copy.y       = this.y      .copy();
        if (this.width  ) copy.width   = this.width  .copy();
        if (this.height ) copy.height  = this.height .copy();
        if (this.angle  ) copy.angle   = this.angle  .copy();
        if (this.round  ) copy.round   = this.round  .copy();
        if (this.corners) copy.corners = this.corners.copy();

        return copy;
    }



    eval(parse)
    {
        if (this.isCached())
            return this;

            
        if (this.input)
            this.input.eval(parse);

        const hasInput =     
               this.input 
            && POLYGON_TYPES.includes(this.input.type);   

             
        if (this.x      ) this.x      .eval(parse); else if (hasInput) this.x       = this.input.x      ;
        if (this.y      ) this.y      .eval(parse); else if (hasInput) this.y       = this.input.y      ;
        if (this.width  ) this.width  .eval(parse); else if (hasInput) this.width   = this.input.width  ;
        if (this.height ) this.height .eval(parse); else if (hasInput) this.height  = this.input.height ;
        if (this.angle  ) this.angle  .eval(parse); else if (hasInput) this.angle   = this.input.angle  ;
        if (this.round  ) this.round  .eval(parse); else if (hasInput) this.round   = this.input.round  ;
        if (this.corners) this.corners.eval(parse); else if (hasInput) this.corners = this.input.corners;

        
        if (this.x      ) genPushUpdateValue(parse, this.nodeId, 'x',       this.x      .toValue());
        if (this.y      ) genPushUpdateValue(parse, this.nodeId, 'y',       this.y      .toValue());
        if (this.width  ) genPushUpdateValue(parse, this.nodeId, 'width',   this.width  .toValue());
        if (this.height ) genPushUpdateValue(parse, this.nodeId, 'height',  this.height .toValue());
        if (this.angle  ) genPushUpdateValue(parse, this.nodeId, 'angle',   this.angle  .toValue());
        if (this.round  ) genPushUpdateValue(parse, this.nodeId, 'round',   this.round  .toValue());
        if (this.corners) genPushUpdateValue(parse, this.nodeId, 'corners', this.corners.toValue());


        if (    hasInput
            && !this.options) this.objects = this.input.objects;
        else                  this.evalObjects();


        this.validate();

        return this;
    }



    evalObjects(options = {})
    {
        if (!this.options.enabled)
            return;
            
            
        if (   this.x 
            && this.y 
            && this.width 
            && this.height 
            && this.angle 
            && this.round
            && this.corners)
        {
            this.objects = 
            [
                new FigmaPolygon(
                                this.nodeId,
                                this.nodeName,
                                0,
                                this.x      .toValue().value,
                                this.y      .toValue().value,
                                this.width  .toValue().value,
                                this.height .toValue().value,
                                this.angle  .toValue().value,
                    Math.max(0, this.round  .toValue().value),
                                this.corners.toValue().value)
            ];
        }

        
        super.evalObjects();
    }



    isValid()
    {
        return this.x      .isValid()
            && this.y      .isValid()
            && this.width  .isValid()
            && this.height .isValid()
            && this.angle  .isValid()
            && this.round  .isValid()
            && this.corners.isValid();
    }



    toValue()
    {
        return new PolygonValue(
            this.nodeId,
            this.x      .toValue(),
            this.y      .toValue(),
            this.width  .toValue(),
            this.height .toValue(),
            this.angle  .toValue(),
            this.round  .toValue(),
            this.corners.toValue());
    }
}


class GStar
extends GObjectBase
{
    input  = null;

    x      = null;
    y      = null;
    width  = null;
    height = null;
    angle  = null;
    round  = null;
    points = null;
    convex = null;



    constructor(nodeId, options)
    {
        super(STAR, nodeId, options);
    }



    copy()
    {
        const copy = new GStar(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        if (this.x     ) copy.x      = this.x     .copy();
        if (this.y     ) copy.y      = this.y     .copy();
        if (this.width ) copy.width  = this.width .copy();
        if (this.height) copy.height = this.height.copy();
        if (this.angle ) copy.angle  = this.angle .copy();
        if (this.round ) copy.round  = this.round .copy();
        if (this.points) copy.points = this.points.copy();
        if (this.convex) copy.convex = this.convex.copy();

        return copy;
    }



    eval(parse)
    {
        if (this.isCached())
            return this;

            
        if (this.input)
            this.input = this.input.eval(parse).copy();

        const hasInput =     
               this.input 
            && STAR_TYPES.includes(this.input.type);   

             
        if (this.x     ) this.x      = this.x     .eval(parse).copy(); else if (hasInput) this.x      = this.input.x     .copy();
        if (this.y     ) this.y      = this.y     .eval(parse).copy(); else if (hasInput) this.y      = this.input.y     .copy();
        if (this.width ) this.width  = this.width .eval(parse).copy(); else if (hasInput) this.width  = this.input.width .copy();
        if (this.height) this.height = this.height.eval(parse).copy(); else if (hasInput) this.height = this.input.height.copy();
        if (this.angle ) this.angle  = this.angle .eval(parse).copy(); else if (hasInput) this.angle  = this.input.angle .copy();
        if (this.round ) this.round  = this.round .eval(parse).copy(); else if (hasInput) this.round  = this.input.round .copy();
        if (this.points) this.points = this.points.eval(parse).copy(); else if (hasInput) this.points = this.input.points.copy();
        if (this.convex) this.convex = this.convex.eval(parse).copy(); else if (hasInput) this.convex = this.input.convex.copy();

        
        if (this.x     ) genPushUpdateValue(parse, this.nodeId, 'x',      this.x     .toValue());
        if (this.y     ) genPushUpdateValue(parse, this.nodeId, 'y',      this.y     .toValue());
        if (this.width ) genPushUpdateValue(parse, this.nodeId, 'width',  this.width .toValue());
        if (this.height) genPushUpdateValue(parse, this.nodeId, 'height', this.height.toValue());
        if (this.angle ) genPushUpdateValue(parse, this.nodeId, 'angle',  this.angle .toValue());
        if (this.round ) genPushUpdateValue(parse, this.nodeId, 'round',  this.round .toValue());
        if (this.points) genPushUpdateValue(parse, this.nodeId, 'points', this.points.toValue());
        if (this.convex) genPushUpdateValue(parse, this.nodeId, 'convex', this.convex.toValue());


        if (    hasInput
            && !this.options) this.objects = this.input.objects;
        else                  this.evalObjects();


        this.validate();

        return this;
   }



   evalObjects(options = {})
   {
       if (!this.options.enabled)
           return;
           
           
       if (   this.x 
           && this.y 
           && this.width 
           && this.height 
           && this.angle 
           && this.round
           && this.points
           && this.convex)
       {
           this.objects = 
           [
               new FigmaStar(
                               this.nodeId,
                               this.nodeName,
                               0,
                               this.x     .toValue().value,
                               this.y     .toValue().value,
                               this.width .toValue().value,
                               this.height.toValue().value,
                               this.angle .toValue().value,
                   Math.max(0, this.round .toValue().value),
                               this.points.toValue().value,
                               this.convex.toValue().value)
           ];
       }

       
       super.evalObjects();
   }



   isValid()
   {
       return this.x     .isValid()
           && this.y     .isValid()
           && this.width .isValid()
           && this.height.isValid()
           && this.angle .isValid()
           && this.round .isValid()
           && this.points.isValid()
           && this.convex.isValid();
   }



   toValue()
   {
       return new StarValue(
           this.nodeId,
           this.x     .toValue(),
           this.y     .toValue(),
           this.width .toValue(),
           this.height.toValue(),
           this.angle .toValue(),
           this.round .toValue(),
           this.points.toValue(),
           this.convex.toValue());
   }
}


class GFill
extends GObjectBase
{
    input   = null;

    color   = null;
    opacity = null;



    constructor(nodeId, options)
    {
        super(FILL, nodeId, options);
    }



    copy()
    {
        const copy = new GFill(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        if (this.color  ) copy.color   = this.color  .copy();
        if (this.opacity) copy.opacity = this.opacity.copy();

        return copy;
    }



    eval(parse)
    {
        if (this.isCached())
            return this;
``

        if (this.input)
        {
            this.input.eval(parse);
            this.copyObjects(this.input.objects);
        }

        const hasInput =     
               this.input 
            && FILL_TYPES.includes(this.input.type);   


        if (this.color  ) this.color   = this.color  .eval(parse).copy(); else if (hasInput) this.color   = this.input.color  .copy();
        if (this.opacity) this.opacity = this.opacity.eval(parse).copy(); else if (hasInput) this.opacity = this.input.opacity.copy();

        if (this.color  ) genPushUpdateValue(parse, this.nodeId, 'color',   this.color  .toValue());
        if (this.opacity) genPushUpdateValue(parse, this.nodeId, 'opacity', this.opacity.toValue());

        
        if (   this.options.active
            || this.options.beforeActive)
            this.evalObjects();


        this.validate();

        return this;
    }



    evalObjects(options = {})
    {
        if (!this.objects)
            return;
        
        
        if (this.options.enabled)
        {
            const rgb = scaleRgb(this.color.toValue().toRgb());

            for (const obj of this.objects)
            {
                if (!obj.fills) 
                    obj.fills = [];

                obj.fills.push([
                    'SOLID', 
                            rgb[0]
                    + ' ' + rgb[1]
                    + ' ' + rgb[2]
                    + ' ' + this.opacity.toValue().toNumber()]);
            }
        }

        
        super.evalObjects();
    }



    isValid()
    {
        return this.color  .isValid()
            && this.opacity.isValid();
    }



    toValue()
    {
        return new FillValue(
            this.color   ? this.color  .toValue() : this.input.color  .toValue(),
            this.opacity ? this.opacity.toValue() : this.input.opacity.toValue());
    }
}


class GStroke
extends GObjectBase
{
    input  = null;

    fill   = null;
    weight = null;
    fit    = null;
    join   = null;
    miter  = null;



    constructor(nodeId, options)
    {
        super(STROKE, nodeId, options);
    }



    copy()
    {
        const copy = new GStroke(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        if (this.fill  ) copy.fill   = this.fill  .copy();
        if (this.weight) copy.weight = this.weight.copy();
        if (this.fit   ) copy.fit    = this.fit   .copy();
        if (this.join  ) copy.join   = this.join  .copy();
        if (this.miter ) copy.miter  = this.miter .copy();

        return copy;
    }



    eval(parse)
    {
        if (this.isCached())
            return this;


        if (this.input)
        {
            this.input = this.input.eval(parse).copy();
            this.copyObjects(this.input.objects);
        }


        if (   this.fill
            && COLOR_TYPES.includes(this.fill.type))
        {
            this.fill = this.fill.eval(parse).copy();

            this.fill = new FillValue(
                this.fill.toValue(), 
                new NumberValue(100));// this.fill.options.opacity.toValue());
        }


        const hasInput =     
               this.input 
            && STROKE_TYPES.includes(this.input.type);   


        // TODO: add .toInteger() to miter, join and fit evaluations
        
        if (this.fill  ) this.fill   = this.fill  .eval(parse).copy(); else if (hasInput) this.fill   = this.input.fill  .copy(); 
        if (this.weight) this.weight = this.weight.eval(parse).copy(); else if (hasInput) this.weight = this.input.weight.copy();
        if (this.fit   ) this.fit    = this.fit   .eval(parse).copy(); else if (hasInput) this.fit    = this.input.fit   .copy();
        if (this.join  ) this.join   = this.join  .eval(parse).copy(); else if (hasInput) this.join   = this.input.join  .copy();
        if (this.miter ) this.miter  = this.miter .eval(parse).copy(); else if (hasInput) this.miter  = this.input.miter .copy();            

        if (this.fill  ) genPushUpdateValue(parse, this.nodeId, 'fill',   this.fill  .toValue());
        if (this.weight) genPushUpdateValue(parse, this.nodeId, 'weight', this.weight.toValue());
        if (this.fit   ) genPushUpdateValue(parse, this.nodeId, 'fit',    this.fit   .toValue());
        if (this.join  ) genPushUpdateValue(parse, this.nodeId, 'join',   this.join  .toValue());
        if (this.miter ) genPushUpdateValue(parse, this.nodeId, 'miter',  this.miter .toValue());


        if (   this.options.active
            || this.options.beforeActive)
            this.evalObjects();


        this.validate();

        return this;
    }



    evalObjects(options = {})
    {
        if (!this.objects)
            return;


        if (this.options.enabled)
        {
            const rgb = scaleRgb(this.fill.color.toValue().toRgb());

            for (const obj of this.objects)
            {
                if (!obj.strokes)
                    obj.strokes = [];

                obj.strokes.push([
                    'SOLID', 
                            rgb[0]
                    + ' ' + rgb[1]
                    + ' ' + rgb[2]
                    + ' ' + this.fill.opacity.toValue().value]);


                if (this.weight)
                    obj.strokeWeight = this.weight.toValue().value;

                if (this.fit)
                    switch (this.fit.toValue().value)
                    {
                        case 0: obj.strokeAlign = 'INSIDE';  break;
                        case 1: obj.strokeAlign = 'CENTER';  break;
                        case 2: obj.strokeAlign = 'OUTSIDE'; break;
                    }

                if (this.join)
                    switch (this.join.toValue().value)
                    {
                        case 0: obj.strokeJoin = 'MITER'; break;
                        case 1: obj.strokeJoin = 'BEVEL'; break;
                        case 2: obj.strokeJoin = 'ROUND'; break;
                    }

                if (this.miter)
                    obj.strokeMiterLimit = this.miter.toValue().value;
            }
        }

        
        super.evalObjects();
    }



    isValid()
    {
        return this.fill  .isValid()
            && this.weight.isValid()
            && this.fit   .isValid()
            && this.join  .isValid()
            && this.miter .isValid();
    }



    toValue()
    {
        return new StrokeValue(
            this.fill   ? this.fill  .toValue() : this.input.fill  .toValue(),
            this.weight ? this.weight.toValue() : this.input.weight.toValue(),
            this.fit    ? this.fit   .toValue() : this.input.fit   .toValue(),
            this.join   ? this.join  .toValue() : this.input.join  .toValue(),
            this.miter  ? this.miter .toValue() : this.input.miter .toValue());
    }
}


class GColorStyle
extends GObjectBase
{
    style;

    existing;
    linked;



    constructor(nodeId, options)
    {
        super(COLOR_STYLE, nodeId, options);
    }



    copy()
    {
        const copy = new GColorStyle(this.nodeId, this.options);

        copy.style    = this.style.copy();
        
        copy.existing = this.existing;
        copy.linked   = this.linked;

        return copy;
    }



    eval(parse)
    {
        if (this.isCached())
            return this;

            
        this.value = this.value.eval(parse).toValue();
      

        if (   this.value.isValid()
            && (  !this.existing
                || this.linked))
        {
            const rgb = this.value.toRgb();
            this.evalStyle({rgb: rgb});
        }
        else
            this.value = ColorValue.NaN;


        genPushUpdateValue(parse, this.nodeId, 'value', this.value);


        this.validate();

        return this;
    }



    evalStyle(options = {})
    {
        if (!this.options.enabled)
            return;

            
        const style = new FigmaColorStyle(this.nodeId, this.nodeName);

        style.existing = this.existing;


        style.paints = 
        [
            [ 'SOLID', 
                      0xff * options.rgb[0]
              + ' ' + 0xff * options.rgb[1]
              + ' ' + 0xff * options.rgb[2]
              + ' ' + 0xff ]
        ];


        this.style = style;
    }
}


const settings =
{
    dataMode:              false,
    debugMode:             false,

    autoConnectNewNodes:   true,
    enableZoomedOutParams: false,
    minZoomForParams:      0.35,
    showAllColorSpaces:    false,
    showBoolValues:        true,
    showOperationResults:  true,
    showClearUndoWarning:  true,
    showDebugMenu:         false,

    showNodeId:            false, // instead of name

    enableBetaFeatures:    false,
    
    logMessages:           false,
    logActions:            false, 
    
    logLoading:            false, 
    logRequests:           false, 
    logValueUpdates:       false, 
    logObjectUpdates:      false,
    logStyleUpdates:       false,
    
    logRawLoading:         false, 
    logRawSaving:          false, 
    logRawRequests:        false, 
    logRawValues:          false    
};



function updateSetting(settingName, value)
{
    switch (settingName)
    {
        case 'dataMode':              settings.dataMode              = value;  break;
        case 'debugMode':             settings.debugMode             = value;  break;

        case 'autoConnectNewNodes':   settings.autoConnectNewNodes   = value;  break;
        case 'enableZoomedOutParams': settings.enableZoomedOutParams = value;  break;
        case 'minZoomForParams':      settings.minZoomForParams      = value;  break;
        case 'showAllColorSpaces':    settings.showAllColorSpaces    = value;  break;
        case 'showBoolValues':        settings.showBoolValues        = value;  break;
        case 'showOperationResults':  settings.showOperationResults  = value;  break;
        case 'showClearUndoWarning':  settings.showClearUndoWarning  = value;  break;
        case 'showDebugMenu':         settings.showDebugMenu         = value;  break;
        
        case 'showNodeId':            settings.showNodeId            = value;  break;

        case 'enableBetaFeatures':    settings.enableBetaFeatures    = value;  break;
   
        case 'logMessages':           settings.logMessages           = value;  break;
        case 'logActions':            settings.logActions            = value;  break;
        case 'logLoading':            settings.logLoading            = value;  break;
        case 'logRequests':           settings.logRequests           = value;  break;
        case 'logValueUpdates':       settings.logValueUpdates       = value;  break;
        case 'logObjectUpdates':      settings.logObjectUpdates      = value;  break;
        case 'logStyleUpdates':       settings.logStyleUpdates       = value;  break;
   
        case 'logRawLoading':         settings.logRawLoading         = value;  break;
        case 'logRawSaving':          settings.logRawSaving          = value;  break;
        case 'logRawRequests':        settings.logRawRequests        = value;  break;
        case 'logRawValues':          settings.logRawValues          = value;  break;
    } 
}



function updateSettingAndMenu(settingName, valid, value, save = true)
{
    switch (settingName)
    {
        case 'dataMode':              updateSettingAndMenu_(valid, settingName, value, menuItemDataMode);               break;
        case 'debugMode':             updateSettingAndMenu_(valid, settingName, value);                                 break;

        case 'autoConnectNewNodes':   updateSettingAndMenu_(valid, settingName, value, menuItemAutoConnectNewNodes  );  break;
        case 'enableZoomedOutParams': updateSettingAndMenu_(valid, settingName, value, menuItemEnableZoomedOutParams);  break;
        case 'showAllColorSpaces':    updateSettingAndMenu_(valid, settingName, value, menuItemShowAllColorSpaces   );  break;
        case 'showBoolValues':        updateSettingAndMenu_(valid, settingName, value, menuItemShowBoolValues       );  break;
        case 'showOperationResults':  updateSettingAndMenu_(valid, settingName, value, menuItemShowOperationResults );  break;
        case 'showClearUndoWarning':  updateSettingAndMenu_(valid, settingName, value, menuItemShowClearUndoWarning );  break;
        case 'showDebugMenu':         updateSettingAndMenu_(valid, settingName, value, menuItemShowDebugMenu        );  break;

        case 'showNodeId':            updateSettingAndMenu_(valid, settingName, value, menuItemShowNodeId           );  break;
        
        case 'enableBetaFeatures':    updateSettingAndMenu_(valid, settingName, value, menuItemEnableBetaFeatures   );  break;
 
        case 'logMessages':           updateSettingAndMenu_(valid, settingName, value, menuItemLogMessages          );  break;
        case 'logActions':            updateSettingAndMenu_(valid, settingName, value, menuItemLogActions           );  break;
        case 'logLoading':            updateSettingAndMenu_(valid, settingName, value, menuItemLogLoading           );  break;
        case 'logRequests':           updateSettingAndMenu_(valid, settingName, value, menuItemLogRequests          );  break;
        case 'logValueUpdates':       updateSettingAndMenu_(valid, settingName, value, menuItemLogValueUpdates      );  break;
        case 'logObjectUpdates':      updateSettingAndMenu_(valid, settingName, value, menuItemLogObjectUpdates     );  break;
        case 'logStyleUpdates':       updateSettingAndMenu_(valid, settingName, value, menuItemLogStyleUpdates      );  break;
  
        case 'logRawLoading':         updateSettingAndMenu_(valid, settingName, value, menuItemLogRawLoading        );  break;
        case 'logRawSaving':          updateSettingAndMenu_(valid, settingName, value, menuItemLogRawSaving         );  break;
        case 'logRawRequests':        updateSettingAndMenu_(valid, settingName, value, menuItemLogRawRequests       );  break;
        case 'logRawValues':          updateSettingAndMenu_(valid, settingName, value, menuItemLogRawValues         );  break;
    } 

    if (   save
        && settingName != 'showAllColorSpaces')
        uiSetLocalData(settingName, boolToString(value));
}



function updateSettingAndMenu_(valid, setting, value, menu)
{
    if (valid) 
        settings[setting] = value;  

    if (menu)
        menu.setChecked(settings[setting]);
}



function updateSettingsMenus()
{
    menuItemDataMode             .setVisible(settings.dataMode             );
    menuItemDebug                .setVisible(settings.debugMode            );

    menuItemAutoConnectNewNodes  .setChecked(settings.autoConnectNewNodes  );
    menuItemEnableZoomedOutParams.setChecked(settings.enableZoomedOutParams);
    menuItemShowAllColorSpaces   .setChecked(settings.showAllColorSpaces   );
    menuItemShowBoolValues       .setChecked(settings.showBoolValues       );
    menuItemShowOperationResults .setChecked(settings.showOperationResults );
    menuItemShowClearUndoWarning .setChecked(settings.showClearUndoWarning );
    menuItemShowDebugMenu        .setChecked(settings.showDebugMenu        );

    menuItemShowNodeId           .setChecked(settings.showNodeId           );

    menuItemEnableBetaFeatures   .setChecked(settings.enableBetaFeatures   );
  
    menuItemLogMessages          .setChecked(settings.logMessages          );
    menuItemLogActions           .setChecked(settings.logActions           );
  
    menuItemLogLoading           .setChecked(settings.logLoading           );
    menuItemLogRequests          .setChecked(settings.logRequests          );
    menuItemLogValueUpdates      .setChecked(settings.logValueUpdates      );
    menuItemLogObjectUpdates     .setChecked(settings.logObjectUpdates     );
    menuItemLogStyleUpdates      .setChecked(settings.logStyleUpdates      );
  
    menuItemLogRawLoading        .setChecked(settings.logRawLoading        );
    menuItemLogRawSaving         .setChecked(settings.logRawSaving         );
    menuItemLogRawRequests       .setChecked(settings.logRawRequests       );
    menuItemLogRawValues         .setChecked(settings.logRawValues         );
}



function updateMenuItemShowAllColorSpaces()
{
    uiSetPageData('showAllColorSpaces', boolToString(settings.showAllColorSpaces));

    graph.nodes
        .filter(n => COLOR_TYPES.includes(n.type))
        .forEach(n => n.updateNode());
}



function updateMenuItemShowBoolValues()
{
    graph.nodes
        .filter(n => 
                 BOOLEAN_TYPES.includes(n.type)
            || CONDITION_TYPES.includes(n.type))
        .forEach(n => n.updateNode());
}



function updateMenuItemShowOperationResults()
{
    graph.nodes
        .filter(n => n.params.find(p => p.isResult))
        .forEach(n => n.updateNode());
}



function enableFeatures(subscription, beta)
{
    updateMenuItemDisplay(menuItemEnableBetaFeatures.div, subscription);

    updateMenuItemDisplay(btnFlow .div,                 subscription && beta);
    updateMenuItemDisplay(btnShape.div,                 subscription && beta);

    updateMenuItemDisplay(menuItemLogObjectUpdates.div, subscription && beta);

    updateMenuItemDisplay(menuItemCorrectColor    .div, subscription);

    // updateMenuItemDisplay(menuItemStyleFill       .div, subscription && beta);
    // updateMenuItemDisplay(menuItemStyleStroke     .div, subscription && beta);
    // updateMenuItemDisplay(menuItemStyleSep1       .div, subscription && beta);

    updateMenuItemDisplay(menuItemSeries.div,           subscription && beta);    


    graph.nodes.forEach(n => n.updateSubscribeStatus(subscription));
}



function updateMenuItemShowDebugMenu()
{
    updateMenuItemDisplay(menuItemDebug.div, settings.showDebugMenu);
}

 

function updateMenuItemDisplay(menuItem, enable)
{
    menuItem.style.display = enable ? 'block' : 'none';
}



function loadLocalSettings()
{
    uiGetLocalData('dataMode'             );
    uiGetLocalData('debugMode'            );

    uiGetLocalData('autoConnectNewNodes'  );
    uiGetLocalData('enableZoomedOutParams');
    uiGetLocalData('minZoomForParams'     );
    uiGetLocalData('showBoolValues'       );
    uiGetLocalData('showOperationResults' );
    uiGetLocalData('showClearUndoWarning' );
    uiGetLocalData('showDebugMenu'        );

    uiGetLocalData('showNodeId'           );

    uiGetLocalData('enableBetaFeatures'   );
    
    uiGetLocalData('logMessages'          );
    uiGetLocalData('logActions'           );
    
    uiGetLocalData('logLoading'           );
    uiGetLocalData('logRequests'          );
    uiGetLocalData('logValueUpdates'      );
    uiGetLocalData('logObjectUpdates'     );
    uiGetLocalData('logStyleUpdates'      );
    
    uiGetLocalData('logRawLoading'        );
    uiGetLocalData('logRawSaving'         );
    uiGetLocalData('logRawRequests'       );
    uiGetLocalData('logRawValues'         );
}


var genFigMessagePosted = false;



var uiMessages = [];



// --> from UI
///////////////////////////////////////////////////////////////////////////////////////////////////

onmessage = function(e)
{
    const msg = JSON.parse(e.data);


    switch (msg.cmd)
    {
        case 'genRequest':       genRequest      (msg.request);   break;
        //case 'genStopGenerate':  genStopGenerate (msg);         break;

        case 'genEndUiMessage':  genEndUiMessage (msg.msgCmd);    break;
        case 'genEndFigMessage': genEndFigMessage();              break;
    }


    genPostMessageToUI({
        cmd:   'uiEndGenMessage',
        msgCmd: msg.cmd
    });
};

///////////////////////////////////////////////////////////////////////////////////////////////////



// <-- to UI
///////////////////////////////////////////////////////////////////////////////////////////////////

function genPostMessageToUI(msg)
{
    postMessage(JSON.stringify(msg));
}



function genQueueMessageToUI(msg)
{
    uiMessages.push(msg);
    genPostNextMessageToUI();
}



function genPostNextMessageToUI(msg)
{
    if (!isEmpty(uiMessages))
    //    && !genFigMessagePosted)
    {
        //console.log('yes');
        let msg = uiMessages.shift();

        // while (   !isEmpty(uiMessages)
        //        &&  uiMessages[0].cmd     == 'uiUpdateValuesAndObjects'
        //        &&  uiMessages[0].chunkId == 0)
        // {
        //     const nextFirst = uiMessages.find(m => 
        //            m.cmd     == msg.cmd 
        //         && m.chunkId == 0);

        //     if (nextFirst)
        //     {
        //         while (!isEmpty(uiMessages)
        //             &&  uiMessages[0].cmd           == msg.cmd
        //             &&  uiMessages[0].updateNodeId  == msg.updateNodeId
        //             &&  uiMessages[0].updateParamId == msg.updateParamId
        //             &&  uiMessages[0].cmd.chunkId   >  0)
        //             msg = uiMessages.shift();

        //         msg = uiMessages.shift();
        //     }
        // }

        genPostMessageToUI(msg);
    }
}



function genEndUiMessage(msgCmd)
{
    //console.log('next UI message');
    genPostNextMessageToUI();
}



function genEndFigMessage()
{
    genFigMessagePosted = false;
    
    if (   !isEmpty(lastUpdateValues )
        || !isEmpty(lastUpdateObjects)
        || !isEmpty(lastUpdateStyles ))
        genUpdateValuesAndObjects(lastRequestId, -1, lastUpdateNodeId, lastUpdateParamId, [], [], []);

    genPostNextMessageToUI();
}

///////////////////////////////////////////////////////////////////////////////////////////////////


var lastRequestId      = -1;
var lastUpdateNodeId   =  NULL;
var lastUpdateParamId  =  NULL;
var lastUpdateValues   =  [];
var lastUpdateObjects  =  [];
var lastUpdateStyles   =  [];

//var stopGenerate       =  false;



function genRequest(request)
{
    const requestId             = parseInt(request[0]);
    const actionId              = parseInt(request[1]);
    const set                   = parseInt(request[2]);

    const showAllColorSpaces = (set >> 0) & 1 != 0;
    const logRequests           = (set >> 1) & 1 != 0;


    const updateNodeId          = request[3];
    const updateParamId         = request[4];


    const parse = new Parse(
        request, 
        5,
        updateNodeId, 
        updateParamId, 
        showAllColorSpaces,
        logRequests);


    const stackOverflowProtect = 100;

    while (   parse.pos < parse.request.length
           && parse.so  < stackOverflowProtect)
        genParse(parse);


    if (logRequests)
        logRequest(parse);


    const    paramNodes = parse.paramNodeIds.map(id => parse.parsedNodes.find(n => n.nodeId == id));
    const topLevelNodes = parse.parsedNodes.filter(n => n.topLevel);

    for (const node of    paramNodes) node.eval(parse);
    for (const node of topLevelNodes) node.eval(parse);


    for (const node of parse.parsedNodes)
    {
        if (   node instanceof GObjectBase
            && node.options.active)
        {
            node.objects.forEach(o => genPushUpdateObject(parse, o));
            if (!!node.style) genPushUpdateStyle(parse, node.style);
        }
    }


    genUpdateValuesAndObjects(
        requestId,
        actionId,
        parse.updateNodeId,
        parse.updateParamId,
        parse.updateValues,
        parse.updateObjects,
        parse.updateStyles);


    //stopGenerate = false;
}



// function genStopGenerate(msg)
// {
//     console.log('%cSTOP', 'color: white; background: #080;');
//     stopGenerate = true;
// }



function genPushUpdateValue(parse, nodeId, paramId, value, forceUpdate = false)
{
    const found = parse.updateValues.find(v =>
           v.nodeId     == nodeId
        && v.paramId    == paramId
        && v.value.type == value.type);

    if (!found)
    {
        parse.updateValues.push(
        {
            nodeId:  nodeId,
            paramId: paramId,
            type:    value.type, // needed to correctly parse NAN_CHAR
            value:   value
        });
    }
}



function genPushUpdateObject(parse, object)
{
    pushUniqueExcept(
        parse.updateObjects,
        object,
        o => o.nodeId == object.nodeId);
}



function genPushUpdateStyle(parse, style)
{
    pushUniqueExcept(
        parse.updateStyles,
        style,
        o => o.nodeId == style.nodeId);
}



function clearLastUpdate()
{
    lastRequestId     = -1;
    lastUpdateNodeId  =  NULL;
    lastUpdateParamId =  NULL;

    lastUpdateValues  =  [];
    lastUpdateObjects =  [];
    lastUpdateStyles  =  [];
}



function genUpdateValuesAndObjects(requestId, actionId, updateNodeId, updateParamId, updateValues, updateObjects, updateStyles)
{
    if (   isEmpty(updateValues )
        && isEmpty(updateObjects)
        && isEmpty(updateStyles ))
    {
        requestId     = lastRequestId;
        updateNodeId  = lastUpdateNodeId;
        updateParamId = lastUpdateParamId;
        
        updateValues  = lastUpdateValues;
        updateObjects = lastUpdateObjects;
        updateStyles  = lastUpdateStyles;

        clearLastUpdate();
    }
    else if (genFigMessagePosted)
    {
        lastRequestId     = requestId;
        lastUpdateNodeId  = updateNodeId;
        lastUpdateParamId = updateParamId;

        lastUpdateValues  = updateValues;
        lastUpdateObjects = updateObjects;
        lastUpdateStyles  = updateStyles;

        return;
    }

    //console.log('2 updateStyles =', [...updateStyles]);

    const nodeIds = filterUnique(updateValues.map(v => v.nodeId));
    const counts  = nodeIds.map(id => updateValues.filter(v => v.nodeId == id).length);


    // send value updates in chunks

    const approxNodeChunkSize = 20;
    const objChunkSize        = 100;
    const styleChunkSize      = 20;

    
    let n  = 0; // node
    let o  = 0; // object
    let s  = 0; // style

    let nc = 0; // node cunk count
    let oc = 0; // object chunk count
    let sc = 0; // style chunk count


    let nodeValChunk    = [],
        objChunk        = [],
        styleChunk      = [];

    let nodeValChunkId = 0;
        

    while (   n < nodeIds      .length
           || o < updateObjects.length
           || s < updateStyles .length)
    {
        if (n < nodeIds.length)
        {
            nodeValChunk.push(nodeIds[n], counts[n]);

            const values = updateValues.filter(v => v.nodeId == nodeIds[n]);
            values.sort((a, b) => a.paramId - b.paramId);

            for (const v of values)
                nodeValChunk.push(v.paramId, v.type, v.value);

            n++, nc++;
        }


        if (o < updateObjects.length)
        {
            objChunk.push(updateObjects[o]);
            o++, oc++;
        }


        if (s < updateStyles.length)
        {
            styleChunk.push(updateStyles[s]);
            s++, sc++;
        }


        const chunkNotEmpty =
               nc >= approxNodeChunkSize
            || oc == objChunkSize
            || sc == styleChunkSize;


        if (chunkNotEmpty)
        {
            const isLastChunk =    
                   n >= nodeIds      .length
                && o >= updateObjects.length
                && s >= updateStyles .length
                && (   !isEmpty(nodeValChunk)
                    || !isEmpty(objChunk    )
                    || !isEmpty(styleChunk  ));

            genQueueChunk(
                requestId,
                actionId,
                updateNodeId,
                updateParamId,
                nodeValChunkId++,
                nodeValChunk,
                objChunk,
                styleChunk,
                n,
                nodeIds.length,
                isLastChunk);

            nodeValChunk = [];  nc = 0;
            objChunk     = [];  oc = 0;
            styleChunk   = [];  sc = 0;
        }
    }


    const lastChunkNotEmpty =
           !isEmpty(nodeValChunk)
        || !isEmpty(objChunk    )
        || !isEmpty(styleChunk  );


    if (lastChunkNotEmpty)
    {
        genQueueChunk(
            requestId,
            actionId,
            updateNodeId,
            updateParamId,
            nodeValChunkId++,
            nodeValChunk,
            objChunk,
            styleChunk,
            nodeIds.length,
            nodeIds.length,
            true);
    }


    genQueueMessageToUI({
        cmd: 'uiForwardToFigma',
        msg: {cmd: 'figCommitUndo'}
    })
}



function genQueueChunk(requestId, actionId, updateNodeId, updateParamId, nodeValChunkId, nodeValChunk, objChunk, styleChunk, updatedNodes, totalNodes, isLastChunk)
{
    genQueueMessageToUI({
        cmd:          'uiUpdateValuesAndObjects',
        requestId:     requestId,
        actionId:      actionId,
        updateNodeId:  updateNodeId,
        updateParamId: updateParamId,
        chunkId:       nodeValChunkId,
        values:        [...nodeValChunk].map(v => v ? v.toString() : NAN_CHAR),
        objects:       [...objChunk],
        styles:        [...styleChunk],
        updatedNodes:  updatedNodes,
        totalNodes:    totalNodes,
        isLastChunk:   isLastChunk
    });

    if (   !isEmpty(objChunk  )
        || !isEmpty(styleChunk))
        genFigMessagePosted = true;
}


function getObjectBounds(objects)
{
    let boundsL = Number.MAX_SAFE_INTEGER;
    let boundsT = Number.MAX_SAFE_INTEGER;
    let boundsR = Number.MIN_SAFE_INTEGER;
    let boundsB = Number.MIN_SAFE_INTEGER;
    
    for (const obj of objects)
    {
        switch (obj[0])
        {
            case RECTANGLE:
                boundsL = Math.min(boundsL, obj[3]);
                boundsT = Math.min(boundsT, obj[4]);
                boundsR = Math.max(boundsR, obj[3] + obj[5]);
                boundsB = Math.max(boundsB, obj[4] + obj[6]);
                break;
        }
    }

    return {
        x: boundsL, 
        y: boundsT,
        w: boundsR - boundsL,
        h: boundsB - boundsT };
}


function genParseColorValue(parse)
{
    parse.pos++; // COLOR_VALUE

    const col = parse.move();

    if (parse.settings.logRequests) 
        logReqColorValue(col, parse, false);

    return parseColorValue(col)[0];
}



function genParseColor(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const col = new GColor(nodeId, options);

    col.hasInputs = options.hasInputs;
    
  
    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(col, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, col);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    
    let paramIds;

    if (nInputs == 1)
    {
        col.input = genParse(parse);
        paramIds = parse.move().split(',');
    }
    else
        paramIds = ['space', 'convert', 'c1', 'c2', 'c3'];


    parse.inParam = false;
    
    for (const id of paramIds)
    {
        switch (id)
        {
        case 'space':   col.space   = genParse(parse); break;
        case 'convert': col.convert = genParse(parse); break;
        case 'c1':      col.c1      = genParse(parse); break;
        case 'c2':      col.c2      = genParse(parse); break;
        case 'c3':      col.c3      = genParse(parse); break;
        }
    }
    
    
    parse.nTab--;


    genParseNodeEnd(parse, col);
    return col;
}



function genParseValidColor(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const valid = new GValidColor(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(valid, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, valid);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        valid.input = genParse(parse);


    valid.quality = genParse(parse);
    valid.value   = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, valid);
    return valid;
}



function genParseCorrectColor(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const corr = new GCorrectColor(nodeId, options);

    corr.hasInputs = options.hasInputs;


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(corr, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, corr);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    let paramIds;

    if (nInputs == 1)
        corr.input = genParse(parse);


    paramIds = parse.move().split(',');

    parse.inParam = false;
    
    for (const id of paramIds)
    {
        switch (id)
        {
        case 'order':    corr.order   = genParse(parse); break;
        case 'margin1':  corr.margin1 = genParse(parse); break;
        case 'margin2':  corr.margin2 = genParse(parse); break;
        case 'margin3':  corr.margin3 = genParse(parse); break;
        case 'value':    corr.value   = genParse(parse); break;
        }
    }
                

    parse.nTab--;


    genParseNodeEnd(parse, corr);
    return corr;
}



function genParseColorContrast(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const cnt = new GColorContrast(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }


    const valueIndex = 
        nInputs == 1
        ? parseInt(parse.move())
        : -1;

    
    if (parse.settings.logRequests) 
        logReqColorContrast(cnt, nInputs, valueIndex, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, cnt);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    if (nInputs == 2)
    {
        cnt.input0   = genParse(parse);
        cnt.input1   = genParse(parse);
        cnt.standard = genParse(parse);
    }
    else if (nInputs == 1)
    {
             if (valueIndex == 0) cnt.input0 = genParse(parse); 
        else if (valueIndex == 1) cnt.input1 = genParse(parse); 

        cnt.standard = genParse(parse);
    }
    else if (nInputs == 0)
    {
        cnt.standard = genParse(parse);
    }

    parse.nTab--;


    genParseNodeEnd(parse, cnt);
    return cnt;
}



function genParseColorBlind(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const cb = new GColorBlind(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(cb, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, cb);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        cb.input = genParse(parse);

    cb.l = genParse(parse);
    cb.m = genParse(parse);
    cb.s = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, cb);
    return cb;
}



function genParseColorInterpolate(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const lerp = new GColorInterpolate(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }

    
    if (parse.settings.logRequests) 
        logReq(lerp, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, lerp);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 2)
    {
        lerp.input0 = genParse(parse);
        lerp.input1 = genParse(parse);
    }

    else if (nInputs == 1)
        lerp.input0 = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same

    else if (nInputs != 0)
        console.assert(false, 'nInputs must be [0, 2]');


    lerp.space  = genParse(parse);
    lerp.amount = genParse(parse);
    lerp.gamma  = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, lerp);
    return lerp;
}


function genParseComment(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const cmnt = new GComment(nodeId, options);

    
    if (parse.settings.logRequests) 
        logReq(cmnt, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, cmnt);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    genParseNodeEnd(parse, cmnt);
    return cmnt;
}



function genParseListValue(parse)
{
    parse.pos++; // LIST_VALUE

    const list = parse.move();

    if (parse.settings.logRequests) 
        logReqListValue(list, parse, ignore);

    return parseListValue(list)[0];
}



function genParseList(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const list = new GList(nodeId, options);

    
    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(list, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, list);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    
    for (let i = 0; i < nInputs; i++)
        list.inputs.push(genParse(parse));


    parse.nTab--;

        
    genParseNodeEnd(parse, list);
    return list;
}



function genParseItems(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const items = new GItems(nodeId, options);

    
    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(items, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, items);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        items.input = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, items);
    return items;
}



function genParseSelect(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const sel = new GSelect(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(sel, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, sel);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        sel.input = genParse(parse);

    sel.index = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, sel);
    return sel;
}



function genParseIfElse(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const ifElse = new GIfElse(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }


    const valueIndex = 
        nInputs == 1
        ? parseInt(parse.move())
        : -1;


    if (parse.settings.logRequests) 
        logReq(ifElse, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, ifElse);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    if (nInputs == 2)
    {
        ifElse.input0    = genParse(parse);
        ifElse.input1    = genParse(parse);
        ifElse.condition = genParse(parse);
    }
    else if (nInputs == 1)
    {
             if (valueIndex == 0) ifElse.input0 = genParse(parse); 
        else if (valueIndex == 1) ifElse.input1 = genParse(parse); 

        ifElse.condition = genParse(parse);
    }
    else if (nInputs == 0)
    {
        ifElse.condition = genParse(parse);
    }

    parse.nTab--;


    genParseNodeEnd(parse, ifElse);
    return ifElse;
}



function genParseStart(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const start = new GStart(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(start, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, start);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        start.input = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, start);
    return start;
}



function genParseRepeat(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const rep = new GRepeat(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(rep, parse, ignore, nInputs);
        // logReqRepeat(rep, nInputs, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, rep);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        rep.input = genParse(parse);

    rep.count = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, rep);
    return rep;
}



function genParseCache(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const cache = new GCache(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(cache, parse, ignore, nInputs);
        //logReqCache(cache, nInputs, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, cache);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        cache.input = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, cache);
    return cache;
}



function genParseCopy(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const copy = new GCopy(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(copy, parse, ignore, nInputs);
        //logReqCopy(copy, nInputs, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, copy);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        copy.input = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, copy);
    return copy;
}


function genParseNumValue(parse)
{
    parse.pos++; // N

    const val = parse.move();

    if (parse.settings.logRequests) 
        logReqNumberValue(val, parse, false);

    return val.indexOf(',') >= 0
         ? parseNumberValue      (val)[0]
         : parseSimpleNumberValue(val)[0];
}



function genParseNumber(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const num = new GNumber(nodeId, options);

    
    if (parse.settings.logRequests) 
        logReq(num, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, num);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;
    parse.inParam = false;


    if (parse.next == NUMBER_VALUE) num.value = genParse(parse);
    else                            num.input = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, num);
    return num;
}



function genParseAbsolute(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const round = new GAbsolute(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(round, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, round);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        round.input = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, round);
    return round;
}



function genParseRound(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const round = new GRound(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(round, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, round);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        round.input = genParse(parse);

    round.type     = genParse(parse);
    round.decimals = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, round);
    return round;
}



function genParseLimits(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const lim = new GLimits(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(lim, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, lim);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        lim.input = genParse(parse);

    lim.min = genParse(parse);
    lim.max = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, lim);
    return lim;
}



function genParseMath(parse, newNode)
{
    const [type, nodeId, options, ignore] = genParseNodeStart(parse);


    const math = newNode(nodeId, options);

    
    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(math, parse, ignore, nInputs);
        //logReqMath(math, nInputs, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, math);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    for (let i = 0; i < nInputs; i++)
        math.inputs.push(genParse(parse));


    math.operation = genParse(parse);


    parse.nTab--;

        
    genParseNodeEnd(parse, math);
    return math;
}



function genParseArithmetic(parse, newNode)
{
    const [type, nodeId, options, ignore] = genParseNodeStart(parse);


    const arith = newNode(nodeId, options);


    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(arith, parse, ignore, nInputs);
        //logReqArithmetic(arith, type, nInputs, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, arith);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    for (let i = 0; i < nInputs; i++)
        arith.inputs.push(genParse(parse));

    parse.nTab--;

        
    genParseNodeEnd(parse, arith);
    return arith;
}



function genParseSeries(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const series = new GSeries(nodeId, options);


    if (parse.settings.logRequests) 
        logReq(series, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, series);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    series.start = genParse(parse);
    series.step  = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, series);
    return series;
}



function genParseRandom(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const rnd = new GRandom(nodeId, options);


    if (parse.settings.logRequests) 
        logReq(rnd, parse);


    if (ignore) 
    {
        genParseNodeEnd(parse, rnd);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    rnd.seed = genParse(parse);
    rnd.min  = genParse(parse);
    rnd.max  = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, rnd);
    return rnd;
}



function genParseInterpolate(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const lerp = new GInterpolate(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }

    
    if (parse.settings.logRequests) 
        logReq(lerp, parse, ignore, nInputs);
        //logReqInterpolate(lerp, nInputs, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, lerp);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    if (nInputs == 2)
    {
        lerp.input0 = genParse(parse);
        lerp.input1 = genParse(parse);
        lerp.amount = genParse(parse);
    }
    else if (nInputs == 1)
    {
        lerp.input0 = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same
        lerp.amount = genParse(parse);
    }
    else if (nInputs == 0)
    {
        lerp.amount = genParse(parse);
    }

    parse.nTab--;


    genParseNodeEnd(parse, lerp);
    return lerp;
}



function genParseBoolean(parse)
{
    const [type, nodeId, options, ignore] = genParseNodeStart(parse);


    const bool = new GBoolean(nodeId, options);

    
    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(bool, parse, ignore, nInputs);
        //logReqBoolean(bool, nInputs, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, bool);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    for (let i = 0; i < nInputs; i++)
        bool.inputs.push(genParse(parse));


    bool.operation = genParse(parse);


    parse.nTab--;

        
    genParseNodeEnd(parse, bool);
    return bool;
}



function genParseCondition(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const cond = new GCondition(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }

    
    if (parse.settings.logRequests) 
        logReq(cond, parse, ignore, nInputs);
        //logReqCondition(cond, nInputs, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, cond);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    if (nInputs == 2)
    {
        cond.input0    = genParse(parse);
        cond.input1    = genParse(parse);
        cond.operation = genParse(parse);
    }
    else if (nInputs == 1)
    {
        cond.input0    = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same
        cond.operation = genParse(parse);
    }
    else if (nInputs == 0)
    {
        cond.operation = genParse(parse);
    }

    parse.nTab--;


    genParseNodeEnd(parse, cond);
    return cond;
}



function genParseConditionBase(parse, newNode)
{
    const [type, nodeId, options, ignore] = genParseNodeStart(parse);


    const cond = newNode(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }

    
    if (parse.settings.logRequests)
        logReq(cond, parse, ignore, nInputs); 
        //logReqConditionBase(cond, type, nInputs, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, cond);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    if (nInputs == 2)
    {
        cond.input0 = genParse(parse);
        cond.input1 = genParse(parse);
    }
    else if (nInputs == 1)
    {
        cond.input0 = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same
    }

    parse.nTab--;


    genParseNodeEnd(parse, cond);
    return cond;
}



function genParseRectangle(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const rect = new GRectangle(nodeId, options);


    if (parse.settings.logRequests) 
        logReq(rect, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, rect);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (RECTANGLE_TYPES.includes(parse.next))
        rect.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {
        case 'x':      rect.x      = genParse(parse); break;
        case 'y':      rect.y      = genParse(parse); break;
        case 'width':  rect.width  = genParse(parse); break;
        case 'height': rect.height = genParse(parse); break;
        case 'angle':  rect.angle  = genParse(parse); break;
        case 'round':  rect.round  = genParse(parse); break;
        }
    }
    
    
    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, rect);
    return rect;
}



function genParseLine(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);

  
    const line = new GLine(nodeId, options);


    if (parse.settings.logRequests) 
        logReqShape(line, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, rect);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (LINE_TYPES.includes(parse.next))
        line.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {
        case 'x':     line.x     = genParse(parse); break;
        case 'y':     line.y     = genParse(parse); break;
        case 'width': line.width = genParse(parse); break;
        case 'angle': line.angle = genParse(parse); break;
        }
    }


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, line);
    return line;
}



function genParseEllipse(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const ellipse = new GEllipse(nodeId, options);


    if (parse.settings.logRequests) 
        logReqShape(ellipse, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, ellipse);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (ELLIPSE_TYPES.includes(parse.next))
        ellipse.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {
        case 'x':      ellipse.x      = genParse(parse); break;
        case 'y':      ellipse.y      = genParse(parse); break;
        case 'width':  ellipse.width  = genParse(parse); break;
        case 'height': ellipse.height = genParse(parse); break;
        case 'angle':  ellipse.angle  = genParse(parse); break;
        }
    }
    
    
    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, ellipse);
    return ellipse;
}



function genParsePolygon(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const poly = new GPolygon(nodeId, options);


    if (parse.settings.logRequests) 
        logReqShape(poly, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, poly);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (POLYGON_TYPES.includes(parse.next))
        poly.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {
        case 'x':       poly.x       = genParse(parse); break;
        case 'y':       poly.y       = genParse(parse); break;
        case 'width':   poly.width   = genParse(parse); break;
        case 'height':  poly.height  = genParse(parse); break;
        case 'angle':   poly.angle   = genParse(parse); break;
        case 'round':   poly.round   = genParse(parse); break;
        case 'corners': poly.corners = genParse(parse); break;
        }
    }
    
    
    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, poly);
    return poly;
}



function genParseStar(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const star = new GStar(nodeId, options);


    if (parse.settings.logRequests) 
        logReqShape(star, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, star);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (STAR_TYPES.includes(parse.next))
        star.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {
        case 'x':      star.x      = genParse(parse); break;
        case 'y':      star.y      = genParse(parse); break;
        case 'width':  star.width  = genParse(parse); break;
        case 'height': star.height = genParse(parse); break;
        case 'angle':  star.angle  = genParse(parse); break;
        case 'round':  star.round  = genParse(parse); break;
        case 'points': star.points = genParse(parse); break;
        case 'convex': star.convex = genParse(parse); break;
        }
    }
    
    
    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, star);
    return star;
}


function genParseFillValue(parse)
{
    parse.pos++; // FILL_VALUE

    const fill = parse.move();

    if (parse.settings.logRequests) 
        logReqFillValue(fill, parse, ignore);

    return parseFillValue(fill)[0];
}



function genParseFill(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const fill = new GFill(nodeId, options);


    if (parse.settings.logRequests) 
        logReq(fill, parse, ignore);


    if (ignore)
    {
        genParseNodeEnd(parse, fill);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (OBJECT_TYPES.includes(parse.next))
        fill.input = genParse(parse);
    // ||    parse.next == PARAM
    //    && FILL_TYPES.includes(parse.afterNext))


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.nTab++;
        parse.inParam = true;

        
        switch (paramId)
        {
        case 'color'  : fill.color   = genParse(parse); break;
        case 'opacity': fill.opacity = genParse(parse); break;
        }


        parse.nTab--;
    }

    
    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, fill);
    return fill;
}



function genParseFillParam(parse)
{
    const fill = genParse(parse); 

    if (COLOR_TYPES.includes(fill.type))
        fill.options.opacity = genParse(parse);

    return fill;
}



function genParseStrokeValue(parse)
{
    parse.pos++; // STROKE_VALUE

    const stroke = parse.move();

    if (parse.settings.logRequests) 
        logReqStrokeValue(stroke, parse, false);

    return parseStrokeValue(stroke)[0];
}



function genParseStroke(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const stroke = new GStroke(nodeId, options);


    if (parse.settings.logRequests) 
        logReq(stroke, parse, ignore);


    if (ignore)
    {
        genParseNodeEnd(parse, stroke);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (OBJECT_TYPES.includes(parse.next))
        stroke.input = genParse(parse);
        //   parse.next == PARAM
        //   && STROKE_TYPES.includes(parse.afterNext))


    const nParamIds = genParseParamCount(parse);
       
    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.nTab++;
        parse.inParam = true;


        switch (paramId)
        {
        case 'fill':   stroke.fill   = genParseFillParam(parse); break;
        case 'weight': stroke.weight = genParse(parse);          break;
        case 'fit':    stroke.fit    = genParse(parse);          break;
        case 'join':   stroke.join   = genParse(parse);          break;
        case 'miter':  stroke.miter  = genParse(parse);          break;
        }


        parse.nTab--;
    }

    
    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, stroke);
    return stroke;
}



function genParseStrokeParam(parse)
{
    const stroke = genParse(parse); 

    if (    FILL_TYPES.includes(stroke.type)
        || COLOR_TYPES.includes(stroke.type))
        stroke.data.weight = genParse(parse);

    return stroke;
}



function genParseColorStopValue(parse)
{
    parse.pos++; // COLOR_STOP_VALUE

    const stop = parse.move();

    if (parse.settings.logRequests) 
        logReqColorStopValue(stop, parse, false);

    return parseColorStopValue(stop);
}



function genParseColorStop(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const stop = new GColorStop(nodeId, options);


    if (parse.settings.logRequests) 
        logReq(stop, parse, ignore);


    if (ignore)
    {
        genParseNodeEnd(parse, stop);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (   parse.next == COLOR_STOP
        || parse.next == COLOR_STOP_VALUE)
        stop.input = genParse(parse);


    stop.fill     = genParse(parse);
    stop.position = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, stop);
    return stop;
}



// function genParseColorStyleValue(parse)
// {
//     parse.pos++; // COLOR_STYLE_VALUE

//     const style = parse.move();

//     if (parse.settings.logRequests) 
//         logReqStyleValue(style, parse);

//     return parseColorStyleValue(style)[0];
// }



function genParseColorStyle(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const style = new GColorStyle(nodeId, options);

    style.existing = options.existing;
    style.linked   = options.linked;


    if (parse.settings.logRequests) 
        logReq(style, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, style);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;
    parse.inParam = false;


    style.value = genParse(parse);
   

    parse.nTab--;


    genParseNodeEnd(parse, style);
    return style;
}



//function genParseStyleParam(parse)
//{
    // const style = genParse(parse); 

    // if (STYLE_TYPES.includes(style.type))
    //     style.options.opacity = genParse(parse);

    // return style;
//}



class Parse
{
    request;
    
    pos; 
    so;

    settings = {};


    log  = '';
    
    nTab = 0;

    get tab() { return this.inParam ? ' ' : (NL + TAB.repeat(Math.max(0, this.nTab))); }

    
    inParam = false;

    
    updateNodeId;
    updateParamId;

    scope         = []; // current parse stack
    parsedNodes   = []; // must be evaluated to create the value updates

    paramNodeIds  = [];

    updateParams  = [];
    updateValues  = [];
    updateObjects = [];
    updateStyles  = [];

    
    get next() { return this.request[this.pos]; }

    get afterNext() 
    { 
        return this.pos+1 < this.request.length 
             ? this.request[this.pos+1]
             : null;
    }



    constructor(request, firstPos, updateNodeId, updateParamId, showAllColorSpaces, logRequests)
    {
        this.request       = request;
          
        this.pos           = firstPos; 
        this.so            = 0;
        
        this.updateNodeId  = updateNodeId; 
        this.updateParamId = updateParamId;
   
        
        this.settings.showAllColorSpaces = showAllColorSpaces;
        this.settings.logRequests           = logRequests;
    }



    move()
    {
        return this.request[this.pos++];
    }
}



function genParse(parse, inParam = true)
{
    //console.log('parse.next', parse.next);

    if (!inParam)
        parse.inParam = false;


    let result = null;


         if (parse.next == PARAM                  ) result = genParseParam           (parse);
        
    else if (parse.next == LIST_VALUE             ) result = genParseListValue       (parse);
    else if (parse.next == LIST                   ) result = genParseList            (parse);
    else if (parse.next == ITEMS                  ) result = genParseItems           (parse);
    else if (parse.next == SELECT                 ) result = genParseSelect          (parse);
    else if (parse.next == IF_ELSE                ) result = genParseIfElse          (parse);
    else if (parse.next == START                  ) result = genParseStart           (parse);
    else if (parse.next == REPEAT                 ) result = genParseRepeat          (parse);
    else if (parse.next == CACHE                  ) result = genParseCache           (parse);
    else if (parse.next == COPY                   ) result = genParseCopy            (parse);
    
    else if (parse.next == NUMBER_VALUE           ) result = genParseNumValue        (parse);
    else if (parse.next == NUMBER                 ) result = genParseNumber          (parse);
    
    else if (parse.next == NUMBER_ABSOLUTE        ) result = genParseAbsolute        (parse);
    else if (parse.next == NUMBER_ROUND           ) result = genParseRound           (parse);
    else if (parse.next == NUMBER_LIMITS          ) result = genParseLimits          (parse);
    else if (parse.next == NUMBER_RANDOM          ) result = genParseRandom          (parse);
    else if (parse.next == NUMBER_SERIES          ) result = genParseSeries          (parse);
    else if (parse.next == NUMBER_INTERPOLATE     ) result = genParseInterpolate     (parse);
    
    else if (parse.next == NUMBER_MATH            ) result = genParseMath            (parse, (nodeId, options) => new GMath          (nodeId, options));
    else if (parse.next == NUMBER_ADD             ) result = genParseArithmetic      (parse, (nodeId, options) => new GAdd           (nodeId, options));
    else if (parse.next == NUMBER_SUBTRACT        ) result = genParseArithmetic      (parse, (nodeId, options) => new GSubtract      (nodeId, options));
    else if (parse.next == NUMBER_MULTIPLY        ) result = genParseArithmetic      (parse, (nodeId, options) => new GMultiply      (nodeId, options));
    else if (parse.next == NUMBER_DIVIDE          ) result = genParseArithmetic      (parse, (nodeId, options) => new GDivide        (nodeId, options));
    else if (parse.next == NUMBER_MODULO          ) result = genParseArithmetic      (parse, (nodeId, options) => new GModulo        (nodeId, options));
    else if (parse.next == NUMBER_EXPONENT        ) result = genParseArithmetic      (parse, (nodeId, options) => new GExponent      (nodeId, options));
    
    else if (parse.next == NUMBER_BOOLEAN         ) result = genParseBoolean         (parse);
    else if (parse.next == NUMBER_NOT             ) result = genParseArithmetic      (parse, (nodeId, options) => new GNot           (nodeId, options));
    else if (parse.next == NUMBER_AND             ) result = genParseArithmetic      (parse, (nodeId, options) => new GAnd           (nodeId, options));
    else if (parse.next == NUMBER_OR              ) result = genParseArithmetic      (parse, (nodeId, options) => new GOr            (nodeId, options));
    else if (parse.next == NUMBER_XOR             ) result = genParseArithmetic      (parse, (nodeId, options) => new GXor           (nodeId, options));
    
    else if (parse.next == NUMBER_CONDITION       ) result = genParseCondition       (parse);
    else if (parse.next == NUMBER_EQUAL           ) result = genParseConditionBase   (parse, (nodeId, options) => new GEqual         (nodeId, options));
    else if (parse.next == NUMBER_NOT_EQUAL       ) result = genParseConditionBase   (parse, (nodeId, options) => new GNotEqual      (nodeId, options));
    else if (parse.next == NUMBER_LESS            ) result = genParseConditionBase   (parse, (nodeId, options) => new GLess          (nodeId, options));
    else if (parse.next == NUMBER_LESS_OR_EQUAL   ) result = genParseConditionBase   (parse, (nodeId, options) => new GLessOrEqual   (nodeId, options));
    else if (parse.next == NUMBER_GREATER         ) result = genParseConditionBase   (parse, (nodeId, options) => new GGreater       (nodeId, options));
    else if (parse.next == NUMBER_GREATER_OR_EQUAL) result = genParseConditionBase   (parse, (nodeId, options) => new GGreaterOrEqual(nodeId, options));

    else if (parse.next == COLOR_VALUE            ) result = genParseColorValue      (parse);
    else if (parse.next == COLOR                  ) result = genParseColor           (parse);
    else if (parse.next == VALID_COLOR            ) result = genParseValidColor      (parse);
    else if (parse.next == CORRECT_COLOR          ) result = genParseCorrectColor    (parse);
    else if (parse.next == COLOR_CONTRAST         ) result = genParseColorContrast   (parse);
    else if (parse.next == COLORBLIND             ) result = genParseColorBlind      (parse);
    else if (parse.next == COLOR_INTERPOLATE      ) result = genParseColorInterpolate(parse);
     
    else if (parse.next == FILL_VALUE             ) result = genParseFillValue       (parse);
    else if (parse.next == FILL                   ) result = genParseFill            (parse);
     
    else if (parse.next == STROKE_VALUE           ) result = genParseStrokeValue     (parse);
    else if (parse.next == STROKE                 ) result = genParseStroke          (parse);
     
    else if (parse.next == COLOR_STOP_VALUE       ) result = genParseColorStopValue  (parse);
    else if (parse.next == COLOR_STOP             ) result = genParseColorStop       (parse);
     
    //else if (parse.next == COLOR_STYLE_VALUE      ) result = genParseStyleValue      (parse);
    else if (parse.next == COLOR_STYLE            ) result = genParseColorStyle      (parse);
     
    else if (parse.next == RECTANGLE              ) result = genParseRectangle       (parse);
    else if (parse.next == LINE                   ) result = genParseLine            (parse);
    else if (parse.next == ELLIPSE                ) result = genParseEllipse         (parse);
    else if (parse.next == POLYGON                ) result = genParsePolygon         (parse);
    else if (parse.next == STAR                   ) result = genParseStar            (parse);

    else if (parse.next == COMMENT                ) result = genParseComment         (parse);

    else console.assert(false, 'unknown parse token \'' + parse.next + '\'');


    parse.inParam = false;


    if (result)
        return result;
    else
    {
        parse.so++;
        return null;
    }
}



function genParseNodeStart(parse)
{
    const type     = parse.move();
    const nodeId   = parse.move();
    const nodeName = parse.move();

    
    parse.scope.push(nodeId);


    if (parse.parsedNodes.find(n => n.nodeId == nodeId))
        return [type, nodeId, {nodeName: nodeName}, true];


    const options = genParseNodeOptions(parse);

    options.nodeName = nodeName;


    return [type, nodeId, options, false];
}



function genParseNodeEnd(parse, node = null)
{
    parse.scope.pop();

    if (node)
    {
        if (isEmpty(parse.scope))
            node.topLevel = true;

        pushUnique(parse.parsedNodes, node);
    }
}



function genParseNodeOptions(parse)
{
    const opt = parseInt(parse.move());

    const options = 
    {
        active:       ((opt >>  0) & 1) != 0,
        beforeActive: ((opt >>  1) & 1) != 0,
        enabled:      ((opt >>  2) & 1) != 0,
        cached:       ((opt >>  3) & 1) != 0,
        hasInputs:    ((opt >> 20) & 1) != 0,
        existing:     ((opt >> 21) & 1) != 0,
        linked:       ((opt >> 22) & 1) != 0
    };

    return options;
}



function genParseParamCount(parse)
{
    const nParamIds = parseInt(parse.move());

    if (parse.settings.logRequests) 
        parse.log += parse.tab + nParamIds;

    return nParamIds;
}



function genParseParam(parse)
{
    if (parse.next != PARAM) 
        return null;
        
    parse.move(); // PARAM
    const type = parse.move(); // type

    
    const nodeId  = parse.move();
    const paramId = parse.move();
    
    const param   = new GParam(nodeId, paramId);
 
    
    pushUnique(parse.paramNodeIds, nodeId);


    if (parse.settings.logRequests) 
        logReqParam(param, type, parse);


    return param;
}



function genParseParamId(parse)
{
    const paramId = parse.move();

    if (parse.settings.logRequests)
        parse.log += parse.tab + paramId;

    return paramId;
}


class RequestSettings
{
    request;
    pos;

    so            = 0;
    nTab          = 0;
  
    skipNewLine   = false;

    loggedNodeIds = [];
    


    constructor(request, pos)
    {
        this.request = request;
        this.pos     = pos;
    }


    get tab() 
    { 
        if (this.skipNewLine)
        {
            this.skipNewLine = false;
            return '';
        }
        else 
            return NL + TAB.repeat(Math.max(0, this.nTab)); 
    }
}



function log(str)
{
    debugInfo.innerHTML = str;
}



function logFunction(funcName, obj = null)
{
    let str = funcName;

    if (obj)
        str = obj.id + '.' + str;

    console.log(
        '%c ' + str + ' ', 
        'background: #fc0; color: #632;');
}



function logString(str, color = 'white', background = 'red')
{
    console.log(
        '%c ' + str + ' ', 
        'background: ' + background + '; color: ' + color + ';');
}



function logValueUpdates(updateNodeId, updateParamId, values)
{
    //console.log('values = ', values);

    let log     = '';
    let newLine = true;

    if (   updateNodeId  != '' 
        || updateParamId != '')
        log = '↓ ' + logReqId(updateNodeId) + '.' + logReqId(updateParamId);
    else
        newLine = false;

          
    let i    = 0;
    let nTab = 0;

    while (i < values.length)
    {
        const nodeId  = values[i++];
        const nInputs = parseInt(values[i++]);

        log += 
              (newLine ? NL : '') + TAB.repeat(Math.max(0, nTab))
            + nodeId;// + ' ' + nInputs;

        newLine = true;

        nTab++;

        for (let j = 0; j < nInputs; j++)
        {
            const index = values[i++];
            const type  = values[i++];
            const value = values[i++];

            log += 
                  NL + TAB.repeat(Math.max(0, nTab))
                + index + ' ' + displayValue(type, value);
        }

        nTab--;
    }


    console.log(
        '%c%s', 
        'background: #e70; color: white;', 
        log);
}



function logObjectUpdates(objects)
{
    console.log(
        '%cobjects', 
        'background: #07e; color: white;', 
        objects);
}



function logStyleUpdates(styles)
{
    console.log(
        '%cstyles', 
        'background: #b4d; color: white;', 
        styles);
}



function logSaveNodes(nodeJson)
{
    console.log('%cSAVING NODES\n' + nodeJson, 'color: black; background: #ddeeff;');
}



function logSaveConnections(conns)
{
    let log = 'SAVING ' + conns.length + ' ' + countString('CONNECTION', conns.length);

    for (const conn of conns)
        log += '\n' + conn.toJson();

    console.log(
        '%c' + log, 
        'color: black; background: #ddeeff;');
}



function logUpdateSavedConnections(conns)
{
    let log = 'UPDATING ' + conns.length + ' ' + countString('SAVED CONNECTION', conns.length);

    for (const conn of conns)
        log += '\n' + conn.toJson();

    console.log(
        '%c' + log, 
        'color: black; background: #ddeeff;');
}



function logRequest(parse)
{
    let log = '';

    if (   parse.updateNodeId  != '' 
        || parse.updateParamId != '')
        log = '↓ ' + logReqId(parse.updateNodeId) + '.' + logReqId(parse.updateParamId);

    log += parse.log;

    console.log(
        '%c%s', 
        'background: #60aa60; color: #fff', 
         log);
}



function logReq(node, parse, ignore, nInputs = -1)
{
    parse.log += parse.tab + node.type;
    parse.log += logReqNodeId(node, ignore);

    if (    nInputs > -1
        && !ignore)
        parse.log += ' ' + nInputs;
}



function logReqNodeId(node, ignore = false)
{
    return ' ' 
         + logReqId(node.nodeId) 
         + ' ' + logReqId(node.nodeName)
         + (!ignore
            ? logReqOptions(node)
            : '');
}



function logReqId(nodeId)
{
    return nodeId == '' ? '\'\'' : nodeId;
}



function logReqOptions(node)
{
    let log = '';

    if ( node.options.active      ) log += ' ' + ACTIVE;
    if ( node.options.beforeActive) log += ' ' + BEFORE_ACTIVE;
    if (!node.options.enabled     ) log += ' ' + DISABLED;
    if (!node.options.cached      ) log += ' ' + NOCACHE;

    return log;
}



function logReqParam(param, type, parse)
{
    parse.log += 
                parse.tab + PARAM
        + ' ' + type 
        + ' ' + logReqId(param.nodeId) 
        + '.' + logReqId(param.paramId);
}



function logReqNode(node, parse)
{
    parse.log += parse.tab + node.type;
    parse.log += logReqNodeId(node);
}



function logReqListValue(list, parse, ignore)
{
    parse.log += parse.tab + LIST_VALUE + ' ' + displayValue(LIST_VALUE, list);
}



function logReqColorValue(val, parse, ignore)
{
    parse.log += parse.tab + COLOR_VALUE + ' ' + displayValue(COLOR_VALUE, val);
}



function logReqColorContrast(lerp, nInputs, valueIndex, parse, ignore)
{
    parse.log += parse.tab + COLOR_CONTRAST;
    parse.log += logReqNodeId(lerp, ignore);

    if (!ignore)
    {
        parse.log += ' ' + nInputs;

        if (nInputs == 1)
            parse.log += ' ' + valueIndex;
    }
}



function logReqNumberValue(val, parse, ignore)
{
    parse.log += parse.tab + NUMBER_VALUE + ' ' + displayValue(NUMBER_VALUE, val);
}



function logReqFillValue(fill, parse, ignore)
{
//     parse.log += parse.tab + FILL_VALUE + ' ' + displayValue(FILL_VALUE, fill);
}



function logReqStrokeValue(stroke, parse, ignore)
{
    // parse.log += parse.tab + STROKE_VALUE + ' ' + displayValue(STROKE_VALUE, stroke);
}



function logReqColorStopValue(stop, parse, ignore)
{
    // parse.log += parse.tab + COLOR_STOP_VALUE + ' ' + displayValue(COLOR_STOP_VALUE, stop);
}



function logSavedNode(nodeKey)
{
    let log = formatSavedNodeJson(figGetPageData(nodeKey, false));

    console.log(
        '%c%s\n%c%s', 
        'background: #fdb', 
         noNodeTag(nodeKey), 
        'background: #fed;',    
         log);
}



function formatSavedNodeJson(json)
{
    let formJson = json
        .replace('{\n', '')
        .replace('\n}', '')

        .replace('[\n' + TAB, '')
        .replace('\n' + TAB + ']', '')

        .split(TAB + '"params":\n').join('') // have to do .split().join() because there's no .replace() in TS

        .split('": "').join(': ')
        .split('", "').join(': ')

        .split(TAB + '"').join(TAB)
        .split(TAB + TAB + '["').join(TAB + TAB)
        
        .split('",\n').join('\n')
        .split('"\n').join('\n')
        
        .split('"],\n').join('\n');


    if (formJson[formJson.length-1] == '"')
        formJson = formJson.substring(0, formJson.length - 1);

    if (formJson.substring(formJson.length-2) == '"]')    
        formJson = formJson.substring(0, formJson.length - 2);

    return formJson;
}



function formatSavedDataJson(json)
{
    let formJson = json
        .replace('{\n', '')
        .replace('\n}', '')
        .replace('[\n' + TAB, '')
        .replace('\n' + TAB + ']', '');

    return formJson;
}



function logSavedConn(conn)
{
    const strConn = connToString(conn, true);

    console.log(
        '%c%s', 
        'background: #cfc', 
        strConn); 
}


// Observer = 2°

const D65 = [0.95047, 1, 1.08883]; 


function createColorSpace(R, G, B, Y, W, gamma, degamma, regamma, luminance)
{
    return {    
        R:         R,
        G:         G,
        B:         B,

        Y:         Y,

        W:         W,

        lin2xyz:   rgbMatrix(R, G, B, W),
        xyz2lin:   inverse(rgbMatrix(R, G, B, W)),

        gamma:     gamma,
        degamma:   degamma,
        regamma:   regamma,
        
        luminance: luminance
    };
}


function rgbMatrix(R, G, B, W)
{
    const C0 = colorVector(R);
    const C1 = colorVector(G);
    const C2 = colorVector(B);

    const M = [ [ C0[0], C1[0], C2[0] ], 
                [ C0[1], C1[1], C2[1] ], 
                [ C0[2], C1[2], C2[2] ] ];

    const S = mulv3m3(W, inverse(M));

    return [ [ S[0]*C0[0], S[1]*C1[0], S[2]*C2[0] ],
             [ S[0]*C0[1], S[1]*C1[1], S[2]*C2[1] ],
             [ S[0]*C0[2], S[1]*C1[2], S[2]*C2[2] ] ];
}


function colorVector(c)
{
    const x = c[0],
          y = c[1];

    return [x/y, 1, (1-x-y)/y];
}



const sRGB = createColorSpace
(
    [0.64, 0.33], // R
    [0.3,  0.6 ], // G
    [0.15, 0.06], // B

    [0.212656,
     0.715158,
     0.072186], // Y

    D65,        // W

    2.4,        // gamma



    function(v) // degamma
    {
        return v > 0.04045
               ? Math.pow((v + 0.055) / 1.055, this.gamma)
               : v / 12.92;
    },
    


    function(v) // regamma
    {
        return v > 0.0031308
               ? 1.055 * Math.pow(v, 1/this.gamma) - 0.055
               : v * 12.92;
    },
    

    
    function(rgb) // luminance
    {
        return  this.Y[0] * this.degamma(rgb[0]) 
              + this.Y[1] * this.degamma(rgb[1]) 
              + this.Y[2] * this.degamma(rgb[2]);
    }
);



function rgbSaturateHsv(rgb, amount)
{
    const hsv = rgb2hsv(rgb);
    hsv[1] *= amount;
    return hsv2rgb(hsv);
}



function rgbSaturateHsl(rgb, amount)
{
    const hsl = rgb2hsl(rgb);
    hsl[1] *= amount;
    return hsl2rgb(hsl);
}


function rgb2hsv_(r, g, b)
{
    let h, s, v;

    let min = Math.min(Math.min(r, g), b),
        max = Math.max(Math.max(r, g), b);

    let delta = max - min;

    v = max;
    s = max == 0 ? 0 : delta / max;
	
    if      (max == r) h = 1/6 * (g - b) / delta + 1;   // between yellow and magenta
    else if (max == g) h = 1/6 * (b - r) / delta + 1/3; // between cyan and yellow
    else if (max == b) h = 1/6 * (r - g) / delta + 2/3; // between between magenta and cyan

	if (h > 1) h -= 1;
	//if (h < 0) h += 1;

    return [h, s, v];
}



function rgb2hsv(rgb)
{
    return rgb2hsv_(rgb[0], rgb[1], rgb[2]);
}



function hsv2rgb_(h, s, v)
{
    // h %= 1;

    // if (h < 0) h += 1;
    //while (h > 1) h -= 1;

    if (s == 0)
        return [v, v, v]; // achromatic

    h *= 6 - 0.0000001;

    let i = Math.floor(h);
    let f = h - i;
	
    let p = v * (1 - s);
    let q = v * (1 - s * f);
    let t = v * (1 - s * (1 - f));

    switch (i)
    {
        case 0:  return [v, t, p];
        case 1:  return [q, v, p];
        case 2:  return [p, v, t];
        case 3:  return [p, q, v];
        case 4:  return [t, p, v];
        default: return [v, p, q];
    }
}



function hsv2rgb(hsv)
{
	return hsv2rgb_(hsv[0], hsv[1], hsv[2]);
}


function rgb2hsl_(r, g, b)
{
    let h, s, l;

    let min = Math.min(Math.min(r, g), b),
        max = Math.max(Math.max(r, g), b);

    let delta = max - min;

    l = (max + min) / 2;

         if (max == min) h = 0;
    else if (max == r  ) h = 1/6 * (g - b) / delta + 1;
    else if (max == g  ) h = 1/6 * (b - r) / delta + 1/3;
    else if (max == b  ) h = 1/6 * (r - g) / delta + 2/3;

         if (max == min) s = 0;
    else if (l <= 0.5)   s = delta / (2 * l);
    else if (l >  0.5)   s = delta / (2 - 2 * l);

    return [h, s, l];
}



function rgb2hsl(rgb)
{
    return rgb2hsl_(rgb[0], rgb[1], rgb[2]);
}



function hsl2rgb_(h, s, l)
{
    let q =
        l < 0.5
        ? l * (1 + s)
        : l + s - l * s;

    let p = 2 * l - q;

    let tr = h + 1/3;
    let tg = h;
    let tb = h - 1/3;

    if (tr < 0) tr += 1; if (tr > 1) tr -= 1;
    if (tg < 0) tg += 1; if (tg > 1) tg -= 1;
    if (tb < 0) tb += 1; if (tb > 1) tb -= 1;

    let r, g, b;

    let qp6 = (q - p) * 6; 

         if (tr <  1/6)				r = p + qp6 * tr;
    else if (tr >= 1/6 && tr < 0.5)	r = q;
    else if (tr >= 0.5 && tr < 2/3)	r = p + qp6 * (2/3 - tr);
    else							r = p;
	
         if (tg <  1/6)				g = p + qp6 * tg;
    else if (tg >= 1/6 && tg < 0.5)	g = q;
    else if (tg >= 0.5 && tg < 2/3) g = p + qp6 * (2/3 - tg);
    else							g = p;

         if (tb <  1/6)				b = p + qp6 * tb;
    else if (tb >= 1/6 && tb < 0.5) b = q;
    else if (tb >= 0.5 && tb < 2/3) b = p + qp6 * (2/3 - tb);
    else							b = p;

    return [r, g, b];
}



function hsl2rgb(hsl)
{
    return hsl2rgb_(hsl[0], hsl[1], hsl[2]);
}


function xyz2lms(xyz)
{
    return mulv3m3(xyz, CAT);//HPE);
}



function lms2xyz(lms)
{
    return mulv3m3(lms, invCAT);//invHPE);
}



function rgb2xyz(rgb, cs = sRGB)
{ 
    return rgb2xyz_(rgb[0], rgb[1], rgb[2], cs);
}    



function rgb2xyz_(r, g, b, cs = sRGB)
{ 
    let rgb = [
        cs.degamma(r),
        cs.degamma(g),
        cs.degamma(b) ];

    return lrgb2xyz(rgb, cs);
}    



function lrgb2xyz(rgb, cs = sRGB)
{
    return mulv3m3(rgb, cs.lin2xyz);
}        



function xyz2rgb(xyz, cs = sRGB)
{
    let rgb = xyz2lrgb(xyz, cs);

    return [
        cs.regamma(rgb[0]),
        cs.regamma(rgb[1]),
        cs.regamma(rgb[2]) ];
}



function xyz2lrgb(xyz, cs = sRGB)
{
    return mulv3m3(xyz, cs.xyz2lin);
}






function rgb2luv(rgb, cs = sRGB)
{
    return xyz2luv(rgb2xyz(rgb, cs), cs.W);
}



function luv2rgb(luv, cs = sRGB)
{
    return xyz2rgb(luv2xyz(luv, cs.W), cs);
}



function xyz2luv(xyz, W = sRGB.W)
{
    const x = xyz[0], 
          y = xyz[1], 
          z = xyz[2];

    const e = cube(6/29);
    const k = cube(29/3);

    const yw = y / W[1];

    let l = 
        yw > e
        ? 116 * Math.cbrt(yw) - 16
        : k * yw;

    const u_ = 4*x / (x + 15*y + 3*z);
    const v_ = 9*y / (x + 15*y + 3*z);
    
    const uw = 4*W[0] / (W[0] + 15*W[1] + 3*W[2]);
    const vw = 9*W[1] / (W[0] + 15*W[1] + 3*W[2]);
    
    const u = 13*l * (u_ - uw);
    const v = 13*l * (v_ - vw);

    return [
        l / 100, 
        u / 100, 
        v / 100];
}



function luv2xyz(luv, W = sRGB.W)
{
    let l = luv[0] * 100, 
        u = luv[1] * 100, 
        v = luv[2] * 100;

    const e = cube(6/29);    
    const k = cube(29/3);

    const uw = 4*W[0] / (W[0] + 15*W[1] + 3*W[2]);
    const vw = 9*W[1] / (W[0] + 15*W[1] + 3*W[2]);
    
    const y = 
        l > e*k
        ? cube((l + 16) / 116)
        : l / k;
    
    const a = (52*l / nozero(u + 13*l*uw) - 1) / 3;
    const b = -5 * y;
    const c = -1/3;
    const d =  y * (39*l / nozero(v + 13*l*vw) - 5);

    const x = (d - b) / nozero(a - c);

    const z = x*a + b;

    return [x, y, z];
}


function rgb2lab(rgb, cs = sRGB)
{
    return xyz2lab(rgb2xyz(rgb, cs), cs.W);
}



function lab2rgb(lab, cs = sRGB)
{
    return xyz2rgb(lab2xyz(lab, cs.W), cs);
}



function xyz2lab(xyz, W = sRGB.W)
{
    const x = xyz[0], 
          y = xyz[1], 
          z = xyz[2];

    const e = cube(6/29);
    const k = cube(29/3);

    let xw = x / W[0];
    let yw = y / W[1];
    let zw = z / W[2];

    xw = xw > e ? Math.cbrt(xw) : (k * xw + 0.16)/1.16;
    yw = yw > e ? Math.cbrt(yw) : (k * yw + 0.16)/1.16;
    zw = zw > e ? Math.cbrt(zw) : (k * zw + 0.16)/1.16;

    const l = (1.16 * yw) - 0.16;
    const a = 5 * (xw - yw);
    const b = 2 * (yw - zw);

    return [l, a, b];
}



function lab2xyz(lab, W = sRGB.W)
{
    const l = lab[0], 
          a = lab[1], 
          b = lab[2];

    const e = cube(6/29) / 100;
    const k = cube(29/3) / 100;

    const yw = (l + 0.16)/1.16;
    const xw = a/5 + yw;
    const zw = yw - b/2;

    let x = cube(xw) > e ? cube(xw) : (1.16*xw - 0.16)/k;
    let y = cube(yw) > e ? cube(yw) : (1.16*yw - 0.16)/k;
    let z = cube(zw) > e ? cube(zw) : (1.16*zw - 0.16)/k;

    x *= W[0];
    y *= W[1];
    z *= W[2];
 
    return [x, y, z];
}


const okLabScale = 5.8209716167;



function rgb2oklab(rgb, cs = sRGB)
{
    return rgb2oklab_(rgb[0], rgb[1], rgb[2], cs);
}



function rgb2oklab_(r, g, b, cs = sRGB) 
{
    return oklms2oklab(rgb2oklms_(r, g, b, cs));
}



function rgb2oklms_(r, g, b, cs = sRGB) 
{
    r = cs.degamma(r);
    g = cs.degamma(g);
    b = cs.degamma(b);

    return [
        0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b,
	    0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b,
	    0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b ];
}        



function oklms2oklab(lms) 
{
    const l = Math.cbrt(lms[0]);
    const m = Math.cbrt(lms[1]);
    const s = Math.cbrt(lms[2]);

    const l_ = 0.2104542553 * l + 0.7936177850 * m - 0.0040720468 * s;
    const a_ = 1.9779984951 * l - 2.4285922050 * m + 0.4505937099 * s;
    const b_ = 0.0259040371 * l + 0.7827717662 * m - 0.8086757660 * s;

    return [
        l_,
        a_, 
        b_ ];
}        



function oklab2rgb(lab, cs = sRGB)
{
    return oklms2rgb(oklab2oklms(lab), cs);
}



function oklab2rgb_(l, a, b, cs = sRGB) 
{
    return oklab2rgb([l, a, b], cs);
}



function oklab2oklms(lab)
{
    return oklab2oklms_(lab[0], lab[1], lab[2]);
}



function oklab2oklms_(l_, a_, b_) 
{
    return [
        l_ + 0.3963377774 * a_ + 0.2158037573 * b_,
        l_ - 0.1055613458 * a_ - 0.0638541728 * b_,
        l_ - 0.0894841775 * a_ - 1.2914855480 * b_ ];
}



function oklms2rgb(lms, cs = sRGB) 
{
    const l = cube(lms[0]);
    const m = cube(lms[1]);
    const s = cube(lms[2]);

	const r =  4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s;
	const g = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s;
	const b = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s;

    return [
        cs.regamma(r),
        cs.regamma(g),
        cs.regamma(b) ];
}


function opp2pol(opp) // opponent to polar
{
    // either lab or luv, 
    // the polar transformation is the same

    const l = opp[0], 
          a = opp[1], 
          b = opp[2];

    const h = Math.atan2(b, a);
    const c = Math.sqrt(a*a + b*b);

    return [h, c, l];
}



function pol2opp(pol) // polar to opponent
{
    // either lab or luv, 
    // the polar transformation is the same

    const h = pol[0], 
          c = pol[1], 
          l = pol[2];

    const a = c * Math.cos(h);
    const b = c * Math.sin(h);

    return [l, a, b];
}


function hclok2rgb(hcl, cs = sRGB)
{
    hcl = [...hcl];

    hcl[0] *= Tau;
    hcl[1] *= hcl[2]; 

    return oklab2rgb(pol2opp(hcl), cs);
}    



function hclok2rgb_(h, c, l, cs = sRGB)
{
    return hclok2rgb_([h, c, l], cs);
}    
    
    
    
function rgb2hclok(rgb, cs = sRGB)
{
    const hcl = opp2pol(rgb2oklab(rgb, cs));

    hcl[0] /= Tau;
    hcl[1] /= nozero(hcl[2]);
    
    return hcl;
}



function rgb2hclok_(r, g, b, cs = sRGB)
{
    return rgb2hclok([r, g, b], cs);
}



function hclab2lab(hcl)
{
    hcl = [...hcl];

    hcl[0] *= Tau;
    hcl[1] *= hcl[2];

    return pol2opp(hcl);
}



function hclab2rgb(hcl, cs = sRGB)
{
    return lab2rgb(hclab2lab(hcl), cs);
}



function lab2hclab(lab)
{
    let hcl = opp2pol(lab);

    hcl[0] /= Tau;
    hcl[1] /= hcl[2];

    return hcl;
}



function rgb2hclab(rgb, cs = sRGB)
{
    return lab2hclab(rgb2lab(rgb, cs));
}



function hcluv2luv(hcl)
{
    hcl = [...hcl];

    hcl[0] *= Tau;
    hcl[1] *= hcl[2];

    return pol2opp(hcl);
}



function hcluv2rgb(hcl, cs = sRGB)
{
    return luv2rgb(hcluv2luv(hcl), cs);
}



function luv2hcluv(luv)
{
    let hcl = opp2pol(luv);

    hcl[0] /= Tau;
    hcl[1] /= hcl[2];

    return hcl;
}



function rgb2hcluv(rgb, cs = sRGB)
{
    return luv2hcluv(rgb2luv(rgb, cs));
}


// Hunt-Pointer-Estevez
// const HPE = [[ 0.4002, 0.7076, -0.0808],
//              [-0.2263, 1.1653,  0.0457],
//              [ 0,      0,       0.9182]];

// const invHPE = inverse(HPE);


// CIECAM02
const CAT = [[ 0.7328, 0.4296, -0.1624],
             [-0.7036, 1.6975,  0.0061],
             [ 0.0030, 0.0136,  0.9834]];

const invCAT = inverse(CAT);



// function colorIsNaN(c)
// {
//     return isNaN(c[0])
//         || isNaN(c[1])
//         || isNaN(c[2]);
// }



function rgbIsNaN(rgb) 
{
    return isNaN(rgb[0])
        || isNaN(rgb[1])
        || isNaN(rgb[2]);
}



function rgbaIsNaN(rgba) 
{
    return isNaN(rgba[0])
        || isNaN(rgba[1])
        || isNaN(rgba[2])
        || isNaN(rgba[3]);
}



function rgbIsValid(rgb, lim = ColorEpsilon)
{
    return rgb[0] > -lim && rgb[0] < 1 + lim 
        && rgb[1] > -lim && rgb[1] < 1 + lim 
        && rgb[2] > -lim && rgb[2] < 1 + lim;
}



function rgbaIsValid(rgba, lim = ColorEpsilon)
{
    return rgba[0] > -lim && rgba[0] < 1 + lim 
        && rgba[1] > -lim && rgba[1] < 1 + lim 
        && rgba[2] > -lim && rgba[2] < 1 + lim
        && rgba[3] > -lim && rgba[3] < 1 + lim;
}



function rgbIsOk(rgb, lim = ColorEpsilon)
{
    return !rgbIsNaN  (rgb)
        &&  rgbIsValid(rgb, lim);
}



function invalid2validRgb(rgb)
{
    return [
        Math.min(Math.max(0, rgb[0]), 1),
        Math.min(Math.max(0, rgb[1]), 1),
        Math.min(Math.max(0, rgb[2]), 1) ];
}



function rgbLerp(rgb1, rgb2, t)
{
    return [ lerp(rgb1[0], rgb2[0], t),
             lerp(rgb1[1], rgb2[1], t),
             lerp(rgb1[2], rgb2[2], t) ];
}



function rgbaLerp(rgba1, rgba2, t)
{
    return [ lerp(rgba1[0], rgba2[0], t),
             lerp(rgba1[1], rgba2[1], t),
             lerp(rgba1[2], rgba2[2], t),
             lerp(rgba1[3], rgba2[3], t) ];
}



function rgbAdd(rgb1, rgb2)
{
    return [ rgb1[0] + rgb2[0],
             rgb1[1] + rgb2[1],
             rgb1[2] + rgb2[2] ];
}



function rgbSub(rgb1, rgb2)
{
    return [ rgb1[0] - rgb2[0],
             rgb1[1] - rgb2[1],
             rgb1[2] - rgb2[2] ];
}



function rgbMuls(rgb, s)
{
    return [ rgb[0] * s,
             rgb[1] * s,
             rgb[2] * s ];
}



function rgbAvg(rgb1, rgb2)
{
    return [ (rgb1[0] + rgb2[0]) / 2,
             (rgb1[1] + rgb2[1]) / 2,
             (rgb1[2] + rgb2[2]) / 2 ];
}



function rgbMax(rgb1, rgb2)
{
    return [ Math.max(rgb1[0], rgb2[0]),
             Math.max(rgb1[1], rgb2[1]),
             Math.max(rgb1[2], rgb2[2]) ];
}



function rgbPow(col, p)
{
    return [
        Math.pow(col[0], p), 
        Math.pow(col[1], p), 
        Math.pow(col[2], p) ]
}



const ColorEpsilon = 0.001;



function rgb2dataColor(rgb)
{
    const _space = 'rgb';

    return [
        _space, 
        getNormalColorValue(rgb[0], _space, 0), 
        getNormalColorValue(rgb[1], _space, 1), 
        getNormalColorValue(rgb[2], _space, 2) ]; 
}



function makeDataColor(space, c1, c2, c3)
{
    const _space = colorSpace(space.value);

    return [
        _space, 
        getNormalColorValue(c1.value, _space, 0), 
        getNormalColorValue(c2.value, _space, 1), 
        getNormalColorValue(c3.value, _space, 2) ]; 
}



function dataColorIsNaN(c)
{
    return isNaN(c[1])
        || isNaN(c[2])
        || isNaN(c[3]);
}



function dataColorIsValid(col, lim = ColorEpsilon)
{
    return rgbIsValid(dataColor2rgb(col), lim);
}



function dataColorIsOk(col, lim = ColorEpsilon)
{
    return rgbIsOk(dataColor2rgb(col), lim);
}


const rgb_NaN = [
    Number.NaN,
    Number.NaN,
    Number.NaN ];

const rgba_NaN = [
    Number.NaN,
    Number.NaN,
    Number.NaN,
    Number.NaN ];


const rgbInvalid  = [0xff, 0, 0xff];
const rgbaInvalid = [0xff, 0, 0xff, 0xff];


const dataColor_NaN = Object.freeze([
    'rgb',
    Number.NaN,
    Number.NaN,
    Number.NaN ]);


function allConesWork(cones)
{
    return cones.l == 1 
        && cones.m == 1 
        && cones.s == 1;
}



function rgbToString(rgb)
{
    return '{' + Math.round(rgb[0] * 255) + ', '
               + Math.round(rgb[1] * 255) + ', '
               + Math.round(rgb[2] * 255) + '}';
}



function colorStyle_(r, g, b, a)
{
    if (a != undefined)
    {
        return 'rgba('
            + Math.round(r * 0xff) + ', '
            + Math.round(g * 0xff) + ', '
            + Math.round(b * 0xff) + ', '
            + a + ')';
    }
    else
    {
        return 'rgb('
            + Math.round(r * 0xff) + ', '
            + Math.round(g * 0xff) + ', '
            + Math.round(b * 0xff) + ')';
    }
}



function colorStyleRgb_(r, g, b)
{
    return colorStyle_(r, g, b, 1);
}



function rgb2style(rgb)
{
    return colorStyle_(rgb[0], rgb[1], rgb[2], 1);
}



function colorStyleRgba_(r, g, b, a)
{
    return colorStyle_(r, g, b, a);
}



function rgba2style(rgba)
{
    return colorStyle_(rgba[0], rgba[1], rgba[2], rgba[3]);
}



function rgb2style_a(rgb, a)
{
    return colorStyle_(rgb[0], rgb[1], rgb[2], a);
}



function toRgba(rgb_)
{
    return rgb_.length == 3
         ? [...rgb_, 1]
         : rgb_;
}



function rgb_a(rgb, a)
{
    return [rgb[0], rgb[1], rgb[2], a];
}



function isDark(rgb, threshold = 0.71)
{
    return rgb2hclok(rgb)[2] < threshold;
}



function rgbDistance(col1, col2)
{
    const d0 = col2[0] - col1[0];
    const d1 = col2[1] - col1[1];
    const d2 = col2[2] - col1[2];

    return Math.sqrt(d0*d0 + d1*d1 + d2*d2);
}



function rgbaMul(rgba, v)
{
    return [
        rgba[0] * v,
        rgba[1] * v,
        rgba[2] * v,
        rgba[3] * v ];
}



function rgbaDiv(rgba, v)
{
    return [
        rgba[0] / v,
        rgba[1] / v,
        rgba[2] / v,
        rgba[3] / v ];
}



function maxRgbDistance(col1, col2)
{
    return Math.max(Math.max(Math.max(
        Math.abs(col2[0] - col1[0]),
        Math.abs(col2[1] - col1[1])),
        Math.abs(col2[2] - col1[2])));
}



function rgbEqual(rgb1, rgb2)
{
    return Math.abs(rgb1[0] - rgb2[0]) < ColorEpsilon
        && Math.abs(rgb1[1] - rgb2[1]) < ColorEpsilon
        && Math.abs(rgb1[2] - rgb2[2]) < ColorEpsilon;        
}



function style2rgba(style) // SLOW
{
    utilContext.fillStyle = style;
    utilContext.fillRect(0, 0, 1, 1);

    return rgbaDiv(utilContext.getImageData(0, 0, 1, 1).data, 0xFF);
}



function computedStyle2rgba(obj, style) // SLOW
{
    utilContext.fillStyle = getStyleValue(obj, style);
    utilContext.fillRect(0, 0, 1, 1);

    return rgbaDiv(utilContext.getImageData(0, 0, 1, 1).data, 0xFF);
}



function getTextColorFromBackColor(rgb, opacity = 1)
{
    return !rgbIsNaN(rgb)
           ? (opacity >= 0.5
               ? (isDark(rgb)  ? [1, 1, 1, 0.75] : [0, 0, 0, 0.75])
               : (darkMode ? [1, 1, 1, 0.75] : [0, 0, 0, 0.75]))
           : (darkMode ? rgbaNoColorTextDark : rgbaNoColorTextLight);
}



function getDefaultWarningRgba(rgb)
{
    return !rgbIsNaN(rgb)
         ? (isDark(rgb)  ? [1, 1, 1, 0.133] : [0, 0, 0, 0.161])  
         : (darkMode ? [1, 1, 1, 0.031] : [0, 0, 0, 0.031]);  
}



function getDefaultWarningStyle(rgb)
{
    return !rgbIsNaN(rgb)
         ? (isDark(rgb)  ? '#ffffff29' : '#00000022')
         : (darkMode ? '#ffffff08' : '#00000006'); 
}



function clipRgb(_rgb)
{
    const rgb = [..._rgb];

    rgb[0] = Math.min(Math.max(0, rgb[0]), 1);   
    rgb[1] = Math.min(Math.max(0, rgb[1]), 1);   
    rgb[2] = Math.min(Math.max(0, rgb[2]), 1); 

    return rgb;
}


const lmsW = xyz2lms(lrgb2xyz([1, 1, 1]));
const lmsB = xyz2lms(lrgb2xyz([0, 0, 1]));
const lmsR = xyz2lms(lrgb2xyz([1, 0, 0]));

const lq1 = (lmsW[2]*lmsB[0] - lmsB[2]*lmsW[0]) / (lmsW[2]*lmsB[1] - lmsB[2]*lmsW[1]);
const lq2 = (lmsW[1]*lmsB[0] - lmsB[1]*lmsW[0]) / (lmsW[1]*lmsB[2] - lmsB[1]*lmsW[2]);

const mq1 = (lmsW[2]*lmsB[1] - lmsB[2]*lmsW[1]) / (lmsW[2]*lmsB[0] - lmsB[2]*lmsW[0]);
const mq2 = (lmsW[0]*lmsB[1] - lmsB[0]*lmsW[1]) / (lmsW[0]*lmsB[2] - lmsB[0]*lmsW[2]);

const sq1 = (lmsW[1]*lmsR[2] - lmsR[1]*lmsW[2]) / (lmsW[1]*lmsR[0] - lmsR[1]*lmsW[0]);
const sq2 = (lmsW[0]*lmsR[2] - lmsR[0]*lmsW[2]) / (lmsW[0]*lmsR[1] - lmsR[0]*lmsW[1]);

const bq1 = lmsW[0] / lmsW[2];
const bq2 = lmsW[1] / lmsW[2];


// this is a number I made up following the information here: https://www.color-blindness.com/2007/07/20/monochromacy-complete-color-blindness/
// the simulation itself gives grayscale
// on the site the simulation has color in it, so I decided to leave some color in as well,
// but the amount is completely arbitrary, I just felt that this particular value matches
// the description on that site without being unrealistically exaggerated
const blueMono = 0.88;


function rgb2colorblind(rgb, l, m, s, cs = sRGB)
{
    if (   l == 0
        && m == 0
        && s == 0)
    {
        // achromatopsia is simulated by taking only the luminance

        const a = 
              cs.Y[0] * rgb[0]
            + cs.Y[1] * rgb[1]
            + cs.Y[2] * rgb[2];

        rgb = [a, a, a];
    }
    else
    {
        const xyz = rgb2xyz(rgb, cs);
        const lms = xyz2lms(xyz);

        const a = 
              cs.Y[0] * rgb[0]
            + cs.Y[1] * rgb[1]
            + cs.Y[2] * rgb[2];

        const lm = Math.min(l + m, 1);


        const lms_ = [
            lms[0] + lerp(blueMono * (bq1*lms[2] - lms[0]), (1 - l) * ((lq1*lms[1] + lq2*lms[2]) - lms[0]), lm),
            lms[1] + lerp(blueMono * (bq2*lms[2] - lms[1]), (1 - m) * ((mq1*lms[0] + mq2*lms[2]) - lms[1]), lm),
            lms[2] + lerp(0,                     lerp(s, 1 - s, lm) * ((sq1*lms[0] + sq2*lms[1]) - lms[2]), lm) ];

        const xyz_ = lms2xyz(lms_);
              rgb  = xyz2rgb(xyz_, cs);


        let bm_ = rgb2lab(rgb, cs);
        bm_[0] = lerp(a, bm_[0], lm);
        rgb = lab2rgb(bm_, cs);

        
        rgb = rgbLerp(
            [a, a, a], 
            rgb, 
            Math.min(s + lm, 1));
    }
    

    return rgb;
}


function rgb2hex(rgb)
{
    let hex =
          Math.round(rgb[0] * 0xff).toString(16).padStart(2, '0').toUpperCase()
        + Math.round(rgb[1] * 0xff).toString(16).padStart(2, '0').toUpperCase()
        + Math.round(rgb[2] * 0xff).toString(16).padStart(2, '0').toUpperCase();

    return hex;
}



function rgba2hex(rgba)
{
    let hex =
          Math.round(rgb[0] * 0xff).toString(16).padStart(2, '0').toUpperCase()
        + Math.round(rgb[1] * 0xff).toString(16).padStart(2, '0').toUpperCase()
        + Math.round(rgb[2] * 0xff).toString(16).padStart(2, '0').toUpperCase()
        + Math.round(rgb[3] * 0xff).toString(16).padStart(2, '0').toUpperCase();

    return hex;
}



function validHex2rgb(hex) // can process invalid '-'
{
    return hex.indexOf(NAN_CHAR) > -1 
           ? rgb_NaN 
           : hex2rgb(hex);
}



function validHex2rgba(hex) // can process invalid '-'
{
    return hex.indexOf(NAN_CHAR) > -1 
           ? rgba_NaN 
           : hex2rgba(hex);
}



function hex2rgb(hex)
{
    if (hex[0] == '#')
        hex = hex.substring(1);

        
    let rgb = [];

    if (hex.length >= 6)
    {
        rgb[0] = parseInt(hex.slice(0, 2), 16); 
        rgb[1] = parseInt(hex.slice(2, 4), 16); 
        rgb[2] = parseInt(hex.slice(4, 6), 16); 
    }
    else if (hex.length >= 3)
    {
        rgb[0] = parseInt(hex[0], 16) * 0x11; 
        rgb[1] = parseInt(hex[1], 16) * 0x11; 
        rgb[2] = parseInt(hex[2], 16) * 0x11; 
    }
    else if (hex.length == 2)
    {
        let v = parseInt(hex, 16);
        
        rgb[0] = v; 
        rgb[1] = v; 
        rgb[2] = v; 
    }
    else if (hex.length == 1)
    {
        let v = parseInt(hex, 16);
        
        rgb[0] = v * 0x11; 
        rgb[1] = v * 0x11; 
        rgb[2] = v * 0x11; 
    }
    else if (hex.length == 0)
    {
        rgb[0] = 0; 
        rgb[1] = 0; 
        rgb[2] = 0;         
    }


    rgb[0] /= 0xff;
    rgb[1] /= 0xff;
    rgb[2] /= 0xff;

    
    return rgb;
}



function hex2rgba(hex)
{
    if (hex[0] == '#')
        hex = hex.substring(1);

        
    let rgba = [];

    if (hex.length >= 8)
    {
        rgba[0] = parseInt(hex.slice(0, 2), 16); 
        rgba[1] = parseInt(hex.slice(2, 4), 16); 
        rgba[2] = parseInt(hex.slice(4, 6), 16); 
        rgba[3] = parseInt(hex.slice(6, 8), 16); 
    }
    else if (hex.length >= 6)
    {
        rgba[0] = parseInt(hex.slice(0, 2), 16); 
        rgba[1] = parseInt(hex.slice(2, 4), 16); 
        rgba[2] = parseInt(hex.slice(4, 6), 16); 
        rgba[3] = 0xff; 
    }
    else if (hex.length >= 4)
    {
        rgba[0] = parseInt(hex[0], 16) * 0x11; 
        rgba[1] = parseInt(hex[1], 16) * 0x11; 
        rgba[2] = parseInt(hex[2], 16) * 0x11; 
        rgba[3] = parseInt(hex[3], 16) * 0x11; 
    }
    else if (hex.length == 3)
    {
        rgba[0] = parseInt(hex[0], 16) * 0x11; 
        rgba[1] = parseInt(hex[1], 16) * 0x11; 
        rgba[2] = parseInt(hex[2], 16) * 0x11; 
        rgba[3] = 0xff; 
    }
    else if (hex.length == 2)
    {
        let v = parseInt(hex, 16);
        
        rgba[0] = v; 
        rgba[1] = v; 
        rgba[2] = v; 
        rgba[3] = 0xff; 
    }
    else if (hex.length == 1)
    {
        let v = parseInt(hex, 16);
        
        rgba[0] = v * 0x11; 
        rgba[1] = v * 0x11; 
        rgba[2] = v * 0x11; 
        rgba[3] = 0xff; 
    }
    else if (hex.length == 0)
    {
        rgba[0] = 0; 
        rgba[1] = 0; 
        rgba[2] = 0;         
        rgba[3] = 0; 
    }


    rgba[0] /= 0xff;
    rgba[1] /= 0xff;
    rgba[2] /= 0xff;
    rgba[3] /= 0xff;


    return rgba;
}


function getContrastRatio2(textColor, backColor)
{
    if (    rgbIsNaN  (textColor)
        || !rgbIsValid(textColor))
        return Number.NaN;

    const txtY = sRGB.luminance(textColor);
    const  bgY = sRGB.luminance(backColor);

    return (
        bgY > txtY
        ? ( bgY + 0.05) / (txtY + 0.05)
        : (txtY + 0.05) / ( bgY + 0.05));
}



function getContrastRating2(ratio)
{
         if (ratio >= 7  ) return 'AAA';
    else if (ratio >= 4.5) return 'AA';
    else if (ratio >= 3  ) return 'AA<sub>L</sub>'
    else                   return '';
}



function getContrastRatio3(textColor, backColor)
{
    if (!rgbIsOk(textColor))
        return Number.NaN;

    return APCAcontrast(
        sRGBtoY(textColor),
        sRGBtoY(backColor));
}



// I copied the code below from https://github.com/Myndex/SAPC-APCA/blob/master/WEBTOOLS/APCA/JS/DEV.0.1.2.G_SAPCsRGB.js
// and refactored it to fit my code style.

const mainTRC     = 2.4; // 2.4 exponent emulates actual monitor perception
       
const sRco        = 0.2126729, 
      sGco        = 0.7151522, 
      sBco        = 0.0721750; // sRGB coefficients
   
const normBG      = 0.56, 
      normTXT     = 0.57,
      revTXT      = 0.62,
      revBG       = 0.65; // G-4g constants for use with 2.4 exponent
   
const blkThrs     = 0.022,
      blkClmp     = 1.414, 
      scaleBoW    = 1.14,
      scaleWoB    = 1.14,
      loBoWthresh = 0.035991,
      loWoBthresh = 0.035991,
      loBoWfactor = 27.7847239587675,
      loWoBfactor = 27.7847239587675,
      loBoWoffset = 0.027,
      loWoBoffset = 0.027,
      loClip      = 0.001,
      deltaYmin   = 0.0005;



function sRGBtoY(rgb) 
{
    // NOTE this is not the actual sRGB luminance as it
    // ignores the straight section. Using actual sRGB
    // luminance gives a slightly different contrast score.

    return sRco * Math.pow(rgb[0], mainTRC) 
         + sGco * Math.pow(rgb[1], mainTRC)
         + sBco * Math.pow(rgb[2], mainTRC);
}



function APCAcontrast(txtY, bgY)
{
    let SAPC           = 0; // For raw SAPC values
    let outputContrast = 0; // For weighted final values

    txtY = 
        txtY > blkThrs 
        ? txtY 
        : txtY + Math.pow(blkThrs - txtY, blkClmp);
        
    bgY = 
        bgY > blkThrs 
        ? bgY 
        : bgY + Math.pow(blkThrs - bgY, blkClmp);

    if (Math.abs(bgY - txtY) < deltaYmin)  
        return 0; 


    if (bgY > txtY) 
    {  
        SAPC = (Math.pow(bgY, normBG) - Math.pow(txtY, normTXT)) * scaleBoW;

        outputContrast = 
            SAPC < loClip 
            ? 0 
            : SAPC < loBoWthresh
              ? SAPC - SAPC * loBoWfactor * loBoWoffset 
              : SAPC - loBoWoffset;
    } 
    else 
    {  
        SAPC = (Math.pow(bgY, revBG) - Math.pow(txtY, revTXT)) * scaleWoB;

        outputContrast = 
            SAPC > -loClip 
            ? 0 
            : SAPC > -loWoBthresh 
              ? SAPC - SAPC * loWoBfactor * loWoBoffset 
              : SAPC + loWoBoffset;
    }


    return outputContrast * 100;
}


const OpColorSpaces = 
[
    ['hex',   'Hex'   ],
    ['rgb',   'RGB'   ], 
    ['hsv',   'HSV'   ], 
    ['hsl',   'HSL'   ], 
    ['hclok', 'HCL/ok'],
    ['hclab', 'HCL/ab'],
    ['hcluv', 'HCL/uv'],
    ['oklab', 'okLab' ],
    ['lab',   'Lab'   ],
    ['luv',   'Luv'   ]
];



function colorSpace     (index) { return OpColorSpaces[index][0]; }
function colorSpaceIndex(space) { return OpColorSpaces.findIndex(s => s[0] == space); }

function colorSpaceCount(parse = null)
{ 
    const set = parse ? parse.settings : settings;

    return set.showAllColorSpaces 
           ? OpColorSpaces.length
        : OpColorSpaces.length - 5; 
}



const rgbFactor  = [255, 255, 255];
const hs_Factor  = [360, 100, 100];
const hclFactor  = [360, 100, 100];
const oppFactor  = [100, 100, 100];
  
 
const rgbScale   = [255, 255, 255];
  
const hs_Scale   = [360, 100, 100];
 
const hclokScale = [360, 51,  100];
const hclabScale = [360, 400, 100];
const hcluvScale = [360, 330, 100];
 
 
const oklabScale = [100,  30,  30];
const labScale   = [100, 100, 100];
const luvScale   = [100, 150, 150];
 


function colorFactor(space)
{
    switch (space)
    {
        case 'hex':
        case 'rgb':   return rgbFactor;

        case 'hsv':
        case 'hsl':   return hs_Factor;

        case 'hclok':
        case 'hclab':
        case 'hcluv': return hclFactor;

        case 'oklab':  
        case 'lab':      
        case 'luv':   return oppFactor;   
        
        default:      console.assert(false, 'invalid color factor from space \''+space+'\''); break;
    }
}



function scaleColor(col, space)
{
    let scale;

    switch (space)
    {
        case 'hex':    
        case 'rgb':   scale = rgbScale;   break;

        case 'hsv':    
        case 'hsl':   scale = hs_Scale;   break;

        case 'hclok': scale = hclokScale; break;
        case 'hclab': scale = hclabScale; break;
        case 'hcluv': scale = hcluvScale; break;

        case 'oklab': scale = oklabScale; break;
        case 'lab':   scale = labScale;   break;
        case 'luv':   scale = luvScale;   break;
    }

    return [
        col[0] * scale[0],
        col[1] * scale[1],
        col[2] * scale[2] ];
}



function scaleRgb(rgb)
{
    return scaleColor(rgb, 'rgb');
}



function switchToSpace(node, space)
{
    switch (space)
    {
        case 'hex':   switchToHex   (node); break;
        case 'rgb':   switchToRgb   (node); break;

        case 'hsv':   switchToHsv   (node); break;
        case 'hsl':   switchToHsl   (node); break;

        case 'hclok': switchToHclok (node); break;
        case 'hclab': switchToHclab (node); break;
        case 'hcluv': switchToHcluv (node); break;

        case 'oklab': switchToOklab (node); break;
        case 'lab':   switchToLab   (node); break;
        case 'luv':   switchToLuv   (node); break;
    }

    node.resetAllControlRanges();
}



function switchToHex  (node) { switchToRgbControls   (node); switchToTextbox(node); }
function switchToRgb  (node) { switchToRgbControls   (node);                        }

function switchToHsv  (node) { switchToHs_Controls   (node, 'V');                   }
function switchToHsl  (node) { switchToHs_Controls   (node, 'L');                   }
             
function switchToHclok(node) { switchToHclOklControls(node);                        }
function switchToHclab(node) { switchToHclLabControls(node);                        }
function switchToHcluv(node) { switchToHclLuvControls(node);                        }
             
function switchToOklab(node) { switchToOklabControls (node, 'a', 'b');              }
function switchToLab  (node) { switchToLabControls   (node, 'a', 'b');              }
function switchToLuv  (node) { switchToLuvControls   (node, 'u', 'v');              }
   


function switchToRgbControls(node)
{
    switchToControls(node, 
        'R', 0, rgbScale[0], '', false, 
        'G', 0, rgbScale[1], 
        'B', 0, rgbScale[2]);  

    node.param1.control.min = 
    node.param2.control.min = 
    node.param3.control.min = Number.MIN_SAFE_INTEGER; // allow extrapolation

    node.param1.control.max = 
    node.param2.control.max = 
    node.param3.control.max = Number.MAX_SAFE_INTEGER; // allow extrapolation

    showRgbControlHex(node, false);    
}



function switchToHs_Controls(node, v_or_l) 
{ 
    switchToControls(node, 
        'H',    0, hs_Scale[0], '°', true,  
        'S',    0, hs_Scale[1], 
        v_or_l, 0, hs_Scale[2]);  

    node.param2.control.min = 
    node.param3.control.min = Number.MIN_SAFE_INTEGER; // allow extrapolation

    node.param2.control.max = 
    node.param3.control.max = Number.MAX_SAFE_INTEGER; // allow extrapolation

    showRgbControlHex(node, false); 
}



function switchToHclControls(node, scale) 
{ 
    switchToControls(node, 
        'H', 0, scale[0], '°', true,  
        'C', 0, scale[1], 
        'L', 0, scale[2]);  

    showRgbControlHex(node, false); 
}



function switchToHclOklControls(node) { switchToHclControls(node, hclokScale); }
function switchToHclLabControls(node) { switchToHclControls(node, hclabScale); }
function switchToHclLuvControls(node) { switchToHclControls(node, hcluvScale); }



function switchToOppControls(node, c2, c3, scale)
{ 
    switchToControls(node, 
        'L', 0,        scale[0], '', false,  
        c2, -scale[1], scale[1], 
        c3, -scale[2], scale[2]);  

    showRgbControlHex(node, false); 
}



function switchToOklabControls(node) { switchToOppControls(node, 'a', 'b', oklabScale); }
function switchToLabControls  (node) { switchToOppControls(node, 'a', 'b', labScale  ); }
function switchToLuvControls  (node) { switchToOppControls(node, 'u', 'v', luvScale  ); }



function showRgbControlHex(node, show)
{
    node.param1.control.showHex = show;
    node.param2.control.showHex = show;
    node.param3.control.showHex = show;
}



function switchToControls(node, c1, c1min, c1max, c1suffix, c1wrap, c2, c2min, c2max, c3, c3min, c3max)
{
    switchToSliders(node);

    node.param1.setName(c1, false); 
    node.param2.setName(c2, false); 
    node.param3.setName(c3, false);

    node.param1.control.wrapValue = c1wrap;
    node.param1.control.setSuffix(c1suffix, c1suffix != '');

    node.param1.control.setMin(c1min); 
    node.param2.control.setMin(c2min);
    node.param3.control.setMin(c3min);
    
    node.param1.control.setMax(c1max); 
    node.param2.control.setMax(c2max); 
    node.param3.control.setMax(c3max); 
    
    node.param1.updateControls();
    node.param2.updateControls();
    node.param3.updateControls();
}



function switchToTextbox(node)
{
    removeOpColorParamWires(node);

    removeDivFrom(node.param1.div, node.inner);
    removeDivFrom(node.param2.div, node.inner);
    removeDivFrom(node.param3.div, node.inner);
        
    appendDivTo(node.paramColor.div, node.inner);
}



function removeParamDivs(node)
{
    removeOpColorParamWires(node);

    removeDivFrom(node.param1.div,     node.inner);
    removeDivFrom(node.param2.div,     node.inner);
    removeDivFrom(node.param3.div,     node.inner);
    
    removeDivFrom(node.paramColor.div, node.inner);
}



function removeOpColorParamWires(node)
{
    for (let i = node.inputs.length-1; i >= 2; i--)
        if (node.inputs[i].connected)
            uiDisconnect(node.inputs[i]);

    for (let i = node.outputs.length-1; i >= 2; i--)
        for (const input of node.outputs[i].connectedInputs)
            uiDisconnect(input);
}



function switchToSliders(node)
{
    removeDivFrom(node.paramColor.div, node.inner);

    appendDivTo(node.param1.div, node.inner);
    appendDivTo(node.param2.div, node.inner);
    appendDivTo(node.param3.div, node.inner);
}



function rgb2dataColor(rgb)
{
    return [
       'rgb',
        rgb[0],
        rgb[1],
        rgb[2] ];
}



function getNormalColorValue(value, space, chan)
{
    switch (space)
    {
        case 'hex':
        case 'rgb':    return getNormalValueRgb_(value, chan);

        case 'hsv':   
        case 'hsl':    return getNormalValueHs_ (value, chan);

        case 'hclok': 
        case 'hclab': 
        case 'hcluv': return getNormalValueHcl (value, chan);

        case 'oklab':  
        case 'lab':    
        case 'luv':    return getNormalValueOpp (value, chan);
    }
}



function getNormalValueRgb_(value, chan)
{
    switch (chan)
    {
        case 0: return value / rgbFactor[0];
        case 1: return value / rgbFactor[1]; 
        case 2: return value / rgbFactor[2];
    }
}



function getNormalValueHs_(value, chan)
{
    switch (chan)
    {
        case 0: return value / hs_Factor[0];
        case 1: return value / hs_Factor[1]; 
        case 2: return value / hs_Factor[2];
    }
}



function getNormalValueOpp(value, chan)
{
    switch (chan)
    {
        case 0: return value / oppFactor[0];
        case 1: return value / oppFactor[1]; 
        case 2: return value / oppFactor[2];
    }
}



function getNormalValueHcl(value, chan)
{
    switch (chan)
    {
        case 0: return value / hclFactor[0];
        case 1: return value / hclFactor[1]; 
        case 2: return value / hclFactor[2];
    }
}



function getNormalColor(color)
{
    return getNormalColor_(
        color[0], 
        color[1], 
        color[2], 
        color[3])
}



function getNormalColor_(space, c1, c2, c3)
{
    switch (space)
    {
        case 'hex':
        case 'rgb':    return getNormalColorRgb_(c1, c2, c3);

        case 'hsv':   
        case 'hsl':    return getNormalColorHs_(c1, c2, c3);

        case 'hclok': 
        case 'hclab': 
        case 'hcluv': return getNormalColorHcl(c1, c2, c3);

        case 'oklab': 
        case 'lab': 
        case 'luv':    return getNormalColorOpp(c1, c2, c3);
    }
}



function getNormalColorRgb_(c1, c2, c3)
{
    return [
        c1 / rgbFactor[0], 
        c2 / rgbFactor[1], 
        c3 / rgbFactor[2]];
}



function getNormalColorHs_(c1, c2, c3)
{
    return [
        c1 / hs_Factor[0], 
        c2 / hs_Factor[1], 
        c3 / hs_Factor[2]];
}



function getNormalColorHcl(c1, c2, c3)
{
    return [
        c1 / hclFactor[0], 
        c2 / hclFactor[1], 
        c3 / hclFactor[2]];
}



function getNormalColorOpp(c1, c2, c3)
{
    return [
        c1 / oppFactor[0], 
        c2 / oppFactor[1], 
        c3 / oppFactor[2]];
}



function getScaledDataColor(color)
{
    switch (color[0])
    {
        case 'hex':
        case 'rgb':    return getScaledDataColorRgb(          color[1], color[2], color[3]);

        case 'hsv':    return getScaledDataColorHs_('hsv',    color[1], color[2], color[3]);
        case 'hsl':    return getScaledDataColorHs_('hsl',    color[1], color[2], color[3]);

        case 'hclok': return getScaledDataColorHcl('hclok', color[1], color[2], color[3]);
        case 'hclab': return getScaledDataColorHcl('hclab', color[1], color[2], color[3]);
        case 'hcluv': return getScaledDataColorHcl('hcluv', color[1], color[2], color[3]);

        case 'oklab':  return getScaledDataColorOpp('oklab',  color[1], color[2], color[3]);
        case 'lab':    return getScaledDataColorOpp('lab',    color[1], color[2], color[3]);
        case 'luv':    return getScaledDataColorOpp('luv',    color[1], color[2], color[3]);
    }
}



function getScaledDataColorRgb(c1, c2, c3)
{
    return [
       'rgb',
        c1 * rgbFactor[0], 
        c2 * rgbFactor[1], 
        c3 * rgbFactor[2] ];
}



function getScaledDataColorHs_(space, c1, c2, c3)
{
    return [
        space,
        c1 * hs_Factor[0], 
        c2 * hs_Factor[1], 
        c3 * hs_Factor[2] ];
}



function getScaledDataColorHcl(space, c1, c2, c3)
{
    return [
        space,
        c1 * hclFactor[0], 
        c2 * hclFactor[1], 
        c3 * hclFactor[2] ];
}



function getScaledDataColorOpp(space, c1, c2, c3)
{
    return [
        space,
        c1 * oppFactor[0], 
        c2 * oppFactor[1], 
        c3 * oppFactor[2] ];
}



function setDataColorToCurrentSpace(node, color)
{
    const toSpace = colorSpace(node.paramSpace.value);
    node._color   = convertDataColorToSpace(color, toSpace);

    node.setColorParams(node._color);
}



function colorSpaceFactor(space)
{
    switch (space)
    {
        case 'hex':
        case 'rgb':    return rgbFactor;

        case 'hsv':   
        case 'hsl':    return hs_Factor;

        case 'hclok': 
        case 'hclab': 
        case 'hcluv': return hclFactor;

        case 'oklab': 
        case 'lab': 
        case 'luv':    return oppFactor;
    }    
}



function getColorSpaceScale(space)
{
    switch (space)
    {
        case 'hex':
        case 'rgb':    return rgbScale;

        case 'hsv':   
        case 'hsl':    return hs_Scale;

        case 'hclok': return hclokScale;
        case 'hclab': return hclabScale;
        case 'hcluv': return hcluvScale;

        case 'oklab':  return oklabScale;
        case 'lab':    return labScale;
        case 'luv':    return luvScale;
    }    
}


function dataColor2array(color)
{
    return [
        color[1], 
        color[2], 
        color[3]];
}



function dataColor2rgb(color)
{
    const col = dataColor2array(color);

    switch (color[0])
    {
        case 'hex':
        case 'rgb':   return           col;

        case 'hsv':   return hsv2rgb  (col);
        case 'hsl':   return hsl2rgb  (col);

        case 'hclok': return hclok2rgb(col);
        case 'hclab': return hclab2rgb(col);
        case 'hcluv': return hcluv2rgb(col);

        case 'oklab': return oklab2rgb(col);
        case 'lab':   return lab2rgb  (col);
        case 'luv':   return luv2rgb  (col);
    }
}



function convertDataColorToSpace(color, toSpace)
{
    switch (toSpace)
    {
        case 'hex':    
        case 'rgb':   return convert2rgb    (color);

        case 'hsv':   return convert2hsv    (color);
        case 'hsl':   return convert2hsl    (color);

        case 'hclok': return convert2hclok  (color);
        case 'hclab': return convert2hclab  (color);
        case 'hcluv': return convert2hcluv  (color);

        case 'oklab': return dataColor2oklab(color);
        case 'lab':   return convert2lab    (color);
        case 'luv':   return convert2luv    (color);
    }
}



function convert2rgb(fromColor)
{
    const col = dataColor2array(fromColor);

    let rgb;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   rgb =           col;  break;

        case 'hsv':   rgb = hsv2rgb  (col); break;
        case 'hsl':   rgb = hsl2rgb  (col); break;

        case 'hclok': rgb = hclok2rgb(col); break;
        case 'hclab': rgb = hclab2rgb(col); break;
        case 'hcluv': rgb = hcluv2rgb(col); break;

        case 'oklab': rgb = oklab2rgb(col); break;
        case 'lab':   rgb = lab2rgb  (col); break;
        case 'luv':   rgb = luv2rgb  (col); break;
    }

    return rgb2dataColor(rgb);
}



function convert2hsv(fromColor)
{
    const col = dataColor2array(fromColor);
    
    let hsv;
    
    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   hsv = rgb2hsv(          col ); break;

        case 'hsv':   hsv =                   col;   break;
        case 'hsl':   hsv = rgb2hsv(hsl2rgb  (col)); break;

        case 'hclok': hsv = rgb2hsv(hclok2rgb(col)); break;
        case 'hclab': hsv = rgb2hsv(hclab2rgb(col)); break;
        case 'hcluv': hsv = rgb2hsv(hcluv2rgb(col)); break;

        case 'oklab': hsv = rgb2hsv(oklab2rgb(col)); break;
        case 'lab':   hsv = rgb2hsv(lab2rgb  (col)); break;
        case 'luv':   hsv = rgb2hsv(luv2rgb  (col)); break;
    }
    
    if (isNaN(hsv[0]))
        hsv[0] = 5/6;
    
    return [
       'hsv',
        hsv[0],
        hsv[1],
        hsv[2] ];
}



function convert2hsl(fromColor)
{
    const col = dataColor2array(fromColor);

    let hsl;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   hsl = rgb2hsl(          col ); break;

        case 'hsv':   hsl = rgb2hsl(hsv2rgb  (col)); break;
        case 'hsl':   hsl =                   col;   break;

        case 'hclok': hsl = rgb2hsl(hclok2rgb(col)); break;
        case 'hclab': hsl = rgb2hsl(hclab2rgb(col)); break;
        case 'hcluv': hsl = rgb2hsl(hcluv2rgb(col)); break;

        case 'oklab': hsl = rgb2hsl(oklab2rgb(col)); break;
        case 'lab':   hsl = rgb2hsl(lab2rgb  (col)); break;
        case 'luv':   hsl = rgb2hsl(luv2rgb  (col)); break;
    }

    return [
       'hsl',
        hsl[0],
        hsl[1],
        hsl[2] ];
}



function dataColor2oklab(fromColor)
{
    const col = dataColor2array(fromColor);

    let lab;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   lab = rgb2oklab(          col ); break;

        case 'hsv':   lab = rgb2oklab(hsv2rgb  (col)); break;
        case 'hsl':   lab = rgb2oklab(hsl2rgb  (col)); break;

        case 'hclok': lab = rgb2oklab(hclok2rgb(col)); break;
        case 'hclab': lab = rgb2oklab(hclab2rgb(col)); break;
        case 'hcluv': lab = rgb2oklab(hcluv2rgb(col)); break;

        case 'oklab': lab =                     col;   break;
        case 'lab':   lab = rgb2oklab(lab2rgb  (col)); break;
        case 'luv':   lab = rgb2oklab(luv2rgb  (col)); break;
    }

    return [
       'oklab',
        lab[0],
        lab[1],
        lab[2] ];
}



function convert2lab(fromColor)
{
    const col = dataColor2array(fromColor);

    let lab;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   lab = rgb2lab(          col ); break;

        case 'hsv':   lab = rgb2lab(hsv2rgb  (col)); break;
        case 'hsl':   lab = rgb2lab(hsl2rgb  (col)); break;

        case 'hclok': lab = rgb2lab(hclok2rgb(col)); break;
        case 'hclab': lab =         hclab2lab(col);  break;
        case 'hcluv': lab = rgb2lab(hcluv2rgb(col)); break;

        case 'oklab': lab = rgb2lab(oklab2rgb(col)); break;
        case 'lab':   lab =                   col;   break;
        case 'luv':   lab = rgb2lab(luv2rgb  (col)); break;
    }

    return [
       'lab',
        lab[0],
        lab[1],
        lab[2] ];
}



function convert2luv(fromColor)
{
    const col = dataColor2array(fromColor);

    let luv;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   luv = rgb2luv(          col ); break;

        case 'hsv':   luv = rgb2luv(hsv2rgb  (col)); break;
        case 'hsl':   luv = rgb2luv(hsl2rgb  (col)); break;

        case 'hclok': luv = rgb2luv(hclok2rgb(col)); break;
        case 'hclab': luv = rgb2luv(hclab2rgb(col)); break;
        case 'hcluv': luv =         hcluv2luv(col);  break;

        case 'oklab': luv = rgb2luv(oklab2rgb(col)); break;
        case 'lab':   luv = rgb2luv(lab2rgb  (col)); break;
        case 'luv':   luv =                   col;   break;
    }

    return [
       'luv',
        luv[0],
        luv[1],
        luv[2] ];
}



function convert2hclok(fromColor)
{
    const col = dataColor2array(fromColor);

    let hcl;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   hcl = rgb2hclok(          col);  break;

        case 'hsv':   hcl = rgb2hclok(hsv2rgb  (col)); break;
        case 'hsl':   hcl = rgb2hclok(hsl2rgb  (col)); break;

        case 'hclok': hcl =                     col;   break;
        case 'hclab': hcl = rgb2hclok(hclab2rgb(col)); break;
        case 'hcluv': hcl = rgb2hclok(hcluv2rgb(col)); break;

        case 'oklab': hcl = rgb2hclok(oklab2rgb(col)); break;
        case 'lab':   hcl = rgb2hclok(lab2rgb  (col)); break;
        case 'luv':   hcl = rgb2hclok(luv2rgb  (col)); break;
    }

    return [
       'hclok',
        hcl[0],
        hcl[1],
        hcl[2] ];
}



function convert2hclab(fromColor)
{
    const col = dataColor2array(fromColor);

    let hcl;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   hcl = rgb2hclab(          col) ; break;
        
        case 'hsv':   hcl = rgb2hclab(hsv2rgb  (col)); break;
        case 'hsl':   hcl = rgb2hclab(hsl2rgb  (col)); break;
        
        case 'hclok': hcl = rgb2hclab(hclok2rgb(col)); break;
        case 'hclab': hcl =                     col;   break;
        case 'hcluv': hcl = rgb2hclab(hcluv2rgb(col)); break;
        
        case 'oklab': hcl = rgb2hclab(oklab2rgb(col)); break;
        case 'lab':   hcl = lab2hclab(          col ); break;
        case 'luv':   hcl = rgb2hclab(luv2rgb  (col)); break;
    }

    return [
       'hclab',
        hcl[0],
        hcl[1],
        hcl[2] ];
}



function convert2hcluv(fromColor)
{
    const col = dataColor2array(fromColor);

    let hcl;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   hcl = rgb2hcluv(          col ); break;

        case 'hsv':   hcl = rgb2hcluv(hsv2rgb  (col)); break;
        case 'hsl':   hcl = rgb2hcluv(hsl2rgb  (col)); break;

        case 'hclab': hcl = rgb2hcluv(hclab2rgb(col)); break;
        case 'hcluv': hcl =                     col;   break;
        case 'hclok': hcl = rgb2hcluv(hclok2rgb(col)); break;

        case 'oklab': hcl = rgb2hcluv(oklab2rgb(col)); break;
        case 'lab':   hcl = rgb2hcluv(lab2rgb  (col)); break;
        case 'luv':   hcl = luv2hcluv(          col ); break;
    }

    return [
       'hcluv',
        hcl[0],
        hcl[1],
        hcl[2] ];
}


</script>