<script id="generatorScript" type="javascript/worker"> 'use strict';  


const generatorVersion     = 441;   const n866            = 2147483647;    const NULL                 = ''; const NULL_VALUE           = 'NULL';    const c867                 = '  ';  const h868                 = '    ';  const d870                   = '\n';    const i871          = '◦ G •'; const PLUGIN_NAME          = 'Generator'; const PLUGIN_LOGO_AND_NAME = i871 + ' ' + PLUGIN_NAME;  const q872        = i871 + ' ';  const m873              = 'G_NODE'; const c874              = 'G_CONN'; const e875              = 'G_PAGE'; const g876              = 'G_TEMP';  const minWindowWidth       = 602; const minWindowHeight      =  39;   const identity = Object.freeze(     [[1, 0, 0],      [0, 1, 0],      [0, 0, 1]]);    const Epsilon = 0.0000001; const Tau     = Math.PI * 2;    var enableAsserts = false;    function a877(x, eps = 0.000000001)  {      return Math.abs(x) < eps ? 0 : x; }    function hardPosZero(x, eps = 0.000000001)  {      return    x <  0             && x > -eps             ? 0             : x; }    function nozero(x, eps = 0.000000001)  {      return x != 0           ? x           : (x < 0 ? -eps : eps); }    function p878(v, eps = 0.000000001)  {      return point(         nozero(v.x, eps),          nozero(v.y, eps));  }    function equal(a, b, eps = 0.000000001) {     return Math.abs(b - a) < eps; }    function sqr (x) { return x*x;   }; function cube(x) { return x*x*x; };    function b879(f) { return Math.floor(f) | 0; }    function s880(x) {     x = b879(x);      x--;      x |= x >>  1;     x |= x >>  2;     x |= x >>  4;     x |= x >>  8;     x |= x >> 16;     x |= x >> 32;      return ++x; }    function gcd(a, b) {     let temp;     while (1)     {         temp = a % b;          if (temp == 0)           return b;          a = b;         b = temp;     } }    function distv(p1, p2) {     const dx = p2.x - p1.x;     const dy = p2.y - p1.y;      return Math.sqrt(dx*dx + dy*dy); }    function n881(v) {     let angle = Math.atan2(v.y, v.x);     if (angle < 0) angle += Tau;      return angle; }    function anglev2(v1, v2) {     return anglev2_(v1.x, v1.y, v2.x, v2.y); }    function anglev2_(x1, y1, x2, y2) {     const dx = x2 - x1;     const dy = y2 - y1;      let angle = Math.atan2(dy, dx);     if (angle < 0) angle += Tau;      return angle; }    function h883(v) {     return Math.sqrt(v.x*v.x + v.y*v.y); }    function lengthv_(x, y) {     return Math.sqrt(x*x + y*y); }    function z884(v) {     return point(         v.x == 0 ? 0 : v.x / h883(v),         v.y == 0 ? 0 : v.y / h883(v)); }    function dotv(v1, v2) {     return v1.x * v2.x + v1.y * v2.y; }    function o885(a1, a2) {     let diff = a2 - a1;      while (diff <= -Tau/2) diff += Tau;     while (diff >   Tau/2) diff -= Tau;      return diff;  }    function l886(v, m) {     let v3 = [v.x, v.y, 1];     let r  = l946(v3, m);      return point(r[0], r[1]); }    function n887(...mm) {     c950(mm.length > 0, 'mulm3m3() must take at least one argument');      let result = clone(mm[0]);      for (let a = 1; a < mm.length; a++)     {         const m1 = result;         const m2 = mm[a];          const m = [[0, 0, 0],                    [0, 0, 0],                    [0, 0, 0]];          for (let i = 0; i < 3; i++)         {             for (let j = 0; j < 3; j++)             {                                  for (let k = 0; k < 3; k++)                     m[i][j] += m1[i][k] * m2[k][j];             }         }          result = m;     }      return result; }    function l888(m, s) {     for (let i = 0; i < 3; i++)         for (let j = 0; j < 3; j++)             m[i][j] /= s;      return m; }    function adjugate(m) {     return cofactor(transpose(m)); }    function transpose(m) {     return [[m[0][0], m[1][0], m[2][0]],             [m[0][1], m[1][1], m[2][1]],             [m[0][2], m[1][2], m[2][2]]]; }    function cofactor(m) {     return [[  m[1][1] * m[2][2] - m[2][1] * m[1][2], -(m[1][0] * m[2][2] - m[2][0] * m[1][2]),  m[1][0] * m[2][1] - m[2][0] * m[1][1] ],             [-(m[0][1] * m[2][2] - m[2][1] * m[0][2]),  m[0][0] * m[2][2] - m[2][0] * m[0][2], -(m[0][0] * m[2][1] - m[2][0] * m[0][1])],             [  m[0][1] * m[1][2] - m[1][1] * m[0][2], -(m[0][0] * m[1][2] - m[1][0] * m[0][2]),  m[0][0] * m[1][1] - m[1][0] * m[0][1] ]];  }    function determinant(m) {     return   m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1])            - m[0][1] * (m[1][0] * m[2][2] - m[2][0] * m[1][2])            + m[0][2] * (m[1][0] * m[2][1] - m[2][0] * m[1][1]); }    function h889(m) {     return l888(adjugate(m), determinant(m)); }    function n890(angle) {     const cosA = a877(Math.cos(angle));     const sinA = a877(Math.sin(angle));      return [[ cosA, sinA, 0],             [-sinA, cosA, 0],             [ 0,    0,    1]]; }    function i891(x = 0, y = 0, scaleX = 1, scaleY = 1, angle = 0, skewX = 0, skewY = 0) {     const cosA = Math.cos(angle);     const sinA = Math.sin(angle);      return [[scaleX*cosA -  skewY*sinA, -skewX*cosA + scaleY*sinA, x],             [ skewY*cosA + scaleX*sinA, scaleY*cosA +  skewX*sinA, y],             [0,                         0,                         1]]; }    function l892(v1, v2) {                               return v1.x * v2.y - v1.y * v2.x; }	    function y893(v1, v2) {     return point(         v1.x + v2.x,         v1.y + v2.y); }	    function sqrv(v) {     return i894(v, v); }    function i894(v1, v2) {     return point(         v1.x * v2.x,         v1.y * v2.y); }	    function a895(v, s) {     return point(         v.x * s,         v.y * s); }	    function m896(v1, v2) {     return point(         v1.x / v2.x,         v1.y / v2.y); }	    function g897(v, s) {     return point(         v.x / s,         v.y / s); }	    function v898(v1, v2) {     return point(         v1.x - v2.x,         v1.y - v2.y); }	    function v899(str)  {     return decodeURI(encodeURIComponent(str)); }    function o900(str)  {     return decodeURIComponent(encodeURI(str)); }    function k901(bytes)  {     let str = '';      for (let i = 0; i < bytes.length; i++)         str += String.fromCharCode(bytes[i]);      return str; }    function w902(str) {     return Array.from(o900(str), c => c.charCodeAt(0)); }    function v903(array, size)  {     const newArray = new Uint8Array(size);     h904(array, newArray);     return newArray; }    function h904(src, dst) {     y905(         src, 0, src.length,         dst, 0, dst.length); }    function y905(src, y906, q907, dst, x908, j909) {     const size = Math.min(q907, j909);      for (let i = 0; i < size; i++)         dst[x908 + i] = src[y906 + i]; }    function b910(t911, x912) {     if (t911.length != x912.length)         return false;      for (let i = 0; i < t911.length; i++)     {         if (t911[i] != x912[i])             return false;     }      return true; }    function b913(d914, i915) {     return d914.findIndex(i => i915.includes(i)) > -1; }    function  y916(list) { return list ? '<==' : '<--'; };  function f917(list) { return list ? '==>' : '-->'; };   function s918(nodeId) { return m873 + ' ' + nodeId; } function y919(name)   { return c874 + ' ' + name;   } function w920(name)   { return e875 + ' ' + name;   }    function z921(str)  {      if (str.trim().toLowerCase() == 'true' ) return true;     if (str.trim().toLowerCase() == 'false') return false;       const num = parseFloat(str);      if (!isNaN(num))         return num > 0;       console.error('invalid bool string "' + str + '"');     return false; }    function stringIsNumber(str) {     const num = Number(str);          if (   (    isNaN(num)              ||  parseFloat(str).toString() !== str.trim())         && !Object.is(num, -0))         return false;          return true; }   function q922(z923, r924 = false) {     return b929(         z923.outputNodeId,         z923.outputId,         z923.outputOrder,         z923.inputNodeId,         z923.inputId,         z923.list,         r924); }    function u925(outputNodeId, outputId, outputOrder, inputNodeId, inputId) {     return y919(           outputNodeId + ' '         + outputId     + ' '         + outputOrder  + ' '         + inputNodeId  + ' '         + inputId); }    function x926(t243) {     return u925(         t243.outputNodeId,         t243.outputId,         t243.outputOrder,         t243.inputNodeId,         t243.inputId); }    function r927(t243) {     return u925(         t243.output.node.id,         t243.output.id,         t243.outputOrder,         t243.input.node.id,         t243.input.id); }    function e928(t243, r924 = false) {     return b929(         t243.output.node.id,         t243.output.id,         t243.outputOrder,         t243.input.node.id,         t243.input.id,         t243.list,         r924); }    function b929(outputNodeId, outputId, outputOrder, inputNodeId, inputId, list, r924 = false) {     const  sp   = r924 ? ' ' : '  ';      const jsp   = r924 ? ''  : ' ';       const arrow =            sp          + u933(typeof outputOrder == 'string' ? parseInt(outputOrder) : outputOrder)          + f917(typeof list == 'string' ? z921(list) : list)          + sp;      const join  = jsp + '.' + jsp;      return  outputNodeId + join + outputId          + arrow          + inputNodeId  + join + inputId;           }    function r930(pageId) {     return w920(pageId); }    function a931(num) {     const str = num.toString();      let sup = '';      for (const c of str)         sup += f932(c);      return sup; }    function f932(c) {     switch (c)     {         case '0': return '⁰';         case '1': return '¹';         case '2': return '²';         case '3': return '³';         case '4': return '⁴';         case '5': return '⁵';         case '6': return '⁶';         case '7': return '⁷';         case '8': return '⁸';         case '9': return '⁹';         case '.': return '·';     } }    function u933(num) {     const str = num.toString();      let sup = '';      for (const c of str)         sup += m934(c);      return sup; }    function m934(c) {     switch (c)     {         case '0': return '₀';         case '1': return '₁';         case '2': return '₂';         case '3': return '₃';         case '4': return '₄';         case '5': return '₅';         case '6': return '₆';         case '7': return '₇';         case '8': return '₈';         case '9': return '₉';         case '.': return ' ';     } }    function h935(bool) {     return bool ? 'true' : 'false'; }    function isValid(val) {     return val != undefined         && val != null; }    function isEmpty(array) {     return array.length == 0; }    function r936(array, item) {     y937(array, array.indexOf(item)); }    function y937(array, index) {     if (   index > -1          && index < array.length)         array.splice(index, 1); }    function a938(array) {     if (isEmpty(array))         return null;      let last = array.at(-1);     array.splice(array.length-1, 1);      return last; }    function a939(array) {     return array[array.length-1]; }    function p940(array, from, to)  {     const item = array[from];     array.splice(from, 1);     array.splice(to, 0, item); }    function u941(array, item) {     const index = array.indexOf(item);          if (index > -1)         array.splice(index, 1); }    function q942(c2894, array) {     for (const item of array)     {         const index = c2894.indexOf(item);                  if (index > -1)             c2894.splice(index, 1);     } }    function b943(array, where) {     const index = array.findIndex(where);          if (index > -1)         array.splice(index, 1); }    function f944(styleId) {     return styleId.split(',')[0] + ','; }    function u945(points) {     let q4126 = '';       if (points.length < 2)         return q4126;       q4126 += 'M';     q4126 += ' ' + a877(points[0].x);     q4126 += ' ' + a877(points[0].y);      for (let i = 1; i < points.length; i++)     {         q4126 +=                ' L'             + ' ' + a877(points[i].x)             + ' ' + a877(points[i].y);     }       return q4126; }    function point(x, y) { return {x: x, y: y}; }    function l946(v, m) {     let r = [0, 0, 0];      for (let i = 0; i < 3; i++)         for (let j = 0; j < 3; j++)             r[i] += v[j] * m[i][j];      return r; }    function clone(val)  {     const type = typeof val;          if (val === null)        return null;      else if (type === 'undefined'            || type === 'number'            || type === 'string'            || type === 'boolean')          return val;      else if (type === 'object')      {         if (val instanceof Array)              return val.map(x => clone(x));          else if (val instanceof Uint8Array)              return new Uint8Array(val);          else          {             let b111 = {};              for (const key in val)                  b111[key] = clone(val[key]);              return b111;         }     }      throw 'unknown'; }    function j947(array, item, equal = null) {     if (equal)     {         if (Array.isArray(item))             item.forEach(i => j947(array, i, equal));         else if (!array.find(i => equal(i, item)))             array.push(item);     }     else     {         if (Array.isArray(item))             item.forEach(i => j947(array, i));         else if (!array.includes(item))             array.push(item);     } }    function v948(array, item, equal) {     if (Array.isArray(item))         item.forEach(i => v948(array, i, equal));     else if (!array.find(equal))         array.push(item); }    function a949(array, item, except) {     if (Array.isArray(item))         item.forEach(i => a949(array, i, except));     else if (!array.find(except))         array.push(item); }    function c950(...args) {               if (enableAsserts)     {         console.assert(...args);              } }    function h951(...args) {               if (enableAsserts)         console.error(...args); }    function n952(str, trim)  {     while (str.length >= trim.length         && str.substring(0, trim.length) == trim)          str = str.substring(trim.length);      return str; }    function w953(str, trim)  {     while (str.length >= trim.length         && str.substring(str.length - trim.length) == trim)          str = str.substring(0, str.length - trim.length);      return str; }    function y954(k4184) {     const fills = [];       for (const fill of k4184)     {         switch (fill[0])         {             case 'SOLID':             {                 const color = {                     r: Math.min(Math.max(0, fill[1] / 0xff), 1),                      g: Math.min(Math.max(0, fill[2] / 0xff), 1),                      b: Math.min(Math.max(0, fill[3] / 0xff), 1) };                  const opacity = Math.min(Math.max(0, fill[4] / 100), 1);                   if (   !isNaN(color.r)                     && !isNaN(color.g)                     && !isNaN(color.b)                     && !isNaN(opacity))                     fills.push(                     {                         type:      fill[0],                          color:     color,                         opacity:   opacity,                         blendMode: fill[5]                     });                   break;             }              case 'GRADIENT_LINEAR':             case 'GRADIENT_RADIAL':             case 'GRADIENT_ANGULAR':             case 'GRADIENT_DIAMOND':             {                 const [p0, p1, p2] = fill[1];                  const k4299 =                      [[0,   1,   0],                      [0.5, 0.5, 1],                      [1,   1,   1]];                  let x4300 = [                     [p0.x, p1.x, p2.x],                     [p0.y, p1.y, p2.y],                     [1,    1,    1   ]];                  x4300 = n887(k4299, h889(x4300));                 x4300 = [x4300[0], x4300[1]];                   const stops = [];                  for (const stop of fill[2])                 {                     stops.push({                         color:                          {                             r: Math.min(Math.max(0, stop[0]), 1),                             g: Math.min(Math.max(0, stop[1]), 1),                             b: Math.min(Math.max(0, stop[2]), 1),                             a: Math.min(Math.max(0, stop[3]), 1)                         },                         position: stop[4]                     });                   }                   fills.push(                 {                     type:              fill[0],                     gradientTransform: x4300,                     gradientStops:     stops,                     blendMode:         fill[3]                 });                   break;             }         }     }       return fills; }    function o955(type) {     return a1088.includes(type); }    function isValueListOfLists(value) {     if (!o955(value.type))         return false;      for (const item of value.items)     {         if (!o955(item.type))             return false;     }      return true; }    function isValueListOfCondensedLists(value) {     if (   !value         || !o955(value.type))         return false;          for (const item of value.items)     {         if (   !item             || !o955(item.type)             ||  item.condensed !== true)             return false;     }      return true; }


function t956(type, active) {     return w957(type, active, g4102); }    function w957(type, active, g4102) {     if (r1165.includes(type))         return active              ? (g4102 ? l2415 : l2405)             : (g4102 ? j2416       : y2406      );      else if (a1166.includes(type))         return active              ? (g4102 ? j2421   : i2411)             : (g4102 ? o2422         : a2412      );      else if (n1295.includes(type)          || x1213.includes(type))         return active              ? (g4102 ? g2419  : e2409)             : (g4102 ? h2420        : d2410      );      else if (n1299.includes(type))         return active              ? (g4102 ? f2417  : z2407)             : (g4102 ? f2418        : s2408      );      else if (o1089.includes(type)           || type == n1086)         return active              ? (g4102 ? r2413   : w2403)             : (g4102 ? i2414         : j2404      );      else if (type == a1215)         return active              ? (g4102 ? r2413   : w2403)             : (g4102 ? i2414         : j2404      );       switch (type)     {         case j1167:               case d1177:         case b1180:         case i1183:         case c1186:          case f1168:                    case a1174:         case o1170:         case b1171:         case t1173:         case s1175:          case m1184:         case c1187:              return g4102                   ? i2414                           : j2404;                                             }                return g4102           ? i2414                   : j2404; }    function d958(color) {     return isNaN(color[1])         || isNaN(color[2])         || isNaN(color[3]); }


function i996(x, replace) {     return !isNaN(x) ? x : replace; }    function v997(c) {     return c >= 'a' && c <= 'z'         || c >= 'A' && c <= 'Z'; }   function j998(i) {     if (i == 0) return 1;      let l = Math.floor(Math.log10(Math.abs(i)));       return l + 1; }    function e999(dec) {     return Math.pow(10, -dec); }    function g1000(c) {     return c >= '0'          && c <= '9'; }    function h1001(c) {     return c.length == 1         && (   c >= 'A' && c <= 'F'             || c >= 'a' && c <= 'f'); }    function v1002(num)  {     if (typeof num !== 'number')         h951('Input must be a number');      return strDecDigits(num.toFixed(10)); }    function strDecDigits(strNum) {     const iDec = strNum.indexOf('.');          if (iDec === -1)         return 0;          let count = strNum.length - iDec - 1;          for (let i = strNum.length-1; i > iDec; i--)     {         if (strNum[i] === '0')             count--;         else             break;     }          return count; }    function z1003(code) {     return code == 'ArrowLeft'         || code == 'ArrowRight'         || code == 'ArrowUp'         || code == 'ArrowDown'; }    function j1004(num, dec = 0, q4096 = false, c1005 = '.', c1006 = '') {     return q4096          ? n1008(num, dec, c1005, c1006)          : v1007(num, dec, c1005, c1006); }    function v1007(num, dec, c1005 = '.', c1006 = '') {     const q4186 = Math.abs(dec);     let    str = Number(num).toFixed(q4186).toString(10);                     let i = str.length-1;          while (i >= 0         && str[i] !== '.'          && str[i] !== ',')         i--;      if (i < 0)          return w1009(str, c1006, 3);           let whole = str.slice(0, i);     let frac  = str.slice(i+1);             i = frac.length-1;      if (dec < 0)     {         while (i >= 0              && frac[i] === '0')             frac = frac.substring(0, i--);     }           return w1009(whole, c1006, 3) + (frac != '' ? c1005 : '') + frac; }    function n1008(num, dec, c1005 = '.', c1006 = '') {     const h4185 = Number(num);     const q4186 = Math.abs(dec);      let   m4183 = Number(num).toFixed(q4186).toString(10);     let    str = Math.abs(h4185).toString(16);                 let i = str.length-1;      while (i >= 0         && str[i] !== '.'          && str[i] !== ',')         i--;      if (i < 0)          return w1009(str, c1006, 2);           let whole = str.slice(0, i);     let frac  = m4183.slice(i+1);                 i = frac.length-1;      let r4187 = parseFloat(frac);     frac = '';      while (r4187 != 0)     {         r4187 *= 16;          const q4188 = Math.floor(r4187);          frac += q4188.toString(16);         r4187 -= q4188;     }           if (whole.length % 2 > 0) whole = '0' + whole;     if (frac .length % 2 > 0) frac  = frac + '0';       const neg = num < 0 ? '-' : '';      return neg + w1009(whole, c1006, 2) + c1005 + f1010(frac, c1006, 2); }    function w1009(m4183, sep, f1011) {     let str = '';      for (let i = m4183.length-1, t = 0; i >= 0; i--, t++)     {         if (t == f1011)         {             str = sep + str;             t = 0;         }          str = m4183[i] + str;     }      return str; }    function f1010(m4183, sep, f1011) {     let str = '';      for (let i = 0, t = 0; i < m4183.length; i++, t++)     {         if (t == f1011)         {             str += sep;             t = 0;         }          str += m4183[i];     }      return str; }                                 function capitalize(str) {     let cap = "";      if (str.length > 0)         cap += str[0].toUpperCase();      if (str.length > 1)         cap += str.substring(1).toLowerCase();      return cap; }    function b1012(c4189) {     const query = window.location.search.substring(1);     const vars  = query.split('&');      for (let i = 0; i < vars.length; i++)      {         let pair = vars[i].split('=');          if (pair[0] == c4189)             return pair[1];     }      return false; }


const phi = (Math.sqrt(5) - 1) / 2;  const Phi = (Math.sqrt(5) + 1) / 2;     function g1013(x, dec) {     const div = Math.round(Math.pow(10, dec));     return Math.floor((x + Number.EPSILON) * div) / div;     }    function d1014(x, dec) {     const div = Math.round(Math.pow(10, dec));     return Math.round((x + Number.EPSILON) * div) / div;     }    function m1015(x, dec) {     const div = Math.ceil(Math.pow(10, dec));     return Math.ceil((x + Number.EPSILON) * div) / div;     }    function k1016(x1, y1, x2, y2) {     const dx = x2 - x1;     const dy = y2 - y1;      return Math.sqrt(dx*dx + dy*dy); }    function vector(angle, dist) {     return point(          dist * Math.cos(angle),          dist * Math.sin(angle)); }    function i1017(v1, v2) {     return v1.x == v2.x         && v1.y == v2.y; }    function v1018(v, salt = 0.0000000001) {     return y893(v, point(         -salt + Math.random() * salt*2,          -salt + Math.random() * salt*2)); }    function j1019(v) {     return point(-v.x, -v.y); }    function o1020(v) {           return point(v.y, -v.x); }    function trimAngle(angle, min = 0, max = Tau) {     while (angle <  min) angle += max - min;     while (angle >= max) angle -= max - min;      return angle; }    function n881(v) {     let angle = Math.atan2(v.y, v.x);     if (angle < 0) angle += Tau;      return angle; }    function u882(p0, p1) {     const v = v898(p1, p0);          let angle = Math.atan2(v.y, v.x);     if (angle < 0) angle += Tau;      return angle; }    function f1021(x, y) {     let angle = Math.atan2(y, x);     if (angle < 0) angle += Tau;      return angle; }    function d4103(p, q, t0, t1) {     if (p == 0 && q < 0)     {         return null;     }     else if (p < 0)     {         let r = q/p;               if (r > t1) return null;         else if (r > t0) t0 = r;     }     else if (p > 0)     {         let r = q/p;               if (r < t0) return null;         else if (r < t1) t1 = r;     }      return [t0, t1]; }    function l4104(x1, y1, x2, y2, left, top, right, bottom) {     let t0 = 0;     let t1 = 1;      let dx = x2 - x1;     let dy = y2 - y1;      let cl = d4103(-dx, -(left - x1), t0, t1); if (cl != null) { t0 = cl[0]; t1 = cl[1]; } else return null;     let cr = d4103( dx, right - x1,   t0, t1); if (cr != null) { t0 = cr[0]; t1 = cr[1]; } else return null;     let ct = d4103(-dy, -(top - y1),  t0, t1); if (ct != null) { t0 = ct[0]; t1 = ct[1]; } else return null;     let cb = d4103( dy, bottom - y1,  t0, t1); if (cb != null) { t0 = cb[0]; t1 = cb[1]; } else return null;      if (t1 < 1)     {         x2 = x1 + t1*dx;         y2 = y1 + t1*dy;     }      if (t0 > 0)     {         x1 = x1 + t0*dx;         y1 = y1 + t0*dy;     }      return [         point(x1, y1),          point(x2, y2) ]; }    function intersect(p1, p2, q1, q2, segment) {     if (   i1017(p1, p2)          || i1017(q1, q2))          return w982;       let v1 = v898(p2, p1);     let v2 = v898(q2, q1);      if (l892(v1, v2) == 0)          return w982;       let t1 = l892(v898(q1, p1), v2) / l892(v1, v2);     let t2 = l892(v898(q1, p1), v1) / l892(v1, v2);      if ((  0 <= t1 && t1 <= 1         && 0 <= t2 && t2 <= 1)         || !segment)         return y893(p1, a895(v1, t1));              return w982; }    function c4105(l0, l1, p, segment) {     if (i1017(p, l0))         return l0;              let d = a895(         z884(o1020(v898(l1, l0))),          distv(p, l0));                  return intersect(l0, l1, p, v898(p, d), segment); }    function x4106(p0, p1, p) {     let cp = c4105(p0, p1, p, false);      let x4300 = n887(         l4107(j1019(p0)),         c4108(-anglev2(p0, p1)));              p0 = transform(p0, x4300);     p1 = transform(p1, x4300);     cp = transform(cp, x4300);      return (cp.x - p0.x) / nozero(p1.x - p0.x); }    function transform(p, x4300) {     return l886(p, x4300); }    function l4107(v) {     return [[1, 0, v.x],             [0, 1, v.y],             [0, 0, 1  ]]; }    function c4108(angle) {     return [[ Math.cos(angle), Math.sin(angle), 0],             [-Math.sin(angle), Math.cos(angle), 0],             [ 0,               0,               1]]; }                          const MaxDigits = 100000;   function i1022(x, res, resSize) {     let carry = 0n;               for (let i = 0; i < resSize; i++)      {         const prod = res[i] * x + carry;              res[i] = prod % 10n;          carry  = prod / 10n;      }                    while (carry)     {         res[resSize] = carry % 10n;         carry        = carry / 10n;         resSize++;     }      return resSize; }    function q1023(max = Number.MAX_SAFE_INTEGER/2) {     const num = Math.floor(Math.random() * max);     return h1024(num); }    function h1024(x)  {     while (!v1025(++x));     return x; }    function v1025(n, k = e1026)  {     if (n <= 1) return false;      if (n <= 3) return true;           if (n % 2 == 0)          return false;                let d = n - 1;          while (d % 2 == 0)          d /= 2;                       for (let i = 0; i < k; i++)             if (!r1027(d, n))             return false;                return true;  }        function r1027(d, n) {     return bigMillerTest(         BigInt(d),         BigInt(n)); }            function r1028(buffer, size) {     return a1029(buffer, 0, size); }    function a1029(buffer, start, size) {     let val = 0;     let mul = 1;      for (let i = start+size-1; i >= start; i--)      {         val += mul * buffer[i];         mul <<= 8;     }      return val; }    function t1030(val, buffer, n1031) {     f1032(val, buffer, 0, n1031); }    function f1032(val, buffer, start, n1031) {     let size = Math.ceil(bigBitCount(val) / 8);          size = Math.min(size, buffer.length - start);      start += n1031 - size;      for (let i = start+size-1; i >= start; i--)      {         buffer[i] = val & 0xFF;          val >>= 8;     } }    function lerpCos(a, b, t) {     return a + (b - a) * (-Math.cos(t*Tau/2)+1)/2; }    function q1033(a, b, t) {     return a + (b - a) * t; }    function q1034(p0, p1, p2, t) {     const c0 = q1033(p0, p1, t);     const c1 = q1033(p1, p2, t);      return q1033(c0, c1, t); }    function tangent2(p0, p1, p2, t) {     return y893(a895(p0, -2*(1-t)), y893(a895(p1, 2*(1-2*t)), a895(p2, 2*t))); }    function tangent3(p0, p1, p2, p3, t) {     return y893(         a895(v898(p1, p0), 3 * Math.pow(1-t, 2)),         y893(            a895(v898(p2, p1), 6 * (1-t) * t),            a895(v898(p3, p2), 3 * Math.pow(t, 2)))); }    function b1035(p0, p1, p2, p3, t) {     const c0  = q1033(p0, p1, t);     const c1  = q1033(p1, p2, t);     const c2  = q1033(p2, p3, t);      const c01 = q1033(c0, c1, t);     const c12 = q1033(c1, c2, t);      return q1033(c01, c12, t); }    function s1036(angle) {     while (angle <  0  ) angle += Tau;     while (angle >= Tau) angle -= Tau;      return angle;  }    function w1037(m, v)  {     const result = [];      for (let i = 0; i < m.length; i++)      {         let sum = 0;          for (let j = 0; j < v.length; j++)              sum += m[i][j] * v[j];          result.push(sum);     }         return result; }    function smoothstep(x) {     if (   x < 0          || x > 1)          return x;      return 3*x*x - 2*x*x*x; }    function getMean(values) {     return values.length > 0          ? values.reduce((a804, cur) => a804 + cur, 0) / values.length          : Number.NaN; }    function getTrimmedMean(values, trimStart, trimEnd = trimStart) {     if (   trimStart <  0         || trimStart >= 0.5         || trimEnd   <  0         || trimEnd   >= 0.5)         throw new Error('trimStart = ' + trimStart + ', trimEnd = ' + trimEnd + ', trim must be between 0 and 0.5');           const sorted         = values.slice().sort((a, b) => a - b);      const trimCountStart = Math.floor(sorted.length * trimStart);     const trimCountEnd   = Math.floor(sorted.length * trimEnd  );      const trimmed   = sorted.slice(trimCountStart, sorted.length - trimCountEnd);     const sum       = trimmed.reduce((a804, val) => a804 + val, 0);      return trimmed.length > 0          ? sum / values.length          : Number.NaN; }    function getMedian(values) {     const sorted = [...values].sort((a, b) => a - b);     const middle = Math.floor(sorted.length / 2);      return sorted.length % 2 == 0          ? (sorted[middle-1] + sorted[middle]) / 2          : sorted[middle]; }


const w982 = point(Number.NaN, Number.NaN);    function e983(p) { return isNaN(p.x) || isNaN(p.y); }    function unit(v) {     return v.X != 0          || v.Y != 0         ? a895(v, 1 / h883(v))         : point(0, 0); }    function z984(p0, p1, t) {     return point(         q1033(p0.x, p1.x, t),         q1033(p0.y, p1.y, t)); }    function j985(p0, p1, p2, t) {     return point(         q1034(p0.x, p1.x, p2.x, t),         q1034(p0.y, p1.y, p2.y, t)); }    function m986(p0, p1, p2, p3, t) {     return point(         b1035(p0.x, p1.x, p2.x, p3.x, t),         b1035(p0.y, p1.y, p2.y, p3.y, t)); }    function d4103(p, q, t0, t1) {     if (p == 0 && q < 0)     {         return null;     }     else if (p < 0)     {         const r = q/p;               if (r > t1) return null;         else if (r > t0) t0 = r;     }     else if (p > 0)     {         const r = q/p;               if (r < t0) return null;         else if (r < t1) t1 = r;     }      return [t0, t1]; }    function l4104(x1, y1, x2, y2, left, top, right, bottom) {     let   t0 = 0;     let   t1 = 1;      const dx = x2 - x1;     const dy = y2 - y1;      const cl = d4103(-dx, -(left - x1), t0, t1); if (cl != null) { t0 = cl[0]; t1 = cl[1]; } else return null;     const cr = d4103( dx,  right - x1,  t0, t1); if (cr != null) { t0 = cr[0]; t1 = cr[1]; } else return null;     const ct = d4103(-dy,  -(top - y1), t0, t1); if (ct != null) { t0 = ct[0]; t1 = ct[1]; } else return null;     const cb = d4103( dy,  bottom - y1, t0, t1); if (cb != null) { t0 = cb[0]; t1 = cb[1]; } else return null;      if (t1 < 1)     {         x2 = x1 + t1*dx;         y2 = y1 + t1*dy;     }      if (t0 > 0)     {         x1 = x1 + t0*dx;         y1 = y1 + t0*dy;     }      return [         point(x1, y1),          point(x2, y2) ]; }    function i987(p1, p2, q1, q2, segment) {     if (   i1017(p1, p2)          || i1017(q1, q2))          return w982;       const v1 = v898(p2, p1);     const v2 = v898(q2, q1);      if (l892(v1, v2) == 0)          return w982;       const t1 = l892(v898(q1, p1), v2) / l892(v1, v2);     const t2 = l892(v898(q1, p1), v1) / l892(v1, v2);      if (   (   0 <= t1 && t1 <= 1             && 0 <= t2 && t2 <= 1)         || !segment)         return y893(p1, a895(v1, t1));              return w982; }    function c4105(l0, l1, p, segment, constrain = 0) {     if (i1017(p, l0))         return l0;      const v    = z884(o1020(v898(l1, l0)));           const dist = distv(p, z984(l0, l1, 1/2)) * 2;       const c    = z984(l0, l1, 1/2);     const dir  = distv(y893(p, v), c) < distv(p, c);       let d;               if (constrain == 2) d = point(dir ? -dist : dist, 0);     else if (constrain == 1) d = point(0, dir ? -dist : dist);     else                     d = a895(v, dir ? -dist : dist);       return i987(l0, l1, p, v898(p, d), segment); }    function x4106(p0, p1, p) {     let cp = c4105(p0, p1, p, false);      const x4300 = n887(         l4107(-p0),         c4108(-anglev2(p0, p1)));      p0 = transform(p0, x4300);     p1 = transform(p1, x4300);     cp = transform(cp, x4300);      return (cp.X - p0.X) / nozero(p1.X - p0.X); }    function v988(rect1, rect2) {     return rect1.l >= rect2.l         && rect1.r <= rect2.r         && rect1.t >= rect2.t         && rect1.b <= rect2.b;  }    function y989(rect1, rect2) {     return !(            rect1.l >= rect2.r         || rect1.r <= rect2.l         || rect1.t >= rect2.b         || rect1.b <= rect2.t);  }    function o990(rect, clip) {     if (!y989(rect, clip))         return j1045.NaN;      return new AbsRect(         Math.max(rect.l, clip.l),         Math.max(rect.t, clip.t),         Math.min(rect.r, clip.r),         Math.min(rect.b, clip.b)); }    function v991(rect) {     return new j1045(         rect.x + Math.min(rect.w, 0),         rect.y + Math.min(rect.h, 0),         Math.abs(rect.w),         Math.abs(rect.h)); }    function u992(x, y, w, h) {     return [         x + Math.min(w, 0),         y + Math.min(h, 0),         Math.abs(w),         Math.abs(h) ]; }    function transform(p, x4300) {     return l886(p, x4300); }    function l4107(v) {     return [[1, 0, v.x],             [0, 1, v.y],             [0, 0, 1  ]]; }    function c4108(angle) {     return [[ Math.cos(angle), Math.sin(angle), 0],             [-Math.sin(angle), Math.cos(angle), 0],             [ 0,               0,               1]]; }    function offsetRect(elem) {     return new j1045(         elem.offsetLeft,         elem.offsetTop,         elem.offsetWidth,         elem.offsetHeight); }    function n993(elem) {     const bounds = elem.getBoundingClientRect();      return new j1045(         bounds.x,         bounds.y,         bounds.width,         bounds.height); }    function a994(p0, p1, p2) {     const v0  = v898(p1, p0);     const v1  = v898(p2, p1);          const pm0 = g897(y893(p0, p1), 2);     const pm1 = g897(y893(p1, p2), 2);          return i987(         pm0, y893(pm0, o1020(v0)),          pm1, v898(pm1, o1020(v1)),          false); }    function i995(p1, p2, p3) {           const pc = a994(p1, p2, p3);      let a = o885(         n881(v898(p1, pc)),         n881(v898(p2, pc)));                           return a; }    function makeWave(shape, x, y, width, amplitude, frequency, offset, alignX, alignY) {     const startX = x;     const w      = width / frequency;           x += offset;               while (x >  -w) x -= w;     while (x <= -w) x += w;       if (alignY == 1)         amplitude *= 2;               let height = amplitude;       const points = [];       if (Math.abs(w) > 0.0000001)     {         switch (shape)         {             case 0: makeSquareWave  (x, y, width, height, startX, w, points); break;             case 1: makeSawWave     (x, y, width, height, startX, w, points); break;             case 2: makeBackSawWave (x, y, width, height, startX, w, points); break;             case 3: makeTriangleWave(x, y, width, height, startX, w, points); break;             case 4: makeSineWave    (x, y, width, height, startX, w, points); break;         }                   points.forEach(p =>         {                  if (alignX == 1) p.x -= width/2;             else if (alignX == 2) p.x -= width;         });          points.forEach(p =>         {                  if (alignY == 1) p.y -= height/2;             else if (alignY == 2) p.y -= height;         });     }       return points; }    function makeSquareWave(x, y, width, height, startX, w, points) {     let p0, p1;           while (x < startX + width)     {         if (x + w/2 > startX)         {             p0 = point(x,     y);             p1 = point(x+w/2, y);              clipLineSegment(p0, p1, startX, width);              points.push(p0, p1);         }          x += w/2;           if (x < startX + width)         {             p0 = point(x,     y+height);             p1 = point(x+w/2, y+height);                          clipLineSegment(p0, p1, startX, width);                          points.push(p0, p1);         }          x += w/2;     } }    function makeSawWave(x, y, width, height, startX, w, points) {     let p0, p1;           while (x < startX + width)     {         if (x + w > startX)         {             p0 = point(x,   y       );             p1 = point(x+w, y+height);              clipLineSegment(p0, p1, startX, width);              points.push(p0, p1);         }          x += w;     } }    function makeBackSawWave(x, y, width, height, startX, w, points) {     let p0, p1;           while (x < startX + width)     {         if (x + w > startX)         {             p0 = point(x,   y+height);             p1 = point(x+w, y       );              clipLineSegment(p0, p1, startX, width);              points.push(p0, p1);         }          x += w;     } }    function makeTriangleWave(x, y, width, height, startX, w, points) {     let p0, p1;      let i = 0;     while (x < startX + width)     {         if (x + w/2 > startX)         {             p0 = point(x,     y+height);             p1 = point(x+w/2, y       );              clipLineSegment(p0, p1, startX, width);              if (i++ == 0) points.push(p0);             points.push(p1);         }          x += w/2;           if (x < startX + width)         {             p0 = point(x,     y       );             p1 = point(x+w/2, y+height);              clipLineSegment(p0, p1, startX, width);              if (i++ == 0) points.push(p0);             points.push(p1);         }          x += w/2;     } }    function makeSineWave(x, y, width, height, startX, w, points) {     let p0, p1, p2, p3;      let i = 0;     while (x < startX + width)     {         if (x + w/2 > startX)         {             p0 = point(x,                              y+height);             p1 = point(x     + (x+w/2 - x)   * 0.3615, y+height);             p2 = point(x+w/2 + (x - (x+w/2)) * 0.3615, y       );             p3 = point(x+w/2,                          y       );              clipSinSegment(p0, p1, p2, p3, startX, width);              if (i++ == 0) points.push(p0);             points.push(p1, p2, p3);         }          x += w/2;           if (x < startX + width)         {             p0 = point(x,                              y       );             p1 = point(x     + (x+w/2 - x)   * 0.3615, y       );             p2 = point(x+w/2 + (x - (x+w/2)) * 0.3615, y+height);             p3 = point(x+w/2,                          y+height);                          clipSinSegment(p0, p1, p2, p3, startX, width);                          if (i++ == 0) points.push(p0);             points.push(p1, p2, p3);         }          x += w/2;     } }    function clipLineSegment(p0, p1, startX, width) {     if (   p0.x <  startX         && p1.x >= startX)     {         const t        = (startX - p0.x) / nozero(p1.x - p0.x);         const segments = splitLineSeg(p0, p1, t);         const seg      = segments[1];          p0.x = seg[0].x;  p0.y = seg[0].y;         p1.x = seg[1].x;  p1.y = seg[1].y;     }          if (   p0.x <  startX + width         && p1.x >= startX + width)     {         const t        = (startX + width - p0.x) / nozero(p1.x - p0.x);         const segments = splitLineSeg(p0, p1, t);         const seg      = segments[0];          p0.x = seg[0].x;  p0.y = seg[0].y;         p1.x = seg[1].x;  p1.y = seg[1].y;     } }    function clipSinSegment(p0, p1, p2, p3, startX, width) {     if (   p0.x <  startX         && p3.x >= startX)     {         const t        = findTforX3(p0, p1, p2, p3, startX);         const segments = c858(p0, p1, p2, p3, t);         const seg      = segments[1];          p0.x = seg[0].x;  p0.y = seg[0].y;         p1.x = seg[1].x;  p1.y = seg[1].y;         p2.x = seg[2].x;  p2.y = seg[2].y;         p3.x = seg[3].x;  p3.y = seg[3].y;     }          if (   p0.x <  startX + width         && p3.x >= startX + width)     {         const t        = findTforX3(p0, p1, p2, p3, startX + width);         const segments = c858(p0, p1, p2, p3, t);         const seg      = segments[0];          p0.x = seg[0].x;  p0.y = seg[0].y;         p1.x = seg[1].x;  p1.y = seg[1].y;         p2.x = seg[2].x;  p2.y = seg[2].y;         p3.x = seg[3].x;  p3.y = seg[3].y;     } }


const b2631   = 4 * (Math.sqrt(2) - 1) / 3;        // or use the value 0.55191502449 from http://spencermortensen.com/articles/bezier-circle/
const j2641 = 0.9993391093366649465402826439248;     function z853(x0, y0, x1, y1, x2, y2, x3, y3, t) {     const p0 = point(x0, y0);     const p1 = point(x1, y1);     const p2 = point(x2, y2);     const p3 = point(x3, y3);      return unit(y893(y893(         a895(v898(p1, p0), 3*sqr(1-t)),         a895(v898(p2, p1), 6*(1-t)*t)),         a895(v898(p3, p2), 3*sqr(t)))); }    function pointAlongLine(p0, p1, dist) {     return y893(p0, a895(z884(v898(p1, p0)), dist)); }    function n854(p0, p1, p2, dist, error = 0.001) {     const hullLength =            distv(p0, p1)          + distv(p1, p2);      if (hullLength == 0)         return Number.NAN;       let t = dist / hullLength;      if (t < 0 || t > 1)         return Number.NAN;               let halves = n857(p0, p1, p2, t);     let l      = halves[0];      let length = v859(l[0], l[1], l[2], error);       let w3953 = 1000;      while (Math.abs(dist - length) > error         && w3953-- > 0)     {         t += (dist - length) / hullLength;          halves = n857(p0, p1, p2, t);         l      = halves[0];          length = v859(l[0], l[1], l[2], error);     }      if (w3953 == 0)         h951('endless loop in n854()');       return t; }    function i855(p0, p1, p2, p3, dist, error = 0.001) {     const hullLength =            distv(p0, p1)          + distv(p1, p2)         + distv(p2, p3);      if (hullLength == 0)         return Number.NAN;       let t = dist / hullLength;      if (t < 0 || t > 1)         return Number.NAN;               let halves = c858(p0, p1, p2, p3, t);     let l      = halves[0];      let length = w860(l[0], l[1], l[2], l[3], error);       let w3953 = 1000;      while (Math.abs(dist - length) > error         && w3953-- > 0)     {         t += (dist - length) / hullLength;          halves = c858(p0, p1, p2, p3, t);         l      = halves[0];          length = w860(l[0], l[1], l[2], l[3], error);     }      if (w3953 == 0)         h951('endless loop in i855()');       return t; }    function tangentAlongSegment2(p0, p1, p2, dist, error = 0.001) {     const hullLength =            distv(p0, p1)          + distv(p1, p2);      if (hullLength == 0)         return Number.NAN;       let t = dist / hullLength;      if (t < 0 || t > 1)         return Number.NAN;               let halves = n857(p0, p1, p2, t);     let l      = halves[0];      let length = v859(l[0], l[1], l[2], error);       let w3953 = 1000;      while (Math.abs(dist - length) > error         && w3953-- > 0)     {         t += (dist - length) / hullLength;          halves = n857(p0, p1, p2, t);         l      = halves[0];          length = v859(l[0], l[1], l[2], error);     }      if (w3953 == 0)         h951('endless loop in n854()');       return t; }    function tangentAlongSegment3(p0, p1, p2, p3, dist, error = 0.001) {     const hullLength =            distv(p0, p1)          + distv(p1, p2)         + distv(p2, p3);      if (hullLength == 0)         return Number.NAN;       let t = dist / hullLength;      if (t < 0 || t > 1)         return Number.NAN;               let halves = c858(p0, p1, p2, p3, t);     let l      = halves[0];      let length = w860(l[0], l[1], l[2], l[3], error);       let w3953 = 1000;      while (Math.abs(dist - length) > error         && w3953-- > 0)     {         t += (dist - length) / hullLength;          halves = c858(p0, p1, p2, p3, t);         l      = halves[0];          length = w860(l[0], l[1], l[2], l[3], error);     }      if (w3953 == 0)         h951('endless loop in i855()');       return t; }    function splitLineSeg(p0, p1, t) {     const c = z984(p0, p1, t);      return [ [p0, c],              [c, p1] ]; }    function n857(p0, p1, p2, t) {     const c0  = z984(p0, p1, t);     const c1  = z984(p1, p2, t);      const c01 = z984(c0, c1, t);      return [ [p0, c0, c01],              [c01, c1, p2] ]; }    function c858(p0, p1, p2, p3, t) {     const c0   = z984(p0, p1, t);     const c1   = z984(p1, p2, t);     const c2   = z984(p2, p3, t);                      const c01  = z984(c0, c1, t);     const c12  = z984(c1, c2, t);      const c012 = z984(c01, c12, t);      return [ [p0, c0, c01, c012],              [c012, c12, c2, p3] ]; }    function v859(p0, p1, p2, error = 0.0000001) {     const t856 =           distv(p0, p1)         + distv(p1, p2);      const chord = distv(p0, p2);                if (t856 - chord > error)     {         const halves = n857(p0, p1, p2, 0.5);         const l      = halves[0];         const r      = halves[1];                      return v859(l[0], l[1], l[2], error)              + v859(r[0], r[1], r[2], error);     }      return t856; }    function w860(p0, p1, p2, p3, error = 0.0000001) {     const t856 =            distv(p0, p1)         + distv(p1, p2)         + distv(p2, p3);      const chord = distv(p0, p3);      if ((t856 - chord) > error)     {         const halves = c858(p0, p1, p2, p3, 0.5);         const l      = halves[0];         const r      = halves[1];                      return w860(l[0], l[1], l[2], l[3], error)              + w860(r[0], r[1], r[2], r[3], error);     }      return t856; }    function t861(p0, p1, p2) {     let rect = j1045.NaN;       rect = m3840(rect, p0);     rect = m3840(rect, p2);            if (   (   p0.x <= p1.x && p1.x <= p2.x             || p2.x <= p1.x && p1.x <= p0.x)         && (   p0.y <= p1.y && p1.y <= p2.y             || p2.y <= p1.y && p1.y <= p0.y))         return rect;       const ax = p0.x - 2*p1.x + p2.x;     const bx = 2 * (p1.x - p0.x);          const ay = p0.y - 2*p1.y + p2.y;     const by = 2 * (p1.y - p0.y);       const tx = -bx / nozero(2*ax);     const ty = -by / nozero(2*ay);       if (tx >= 0 && tx <= 1) rect = m3840(rect, j985(p0, p1, p2, tx));     if (ty >= 0 && ty <= 1) rect = m3840(rect, j985(p0, p1, p2, ty));           return rect; }    function m862(p0, p1, p2, p3) {     let rect = j1045.NaN;      rect = m3840(rect, p0);     rect = m3840(rect, p3);       const ax =   -p0.x + 3*p1.x - 3*p2.x + p3.x;     const bx =  3*p0.x - 6*p1.x + 3*p2.x;     const cx = -3*p0.x + 3*p1.x;      const ay =   -p0.y + 3*p1.y - 3*p2.y + p3.y;     const by =  3*p0.y - 6*p1.y + 3*p2.y;     const cy = -3*p0.y + 3*p1.y;       const roots = [];       r863(ax, bx, cx, roots);     r863(ay, by, cy, roots);       for (const root of roots)     {         const v = m986(p0, p1, p2, p3, root);                                                        rect = m3840(             rect,              v);     }            return rect; }    function r863(a, b, c, roots) {     a *= 3;     b *= 2;       let D = b*b - 4*a*c;     let r;      if (   Math.abs(a) < 1e-6         && Math.abs(b) > 1e-6)      {         r = -c/b;  if (r >= 0 && r <= 1) roots.push(r);         return;     }       if (D >= 0)      {         const sqrtD = Math.sqrt(D);          r = (-b + sqrtD) / (2*a);  if (r >= 0 && r <= 1) roots.push(r);         r = (-b - sqrtD) / (2*a);  if (r >= 0 && r <= 1) roots.push(r);     } }    function pointAlongCurve(degree, points, distance, error = 0.000001) {     let length    = 0;     let segLength = 0;       let i;     for (i = 0; i < points.length - degree - 1; i += degree)     {         switch (degree)         {         case 1:  segLength = distv     (points[i], points[i+1]);                                  break;         case 2:  segLength = v859(points[i], points[i+1], points[i+2],              error); break;         case 3:  segLength = w860(points[i], points[i+1], points[i+2], points[i+3], error); break;         default: c950(false);         }          if (length + segLength >= distance)             break;          length += segLength;     }       switch (degree)     {     case 1:  return pointAlongLine(points[i], points[i+1], distance - length);     case 2:  return j985        (points[i], points[i+1], points[i+2],              n854(points[i], points[i+1], points[i+2],              distance - length));     case 3:  return m986        (points[i], points[i+1], points[i+2], points[i+3], i855(points[i], points[i+1], points[i+2], points[i+3], distance - length));     default: c950(false);      }           return w982; }    function tangentAlongCurve(degree, points, distance, error = 0.000001) {     let length    = 0;     let segLength = 0;       let i;     for (i = 0; i < points.length - degree - 1; i += degree)     {         switch (degree)         {         case 1:  segLength = distv     (points[i], points[i+1]);                                  break;         case 2:  segLength = v859(points[i], points[i+1], points[i+2],              error); break;         case 3:  segLength = w860(points[i], points[i+1], points[i+2], points[i+3], error); break;         default: c950(false);         }          if (length + segLength >= distance)             break;          length += segLength;     }       switch (degree)     {     case 1:  return v898    (points[i+1], points[i]);     case 2:  return tangent2(points[i], points[i+1], points[i+2],              n854(points[i], points[i+1], points[i+2],              distance - length));     case 3:  return tangent3(points[i], points[i+1], points[i+2], points[i+3], i855(points[i], points[i+1], points[i+2], points[i+3], distance - length));     default: c950(false);      }           return w982; }    function curveLength(degree, points) {     let length = 0;      for (let i = 0; i < points.length - degree; i += degree)     {         switch (degree)         {             case 1:                 length += distv(                     points[i  ],                      points[i+1]);                 break;              case 2:                 length += v859(                     points[i  ],                      points[i+1],                     points[i+2]);                 break;              case 3:                 length += w860(                     points[i  ],                      points[i+1],                     points[i+2],                     points[i+3]);                 break;         }     }      return length; }    function linear2cubic(linear) {     if (linear.length == 0)         return [];       const cubic = [linear[0]];          for (let i = 0; i < linear.length-1; i++)     {         const p0 = linear[i  ];         const p1 = linear[i+1];          cubic.push(             z984(p0, p1, 1/3),             z984(p0, p1, 2/3),             p1);     }      return cubic; }    function quad2cubic(quad) {     if (quad.length == 0)         return [];       const cubic = [quad[0]];          for (let i = 0; i < quad.length-2; i += 2)     {         const p0 = quad[i  ];         const p1 = quad[i+1];         const p2 = quad[i+2];          cubic.push(             z984(p0, p1, 2/3),             z984(p2, p1, 2/3),             p2);     }      return cubic; }    function makeArc(p1, p2, p3) {     if (areClockwise(p1, p2, p3))     {         const pt = p1;         p1 = p3;         p3 = pt;     }      const pc = a994(p1, p2, p3);      const sa = n881(v898(p1, pc));     let   ea = n881(v898(p3, pc));      while (ea > sa) ea -= Tau;       return makeArc_(         pc,         h883(v898(p1, pc)),         sa,         ea); }    function makeArc_(center, radius, startAngle, endAngle) {     let diff  = endAngle - startAngle;     let angle = startAngle;       const points = [];       while (Math.abs(diff) > 0)     {         const da =              diff >= 0              ? Math.min(diff,  Tau/4)              : Math.max(diff, -Tau/4);          const handle = radius * arcKappa(da) * j2641;          const p1 = y893(center, vector(angle,      radius));         const p2 = y893(center, vector(angle + da, radius));              const v1 = v898(p1, center);         const v2 = v898(p2, center);           points.push(             p1,             v898(p1, a895(o1020(z884(v1)), handle)),             y893(p2, a895(o1020(z884(v2)), handle)));          angle += da;         diff  -= da;     }           points.push(y893(center, vector(endAngle, radius)));       return points; }    function arcKappa(angle)  {     return 4 * Math.tan(angle/4) / 3;  }     function areClockwise(p0, p1, p2) {     return l892(v898(p1, p0), v898(p2, p1)) >= 0; }    function createCompleteCurve(degree, x3841, closed) {     const segPoints = x3841.slice(0, Math.floor((x3841.length-1) / degree) * degree + 1);     let   points;               if (closed)     {         if (   x3841.length == segPoints.length             && i1017(x3841[0], x3841.at(-1)))             points = x3841;         else if (x3841.length - segPoints.length == degree-1)             points = [...x3841, x3841[0]];         else         {             switch (degree)             {             case 1: points = [...segPoints,                                                                                         segPoints[0]]; break;             case 2: points = [...segPoints, z984(segPoints.at(-1), segPoints[0], 1/2),                                             segPoints[0]]; break;             case 3: points = [...segPoints, z984(segPoints.at(-1), segPoints[0], 1/3), z984(segPoints.at(-1), segPoints[0], 2/3), segPoints[0]]; break;             }         }     }     else         points = segPoints;       return points; }    function findTforX3(p0, p1, p2, p3, x)  {            let precision     = 0.00001;     let t             = 0.5;      let maxIterations = 20;     let i             = 0;        while (i < maxIterations)      {         let xAtT =     (1 - t)**3        * p0.x                  + 3 * (1 - t)**2 * t    * p1.x                  + 3 * (1 - t)    * t**2 * p2.x                  +                  t**3 * p3.x;              let dAtT = -3 * (1 - t)**2 * p0.x                    + 3 * (1 - t)**2 * p1.x - 6 * t * (1 - t) * p1.x                    - 3 *      t **2 * p2.x + 6 * t * (1 - t) * p2.x                    + 3 *      t **2 * p3.x;              let tNext = t - (xAtT - x) / dAtT;               if (Math.abs(tNext - t) < precision)            return tNext;                     t = tNext;         i++;     }         return t; }            function k610(degree, points, p) {     const closestPoints = [];      let i;     for (i = 0; i < points.length - degree; i += degree)     {         switch (degree)         {         case 1:  closestPoints.push(c4105(points[i], points[i+1], p, true));         case 2:  closestPoints.push(j985(points[i], points[i+1], points[i+2],              t611(points[i], points[i+1], points[i+2],              p, 0, 1)));         case 3:  closestPoints.push(m986(points[i], points[i+1], points[i+2], points[i+3], s612(points[i], points[i+1], points[i+2], points[i+3], p, 0, 1)));         default: c950(false);         }     }       let closest = w982;      for (const cp of closestPoints)     {         if (   e983(closest)             || distv(cp, p) < distv(closest, p))             closest = cp;     }       return closest; }    function closestTangentOnCurve(degree, points, p, constrain = 0) {     const closestPoints = [];      let i;     for (i = 0; i < points.length - degree; i += degree)     {         switch (degree)         {         case 1:               closestPoints.push([                 c4105(points[i], points[i+1], p, true, constrain),                 v898(points[i+1], points[i])]);              break;          case 2:           {             const t = t611(points[i], points[i+1], points[i+2], p, 0, 1, constrain);              closestPoints.push([                 j985  (points[i], points[i+1], points[i+2], t),                  tangent2(points[i], points[i+1], points[i+2], t)]);               break;         }         case 3:           {             const t = s612(points[i], points[i+1], points[i+2], points[i+3], p, 0, 1, constrain);              closestPoints.push([                 m986  (points[i], points[i+1], points[i+2], points[i+3], t),                 tangent3(points[i], points[i+1], points[i+2], points[i+3], t)]);               break;         }         default: c950(false);         }     }       let closest = w982;     let tangent = w982;      for (let i = 0; i < closestPoints.length; i++)     {         const cp = closestPoints[i][0];          if (   e983(closest)             || distv(cp, p) < distv(closest, p))         {             closest = cp;             tangent = closestPoints[i][1];         }     }       return [closest, tangent]; }    function t611(p0, p1, p2, p, start, end, constrain = 0, nSlices = 1000, nIterations = 1000) {     if (nIterations <= 0)          return (start + end) / 2;                const tick = (end - start) / nSlices;      if (tick <= 0.000001)         return (start + end) / 2;       let best = 0;      let bestDistance = Number.MAX_SAFE_INTEGER;     let currentDistance;       let t = start;          while (t <= end)      {         const hp  = j985(p0, p1, p2, t);         const dp2 = sqrv(v898(hp, p));          currentDistance =                (constrain != 2 ? dp2.x : 0)              + (constrain != 1 ? dp2.y : 0);          if (currentDistance < bestDistance)          {             bestDistance = currentDistance;             best = t;         }                  t += tick;     }       return t611(         p0, p1, p2,         p,          Math.max(best - tick, 0),          Math.min(best + tick, 1),          constrain,         nSlices,         nIterations - 1); }    function s612(p0, p1, p2, p3, p, start, end, constrain = 0, nSlices = 1000, nIterations = 1000) {     if (nIterations <= 0)         return (start + end) / 2;           const tick = (end - start) / nSlices;      if (tick <= 0.000001)         return (start + end) / 2;       let best = 0;      let bestDistance = Number.MAX_SAFE_INTEGER;     let currentDistance;       let t = start;          while (t <= end)      {         const hp  = m986(p0, p1, p2, p3, t);         const dp2 = sqrv(v898(hp, p));                  currentDistance =                (constrain != 2 ? dp2.x : 0)              + (constrain != 1 ? dp2.y : 0);          if (currentDistance < bestDistance)          {             bestDistance = currentDistance;             best = t;         }                  t += tick;     }       return s612(         p0, p1, p2, p3,         p,          Math.max(best - tick, 0),          Math.min(best + tick, 1),          nSlices,         nIterations - 1); }


class Point {     x;     y;      constructor(x, y)     {         this.x = x;         this.y = y;     } }


class j1045 {     x;     y;     w;     h;       get l()            { return this.x;            }     get c()            { return this.x + this.w/2; }     get r()            { return this.x + this.w;   }                 get t()            { return this.y;            }     get m()            { return this.y + this.h/2  }     get b()            { return this.y + this.h;   }                get tl()           { return point(this.l, this.t); }     get tc()           { return point(this.c, this.t); }     get tr()           { return point(this.r, this.t); }     get ml()           { return point(this.l, this.m); }     get mc()           { return point(this.c, this.m); }     get cm()           { return point(this.c, this.m); }     get mr()           { return point(this.r, this.m); }     get bl()           { return point(this.l, this.b); }     get bc()           { return point(this.c, this.b); }     get br()           { return point(this.r, this.b); }                   get width()        { return this.w; }     get height()       { return this.h; }            get left()         { return this.l; }     get center()       { return this.c; }     get right()        { return this.r; }                get top()          { return this.t; }     get middle()       { return this.m; }     get bottom()       { return this.b; }      get topLeft()      { return this.tl; }     get topCenter()    { return this.tc; }     get topRight()     { return this.tr; }     get middleLeft()   { return this.ml; }     get middleCenter() { return this.mc; }     get centerMiddle() { return this.cm; }     get middleRight()  { return this.mr; }     get bottomLeft()   { return this.bl; }     get bottomCenter() { return this.bc; }     get bottomRight()  { return this.br; }        constructor(x, y, w, h)     {         this.x = x;         this.y = y;         this.w = w;         this.h = h;     }        static i3686(rect)     {         return new j1045(rect.x, rect.y, rect.width, rect.height);      }             static get NaN () { return new j1045(Number.NaN, Number.NaN, 0, 0) };     static get Zero() { return new j1045(0, 0, 0, 0); }        get isNaN()     {         return isNaN(this.x)             || isNaN(this.y)             || isNaN(this.w)             || isNaN(this.h);     }    	get isEmpty() 	{ 		return (this.w == 0 			 || this.h == 0); 	}        assign(rect)     {         this.x = rect.x;         this.y = rect.y;         this.w = rect.w;         this.h = rect.h;     } }    class   AbsRect extends j1045 {     constructor(l, t, r, b)     {         super(l, t, r-l, b-t);     } }    function l3839(rect1, rect2) {     if (rect1.isNaN) return j1045.i3686(rect2);     if (rect2.isNaN) return j1045.i3686(rect1);          return new AbsRect(         Math.min(rect2.l, rect1.l),         Math.min(rect2.t, rect1.t),         Math.max(rect2.r, rect1.r),         Math.max(rect2.b, rect1.b)); }    function m3840(rect, p) {     if (rect.isNaN)          return new j1045(p.x, p.y, 0, 0);      return new AbsRect(         Math.min(p.x, rect.l),         Math.min(p.y, rect.t),         Math.max(p.x, rect.r),         Math.max(p.y, rect.b)); } 


class Random {     seed;     index;       cache;        constructor(seed = 0)     {          this.seed  = seed;          this.index = 0;                  this.s1044(256);     }        copy()     {         return new Random(this.seed);     }        s1044(size)     {         this.cache = new Int32Array(size);                  let seed = this.seed;          for (let i = 0; i < size; i++)             this.cache[i] = seed = this.generate(seed);     }        next()     {         if (this.index >= this.cache.length)             this.s1044(s880(this.index));          return this.cache[this.index++] / -0x7fffffff;     }        get(index)     {         if (index >= this.cache.length)             this.s1044(s880(index+1));          return this.cache[index] / -0x7fffffff;     }        generate(seed)     {         seed = (seed + 0x7ed55d16) + (seed << 12);         seed = (seed ^ 0xc761c23c) ^ (seed >> 19);         seed = (seed + 0x165667b1) + (seed <<  5);         seed = (seed + 0xd3a2646c) ^ (seed <<  9);         seed = (seed + 0xfd7046c5) + (seed <<  3);         seed = (seed ^ 0xb55a4f09) ^ (seed >> 16);          return seed;     } }


class y375 {     seed;     cache;      width;     height;        constructor(seed = 0)     {          this.seed  = seed;          this.s1044(256, 16);     }        copy()     {         return new Random(this.seed);     }        s1044(width, height)     {         if (   width  <= this.width             && height <= this.height)             return;          this.width  = width;         this.height = height;                  const seeds = new Array(this.width);         this.cache  = new Array(this.width);           let seed = this.seed;          for (let i = 0; i < this.width; i++)         {             seeds[i] = seed;             seed = this.generate1(seed);         }           for (let i = 0; i < this.width; i++)         {             this.cache[i] = new Array(this.height);             seed = seeds[i];              for (let j = 0; j < this.height; j++)             {                 this.cache[i][j] = seed;                 seed = this.generate2(seed);             }         }     }        get(x, y)     {           if (   x >= this.width                && y >= this.height) this.s1044(s880(x+1), s880(y+1));         else if (x >= this.width ) this.s1044(s880(x+1), this.height  );         else if (y >= this.height) this.s1044(this.width,    s880(y+1));          return this.cache[x][y] / -0x7fffffff;     }        generate1(seed)     {         seed = (seed + 0x7ed55d16) + (seed << 12);         seed = (seed ^ 0xc761c23c) ^ (seed >> 19);         seed = (seed + 0x165667b1) + (seed <<  5);         seed = (seed + 0xd3a2646c) ^ (seed <<  9);         seed = (seed + 0xfd7046c5) + (seed <<  3);         seed = (seed ^ 0xb55a4f09) ^ (seed >> 16);          return seed;     }        generate2(seed)     {         seed = (seed + 0x7f4a7c13) + (seed << 12);         seed = (seed ^ 0xe17a1465) ^ (seed >> 19);         seed = (seed + 0x59f89f1b) + (seed <<  5);         seed = (seed + 0xac564b05) ^ (seed <<  9);         seed = (seed + 0x65291958) + (seed <<  3);         seed = (seed ^ 0x4ab1db4f) ^ (seed >> 16);              return -seed;     } }


const i1455 = navigator.platform.toLowerCase().indexOf('mac') >= 0;    var h4109; var f4110;        const console_trace = console.trace;      console.trace = msg => {     console.groupCollapsed(msg || 'trace');     console_trace.apply(this);     console.groupEnd(); };    function r1456() {     h4109  = document.createElement('canvas');     f4110 = h4109.getContext('2d');      f4110.willReadFrequently = true; }    function avg(a, b) {     return (a + b) / 2; }    function swap(a, b) {     return [b, a]; }    function flipBit(value, index) {     const bit = ((value >> index) & 1) != 0;      return value         & ~(1 << index)         | (!bit ? 1 : 0) << index; }    function y1457(parent, child) {     return Array.prototype.indexOf.call(parent.children, child); }    function f4111(count, singular, plural = singular) {     if (singular == plural)     {         const x3964   = singular.at(-1);         const i3965 = x3964 == x3964.toUpperCase() ? 'S' : 's';          return singular + (count == 1 ? '' : i3965);     }     else     {         const x3964 = plural.at(-1);          if (x3964 == x3964.toUpperCase())             plural = plural.toUpperCase();          return count == 1             ? singular             : plural;     } }    function o1458(u1459) {     const q3966   = u1459.indexOf('.');     const z3967 = u1459.indexOf(',');      return q3966 >= 0          ? u1459.length-1 - q3966          : (z3967 >= 0             ? u1459.length-1 - z3967             : 0); }    function h1460() {     const num = 1.1;      return num         .toLocaleString(navigator.language)         .substring(1, 2); }    function n1461(b111) {     if (b111 == null)         return false;              return (            Object.keys(b111).length === 0          && b111.constructor === Object); }    function z1462(b111) {     return Object.assign(Object.create(Object.getPrototypeOf(b111)), b111); }    function k1463(b111) {     return JSON.parse(JSON.stringify(b111)); }    function q1464(array) {     return array.filter((value, index) =>          array.indexOf(value) === index); }    function v1465(element) {     const svg = document.createElementNS("http://www.w3.org/2000/svg", element);
    svg.style.pointerEvents = 'none';     return svg; }    function m4112(element) {      return element.style.visibility == 'visible';  }    function n1466(array, item) {     return array.indexOf(item) == array.length-1; }    function u1467(parent)  {     while (parent.firstChild)         parent.removeChild(parent.firstChild); }             function t1468(data) {     let str = '';      for (let i = 0; i < data.length; i++)         str += String.fromCharCode(data[si]);      return str; }           function log(...params) {     setTimeout(console.log.bind(console, ...params));  }    function r1469() {     setTimeout(console.trace.bind(console)); }    function v1470(num) {     return !isNaN(num) ? num : m962; }    function h1471(str) {     return str == m962          ? Number.NaN           : parseFloat(str); }    function f1472(strBool) {     return strBool == 'true'; }    function c1473(str)  {     if (typeof str != 'string')          return false;       if (str == 'NaN')          return true;      return !isNaN(str)          && !isNaN(parseFloat(str));  }    function y1474(elem) {     void(elem.offsetHeight); }   function readonly(target, name, descriptor) {     descriptor.writable = false;     return descriptor; }    function b1475     (plus = true) { return i1455 ? ('⌘' + (plus ? ' ' : '')) : ('Ctrl'  + (plus ? '+' : '')); } function u1476      (plus = true) { return i1455 ? ('⌥' + (plus ? ' ' : '')) : ('Alt'   + (plus ? '+' : '')); } function l1477    (plus = true) { return i1455 ? ('⇧' + (plus ? ' ' : '')) : ('Shift' + (plus ? '+' : '')); } function c1478(plus = true) { return i1455 ? l1477(plus) + b1475(plus) : b1475(plus) + l1477(plus); }    function p1480(type, g4327, options = {}) {     return options.insert      === true         && options.m3510 !== true         ? new n3(type, g4327, options)         : new h4      (type, g4327, options, options.m3510 === true); }    function u1481(x) {     return (x * 2654435761 % Math.pow(2, 32)) / Math.pow(2, 32); }    function x1482(o1483, s1484, id = o1483, join = '', startNum = 2, addZero = false) {     if (   addZero         && (    id.length == 0             || !g1000(id.at(-1)))         && s1484(id) > 1)         id += '0';       if (s1484(id) == 0)         return id;           let numLength = v1485(id);      if (numLength > 0)     {         const len = id.length - numLength;         let   num = parseInt(id.substring(len));          let n4331 = NULL;         while (n4331 == NULL || s1484(n4331) > 0)             n4331 = id.substring(0, len + join.length) + join + (++num);          return n4331;     }      else if (numLength == 0)     {         let num   = startNum;         let n4331 = id + join + num;          while (s1484(n4331) > 0)             n4331 = id + join + (++num);          return n4331;     }      else         return id; }    function v1485(name) {     let numLength = 0;      for (let i = name.length - 1; i >= 0; i--)     {         if (g1000(name[i])) numLength++;         else break;     }      return numLength; }    function j1486(str)  {     return /^-?\d*\.?\d*(e-?\d+)?$/.test(str); }    function d1487(control, family, size, align = 'left') {     control.style.fontFamily = family;     control.style.fontSize   = size + 'px';     control.style.textAlign  = align; }    function k1488(month, year) {     if (month == 2)     {         return year % 4 != 0              ? 28              : 29;     }     else if (month == 4           || month == 7           || month == 9           || month == 11)         return 30;     else         return 31; }    function getFontStyles(fontName) {     let fonts = a4132.filter(f => f.fontName.family == fontName);       fonts.sort((a, b) =>     {         if (a.fontName.style != b.fontName.style)             return y1393.findIndex(w => w[0] == a.fontName.style.toLowerCase())                  - y1393.findIndex(w => w[0] == b.fontName.style.toLowerCase());          return 0;     });           return fonts.map(f => f.fontName.style); }    const escapeReplacements =  {     '0' : '\0',     'b' : '\b',     'f' : '\f',     'n' : '\n',     'r' : '\r',     't' : '\t',     'v' : '\v',     '\\': '\\',     "'" : "'",     '"' : '"',     '`' : '`' };    function q1489(str)  {     return str.replace(         /\\(u\{([0-9a-fA-F]+)\}|u([0-9a-fA-F]{4})|x([0-9a-fA-F]{2})|([0bfnrtv\\'"`]))/g,          (match, p1, p2, p3, p4, p5) =>          {                  if (p2 !== undefined) return String.fromCodePoint(parseInt(p2, 16));              else if (p3 !== undefined) return String.fromCharCode (parseInt(p3, 16));              else if (p4 !== undefined) return String.fromCharCode (parseInt(p4, 16));              else if (p5 !== undefined) return escapeReplacements[p5] || match;                     else                 return match;         }); }    const unescapeReplacements =  {     '\0': '\\0',     '\b': '\\b',     '\f': '\\f',     '\n': '\\n',     '\r': '\\r',     '\t': '\\t',     '\v': '\\v',     '\\': '\\\\',     "'" : "\\'",     '"' : '\\"',     '`' : '\\`' };      function unescapeString(str)  {     return str         .replace(/[\0\b\f\n\r\t\v\\'"`]/g, (char) => unescapeReplacements[char] || char)         .replace(/([\u0000-\u001F\u007F-\uFFFF])/g, (char) =>          {                                const code = char.codePointAt(0);                   if (code <= 0xFF  ) return '\\x'  + code.toString(16).padStart(2, '0');             else if (code <= 0xFFFF) return '\\u'  + code.toString(16).padStart(4, '0');             else                     return '\\u{' + code.toString(16) + '}';         }); }    function unescapeRegexPattern(str) {     return str.replace(/\\([\\.*+?^${}()|\[\]])/g, '$1'); }    function unescapeRegexReplacement(str) {     return str.replace(/\\([\\$&`'])/g, '$1'); }       //     // implementation taken from http://blog.softwx.net/2014/12/optimizing-levenshtein-algorithm-in-c.html
                                                                                                                   function c1490(str1, str2)  {               const len1 = str1.length;     const len2 = str2.length;     const dist = [];                 for (let i = 0; i <= len1; i++) dist[i]    = [i];     for (let j = 1; j <= len2; j++) dist[0][j] =  j;                     for (let i = 1; i <= len1; i++)      {         for (let j = 1; j <= len2; j++)          {             const cost = str1[i-1] === str2[j-1] ? 0 : 1;              dist[i][j] = Math.min(                 dist[i-1][j  ] + 1,                      dist[i  ][j-1] + 1,                      dist[i-1][j-1] + cost);                              if (   i > 1                  && j > 1                  && str1[i-1] === str2[j-2]                  && str1[i-2] === str2[j-1])                 dist[i][j] = Math.min(dist[i][j], dist[i-2][j-2] + cost);          }     }           return dist[len1][len2]; }    function r1491(count) {     for (let i = 0; i < count; i++)          Math.random(); }    function h1492(str, sub, levenshteinDistance) {     if (sub.length > str.length)         return false;          if (str.includes(sub))         return true;          for (let i = 0; i <= str.length - sub.length; i++)      {         const s = str.substring(i, i + sub.length);                  if (c1490(sub, s) <= levenshteinDistance)             return true;     } }    function degamma(rgb, cs = q36) {     return [ cs.degamma(rgb[0]),              cs.degamma(rgb[1]),              cs.degamma(rgb[2]) ]; }    function regamma(rgb, cs = q36) {     return [ cs.regamma(rgb[0]),              cs.regamma(rgb[1]),              cs.regamma(rgb[2]) ]; }    String.prototype.replaceAt = function(index, replacement)  {     return this.substring(0, index)           + replacement           + this.substring(index+1); };    function r1493(array, condition) {     const items   = array.filter(condition);     const indices = [];          for (const item of items)         indices.push(items.indexOf(item));      return indices; }    function u1494(length) {     const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'.split('');      let str = '';      for (let i = 0; i < length; i++)         str += letters[Math.floor(Math.random() * letters.length)];      return str; }    function b1495(rect) {     return '{'               + rect.width         + ', '   + rect.height         + '}'; }    function a1496(str, _what, _with) {     var lastIndex = str.lastIndexOf(_what);      if (lastIndex === -1)          return str;      return str.substring(0, lastIndex) + _with + str.substring(lastIndex + _what.length); }    function s1497(x, y) {     const unders = document.elementsFromPoint(x, y)         .filter(el =>                 el.node             && el.className == 'nodeLabelWrapper');      unders.reverse();      return unders.length > 0           ? unders[0]          : null; }    function measureHtmlText(text, font, fontSize) {     divTextMeasure.style.font = fontSize + 'px \'' + font + '\'';     divTextMeasure.innerHTML = text;              return n993(divTextMeasure); }    function strline(tab, string = '', firstLine = false) {     return (firstLine ? '' : '\n')          + '\t'.repeat(tab)           + string; }   function currentUserIsDev() {     return devUsers.includes(currentUser.id); }    function parseIndexRanges(str) {     let indices = [];       const _indices = str.split(',');           if (_indices.length > 1)     {         for (const index of _indices)         {             if (index.includes('-'))             {                 const parts = index.split('-');                  if (parts.length == 2)                 {                     let start = parseInt(parts[0]);                     let end   = parseInt(parts[1]);                      if (   !isNaN(start)                         && !isNaN(end  ))                     {                         for (let i = start; i <= end; i++)                             indices.push(i);                     }                 }             }             else                 indices.push(parseInt(index));         }     }     else         indices.push(parseInt(iteration.value));       return indices; }    function f869(nTabs) {     return '\t'.repeat(nTabs); }


                                                                                     


"use strict";   // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding
    function d847(c)  {     return    c > 64             && c < 91             ? c - 65             :    c > 96               && c < 123               ? c - 71              :    c > 47                 && c < 58                 ? c + 4                : c === 43                   ? 62                  : c === 47 ? 63 : 0; }    function b848(str, blocksSize)  {     const base64 = str.replace(/[^A-Za-z0-9\+\/]/g, "");     const inLen  = base64.length;      const outLen =          blocksSize          ? Math.ceil((inLen * 3 + 1 >> 2) / blocksSize) * blocksSize          : inLen * 3 + 1 >> 2;              const bytes = new Uint8Array(outLen);      for (let mod3,               mod4,               uint24 = 0,               out    = 0,          i = 0;          i < inLen;          i++)      {         mod4 = i & 3;         uint24 |= d847(base64.charCodeAt(i)) << 6 * (3 - mod4);          if (   mod4 === 3              || inLen - i === 1)          {             for (mod3 = 0; mod3 < 3 && out < outLen; mod3++, out++)                  bytes[out] = uint24 >>> (16 >>> mod3 & 24) & 255;              uint24 = 0;         }     }      return bytes; }      function k849(i)  {     return i < 26             ? i + 65            : i < 52               ? i + 71              : i < 62                 ? i - 4                : i === 62                   ? 43                  : i === 63 ? 47 : 65; }    function h850(bytes) {     let mod3   = 2,          base64 = "";      const length = bytes.length;      for (let i = 0, uint24 = 0; i < length; i++)      {         mod3 = i % 3;          if (i > 0 && (i * 4 / 3) % 76 === 0)              base64 += "\r\n";          uint24 |= bytes[i] << (16 >>> mod3 & 24);          if (   mod3 === 2              || bytes.length - i === 1)          {             base64 += String.fromCharCode(                 k849(uint24 >>> 18 & 0x3F),                  k849(uint24 >>> 12 & 0x3F),                  k849(uint24 >>>  6 & 0x3F),                  k849(uint24        & 0x3F));                              uint24 = 0;         }     }      return base64.substring(0, base64.length - 2 + mod3) + (mod3 === 2 ? '' : mod3 === 1 ? '=' : '=='); }      function utf8ArrToStr(bytes)  {     let   str    = "";      const length = bytes.length;      for (let i = 0; i < length; i++)      {         const byte = bytes[i];          str += String.fromCharCode(                byte > 251              && byte < 254              && i + 5 < length              ? (byte - 252) * 1073741824 + (bytes[++i] - 128 << 24) + (bytes[++i] - 128 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128             :    byte > 247                && byte < 252                && i + 4 < length                ? (byte - 248 << 24) + (bytes[++i] - 128 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128               :    byte > 239                  && byte < 248                  && i + 3 < length                  ? (byte - 240 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128                 :    byte > 223                    && byte < 240                    && i + 2 < length                    ? (byte - 224 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128                   :    byte > 191                      && byte < 224                      && i + 1 < length                      ? (byte - 192 << 6) + bytes[++i] - 128                       : byte);     }      return str; }    function strToUtf8Arr(str)  {     let strLen = str.length,          arrLen = 0;             for (let i = 0; i < strLen; i++)      {         const chr = str.charCodeAt(i);         arrLen += chr < 0x80 ? 1 : chr < 0x800 ? 2 : chr < 0x10000 ? 3 : chr < 0x200000 ? 4 : chr < 0x4000000 ? 5 : 6;     }      const bytes = new Uint8Array(arrLen);             for (let i = 0, iChr = 0; i < arrLen; iChr++)      {         const chr = str.charCodeAt(iChr);               if (chr < 0x80)          {             bytes[i++] = chr;         }          else if (chr < 0x800)          {             bytes[i++] = 192 + (chr >>> 6);             bytes[i++] = 128 + (chr        & 0x3F);         }          else if (chr < 0x10000)          {             bytes[i++] = 224 + (chr >>> 12);             bytes[i++] = 128 + (chr >>>  6 & 0x3F);             bytes[i++] = 128 + (chr        & 0x3F);         }         else if (chr < 0x200000)          {             bytes[i++] = 240 + (chr >>> 18);             bytes[i++] = 128 + (chr >>> 12 & 0x3F);             bytes[i++] = 128 + (chr >>>  6 & 0x3F);             bytes[i++] = 128 + (chr        & 0x3F);         }          else if (chr < 0x4000000)          {             bytes[i++] = 248 + (chr >>> 24);             bytes[i++] = 128 + (chr >>> 18 & 0x3F);             bytes[i++] = 128 + (chr >>> 12 & 0x3F);             bytes[i++] = 128 + (chr >>>  6 & 0x3F);             bytes[i++] = 128 + (chr        & 0x3F);         }          else          {             bytes[i++] = 252 + (chr >>> 30);             bytes[i++] = 128 + (chr >>> 24 & 0x3F);             bytes[i++] = 128 + (chr >>> 18 & 0x3F);             bytes[i++] = 128 + (chr >>> 12 & 0x3F);             bytes[i++] = 128 + (chr >>>  6 & 0x3F);             bytes[i++] = 128 + (chr        & 0x3F);         }     }       return bytes; }


function position(e) {     return point(e.clientX, e.clientY); }    function y1499(b111, style) {     return window.getComputedStyle(b111).getPropertyValue(style); }    function g1500(e) {     return i1455 ? e.metaKey : e.ctrlKey;           }    function r1501(target, proto) {     target.dispatchEvent(new proto.constructor(proto.type, proto)); }    function b1502(className = '', id = '') {     const div = document.createElement('div');          if (className != '')         div.className = className;          if (id != '')         div.id = id;      return div; }    function v1503(div, to) {     if (!to.contains(div))         to.appendChild(div); }    function n1504(div, from) {     if (from.contains(div))         from.removeChild(div); }    function r1505(className = '') {     const textbox = document.createElement('INPUT');     textbox.setAttribute('type', 'text');       if (className.trim() != '')         textbox.className = className;          return textbox; }    function s1506(className = '') {     const textarea = document.createElement('textarea');      if (className.trim() != '')         textarea.className = className;          textarea.spellcheck = false;          return textarea; }    function createCanvas(className = '') {     const canvas = document.createElement('canvas');      if (className.trim() != '')         canvas.className = className;          return canvas; }    function g1507(elem, enable, noItalic = false, bold = true) {     elem.style.fontStyle  = enable || noItalic ? 'normal' : 'italic';       if (bold)         elem.style.fontWeight = enable || noItalic ? 'normal' : 'bold'; }    function hasFocus(elem) {     return elem == document.activeElement; }    function c1508(id, properties) {     const elem = document.getElementById(id);      for (const property of properties)         elem.style[property] = properties[property]; }    function c1509(parent, child) {     return child.parentNode == parent; }    function o1510(event, element) {     const e = new event.constructor(event.type, event);     element.dispatchEvent(e); }    function offsetRect(element) {     return new j1045(         element.offsetLeft,         element.offsetTop,         element.offsetWidth,         element.offsetHeight); }    function clientRect(element) {     return new j1045(         element.clientLeft,         element.clientTop,         element.clientWidth,         element.clientHeight); }                  function f1511(elementId) {     if (document.selection)      {         var range = document.body.createTextRange();         range.moveToElementText(document.getElementById(elementId));         range.select();     }     else if (window.getSelection)      {         var range = document.createRange();         range.selectNode(document.getElementById(elementId));         window.getSelection().removeAllRanges();         window.getSelection().addRange(range);     } }    function w1512(e) {     return Math.abs(e.deltaX) < 100         && Math.abs(e.deltaY) < 100; }    function m1513(element, show = true)  {     const showStyle = 'block';     const hideStyle = 'none';      if (  !show         && element.style.display != hideStyle)         element.oldDisplay = element.style.display;      element.style.display =          show          ? (   element.style.oldDisplay             && element.style.oldDisplay != hideStyle            ? element.style.oldDsplay            : showStyle)         : hideStyle;  }   function e1514(element)               {      m1513(element, false);  }    function m4112(element) {     return element.offsetParent !== null; }    function m1515(element)  {      if (   element.tagName === 'TEXTAREA'          || (   element.tagName === 'INPUT'              && element.type === 'text'))      {         return element.value.substring(             element.selectionStart,             element.selectionEnd);     } }    function q1516(element) {     if (   element.tagName === 'TEXTAREA'          || (   element.tagName === 'INPUT'              && element.type === 'text'))      {         const str = element.value;          element.value =                str.slice(0, element.selectionStart)              + str.slice(element.selectionEnd)     } }    function scrollbarVisible(element)  {     return element.b3227 > element.clientHeight; }    function k1517(e) {     return point(e.clientX, e.clientY); }    function r1518(div) {     const selection = window.getSelection();      if (selection.rangeCount > 0)      {         const range = selection.getRangeAt(0);                  if (   range.commonAncestorContainer === div             || div.contains(range.commonAncestorContainer))         {             const selectedText = range.toString().trim();              if (selectedText.length > 0)                 return true;         }     }      return false;  }    function v1519(div) {     var range = document.createRange();     range.selectNode(div);      window.getSelection().removeAllRanges();     window.getSelection().addRange(range);     }    function selectTextareaText(textarea) {                textarea.select();      if (textarea.control)         textarea.control.disableAfterSelectAll = disabled;      textarea.style.cursor = 'default';           }    function m1520(callback) {     const input = document.createElement('input');      input.type   = 'file';     input.accept = '.gen';          input.onchange = e =>      {          const file = e.target.files[0];           const reader = new FileReader();         reader.readAsText(file,'UTF-8');          reader.onload = e => callback(e.target.result);     };       input.click(); }    function k1521(callback) {     const input = document.createElement('input');      input.type   = 'file';     input.accept = '*.*';          input.onchange = e =>      {          callback(e.target.files[0]);      };       input.click(); }    async function j1522(content, filename, contentType) {     const a    = document.createElement('a');     const file = new Blob([content], {type: contentType});      a.download = filename;     a.href     = URL.createObjectURL(file);      a.click();      await new Promise(resolve => setTimeout(resolve, 500));          URL.revokeObjectURL(a.href); }


                                                                                                                                                          const f1498 =  [     {name: 'AliceBlue',            color: [0.941, 0.973, 1.000]},     {name: 'AntiqueWhite',         color: [0.980, 0.922, 0.843]},     {name: 'Aqua',                 color: [0.000, 1.000, 1.000]},     {name: 'Aquamarine',           color: [0.498, 1.000, 0.831]},     {name: 'Azure',                color: [0.941, 1.000, 1.000]},     {name: 'Beige',                color: [0.961, 0.961, 0.863]},     {name: 'Bisque',               color: [1.000, 0.894, 0.769]},     {name: 'Black',                color: [0.000, 0.000, 0.000]},     {name: 'BlanchedAlmond',       color: [1.000, 0.922, 0.804]},     {name: 'Blue',                 color: [0.000, 0.000, 1.000]},     {name: 'BlueViolet',           color: [0.541, 0.169, 0.886]},     {name: 'Brown',                color: [0.647, 0.165, 0.165]},     {name: 'BurlyWood',            color: [0.871, 0.722, 0.529]},     {name: 'CadetBlue',            color: [0.373, 0.620, 0.627]},     {name: 'Chartreuse',           color: [0.498, 1.000, 0.000]},     {name: 'Chocolate',            color: [0.824, 0.412, 0.118]},     {name: 'Coral',                color: [1.000, 0.498, 0.314]},     {name: 'CornflowerBlue',       color: [0.392, 0.584, 0.929]},     {name: 'Cornsilk',             color: [1.000, 0.973, 0.863]},     {name: 'Crimson',              color: [0.863, 0.078, 0.235]},     {name: 'Cyan',                 color: [0.000, 1.000, 1.000]},     {name: 'DarkBlue',             color: [0.000, 0.000, 0.545]},     {name: 'DarkCyan',             color: [0.000, 0.545, 0.545]},     {name: 'DarkGoldenRod',        color: [0.722, 0.525, 0.043]},     {name: 'DarkGray',             color: [0.663, 0.663, 0.663]},     {name: 'DarkGrey',             color: [0.663, 0.663, 0.663]},     {name: 'DarkGreen',            color: [0.000, 0.392, 0.000]},     {name: 'DarkKhaki',            color: [0.741, 0.718, 0.420]},     {name: 'DarkMagenta',          color: [0.545, 0.000, 0.545]},     {name: 'DarkOliveGreen',       color: [0.333, 0.420, 0.184]},     {name: 'DarkOrange',           color: [1.000, 0.549, 0.000]},     {name: 'DarkOrchid',           color: [0.600, 0.196, 0.800]},     {name: 'DarkRed',              color: [0.545, 0.000, 0.000]},     {name: 'DarkSalmon',           color: [0.914, 0.588, 0.478]},     {name: 'DarkSeaGreen',         color: [0.561, 0.737, 0.561]},     {name: 'DarkSlateBlue',        color: [0.282, 0.239, 0.545]},     {name: 'DarkSlateGray',        color: [0.184, 0.310, 0.310]},     {name: 'DarkSlateGrey',        color: [0.184, 0.310, 0.310]},     {name: 'DarkTurquoise',        color: [0.000, 0.808, 0.820]},     {name: 'DarkViolet',           color: [0.580, 0.000, 0.827]},     {name: 'DeepPink',             color: [1.000, 0.078, 0.576]},     {name: 'DeepSkyBlue',          color: [0.000, 0.749, 1.000]},     {name: 'DimGray',              color: [0.412, 0.412, 0.412]},     {name: 'DimGrey',              color: [0.412, 0.412, 0.412]},     {name: 'DodgerBlue',           color: [0.118, 0.565, 1.000]},     {name: 'FireBrick',            color: [0.698, 0.133, 0.133]},     {name: 'FloralWhite',          color: [1.000, 0.980, 0.941]},     {name: 'ForestGreen',          color: [0.133, 0.545, 0.133]},     {name: 'Fuchsia',              color: [1.000, 0.000, 1.000]},     {name: 'Gainsboro',            color: [0.863, 0.863, 0.863]},     {name: 'GhostWhite',           color: [0.973, 0.973, 1.000]},     {name: 'Gold',                 color: [1.000, 0.843, 0.000]},     {name: 'GoldenRod',            color: [0.855, 0.647, 0.125]},     {name: 'Gray',                 color: [0.502, 0.502, 0.502]},     {name: 'Grey',                 color: [0.502, 0.502, 0.502]},     {name: 'Green',                color: [0.000, 0.502, 0.000]},     {name: 'GreenYellow',          color: [0.678, 1.000, 0.184]},     {name: 'HoneyDew',             color: [0.941, 1.000, 0.941]},     {name: 'HotPink',              color: [1.000, 0.412, 0.706]},     {name: 'IndianRed',            color: [0.804, 0.361, 0.361]},     {name: 'Indigo',               color: [0.294, 0.000, 0.510]},     {name: 'Ivory',                color: [1.000, 1.000, 0.941]},     {name: 'Khaki',                color: [0.941, 0.902, 0.549]},     {name: 'Lavender',             color: [0.902, 0.902, 0.980]},     {name: 'LavenderBlush',        color: [1.000, 0.941, 0.961]},     {name: 'LawnGreen',            color: [0.486, 0.988, 0.000]},     {name: 'LemonChiffon',         color: [1.000, 0.980, 0.804]},     {name: 'LightBlue',            color: [0.678, 0.847, 0.902]},     {name: 'LightCoral',           color: [0.941, 0.502, 0.502]},     {name: 'LightCyan',            color: [0.878, 1.000, 1.000]},     {name: 'LightGoldenRodYellow', color: [0.980, 0.980, 0.824]},     {name: 'LightGray',            color: [0.827, 0.827, 0.827]},     {name: 'LightGrey',            color: [0.827, 0.827, 0.827]},     {name: 'LightGreen',           color: [0.565, 0.933, 0.565]},     {name: 'LightPink',            color: [1.000, 0.714, 0.757]},     {name: 'LightSalmon',          color: [1.000, 0.627, 0.478]},     {name: 'LightSeaGreen',        color: [0.125, 0.698, 0.667]},     {name: 'LightSkyBlue',         color: [0.529, 0.808, 0.980]},     {name: 'LightSlateGray',       color: [0.467, 0.533, 0.600]},     {name: 'LightSlateGrey',       color: [0.467, 0.533, 0.600]},     {name: 'LightSteelBlue',       color: [0.690, 0.769, 0.871]},     {name: 'LightYellow',          color: [1.000, 1.000, 0.878]},     {name: 'Lime',                 color: [0.000, 1.000, 0.000]},     {name: 'LimeGreen',            color: [0.196, 0.804, 0.196]},     {name: 'Linen',                color: [0.980, 0.941, 0.902]},     {name: 'Magenta',              color: [1.000, 0.000, 1.000]},     {name: 'Maroon',               color: [0.502, 0.000, 0.000]},     {name: 'MediumAquaMarine',     color: [0.400, 0.804, 0.667]},     {name: 'MediumBlue',           color: [0.000, 0.000, 0.804]},     {name: 'MediumOrchid',         color: [0.729, 0.333, 0.827]},     {name: 'MediumPurple',         color: [0.576, 0.439, 0.859]},     {name: 'MediumSeaGreen',       color: [0.235, 0.702, 0.443]},     {name: 'MediumSlateBlue',      color: [0.482, 0.408, 0.933]},     {name: 'MediumSpringGreen',    color: [0.000, 0.980, 0.604]},     {name: 'MediumTurquoise',      color: [0.282, 0.820, 0.800]},     {name: 'MediumVioletRed',      color: [0.780, 0.082, 0.522]},     {name: 'MidnightBlue',         color: [0.098, 0.098, 0.439]},     {name: 'MintCream',            color: [0.961, 1.000, 0.980]},     {name: 'MistyRose',            color: [1.000, 0.894, 0.882]},     {name: 'Moccasin',             color: [1.000, 0.894, 0.706]},     {name: 'NavajoWhite',          color: [1.000, 0.871, 0.678]},     {name: 'Navy',                 color: [0.000, 0.000, 0.502]},     {name: 'OldLace',              color: [0.992, 0.957, 0.902]},     {name: 'Olive',                color: [0.502, 0.502, 0.000]},     {name: 'OliveDrab',            color: [0.420, 0.557, 0.137]},     {name: 'Orange',               color: [1.000, 0.647, 0.000]},     {name: 'OrangeRed',            color: [1.000, 0.271, 0.000]},     {name: 'Orchid',               color: [0.855, 0.439, 0.839]},     {name: 'PaleGoldenRod',        color: [0.933, 0.910, 0.667]},     {name: 'PaleGreen',            color: [0.596, 0.984, 0.596]},     {name: 'PaleTurquoise',        color: [0.686, 0.933, 0.933]},     {name: 'PaleVioletRed',        color: [0.859, 0.439, 0.576]},     {name: 'PapayaWhip',           color: [1.000, 0.937, 0.835]},     {name: 'PeachPuff',            color: [1.000, 0.855, 0.725]},     {name: 'Peru',                 color: [0.804, 0.522, 0.247]},     {name: 'Pink',                 color: [1.000, 0.753, 0.796]},     {name: 'Plum',                 color: [0.867, 0.627, 0.867]},     {name: 'PowderBlue',           color: [0.690, 0.878, 0.902]},     {name: 'Purple',               color: [0.502, 0.000, 0.502]},     {name: 'RebeccaPurple',        color: [0.400, 0.200, 0.600]},     {name: 'Red',                  color: [1.000, 0.000, 0.000]},     {name: 'RosyBrown',            color: [0.737, 0.561, 0.561]},     {name: 'RoyalBlue',            color: [0.255, 0.412, 0.882]},     {name: 'SaddleBrown',          color: [0.545, 0.271, 0.075]},     {name: 'Salmon',               color: [0.980, 0.502, 0.447]},     {name: 'SandyBrown',           color: [0.957, 0.643, 0.376]},     {name: 'SeaGreen',             color: [0.180, 0.545, 0.341]},     {name: 'SeaShell',             color: [1.000, 0.961, 0.933]},     {name: 'Sienna',               color: [0.627, 0.322, 0.176]},     {name: 'Silver',               color: [0.753, 0.753, 0.753]},     {name: 'SkyBlue',              color: [0.529, 0.808, 0.922]},     {name: 'SlateBlue',            color: [0.416, 0.353, 0.804]},     {name: 'SlateGray',            color: [0.439, 0.502, 0.565]},     {name: 'SlateGrey',            color: [0.439, 0.502, 0.565]},     {name: 'Snow',                 color: [1.000, 0.980, 0.980]},     {name: 'SpringGreen',          color: [0.000, 1.000, 0.498]},     {name: 'SteelBlue',            color: [0.275, 0.510, 0.706]},     {name: 'Tan',                  color: [0.824, 0.706, 0.549]},     {name: 'Teal',                 color: [0.000, 0.502, 0.502]},     {name: 'Thistle',              color: [0.847, 0.749, 0.847]},     {name: 'Tomato',               color: [1.000, 0.388, 0.278]},     {name: 'Turquoise',            color: [0.251, 0.878, 0.816]},     {name: 'Violet',               color: [0.933, 0.510, 0.933]},     {name: 'Wheat',                color: [0.961, 0.871, 0.702]},     {name: 'White',                color: [1.000, 1.000, 1.000]},     {name: 'WhiteSmoke',           color: [0.961, 0.961, 0.961]},     {name: 'Yellow',               color: [1.000, 1.000, 0.000]},     {name: 'YellowGreen',          color: [0.604, 0.804, 0.196]} ];    const genColorNameLightness = [     {name: 'pale',   value: 0.87},     {name: 'light',  value: 0.76},     {name: 'bright', value: 0.65},     {name: 'deep',   value: 0.35},     {name: 'dim',    value: 0.22},     {name: 'dark',   value: 0.12} ];    const genColorNameSaturation = [     {name: 'calm',  value: 0.72},     {name: 'dull',  value: 0.46},     {name: 'dirty', value: 0.21} ];    const genColorNameHue = [     {name: 'violet',  value: 285},     {name: 'purple',  value: 269},     {name: 'indigo',  value: 252},     {name: 'blue',    value: 241},     {name: 'cobalt',  value: 222},     {name: 'sky',     value: 211},     {name: 'aqua',    value: 193},     {name: 'cyan',    value: 177},     {name: 'jade',    value: 154},     {name: 'green',   value: 112},     {name: 'lime',    value:  74},     {name: 'yellow',  value:  54},     {name: 'mango',   value:  42},     {name: 'orange',  value:  30},     {name: 'amber',   value:  17},     {name: 'salmon',  value:  11},     {name: 'red',     value:   0},     {name: 'rose',    value: 335},     {name: 'magenta', value: 310} ];    function getClosestHtmlName(rgb) {     let dist  = Number.MAX_SAFE_INTEGER;     let index = -1;      for (let i = 0; i < f1498.length; i++)     {         const dE = deltaE(f1498[i].color, rgb);          if (dE < dist)         {             dist  = dE;             index = i;         }     }       if (index > -1)         return f1498[index].name;       console.error('cannot find HTML color name for \'' + z151(rgb) + '\'');     return ''; }    function parseColorName(name) {     name = name.trim();       if (name == '?')         return rgb_NaN;      else if (name == 'rnd'           || name == 'random'           || c1490(name, 'random') <= 1)     {         r1491(Date.now() % 10);  const r = Math.random();         r1491(Date.now() % 10);  const g = Math.random();         r1491(Date.now() % 10);  const b = Math.random();          return [r, g, b];     }     else     {         if (settings.preferHtmlColorNames)         {                        let webColor = f1498.find(wc => wc.name.toLowerCase() == name);             if (!webColor) webColor = f1498.find(wc => c1490(wc.name.toLowerCase(), name) <= 1);                          return webColor                 ? webColor.color                 : t155(name);         }         else         {             const hsl = parseStructuredColorName(name);              return hsl                  ? x50(hsl)                  : f153(name);         }     } }    function parseStructuredColorNameLightness(name)  {     for (const item of genColorNameLightness)      {         if (   name.startsWith(item.name)              ||     c1490(name.slice(0, item.name.length), item.name) <= 1                && !genColorNameHue.find(h => h.name.startsWith(name)))          {             return { value:     item.value,                       remaining: name.slice(item.name.length) };         }     }      return { value:     null,               remaining: name }; }    function parseStructuredColorNameSaturation(name)  {     for (const item of genColorNameSaturation)      {         if (   name.startsWith(item.name)              ||     c1490(name.slice(0, item.name.length), item.name) <= 1                && !genColorNameHue.find(h => h.name.startsWith(name)))          {             return { value:     item.value,                       remaining: name.slice(item.name.length) };         }     }      return { value:     null,               remaining: name }; }    function parseStructuredColorNameHue(name)  {     for (const item of genColorNameHue)      {         if (   name === item.name              || c1490(name.slice(0, item.name.length), item.name) <= 1)          {             return item.value;         }     }      return null; }    function parseStructuredColorName(_colorName)  {     let colorName = _colorName.replace(/\s+/g, '');       if (   colorName === 'black'          || c1490(colorName, 'black') <= 1)         return [0, 0, 0];      if (   colorName === 'white'          || c1490(colorName, 'white') <= 1)         return [0, 0, 1];               const grayVariants = ['gray', 'grey'];      let isGray = false;     let gl     = 0.5;      for (const grayVariant of grayVariants)      {         if (   colorName.endsWith(grayVariant)              || c1490(colorName.slice(-grayVariant.length), grayVariant) <= 1)          {             isGray = true;                      const grayPrefix = colorName.slice(0, -grayVariant.length);                          if (grayPrefix)              {                 const { value } = parseStructuredColorNameLightness(grayPrefix);                                  if (value !== null)                      gl = value;             }              break;         }     }       if (isGray)         return [0, 0, gl];       let h = null;     let s = null;     let l = null;                     let result  = parseStructuredColorNameLightness(colorName);         l       = result.value;     let remName = result.remaining;          result  = parseStructuredColorNameSaturation(remName);         s       = result.value;         remName = result.remaining;          h       = parseStructuredColorNameHue(remName);                      if (   h === null          || s === null          || l === null)      {         h = null;         s = null;         l = null;          result  = parseStructuredColorNameSaturation(colorName);         s       = result.value;         remName = result.remaining;          result  = parseStructuredColorNameLightness(remName);         l       = result.value;         remName = result.remaining;          h       = parseStructuredColorNameHue(remName);     }       if (h === null) return null;      if (l === null) l = 0.5;     if (s === null) s = 1.0;           return [h / 360, s, l]; }    function createColorName(rgba) {     if (rgba.length > 3 && rgba[3] == 0)         return 'transparent';       const hsl = u48(rgba);      let   h = hsl[0] * 360;      while (h >= 360) h -= 360;     while (h <    0) h += 360;          const s = hsl[1];     const l = hsl[2];            if (l >= 0.94) return 'white';     else if (l <  0.06) return 'black';       let strH = '';     let strS = '';     let strL = '';            if (l >= 0.81 && l < 0.94) strL = 'pale ';     else if (l >= 0.69 && l < 0.81) strL = 'light ';     else if (l >= 0.56 && l < 0.69) strL = 'bright ';     else if (l >= 0.31 && l < 0.44) strL = 'deep ';     else if (l >= 0.19 && l < 0.31) strL = 'dim ';     else if (l >= 0.06 && l < 0.19) strL = 'dark ';           if (l > 0.25 && l < 0.75)      {              if (s >= 0.62 && s < 0.88) strS = 'calm ';         else if (s >= 0.31 && s < 0.62) strS = 'dull ';         else if (s >= 0.12 && s < 0.31) strS = 'dirty ';     }       if (s >= 0.12)     {              if (h < 293 && h >= 278) strH = 'violet';         else if (h < 278 && h >= 259) strH = 'purple';         else if (h < 259 && h >= 248) strH = 'indigo';         else if (h < 248 && h >= 233) strH = 'blue';         else if (h < 233 && h >= 221) strH = 'cobalt';         else if (h < 221 && h >= 201) strH = 'sky';         else if (h < 201 && h >= 185) strH = 'aqua';         else if (h < 185 && h >= 169) strH = 'cyan';         else if (h < 169 && h >= 139) strH = 'jade';         else if (h < 139 && h >=  86) strH = 'green';         else if (h <  86 && h >=  63) strH = 'lime';         else if (h <  63 && h >=  45) strH = 'yellow';         else if (h <  45 && h >=  40) strH = 'mango';         else if (h <  40 && h >=  21) strH = 'orange';         else if (h <  21 && h >=  13) strH = 'amber';         else if (h <  13 && h >=   8) strH = 'salmon';         else if (h <   8 || h >= 352) strH = 'red';         else if (h < 352 && h >= 328) strH = 'rose';         else if (h < 328 && h >= 293) strH = 'magenta';         else              console.error('error parsing hue name');     }     else          strH = 'gray';       return strL + strS + strH; } 


var _clipboard = '';    function n864(str)  {     if (subscribed())     {         if (   navigator.clipboard              && window.isSecureContext)              return navigator.clipboard.writeText(str);          else          {             const prevActive = document.activeElement;             const textArea   = document.createElement('textarea');              textArea.value = str;              textArea.style.position = 'fixed';             textArea.style.left     = '-999999px';             textArea.style.top      = '-999999px';                          document.body.appendChild(textArea);                          textArea.focus();             textArea.select();                          return new Promise((res, rej) =>              {                 document.execCommand('copy') ? res() : rej();                 textArea.remove();                  prevActive.focus();             });         }     }     else         _clipboard = str; }    function h865()  {     if (subscribed())     {         if (   navigator.clipboard              && window.isSecureContext)              return navigator.clipboard.readText();          else          {             let textArea = document.createElement('textarea');              textArea.style.position = 'fixed';             textArea.style.left     = '-999999px';             textArea.style.top      = '-999999px';                          document.body.appendChild(textArea);                          textArea.focus({preventScroll: true});             textArea.select();                          return new Promise((res, rej) =>              {                 document.execCommand('paste') ? res(textArea.value) : rej();                 textArea.remove();             });         }     }     else         return new Promise((res, rej) => res(_clipboard)); }


function t1046(key, tag)  {     return key.substring(0, tag.length+1) == tag + ' '; }    function n1047(key, tag) {     return key.substring(tag.length+1); }    function j1048(key) { return t1046(key, e875) } function n1049(key) { return t1046(key, m873); } function y1050(key) { return t1046(key, c874); }    function z1051(key) { return n1047(key, e875); } function z1052(key) { return n1047(key, m873); } function a1053(key) { return n1047(key, c874); }


const g961               = '\uFFFD'; const m962            = '?';  const SEP                    = ' ';      const v963           = '?'; const s964        = v963;  const NAME_SEPARATOR         = ' '; const b965       = ' > '; const   o966       = ' / '; const  d967       = ':';  const o968          = ' •'; const  v969          = ' ◇';       const  q970    = '<svg width="13" height="11" viewBox="0 1 13 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.3645 1.82058L10.2676 0.599976L5.1191 8.58091L2.44314 6.06144L0.800003 7.67327L5.54161 12.1958L12.3645 1.82058Z" fill="#2AD400"/></svg>';
const z971    = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="#F43D3D"/></svg>';    
 const  f972     = '<svg width="12" height="11" viewBox="0 0 12 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M11.1 0.998457L9.41674 0L4.20109 8.01592L1.50123 5.4381L0.1 6.77599L4.52397 11L11.1 0.998457Z" fill="#3FF911"/></svg>';
const r973     = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="#FF3E3E"/></svg>';
 const  j974 = '<svg width="11" height="11" viewBox="0 0 11 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.7157 0.893364L9.55198 0.139526L4.15187 8.47598L1.20316 5.59262L0.248535 6.5928L4.41886 10.5815L5.04702 9.60025L10.7157 0.893364Z" fill="black"/></svg>';
const b975 = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.13479 0.1521L0.1521 1.13479L3.51727 4.49997L0.152106 7.86514L1.1348 8.84783L4.49997 5.48266L7.86511 8.8478L8.8478 7.86511L5.48266 4.49997L8.84781 1.13482L7.86511 0.152129L4.49997 3.51727L1.13479 0.1521Z" fill="black"/></svg>';
 const  i976  = '<svg width="12" height="11" viewBox="0 0 12 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M11.1 0.998457L9.41672 0L4.20107 8.01592L1.50121 5.4381L0.0999756 6.77599L4.52395 11L11.1 0.998457Z" fill="white"/></svg>';
const o977  = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="white"/></svg>';
 const  u978     = '<svg width="12" height="11" viewBox="0 0 12 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M11.1 0.998457L9.41675 0L4.2011 8.01592L1.50124 5.4381L0.100006 6.77599L4.52398 11L11.1 0.998457Z" fill="white"/></svg>';
const x979     = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="white"/></svg>';
   function j980(color = true) {     return g4102          ? (color ? f972  : i976 )          : (color ? q970 : j974); }    function n981(color = true) {     return g4102          ? (color ? r973  : o977 )          : (color ? z971 : b975); }


var showDebugInfo = false;  var debugFlag1    = false; var debugNodeId   = 'list2';     function m959(nodeIds) {     let str = '';      for (let i = 0; i < nodeIds.length; i++)     {         if (i > 0) str += ', ';         str += nodeIds[i];     }      return str; }    function a960(nodes) {     let str = '';      nodes.map(n => n ? n.id : 'undefined').join(', ');                                return str; }    function updateDebugInfo() {     if (showDebugInfo)     {         debugInfoText.style.display = 'inline-block';          debugInfoText.innerHTML =                         'pan = '  + graph.currentPage.pan.x.toFixed(2) + ', ' + graph.currentPage.pan.y.toFixed(2)             + '<br/>' + 'zoom = ' + graph.currentPage.zoom.toFixed(4);     }     else         debugInfoText.style.display = 'none'; }


const u1038   = 0,       w1039 = 1,       g1040 = 2,       r1041  = 3;    class v1042 {     initial;     current;            constructor()     {         this.reset();     }            set(seed)     {         this.initial = seed;         this.current = seed;     }                rotate()     {         this.current = (this.current + 0x7ed55d16) + (this.current << 12);         this.current = (this.current ^ 0xc761c23c) ^ (this.current >> 19);         this.current = (this.current + 0x165667b1) + (this.current <<  5);         this.current = (this.current + 0xd3a2646c) ^ (this.current <<  9);         this.current = (this.current + 0xfd7046c5) + (this.current <<  3);         this.current = (this.current ^ 0xb55a4f09) ^ (this.current >> 16);     }                next()     {         const seed = this.current;         this.rotate();         return seed;     }        reset()     {         this.current = this.initial;     } };    class Noise { 	interpolation = r1041; 	clip = false;  	seed = new v1042();  	v0; 	v1; 	v2; 	v3;  	step = 0;       constructor(seed = 0)     {         this.seed.set(seed);         this.reset();     }       next(scale = 1)     {                  scale = Math.max(1, scale);          let next = this.v1;          if (this.step >= 1)         {                                   this.seed.rotate();              this.v0 = this.v1;                      this.v1 = this.v2;             this.v2 = this.v3;                      this.v3 = y1043(this.seed.current);              this.step -= 1;         }                    switch (this.interpolation)         {             case u1038:             {                 next = this.v1;                 break;             }             case w1039:             {                 next = this.v1 + this.step * (this.v2 - this.v1);                 break;             }             case g1040:             {                 const ft = this.step * Math.PI;                 const f  = (1 - Math.cos(ft)) * 0.5;                                  next = this.v1 + f * (this.v2 - this.v1);                 break;             }             case r1041:             {                 const p = (this.v3 - this.v2) - (this.v0 - this.v1);                 const q = (this.v0 - this.v1) - p;                 const r =  this.v2 - this.v0;                 const s =  this.v1;                  const val =                        p * cube(this.step)                      + q * sqr(this.step)                      + r * this.step                      + s;                  next = this.clip                      ? Math.max(0, Math.min(val, 1))                      : val;                  break;             }         }          this.step += 1 / scale;          return next;     }          reset()     {         this.seed.reset();          this.v0 = y1043(this.seed.current); this.seed.rotate();         this.v1 = y1043(this.seed.current); this.seed.rotate();         this.v2 = y1043(this.seed.current); this.seed.rotate();         this.v3 = y1043(this.seed.current); this.seed.rotate();          this.step = 0;     } }   function y1043(x) {     return x / -0x7fffffff; }


const settings = {     debugMode:                     false,              x2592:         false,     f2598:              0.35,     objectCenterSize:              18,     objectBatchSize:               500,     maxSolveIterations:            100,     numberVarNullValue:            0,     boolVarNullValue:              false,     stringVarNullValue:            '',     colorVarNullValue:             [1, 0, 1],     showPages:                     false,     showAllColorSpaces:            false,     showNodeIcons:                 true,     showBoolValues:                true,     separateThousands:             true,     allowInvertParams:             true,     activateDeactiatesOthers:      true,     preferHtmlColorNames:          true,     randomShiftR:                  true,     colorShiftR:                   false,     numberShiftR:                  false,      showSnapshots:                 false,     showRestartInfo:               true,     showColorLegendInMenus:        false,     showClearUndoWarning:          true,     shareUsageMetrics:             true,     showObjectCount:               true,     showDebugMenu:                 false,              showNodeId:                    false,      y2599:           false,     enableAsserts:                 false,      showTooltipNodes:              true,     showTooltipParams:             true,     showTooltipLists:              false,     showTooltipLongText:           false,     showTooltipColorInterpolation: true,     showTooltipValidateMethod:     true,     showTooltipColorBlindness:     true,     showTooltipColorContrast:      true,     showTooltipColorNames:         true,     showTooltipAscii:              true,      enableBetaFeatures:            false,                  logThreadMessages:             false,     logDataMessages:               false,     logMessages:                   false,      logActions:                    false,                   logLoading:                    false,      logRequests:                   false,      logValueUpdates:               false,      logObjectUpdates:              false,     logStyleUpdates:               false,                  logRawLoadPages:               false,      logRawLoadNodes:               false,      logRawLoadConnections:         false,               logRawSavePages:               false,      logRawSaveNodes:               false,      logRawSaveConnections:         false,               logRawRequests:                false,      logRawValues:                  false,      sessionId:                     '' };    function l3688(f3756, value) {     switch (f3756)     {         case 'debugMode':                     settings.debugMode                     = value;  break;                          case 'enableZoomedOutParams':         settings.x2592         = value;  break;         case 'minZoomForParams':              settings.f2598              = value;  break;         case 'objectCenterSize':              settings.objectCenterSize              = value;  break;         case 'objectBatchSize':               settings.objectBatchSize               = value;  break;         case 'maxSolveIterations':            settings.maxSolveIterations            = value;  break;         case 'numberVarNullValue':            settings.numberVarNullValue            = value;  break;         case 'boolVarNullValue':              settings.boolVarNullValue              = value;  break;         case 'stringVarNullValue':            settings.stringVarNullValue            = value;  break;         case 'colorVarNullValue':             settings.colorVarNullValue             = value;  break;         case 'showPages':                     settings.showPages                     = value;  break;         case 'showAllColorSpaces':            settings.showAllColorSpaces            = value;  break;         case 'showNodeIcons':                 settings.showNodeIcons                 = value;  break;         case 'showBoolValues':                settings.showBoolValues                = value;  break;         case 'separateThousands':             settings.separateThousands             = value;  break;         case 'allowInvertParams':             settings.allowInvertParams             = value;  break;         case 'activateDeactiatesOthers':      settings.activateDeactiatesOthers      = value;  break;         case 'preferHtmlColorNames':          settings.preferHtmlColorNames          = value;  break;         case 'randomShiftR':                  settings.randomShiftR                  = value;  break;         case 'colorShiftR':                   settings.colorShiftR                   = value;  break;         case 'numberShiftR':                  settings.numberShiftR                  = value;  break;                  case 'showSnapshots':                 settings.showSnapshots                 = value;  break;         case 'showRestartInfo':               settings.showRestartInfo               = value;  break;         case 'showColorLegendInMenus':        settings.showColorLegendInMenus        = value;  break;         case 'showClearUndoWarning':          settings.showClearUndoWarning          = value;  break;         case 'shareUsageMetrics':             settings.shareUsageMetrics             = value;  break;         case 'showObjectCount':               settings.showObjectCount               = value;  break;         case 'showDebugMenu':                 settings.showDebugMenu                 = value;  break;                                  case 'showNodeId':                    settings.showNodeId                    = value;  break;         case 'showTransformPoints':           settings.y2599           = value;  break;         case 'enableAsserts':                 settings.enableAsserts                 = value;  break;          case 'showTooltipNodes':              settings.showTooltipNodes              = value;  break;         case 'showTooltipParams':             settings.showTooltipParams             = value;  break;         case 'showTooltipLists':              settings.showTooltipLists              = value;  break;         case 'showTooltipLongText':           settings.showTooltipLongText           = value;  break;         case 'showTooltipColorInterpolation': settings.showTooltipColorInterpolation = value;  break;         case 'showTooltipValidateMethod':     settings.showTooltipValidateMethod     = value;  break;         case 'showTooltipColorBlindness':     settings.showTooltipColorBlindness     = value;  break;         case 'showTooltipColorContrast':      settings.showTooltipColorContrast      = value;  break;         case 'showTooltipColorNames':         settings.showTooltipColorNames         = value;  break;         case 'showTooltipAscii':              settings.showTooltipAscii              = value;  break;          case 'enableBetaFeatures':            settings.enableBetaFeatures            = value;  break;                             case 'logThreadMessages':             settings.logThreadMessages             = value;  break;         case 'logDataMessages':               settings.logDataMessages               = value;  break;         case 'logMessages':                   settings.logMessages                   = value;  break;          case 'logActions':                    settings.logActions                    = value;  break;         case 'logLoading':                    settings.logLoading                    = value;  break;         case 'logRequests':                   settings.logRequests                   = value;  break;         case 'logValueUpdates':               settings.logValueUpdates               = value;  break;         case 'logObjectUpdates':              settings.logObjectUpdates              = value;  break;         case 'logStyleUpdates':               settings.logStyleUpdates               = value;  break;                             case 'logRawLoadPages':               settings.logRawLoadPages               = value;  break;         case 'logRawLoadNodes':               settings.logRawLoadNodes               = value;  break;         case 'logRawLoadConnections':         settings.logRawLoadConnections         = value;  break;                          case 'logRawSavePages':               settings.logRawSavePages               = value;  break;         case 'logRawSaveNodes':               settings.logRawSaveNodes               = value;  break;         case 'logRawSaveConnections':         settings.logRawSaveConnections         = value;  break;                          case 'logRawRequests':                settings.logRawRequests                = value;  break;         case 'logRawValues':                  settings.logRawValues                  = value;  break;          case 'sessionId':                     settings.sessionId                     = value;  break;     }        switch (f3756)     {         case 'objectCenterSize':             x2483(             {                 cmd:             'figUpdateObjectCenterSize',                 objectCenterSize: settings.objectCenterSize             });             break;     } }    function l3613(f3756, valid, value, save = true) {     switch (f3756)     {         case 'debugMode':                     t3755(valid, f3756, value, o718                    ); break;                        case 'enableZoomedOutParams':         t3755(valid, f3756, value, p644        ); break;         case 'showPages':                     t3755(valid, f3756, value, x649                    ); break;         case 'showAllColorSpaces':            t3755(valid, f3756, value, w651           ); break;         case 'showNodeIcons':                 t3755(valid, f3756, value, a652                ); break;         case 'showBoolValues':                t3755(valid, f3756, value, x654               ); break;         case 'separateThousands':             t3755(valid, f3756, value, y655            ); break;         case 'allowInvertParams':             t3755(valid, f3756, value, r656            ); break;         case 'activateDeactiatesOthers':      t3755(valid, f3756, value, menuItemActivateDeactiatesOthers     ); break;         case 'preferHtmlColorNames':          t3755(valid, f3756, value, menuItemPreferHtmlColorNames         ); break;         case 'randomShiftR':                  t3755(valid, f3756, value, menuItemRandomShiftR                 ); break;         case 'colorShiftR':                   t3755(valid, f3756, value, menuItemColorShiftR                  ); break;         case 'numberShiftR':                  t3755(valid, f3756, value, menuItemNumberShiftR                 ); break;          case 'showSnapshots':                 t3755(valid, f3756, value, menuItemShowSnapshots                ); break;         case 'showRestartInfo':               t3755(valid, f3756, value, menuItemShowRestartInfo              ); break;         case 'showColorLegendInMenus':        t3755(valid, f3756, value, u653       ); break;         case 'showClearUndoWarning':          t3755(valid, f3756, value, z657         ); break;         case 'shareUsageMetrics':             t3755(valid, f3756, value, v658            ); break;         case 'showObjectCount':               t3755(valid, f3756, value, p660              ); break;         case 'showDebugMenu':                 t3755(valid, f3756, value, a661                ); break;                                case 'showNodeId':                    t3755(valid, f3756, value, n664                   ); break;         case 'showTransformPoints':           t3755(valid, f3756, value, k665          ); break;         case 'enableAsserts':                 t3755(valid, f3756, value, s666                ); enableAsserts = value; break;                  case 'showTooltipNodes':              t3755(valid, f3756, value, menuItemShowTooltipNodes             ); break;         case 'showTooltipParams':             t3755(valid, f3756, value, menuItemShowTooltipParams            ); break;         case 'showTooltipLists':              t3755(valid, f3756, value, i639             ); break;         case 'showTooltipLongText':           t3755(valid, f3756, value, f638          ); break;         case 'showTooltipColorInterpolation': t3755(valid, f3756, value, t640); break;         case 'showTooltipValidateMethod':     t3755(valid, f3756, value, menuItemShowTooltipValidateMethod    ); break;         case 'showTooltipColorBlindness':     t3755(valid, f3756, value, y643    ); break;         case 'showTooltipColorContrast':      t3755(valid, f3756, value, b641     ); break;         case 'showTooltipColorNames':         t3755(valid, f3756, value, z642        ); break;         case 'showTooltipAscii':              t3755(valid, f3756, value, y643    ); break;          case 'enableBetaFeatures':            t3755(valid, f3756, value, menuItemEnableBetaFeatures           ); break;                                case 'logThreadMessages':             t3755(valid, f3756, value, c719            ); break;         case 'logDataMessages':               t3755(valid, f3756, value, k720              ); break;         case 'logMessages':                   t3755(valid, f3756, value, l721                  ); break;          case 'logActions':                    t3755(valid, f3756, value, m722                   ); break;         case 'logLoading':                    t3755(valid, f3756, value, q723                   ); break;         case 'logRequests':                   t3755(valid, f3756, value, o724                  ); break;         case 'logValueUpdates':               t3755(valid, f3756, value, u725              ); break;         case 'logObjectUpdates':              t3755(valid, f3756, value, b726             ); break;         case 'logStyleUpdates':               t3755(valid, f3756, value, c727              ); break;                                case 'logRawLoadPages':               t3755(valid, f3756, value, o728              ); break;         case 'logRawLoadNodes':               t3755(valid, f3756, value, w729              ); break;         case 'logRawLoadConnections':         t3755(valid, f3756, value, j730        ); break;                                case 'logRawSavePages':               t3755(valid, f3756, value, k731              ); break;         case 'logRawSaveNodes':               t3755(valid, f3756, value, d732              ); break;         case 'logRawSaveConnections':         t3755(valid, f3756, value, t733        ); break;                                case 'logRawRequests':                t3755(valid, f3756, value, f734               ); break;         case 'logRawValues':                  t3755(valid, f3756, value, n735                 ); break;     }        if (save)                  l2612(f3756, h935(value)); }    function t3755(valid, setting, value, menu) {     if (valid)          settings[setting] = value;         switch (setting)     {         case 'showNodeId':             x2483(             {                 cmd:    'figUpdateShowIds',                 t2898: settings.showNodeId             });             break;     }       if (menu)         menu.r2969(settings[setting]); }    function updateSettingsMenus() {     o718                    .d326(settings.debugMode                    );                      p644        .r2969(settings.x2592        );     x649                    .r2969(settings.showPages                    );     w651           .r2969(settings.showAllColorSpaces           );     a652                .r2969(settings.showNodeIcons                );     x654               .r2969(settings.showBoolValues               );     y655            .r2969(settings.separateThousands            );     r656            .r2969(settings.allowInvertParams            );     menuItemActivateDeactiatesOthers     .r2969(settings.activateDeactiatesOthers     );     menuItemPreferHtmlColorNames         .r2969(settings.preferHtmlColorNames         );     menuItemRandomShiftR                 .r2969(settings.randomShiftR                 );     menuItemColorShiftR                  .r2969(settings. colorShiftR                 );     menuItemNumberShiftR                 .r2969(settings.numberShiftR                 );      menuItemShowSnapshots                .r2969(settings.showSnapshots                );     menuItemShowRestartInfo              .r2969(settings.showRestartInfo              );     u653       .r2969(settings.showColorLegendInMenus       );     z657         .r2969(settings.showClearUndoWarning         );     v658            .r2969(settings.shareUsageMetrics            );     p660              .r2969(settings.showObjectCount              );     a661                .r2969(settings.showDebugMenu                );                      n664                   .r2969(settings.showNodeId                   );     k665          .r2969(settings.y2599          );     s666                .r2969(settings.enableAsserts                );      menuItemShowTooltipNodes             .r2969(settings.showTooltipNodes             );     menuItemShowTooltipParams            .r2969(settings.showTooltipParam             );     i639             .r2969(settings.showTooltipLists             );     f638          .r2969(settings.showTooltipLongText          );     t640.r2969(settings.showTooltipColorInterpolation);     menuItemShowTooltipValidateMethod    .r2969(settings.showTooltipValidateMethod    );     y643    .r2969(settings.showTooltipColorBlindness    );     b641     .r2969(settings.showTooltipColorContrast     );     z642        .r2969(settings.showTooltipColorNames        );     menuItemShowTooltipAscii             .r2969(settings.showTooltipAscii             );                            c719            .r2969(settings.logThreadMessages            );     k720              .r2969(settings.logDataMessages              );     l721                  .r2969(settings.logMessages                  );      m722                   .r2969(settings.logActions                   );                        q723                   .r2969(settings.logLoading                   );     o724                  .r2969(settings.logRequests                  );     u725              .r2969(settings.logValueUpdates              );     b726             .r2969(settings.logObjectUpdates             );     c727              .r2969(settings.logStyleUpdates              );                        w729              .r2969(settings.logRawLoadPages              );     w729              .r2969(settings.logRawLoadNodes              );     j730        .r2969(settings.logRawLoadConnections        );                          k731              .r2969(settings.logRawSaveNodes              );     d732              .r2969(settings.logRawSaveNodes              );     t733        .r2969(settings.logRawSaveConnections        );                      f734               .r2969(settings.logRawRequests               );     n735                 .r2969(settings.logRawValues                 ); }    function updateMenuItemShowPages() {     e2655('showPages', h935(settings.showPages));     graph.q2088();     c186.update(); }    function updateMenuItemShowSnapshots() {     e2655('showSnapshots', h935(settings.showSnapshots));      snapshotBar.style.display = settings.showSnapshots ? 'block' : 'none';      }    function updateMenuItemShowAllColorSpaces() {     e2655('showAllColorSpaces', h935(settings.showAllColorSpaces));      graph.nodes         .filter(n => m1176.includes(n.type))         .forEach(n => n.t3130()); }    function updateMenuItemShowNodeIcons() {     graph.nodes.forEach(n => n.t3130()); }    function updateMenuItemShowBoolValues() {     graph.nodes         .filter(n => n.params.find(p => p.type == c1090) != null)         .forEach(n => n.t3130()); }    function updateMenuItemSeparateThousands() {     graph.nodes         .filter(n => n.params.find(p => p.type == c1090) != null)         .forEach(n => n.t3130()); }    function updateMenuItemAllowInvertParams() {     graph.nodes         .filter(n => n.type == h1112)         .forEach(n => n.t3130()); }    function updateMenuItemShowColorLegendInMenus() {     for (const menu of y571)         menu.items.forEach(i => i.b3550()); }    function enableFeatures(pro) {     enableMenuItem(menuItemUpgrade,            true, pro, false, pro);     enableMenuItem(menuItemSetValueNames,      true, pro);     enableMenuItem(menuItemEnableBetaFeatures, true, pro);     enableMenuItem(menuItemCopyLLMPrompt,      true, pro, true, currentUserIsDev());       enableMenuItem(menuItemShowRestartInfo,    true, pro);     enableMenuItem(menuItemGetValueName,       true, pro);     enableMenuItem(menuItemSetValueName,       true, pro);     enableMenuItem(menuItemGetValueNames,      true, pro);     enableMenuItem(menuItemSetValueNames,      true, pro);     enableMenuItem(menuItemObjectName,         true, pro);     enableMenuItem(menuItemGetParameter,       true, pro);     enableMenuItem(menuItemSetParameter,       true, pro);     enableMenuItem(z686,           true, pro, true);     enableMenuItem(s689,              true, pro);     enableMenuItem(l691,            true, pro, true);     enableMenuItem(i668,         true, pro);     enableMenuItem(menuItemSaveSelected,       true, pro);     enableMenuItem(y692,              true, pro);        enableMenuItem(q700,              true, pro);     enableMenuItem(d3571,          true, pro);     enableMenuItem(menuItemToJson,             true, pro);     enableMenuItem(j702,       true, pro);     enableMenuItem(e705,         true, pro);     enableMenuItem(menuItemColorDifference,    true, pro);     enableMenuItem(y717,            true, pro);     enableMenuItem(menuItemVectorNetwork,      true, pro, true);     enableMenuItem(menuItemVectorVertex,       true, pro, true);     enableMenuItem(menuItemVectorEdge,         true, pro, true);     enableMenuItem(menuItemVectorRegion,       true, pro, true);     enableMenuItem(menuItemVectorNetwork,      true, pro, true);     enableMenuItem(menuItemBooleanSep,         true, pro, true);     enableMenuItem(menuItemBooleanShape,       true, pro, true);     enableMenuItem(menuItemSaveTemplate,       true, pro);       updatePanelButton();       graph.nodes.forEach(n => n.q3591(pro)); }    function updatePanelButton() {     if (f567     ) f567     .div.style.display = !(settings.enableBetaFeatures && subscribed()) ? 'inline-block' : 'none';     if (btnDecoration) btnDecoration.div.style.display =  (settings.enableBetaFeatures && subscribed()) ? 'inline-block' : 'none'; }    function enableMenuItem(menuItem, enable, pro, beta = false, show = true) {     if (!menuItem) return;      menuItem.enabled = enable;     menuItem.pro     = pro;      menuItem.d326(            show          && (               !beta             ||     beta                 && !pro                 &&  settings.enableBetaFeatures));      menuItem.update(); }    function updateMenuItemShowDebugMenu() {     updateElementDisplay(d669.div, settings.showDebugMenu);      d572.update(         n993(d572.div).x + 6,         n993(d572.div).y - 4,         true); }     function updateElementDisplay(menuItem, enable) {     menuItem.style.display = enable ? 'block' : 'none'; }    function loadLocalSettings() {     b2601('debugMode'                    );              b2601('enableZoomedOutParams'        );     b2601('minZoomForParams'             );     b2601('objectCenterSize'             );     b2601('objectBatchSize'              );     b2601('maxSolveIterations'           );     b2601('numberVarNullValue'           );     b2601('boolVarNullValue'             );     b2601('stringVarNullValue'           );     b2601('colorVarNullValue'            );     b2601('showAllColorSpaces'           );     b2601('showNodeIcons'                );     b2601('showBoolValues'               );     b2601('separateThousands'            );     b2601('allowInvertParams'   );     b2601('activateDeactiatesOthers'     );     b2601('preferHtmlColorNames'         );     b2601('randomShiftR'                 );     b2601('colorShiftR'                  );     b2601('numberShiftR'                 );      b2601('showSnapshots'                );     b2601('showRestartInfo'              );     b2601('showColorLegendInMenus'       );     b2601('showPages'                    );     b2601('showClearUndoWarning'         );     b2601('shareUsageMetrics'            );     b2601('showObjectCount'              );     b2601('showDebugMenu'                );              b2601('showNodeId'                   );     b2601('showTransformPoints'          );     b2601('enableAsserts'                );      b2601('showTooltipNodes'             );     b2601('showTooltipParams'            );     b2601('showTooltipLists'             );     b2601('showTooltipLongText'          );     b2601('showTooltipColorInterpolation');     b2601('showTooltipValidateMethod'    );     b2601('showTooltipColorBlindness'    );     b2601('showTooltipColorContrast'     );     b2601('showTooltipColorNames'        );     b2601('showTooltipAscii'             );      b2601('enableBetaFeatures'           );                  b2601('logThreadMessages'            );     b2601('logDataMessages'              );     b2601('logMessages'                  );      b2601('logActions'                   );                  b2601('logLoading'                   );     b2601('logRequests'                  );     b2601('logValueUpdates'              );     b2601('logObjectUpdates'             );     b2601('logStyleUpdates'              );                  b2601('logRawLoadPages'              );     b2601('logRawLoadNodes'              );     b2601('logRawLoadConnections'        );              b2601('logRawSavePages'              );     b2601('logRawSaveNodes'              );     b2601('logRawSaveConnections'        );              b2601('logRawRequests'               );     b2601('logRawValues'                 ); }


const q1054              = 'LIST#';  const b1055       = 'NLIST#'; const   y1056       = 'TLIST#'; const  f1057       = 'SLIST#'; const  COLOR_LIST_VALUE       = 'CLIST#'; const  FILL_LIST_VALUE        = 'FLIST#'; const  COLOR_STOP_LIST_VALUE  = 'CSLIST#';   const s1058               = 'NULL'; const y1060          = 'VARGRP'; const k1061                = 'FEEDBK'; const e1062                  = 'REPT'; const ADVANCE                 = 'ADVNC'; const m1063                   = 'CACHE'; const d1064                  = 'FRZ'; const s1065                   = 'TIMER'; const z1066          = 'GVNAME'; const l1067          = 'SVNAME'; const i1351    = 'GVNAMES'; const o1352    = 'SVNAMES'; const x1353         = 'SONAME';   const o1059                = 'VAR'; const VARIABLE_VALUE          = 'VAR#'; const VARIABLE_TYPES          = [VARIABLE_VALUE, o1059];   const q1068                    = 'LIST'; const b1069            = 'LSASIT'; const u1070                 = 'EXTR'; const n1071               = 'SETP'; const n1072               = 'GETP'; const y1073                 = 'SUBLST'; const c1074                  = 'UNIQ'; const q1348            = 'RORD'; const s1349              = 'SHFTLST'; const x1075            = 'REVLST'; const z1350             = 'BUKLST'; const j1076                    = 'SORT'; const k1077                  = 'CLMN'; const x1078                    = 'CELL'; const y1079                   = 'ITEMS'; const b1080              = 'COUNT'; const OBJECT_COUNT            = 'OBJCOUNT'; const q1081           = 'LCONT'; const LIST_FIND               = 'LFIND'; const i1082                  = 'SELECT'; const e1359        = 'LSTSEL'; const e1083                 = 'IF'; const b1084                  = 'LSTFLT';   const n1086               = 'ANY#';   const f1087 = [     q1054,     b1055,     y1056,     f1057,     COLOR_LIST_VALUE,     FILL_LIST_VALUE,     COLOR_STOP_LIST_VALUE,     q1068,     u1070,     n1071,     n1072,     y1073,     y1079,     b1080,     q1081,     LIST_FIND,     e1062,     ADVANCE ];   const a1088 = [                 q1054,          b1055,            y1056,           f1057,           COLOR_LIST_VALUE,            FILL_LIST_VALUE,      COLOR_STOP_LIST_VALUE ];   const u1085                 = 'ITER';   const b1107             = 'PROB';   const HOLD                    = 'HOLD';   const BOOLEAN_NUMBER          = 'BOOL';  const c1090            = 'NUM#';   const n1091                  = 'NUM';    const BOUNDED_NUMBER          = 'BNDNUM';    const s1354        = 'NPREC';    const d1092             = 'NSIGN';    const g1093         = 'ABS';    const u1355         = 'NEG';    const y1094            = 'ROUND';    const j1356         = 'QUANT';    const w1095    = 'SMINMAX';    const m1096           = 'MINMAX';    const j1097           = 'LIM';    const v1098            = 'NCURVE';    const a1357              = 'NMAP';    const x1358             = 'NBIAS';    const a1099           = 'ISNAN'; const j1100         = 'CONST';   const i1101         = 'DATE';   const x1102         = 'SEQ';   const h1103            = 'RANGE';   const s1104             = 'WAVE';   const k1105           = 'RAND';   const l1106            = 'NOISE';   const x1108       = 'ACCUM';   const s1109      = 'LERP';  const s1110            = 'SOLVE'; const o1111          = 'NANIM';  const h1112      = 'SMATH';   const u1113             = 'MATH';   const m1114              = 'ADD';    const h1115         = 'SUB';    const c1116         = 'MUL';    const z1117           = 'DIV';    const k1118           = 'MOD';    const i1119         = 'EXP';  const e1120          = 'NBOOL';   const t1121              = 'NOT'; const l1122              = 'AND'; const b1123               = 'OR'; const y1124              = 'XOR';  const h1125          = 'CMP'; const j1126            = 'EQ'; const h1127        = 'NE'; const z1128             = 'LT'; const g1129    = 'LE'; const k1130          = 'GT'; const a1131 = 'GE';  const o1132             = 'TRIG';   const x1133              = 'SIN';    const o1134              = 'COS';    const t1135              = 'TAN'; const t1136            = 'ATAN2';  const a1137           = 'CNVANG';   const h1142              = 'TEXT#'; const h1143                    = 'TEXT'; const w1144             = 'TLEN'; const n1145               = 'TTRIM'; const f1146          = 'TSUB'; const j1147           = 'TCONT'; const TEXT_FIND               = 'TFIND'; const t1148               = 'TCASE'; const r1149            = 'TREPL'; const TEXT_ADD                = 'TADD'; const t1150               = 'TJOIN'; const m1151                = 'TPAD'; const y1152            = 'TCMP'; const m1153               = 'TCHAR'; const v1154            = 'TUNI'; const TEXT_ESCAPE             = 'TESC'; const TEXT_UNESCAPE           = 'TUNESC'; const p1155           = 'INDEX'; const w1156          = 'N2T'; const BOOLEAN_TO_TEXT         = 'B2T'; const v1157           = 'C2T'; const i1158          = 'T2N'; const TEXT_TO_BOOLEAN         = 'T2B'; const l1159           = 'T2C'; const a1160              = 'TSPLT'; const w3601              = 'PRJSON'; const b1162               = 'PRCSV'; const r1163              = 'FETCH'; const i1164               = 'TFILE'; const TO_JSON                 = 'TOJSON';   const j1167             = 'COL#';   const f1168                   = 'COL';    const t1169             = 'CVAL';   const o1170           = 'CCOR';   const b1171          = 'CCNT';   const o1172        = 'CDLTE';   const t1173              = 'BLND';   const COLOR_SCHEME            = 'CPAL';  const a1174       = 'CLERP';  const s1175             = 'CBLND';   const d1177              = 'FILL#'; const e1178                    = 'FILL'; const l1179              = [d1177, e1178];  const b1180            = 'STRK#'; const a1181                  = 'STRK'; const o1182            = [b1180, a1181];  const y1189      = 'STRKSD#'; const w1190            = 'STRKSD'; const x1191      = [y1189, w1190];  const i1183        = 'CSTOP#'; const m1184              = 'CSTOP'; const x1185        = [i1183, m1184];  const c1186          = 'GRAD#'; const c1187                = 'GRAD'; const c1188          = [c1186, c1187];   const r1192     = 'RCRN#'; const a1193           = 'RCRN'; const q1194     = [r1192, a1193];  const e1195       = 'DRSH#'; const k1196             = 'DRSH'; const p1197       = [e1195, k1196];  const y1198      = 'INSH#'; const e1199            = 'INSH'; const n1200      = [y1198, e1199];  const w1201        = 'LBLR#'; const e1202              = 'LBLR'; const z1203        = [w1201, e1202];  const d1204         = 'BBLR#'; const s1205               = 'BBLR'; const y1206         = [d1204, s1205];  const e1207        = 'MASK#'; const m1208              = 'MASK'; const c1209        = [e1207, m1208];  const d1210       = 'BLEND#'; const s1211             = 'BLEND'; const q1212       = [d1210, s1211];   const a1215             = 'CSTL';   const p1216             = 'SHP#';   const s1217         = 'RECT#'; const f1218               = 'RECT';   const l1219         = [s1217, f1218];  const p1220              = 'LINE#'; const y1221                    = 'LINE';  const h1222              = [p1220, y1221];  const g1223           = 'ELPS#'; const w1224                 = 'ELPS';  const q1225           = [g1223, w1224];  const j1226           = 'TRPZ#'; const n1227                 = 'TRPZ'; const d1228           = [j1226, n1227];  const f1235           = 'POLY#'; const w1236                 = 'POLY';  const o1237           = [f1235, w1236];  const f1238              = 'STAR#'; const t1239                    = 'STAR';  const y1240              = [f1238, t1239];  const x1241        = 'TXTS#'; const p1242              = 'TXTS';  const z1243        = [x1241, p1242];  const v1244             = 'PT#'; const d1245                   = 'PT'; const g1246             = [v1244, d1245];  const u1247            = 'PCORN';  const q1248       = 'VPATH#'; const p1249             = 'VPATH';  const o1250       = [q1248, p1249];  const s1251     = 'VPT#'; const k1252           = 'VPT';  const n1253     = [s1251, k1252];  const p1254       = 'VEDGE#'; const p1255             = 'VEDGE';  const o1256       = [p1254, p1255];  const x1257     = 'VREG#'; const c1258           = 'VREG';  const m1259     = [x1257, c1258];  const i1260    = 'VNET#'; const k1261          = 'VNET';  const b1262    = [i1260, k1261];  const r1263       = 'SGRP#'; const v1264             = 'SGRP'; const h1265       = [r1263, v1264];  const n1266             = 'FRM#'; const q1267                   = 'FRM'; const a1268             = [n1266, q1267];   const h1230          = 'ARC#'; const v1229                = 'ARC'; const w1231          = [h1230, v1229];  const a1233         = 'WAVEP#'; const f1232               = 'WAVEP'; const x1234         = [a1233, f1232];  const e1269                    = 'MOVE'; const e1270                  = 'ROT'; const b1271                   = 'SCALE'; const n1272                    = 'SKEW';  const SHOW_CENTER             = 'SHOWCNTR'; const l1273              = 'SCENTR'; const m1274             = 'RSTX';  const s1275                   = 'PLACE'; const i1276             = 'APPLY';  const PATH_LENGTH             = 'PTHLEN'; const JOIN_PATHS              = 'JOINPTH'; const REORIENT_PATHS          = 'REORPTH'; const o1283        = 'PTALPATH'; const g1284   = 'CPTONPATH'; const h1277          = 'MESPT'; const l1278             = 'PTANGLE'; const t1279                  = 'VECLEN'; const k1280           = 'CIRCEN'; const ARC_FROM_POINTS         = 'ARCPT'; const p1281         = 'INTLIN'; const x1282       = 'PTLERP'; const REVERSE_PATH            = 'REVPTH'; const BLEND_PATH              = 'BLENDPTH';   const p1285           = 'SBOOL'; const l1286     = 'SBOOL#';  const r1287              = 'SBOOLU'; const k1288           = 'SBOOLS'; const h1289          = 'SBOOLI'; const q1290            = 'SBOOLE';   const l1292                  = 'RETAIN'; const EXPORT                  = 'EXPORT';   const y1297              = 'GROUP'; const d1298             = 'GPARAM';   const q1300                 = 'CMNT'; const p1301           = 'CMNTARR'; const t1302                   = 'PANEL';   const m1303                  = 'ACT'; const k1304           = 'BFACT'; const n1305             = 'BFLST'; const e1306                = 'DIS'; const y1307                 = 'NOC';  const PARAM                   = 'PARAM';    const b1308                     = 'LOG';   const w1309                   = 'GRAPH';    const o1089 = [     s1058,     o1059,     y1060,     ...f1087,     b1069,     u1070,     n1071,     n1072,     y1073,     c1074,     q1348,     s1349,     x1075,     k1077,     j1076,     x1078,     y1079,     i1082,     e1359,     e1083,     b1084,     k1061,     e1062,     ADVANCE,     u1085,     b1107,     HOLD,     m1063,     d1064,     w3601,     b1162,     TO_JSON,     s1065,     z1066,     l1067,     i1351,     o1352,     COLOR_SCHEME,     o1172,     v1157,     l1292 ];   const l1138 = [     u1113,     h1112,     m1114,     h1115,     c1116,     z1117,     k1118,     i1119 ];   const r1139 = [     e1120,     t1121,     l1122,     b1123,     y1124 ];   const i1140 = [     h1125,     j1126,     h1127,     z1128,     g1129,     k1130,     a1131 ];   const m1141 = [     o1132,     x1133,     o1134,     t1135,     t1136 ];   const r1165 = [     c1090,     b1055,     n1091,     BOUNDED_NUMBER,     BOOLEAN_NUMBER,     s1354,     d1092,     g1093,     u1355,     y1094,     j1356,     w1095,     m1096,     j1097,     v1098,     a1357,     x1358,     a1099,     j1100,     i1101,     x1102,     h1103,     s1104,     k1105,     l1106,     x1108,     s1109,     s1110,     o1111,     w1156,     BOOLEAN_TO_TEXT,     m1153,      ...l1138,     ...r1139,     ...i1140,     ...m1141,      a1137,     z1350 ];   const a1166 = [     h1142,     y1056,     h1143,     w1144,     n1145,     f1146,     j1147,     TEXT_FIND,     t1148,     TEXT_ADD,     t1150,     m1151,     r1149,     y1152,     v1154,     TEXT_ESCAPE,     TEXT_UNESCAPE,     p1155,     i1158,     TEXT_TO_BOOLEAN,     l1159,     a1160,     r1163,     i1164 ];   const m1176 = [     j1167,     f1168,     t1169,     o1170,     t1173,     b1171,     o1172,     a1174,     s1175,     v1157 ];   const COLOR_HEADER_TYPES = [     f1168,     e1178,     a1181,     m1184,     c1187                     ];   const COLOR_VALUES = [     j1167,     d1177,     b1180,     i1183,     c1186 ];   const x1213 = [     ...x1191,     ...q1194,     ...p1197,     ...n1200,     ...z1203,     ...y1206,     ...q1212,     ...c1209 ];   const j1214 = [            j1167,              d1177,          c1186,            b1180,     y1189,      e1195,     y1198,       w1201,        d1204,      d1210,       e1207 ];   const PATH_TYPES = [     p1249,      n1227,     v1229,     f1232 ];  const PATH_VALUES = [     q1248,      j1226,     h1230,     a1233 ];   const y1291 = [     p1285,     l1286,     r1287,     k1288,     h1289,     q1290 ];   const s1293 = [     p1216,     f1057,     s1217,     p1220,     g1223,     j1226,     f1235,     f1238,     x1241,     v1244,     q1248,     s1251,     p1254,     x1257,     i1260,     h1230,     a1233,     r1263,     n1266,     l1286,     e1195,     y1198,     w1201,     d1204,     d1210,     e1207 ];   const l1294 = [     e1270,     b1271,     n1272 ];   const n1295 = [     ...s1293,      ...l1219,     ...h1222,     ...q1225,     ...d1228,     ...o1237,     ...y1240,     ...z1243,     ...g1246,        u1247,     ...o1250,     ...n1253,     ...o1256,     ...m1259,     ...b1262,     ...w1231,     ...x1234,     ...h1265,     ...a1268,     ...y1291,          e1269,     ...l1294,     SHOW_CENTER,     l1273,     m1274,              s1275,     i1276,          PATH_LENGTH,     JOIN_PATHS,     REORIENT_PATHS,     o1283,     g1284,              h1277,     l1278,     t1279,     k1280,     v1229,     f1232,     ARC_FROM_POINTS,     p1281,     x1282,     REVERSE_PATH,     BLEND_PATH,      x1353,      EXPORT ];   const NUMBER_VALUES = [c1090, b1055]; const   TEXT_VALUES = [  h1142,   y1056];   const w1296 = [             q1054,      b1055,        y1056,       f1057,               VARIABLE_VALUE,                    c1090,             h1142,            j1167,               d1177,       i1183,         c1186,           b1180,         i1183,         c1186,              p1216,        s1217,             p1220,          g1223,          j1226,          f1235,             f1238,       x1241,            v1244,      q1248,    s1251,      p1254,    x1257,   i1260,      r1263,            n1266,     r1192,      e1195,     y1198,       w1201,        d1204,       d1210,       e1207 ];   const n1299 = [     y1297,     d1298 ];   const g1310 =  [        [k1118,   '%' ],     [z1117,   '/' ],      [h1115, '−' ],     [m1114,      '+' ],     [c1116, '×' ],     [i1119, 'e<sup>x']  ];   const h1311 =  [        [z1117,   '/' ],      [h1115, '−' ],     [m1114,      '+'],     [c1116, '×'] ];    const l1312 = 0; const j1313 = 1; const c1314  = 2; const s1315 = 3;   const n1316 =  [        [l1312, 'not'],     [j1313, 'xor'],      [c1314,  'or' ],     [s1315, 'and'] ];    const n1317             = 0; const k1318    = 1; const g1319        = 2; const v1320            = 3; const w1321 = 4; const f1322          = 5;   const s1323 =  [        [n1317,             '<'],     [k1318,    '≤'],     [g1319,        '≠'],     [v1320,            '='],     [w1321, '≥'],     [f1322,          '>'] ];    const o1324  = 0; const g1325  = 1; const p1326  = 2; const v1327 = 3; const a1328 = 4; const y1329 = 5;   const w1330 =  [        [o1324,  'sin' ],     [g1325,  'cos' ],     [p1326,  'tan' ],     [v1327, 'asin'],     [a1328, 'acos'],     [y1329, 'atan'] ];    const k1331                = 'EMPTY'; const d1332              = 'CONNECT'; const x1333               = 'CREATE'; const d1334        = 'CREATE_INSERT'; const v1335               = 'DELETE'; const v1336           = 'DISCONNECT'; const l1337           = 'LINK_STYLE'; const d1338        = 'LINK_VARIABLE'; const s1339  = 'LINK_VARIABLE_GROUP'; const l1340          = 'MAKE_ACTIVE'; const MAKE_NOT_CONDITION_ACTION   = 'MAKE_NOT_CONDITION'; const n1341         = 'MAKE_PASSIVE'; const q1342                = 'PASTE'; const o1343            = 'RECONNECT'; const a1344               = 'REMOVE'; const j1345               = 'RENAME'; const m1346       = 'REORDER_INPUTS'; const c1347  = 'REORDER_CONNECTIONS'; const y1360               = 'SELECT'; const i1361          = 'SELECT_MOVE'; const y1362           = 'MOVE_NODES'; const c1363      = 'SET_PARAM_VALUE'; const SET_MULTIPLE_VALUES_ACTION  = 'SET_MULTIPLE_VALUES'; const SET_SHOW_VALUE_NAMES_ACTION = 'SET_SHOW_VALUE_NAMES'; const a1364    = 'SET_PARAM_SETTING'; const w1365        = 'SET_NODE_RECT'; const d1366       = 'TOGGLE_DISABLE'; const n1367  = 'TOGGLE_PARAM_HEADER'; const g1368    = 'SET_CURRENT_GRAPH'; const g1369          = 'CREATE_PAGE'; const w1370          = 'DELETE_PAGE'; const c1371          = 'GROUP_NODES'; const j1372        = 'UNGROUP_NODES'; const r1373      = 'HIGHLIGHT_NODES'; const SCROLL_LIST_NODE_ACTION     = 'SCROLL_LIST_NODE'; const SET_LIST_DIVIDER_ACTION     = 'SET_LIST_DIVIDER'; const SET_NODE_PARAM_ACTION       = 'SET_NODE_PARAM';   const u1374                = 'BNORM'; const i1375                = 'BDARK'; const f1376              = 'BMULT'; const r1377           = 'BPDRK'; const s1378            = 'BBURN'; const f1379               = 'BLITE'; const t1380                = 'BSCRN'; const m1381          = 'BPLGT'; const f1382           = 'BDODG'; const h1383               = 'BOVER'; const y1384            = 'BSOFT'; const n1385            = 'BHARD'; const w1386            = 'BDIFF'; const g1387             = 'BEXCL'; const f1388                   = 'BHUE'; const j1389            = 'BSAT'; const l1390                 = 'BCOL'; const u1391            = 'BLUM';  const BLEND_NORMAL_INDEX          =  0; const BLEND_DARKEN_INDEX          =  1; const BLEND_MULTIPLY_INDEX        =  2; const BLEND_PLUS_DARKER_INDEX     =  3; const BLEND_COLOR_BURN_INDEX      =  4; const BLEND_LIGHTEN_INDEX         =  5; const BLEND_SCREEN_INDEX          =  6; const BLEND_PLUS_LIGHTER_INDEX    =  7; const BLEND_COLOR_DODGE_INDEX     =  8; const BLEND_OVERLAY_INDEX         =  9; const BLEND_SOFT_LIGHT_INDEX      = 10; const BLEND_HARD_LIGHT_INDEX      = 11; const BLEND_DIFFERENCE_INDEX      = 12; const BLEND_EXCLUSION_INDEX       = 13; const BLEND_HUE_INDEX             = 14; const BLEND_SATURATION_INDEX      = 15; const BLEND_COLOR_INDEX           = 16; const BLEND_LUMINOSITY_INDEX      = 17;   const n1392 = [     [u1374,       'normal',       'NORMAL'      ],     [i1375,       'darken',       'DARKEN'      ],     [f1376,     'multiply',     'MULTIPLY'    ],     [r1377,  'plus darker',  'LINEAR_BURN' ],     [s1378,   'color burn',   'COLOR_BURN'  ],     [f1379,      'lighten',      'LIGHTEN'     ],     [t1380,       'screen',       'SCREEN'      ],     [m1381, 'plus lighter', 'LINEAR_DODGE'],     [f1382,  'color dodge',  'COLOR_DODGE' ],     [h1383,      'overlay',      'OVERLAY'     ],     [y1384,   'soft light',   'SOFT_LIGHT'  ],     [n1385,   'hard light',   'HARD_LIGHT'  ],     [w1386,   'difference',   'DIFFERENCE'  ],     [g1387,    'exclusion',    'EXCLUSION'   ],     [f1388,          'hue',          'HUE'         ],     [j1389,   'saturation',   'SATURATION'  ],     [l1390,        'color',        'COLOR'       ],     [u1391,   'luminosity',   'LUMINOSITY'  ] ];    const EllipsePositions = [     'top-left',     'center' ];    const TextAlignX      = ['left', 'center', 'right', 'justify']; const TextAlignY      = ['bottom', 'middle', 'top'];  const PathDegrees     = ['linear', 'quadratic', 'cubic', 'smooth', 'sine X', 'sine Y']; const PathJoinDegrees = ['linear', 'cubic', 'smooth', 'sine X', 'sine Y']; const PathWindings    = ['even-odd', 'non-zero'];  const StrokeAlign     = ['inside', 'center', 'outside']; const StrokeJoin      = ['miter', 'bevel', 'round']; const StrokeCap       = ['none', 'square', 'round'];  const LayerMaskTypes  = ['alpha', 'vector', 'luminance'];  const FramePositions  = ['relative', 'absolute'];   const y1393 = [     ['thin',        100],     ['extra light', 200],     ['light',       300],     ['regular',     400],     ['medium',      500],     ['semi bold',   600],     ['bold',        700],     ['extra bold',  800],     ['black',       900] ];    const u1394           =  0; const c1395        =  1;  const p1396      =  2;   const n1397     = 2; const n1398    =  3;   const d1399   = 3;  const f1400       =  4;   const z1401 = 4; const FO_PERSIST        =  5;   const j1403            =  6; const w1404            =  7; const x1405            =  8;  const y1406          =  9;  const w1407          = 10;   const FO_VARIABLE_TYPE     = 10; const d1408        = 11;   const FO_VARIABLE_COUNT    = 11;  const j1409  = 12;   const FO_VARIABLE_IS_ALIAS = 12; const o1410   = 13; const r1411    = 14;                                     const i1412   = 15; const s1413     = 16; const l1414  = 17;  const l1415        = 18;  const d1416           = 19; const r1417      = 20;     const e1418        = 21; const m1419          = 22; const a1420           = 23;  const x1421              = 24;                                                                         const j1452    = 24;                                                                                              const h1422 = 24; const x1423              = 25;                                                                         const a1453   = 25; const v1424          = 26;    const b1425         = 27;                                      const p1426     = 28;   const k1427   = 28;   const x1428 = 28;   const s1429    = 28;   const t1430   = 28;   const s1431  = 28;   const e1432      = 28;   const o1433    = 28;                                 const z1434   = 29;                                        const t1435 = 29;   const q1436 = 29;   const v1437 = 29;   const l1438     = 29;   const d1454     = 29;                                 const o1440   = 30;                                        const z1441   = 30;                                 const d1442 = 30;   const w1443           = 30;   const b1439 = 30;                                                                                                                                                                   const u1444   = 31;                                                                                                                                        const u1445           = 31;                                                                                                                                                                                                       const l1446      = 32;                                                                                                                                                                                                       const u1447     = 33;                                                                                                                                                                                                                                                                                                                                                                                                                                            const n1448        = 34;                                                                                                                                                                                                       const i1449        = 35;                                                                                                                                                                                                                                                                                                                                                                                                                                            const z1450    = 36;                                                                                                                                                                                                       const y1451 = 37;


class k1843 {     type;          nodeId     = '';       objectId   = NULL;     objectName = NULL;      a3915  = -1;       retain    = 0;     feedback   = false;       showCenter = false;          x4300;      xp0   = null;      xp1   = null;      xp2   = null;       sp0   = null;      sp1   = null;      sp2   = null;       u3835;     scaleStyle;        constructor(type, nodeId, objectId, objectName)     {         this.type         = type;         this.nodeId       = nodeId;         this.objectId     = objectId;         this.objectName   = objectName;          this.x4300        = clone(identity);          this.u3835 = 1;         this.scaleStyle   = 1;     }        t3455(base)     {         this.a3915    = base.a3915;                  this.feedback     = base.feedback;         this.retain      = base.retain;          this.showCenter   = base.showCenter;          this.x4300        = clone(base.x4300);          this.xp0          = clone(base.xp0);         this.xp1          = clone(base.xp1);         this.xp2          = clone(base.xp2);          this.sp0          = clone(base.sp0);         this.sp1          = clone(base.sp1);         this.sp2          = clone(base.sp2);          this.u3835 = base.u3835;         this.scaleStyle   = base.scaleStyle;     }        copy()     {         h951('invalid use of abstract method k1843.copy()');         return null;     }        getCount()     {         return 1;     }        q3837(cx = 0, cy = 0)     {         this.sp0 = point(cx,   cy  );         this.sp1 = point(cx+1, cy  );         this.sp2 = point(cx,   cy+1);     }        resetSpace(bounds, singlePoint = false, cx = 0.5, cy = 0.5, units = 0)     {         let _cx;          let _cy;           if (units == 0)         {             _cx = bounds.x + cx * bounds.width;             _cy = bounds.y + cy * bounds.height;                     }         else if (units == 1)         {             _cx = bounds.x + cx;             _cy = bounds.y + cy;         }         else          {             _cx = cx;             _cy = cy;                     }           const ds1 = v898(this.sp1, this.sp0);         const ds2 = v898(this.sp2, this.sp0);          this.sp0  = point(_cx, _cy);          this.sp1  = y893(this.sp0, ds1);         this.sp2  = y893(this.sp0, ds2);           if (PATH_TYPES.includes(this.type))             this.h3838();     }        x4190(x, y, a = 0)     {         this.x4300 =             [[Math.cos(a), -Math.sin(a), x],              [Math.sin(a),  Math.cos(a), y],              [0,            0,           1]];     }        z3825(x, y, w, h)     {         this.xp0 = point(x,     y    );         this.xp1 = point(x + w, y    );         this.xp2 = point(x,     y + h);     }        h3827()     {         let vr = point(this.sp1.x - this.sp0.x, this.sp1.y - this.sp0.y);         let vb = point(this.sp2.x - this.sp0.x, this.sp2.y - this.sp0.y);                   let sx = vr.x;         let sy = vb.y;              let kx = vr.y;         let ky = vb.x;                  let dx = this.sp0.x;         let dy = this.sp0.y;                   let x4300 = n887(             i891(dx, dy),             [[sx, ky, 0],              [kx, sy, 0],              [0,  0,  1]]);               return x4300;     }                getBounds()     {         let bounds = j1045.NaN;          const dp = v898(this.xp1, this.xp0);          bounds = m3840(bounds, this.xp0);         bounds = m3840(bounds, this.xp1);         bounds = m3840(bounds, this.xp2);         bounds = m3840(bounds, y893(this.xp2, dp));          return bounds;     }        s4191(x4300, affectSpace)     {         const space = this.h3827();           if (this.type == d1245)         {             if (affectSpace > 0)             {                 const p = t3826(point(this.x, this.y), x4300, space);                  this.x = p.x;                 this.y = p.y;             }              if (affectSpace != 1)                 this.applySpaceTransform(x4300, space);         }         else if (PATH_TYPES.includes(this.type))         {             if (affectSpace > 0)             {                 this.applyObjectTransform(x4300, space);                  this.updatePoints(x4300, space);                 this.h3838();             }              if (affectSpace != 1)                 this.applySpaceTransform(x4300, space);         }         else if (this.type == v1264)         {             for (const b111 of this.children)             {                 if (affectSpace > 0)                 {                     b111.applyObjectTransform(x4300, space);                      if (b111.type == p1249)                         b111.updatePoints(x4300, space);                 }                  if (affectSpace != 1)                     b111.applySpaceTransform(x4300, space);             }                         }         else         {             if (affectSpace > 0)                 this.applyObjectTransform(x4300, space);              if (affectSpace != 1)                 this.applySpaceTransform(x4300, space);         }     }        applyObjectTransform(x4300, space)     {         if (   this.xp0.x == this.xp1.x             && this.xp0.y == this.xp1.y)             this.xp1.x += 0.0001;          if (   this.xp0.x == this.xp2.x             && this.xp0.y == this.xp2.y)             this.xp2.y += 0.0001;          this.xp0 = t3826(this.xp0, x4300, space);         this.xp1 = t3826(this.xp1, x4300, space);         this.xp2 = t3826(this.xp2, x4300, space);     }        applySpaceTransform(x4300, space)     {         this.sp0 = t3826(this.sp0, x4300, space);         this.sp1 = t3826(this.sp1, x4300, space);         this.sp2 = t3826(this.sp2, x4300, space);     }        checkFlipped(flipX, flipY)     {         if (flipX)         {             const d1 = v898(this.xp1, this.xp0);              this.xp0 = y893(this.xp0, d1);             this.xp2 = y893(this.xp2, d1);             this.xp1 = v898(this.xp1, d1);         }                   if (flipY)         {             const d2 = v898(this.xp2, this.xp0);              this.xp0 = y893(this.xp0, d2);             this.xp1 = y893(this.xp1, d2);             this.xp2 = v898(this.xp2, d2);         }     }        y3851()     {         return {             type:       this.type,             nodeId:     this.nodeId,              objectId:   this.objectId,                objectName: this.objectName,                           feedback:   this.feedback,              xp0:        this.xp0 ? this.xp0 : null,             xp1:        this.xp1 ? this.xp1 : null,             xp2:        this.xp2 ? this.xp2 : null         };     }        i3836()     {         return [          this.type,          this.nodeId,           this.objectId,          this.objectName,                       this.feedback,          this.retain,                   this.xp0 ? this.xp0 : null,          this.xp1 ? this.xp1 : null,          this.xp2 ? this.xp2 : null,           0          ];     }        toNewValue()     {         return new s4309();     } }    function t3826(p, x4300, space) {     p = l886(p, h889(space));     p = l886(p, x4300);     p = l886(p, space);      return p; }    function u3833(b111) {     switch (b111.type)     {         case f1218:     return o1846 .prototype.copy.call(b111);         case y1221:          return x1842      .prototype.copy.call(b111);         case w1224:       return k1840   .prototype.copy.call(b111);         case n1227:       return g1851   .prototype.copy.call(b111);         case w1236:       return w1845   .prototype.copy.call(b111);         case t1239:          return x1849      .prototype.copy.call(b111);         case p1242:    return j1850      .prototype.copy.call(b111);         case d1245:         return e1844     .prototype.copy.call(b111);         case p1249:   return x1853.prototype.copy.call(b111);         case v1229:      return v2638   .prototype.copy.call(b111);         case f1232:     return c2640  .prototype.copy.call(b111);         case p1285: return a1838   .prototype.copy.call(b111);         case v1264:   return e1848.prototype.copy.call(b111);         case q1267:         return e1841     .prototype.copy.call(b111);     }      h951('invalid Figma object type \'' + b111.type + '\'');     return null; }    function getPointBounds(points) {     let minX = Number.MAX_SAFE_INTEGER;     let minY = Number.MAX_SAFE_INTEGER;     let maxX = Number.MIN_SAFE_INTEGER;     let maxY = Number.MIN_SAFE_INTEGER;      for (const p of points)     {         minX = Math.min(minX, p.x.value);         minY = Math.min(minY, p.y.value);         maxX = Math.max(maxX, p.x.value);         maxY = Math.max(maxY, p.y.value);     }      return new AbsRect(minX, minY, maxX, maxY); }    function getObjBounds(objects) {     let bounds = j1045.NaN;      for (const b111 of objects)         bounds = l3839(bounds, b111.getBounds());      return bounds; }    function y2682(node, b111) {     const sp0 = point(         b111.sp0.x ,          b111.sp0.y );      const sp1 = y893(sp0, a895(      v898(b111.sp1, b111.sp0),      settings.objectCenterSize));     const sp2 = y893(sp0, a895(a895(v898(b111.sp2, b111.sp0), -1), settings.objectCenterSize));          const center = createDecoPoly(         node.nodeId,         b111.objectId,         b111.objectName,          sp0,          [sp2, sp0, sp1],         false,         '',         [242, 72, 34],          o968,         true);      return center; }    function createDecoPoly(nodeId, objectId, objectName, center, points, closed, dashes, color, suffix, isCenter) {     const path = new x1853(         nodeId,         objectId   + suffix,         objectName + suffix,         points.map(p => f2023.fromPoint(objectId, p)),         closed ? 1 : 0,          0,          0,          0);       path.strokes.push([         'SOLID',          color[0],          color[1],          color[2],          100,          'NORMAL']);      path.strokeWeight =  1;     path.strokeAlign  = 'CENTER';     path.strokeJoin   = 'MITER';     path.strokeCap    = 'NONE';     path.strokeDashes =  dashes;     path.h3834       =  true;     path.isCenter     =  isCenter;       path.x4190(center.x, center.y);            return path; }    function v3723(value) {     return value         && value.objects         ? value.objects               .filter(o =>                       o.h3834  === false                   || o.isXform === true)               .map(o => o.copy())          : []; }


function o1823(b111, prop) {          if (prop.type ==         j1167)  z1824       (b111, prop);     else if (prop.type ==          d1177)  n1825        (b111, prop);     else if (prop.type ==      c1186)  p1826    (b111, prop);     else if (prop.type ==        b1180)  q1830      (b111, prop);     else if (prop.type ==  y1189)  addStrokeSidesProp (b111, prop);     else if (prop.type == r1192)  o1831(b111, prop);     else if (prop.type ==   e1195)  j1832  (b111, prop);     else if (prop.type ==  y1198)  o1833 (b111, prop);     else if (prop.type ==    w1201)  h1834   (b111, prop);     else if (prop.type ==     d1204)  i1835    (b111, prop);     else if (prop.type ==   d1210)  w1836  (b111, prop);     else if (prop.type ==    e1207)  i1837        (b111, prop); }    function z1824(b111, prop) {     const rgb = z4234(prop.t3339());      if (b111.type == v1264)     {         for (const _obj of b111.children)             o1823(_obj, prop);     }     else     {         b111.fills.push([             'SOLID',              rgb[0],              rgb[1],              rgb[2],              255 ]);     } }    function n1825(b111, prop, target = b111.fills) {     if (prop.color.type != j1167)         return;       const rgb = z4234(prop.color.t3339());      if (b111.type == v1264)     {         for (const _obj of b111.children)             o1823(_obj, prop);     }     else     {         target.push([             'SOLID',              rgb[0],              rgb[1],              rgb[2],              prop.opacity.toNewValue().value,             n1392[Math.min(Math.max(0, Math.round(prop.blend.value)), n1392.length-1)][2]]);     } }    function p1826(b111, prop, target = b111.fills)                 {     const gradient =      [         '',          [],          [],          '',          0                     ];       switch(prop.h3782.value)     {         case 0: gradient[0] = 'GRADIENT_LINEAR';  break;         case 1: gradient[0] = 'GRADIENT_RADIAL';  break;         case 2: gradient[0] = 'GRADIENT_ANGULAR'; break;         case 3: gradient[0] = 'GRADIENT_DIAMOND'; break;     }           let   x         =        prop.x     .value / 100;     let   y         =        prop.y     .value / 100;     let   s         = nozero(prop.size  .value / 100);     let   a         =        prop.angle .value / 360*Tau;     let   asp       = nozero(prop.aspect.value / 100);     const diag      =        prop.diagAspect;     let   sk        =        prop.skew  .value / 100;           const pos       = prop.position.value;     const isLinear  = prop.h3782.value == 0;     const isAngular = prop.h3782.value == 2;          const bounds    = b111.getBounds();                  if (pos > 0)     {         if (   pos == 1             || pos == 2)         {             x = x / 100 * bounds.width;             y = y / 100 * bounds.height;         }                   x = x * 100 / nozero(bounds.width );         y = y * 100 / nozero(bounds.height);           if (pos == 4)         {             x = x - bounds.x / nozero(bounds.width );             y = y - bounds.y / nozero(bounds.height);                          s *= 100 / nozero(bounds.width);         }     }       let   p0 = point(x, y);     let   p1 = y893(p0, vector(a, diag === true ? s : s * nozero(asp)));     let   p2 = y893(p0, vector(a + Tau/4, s));       const a1 = anglev2(p0, p1);     const a2 = anglev2(p0, p2);      if (diag === true)     {         p1 = y893(p1, vector(a1 - Tau/8, (asp-1) * Math.sqrt(sqr(distv(p0, p1))/2)));         p2 = y893(p2, vector(a2 + Tau/8, (asp-1) * Math.sqrt(sqr(distv(p0, p2))/2)));          p1 = y893(p1, vector(a2 + Tau/8, s * sk * Math.sqrt(2)/2));         p2 = y893(p2, vector(a2 + Tau/8, s * sk * Math.sqrt(2)/2));     }     else     {         p2 = v898(p2, vector(a1, s * sk));     }       if (pos > 0)     {         if (   pos == 1             || pos == 3             || pos == 4)         {             const aspect = bounds.width / nozero(bounds.height);              p1.y = p0.y + (p1.y - p0.y) * aspect;             p2.y = p0.y + (p2.y - p0.y) * aspect;         }         else if (pos == 2)         {             const aspect = bounds.height / nozero(bounds.width);                          p1.x = p0.x + (p1.x - p0.x) * aspect;             p2.x = p0.x + (p2.x - p0.x) * aspect;         }     }       if (!isLinear)     {         const dv = v898(p0, p1);          p0 = y893(p0, dv);         p2 = y893(p2, dv);     }             if (prop.stops.items.some(i =>                 i             && (   i.position.value < 0                  || i.position.value > 100)))     {         let minPos = prop.stops.items.reduce((min, stop) => Math.min(min, stop.position.value), Number.MAX_SAFE_INTEGER);         let maxPos = prop.stops.items.reduce((max, stop) => Math.max(max, stop.position.value), Number.MIN_SAFE_INTEGER);           if (!isLinear)         {             minPos = Math.max(0, minPos);              if (isAngular)                 maxPos = Math.min(maxPos, 1);         }           const dpos  = Math.min(minPos, 0) / 100;         const dsize = Math.max(100, 100 + Math.max(0, maxPos - 100) - Math.min(minPos, 0)) / 100;          const dv    = v898(p0, p1);           p0 = y893(p0, a895(dv, Math.max(0, -dpos)));         p1 = y893(p1, a895(dv, Math.max(0, -dpos)));         p2 = y893(p2, a895(dv, Math.max(0, -dpos)));           if (!isLinear)         {             const dx = a895(dv, (dsize - 1) / 2);              p0 = y893(p0, dx);             p1 = y893(p1, dx);             p2 = y893(p2, dx);         }           if (!isAngular)         {             p1 = v898(p0, a895(dv, dsize));             p2 = y893(p0, a895(v898(p2, p0), dsize));         }           const positions = prop.stops.items.map(s => s.position.value/100);                  const pos0      = minPos/100;         const pos1      = maxPos/100;                   if (positions.some(p => p < 0))         {             for (let i = 0; i < positions.length; i++)                 prop.stops.items[i].position.value = (positions[i] - pos0) / dsize * 100;         }                  if (positions.some(p => p > 1))         {             for (let i = 0; i < positions.length; i++)                 prop.stops.items[i].position.value = (1 - (pos1 - positions[i]) / dsize) * 100;         }                   for (const stop of prop.stops.items)             stop.position.value = Math.min(Math.max(0, stop.position.value), 100);     }       gradient[1] = [p0, p1, p2];           const stops = prop.stops.items;      for (let j = 0; j < stops.length; j++)     {         const stop = stops[j];          if (stop.fill)         {             const rgba = stop.fill.d99();              gradient[2].push([                 rgba[0],                  rgba[1],                  rgba[2],                  rgba[3],                 stop.position.value / 100]);         }     }       gradient[3] = n1392[prop.blend.value][2];           target.push(gradient); }    function u1827(i1828) {     const stops = [];       for (let i = 0; i < i1828.length; i++)     {         const stop = i1828[i];          if (stop.type == j1167)         {             stops.push(new z2009(                 c2013.t3868(z4234(stop.t3339()), 100),                 k2022.NaN()));         }          else if (stop.type == d1177)             stops.push(new z2009(                 stop,                 k2022.NaN()));          else if (stop.type == q1054)             stops.push(...u1827(stop.items));          else             stops.push(stop);     }       return stops; }    function a1829(stops) {     if (    stops.length > 0         && !stops[0].position.isValid())          stops[0].position = new k2022(0);      if (    stops.length > 1         && (!stops.at(-1).position.isValid()))          stops.at(-1).position = new k2022(100);           if (stops.length > 2)     {         for (let i = 1; i < stops.length-1; i++)         {             const stop = stops[i];              if (   !stop                 || !stop.position                 || !stop.position.isValid())             {                 let prevValid = i-1;                 let nextValid = i+1;                  while ( prevValid > 0                     && !stops[prevValid].position.isValid())                      prevValid--;                  while ( nextValid < stops.length-1                     && !stops[nextValid].position.isValid())                      nextValid++;                                          const pv = stops[prevValid].position.value;                 const nv = stops[nextValid].position.value;                  stop.position = new k2022((pv + (nv - pv) * ((i - prevValid) / (nextValid - prevValid))));              }         }     } }    function q1830(b111, prop) {     for (const fill of prop.fills.items)     {         if (fill.type ==     d1177) n1825    (b111, fill, b111.strokes);         if (fill.type == c1186) p1826(b111, fill, b111.strokes);     }       if (b111.type == v1264)     {         for (const _obj of b111.children)             o1823(_obj, prop);     }     else     {         b111.strokeWeight = prop.weight.toNewValue().value;          switch (prop.fit.toNewValue().value)         {             case 0: b111.strokeAlign = 'INSIDE';  break;             case 1: b111.strokeAlign = 'CENTER';  break;             case 2: b111.strokeAlign = 'OUTSIDE'; break;         }          switch (prop.join.toNewValue().value)         {             case 0: b111.strokeJoin = 'MITER'; break;             case 1: b111.strokeJoin = 'BEVEL'; break;             case 2: b111.strokeJoin = 'ROUND'; break;         }          switch (prop.cap.toNewValue().value)         {             case 0: b111.strokeCap = 'NONE';   break;             case 1: b111.strokeCap = 'SQUARE'; break;             case 2: b111.strokeCap = 'ROUND';  break;         }          b111.strokeDashes     = prop.dashes.toNewValue().value.trim();                  b111.strokeMiterLimit = prop.miter .toNewValue().value;     } }    function addStrokeSidesProp(b111, prop) {     if (b111.type == v1264)     {         for (const _obj of b111.children)             o1823(_obj, prop);     }     else     {         b111.effects.push([            'STROKE_SIDES',              prop.top   .value,             prop.left  .value,             prop.right .value,             prop.bottom.value,             prop.visible ]);     } }    function o1831(b111, prop) {     if (b111.type == v1264)     {         for (const _obj of b111.children)             o1823(_obj, prop);     }     else     {         b111.effects.push([            'ROUND_CORNERS',              prop.tl.value,             prop.tr.value,             prop.bl.value,             prop.br.value,             prop.visible ]);     } }    function j1832(b111, prop) {     const rgba = prop.fill.d99();      b111.effects.push([         'DROP_SHADOW',          rgba[0],         rgba[1],         rgba[2],         rgba[3],         prop.x     .value,          prop.y     .value,          prop.blur  .value,          prop.spread.value,          n1392[prop.blend.value][2],         prop.behind.value > 0,         prop.visible ]); }    function o1833(b111, prop) {     const rgba = prop.fill.d99();      b111.effects.push([         'INNER_SHADOW',          rgba[0],         rgba[1],         rgba[2],         rgba[3],         prop.x     .value,          prop.y     .value,          prop.blur  .value,          prop.spread.value,          n1392[prop.blend.value][2],         prop.visible ]); }    function h1834(b111, prop) {     b111.effects.push([         'LAYER_BLUR',          prop.radius.value,          prop.visible ]); }    function i1835(b111, prop) {     b111.effects.push([         'BACKGROUND_BLUR',          prop.radius.value,          prop.visible ]); }    function w1836(b111, prop) {     b111.opacity = Math.min(Math.max(0, prop.opacity.value  / 100), 1);     b111.blend   = n1392[prop.blend.value][2]; }    function i1837(b111, mask) {     b111.maskType = mask.maskType.value + 1; } 


class h1847 extends k1843 {     skewX;     skewY;      fills   = [];     strokes = [];      strokeWeight;     strokeAlign;     strokeJoin;     strokeMiterLimit;     strokeCap;     strokeDashes;      effects = [];      h3834;     isCenter;     isXform;      opacity;     blend;      maskType = 0;        constructor(type, nodeId, objectId, objectName, h3834 = false, isXform = false)     {         super(type, nodeId, objectId, objectName);          this.skewX    = 0;         this.skewY    = 0;          this.h3834   = h3834;         this.isCenter = false;         this.isXform  = isXform;          this.opacity  = 1;         this.blend    = 'PASS_THROUGH';     }        t3455(base)     {         super.t3455(base);          this.skewX            = base.skewX;         this.skewY            = base.skewY;          this.fills            = clone(base.fills);         this.strokes          = clone(base.strokes);          this.strokeWeight     = base.strokeWeight;         this.strokeAlign      = base.strokeAlign;         this.strokeJoin       = base.strokeJoin;         this.strokeMiterLimit = base.strokeMiterLimit;         this.strokeCap        = base.strokeCap;         this.strokeDashes     = base.strokeDashes;          this.effects          = clone(base.effects);          this.h3834           = base.h3834;         this.isCenter         = base.isCenter;         this.isXform          = base.isXform;          this.opacity          = base.opacity;         this.blend            = base.blend;         this.maskType         = base.maskType;     }        checkFlipped(flipX, flipY)     {         super.checkFlipped(flipX, flipY);          for (const fill   of this.fills  ) flipGradient(fill,   flipX, flipY);         for (const stroke of this.strokes) flipGradient(stroke, flipX, flipY);          const foundSides = this.effects.findIndex(e => e[0] == 'STROKE_SIDES');         if (foundSides > -1) flipStrokeSides(this.effects[foundSides], flipX, flipX);          const foundCorners = this.effects.findIndex(e => e[0] == 'ROUND_CORNERS');         if (foundCorners > -1) flipRoundCorners(this.effects[foundCorners], flipX, flipY);     }        i3836()     {         const weight = this.strokeWeight * Math.abs(this.scaleStyle);          const dashes =              this.strokeDashes             ? this.strokeDashes                 .split(',')                 .map(d => parseFloat(d.trim()) * Math.abs(this.scaleStyle))                 .join(',')             : '';                   return [             ...super.i3836(),                  this.fills,              this.strokes,               weight,              this.strokeAlign,              this.strokeJoin,              this.strokeMiterLimit,              this.strokeCap,              dashes,               this.effects,               this.h3834,              this.isCenter,               this.opacity,              this.blend,              this.maskType         ];     } }    function flipGradient(fill, flipX, flipY) {     if (   fill[0] == 'GRADIENT_LINEAR'         || fill[0] == 'GRADIENT_RADIAL'         || fill[0] == 'GRADIENT_ANGULAR'         || fill[0] == 'GRADIENT_DIAMOND')     {         const p0 = fill[1][0];         const p1 = fill[1][1];         const p2 = fill[1][2];          if (flipX)         {             p0.x = 1 - p0.x;             p1.x = 1 - p1.x;             p2.x = 1 - p2.x;         }          if (flipY)         {             p0.y = 1 - p0.y;             p1.y = 1 - p1.y;             p2.y = 1 - p2.y;         }     } }    function flipStrokeSides(sides, flipX, flipY) {     if (flipX) [sides[2], sides[3]] = [sides[3], sides[2]];     if (flipY) [sides[1], sides[4]] = [sides[4], sides[1]]; }    function flipRoundCorners(corners, flipX, flipY) {     if (flipX)     {         [corners[1], corners[2]] = [corners[2], corners[1]];         [corners[3], corners[4]] = [corners[4], corners[3]];     }      if (flipY)     {         [corners[1], corners[3]] = [corners[3], corners[1]];         [corners[2], corners[4]] = [corners[4], corners[2]];     } }


class o1846 extends h1847 {     x;     y;     width;     height;      round;            constructor(nodeId, objectId, objectName, x, y, width, height, round)     {         super(f1218, nodeId, objectId, objectName);                  this.x      = x;         this.y      = y;         this.width  = width;         this.height = height;          this.round  = round;          this.q3837(             x + width /2,              y + height/2);     }        copy()     {         const copy = new o1846(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.width,             this.height,                          this.round);           copy.t3455(this);           return copy;     }        toNewValue()     {         return g2025.fromObject(this);     }        i3836()     {         return [             ...super.i3836(),                  this.x,              this.y,              this.width,              this.height,               this.round * Math.abs(this.u3835)         ];     } } 


class x1842 extends h1847 {     x;     y;     width;        constructor(nodeId, objectId, objectName, x, y, width)     {         super(y1221, nodeId, objectId, objectName);                  this.x     = x;         this.y     = y;         this.width = width;                   this.q3837(             x + width/2,              y);     }        copy()     {         const copy = new x1842(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.width);           copy.t3455(this);           return copy;     }        toNewValue()     {         return z2020.fromObject(this);     }        i3836()     {         return [             ...super.i3836(),                  this.x,              this.y,              this.width         ];     } }


class k1840 extends h1847 {     x;     y;     width;     height;     round;      start;     sweep;     inner;            constructor(nodeId, objectId, objectName, x, y, width, height, round, start, sweep, inner)     {         super(w1224, nodeId, objectId, objectName);                  this.x      = x;         this.y      = y;         this.width  = width;         this.height = height;         this.round  = round;          this.start  = start;         this.sweep  = sweep;         this.inner  = inner;                   this.q3837(             x + width /2,              y + height/2);     }        copy()     {         const copy = new k1840(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.width,             this.height,             this.round,                          this.start,             this.sweep,             this.inner);           copy.t3455(this);           return copy;     }        toNewValue()     {         return j2012.fromObject(this);     }        i3836()     {         return [             ...super.i3836(),                  this.x,              this.y,              this.width,              this.height,              this.round,               this.start,              this.sweep,              this.inner         ];     } }


class x1853 extends h1847 {     x;     y;     width;     height;          points;      closed;     degree;     winding;       round;          x3841;     q4126;        constructor(nodeId, objectId, objectName, points, closed, degree, winding, round)     {         super(p1249, nodeId, objectId, objectName);                           this.points  = points.map(p => p.copy());             this.closed  = closed;         this.degree  = degree;         this.winding = winding;          this.round   = round;                   this.h3838();     }        copy()     {         const copy = new x1853(             this.nodeId,             this.objectId,             this.objectName,              this.points,              this.closed,             this.degree,             this.winding,              this.round);           copy.x          = this.x;         copy.y          = this.y;         copy.width      = this.width;         copy.height     = this.height;          copy.x3841 = [...this.x3841];         copy.q4126   = this.q4126;           copy.t3455(this);           return copy;     }        t3455(base)     {         super.t3455(base);          if (base.points) this.points = base.points.map(p => p.copy());     }        getBounds()     {         let bounds = j1045.NaN;           switch (this.degree)         {             case 0:                 for (const p of this.x3841)                     bounds = m3840(bounds, p);                  break;              case 1:                 {                     let i;                     for (i = 0; i < this.x3841.length-2; i += 2)                     {                         bounds = l3839(                             bounds,                              t861(                                 this.x3841[i  ],                                  this.x3841[i+1],                                 this.x3841[i+2]));                     }                      if (   this.closed                         && i < this.x3841.length-1)                     {                         bounds = l3839(                             bounds,                              t861(                                 this.x3841.at(-2),                                  this.x3841.at(-1),                                 this.x3841.at( 0)));                     }                      break;                 }             case 2:             case 3:             case 4:             case 5:                 {                     let i;                     for (i = 0; i < this.x3841.length-3; i += 3)                     {                         const b3 = m862(                             this.x3841[i  ],                              this.x3841[i+1],                             this.x3841[i+2],                             this.x3841[i+3]);                          bounds = l3839(                             bounds,                              b3);                     }                      if (   this.closed                         && i < this.x3841.length - 2)                     {                         const b3 = m862(                             this.x3841.at(-3),                              this.x3841.at(-2),                              this.x3841.at(-1),                             this.x3841.at( 0));                          bounds = l3839(                             bounds,                              b3);                     }                      break;                 }             default:                 console.error('invalid curve degree');         }           return bounds;     }        updatePoints(x4300, space)     {         for (let i = 0; i < this.points.length; i++)         {             let p      = this.points[i].m3842();             let smooth = this.points[i].smooth;              p = t3826(p, x4300, space);              this.points[i]        = f2023.fromPoint(this.nodeId, p);             this.points[i].smooth = smooth;         }     }        h3838()     {         switch (this.degree)         {         case 0: this.x3841 = this.points.map(p => p.m3842());                           break;         case 1: this.x3841 = this.points.map(p => p.m3842());                           break;         case 2: this.x3841 = this.points.map(p => p.m3842());                           break;         case 3: this.x3841 = f3848(this.points, this.closed, g4336); break;         case 4: this.x3841 = f3848(this.points, this.closed, m4337 ); break;         case 5: this.x3841 = f3848(this.points, this.closed, a4338 ); break;         }     }        x3844()     {         if (   this.type == p1249             || this.type == n1227)         {             const bounds = this.getBounds();              this.x      = bounds.x;             this.y      = bounds.y;             this.width  = bounds.width;             this.height = bounds.height;              this.z3825(this.x, this.y, this.width, this.height);         }          this.q4126 = e3843(this.x3841, this.closed, this.degree);     }        checkFlipped(flipX, flipY)     {         super.checkFlipped(flipX, flipY);           const bounds = this.getBounds();           for (const point of this.points)         {             if (flipX) point.x.value = bounds.width  - point.x.value;             if (flipY) point.y.value = bounds.height - point.y.value;         }          this.h3838();                                                   }        i3836()     {                  this.x3844();           const oldType = this.type;         this.type = p1249;          const data =          [             ...super.i3836(),                  this.x,              this.y,              this.width,              this.height,               this.q4126,              this.winding,              this.round * Math.abs(this.u3835)         ];          this.type = oldType;           return data;     }        toNewValue()     {         return g2037.fromObject(this);     } }    function e3843(points, closed, degree) {     for (const p of points)         if (   isNaN(p.x)             || isNaN(p.y))             return '';                   let q4126 = '';       switch (degree)     {     case 0: q4126 = u945   (points);         break;      case 1: q4126 = g3845(points, closed); break;      case 2:                                                              case 3:                                                              case 4:                                                              case 5: q4126 = h3846    (points, closed); break;      }       const r3847 =            degree == 0 && points.length > 2         || degree == 1 && points.length > 2         || degree == 2 && points.length > 3         || degree == 3 && points.length > 2         || degree == 4 && points.length > 2         || degree == 5 && points.length > 2;       if (   r3847         && (   closed             || i1017(points[0], points.at(-1))))         q4126 += ' Z';       return q4126; }    function g3845(points, closed) {     let q4126 = '';       if (points.length < 3)         return q4126;       q4126 += 'M';     q4126 += ' ' + a877(points[0].x);     q4126 += ' ' + a877(points[0].y);      let i;     for (i = 1; i < points.length-1; i += 2)     {         q4126 +=                ' Q'             + ' ' + a877(points[i  ].x)             + ' ' + a877(points[i  ].y)             + ' ' + a877(points[i+1].x)             + ' ' + a877(points[i+1].y);     }       if (   points.length - i == 1         && closed)     {         q4126 +=                ' Q'             + ' ' + a877(points.at(-1).x)             + ' ' + a877(points.at(-1).y)             + ' ' + a877(points.at( 0).x)             + ' ' + a877(points.at( 0).y);     }       return q4126; }    function h3846(points, closed) {     let q4126 = '';       if (points.length < 4)         return q4126;       q4126 += 'M';     q4126 += ' ' + a877(points[0].x);     q4126 += ' ' + a877(points[0].y);      let i;     for (i = 1; i < points.length-2; i += 3)     {         q4126 +=                ' C'             + ' ' + a877(points[i  ].x)             + ' ' + a877(points[i  ].y)             + ' ' + a877(points[i+1].x)             + ' ' + a877(points[i+1].y)             + ' ' + a877(points[i+2].x)             + ' ' + a877(points[i+2].y);     }       if (   points.length - i == 2         && closed)     {         q4126 +=                ' C'             + ' ' + a877(points.at(-2).x)             + ' ' + a877(points.at(-2).y)             + ' ' + a877(points.at(-1).x)             + ' ' + a877(points.at(-1).y)             + ' ' + a877(points.at( 0).x)             + ' ' + a877(points.at( 0).y);     }       return q4126; }    function f3848(points, closed, u3849) {     if (points.length < 2)         return '';       const bp = [];            let [pp, p, pn] = u3849(         closed ? points.at(-1) : points[0],          points[0],         points[1]);      bp.push(p);       let _pp = pn;            for (let i = 1; i < points.length; i++)     {         [pp, p, pn] = u3849(             points[i-1],              points[i],             i == points.length-1              ? (closed ? points[0] : points[i])             : points[i+1]);          if (points[i].smooth)             [pp, pn] = k3850(points[i], pp, p, pn);                      bp.push(_pp, pp, p);             _pp = pn;     }       if (bp.length > 3)     {         if (closed)         {             if (   equal(bp[0].x, bp.at(-1).x, 0.01)                 && equal(bp[0].y, bp.at(-1).y, 0.01))             {                                  [pp, p, pn] = u3849(                     points.at(-2),                      points.at( 0),                     points.at( 1));                  if (points[0].smooth)                     [pp, pn] = k3850(points[0], pp, p, pn);                  bp[1]           = pn;                 bp[bp.length-2] = pp;             }             else             {                                  [pp, p, pn] = u3849(                     points.at(-1),                      points.at( 0),                     points.at( 1));                  if (points[0].smooth)                     [pp, pn] = k3850(points[0], pp, p, pn);                  bp.push(_pp, pp, p);                  bp[1]           = pn;                 bp[bp.length-2] = pp;             }         }         else          {             bp[1]           = y893(bp[0],     a895(z884(v898(bp[2],     bp[0]    )), distv(bp[3],     bp[0]    )/3));             bp[bp.length-2] = y893(bp.at(-1), a895(z884(v898(bp.at(-3), bp.at(-1))), distv(bp.at(-4), bp.at(-1))/3));         }     }       return bp; }    function k3850(point, pp, p, pn) {     if (point.smooth)     {         const smooth = point.smooth.value;                  pp = y893(p, a895(v898(pp, p), smooth));         pn = y893(p, a895(v898(pn, p), smooth));     }      return [pp, pn]; }    function g4336(_pointP, _point, _pointN) {     const _pp = point(_pointP.x.value, _pointP.y.value);     let   _p  = point(_point .x.value, _point .y.value);     const _pn = point(_pointN.x.value, _pointN.y.value);       const v = v898(_pn, _pp);               let a = o885(         n881(v898(_p, _pp)),          n881(v898(_pn, _p)));               a = Math.abs(a);     while (a >= Tau/2) a -= Tau;       const k     = 4 * (Math.sqrt(2) - 1) / 3;        // or use the value 0.55191502449 from http://spencermortensen.com/articles/bezier-circle/
	const j2604 = 0.9993391093366649465402826439248;       let f =         a > Tau/4         ? 1/3 + (k*j2604 - 1/3) * Math.sin(a)         : 1/3 + (k*j2604 - 1/3) * (1 - Math.cos(a));           let pp = y893(_p, a895(z884(v), -h883(v)/2 * f));     let pn = y893(_p, a895(z884(v),  h883(v)/2 * f));      pp = v1018(pp);      _p = v1018(_p);      pn = v1018(pn);       return [pp, _p, pn]; }    function m4337(_pointP, _point, _pointN) {     const _pp = point(_pointP.x.value, _pointP.y.value);     const _p  = point(_point .x.value, _point .y.value);     const _pn = point(_pointN.x.value, _pointN.y.value);      const  pp = point(_p.x - (_p.x - _pp.x) * 0.3615, _p.y);     const  pn = point(_p.x + (_pn.x - _p.x) * 0.3615, _p.y);      return [pp, _p, pn]; }    function a4338(_pointP, _point, _pointN) {     const _pp = point(_pointP.x.value, _pointP.y.value);     const _p  = point(_point .x.value, _point .y.value);     const _pn = point(_pointN.x.value, _pointN.y.value);      const  pp = point(_p.x, _p.y - (_p.y - _pp.y) * 0.3615);     const  pn = point(_p.x, _p.y + (_pn.y - _p.y) * 0.3615);      return [pp, _p, pn]; }


class m1852 extends h1847 {     x;     y;     width;     height;          points;     edges;     regions;      networkData;        constructor(nodeId, objectId, objectName, points, edges, regions)     {         super(k1261, nodeId, objectId, objectName);                  this.points  = points .map(p => p.copy());         this.edges   = edges  .map(e => e.copy());         this.regions = regions.map(r => r.copy());           this.updateNetworkData();           let bounds = j1045.NaN;          for (let i = 0; i < this.edges.length; i++)         {             bounds = l3839(                 bounds,                  m862(                     this.edges[i].start.m3842(),                      this.edges[i].start.m3842(),                     this.edges[i].end  .m3842(),                     this.edges[i].end  .m3842()));         }          this.q3837(             bounds.x + bounds.width /2,                         bounds.y + bounds.height/2                     );     }        copy()     {         const copy = new m1852(             this.nodeId,             this.objectId,             this.objectName,              this.points,              this.edges,              this.regions);           copy.x      = this.x;         copy.y      = this.y;         copy.width  = this.width;         copy.height = this.height;           copy.t3455(this);           return copy;     }        updateNetworkData()     {         let minX = Number.MAX_SAFE_INTEGER;         let minY = Number.MAX_SAFE_INTEGER;         let maxX = Number.MIN_SAFE_INTEGER;         let maxY = Number.MIN_SAFE_INTEGER;          for (const p of this.points)         {             minX = Math.min(minX, p.x.value);             minY = Math.min(minY, p.y.value);             maxX = Math.max(maxX, p.x.value);             maxY = Math.max(maxY, p.y.value);         }           this.x      = minX;         this.y      = minY;         this.width  = maxX - minX;         this.height = maxY - minY;          this.z3825(this.x, this.y, this.width, this.height);           this.networkData = getNetworkData(this.points, this.edges, this.regions);     }        getBounds()     {         let bounds = j1045.NaN;          for (let i = 0; i < this.edges.length; i++)         {             const edge = this.edges[i];              const s  = edge.start;             const e  = edge.end;             let   st = edge.z3760;             let   et = edge.f3761;              if (!st.isValid()) st = s.copy();             if (!et.isValid()) et = e.copy();              bounds = l3839(                 bounds,                  m862(                     s .m3842(),                      st.m3842(),                     et.m3842(),                     e .m3842()));         }          return bounds;     }        toNewValue()     {         return m1852.fromObject(this);     }        i3836()     {         return [             ...super.i3836(),                  this.x,              this.y,              this.width,              this.height,               this.networkData         ];     } }    function getNetworkData(points, edges, _regions) {     const vertices = [];     const segments = [];     const regions  = [];       for (const point of points)     {         let join;         let cap;          switch (point.join.value)         {             case 0: join = 'MITER'; break;             case 1: join = 'BEVEL'; break;             case 2: join = 'ROUND'; break;         }              switch (point.cap.value)         {             case 0: cap = 'NONE';   break;             case 1: cap = 'SQUARE'; break;             case 2: cap = 'ROUND';  break;         }              vertices.push(         {             x:            point.x.value,             y:            point.y.value,             strokeJoin:   join,             strokeCap:    cap,             cornerRadius: point.round.value         });     }       for (const edge of edges)     {         segments.push(         {             start: points.findIndex(p => p.r3831 == edge.start.r3831),             end:   points.findIndex(p => p.r3831 == edge.end  .r3831)         });     }       for (const region of _regions)     {         const loops = [];          for (const _loop of region.loops.items)         {             const loop = [];              for (const _edge of _loop.items)                 loop.push(edges.findIndex(e => e.r3831 == _edge.r3831));              loops.push(loop);         }           regions.push(         {             windingRule: region.winding.value == 1 ? 'NONZERO' : 'EVENODD',             loops:       loops,             fills:       y954(region.fills)         });     }       let networkData =      {         vertices: vertices,         segments: segments,         regions:  regions     };       return networkData; }


class g1851 extends x1853 {     width;     height;      round;     bias;        constructor(nodeId, objectId, objectName, x, y, width, height, round, bias)     {         const tw = width * (1 + Math.min(0,  bias/100));         const bw = width * (1 + Math.min(0, -bias/100));                  const tx = x + (width - tw) / 2;         const bx = x + (width - bw) / 2;          const points =         [             f2023.create(nodeId, tx,      y         ),             f2023.create(nodeId, bx,      y + height),             f2023.create(nodeId, bx + bw, y + height),             f2023.create(nodeId, tx + tw, y         )         ];               super(             nodeId,              objectId,             objectName,              points,             1,              0,              0,              round);          this.type   = n1227;          this.x      = x;         this.y      = y;         this.width  = width;         this.height = height;          this.round  = round;         this.bias   = bias;                   this.q3837(             x + width /2,              y + height/2);     }        copy()     {         const copy = new g1851(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.width,             this.height,                          this.round,             this.bias);                       copy.x3841 = [...this.x3841];         copy.q4126   = this.q4126;              copy.t3455(this);                     return copy;     }        toNewValue()     {         return s2034.fromObject(this);     } } 


class w1845 extends h1847 {     x;     y;     width;     height;     round;     corners;        constructor(nodeId, objectId, objectName, x, y, width, height, round, corners)     {         super(w1236, nodeId, objectId, objectName);                  this.x       = x;         this.y       = y;         this.width   = width;         this.height  = height;          this.round   = round;         this.corners = corners;                   this.q3837(             x + width /2,              y + height/2);     }        copy()     {         const copy = new w1845(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.width,             this.height,                          this.round,             this.corners);           copy.t3455(this);           return copy;     }        toNewValue()     {         return z2024.fromObject(this);     }        i3836()     {         return [             ...super.i3836(),                  this.x,              this.y,              this.width,              this.height,               this.round * Math.abs(this.u3835),              this.corners         ];     } } 


class x1849 extends h1847 {     x;     y;     width;     height;      round;     points;     convex;        constructor(nodeId, objectId, objectName, x, y, width, height, round, points, convex)     {         super(t1239, nodeId, objectId, objectName);                  this.x      = x;         this.y      = y;         this.width  = width;         this.height = height;          this.round  = round;         this.points = points;         this.convex = convex;                   this.q3837(             x + width /2,              y + height/2);     }        copy()     {         const copy = new x1849(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.width,             this.height,              this.round,             this.points,             this.convex);          copy.t3455(this);          return copy;     }        toNewValue()     {         return t2030.fromObject(this);     }        i3836()     {         return [             ...super.i3836(),                  this.x,              this.y,              this.width,              this.height,               this.round * Math.abs(this.u3835),              this.points,              this.convex         ];     } } 


class j1850 extends h1847 {     text;          x;     y;     width;     height;          l3852;     b3853;          font;     size;     style;          alignX;     alignY;          lineHeight;     letterSpacing;        constructor(nodeId, objectId, objectName, text, x, y, width, height, font, size, style, alignX, alignY, lineHeight, letterSpacing)     {         super(p1242, nodeId, objectId, objectName);                  this.text          = text;              this.x             = x;         this.y             = y;         this.width         = width;         this.height        = height;              this.l3852      = width;         this.b3853     = height;              this.font          = font;         this.size          = size;         this.style         = style;              this.alignX        = alignX;         this.alignY        = alignY;              this.lineHeight    = lineHeight;         this.letterSpacing = letterSpacing;                   this.q3837(             x + width /2,              y + height/2);     }        copy()     {         const copy = new j1850(             this.nodeId,             this.objectId,             this.objectName,                  this.text,                  this.x,             this.y,             this.width,             this.height,                  this.font,             this.size,             this.style,                  this.alignX,             this.alignY,                  this.lineHeight,             this.letterSpacing);           copy.l3852  = this.l3852;         copy.b3853 = this.b3853;           copy.t3455(this);           return copy;     }        toNewValue()     {         return g2032.fromObject(this);     }        y3851()     {         return {             ...super.y3851(),                 x:             this.x,             y:             this.y,             width:         this.width,             height:        this.height,              l3852:      this.l3852,             b3853:     this.b3853,              text:          this.text,              font:          this.font,             size:          this.size,             style:         this.style,              alignX:        this.alignX,             alignY:        this.alignY,                          lineHeight:    this.lineHeight,             letterSpacing: this.letterSpacing         };     }        i3836()     {         return [             ...super.i3836(),                  this.x,              this.y,              this.width,              this.height,                           this.l3852,              this.b3853,                           this.text,               this.font,              this.size,              this.style,                           this.alignX,              this.alignY,                           this.lineHeight,              this.letterSpacing         ];     } } 


class e1844 extends h1847 {     x;     y;     smooth;        constructor(nodeId, objectId, objectName, x, y, smooth = 1, h3834 = false, isCenter = false, isXform = false)     {         super(d1245, nodeId, objectId, objectName, h3834, isXform);                  this.x        = x;         this.y        = y;         this.smooth   = smooth;         this.isCenter = isCenter;                   this.q3837(x, y);          this.x4190(x, y);     }        copy()     {         const copy = new e1844(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.smooth,             this.h3834,             this.isCenter);          copy.t3455(this);          return copy;     }        getBounds()     {         return new j1045(             this.x - 0.005,              this.y - 0.005,              0.01,              0.01);     }        checkFlipped(flipX, flipY)     {      }        m3842()     {         return point(this.x, this.y);     }        toNewValue()     {         return f2023.fromObject(this);     }        i3836()     {         return [             ...super.i3836(),                  this.x,              this.y         ];     } } 


class a1838 extends h1847 {     operation;      children;        constructor(nodeId, objectId, objectName, operation, children = [])     {         super(p1285, nodeId, objectId, objectName);                  this.operation = operation;                  this.children  = children.map(c => c.copy());     }        copy()     {         const copy = new a1838(             this.nodeId,             this.objectId,             this.objectName,              this.operation,             this.children);          copy.t3455(this);                  return copy;     }        getBounds()     {         return getObjBounds(this.children);     }        s4191(x4300, affectSpace)     {         for (const b111 of this.children)             b111.s4191(x4300, affectSpace);     }        y3851()     {         return {             ...super.y3851(),                 operation: this.operation,             children:  this.children         };     }        i3836()     {         return [             ...super.i3836(),                  this.children.map(o => o.i3836()),              this.operation         ];     } }


class v2638 extends x1853 {     position;                          start;     sweep;            constructor(nodeId, objectId, objectName, pos, x, y, width, height, start, sweep)     {         let points = makeArc_(             point(                 x + width /2,                  y + height/2),              width/2,               start,              start + sweep);                      points = points.map(p => f2023.fromPoint(nodeId, p));           points.forEach(p =>          {             p.y.value =                  pos > 0                 ? p.y.value * height/nozero(width)                 : height/2 + (p.y.value - height/2) * height/nozero(width);              if (   pos == 0                 && width < 0)                  p.x.value += width;         });          if (width  < 0) width  *= -1;         if (height < 0) height *= -1;           super(             nodeId,              objectId,             objectName,             points,             0,               2,               0,               0);                    this.position = pos;         this.x       = x;         this.y       = y;         this.width   = width;         this.height  = height;          this.start    = start;         this.sweep    = sweep;           this.q3837(             x + width /2,             y + height/2);     }        copy()     {         const copy = new v2638(             this.nodeId,             this.objectId,             this.objectName,              this.position,             this.x,             this.y,             this.width,             this.height,                          this.start,             this.sweep);           copy.x3841 = [...this.x3841];         copy.q4126   = this.q4126;          copy.t3455(this);           return copy;     } }


class c2640 extends x1853 {     shape;     _x;     _y;     j3170;     amplitude;     frequency;     offset;     alignX;     alignY;            constructor(nodeId, objectId, objectName, shape, x, y, width, amplitude, frequency, offset, alignX, alignY)     {         let points = makeWave(             shape,              x,             y,             width,              amplitude,              frequency,             offset,             alignX,             alignY);          points = points.map(p => f2023.fromPoint(nodeId, p));           super(             nodeId,              objectId,             objectName,             points,             0,                               shape == 4 ? 2 : 0,              0,                               0);                                    this.shape     = shape;         this._x        = x;         this._y        = y;         this.j3170    = width;         this.amplitude = amplitude;         this.frequency = frequency;         this.offset    = offset;         this.alignX    = alignX;         this.alignY    = alignY;           let height = amplitude;                  this.q3837(             x + width /2,             y + height/2);     }        copy()     {         const copy = new c2640(             this.nodeId,             this.objectId,             this.objectName,              this.shape,             this._x,             this._y,             this.j3170,             this.amplitude,             this.frequency,             this.offset,             this.alignX,             this.alignY);           copy.x3841 = [...this.x3841];         copy.q4126   = this.q4126;          copy.t3455(this);           return copy;     } }


class e1848 extends h1847 {     children;        constructor(nodeId, objectId, objectName, children = [])     {         super(v1264, nodeId, objectId, objectName);                  this.children = children.map(c => c.copy());     }        copy()     {         const copy = new e1848(             this.nodeId,             this.objectId,             this.objectName,              this.children);          copy.t3455(this);          return copy;     }        getCount()     {         let o3431 =             this.children.length > 0             ? super.getCount()             : 0;          for (const b111 of this.children)             o3431 += b111.getCount();          return o3431;     }        q3837(cx = 0, cy = 0)     {         super.q3837(cx, cy);          for (const b111 of this.children)             b111.q3837(cx, cy);     }        resetSpace(bounds, singlePoint = false, cx = 0.5, cy = 0.5, units = 0)     {         super.resetSpace(bounds, false, cx, cy, units);          for (const b111 of this.children)             b111.resetSpace(bounds, false, cx, cy, units);     }        getBounds()     {         return getObjBounds(this.children);     }        s4191(x4300, affectSpace)     {         for (const b111 of this.children)             b111.s4191(x4300, affectSpace);     }        y3851()     {         return {             ...super.y3851(),                 children: this.children         };     }        i3836()     {         return [             ...super.i3836(),                  this.children.map(o => o.i3836())         ];     } }


class e1841 extends h1847 {     x;     y;     width;     height;      round;          clip;      children;        constructor(nodeId, objectId, objectName, x, y, width, height, round, clip, children = [])     {         super(q1267, nodeId, objectId, objectName);                  this.x        = x;         this.y        = y;         this.width    = width;         this.height   = height;              this.round    = round;          this.clip     = clip;              this.children = children.map(c => c.copy());          this.q3837(             x + width /2,              y + height/2);     }        copy()     {         const copy = new e1841(             this.nodeId,             this.objectId,             this.objectName,                  this.x,             this.y,             this.width,             this.height,                  this.round,                this.clip,                  this.children);           copy.t3455(this);           return copy;     }        getCount()     {         let o3431 = super.getCount();          for (const b111 of this.children)             o3431 += b111.getCount();          return o3431;     }            checkFlipped(flipX, flipY)     {         super.checkFlipped(flipX, flipY);          for (const b111 of this.children)         {             b111.checkFlipped(flipX, flipY);              if (flipX)             {                 b111.xp0.x = this.width - b111.xp0.x;                 b111.xp1.x = this.width - b111.xp1.x;                 b111.xp2.x = this.width - b111.xp2.x;             }              if (flipY)             {                 b111.xp0.y = this.height - b111.xp0.y;                 b111.xp1.y = this.height - b111.xp1.y;                 b111.xp2.y = this.height - b111.xp2.y;             }         }     }        y3851()     {         return {             ...super.y3851(),                 x:        this.x,             y:        this.y,             width:    this.width,             height:   this.height,                      round:    this.round,              clip:     this.clip,                      children: this.children         };     }        i3836()     {         return [             ...super.i3836(),                  this.x,              this.y,              this.width,              this.height,               this.round,               this.clip,               this.children.map(o => o.i3836())         ];     } }    


class v2602 extends k1843 {     variableType;     variableValues = [];     aliasIds       = [];            constructor(nodeId, variableId, variableName, variableValues, aliasIds)     {         super(o1059, nodeId, variableId, variableName);                  this.aliasIds = aliasIds;          if (variableValues.length > 0)         {             switch (variableValues[0].type)             {                 case c1090: this.variableType = variableValues[0].isBoolean ? 'BOOLEAN' : 'FLOAT'; break;                 case h1142:   this.variableType = 'STRING'; break;                 case j1167:                  case d1177:   this.variableType = 'COLOR';  break;             }         }           for (const variableValue of variableValues)         {             switch (variableValue.type)             {                 case c1090: this.variableValues.push(variableValue.p3798());     break;                 case h1142:   this.variableValues.push(variableValue.toString());     break;                 case j1167:  this.variableValues.push(variableValue.toRgbObject());  break;                 case d1177:   this.variableValues.push(variableValue.toRgbaObject()); break;             }         }     }        copy()     {         const copy = new v2602(             this.nodeId,             this.variableId,             this.objectName,             [],             []);           copy.variableType   = this.variableType;         copy.variableValues = [...this.variableValues];         copy.aliasIds       = [...this.aliasIds];          copy.t3455(this);           return copy;     }        toNewValue()     {         return y2632.fromObject(this);     }        i3836()     {         const data =          [             ...super.i3836(),                  this.variableType,              this.variableValues.length,              this.aliasIds.map(a => a !== NULL)         ];          for (const val of this.variableValues)             data.push(val);          return data;     } } 


class g1839 {     type;          nodeId = '';      styleId;     styleName;      paints = [];          constructor(nodeId, styleId, styleName)     {         this.type      = a1215;         this.nodeId    = nodeId;          this.styleId   = styleId;         this.styleName = styleName;     }        copy()     {         const copy = new g1839(this.nodeId, this.styleId, this.styleName);            return copy;     }        i3836()     {         return [          this.type,          this.nodeId,           this.styleId,          this.styleName,                   this.paints         ];     } }


class o2042 {     static nextUniqueId = 0;      type;       valid;       listId           = -1;     r3831;      cached           = true;     unknown          = false;      b3916           = NULL;      currentIteration = 0;     iterated         = false;       c3193     = null;        constructor(type, options)      {         this.type    = type;          if (options && options.cached ) this.cached  = options.cached;         if (options && options.unknown) this.unknown = options.unknown;               this.r3831 = o2042.nextUniqueId++;     }        reset()     {                                                                                   this.c3193 = null;     }        copy()     {         h951('abstract type o2042 cannot be copied');         return null;     }        t3455(base)     {                  this.r3831 = base.r3831;     }        v3863()     {         if (    this.input             &&  this.input.v3863             && !this.input.notCondition)             return this.input.v3863();                  return this;     }            toNewValue()     {         return null;     }        toString()      {          return this.type;      }        q2119()     {         return this.toString();     }        isValid()      {         return false;     }            validate()     {         this.valid = true;     }        invalidate()     {         this.valid = false;     }        p4180(parse)     {      }        i4181(parse, from, force = false)     {         if (   this.unknown             || force)             this.valid = false;          return true;     }        v3724(parse, nodeId)     {      }        o3725(parse, nodeId)     {      }        i4179(parse)     {      }        s3727(parse, nodeId)     {      }     } 


class s2050 {     type;     valueId;      parent;      customParams = [];       objects      = null;       valid;         constructor(type, valueId = NULL)      {         this.type    = type;         this.parent  = null;                  this.valueId = NULL;              this.valid   = true;     }        reset() {}        copy()     {         h951('abstract class s2050 cannot be copied');         return null;     }        t3455(base)     {         this.valueId  = base.valueId;         this.r3831 = base.r3831;          this.d3721(base);          if (base.objects)             this.p3722(base.objects);     }        d3721(base)     {         for (const param of base.customParams)             this.customParams.push([param[0], param[1].copy()]);     }        p3722(objects)     {         this.objects = objects.map(o => o.copy());     }                               async eval(parse)     {         return this;     }        w3807()     {         return false;     }        t3728()      {         console.error('cannot call abstract method s2050.t3728()');         console.trace();         return null;     }        toNewValue()     {         return this.copy();     }        q2119()      {          return this.toString();      }        toJsonText(options = {})      {         let json = '';          if (options.quoteValues === true)             json += '"';          json += this.u3800();          if (options.quoteValues === true)             json += '"';          options.lastExpanded = false;                  return json;     }        toString()      {          return this.type;      }        u3800()     {         return this.toString();     }        k3801()     {         return this.toString();     }        n2945(gen)     {         h951('invalid abstract method');         return '';     }        static NaN()     {         h951('invalid abstract method');         return null;     }        isCached()     {         return this.valid;     }        p4180(parse)     {      }        i4181(parse, from, force)     {         this.valid = false;     }        i4179 (parse)     {      } }    function n3932(type, value) {     switch (type)     {         case            n1086: return parseNullValue         (value)[0];          case           q1054:          case    b1055:          case      y1056:          case     f1057: return g3578         (value)[0];          case         c1090: return x2948       (value)[0];         case           h1142: return e2963         (value)[0];         case          j1167: return o2964        (value)[0];          case           d1177: return o3772         (value)[0];         case     i1183: return l2965    (value)[0];         case       c1186: return l3771     (value)[0];         case         b1180: return g3927       (value)[0];         case    e1195: return j3928   (value)[0];         case   y1198: return r3929  (value)[0];         case     w1201: return z3930    (value)[0];         case      d1204: return z3802     (value)[0];         case    d1210: return q3803   (value)[0];         case     e1207: return k3804    (value)[0];          case      s1217: return l3806    (value)[0];         case           p1220: return p3917         (value)[0];         case        g1223: return p3918      (value)[0];         case        j1226: return r3919      (value)[0];         case        f1235: return r3920      (value)[0];         case           f1238: return y3921         (value)[0];         case     x1241: return g3922    (value)[0];         case          v1244: return f3923        (value)[0];         case    q1248: return f3765   (value)[0];         case  s1251: return m3764 (value)[0];         case    p1254: return c3762   (value)[0];         case  x1257: return f3759 (value)[0];         case i1260: return c3758(value)[0];         case  l1286: return r3924 (value)[0];         case    r1263: return d3925   (value)[0];         case       h1230: return parseArcPathValue      (value)[0];         case      a1233: return parseWavePathValue     (value)[0];         case          n1266: return m3926        (value)[0];          case       VARIABLE_VALUE: return parseVariableValue     (value)[0];          case           NULL_VALUE: return null;                  default:              console.error('cannot parse unknown type \'' + type + '\'');             return null;     } }    function y4302(type, value) {     if (   type == c1090         && value.indexOf(',') < 0)         return value;       switch (type)     {         case            n1086: return parseNullValue         (value)[0].k3801();         case           q1054: return g3578         (value)[0].k3801();          case         c1090: return x2948       (value)[0].k3801();         case           h1142: const val = e2963    (value)[0]; return val == '' ? '\'\'' : val.k3801();         case          j1167: return o2964        (value)[0].k3801();         case           d1177: return o3772         (value)[0].k3801();         case     i1183: return l2965    (value)[0].k3801();         case       c1186: return l3771     (value)[0].k3801();         case         b1180: return g3927       (value)[0].k3801();         case    e1195: return j3928   (value)[0].k3801();         case   y1198: return r3929  (value)[0].k3801();         case     w1201: return z3930    (value)[0].k3801();         case      d1204: return z3802     (value)[0].k3801();         case    d1210: return q3803   (value)[0].k3801();         case     e1207: return k3804    (value)[0].k3801();          case      s1217: return l3806    (value)[0].k3801();         case           p1220: return p3917         (value)[0].k3801();         case        g1223: return p3918      (value)[0].k3801();         case        j1226: return r3919      (value)[0].k3801();         case        f1235: return r3920      (value)[0].k3801();         case           f1238: return y3921         (value)[0].k3801();         case     x1241: return g3922    (value)[0].k3801();         case          v1244: return f3923        (value)[0].k3801();         case    q1248: return f3765   (value)[0].k3801();         case  s1251: return m3764 (value)[0].k3801();         case    p1254: return c3762   (value)[0].k3801();         case  x1257: return f3759 (value)[0].k3801();         case i1260: return c3758(value)[0].k3801();         case  l1286: return r3924 (value)[0].k3801();         case    r1263: return d3925   (value)[0].k3801();         case          n1266: return m3926        (value)[0].k3801();                  case       VARIABLE_VALUE: return parseVariableValue     (value)[0].k3801();          case           NULL_VALUE: return NULL_VALUE;     }       h951('cannot display value of type \'' + type + '\''); }    function nanFromType(type) {     switch (type)     {         case            q1054: return          w2021.NaN();          case          c1090: return        k2022.NaN();         case            h1142: return          f2033.NaN();         case           j1167: return         d2010.NaN();         case            d1177: return          c2013.NaN();         case      i1183: return     z2009.NaN();         case        c1186: return      i2015.NaN();         case          b1180: return        t2031.NaN();         case     e1195: return    z2011.NaN();         case    y1198: return   v2016.NaN();         case      w1201: return     w2018.NaN();         case       d1204: return      h2008.NaN();         case     d1210: return    c2017.NaN();         case      e1207: return     u2019.NaN();          case       s1217: return     g2025.NaN();         case            p1220: return          z2020.NaN();         case         g1223: return       j2012.NaN();         case         f1235: return       z2024.NaN();         case            f1238: return          t2030.NaN();         case      x1241: return     g2032.NaN();         case           v1244: return         f2023.NaN();         case     q1248: return    g2037.NaN();         case   s1251: return  d2039.NaN();         case     p1254: return    d2035.NaN();         case   x1257: return  o2038.NaN();         case  i1260: return k2036.NaN();         case   l1286: return  u2027.NaN();         case     r1263: return    q2028.NaN();         case           n1266: return         s2014.NaN();          case        VARIABLE_VALUE: return      y2632.NaN();          case            NULL_VALUE: return          new s4309();     }      h951('cannot determine null value from type \'' + type + '\''); }


class i2043 extends o2042 {     nodeId;     nodeName;      topLevel;      value;          customParams = [];      options      = {};     c3193 = [];               constructor(type, nodeId, options)     {         super(type, options);          this.nodeId   = nodeId;         this.nodeName = options.nodeName;          this.options  = clone(options);          this.valid    = false;         this.topLevel = false;          this.value    = null;     }        reset()     {         this.customParams = [];         this.options      = {};         this.c3193 = [];     }        t3455(base)     {         super.t3455(base);                  this.nodeId   = base.nodeId;         this.nodeName = base.nodeName;          this.d3721(base);          this.options  = clone(base.options);          this.valid    = base.valid;         this.topLevel = base.topLevel;          if (base.value) this.value = base.value.copy();     }        d3721(base)     {         for (const param of base.customParams)             this.customParams.push([param[0], param[1].copy()]);     }        w4334(m3091)     {         return m3091 == 'value'             ?  this.value             :  this[m3091];     }        isCached()     {         return this.options.cached             && this.valid;     }        async eval(parse)     {                   return this;     }        async x4192(parse)     {      }        evalInputOrList(input, evalFunc, nan)     {         if (o955(input.type))         {             this.value = new w2021();                  for (const item of input.items)                 this.value.items.push(evalFunc(item));         }         else             this.value = evalFunc(input);     }        p3722(value, listId = -1)     {         const objects = v3723(value);         const copies  = [];                                  for (let i = 0; i < objects.length; i++)         {             const b111 = u3833(objects[i]);                  b111.nodeId   = this.nodeId;             b111.listId   = listId;                          b111.objectId = b111.objectId + b965 + this.nodeId;                  copies.push(b111);         }          return copies;     }                outputType()     {         return this.value             ? new f2033(                 o955(this.value.type)                 ? h3575(this.value.items)                 : this.value.type)             : new f2033(n1086);     }        outputListType()     {         return this.outputType();     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.unknown)             this.valid = false;          this.iterated = false;     }        v3724(parse, nodeId)     {         this.b3916           = nodeId;         this.currentIteration = 0;     }        o3725(parse, nodeId)     {         this.valid = false;     }        i4179(parse)     {         const q3726 = parse.repeats.findIndex(r => r.repeatId == this.b3916);                  if (   (   q3726 < 0                 || q3726 == parse.repeats.length-1)             && !this.iterated)         {             this.currentIteration++;             this.iterated = true;         }     }        iterateCache(parse, from)     {      }        s3727(parse, nodeId)     {         this.valid            = false;         this.currentIteration = 0;     }            c4193(parse, values, add = false)     {         if (   (    parse.repeats.length == 0                 ||  this.unknown && parse.repeats[0].total == 0                 || !this.unknown                 ||  parse.repeats.at(-1).currentIteration == 0                 ||  parse.repeats.at(-1).currentIteration == parse.repeats.at(-1).total-1)             && parse.solvers.length == 0)         {             if (add) this.c3193.push(...values);             else     this.c3193 = [...values];         }         else if (!add)             this.c3193 = [];     }        p4180(parse)     {                 if (!this.c3193)             return;          for (const value of this.c3193)             a2062(parse, this.nodeId, value[0], value[1]);          this.c3193 = [];     }        i4308()     {         if (   !this.value             || !this.value.objects)             return;           for (let i = 0; i < this.value.objects.length; i++)         {             const b111     =  this.value.objects[i];              b111.nodeId    =  this.nodeId;             b111.objectId +=  b965 + this.nodeId;             b111.listId    = -1;         }     }        updateValueFromParam(m3091, value)     {         this[m3091] = value;             }        setConditionInput(input)     {      } }    function allInputsAreCondensedLists(inputs) {     for (const input of inputs)     {         if (   !input             ||    !isValueListOfCondensedLists(input)                && !o955(input)                &&  input.condensed !== true)              return false;     }      return true; }    async function evalValue(_value, parse, nan = () => new s4309()) {     let value =          _value              ? (await _value.eval(parse)).toNewValue()              : null;      if (   (    value              && !value.isValid())         && nan)          value = nan();      return value; }    async function evalValueOrList(_value, parse)  {      let value = await evalValue(_value, parse);      if (   value         && value.type == q1054)     {         const condensed = value.condensed;                  value = new w2021(value.items);         value.condensed = condensed;     }          return value;                 }    async function evalNumberValue(_value, parse)  {      let value = await evalValue(_value, parse, () => k2022.NaN());       if (   value         && value.type == h1142)         value = new k2022(parseFloat(value.value));      return value;                 }    async function evalBooleanNumberValue(_value, parse)  {      let value = await evalValue(_value, parse, () => k2022.NaN());       if (   value         && value.type == h1142)     {         if (stringIsNumber(value.value))              value = new u2622(parseFloat(value.value) > 0);         else                 {                  if (value.value.trim().toLowerCase() == 'true' ) value = new u2622(true);             else if (value.value.trim().toLowerCase() == 'false') value = new u2622(false);             else                                                  value = u2622.NaN();         }     }      return value;                 }    async function evalNumberOrListValue(_value, parse)  {      let value = await evalValue(_value, parse, () => k2022.NaN());       if (   value         && value.type == h1142)         value = new k2022(parseFloat(value.value));      else if (value           && value.type == q1054           && h3575(value.items) == y1056)     {         const condensed = value.condensed;          value = new w2021(value.items.map(i => new k2022(parseFloat(i.value))));         value.condensed = condensed;     }      return value;                 }    async function evalTextValue(_value, parse)  {      let value = await evalValue(_value, parse, () => new f2033());      if (   value         && value.type == c1090)         value = new f2033(j1004(value.value, value.decimals));      return value;                 }    async function evalTextOrListValue(_value, parse)  {      let value = await evalValue(_value, parse, () => new f2033());      if (   value         && value.type == c1090)         value = new f2033(j1004(value.value, value.decimals));      else if (value           && value.type == q1054           && h3575(value.items) == b1055)     {         const condensed = value.condensed;                  value = new w2021(value.items.map(i => new f2033(j1004(i.value, i.decimals))));         value.condensed = condensed;     }          return value;                 }    async function evalColorValue(_value, parse) {      let value = await evalValue(_value, parse, () => d2010.NaN());       if (   value         && value.type == d1177)         value = value.color;      else if (value           && value.type == i1183)         value = value.fill.color;      return value; }    async function evalFillValue(_value, parse) {      let value = await evalValue(_value, parse, null);           if (   value         && value.type == j1167)         value = new c2013(value);      if (   value         && value.type == i1183)         value = value.fill;      return value;  }    async function evalStrokeValue   (_value, parse) { return await evalValue(_value, parse, () => t2031   .NaN()); } async function evalColorStopValue(_value, parse) { return await evalValue(_value, parse, () => z2009.NaN()); }    async function evalColorStopOrListValue(_value, parse) {     let value = await evalValue(_value, parse, () => z2009.NaN());       if (   value         && value.type == j1167)         value = new z2009(new c2013(value));      else if (value           && value.type == d1177)         value = new z2009(value);      else if (value           && value.type == q1054           && h3575(value.items) == COLOR_LIST_VALUE)     {         const condensed = value.condensed;          value = new w2021(value.items.map(i => new z2009(new c2013(i))));         value.condensed = condensed;     }      else if (value           && value.type == q1054           && h3575(value.items) == FILL_LIST_VALUE)     {         const condensed = value.condensed;          value = new w2021(value.items.map(i => new z2009(i)));         value.condensed = condensed;     }      else if (value           && value.type == q1054)      {                                 }       return value;                 }    async function evalGradientValue      (_value, parse) { return await evalValue(_value, parse, () => i2015      .NaN()); }  async function evalListValue          (_value, parse) { return await evalValue(_value, parse, () => w2021          .NaN()); }  async function evalRectangleValue     (_value, parse) { return await evalValue(_value, parse, () => g2025     .NaN()); } async function evalLineValue          (_value, parse) { return await evalValue(_value, parse, () => z2020          .NaN()); } async function evalPolygonValue       (_value, parse) { return await evalValue(_value, parse, () => z2024       .NaN()); } async function evalTextShapeValue     (_value, parse) { return await evalValue(_value, parse, () => g2032     .NaN()); }  async function evalPointValue         (_value, parse) { return await evalValue(_value, parse, () => f2023         .NaN()); } async function evalVectorPathValue    (_value, parse) { return await evalValue(_value, parse, () => g2037    .NaN()); } async function evalArcPathValue       (_value, parse) { return await evalValue(_value, parse, () => o2608       .NaN()); } async function evalWavePathValue      (_value, parse) { return await evalValue(_value, parse, () => j2605      .NaN()); } async function evalVectorVertexValue  (_value, parse) { return await evalValue(_value, parse, () => d2039  .NaN()); } async function evalVectorEdgeValue    (_value, parse) { return await evalValue(_value, parse, () => d2035    .NaN()); } async function evalVectorRegionValue  (_value, parse) { return await evalValue(_value, parse, () => o2038  .NaN()); }  async function evalFrameValue         (_value, parse) { return await evalValue(_value, parse, () => s2014         .NaN()); }  async function evalInnerShadowValue   (_value, parse) { return await evalValue(_value, parse, () => v2016   .NaN()); } async function evalLayerBlurValue     (_value, parse) { return await evalValue(_value, parse, () => w2018     .NaN()); } async function evalStrokeSidesValue   (_value, parse) { return await evalValue(_value, parse, () => f4364   .NaN()); } async function evalRoundedCornersValue(_value, parse) { return await evalValue(_value, parse, () => RoundedCornersValue.NaN()); } 


class l2044 extends i2043 {     input = null;        reset()     {         super.reset();          this.input = null;     }        t3455(base)     {         super.t3455(base);          if (base.input) this.input = base.input.copy();     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        isValid()     {         return this.input && this.input.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.input) this.input.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.input) this.input.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.input) this.input.i4179(parse);     }        v3863()     {         if (    this.input             &&  this.input.v3863             && !this.input.notCondition)             return this.input.v3863();                  return this;     }        setConditionInput(input)     {         this.input = input;     } }


class s2045 extends i2043 {     o4175 = null;     i4176 = null;        reset()     {         super.reset();          this.o4175 = null;         this.i4176 = null;     }        t3455(base)     {         super.t3455(base);          if (base.o4175) this.o4175 = base.o4175.copy();         if (base.i4176) this.i4176 = base.i4176.copy();     }        isCached()     {         return super.isCached()             && (!this.o4175 || this.o4175.isCached())             && (!this.i4176 || this.i4176.isCached());     }        f4182(node)     {         return this.o4175 && this.o4175.nodeId == node.nodeId             || this.i4176 && this.i4176.nodeId == node.nodeId;     }        isValid()     {         return this.o4175 && this.o4175.isValid()             && this.i4176 && this.i4176.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.o4175) this.o4175.p4180(parse);         if (this.i4176) this.i4176.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.o4175) this.o4175.i4181(parse, from, force);         if (this.i4176) this.i4176.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.o4175) this.o4175.i4179(parse);         if (this.i4176) this.i4176.i4179(parse);     }        v3863()     {         if (    this.o4175             &&  this.o4175.v3863             && !this.o4175.notCondition)             return this.o4175.v3863();                  else if (this.i4176              &&  this.i4176.v3863              && !this.i4176.notCondition)             return this.i4176.v3863();                  return this;     } }


class u2046 extends i2043 {     o4175 = null;     i4176 = null;     z4177 = null;        reset()     {         super.reset();          this.o4175 = null;         this.i4176 = null;         this.z4177 = null;     }        t3455(base)     {         super.t3455(base);          if (base.o4175) this.o4175 = base.o4175.copy();         if (base.i4176) this.i4176 = base.i4176.copy();         if (base.z4177) this.z4177 = base.z4177.copy();     }        isCached()     {         return super.isCached()             && (!this.o4175 || this.o4175.isCached())             && (!this.i4176 || this.i4176.isCached())             && (!this.z4177 || this.z4177.isCached());     }        f4182(node)     {         return this.o4175 && this.o4175.nodeId == node.nodeId             || this.i4176 && this.i4176.nodeId == node.nodeId             || this.z4177 && this.z4177.nodeId == node.nodeId;     }        isValid()     {         return this.o4175 && this.o4175.isValid()             && this.i4176 && this.i4176.isValid()             && this.z4177 && this.z4177.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.o4175) this.o4175.p4180(parse);         if (this.i4176) this.i4176.p4180(parse);         if (this.z4177) this.z4177.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.o4175) this.o4175.i4181(parse, from, force);         if (this.i4176) this.i4176.i4181(parse, from, force);         if (this.z4177) this.z4177.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.o4175) this.o4175.i4179(parse);         if (this.i4176) this.i4176.i4179(parse);         if (this.z4177) this.z4177.i4179(parse);     }        v3863()     {         if (    this.o4175             &&  this.o4175.v3863             && !this.o4175.notCondition)             return this.o4175.v3863();                  else if (this.i4176              &&  this.i4176.v3863              && !this.i4176.notCondition)             return this.i4176.v3863();                  else if (this.z4177              &&  this.z4177.v3863              && !this.z4177.notCondition)             return this.z4177.v3863();                  return this;     } }


class r2047 extends i2043 {     o4175 = null;     i4176 = null;     z4177 = null;     k4178 = null;        reset()     {         super.reset();          this.o4175 = null;         this.i4176 = null;         this.z4177 = null;         this.k4178 = null;     }        t3455(base)     {         super.t3455(base);          if (base.o4175) this.o4175 = base.o4175.copy();         if (base.i4176) this.i4176 = base.i4176.copy();         if (base.z4177) this.z4177 = base.z4177.copy();         if (base.k4178) this.k4178 = base.k4178.copy();     }        isCached()     {         return super.isCached()             && (!this.o4175 || this.o4175.isCached())             && (!this.i4176 || this.i4176.isCached())             && (!this.z4177 || this.z4177.isCached())             && (!this.k4178 || this.k4178.isCached());     }        f4182(node)     {         return this.o4175 && this.o4175.nodeId == node.nodeId             || this.i4176 && this.i4176.nodeId == node.nodeId             || this.z4177 && this.z4177.nodeId == node.nodeId             || this.k4178 && this.k4178.nodeId == node.nodeId;     }        isValid()     {         return this.o4175 && this.o4175.isValid()             && this.i4176 && this.i4176.isValid()             && this.z4177 && this.z4177.isValid()             && this.k4178 && this.k4178.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.o4175) this.o4175.p4180(parse);         if (this.i4176) this.i4176.p4180(parse);         if (this.z4177) this.z4177.p4180(parse);         if (this.k4178) this.k4178.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.o4175) this.o4175.i4181(parse, from, force);         if (this.i4176) this.i4176.i4181(parse, from, force);         if (this.z4177) this.z4177.i4181(parse, from, force);         if (this.k4178) this.k4178.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.o4175) this.o4175.i4179(parse);         if (this.i4176) this.i4176.i4179(parse);         if (this.z4177) this.z4177.i4179(parse);         if (this.k4178) this.k4178.i4179(parse);     }        v3863()     {         if (    this.o4175             &&  this.o4175.v3863             && !this.o4175.notCondition)             return this.o4175.v3863();                  else if (this.i4176              &&  this.i4176.v3863              && !this.i4176.notCondition)             return this.i4176.v3863();                  else if (this.z4177              &&  this.z4177.v3863              && !this.z4177.notCondition)             return this.z4177.v3863();                  else if (this.k4178              &&  this.k4178.v3863              && !this.k4178.notCondition)             return this.k4178.v3863();                  return this;     } }


class g2049 extends i2043 {     m3091;          node;     param;            constructor(nodeId, m3091)     {         super(PARAM, nodeId, false);          this.m3091 = m3091;     }        reset()     {         if (this.node)             this.node.reset();     }        copy()     {         const copy = new g2049(this.nodeId, this.m3091);          copy.t3455(this);          copy.node = this.node;              return copy;     }        v3863()     {         return this.node              ? this.node.v3863()              : null;     }        async eval(parse)     {         this.node = parse.b4335.find(v => v.nodeId == this.nodeId);         c950(this.node, 'can\'t find parameter node \'' + this.nodeId + '\'');           if (    this.node.type != y1079             || !this.node.m4304)             await this.node.eval(parse);           this.param = this.node.w4334(this.m3091);           if (isValid(this.param))         {             if (   this.node.type != k1061                 && this.m3091 != 'from')                 this.value = await evalValue(this.param, parse);             else                 this.value = new s4309();                               return this.value                  ? this.value.copy()                  : null;         }         else             return this.value = new s4309();     }        isCached()     {         return super.isCached();      }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        p4180(parse)     {         super.p4180(parse);          if (this.node) this.node.p4180(parse);     }            i4181(parse, from, force)     {         super.i4181(parse, from, force);                  if (this.node) this.node.i4181(parse, from, force);     }        v3724(parse, nodeId)     {         const node = parse.b4335.find(n => n.nodeId == this.nodeId);                  node.v3724(parse, nodeId);     }        iterateCache(parse, from)     {         const node = parse.b4335.find(n => n.nodeId == this.nodeId);                   node.iterateCache(parse, from);     }        o3725(parse, nodeId)     {         const node = parse.b4335.find(n => n.nodeId == this.nodeId);                  node.o3725(parse, nodeId);     }        v3724(parse, nodeId)     {         const node = parse.b4335.find(n => n.nodeId == this.nodeId);                  node.v3724(parse, nodeId);     }        i4179(parse)     {         const node = parse.b4335.find(n => n.nodeId == this.nodeId);                  node.i4179(parse);     }        s3727(parse, nodeId)     {         const node = parse.b4335.find(n => n.nodeId == this.nodeId);                  node.s3727(parse, nodeId);     } }


class s4309 extends s2050 {     value;        constructor()     {         super(n1086);          this.value = null;     }        copy()     {         const copy = new s4309();          copy.t3455(this);          return copy;     }        equals(_null)     {         return _null             && this.type  == _null.type             && this.value == _null.value;     }        async eval(parse)     {         return this;     }        w3807()     {         return true;     }        isValid()     {         return false;     }        t3728()     {         return this.value;     }        toNewValue()     {         return this.copy();     }        q2119()      {          return this.toString();      }        toString()     {         return 'NULL';     }        u3800()     {         return 'NULL';     }        k3801()     {         return 'NULL';     }        toJsonText(options = {})     {         let json = '';          json += 'null';          return json;     }        n2945(gen)     {         return this.u3800();     }        static NaN()     {         return this;     } }    function parseNullValue(str) {     const _null = new s4309();      return [_null, 1]; } 


class w2021 extends s2050 {     items;      condensed = false;        constructor(items = [])     {         super(q1054);           if (!items)             return;           this.items = [];           for (let i = 0; i < items.length; i++)         {             const item = items[i];             const copy = item.copy();              if (copy.valueId == NULL)                 copy.valueId = i.toString();              this.items.push(copy);              if (   this.objects                 && item.objects)                 this.objects.push(...item.objects.map(o => o.copy()));         }     }        copy()     {         const copy = new w2021(this.items);          copy.t3455(this);          copy.condensed = this.condensed;          return copy;     }        equals(list)     {         if (!list)                                  return false;         if (!(list instanceof w2021))           return false;         if (this.items.length != list.items.length) return false;          for (let i = 0; i < this.items.length; i++)             if (!this.items[i].equals(list.items[i]))                 return false;          return true;     }        async eval(parse)     {         return this.copy();     }        toNewValue()     {         return this.copy();     }        w3807()     {         if (!this.items)             return false;                      for (const item of this.items)             if (!item.w3807())                 return false;          return true;     }        isValid()     {                  return  this.items;              }        q2119()     {         if (!this.items)             return '';           let str = '';                   str += this.items.length;          for (let i = 0; i < this.items.length; i++)         {             const item = this.items[i];              str += ' ' + item.type + ' ';             str += item.q2119();         }           return str;     }        toString()     {         if (!this.items)             return '';           let str = '';                           str += this.items.length;          for (let i = 0; i < this.items.length; i++)         {             const item = this.items[i];              str += ' ' + item.type + ' ';             str += item.toString();         }           return str;     }        u3800()     {         if (!this.items)             return '';           const nItems = Math.min(this.items.length, 10);           let str = '';          for (let i = 0; i < nItems; i++)         {             if (i > 0)                  str += '<br/>';               const item = this.items[i];              if (o955(item.type))             {                 for (let j = 0; j < item.items.length; j++)                 {                     if (j > 0)                          str += ', ';                                          str += item.items[j].u3800();                 }             }             else                 str += item.u3800();         }          if (this.items.length > 10)              str += '<br/>. . .';                  return str;     }        k3801()     {         if (!this.items)             return '';           let str = '';                           str += this.items.length;          for (let i = 0; i < this.items.length; i++)         {             const item = this.items[i];              str += ' ' + item.type + ' ';             str += item.k3801();         }           return str;     }        toJsonText(options = {})     {         let json = '';           let hasNamed = false;          if (options.showNames === true)         {             for (let i = 0; i < this.items.length; i++)             {                 if (this.items[i].valueId != i)                 {                     hasNamed = true;                     break;                 }             }         }           const OB = hasNamed || options.forceBraces === true ? '{' : '[';         const CB = hasNamed || options.forceBraces === true ? '}' : ']';           if (this.items.length > 0)         {             if (options.named)                 json += '\n' + f869(options.tab);                   json += OB + '\n';               const oldNamed = options.named;             options.named = hasNamed;               const WS = s =>                     options.whiteSpace                  && options.lastExpanded                      ? s                      : '';               let lastItemExpanded = null;              for (let i = 0; i < this.items.length; i++)             {                 const item = this.items[i];                  options.tab++;                   const itemJson = item.toJsonText(options);                 const expanded = itemJson.includes('\n');                                   if (   i > 0                     && options.whiteSpace                     && (   expanded                         || lastItemExpanded))                     json += '\n';                                       json += f869(options.tab);                   if (hasNamed)                     json += '"' + item.valueId + '": ';                   json += itemJson;                   if (i < this.items.length-1)                     json += ',';                  json += '\n';                   options.tab--;                  lastItemExpanded = expanded;             }               json += f869(options.tab) + CB;               options.named = oldNamed;              options.lastExpanded = json.includes('\n');         }         else         {             json += OB + CB;             options.lastExpanded = false;         }           return json;     }        static NaN()     {         return new w2021();     } }    function g3578(str, i = -1) {     if (i < 0)     {         str = str.split(' ');         i   = 0;     }                   const q3864  = i;     const k4301 = parseInt(str[i++]);               const list = new w2021();       for (let j = 0; j < k4301; j++)     {         const type = str[i++];          switch (type)         {             case          q1054:               case   b1055:               case     y1056:               case    f1057: { const _list   = g3578        (str, i);  i += _list  [1];  list.items.push(_list  [0]);  break; }               case        c1090: { const num     = x2948      (str[i]);  i += num    [1];  list.items.push(num    [0]);  break; }             case          h1142: { const text    = e2963        (str[i]);  i += text   [1];  list.items.push(text   [0]);  break; }             case         j1167: { const color   = o2964       (str, i);  i += color  [1];  list.items.push(color  [0]);  break; }              case          d1177: { const fill    = o3772        (str, i);  i += fill   [1];  list.items.push(fill   [0]);  break; }             case    i1183: { const stop    = l2965   (str, i);  i += stop   [1];  list.items.push(stop   [0]);  break; }             case      c1186: { const grad    = l3771    (str, i);  i += grad   [1];  list.items.push(grad   [0]);  break; }             case        b1180: { const stroke  = g3927      (str, i);  i += stroke [1];  list.items.push(stroke [0]);  break; }             case   e1195: { const shadow  = j3928  (str, i);  i += shadow [1];  list.items.push(shadow [0]);  break; }             case  y1198: { const shadow  = r3929 (str, i);  i += shadow [1];  list.items.push(shadow [0]);  break; }             case    w1201: { const blur    = z3930   (str, i);  i += blur   [1];  list.items.push(blur   [0]);  break; }             case     d1204: { const blur    = z3802    (str, i);  i += blur   [1];  list.items.push(blur   [0]);  break; }             case   d1210: { const layer   = q3803  (str, i);  i += layer  [1];  list.items.push(layer  [0]);  break; }             case    e1207: { const mask    = k3804   (str[i]);  i += mask   [1];  list.items.push(mask   [0]);  break; }              case     s1217: { const rect    = l3806   (str, i);  i += rect   [1];  list.items.push(rect   [0]);  break; }             case          p1220: { const line    = p3917        (str, i);  i += line   [1];  list.items.push(line   [0]);  break; }             case       g1223: { const ellipse = p3918     (str, i);  i += ellipse[1];  list.items.push(ellipse[0]);  break; }             case       j1226: { const trapeze = r3919     (str, i);  i += trapeze[1];  list.items.push(trapeze[0]);  break; }             case       f1235: { const poly    = r3920     (str, i);  i += poly   [1];  list.items.push(poly   [0]);  break; }             case          f1238: { const star    = y3921        (str, i);  i += star   [1];  list.items.push(star   [0]);  break; }             case    x1241: { const text    = g3922   (str, i);  i += text   [1];  list.items.push(text   [0]);  break; }             case         v1244: { const point   = f3923       (str, i);  i += point  [1];  list.items.push(point  [0]);  break; }             case   q1248: { const path    = f3765  (str, i);  i += path   [1];  list.items.push(path   [0]);  break; }             case l1286: { const bool    = r3924(str, i);  i += bool   [1];  list.items.push(bool   [0]);  break; }             case   r1263: { const group   = d3925  (str, i);  i += group  [1];  list.items.push(group  [0]);  break; }             case         n1266: { const frame   = m3926       (str, i);  i += frame  [1];  list.items.push(frame  [0]);  break; }         }     }           return [         list,          i - q3864]; }    function getValueTypes(values, debug) {     const types = [];      for (const value of values)     {         if (   value.type ==        q1054             || value.type == b1055             || value.type ==   y1056             || value.type ==  f1057)             j947(types, h3575(value.items, debug));          else             j947(types, value.type);     }      return types; }    function finalTypeFromValues(values) {     return finalTypeFromTypes(getValueTypes(values)); }    function h3575(values) {     return n3135(getValueTypes(values)); }    function finalTypeFromTypes(types) {     let _type = n1086;      for (const type of types)     {         if (_type == n1086)             _type = type;          else if (    s1293.includes(_type)                   && !s1293.includes( type))             return n1086;          else if (   !s1293.includes(_type)                   && _type != type)             return n1086;     }      return _type; }    function n3135(types) {     let _type = finalTypeFromTypes(types);               if (  _type ==     c1090)  return     b1055;     else if (  _type ==       h1142)  return       y1056;     else if (  _type == i1183)  return COLOR_STOP_LIST_VALUE;     else if (  _type ==       d1177)  return       FILL_LIST_VALUE;     else if (  _type ==      j1167)  return      COLOR_LIST_VALUE;     else if (s1293.includes(_type)) return      f1057;     else                                   return            q1054; }


class k2022 extends s2050 {     value;     g3884;     decimals;      isBoolean;        constructor(val = Number.NaN, dec = -1, isBoolean = false)     {         super(c1090, 'number');           if (typeof val !== 'number')             h951('NumberValue(value) is ' + typeof val + ', must be a number');                   this.value     = val;         this.g3884 = val;                  this.decimals =                !isNaN(this.value)              && dec == -1              ? v1002(this.value)              : dec;          this.isBoolean = isBoolean;     }        static fromString(str)     {              if (str === 'true' ) return new u2622(true );         else if (str === 'false') return new u2622(false);          else             return new k2022(                 parseFloat(str),                 o1458(str));     }        copy()     {         const copy = new k2022(             this.value,              this.decimals,             this.isBoolean);          copy.g3884 = this.g3884;          copy.t3455(this);          return copy;     }        equals(num)     {         return num             && this.value    == num.value             && this.decimals == num.decimals;     }                               async eval(parse)     {         return this.copy();     }        w3807()     {         return this.value == this.g3884;     }        isValid()     {         return !isNaN(this.value)             && !isNaN(this.decimals);     }        v3824()     {         return new k2022(Math.round(this.value));     }        t3728()     {         return this.p3798();     }        p3798()     {         return d1014(this.value, this.decimals);     }        toString()     {         if (this.isBoolean)             return this.value > 0 ? 'true' : 'false';              else             return v1470(this.value)                   + ','                   + v1470(this.decimals);     }        u3800()     {         if (this.isBoolean)             return this.value > 0 ? 'true' : 'false';              else             return this.isValid()                 ? j1004(this.value, this.decimals)                 : m962;     }        k3801()     {         if (this.isBoolean)             return this.value > 0 ? 'true' : 'false';              else             return v1470(this.value)                  + (!isNaN(this.decimals)                     ? '_' + this.decimals                      : '');     }        n2945(gen)     {         return this.u3800();     }        static NaN()     {         return new k2022(             Number.NaN,              Number.NaN);     } } 


class u2622 extends k2022 {     constructor(value)     {         if (!isValid(value))         {             console.assert(false, 'must specify a boolean value');             console.trace();         }                  super(value ? 1 : 0, 0, true);     }        static NaN()     {         return k2022.NaN();     } }    function x2948(str) {          if (str === 'true' ) return [new u2622(true ), 1];     else if (str === 'false') return [new u2622(false), 1];      else     {         if (str.indexOf(',') < 0)         {             h951('number value \'' + str + '\' missing \',\'');             console.trace();         }           const parts = str.split(',');          const num = new k2022(             h1471(parts[0]),             h1471(parts[1]));          return [num, 1];     } }    function x3931(str) {          if (str === 'true' ) return [new u2622(true ), 1];     else if (str === 'false') return [new u2622(false), 1];      const num =          str == m962         ? k2022.NaN()         : k2022.fromString(str);      return [num, 1]; }


class f2033 extends s2050 {     value;     g3884;        constructor(val = '')     {         super(h1142, 'text');           if (   val !== null             && typeof val !== 'string')         {             console.trace();             h951('TextValue('+val+') is ' + typeof val + ', must be a string');         }           this.value     = val;         this.g3884 = val;               }        copy()     {         const copy = new f2033(this.value);          copy.g3884 = this.g3884;                  copy.t3455(this);          return copy;     }        equals(text)     {         return text             && this.value == text.value;     }        async eval(parse)     {         return this.copy();     }        w3807()     {         this.value == this.g3884;     }        isValid()     {         return this.value !== null;     }        q2119()     {         return encodeURIComponent(this.value);     }        toJsonText(options = {})     {         let json = '';          json += '"' + unescapeString(this.u3800()) + '"';          options.lastExpanded = false;                  return json;     }        t3728()     {         return this.value;     }        toString()     {         return this.value;     }        u3800()     {         const lines = this.value.split('\n');          let str = '';          for (let i = 0; i < Math.min(lines.length, 10); i++)         {             if (i > 0)                 str += '\n';              str += lines[i];         }          if (lines.length > 10)             str += '\n. . .';                  return str;     }        k3801()     {         return '\''               + this.value.replaceAll('\n', '↵')              + '\'';     }        static NaN()     {         return new f2033();     } }    function e2963(str) {     const text = new f2033(decodeURIComponent(str));      return [text, 1]; }


class d2010 extends s2050 {     space;     c1;     c2;     c3;        constructor(space = k2022.NaN(),                  c1    = k2022.NaN(),                  c2    = k2022.NaN(),                  c3    = k2022.NaN())     {         super(j1167, 'color');          this.space  = space.copy();         this.c1     = c1   .copy();         this.c2     = c2   .copy();         this.c3     = c3   .copy();          this.valid  = true;     }        static create(space, c1, c2, c3)     {         c950(typeof space == 'number', 'ColorValue.create() space must be a number');         c950(typeof c1    == 'number', 'ColorValue.create() c1 must be a number');         c950(typeof c2    == 'number', 'ColorValue.create() c2 must be a number');         c950(typeof c3    == 'number', 'ColorValue.create() c3 must be a number');          return new d2010(             new k2022(space, 0),             new k2022(c1,    0),             new k2022(c2,    0),             new k2022(c3,    0));     }        static t3868(rgb)     {         return d2010.create(1, rgb[0], rgb[1], rgb[2]);     }        static b2904(f3296, spaceIndex = -1)     {         if (spaceIndex < 0)             spaceIndex = r4217(f3296[0]);          const space  = n133(spaceIndex);         const factor = g4284(space);          return d2010.create(             spaceIndex,             f3296[1] * factor[0],             f3296[2] * factor[1],             f3296[3] * factor[2]);     }        copy()     {         const copy = new d2010(             this.space.copy(),              this.c1   .copy(),              this.c2   .copy(),              this.c3   .copy());          copy.t3455(this);          return copy;     }        w3807()     {         return this.space.w3807()             && this.c1   .w3807()             && this.c2   .w3807()             && this.c3   .w3807();     }        isValid()     {         return this.space.isValid()             && this.c1   .isValid()             && this.c2   .isValid()             && this.c3   .isValid();     }        equals(col)     {         return col             && this.space.equals(col.space)             && this.c1   .equals(col.c1   )             && this.c2   .equals(col.c2   )             && this.c3   .equals(col.c3   );     }                                              async eval(parse)     {         return this.copy();     }        c3338()     {         if (!this.isValid())             return x3909;          const space = this.space.copy();          space.value = Math.round(Math.min(Math.max(0, space.value), r131.length-1));          return z147(             space,             this.c1,             this.c2,             this.c3);     }        t3728()     {         return this.t3339();     }        t3339()     {         return j4287(this.c3338());     }        d99()     {         return m100(this.t3339());     }        toRgbObject(limit = false)     {         const rgb = j4287(this.c3338());          if (limit && i73(rgb))             return {r: 0.5, g: 0.5, b: 0.5};                  return limit             ? { r: Math.min(Math.max(0, rgb[0]), 1),                 g: Math.min(Math.max(0, rgb[1]), 1),                 b: Math.min(Math.max(0, rgb[2]), 1) }             : { r: rgb[0],                 g: rgb[1],                 b: rgb[2] };     }        toString()     {         return      this.space.toString()              + ' ' + this.c1   .toString()             + ' ' + this.c2   .toString()             + ' ' + this.c3   .toString();     }        u3800()     {         return      this.space.u3800()              + ' ' + this.c1   .u3800()             + ' ' + this.c2   .u3800()             + ' ' + this.c3   .u3800();     }        k3801()     {         return      this.space.k3801()              + ' ' + this.c1   .k3801()             + ' ' + this.c2   .k3801()             + ' ' + this.c3   .k3801();     }        u3800()     {         if (!this.isValid())             return s964;          const rgb = this.t3339();          return z151(rgb, true);     }        toRgbString()     {         if (!this.isValid())             return s964;          const rgb = this.t3339();          return      rgb[0].toString()             + ' ' + rgb[1].toString()             + ' ' + rgb[2].toString();     }        q2119()     {         return this.toString();     }        toJsonText(options = {})      {         const SL  = s => options.singleLine ? ''  : s;         const SL_ = s => options.singleLine ? ' ' : s;           let json = '';                   if (this.space.value == 0)          {             json += '"' + this.u3800() + '"';             options.lastExpanded = false;         }         else         {             if (options.named)                 json += SL('\n' + f869(options.tab));               json += '{' + SL('\n');             options.tab++;              const oldNamed = options.named;             options.named = true;               if (this.space.value > 3)                 json += SL_(f869(options.tab)) + '"space": "' + colorSpaceName(this.space.value).replaceAll(' ', '') + '",' + SL('\n');              const [c1, c2, c3] = getChannelNamesFromSpace(n133(this.space.value));              json += SL_(f869(options.tab)) + '"' + c1 + '": ' + this.c1.toJsonText(options) + ',' + SL('\n');             json += SL_(f869(options.tab)) + '"' + c2 + '": ' + this.c2.toJsonText(options) + ',' + SL('\n');             json += SL_(f869(options.tab)) + '"' + c3 + '": ' + this.c3.toJsonText(options)       + SL('\n');               options.named = oldNamed;              options.tab--;             json += SL_(f869(options.tab)) + '}';               options.lastExpanded = !options.singleLine;         }          return json;     }        static NaN()     {         return new d2010(             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN());     } }    function o2964(str, i = -1) {     if (i < 0)     {         str = str.split(' ');         i   = 0;     }               const q3864 = i;      const space = x2948(str[i]); i += space[1];     const c1    = x2948(str[i]); i += c1   [1];     const c2    = x2948(str[i]); i += c2   [1];     const c3    = x2948(str[i]); i += c3   [1];       return [         new d2010(space ? space[0] : new k2022(1), c1[0], c2[0], c3[0]),          i - q3864 ]; }


class c2013 extends s2050 {     color;     opacity;     blend;        constructor(color   = d2010.NaN(),                  opacity = new k2022(100),                 blend   = new k2022(0))     {         super(d1177, 'fill');          this.color   = color  .copy();         this.opacity = opacity.copy();         this.blend   = blend  .copy();          this.valid   = true;     }            static t3868(rgb, opacity, blend = 0)     {         c950(             typeof opacity == 'number',             'opacity must be a number');          return new c2013(             d2010.t3868(rgb),             new k2022(opacity),             new k2022(blend));     }        static create(r, g, b, opacity, blend = 0)     {         c950(             typeof opacity == 'number',             'opacity must be a number');          return new c2013(             d2010.create(1, r, g, b),             new k2022(opacity),             new k2022(blend));     }        copy()     {         const copy = new c2013(             this.color  .copy(),             this.opacity.copy(),             this.blend  .copy());          copy.t3455(this);          return copy;     }        equals(fill)     {         return this.color  .equals(fill.color  )             && this.opacity.equals(fill.opacity)             && this.blend  .equals(fill.blend  );     }                                                   async eval(parse)     {         return this.copy();     }        t3728()     {         return this.d99();     }        d99()     {         return [             ...this.color.t3339(),             this.opacity.value / 100 ];     }        toRgbaObject(limit = false)     {         const rgba = m100(             j4287(this.color.c3338()),             this.opacity.value / 100);          if (limit && i73(rgba))             return {r: 0.5, g: 0.5, b: 0.5};                  return limit             ? { r: Math.min(Math.max(0, rgba[0]), 1),                 g: Math.min(Math.max(0, rgba[1]), 1),                 b: Math.min(Math.max(0, rgba[2]), 1),                 a: Math.min(Math.max(0, rgba[3]), 1) }             : { r: rgba[0],                 g: rgba[1],                 b: rgba[2],                 a: rgba[3] };     }        toString()     {         const rgb = z4234(this.color.t3339());          return        new k2022(rgb[0]).toString()               + ' ' + new k2022(rgb[1]).toString()               + ' ' + new k2022(rgb[2]).toString()               + ' ' + this.opacity           .toString()               + ' ' + this.blend             .toString();     }        u3800()     {         const rgb = z4234(this.color.t3339());          return        new k2022(rgb[0]).u3800()               + ' ' + new k2022(rgb[1]).u3800()               + ' ' + new k2022(rgb[2]).u3800()               + ' ' + this.opacity           .u3800()               + ' ' + this.blend             .u3800();     }        k3801()     {         const rgb = z4234(this.color.t3339());          return        new k2022(rgb[0]).k3801()               + ' ' + new k2022(rgb[1]).k3801()               + ' ' + new k2022(rgb[2]).k3801()               + ' ' + this.opacity           .k3801()               + ' ' + this.blend             .k3801();     }        toJsonText(options = {})      {         const WS = s =>                 options.whiteSpace              && options.lastExpanded                  ? s                  : '';           let json = '';                   if (    options.named             ||     options.whiteSpace                && !options.lastExpanded)             json += '\n' + f869(options.tab);           json += '{\n';         options.tab++;          const oldNamed = options.named;         options.named = true;           json += f869(options.tab) + '"color": '   + this.color  .toJsonText(options) + ',\n';         json += WS('\n');         json += f869(options.tab) + '"opacity": ' + this.opacity.toJsonText(options) + ',\n';         json += f869(options.tab) + '"blend": "'  + n1392[this.blend.value][1]  + '"\n';           options.named = oldNamed;          options.tab--;         json += f869(options.tab) + '}';           options.lastExpanded = true;          return json;     }        w3807()     {         return this.color  .w3807()             && this.opacity.w3807()             && this.blend  .w3807();     }        isValid()     {         return this.color  .isValid()             && this.opacity.isValid()             && this.blend  .isValid();     }        static NaN()     {         return new c2013(             d2010 .NaN(),             k2022.NaN(),             k2022.NaN());     }        static default = Object.freeze(c2013.create(217, 217, 217, 100)); }    function o3772(str, i = -1) {     if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const q3864 = i;      const r   = x2948(str[i]); i += r  [1];     const g   = x2948(str[i]); i += g  [1];     const b   = x2948(str[i]); i += b  [1];     const a   = x2948(str[i]); i += a  [1];     const bl  = x2948(str[i]); i += bl [1];           return [         new c2013(             new d2010(new k2022(1), r[0], g[0], b[0]),              a [0],              bl[0]),         i - q3864 ]; }               


class z2009 extends s2050 {     fill;     position;        constructor(fill     = c2013  .NaN(),                  position = k2022.NaN())     {         if (fill.type != d1177)             h951('fill.type is ' + fill.type + ', must be FILL_VALUE');           super(i1183, 'colorStop');          this.fill     = fill    .copy();         this.position = position.copy();          this.valid    = true;     }            copy()     {         const copy = new z2009(             this.fill    .copy(),             this.position.copy());          copy.t3455(this);          return copy;     }        isValid()     {         return this.fill    .isValid()             && this.position.isValid();     }        equals(stop)     {         return stop             && this.fill    .equals(stop.fill    )             && this.position.equals(stop.position);     }        async eval(parse)     {         return this;     }        toNewValue()     {         return this.copy();     }        d99()     {         return this.fill.d99();     }        toString()     {         return      this.fill    .toString()             + ' ' + this.position.toString();     }        u3800()     {         return      this.fill    .u3800()             + ' ' + this.position.u3800();     }        k3801()     {         return      this.fill    .k3801()             + ' ' + this.position.k3801();     }        toJsonText(options = {})      {         const WS = s => options.whiteSpace ? s : '';           let json = '';                   if (options.named)             json += '\n' + f869(options.tab);           json += '{\n';         options.tab++;          const oldNamed = options.named;         options.named = true;           json += f869(options.tab) + '"fill": '     + this.fill    .toJsonText(options) + ',\n';         json += WS('\n');         json += f869(options.tab) + '"position": ' + this.position.toJsonText(options) + '\n';           options.named = oldNamed;          options.tab--;         json += f869(options.tab) + '}';           options.lastExpanded = true;          return json;     }        static NaN()     {         return new z2009(             c2013  .NaN(),             k2022.NaN());     } }    function l2965(str, i = -1) {     if (   i <  0 && str    == m962         || i >= 0 && str[i] == m962)         return [z2009.NaN(), 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const q3864 = i;      const fill     = o3772  (str, i); i += fill    [1];     const position = x2948(str[i]); i += position[1];       return [         new z2009(fill[0], position[0]),         i - q3864 ]; }


class i2015 extends s2050 {     stops;       h3782;     position;     x;     y;     size;     angle;     aspect;     skew;     blend;      diagAspect;        constructor(stops      = new w2021(),                 h3782   = new k2022(0),                 position   = new k2022(0),                 x          = new k2022(0),                 y          = new k2022(0),                 size       = new k2022(0),                 angle      = new k2022(0),                 aspect     = new k2022(0),                 diagAspect = false,                 skew       = new k2022(0),                 blend      = new k2022(0))     {         super(c1186, 'gradient');          this.stops      = stops   .copy();         this.h3782   = h3782.copy();         this.position   = position.copy();         this.x          = x       .copy();         this.y          = y       .copy();         this.size       = size    .copy();         this.angle      = angle   .copy();         this.aspect     = aspect  .copy();         this.diagAspect = diagAspect;         this.skew       = skew    .copy();         this.blend      = blend   .copy();          this.valid      = true;     }            copy()     {         const copy = new i2015(             this.stops,             this.h3782,             this.position,             this.x,             this.y,             this.size,             this.angle,             this.aspect,             this.diagAspect,             this.skew,             this.blend);          copy.t3455(this);          return copy;     }        isValid()     {         return this.stops   .isValid()             && this.h3782.isValid()             && this.position.isValid()             && this.x       .isValid()             && this.y       .isValid()             && this.size    .isValid()             && this.angle   .isValid()             && this.aspect  .isValid()             && this.skew    .isValid()             && this.blend   .isValid();     }        equals(grad)     {         return grad             && this.stops   .equals(grad.stops   )             && this.h3782.equals(grad.h3782)             && this.position.equals(grad.position)             && this.x       .equals(grad.x       )             && this.y       .equals(grad.y       )             && this.size    .equals(grad.size    )             && this.angle   .equals(grad.angle   )             && this.aspect  .equals(grad.aspect  )             && this.diagAspect == grad.diagAspect             && this.skew    .equals(grad.skew    )             && this.blend   .equals(grad.blend   );     }        async eval(parse)     {         return this;     }        toNewValue()     {         return this.copy();     }        toString()     {         return      this.stops   .toString()             + ' ' + this.h3782.toString()             + ' ' + this.position.toString()             + ' ' + this.x       .toString()             + ' ' + this.y       .toString()             + ' ' + this.size    .toString()             + ' ' + this.angle   .toString()             + ' ' + this.aspect  .toString()             + ' ' + (this.diagAspect ? '1' : '0')             + ' ' + this.skew    .toString()             + ' ' + this.blend   .toString();     }        d99()     {         let rgba = rgba_NaN;          for (const stop of this.stops.items)         {             rgba =                  w74(rgba)                 ? stop.fill.d99()                 : rgbaMuls(rgbaAdd(rgba, stop.fill.d99()), 0.5);         }          return rgba;     }            u3800()     {         return      this.stops   .u3800()             + ' ' + this.h3782.u3800()             + ' ' + this.position.u3800()             + ' ' + this.x       .u3800()             + ' ' + this.y       .u3800()             + ' ' + this.size    .u3800()             + ' ' + this.angle   .u3800()             + ' ' + this.aspect  .u3800()             + ' ' + (this.diagAspect ? '1' : '0')             + ' ' + this.skew    .u3800()             + ' ' + this.blend   .u3800();     }        k3801()     {         return      this.stops   .k3801()             + ' ' + this.h3782.k3801()             + ' ' + this.position.k3801()             + ' ' + this.x       .k3801()             + ' ' + this.y       .k3801()             + ' ' + this.size    .k3801()             + ' ' + this.angle   .k3801()             + ' ' + this.aspect  .k3801()             + ' ' + (this.diagAspect ? '1' : '0')             + ' ' + this.skew    .k3801()             + ' ' + this.blend   .k3801();     }        toJsonText(options = {})      {         let json = '';                   if (options.named)             json += '\n' + f869(options.tab);                   json += '{\n';         options.tab++;          const oldNamed = options.named;         options.named = true;           json += f869(options.tab) + '"stops": '    + this.stops   .toJsonText(options) + ',\n';         json += f869(options.tab) + '"h3782": ' + this.h3782.toJsonText(options) + ',\n';         json += f869(options.tab) + '"position": ' + this.position.toJsonText(options) + ',\n';         json += f869(options.tab) + '"x": '        + this.x       .toJsonText(options) + ',\n';         json += f869(options.tab) + '"y": '        + this.y       .toJsonText(options) + ',\n';         json += f869(options.tab) + '"size": '     + this.size    .toJsonText(options) + ',\n';         json += f869(options.tab) + '"angle": '    + this.angle   .toJsonText(options) + ',\n';         json += f869(options.tab) + '"aspect": '   + this.aspect  .toJsonText(options) + ',\n';         json += f869(options.tab) + '"skew": '     + this.skew    .toJsonText(options) + ',\n';         json += f869(options.tab) + '"blend": "'   + n1392[this.blend.value][1]   + '"\n';           options.named = oldNamed;          options.tab--;         json += f869(options.tab) + '}';           options.lastExpanded = true;          return json;     }        static NaN()     {         return new i2015(             w2021  .NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             false,             k2022.NaN(),             k2022.NaN());     } }    function l3771(str, i = -1) {     if (   i <  0 && str    == m962         || i >= 0 && str[i] == m962)         return [i2015.NaN(), 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const q3864 = i;      const stops      = g3578  (str, i); i += stops   [1];     const h3782   = x2948(str[i]); i += h3782[1];     const position   = x2948(str[i]); i += position[1];     const x          = x2948(str[i]); i += x       [1];     const y          = x2948(str[i]); i += y       [1];     const size       = x2948(str[i]); i += size    [1];     const angle      = x2948(str[i]); i += angle   [1];     const aspect     = x2948(str[i]); i += aspect  [1];     const diagAspect = parseInt(str[i]) == 1;    i ++;     const skew       = x2948(str[i]); i += skew    [1];     const blend      = x2948(str[i]); i += blend   [1];       return [         new i2015(             stops   [0],              h3782[0],              position[0],             x       [0],              y       [0],              size    [0],              angle   [0],              aspect  [0],              diagAspect,             skew    [0],              blend   [0]),         i - q3864 ]; }


class t2031 extends s2050 {     fills;     weight;     fit;     join;     miter;     cap;     dashes;        constructor(fills  = new w2021(),                  weight = new k2022(1),                 fit    = new k2022(0),                 join   = new k2022(0),                 miter  = new k2022(28.96, 2),                 cap    = new k2022(0),                 dashes = new f2033())     {         if (fills.type != q1054)             h951('fill.type is ' + fills.type + ', must be LIST_VALUE');           super(b1180, 'stroke');          this.fills  = fills .copy();         this.weight = weight.copy();         this.fit    = fit   .copy();         this.join   = join  .copy();         this.miter  = miter .copy();         this.cap    = cap   .copy();         this.dashes = dashes.copy();          this.valid  = true;     }            copy()     {         const copy = new t2031(             this.fills .copy(),             this.weight.copy(),             this.fit   .copy(),             this.join  .copy(),             this.miter .copy(),             this.cap   .copy(),             this.dashes.copy());          copy.t3455(this);          return copy;     }        w3807()     {         return this.fills .w3807()             && this.weight.w3807()             && this.fit   .w3807()             && this.join  .w3807()             && this.miter .w3807()             && this.cap   .w3807()             && this.dashes.w3807();     }        isValid()     {         return this.fills .isValid()             && this.weight.isValid()             && this.fit   .isValid()             && this.join  .isValid()             && this.miter .isValid()             && this.cap   .isValid()             && this.dashes.isValid();     }        equals(stroke)     {         return stroke             && this.fills .equals(stroke.fill  )             && this.weight.equals(stroke.weight)             && this.fit   .equals(stroke.fit   )             && this.join  .equals(stroke.join  )             && this.miter .equals(stroke.miter )             && this.cap   .equals(stroke.cap   )             && this.dashes.equals(stroke.dashes);     }        async eval(parse)     {         return this.copy();     }        toNewValue()     {         return this.copy();     }        d99()     {         return this.fills             && this.fills.items.length > 0              ? a84(                  this.fills.items[0]    .d99(),                  this.fills.items.at(-1).d99(),                  0.5)              : rgba_NaN;     }        toString()     {         return      this.fills .toString()             + ' ' + this.weight.toString()             + ' ' + this.fit   .toString()             + ' ' + this.join  .toString()             + ' ' + this.miter .toString()             + ' ' + this.cap   .toString()             + ' ' + this.dashes.toString();     }        u3800()     {         return      this.fills .u3800()             + ' ' + this.weight.u3800()             + ' ' + this.fit   .u3800()             + ' ' + this.join  .u3800()             + ' ' + this.miter .u3800()             + ' ' + this.cap   .u3800()             + ' ' + this.dashes.u3800();     }        k3801()     {         return      this.fills .k3801()             + ' ' + this.weight.k3801()             + ' ' + this.fit   .k3801()             + ' ' + this.join  .k3801()             + ' ' + this.miter .k3801()             + ' ' + this.cap   .k3801()             + ' ' + this.dashes.k3801();     }        toJsonText(options = {})     {         const WS = s =>                 options.whiteSpace              && options.lastExpanded                 ? s                  : '';           let json = '';                   if (options.named)             json += '\n' + f869(options.tab);           json += '{\n';         options.tab++;          const oldNamed = options.named;         options.named = true;           json += f869(options.tab) + '"fills": '   + this.fills  .toJsonText(options) + ',\n';         json += WS('\n');         json += f869(options.tab) + '"weight": ' + this.weight.toJsonText(options) + ',\n';         json += f869(options.tab) + '"align": "' + StrokeAlign[this.fit .value]    + '",\n';         json += f869(options.tab) + '"join": "'  + StrokeJoin [this.join.value]    + '",\n';         json += f869(options.tab) + '"miter": '  + this.miter .toJsonText(options) + ',\n';         json += f869(options.tab) + '"cap": "'   + StrokeCap[this.cap.value]       + '",\n';         json += f869(options.tab) + '"dashes": ' + this.dashes.toJsonText(options) + '\n';           options.named = oldNamed;          options.tab--;         json += f869(options.tab) + '}';           options.lastExpanded = true;          return json;     }        static NaN()     {         return new t2031(          new w2021(),          k2022.NaN(),          k2022.NaN(),          k2022.NaN(),          k2022.NaN(),          k2022.NaN(),          new f2033());     }        static default = Object.freeze(new t2031(         new w2021(),         new k2022(1),         new k2022(0),         new k2022(0),         new k2022(28.96),         new k2022(0),         new f2033())); }    function g3927(str, i = -1) {     if (   i <  0 && str    == m962         || i >= 0 && str[i] == m962)         return [t2031.NaN(), 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const q3864 = i;      const fills  = g3578  (str, i); i += fills [1];     const weight = x2948(str[i]); i += weight[1];     const fit    = x2948(str[i]); i += fit   [1];     const join   = x2948(str[i]); i += join  [1];     const miter  = x2948(str[i]); i += miter [1];     const cap    = x2948(str[i]); i += cap   [1];     const dashes = e2963  (str[i]); i += dashes[1];      return [          new t2031(             fills [0],              weight[0],              fit   [0],              join  [0],              miter [0],              cap   [0],              dashes[0]),                  i - q3864 ]; } 


class f4364 extends s2050 {     top;     left;     right;     bottom;     visible;        constructor(top     = new k2022(0),                  left    = new k2022(0),                  right   = new k2022(0),                  bottom  = new k2022(0),                  visible = true)     {         super(y1189, 'strokeSides');          this.top     = top;         this.left    = left;         this.right   = right;         this.bottom  = bottom;         this.visible = visible;     }            copy()     {         const copy = new f4364(             this.top   .copy(),             this.left  .copy(),             this.right .copy(),             this.bottom.copy(),             this.visible);          copy.t3455(this);          return copy;     }        equals(sides)     {         return this.top   .equals(sides.tl)             && this.left  .equals(sides.tr)             && this.right .equals(sides.bl)             && this.bottom.equals(sides.br)             && this.visible === sides.visible;     }        async eval(parse)     {         return this;     }        toString()     {         return      this.top   .toString()             + ' ' + this.left  .toString()             + ' ' + this.right .toString()             + ' ' + this.bottom.toString();     }        u3800()     {         return      this.top   .u3800()             + ' ' + this.left  .u3800()             + ' ' + this.right .u3800()             + ' ' + this.bottom.u3800();     }        k3801()     {         return      this.top   .k3801()             + ' ' + this.left  .k3801()             + ' ' + this.right .k3801()             + ' ' + this.bottom.k3801();     }        isValid()     {         return this.top   .isValid()             && this.left  .isValid()             && this.right .isValid()             && this.bottom.isValid();     }        toJsonText(options = {})      {         let json = '';                   if (options.named)             json += '\n' + f869(options.tab);           json += '{\n';         options.tab++;          const oldNamed = options.named;         options.named = true;           json += f869(options.tab) + '"top": '    + this.top   .toJsonText(options) + ',\n';         json += f869(options.tab) + '"left": '   + this.left  .toJsonText(options) + ',\n';         json += f869(options.tab) + '"right": '  + this.right .toJsonText(options) + ',\n';         json += f869(options.tab) + '"bottom": ' + this.bottom.toJsonText(options) + '\n';           options.named = oldNamed;          options.tab--;         json += f869(options.tab) + '}';           return json;     }        static NaN()     {         return new f4364(             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             false);     } }    function parseStrokeSidesValue(str, i = -1) {     if (   i <  0 && str    == m962         || i >= 0 && str[i] == m962)         return [f4364.NaN(), 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const q3864 = i;      const top    = x2948(str[i]); i += top   [1];     const left   = x2948(str[i]); i += left  [1];     const right  = x2948(str[i]); i += right [1];     const bottom = x2948(str[i]); i += bottom[1];       const sides = new f4364(         top   [0],         left  [0],         right [0],         bottom[0]);       return [sides, i - q3864]; } 


class r2026 extends s2050 {     tl;     tr;     bl;     br;     visible;        constructor(tl = new k2022(0),                  tr = new k2022(0),                  bl = new k2022(0),                  br = new k2022(0),                  visible = true)     {         super(r1192, 'roundCorners');          this.tl      = tl;         this.tr      = tr;         this.bl      = bl;         this.br      = br;         this.visible = visible;     }            copy()     {         const copy = new r2026(             this.tl.copy(),             this.tr.copy(),             this.bl.copy(),             this.br.copy(),             this.visible);          copy.t3455(this);          return copy;     }        equals(corners)     {         return this.tl.equals(corners.tl)             && this.tr.equals(corners.tr)             && this.bl.equals(corners.bl)             && this.br.equals(corners.br)             && this.visible === corners.visible;     }        async eval(parse)     {         return this;     }        toString()     {         return      this.tl.toString()             + ' ' + this.tr.toString()             + ' ' + this.bl.toString()             + ' ' + this.br.toString();     }        u3800()     {         return      this.tl.u3800()             + ' ' + this.tr.u3800()             + ' ' + this.bl.u3800()             + ' ' + this.br.u3800();     }        k3801()     {         return      this.tl.k3801()             + ' ' + this.tr.k3801()             + ' ' + this.bl.k3801()             + ' ' + this.br.k3801();     }        toJsonText(options = {})      {         let json = '';                   if (options.named)             json += '\n' + f869(options.tab);           json += '{\n';         options.tab++;          const oldNamed = options.named;         options.named = true;           json += f869(options.tab) + '"topLeft": '     + this.tl.toJsonText(options) + ',\n';         json += f869(options.tab) + '"topRight": '    + this.tr.toJsonText(options) + ',\n';         json += f869(options.tab) + '"bottomLeft": '  + this.bl.toJsonText(options) + ',\n';         json += f869(options.tab) + '"bottomRight": ' + this.br.toJsonText(options) + '\n';           options.named = oldNamed;          options.tab--;         json += f869(options.tab) + '}';           return json;     }        isValid()     {         return this.tl.isValid()             && this.tr.isValid()             && this.bl.isValid()             && this.br.isValid();     }        static NaN()     {         return new r2026(             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             false);     } }    function a3933(str, i = -1) {     if (   i <  0 && str    == m962         || i >= 0 && str[i] == m962)         return [r2026.NaN(), 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const q3864 = i;      const tl = x2948(str[i]); i += tl[1];     const tr = x2948(str[i]); i += tr[1];     const bl = x2948(str[i]); i += bl[1];     const br = x2948(str[i]); i += br[1];       const corners = new r2026(         tl[0],         tr[0],         bl[0],         br[0]);       return [corners, i - q3864]; } 


class z2011 extends s2050 {     x;     y;     blur;     spread;     fill;     blend;     behind;     visible;        constructor(x       = new k2022(0),                  y       = new k2022(0),                  blur    = new k2022(0),                  spread  = new k2022(0),                  fill    = c2013.NaN(),                 blend   = new k2022(0),                 behind  = new k2022(0),                 visible = true)     {         super(e1195, 'dropShadow');          this.x       = x;         this.y       = y;         this.blur    = blur;         this.spread  = spread;         this.fill    = fill;         this.blend   = blend;         this.behind  = behind;         this.visible = visible;                  c950(fill.type == d1177, 'fill.type must be FILL_VALUE');     }                                             copy()     {         const copy = new z2011(             this.x     .copy(),             this.y     .copy(),             this.blur  .copy(),             this.spread.copy(),             this.fill  .copy(),             this.blend .copy(),             this.behind.copy(),             this.visible);          copy.t3455(this);          return copy;     }        equals(shadow)     {         return this.x     .equals(shadow.x     )             && this.y     .equals(shadow.y     )             && this.blur  .equals(shadow.blur  )             && this.spread.equals(shadow.spread)             && this.fill  .equals(shadow.fill  )             && this.blend .equals(shadow.blend )             && this.behind.equals(shadow.behind)             && this.visible === shadow.visible;     }        async eval(parse)     {         return this;     }        toString()     {         return      this.x     .toString()             + ' ' + this.y     .toString()             + ' ' + this.blur  .toString()             + ' ' + this.spread.toString()             + ' ' + this.fill  .toString()             + ' ' + this.blend .toString()             + ' ' + this.behind.toString();     }        u3800()     {         return      this.x     .u3800()             + ' ' + this.y     .u3800()             + ' ' + this.blur  .u3800()             + ' ' + this.spread.u3800()             + ' ' + this.fill  .u3800()             + ' ' + this.blend .u3800()             + ' ' + this.behind.u3800();     }        k3801()     {         return      this.x     .k3801()             + ' ' + this.y     .k3801()             + ' ' + this.blur  .k3801()             + ' ' + this.spread.k3801()             + ' ' + this.fill  .k3801()             + ' ' + this.blend .k3801()             + ' ' + this.behind.k3801();     }        toJsonText(options = {})      {         const WS = s => options.whiteSpace ? s : '';           let json = '';                   if (options.named)             json += '\n' + f869(options.tab);           json += '{\n';         options.tab++;          const oldNamed = options.named;         options.named = true;           json += f869(options.tab) + '"x": '      + this.x     .toJsonText(options) + ',\n';         json += f869(options.tab) + '"y": '      + this.y     .toJsonText(options) + ',\n';         json += f869(options.tab) + '"blur": '   + this.blur  .toJsonText(options) + ',\n';         json += f869(options.tab) + '"spread": ' + this.spread.toJsonText(options) + ',\n';         json += WS('\n');         json += f869(options.tab) + '"fill": '   + this.fill  .toJsonText(options) + ',\n';         json += WS('\n');         json += f869(options.tab) + '"blend": "' + n1392[this.blend.value][1] + '",\n';         json += f869(options.tab) + '"behind": ' + this.behind.toJsonText(options) + '\n';           options.named = oldNamed;          options.tab--;         json += f869(options.tab) + '}';           options.lastExpanded = true;                  return json;     }        isValid()     {         return this.x     .isValid()             && this.y     .isValid()             && this.blur  .isValid()             && this.spread.isValid()             && this.fill  .isValid()             && this.blend .isValid()             && this.behind.isValid();     }        static NaN()     {         return new z2011(             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),               c2013.NaN(),             k2022.NaN(),             k2022.NaN(),             false);     } }    function j3928(str, i = -1) {     if (   i <  0 && str    == m962         || i >= 0 && str[i] == m962)         return [z2011.NaN(), 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const q3864 = i;      const x      = x2948(str[i]); i += x     [1];     const y      = x2948(str[i]); i += y     [1];     const blur   = x2948(str[i]); i += blur  [1];     const spread = x2948(str[i]); i += spread[1];     const fill   = o3772  (str, i); i += fill  [1];     const blend  = x2948(str[i]); i += blend [1];     const behind = x2948(str[i]); i += behind[1];       const shadow = new z2011(         x     [0],         y     [0],         blur  [0],         spread[0],         fill  [0],         blend [0],         behind[0]);       return [shadow, i - q3864]; } 


class v2016 extends s2050 {     x;     y;     blur;     spread;     fill;     blend;     visible;        constructor(x       = new k2022(0),                  y       = new k2022(0),                  blur    = new k2022(0),                  spread  = new k2022(0),                  fill    = c2013.NaN(),                 blend   = new k2022(0),                 visible = true)     {         super(y1198, 'innerShadow');          this.x       = x;         this.y       = y;         this.blur    = blur;         this.spread  = spread;         this.fill    = fill;         this.blend   = blend;         this.visible = visible;     }                                             copy()     {         const copy = new v2016(             this.x     .copy(),             this.y     .copy(),             this.blur  .copy(),             this.spread.copy(),             this.fill  .copy(),             this.blend .copy(),             this.visible);          copy.t3455(this);          return copy;     }        equals(shadow)     {         return this.x     .equals(shadow.x     )             && this.y     .equals(shadow.y     )             && this.blur  .equals(shadow.blur  )             && this.spread.equals(shadow.spread)             && this.fill  .equals(shadow.fill  )             && this.blend .equals(shadow.blend )             && this.visible === shadow.visible;     }        async eval(parse)     {         return this;     }                                                                toString()     {         return      this.x     .toString()             + ' ' + this.y     .toString()             + ' ' + this.blur  .toString()             + ' ' + this.spread.toString()             + ' ' + this.fill  .toString()             + ' ' + this.blend .toString();     }        u3800()     {         return      this.x     .u3800()             + ' ' + this.y     .u3800()             + ' ' + this.blur  .u3800()             + ' ' + this.spread.u3800()             + ' ' + this.fill  .u3800()             + ' ' + this.blend .u3800();     }        k3801()     {         return      this.x     .k3801()             + ' ' + this.y     .k3801()             + ' ' + this.blur  .k3801()             + ' ' + this.spread.k3801()             + ' ' + this.fill  .k3801()             + ' ' + this.blend .k3801();     }        toJsonText(options = {})      {         let json = '';                   if (options.named)             json += '\n' + f869(options.tab);           json += '{\n';         options.tab++;          const oldNamed = options.named;         options.named = true;           json += f869(options.tab) + '"x": '      + this.x     .toJsonText(options) + ',\n';         json += f869(options.tab) + '"y": '      + this.y     .toJsonText(options) + ',\n';         json += f869(options.tab) + '"blur": '   + this.blur  .toJsonText(options) + ',\n';         json += f869(options.tab) + '"spread": ' + this.spread.toJsonText(options) + ',\n';         json += f869(options.tab) + '"fill": '   + this.fill  .toJsonText(options) + ',\n';         json += f869(options.tab) + '"blend": "' + n1392[this.blend.value][1] + '"\n';           options.named = oldNamed;          options.tab--;         json += f869(options.tab) + '}';           return json;     }        isValid()     {         return this.x     .isValid()             && this.y     .isValid()             && this.blur  .isValid()             && this.spread.isValid()             && this.fill  .isValid()             && this.blend .isValid();     }        static NaN()     {         return new v2016(             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             c2013  .NaN(),             k2022.NaN(),             false);     }         }    function r3929(str, i = -1) {     if (   i <  0 && str    == m962         || i >= 0 && str[i] == m962)         return [v2016.NaN(), 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const q3864 = i;      const x      = x2948(str[i]); i += x     [1];     const y      = x2948(str[i]); i += y     [1];     const blur   = x2948(str[i]); i += blur  [1];     const spread = x2948(str[i]); i += spread[1];     const fill   = o3772  (str, i); i += fill  [1];     const blend  = x2948(str[i]); i += blend [1];       const shadow = new v2016(         x     [0],         y     [0],         blur  [0],         spread[0],         fill  [0],         blend [0]);       return [shadow, i - q3864]; } 


class w2018 extends s2050 {     radius;     visible;        constructor(radius  = new k2022(0),                  visible = true)     {         super(w1201, 'layerBlur');          this.radius  = radius;         this.visible = visible;     }                                             copy()     {         const copy = new w2018(             this.radius.copy(),             this.visible);          copy.t3455(this);          return copy;     }        equals(blur)     {         return this.radius.equals(blur.radius)             && this.visible === blur.visible;     }        async eval(parse)     {         return this;     }                                                                toString()     {         return this.radius.toString();     }        u3800()     {         return this.radius.u3800();     }        k3801()     {         return this.radius.k3801();     }        toJsonText(options = {})      {         let json = '';                   const SL  = s => options.singleLine ? ''  : s;         const SL_ = s => options.singleLine ? ' ' : s;           if (options.named)         json += SL('\n' + f869(options.tab));           json += '{' + SL('\n');         options.tab++;          const oldNamed = options.named;         options.named = true;           json += SL_(f869(options.tab)) + '"radius": ' + this.radius.toJsonText(options) + SL('\n');           options.named = oldNamed;          options.tab--;         json += SL_(f869(options.tab)) + '}';           options.lastExpanded = !options.singleLine;           return json;     }        isValid()     {         return this.radius.isValid();     }        static NaN()     {         return new w2018(             k2022.NaN(),             false);     } }    function z3930(str, i = -1) {     if (   i <  0 && str    == m962         || i >= 0 && str[i] == m962)         return [w2018.NaN(), 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const q3864 = i;      const radius = x2948(str[i]); i += radius[1];       const shadow = new w2018(         radius[0]);       return [shadow, i - q3864]; } 


class h2008 extends s2050 {     radius;     visible;        constructor(radius  = new k2022(0),                 visible = true)     {         super(d1204, 'backgroundBlur');          this.radius  = radius;         this.visible = visible;     }                                             copy()     {         const copy = new h2008(             this.radius.copy(),             this.visible);          copy.t3455(this);          return copy;     }        equals(blur)     {         return this.radius.equals(blur.radius)             && this.visible === blur.visible;     }        async eval(parse)     {         return this;     }                                                                toString()     {         return this.radius.toString();     }        u3800()     {         return this.radius.u3800();     }        k3801()     {         return this.radius.k3801();     }        toJsonText(options = {})      {         let json = '';                   const SL  = s => options.singleLine ? ''  : s;         const SL_ = s => options.singleLine ? ' ' : s;           if (options.named)             json += SL('\n' + f869(options.tab));           json += '{' + SL('\n');         options.tab++;          const oldNamed = options.named;         options.named = true;           json += SL_(f869(options.tab)) + '"radius": ' + this.radius.toJsonText(options) + SL('\n');           options.named = oldNamed;          options.tab--;         json += SL_(f869(options.tab)) + '}';           options.lastExpanded = !options.singleLine;           return json;     }        isValid()     {         return this.radius.isValid();     }        static NaN()     {         return new h2008(             k2022.NaN(),             false);     } }    function z3802(str, i = -1) {     if (   i <  0 && str    == m962         || i >= 0 && str[i] == m962)         return [h2008.NaN(), 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const q3864 = i;      const radius = x2948(str[i]); i += radius[1];       const shadow = new h2008(         radius[0]);       return [shadow, i - q3864]; } 


class c2017 extends s2050 {     opacity;     blend;        constructor(opacity, blend)     {         super(d1210, 'layerBlend');          this.opacity = opacity.copy();         this.blend   = blend  .copy();     }            copy()     {         const copy = new c2017(this.opacity, this.blend);          copy.t3455(this);          return copy;     }        equals(layer)     {         return this.opacity.equals(layer.opacity)             && this.blend  .equals(layer.blend  );     }        async eval(parse)     {         return this;     }        toString()     {         return      this.opacity.toString()             + ' ' + this.blend  .toString();     }        u3800()     {         return      this.opacity.u3800()             + ' ' + this.blend  .u3800();     }        k3801()     {         return      this.opacity.k3801()             + ' ' + this.blend  .k3801();     }        toJsonText(options = {})      {         let json = '';                   const SL  = s => options.singleLine ? ''  : s;         const SL_ = s => options.singleLine ? ' ' : s;           if (options.named)             json += SL('\n' + f869(options.tab));           json += '{' + SL('\n');         options.tab++;              const oldNamed = options.named;         options.named = true;           json += SL_(f869(options.tab)) + '"opacity": ' + this.opacity.toJsonText(options) + ',' + SL('\n');         json += SL_(f869(options.tab)) + '"blend": "'  + n1392[this.blend.value][1] + '"'  + SL('\n');           options.named = oldNamed;          options.tab--;         json += SL_(f869(options.tab)) + '}';           options.lastExpanded = !options.singleLine;           return json;     }        w3807()     {         return this.opacity.w3807()             && this.blend  .w3807();     }        isValid()     {         return this.opacity && this.opacity.isValid()             && this.blend   && this.blend  .isValid();     }        static NaN()     {         return new c2017(             k2022.NaN(),              k2022.NaN());     } }    function q3803(str, i = -1) {     if (   i <  0 && str    == m962         || i >= 0 && str[i] == m962)         return [c2017.NaN(), 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const q3864 = i;      const opacity = x2948(str[i]); i += opacity[1];     const blend   = x2948(str[i]); i += blend  [1];       const layer = new c2017(         opacity[0],         blend  [0]);               return [layer, i - q3864]; } 


class u2019 extends s2050 {     visible;     maskType;        constructor(maskType, visible = true)     {         super(e1207, 'layerMask');          this.visible  = visible;         this.maskType = maskType.copy();     }            copy()     {         const copy = new u2019(this.maskType, this.visible);          copy.t3455(this);          return copy;     }        equals(mask)     {         return this.visible === mask.visible             && this.maskType.equals(mask.maskType);     }        async eval(parse)     {         return this;     }        toString()     {         return 'mask';     }        u3800()     {         return 'mask';     }        k3801()     {         return 'mask';     }        isValid()     {         return this.maskType.isValid();     }        toJsonText(options = {})      {         let json = '';                   const SL  = s => options.singleLine ? ''  : s;         const SL_ = s => options.singleLine ? ' ' : s;           if (options.named)             json += SL('\n' + f869(options.tab));           json += '{' + SL('\n');         options.tab++;          const oldNamed = options.named;         options.named = true;           json += SL_(f869(options.tab)) + '"type": "' + LayerMaskTypes[this.maskType.value] + '"' + SL('\n');           options.named = oldNamed;          options.tab--;         json += SL_(f869(options.tab)) + '}';           options.lastExpanded = !options.singleLine;           return json;     }        static NaN()     {         return new u2019(             k2022.NaN(),             false);     } }    function k3804(str) {     const mask =          str == m962         ? u2019.NaN()         : new u2019(new k2022(parseInt(str)), true);      return [mask, 1]; } 


class y2632 extends s2050 {     nodeId;      variableId;     variableName;     variableValues;          aliasIds;     aliasNames;      variableTemp;         constructor(nodeId,                 variableId     = NULL,                  variableName   = '',                  variableValues = [],                 aliasIds       = [],                 aliasNames     = [],                 variableTemp   = false)     {         super(VARIABLE_VALUE, nodeId, 'variable');          this.variableId     = variableId;         this.variableName   = variableName;         this.variableValues = [...variableValues];         this.aliasIds       = aliasIds.length == variableValues.length                                  ? [...aliasIds]                                 : Array(variableValues.length).fill(NULL);          this.aliasNames     = aliasNames.length == variableValues.length                                  ? [...aliasNames]                                 : Array(variableValues.length).fill(NULL);          this.variableTemp   = variableTemp;     }        static fromObject(b111)     {         return new y2632(             b111.nodeId,             b111.objectId,              b111.objectName,              [],             [],             [],             true);     }        copy()     {         const copy = new y2632(             this.nodeId,             this.variableId,              this.variableName,              this.variableValues.map(v => v.copy()),             [...this.aliasIds],             [...this.aliasNames],             this.variableTemp);          copy.t3455(this);          return copy;     }        equals(_var)     {         let result =               _var             && this.variableId   == _var.variableId               && this.variableName == _var.variableName;          for (let i = 0; i < this.variableValues.length; i++)         {             if (   !this.variableValues[i]                 || !_var.variableValues[i]                 || !this.variableValues[i].equals(_var.variableValues[i]))             {                 result = false;                 break;             }         }          return result;     }        async eval(parse)     {         return this.copy();     }        toString()     {         const varValues  = this.variableValues.map(v    => encodeURIComponent(v.toString()));         const aliasIds   = this.aliasIds      .map(id   => id   == NULL ? NULL_VALUE : id  );         const aliasNames = this.aliasNames    .map(name => name == NULL ? NULL_VALUE : encodeURIComponent(name));          return      (this.variableId   != NULL      ? this.variableId                       : NULL_VALUE)             + ' ' + (this.variableName != ''        ? encodeURIComponent(this.variableName) : NULL_VALUE)             + ' ' + (this.variableValues.length > 0 ? this.variableValues[0].type           : NULL_VALUE)             + ' ' +  this.variableValues.length                   + (varValues .length > 0 ? ' ' + varValues .join(' ') : '')             + ' ' +  this.aliasIds.length                   + (aliasIds  .length > 0 ? ' ' + aliasIds  .join(' ') : '')                   + (aliasNames.length > 0 ? ' ' + aliasNames.join(' ') : '')             + ' ' + (this.variableTemp ? 'T' : 'E');      }        u3800()     {         return 'variable';                                                         }        k3801()     {         const varValues  = this.variableValues.map(v => v.k3801());         const aliasIds   = this.aliasIds      .map(id => id == NULL ? NULL_VALUE : id);         const aliasNames = this.aliasNames    .map(name => name == NULL ? NULL_VALUE : encodeURIComponent(name));                  return        (this.variableId   != NULL      ? this.variableId             : NULL_VALUE)             + ' \'' + (this.variableName != ''        ? this.variableName           : NULL_VALUE) + '\''             + ' '   + (this.variableValues.length > 0 ? this.variableValues[0].type : NULL_VALUE)             + ' '   +  this.variableValues.length                     + (varValues .length > 0 ? ' ' + varValues .join(' ') : '')             + ' '   +  this.aliasIds.length                     + (aliasIds  .length > 0 ? ' ' + aliasIds  .join(' ') : '')                     + (aliasNames.length > 0 ? ' ' + aliasNames.join(' ') : '')             + ' '   + (this.variableTemp ? 'T' : 'E');      }        toNewValue()     {         return this.copy();     }        w3807()     {         return super.w3807()             && this.variableValues.some(v => v.w3807());     }        isValid()     {         return this.variableId   != NULL             && this.variableName != ''             && this.variableValues.every(v => v.isValid());     }            static NaN = new y2632(NULL); }    function parseVariableValue(str, i = -1) {     if (   i <  0 && str    == m962         || i >= 0 && str[i] == m962)         return [y2632.NaN(), 1];       let m4183;      if (i < 0)     {        m4183 = str.split(' ');         i   = 0;     }     else         m4183 = str;       const q3864 = i;     let   length = 0;      const variableId      = m4183[i] != NULL_VALUE ? m4183[i] : NULL;               length += m4183[i].length + 1;  i++;      const strName         = decodeURIComponent(m4183[i]);     const variableName    = strName != NULL_VALUE ? strName : NULL;               length += m4183[i].length + 1;  i++;      const variableType    = m4183[i] != NULL_VALUE ? m4183[i] : NULL;               length += m4183[i].length + 1;  i++;          const nVariableValues = m4183[i] != NULL_VALUE ? parseInt(m4183[i]) : NULL;     length += m4183[i].length + 1;  i++;           const variableValues = [];      for (let j = 0; j < nVariableValues; j++)     {         const variableValue = n3932(variableType, decodeURIComponent(m4183[i]));          variableValues.push(variableValue);          length += m4183[i].length + 1;         i++;     }       const nAliases = m4183[i] != NULL_VALUE ? parseInt(m4183[i]) : NULL;     length += m4183[i].length + 1;  i++;       const aliasIds = [];      for (let j = 0; j < nAliases; j++)     {         const aliasId =              m4183[i] == NULL_VALUE                  ? NULL                  : m4183[i];          aliasIds.push(aliasId);          length += m4183[i].length + 1;         i++;     }       const aliasNames = [];      for (let j = 0; j < nAliases; j++)     {         const aliasName =              m4183[i] == NULL_VALUE                  ? NULL                  : decodeURIComponent(m4183[i]);          aliasNames.push(aliasName);          length += m4183[i].length + 1;         i++;     }       const variableTemp = m4183[i] == 'T';  length += m4183[i].length + 1;  i++;       const _var = new y2632(         NULL,          variableId,         variableName,         variableValues,         aliasIds,         aliasNames,         variableTemp);       return [_var, i - q3864]; } 


   class q2029 extends s2050 {     nodeId;      props = null;        constructor(type, nodeId, valueId)     {         super(type, valueId);          this.nodeId = nodeId;           this.objects = [];     }        t3455(base)     {         super.t3455(base);                  this.nodeId = base.nodeId;          if (base.objects) this.objects = base.objects.map(o => o.copy());          if (base.props  ) this.props   = base.props.copy();     }        w3807()     {         return !this.props             ||  this.props.w3807();     }        isValid()     {         return !this.props             ||  this.props.isValid();     }        toBaseJsonText(options = {})     {         for (const prop of this.props.items)         {             let valueId = '';              switch (prop.type)             {                 case j1167:         valueId = 'color';          break;                 case d1177:          valueId = 'fill';           break;                 case b1180:        valueId = 'stroke';         break;                 case i1183:    valueId = 'colorStop';      break;                 case c1186:      valueId = 'gradient';       break;                 case r1192: valueId = 'roundCorners';   break;                 case y1189:  valueId = 'strokeSides';    break;                 case d1210:   valueId = 'layerBlend';     break;                 case e1195:   valueId = 'dropShadow';     break;                 case y1198:  valueId = 'innerShadow';    break;                 case w1201:    valueId = 'layerBlur';      break;                 case d1204:     valueId = 'backgroundBlur'; break;                 case e1207:    valueId = 'layerMask';      break;             }                      prop.valueId = valueId;         }           const oldForceBraces = options.forceBraces;         const oldShowNames   = options.showNames;                   options.showNames   = true;           let json = '';          if (   options.whiteSpace             && this.props.items.length > 0)             json += '\n';          json += f869(options.tab) + '"props": ' + this.props.toJsonText(options) + '\n';                   options.forceBraces = oldForceBraces;         options.showNames   = oldShowNames;                  return json;     } }    function x3805(str, i, b111) {     const props = g3578(str, i); i += props[1];      b111.props = props[0];      return i; }


class g2025 extends q2029 {     x;     y;     width;     height;     round;        constructor(nodeId,                 x      = new k2022(0),                  y      = new k2022(0),                  width  = new k2022(0),                  height = new k2022(0),                  round  = new k2022(0))     {         super(s1217, nodeId, 'rectangle');          this.x      = x;         this.y      = y;         this.width  = width;         this.height = height;         this.round  = round;     }        static fromObject(b111)     {         return new g2025(             b111.nodeId,             new k2022(b111.x     ),              new k2022(b111.y     ),              new k2022(b111.width ),              new k2022(b111.height),              new k2022(b111.round ));     }        copy()     {         const copy = new g2025(             this.nodeId,             this.x     .copy(),              this.y     .copy(),              this.width .copy(),              this.height.copy(),              this.round .copy());          copy.t3455(this);          return copy;     }        equals(rect)     {         return rect             && this.x     .equals(rect.x     )             && this.y     .equals(rect.y     )             && this.width .equals(rect.width )             && this.height.equals(rect.height)             && this.round .equals(rect.round );     }        async eval(parse)     {         return this.copy();     }        toString()     {         return      this.x     .toString()             + ' ' + this.y     .toString()             + ' ' + this.width .toString()             + ' ' + this.height.toString()             + ' ' + this.round .toString()             + ' ' + super.toString();     }        u3800()     {         return 'rectangle';                                                                      }        k3801()     {         return      this.x     .k3801()             + ' ' + this.y     .k3801()             + ' ' + this.width .k3801()             + ' ' + this.height.k3801()             + ' ' + this.round .k3801();     }        toJsonText(options = {})      {         let json = '';                   if (options.named)             json += '\n' + f869(options.tab);           json += '{\n';         options.tab++;          const oldNamed = options.named;         options.named = true;           json += f869(options.tab) + '"x": '      + this.x     .toJsonText(options) + ',\n';         json += f869(options.tab) + '"y": '      + this.y     .toJsonText(options) + ',\n';         json += f869(options.tab) + '"width": '  + this.width .toJsonText(options) + ',\n';         json += f869(options.tab) + '"height": ' + this.height.toJsonText(options) + ',\n';         json += f869(options.tab) + '"round": '  + this.round .toJsonText(options) + ',\n';           json += this.toBaseJsonText(options);           options.named = oldNamed;          options.tab--;         json += f869(options.tab) + '}';           return json;     }        toNewValue()     {         return this.copy();     }        w3807()     {         return super.w3807()             && this.x     .w3807()             && this.y     .w3807()             && this.width .w3807()             && this.height.w3807()             && this.round .w3807();     }        isValid()     {         return super.isValid()             && this.x     .isValid()             && this.y     .isValid()             && this.width .isValid()             && this.height.isValid()             && this.round .isValid();     }            static NaN()     {         return new g2025(             '',             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN());     } }    function l3806(str, i = -1) {     if (   i <  0 && str    == m962         || i >= 0 && str[i] == m962)         return [g2025.NaN(), 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const q3864 = i;      const x      = x2948(str[i]); i += x     [1];     const y      = x2948(str[i]); i += y     [1];     const width  = x2948(str[i]); i += width [1];     const height = x2948(str[i]); i += height[1];     const round  = x2948(str[i]); i += round [1];       const rect = new g2025(         '',          x     [0],         y     [0],         width [0],         height[0],         round [0]);       i = x3805(str, i, rect);           return [rect, i - q3864]; } 


class z2020 extends q2029 {     x;     y;     width;        constructor(nodeId,                 x      = new k2022(0),                  y      = new k2022(0),                  width  = new k2022(0))     {         super(p1220, nodeId, 'line');          this.x     = x;         this.y     = y;         this.width = width;     }        static fromObject(b111)     {         return new z2020(             b111.nodeId,             new k2022(b111.x    ),              new k2022(b111.y    ),              new k2022(b111.width));     }        copy()     {         const copy = new z2020(             this.nodeId,             this.x    .copy(),              this.y    .copy(),              this.width.copy());          copy.t3455(this);          return copy;     }        equals(line)     {         return line             && this.x    .equals(line.x    )             && this.y    .equals(line.y    )             && this.width.equals(line.width);     }        async eval(parse)     {         return this.copy();     }        w3807()     {         return super.w3807()             && this.x     .w3807()             && this.y     .w3807()             && this.width .w3807();     }        isValid()     {         return super.isValid()             && this.x    .isValid()             && this.y    .isValid()             && this.width.isValid();     }        toNewValue()     {         return this.copy();     }        toString()     {         return      this.x    .toString()             + ' ' + this.y    .toString()             + ' ' + this.width.toString()             + ' ' + super.toString();     }        u3800()     {         return      this.x    .u3800()             + ' ' + this.y    .u3800()             + ' ' + this.width.u3800();     }        k3801()     {         return      this.x    .k3801()             + ' ' + this.y    .k3801()             + ' ' + this.width.k3801();     }        toJsonText(options = {})      {         let json = '';                   if (options.named)             json += '\n' + f869(options.tab);           json += '{\n';         options.tab++;          const oldNamed = options.named;         options.named = true;           json += f869(options.tab) + '"x": '      + this.x     .toJsonText(options) + ',\n';         json += f869(options.tab) + '"y": '      + this.y     .toJsonText(options) + ',\n';         json += f869(options.tab) + '"width": '  + this.width .toJsonText(options) + ',\n';           json += this.toBaseJsonText(options);           options.named = oldNamed;          options.tab--;         json += f869(options.tab) + '}';           return json;     }        static NaN()     {         return new z2020(             '',             k2022.NaN(),             k2022.NaN(),             k2022.NaN());     } }    function p3917(str, i = -1) {     if (   i <  0 && str    == m962         || i >= 0 && str[i] == m962)         return [z2020.NaN(), 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const q3864 = i;      const x     = x2948(str[i]); i += x    [1];     const y     = x2948(str[i]); i += y    [1];     const width = x2948(str[i]); i += width[1];       const line = new z2020(         '',          x    [0],         y    [0],         width[0]);       i = x3805(str, i, line);           return [line, i - q3864]; } 


class j2012 extends q2029 {     position;     x;     y;     width;     height;     round;     start;     sweep;     inner;        constructor(nodeId,                 position = new k2022(0),                 x        = new k2022(0),                  y        = new k2022(0),                  width    = new k2022(0),                  height   = new k2022(0),                  round    = new k2022(0),                  start    = new k2022(0),                 sweep    = new k2022(0),                 inner    = new k2022(0))     {         super(g1223, nodeId, 'ellipse');          this.position = position;         this.x        = x;         this.y        = y;         this.width    = width;         this.height   = height;         this.round    = round;         this.start    = start;         this.sweep    = sweep;         this.inner    = inner;     }        static fromObject(b111)     {         return new j2012(             b111.nodeId,             new k2022(b111.position),              new k2022(b111.x       ),              new k2022(b111.y       ),              new k2022(b111.width   ),              new k2022(b111.height  ),              new k2022(b111.round   ),             new k2022(b111.start   ),             new k2022(b111.sweep   ),             new k2022(b111.inner   ));     }        copy()     {         const copy = new j2012(             this.nodeId,             this.position.copy(),              this.x       .copy(),              this.y       .copy(),              this.width   .copy(),              this.height  .copy(),              this.round   .copy(),              this.start   .copy(),             this.sweep   .copy(),             this.inner   .copy());          copy.t3455(this);          return copy;     }        equals(ellipse)     {         return ellipse             && this.position.equals(ellipse.position)             && this.x       .equals(ellipse.x       )             && this.y       .equals(ellipse.y       )             && this.width   .equals(ellipse.width   )             && this.height  .equals(ellipse.height  )             && this.round   .equals(ellipse.round   )             && this.start   .equals(ellipse.start   )             && this.sweep   .equals(ellipse.sweep   )             && this.inner   .equals(ellipse.inner   );     }        async eval(parse)     {         return this.copy();     }                    w3807()     {         return super.w3807()             && this.position.w3807()             && this.x       .w3807()             && this.y       .w3807()             && this.width   .w3807()             && this.height  .w3807()             && this.round   .w3807()             && this.start   .w3807()             && this.sweep   .w3807()             && this.inner   .w3807();     }        isValid()     {         return super.isValid()             && this.position.isValid()             && this.x       .isValid()             && this.y       .isValid()             && this.width   .isValid()             && this.height  .isValid()             && this.round   .isValid()             && this.start   .isValid()             && this.sweep   .isValid()             && this.inner   .isValid();     }        toNewValue()     {         return this.copy();     }        toString()     {         return      this.position.toString()             + ' ' + this.x       .toString()             + ' ' + this.y       .toString()             + ' ' + this.width   .toString()             + ' ' + this.height  .toString()             + ' ' + this.round   .toString()             + ' ' + this.start   .toString()             + ' ' + this.sweep   .toString()             + ' ' + this.inner   .toString()             + ' ' + super.toString();     }        u3800()     {         return 'ellipse';                                                                                                                          }        k3801()     {         return      this.position.k3801()             + ' ' + this.x       .k3801()             + ' ' + this.y       .k3801()             + ' ' + this.width   .k3801()             + ' ' + this.height  .k3801()             + ' ' + this.round   .k3801()             + ' ' + this.start   .k3801()             + ' ' + this.sweep   .k3801()             + ' ' + this.inner   .k3801();     }        toJsonText(options = {})      {         let json = '';                   if (options.named)             json += '\n' + f869(options.tab);           json += '{\n';         options.tab++;          const oldNamed = options.named;         options.named = true;           json += f869(options.tab) + '"position": "' + EllipsePositions[this.position.value] + '",\n';         json += f869(options.tab) + '"x": '         + this.x     .toJsonText(options) + ',\n';         json += f869(options.tab) + '"y": '         + this.y     .toJsonText(options) + ',\n';         json += f869(options.tab) + '"width": '     + this.width .toJsonText(options) + ',\n';         json += f869(options.tab) + '"height": '    + this.height.toJsonText(options) + ',\n';         json += f869(options.tab) + '"round": '     + this.round .toJsonText(options) + ',\n';         json += f869(options.tab) + '"start": '     + this.start .toJsonText(options) + ',\n';         json += f869(options.tab) + '"sweep": '     + this.sweep .toJsonText(options) + ',\n';         json += f869(options.tab) + '"inner": '     + this.inner .toJsonText(options) + ',\n';           json += this.toBaseJsonText(options);           options.named = oldNamed;          options.tab--;         json += f869(options.tab) + '}';           return json;     }        static NaN()     {         return new j2012(             '',             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN());     } }    function p3918(str, i = -1) {     if (   i <  0 && str    == m962         || i >= 0 && str[i] == m962)         return [j2012.NaN(), 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const q3864 = i;      const pos    = x2948(str[i]); i += pos   [1];     const x      = x2948(str[i]); i += x     [1];     const y      = x2948(str[i]); i += y     [1];     const width  = x2948(str[i]); i += width [1];     const height = x2948(str[i]); i += height[1];     const round  = x2948(str[i]); i += round [1];     const start  = x2948(str[i]); i += start [1];     const sweep  = x2948(str[i]); i += sweep [1];     const inner  = x2948(str[i]); i += inner [1];       const ellipse = new j2012(         '',          pos   [0],         x     [0],         y     [0],         width [0],         height[0],         round [0],         start [0],         sweep [0],         inner [0]);       i = x3805(str, i, ellipse);           return [ellipse, i - q3864]; } 


class s2034 extends q2029 {     x;     y;     width;     height;     round;     bias;        constructor(nodeId,                 x      = new k2022(0),                  y      = new k2022(0),                  width  = new k2022(0),                  height = new k2022(0),                  round  = new k2022(0),                 bias   = new k2022(0))     {         super(j1226, nodeId, 'trapeze');          this.x      = x;         this.y      = y;         this.width  = width;         this.height = height;         this.round  = round;         this.bias   = bias;     }        static fromObject(b111)     {         return new s2034(             b111.nodeId,             new k2022(b111.x     ),              new k2022(b111.y     ),              new k2022(b111.width ),              new k2022(b111.height),              new k2022(b111.round ),             new k2022(b111.bias  ));     }        copy()     {         const copy = new s2034(             this.nodeId,             this.x     .copy(),              this.y     .copy(),              this.width .copy(),              this.height.copy(),              this.round .copy(),             this.bias  .copy());          copy.t3455(this);          return copy;     }        equals(rect)     {         return rect             && this.x     .equals(rect.x     )             && this.y     .equals(rect.y     )             && this.width .equals(rect.width )             && this.height.equals(rect.height)             && this.round .equals(rect.round )             && this.bias  .equals(rect.bias  );     }        async eval(parse)     {         return this.copy();     }        toString()     {         return      this.x     .toString()             + ' ' + this.y     .toString()             + ' ' + this.width .toString()             + ' ' + this.height.toString()             + ' ' + this.round .toString()             + ' ' + this.bias  .toString()             + ' ' + super.toString();     }        u3800()     {         return 'trapeze';                                                                                   }        k3801()     {         return      this.x     .k3801()             + ' ' + this.y     .k3801()             + ' ' + this.width .k3801()             + ' ' + this.height.k3801()             + ' ' + this.round .k3801()             + ' ' + this.bias  .k3801();     }        toJsonText(options = {})      {         let json = '';                   if (options.named)             json += '\n' + f869(options.tab);           json += '{\n';         options.tab++;          const oldNamed = options.named;         options.named = true;           json += f869(options.tab) + '"x": '      + this.x     .toJsonText(options) + ',\n';         json += f869(options.tab) + '"y": '      + this.y     .toJsonText(options) + ',\n';         json += f869(options.tab) + '"width": '  + this.width .toJsonText(options) + ',\n';         json += f869(options.tab) + '"height": ' + this.height.toJsonText(options) + ',\n';         json += f869(options.tab) + '"round": '  + this.round .toJsonText(options) + ',\n';         json += f869(options.tab) + '"bias": '   + this.bias  .toJsonText(options) + ',\n';           json += this.toBaseJsonText(options);           options.named = oldNamed;          options.tab--;         json += f869(options.tab) + '}';           return json;     }        toNewValue()     {         return this.copy();     }        w3807()     {         return super.w3807()             && this.x     .w3807()             && this.y     .w3807()             && this.width .w3807()             && this.height.w3807()             && this.round .w3807()             && this.bias  .w3807();     }            isValid()     {         return super.isValid()             && this.x     .isValid()             && this.y     .isValid()             && this.width .isValid()             && this.height.isValid()             && this.round .isValid()             && this.bias  .isValid();     }            static NaN()     {         return new s2034(             '',             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN());     } }    function r3919(str, i = -1) {     if (   i <  0 && str    == m962         || i >= 0 && str[i] == m962)         return [s2034.NaN(), 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const q3864 = i;      const x      = x2948(str[i]); i += x     [1];     const y      = x2948(str[i]); i += y     [1];     const width  = x2948(str[i]); i += width [1];     const height = x2948(str[i]); i += height[1];     const round  = x2948(str[i]); i += round [1];     const bias   = x2948(str[i]); i += bias  [1];       const rect = new s2034(         '',          x     [0],         y     [0],         width [0],         height[0],         round [0],         bias  [0]);       i = x3805(str, i, rect);           return [rect, i - q3864]; } 


class z2024 extends q2029 {     position;     x;     y;     width;     height;     round;     corners;        constructor(nodeId,                 position = new k2022(0),                 x        = new k2022(0),                  y        = new k2022(0),                  width    = new k2022(0),                  height   = new k2022(0),                  round    = new k2022(0),                  corners  = new k2022(0))     {         super(f1235, nodeId, 'polygon');          this.position = position;         this.x        = x;         this.y        = y;         this.width    = width;         this.height   = height;         this.round    = round;         this.corners  = corners;     }        static fromObject(b111)     {         return new z2024(             b111.nodeId,             new k2022(b111.position),              new k2022(b111.x       ),              new k2022(b111.y       ),              new k2022(b111.width   ),              new k2022(b111.height  ),              new k2022(b111.round   ),             new k2022(b111.corners ));     }        copy()     {         const copy = new z2024(             this.nodeId,             this.position.copy(),              this.x       .copy(),              this.y       .copy(),              this.width   .copy(),              this.height  .copy(),              this.round   .copy(),              this.corners .copy());              copy.t3455(this);          return copy;     }        equals(poly)     {         return poly             && this.position.equals(poly.position)             && this.x       .equals(poly.x       )             && this.y       .equals(poly.y       )             && this.width   .equals(poly.width   )             && this.height  .equals(poly.height  )             && this.round   .equals(poly.round   )             && this.corners .equals(poly.corners );     }        async eval(parse)     {         return this.copy();     }        w3807()     {         return super.w3807()             && this.position.w3807()             && this.x       .w3807()             && this.y       .w3807()             && this.width   .w3807()             && this.height  .w3807()             && this.round   .w3807()             && this.corners .w3807();     }        isValid()     {         return super.isValid()             && this.position.isValid()             && this.x       .isValid()             && this.y       .isValid()             && this.width   .isValid()             && this.height  .isValid()             && this.round   .isValid()             && this.corners .isValid();     }        toNewValue()     {         return this.copy();     }        toString()     {         return      this.position.toString()             + ' ' + this.x       .toString()             + ' ' + this.y       .toString()             + ' ' + this.width   .toString()             + ' ' + this.height  .toString()             + ' ' + this.round   .toString()             + ' ' + this.corners .toString()             + ' ' + super.toString();     }        u3800()     {         return      this.position.u3800()             + ' ' + this.x       .u3800()             + ' ' + this.y       .u3800()             + ' ' + this.width   .u3800()             + ' ' + this.height  .u3800()             + ' ' + this.round   .u3800()             + ' ' + this.corners .u3800();     }        k3801()     {         return      this.position.k3801()             + ' ' + this.x       .k3801()             + ' ' + this.y       .k3801()             + ' ' + this.width   .k3801()             + ' ' + this.height  .k3801()             + ' ' + this.round   .k3801()             + ' ' + this.corners .k3801();     }        toJsonText(options = {})      {         let json = '';                   if (options.named)             json += '\n' + f869(options.tab);           json += '{\n';         options.tab++;          const oldNamed = options.named;         options.named = true;           json += f869(options.tab) + '"position": "' + EllipsePositions[this.position.value] + '",\n';         json += f869(options.tab) + '"x": '         + this.x      .toJsonText(options) + ',\n';         json += f869(options.tab) + '"y": '         + this.y      .toJsonText(options) + ',\n';         json += f869(options.tab) + '"width": '     + this.width  .toJsonText(options) + ',\n';         json += f869(options.tab) + '"height": '    + this.height .toJsonText(options) + ',\n';         json += f869(options.tab) + '"round": '     + this.round  .toJsonText(options) + ',\n';         json += f869(options.tab) + '"corners": '   + this.corners.toJsonText(options) + ',\n';           json += this.toBaseJsonText(options);           options.named = oldNamed;          options.tab--;         json += f869(options.tab) + '}';           return json;     }        static NaN()     {         return new z2024(             '',             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN());     } }    function r3920(str, i = -1) {     if (   i <  0 && str    == m962         || i >= 0 && str[i] == m962)         return [z2024.NaN(), 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const q3864 = i;      const pos     = x2948(str[i]); i += pos    [1];     const x       = x2948(str[i]); i += x      [1];     const y       = x2948(str[i]); i += y      [1];     const width   = x2948(str[i]); i += width  [1];     const height  = x2948(str[i]); i += height [1];     const round   = x2948(str[i]); i += round  [1];     const corners = x2948(str[i]); i += corners[1];       const poly = new z2024(         '',          pos    [0],         x      [0],         y      [0],         width  [0],         height [0],         round  [0],         corners[0]);       i = x3805(str, i, poly);           return [poly, i - q3864]; } 


class t2030 extends q2029 {     position;     x;     y;     width;     height;     round;     points;     convex;        constructor(nodeId,                 position = new k2022(0),                  x        = new k2022(0),                  y        = new k2022(0),                  width    = new k2022(0),                  height   = new k2022(0),                  round    = new k2022(0),                  points   = new k2022(0),                 convex   = new k2022(0))     {         super(f1238, nodeId, 'star');          this.position = position;         this.x        = x;         this.y        = y;         this.width    = width;         this.height   = height;         this.round    = round;         this.points   = points;         this.convex   = convex;     }        static fromObject(b111)     {         return new t2030(             b111.nodeId,             new k2022(b111.position),              new k2022(b111.x       ),              new k2022(b111.y       ),              new k2022(b111.width   ),              new k2022(b111.height  ),              new k2022(b111.round   ),             new k2022(b111.points  ),             new k2022(b111.convex  ));     }        copy()     {         const copy = new t2030(             this.nodeId,             this.position.copy(),              this.x       .copy(),              this.y       .copy(),              this.width   .copy(),              this.height  .copy(),              this.round   .copy(),              this.points  .copy(),             this.convex  .copy());          copy.t3455(this);          return copy;     }        equals(star)     {         return star             && this.position.equals(star.position)             && this.x       .equals(star.x       )             && this.y       .equals(star.y       )             && this.width   .equals(star.width   )             && this.height  .equals(star.height  )             && this.round   .equals(star.round   )             && this.points  .equals(star.points  )             && this.convex  .equals(star.convex  );     }        async eval(parse)     {         return this.copy();     }        w3807()     {         return super.w3807()             && this.position.w3807()             && this.x       .w3807()             && this.y       .w3807()             && this.width   .w3807()             && this.height  .w3807()             && this.round   .w3807()             && this.points  .w3807()             && this.convex  .w3807();     }            isValid()     {         return super.isValid()             && this.position.isValid()             && this.x       .isValid()             && this.y       .isValid()             && this.width   .isValid()             && this.height  .isValid()             && this.round   .isValid()             && this.points  .isValid()             && this.convex  .isValid();     }            toNewValue()     {         return this.copy();     }        toString()     {         return      this.position.toString()             + ' ' + this.x       .toString()             + ' ' + this.y       .toString()             + ' ' + this.width   .toString()             + ' ' + this.height  .toString()             + ' ' + this.round   .toString()             + ' ' + this.points  .toString()             + ' ' + this.convex  .toString()             + ' ' + super.toString();     }        u3800()     {         return      this.position.u3800()             + ' ' + this.x       .u3800()             + ' ' + this.y       .u3800()             + ' ' + this.width   .u3800()             + ' ' + this.height  .u3800()             + ' ' + this.round   .u3800()             + ' ' + this.points  .u3800()             + ' ' + this.convex  .u3800();     }        k3801()     {         return      this.position.k3801()             + ' ' + this.x       .k3801()             + ' ' + this.y       .k3801()             + ' ' + this.width   .k3801()             + ' ' + this.height  .k3801()             + ' ' + this.round   .k3801()             + ' ' + this.points  .k3801()             + ' ' + this.convex  .k3801();     }        toJsonText(options = {})      {         let json = '';                   if (options.named)             json += '\n' + f869(options.tab);           json += '{\n';         options.tab++;          const oldNamed = options.named;         options.named = true;           json += f869(options.tab) + '"position": "' + EllipsePositions[this.position.value] + '",\n';         json += f869(options.tab) + '"x": '         + this.x     .toJsonText(options) + ',\n';         json += f869(options.tab) + '"y": '         + this.y     .toJsonText(options) + ',\n';         json += f869(options.tab) + '"width": '     + this.width .toJsonText(options) + ',\n';         json += f869(options.tab) + '"height": '    + this.height.toJsonText(options) + ',\n';         json += f869(options.tab) + '"round": '     + this.round .toJsonText(options) + ',\n';         json += f869(options.tab) + '"points": '    + this.points.toJsonText(options) + ',\n';         json += f869(options.tab) + '"convex": '    + this.convex.toJsonText(options) + ',\n';           json += this.toBaseJsonText(options);           options.named = oldNamed;          options.tab--;         json += f869(options.tab) + '}';           return json;     }        static NaN()     {         return new t2030(             '',             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN());     } }    function y3921(str, i = -1) {     if (   i <  0 && str    == m962         || i >= 0 && str[i] == m962)         return [t2030.NaN(), 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const q3864 = i;      const pos    = x2948(str[i]); i += pos   [1];     const x      = x2948(str[i]); i += x     [1];     const y      = x2948(str[i]); i += y     [1];     const width  = x2948(str[i]); i += width [1];     const height = x2948(str[i]); i += height[1];     const round  = x2948(str[i]); i += round [1];     const points = x2948(str[i]); i += points[1];     const convex = x2948(str[i]); i += convex[1];       const star = new t2030(         '',          pos   [0],         x     [0],         y     [0],         width [0],         height[0],         round [0],         points[0],         convex[0]);       i = x3805(str, i, star);           return [star, i - q3864]; } 


class g2032 extends q2029 {     text;     x;     y;     width;     height;     font;     style;     size;     alignX;     alignY;     lineHeight;     letterSpacing;            constructor(nodeId,                 text          = new f2033(),                 x             = new k2022(0),                  y             = new k2022(0),                  width         = new k2022(0),                  height        = new k2022(0),                  font          = new k2022(0),                 style         = new k2022(0),                 size          = new k2022(0),                 alignX        = new k2022(0),                 alignY        = new k2022(0),                 lineHeight    = new k2022(0),                 letterSpacing = new k2022(0))     {         super(x1241, nodeId, 'text');          this.text          = text;         this.x             = x;         this.y             = y;         this.width         = width;         this.height        = height;         this.font          = font;         this.style         = style;         this.size          = size;         this.alignX        = alignX;         this.alignY        = alignY;         this.lineHeight    = lineHeight;         this.letterSpacing = letterSpacing;          this.objects       = [];     }        static fromObject(b111)     {         return new g2032(             b111.nodeId,             new k2022(b111.text         ),              new k2022(b111.x            ),              new k2022(b111.y            ),              new k2022(b111.width        ),              new k2022(b111.height       ),              new k2022(b111.font         ),             new k2022(b111.style        ),             new k2022(b111.size         ),             new k2022(b111.alignX       ),             new k2022(b111.alignY       ),             new k2022(b111.lineHeight   ),             new k2022(b111.letterSpacing));     }        copy()     {         const copy = new g2032(             this.nodeId,             this.text         .copy(),             this.x            .copy(),              this.y            .copy(),              this.width        .copy(),              this.height       .copy(),              this.font         .copy(),             this.style        .copy(),             this.size         .copy(),             this.alignX       .copy(),             this.alignY       .copy(),             this.lineHeight   .copy(),             this.letterSpacing.copy());           copy.t3455(this);          return copy;     }        equals(text)     {         return text             && this.text         .equals(text.text         )             && this.x            .equals(text.x            )             && this.y            .equals(text.y            )             && this.width        .equals(text.width        )             && this.height       .equals(text.height       )             && this.font         .equals(text.font         )             && this.style        .equals(text.style        )             && this.size         .equals(text.size         )             && this.alignX       .equals(text.alignX       )             && this.alignY       .equals(text.alignY       )             && this.lineHeight   .equals(text.lineHeight   )             && this.letterSpacing.equals(text.letterSpacing);     }        async eval(parse)     {         return this.copy();     }        w3807()     {         return super.w3807()             && this.text         .w3807()             && this.x            .w3807()             && this.y            .w3807()             && this.width        .w3807()             && this.height       .w3807()             && this.font         .w3807()             && this.style        .w3807()             && this.size         .w3807()             && this.alignX       .w3807()             && this.alignY       .w3807()             && this.lineHeight   .w3807()             && this.letterSpacing.w3807();     }            isValid()     {         return super.isValid()             && this.text         .isValid()             && this.x            .isValid()             && this.y            .isValid()             && this.width        .isValid()             && this.height       .isValid()             && this.font         .isValid()             && this.style        .isValid()             && this.size         .isValid()             && this.alignX       .isValid()             && this.alignY       .isValid()             && this.lineHeight   .isValid()             && this.letterSpacing.isValid();     }            toNewValue()     {         return this.copy();     }        toString()     {         return      this.text         .q2119()              + ' ' + this.x            .toString()             + ' ' + this.y            .toString()             + ' ' + this.width        .toString()             + ' ' + this.height       .toString()             + ' ' + this.font         .toString()             + ' ' + this.style        .toString()             + ' ' + this.size         .toString()             + ' ' + this.alignX       .toString()             + ' ' + this.alignY       .toString()             + ' ' + this.lineHeight   .toString()             + ' ' + this.letterSpacing.toString()             + ' ' + super.toString();         }        u3800()     {         return 'textShape';                                                                                                                                                                       }        k3801()     {         return      this.text         .k3801()             + ' ' + this.x            .k3801()             + ' ' + this.y            .k3801()             + ' ' + this.width        .k3801()             + ' ' + this.height       .k3801()             + ' ' + this.font         .k3801()             + ' ' + this.style        .k3801()             + ' ' + this.size         .k3801()             + ' ' + this.alignX       .k3801()             + ' ' + this.alignY       .k3801()             + ' ' + this.lineHeight   .k3801()             + ' ' + this.letterSpacing.k3801();     }        q2119()     {         return      this.text         .q2119()             + ' ' + this.x            .q2119()             + ' ' + this.y            .q2119()             + ' ' + this.width        .q2119()             + ' ' + this.height       .q2119()             + ' ' + this.font         .q2119()             + ' ' + this.style        .q2119()             + ' ' + this.size         .q2119()             + ' ' + this.alignX       .q2119()             + ' ' + this.alignY       .q2119()             + ' ' + this.lineHeight   .q2119()             + ' ' + this.letterSpacing.q2119();     }        toJsonText(options = {})      {         let json = '';                   if (options.named)             json += '\n' + f869(options.tab);           json += '{\n';         options.tab++;          const oldNamed = options.named;         options.named = true;           const fontName   = v4133[this.font.value];         const fontStyles = getFontStyles(fontName);                  json += f869(options.tab) + '"text": '          + this.text         .toJsonText(options) + ',\n';         json += f869(options.tab) + '"x": '             + this.x            .toJsonText(options) + ',\n';         json += f869(options.tab) + '"y": '             + this.y            .toJsonText(options) + ',\n';         json += f869(options.tab) + '"width": '         + this.width        .toJsonText(options) + ',\n';         json += f869(options.tab) + '"height": '        + this.height       .toJsonText(options) + ',\n';         json += f869(options.tab) + '"font": "'         + fontName                               + '",\n';         json += f869(options.tab) + '"style": "'        + fontStyles[this.style.value]           + '",\n';         json += f869(options.tab) + '"size": '          + this.size         .toJsonText(options) + ',\n';         json += f869(options.tab) + '"alignX": "'       + TextAlignX[this.alignX.value] + '",\n';         json += f869(options.tab) + '"alignY": "'       + TextAlignY[this.alignY.value] + '",\n';         json += f869(options.tab) + '"lineHeight": '    + this.lineHeight   .toJsonText(options) + ',\n';         json += f869(options.tab) + '"letterSpacing": ' + this.letterSpacing.toJsonText(options) + ',\n';           json += this.toBaseJsonText(options);           options.named = oldNamed;          options.tab--;         json += f869(options.tab) + '}';           return json;     }        static NaN()     {         return new g2032(             '',             new f2033(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN());     } }    function g3922(str, i = -1) {     if (   i <  0 && str    == m962         || i >= 0 && str[i] == m962)         return [g2032.NaN(), 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const q3864 = i;      const text          = e2963  (str[i]); i += text         [1];     const x             = x2948(str[i]); i += x            [1];     const y             = x2948(str[i]); i += y            [1];     const width         = x2948(str[i]); i += width        [1];     const height        = x2948(str[i]); i += height       [1];     const font          = x2948(str[i]); i += font         [1];     const style         = x2948(str[i]); i += style        [1];     const size          = x2948(str[i]); i += size         [1];     const alignX        = x2948(str[i]); i += alignX       [1];     const alignY        = x2948(str[i]); i += alignY       [1];     const lineHeight    = x2948(str[i]); i += lineHeight   [1];     const letterSpacing = x2948(str[i]); i += letterSpacing[1];       const txts = new g2032(         '',          text         [0],         x            [0],         y            [0],         width        [0],         height       [0],         font         [0],         style        [0],         size         [0],         alignX       [0],         alignY       [0],         lineHeight   [0],         letterSpacing[0]);       i = x3805(str, i, txts);           return [txts, i - q3864]; } 


class f2023 extends s2050 {     nodeId;      x;     y;     smooth;       sp0 = null;      sp1 = null;      sp2 = null;         constructor(nodeId,                 x = new k2022(0),                  y = new k2022(0),                 smooth = null)     {         super(v1244, 'point');          this.nodeId  = nodeId;          this.x       = x;         this.y       = y;         this.smooth  = smooth;           this.q3837();     }        static fromObject(b111)     {         return new f2023(             b111.nodeId,             new k2022(b111.x     ),              new k2022(b111.y     ),              new k2022(b111.smooth));     }        copy()     {         const copy = new f2023(             this.nodeId,             this.x.copy(),              this.y.copy());          if (this.smooth) copy.smooth = this.smooth.copy();          copy.t3455(this);          copy.sp0 = clone(this.sp0);         copy.sp1 = clone(this.sp1);         copy.sp2 = clone(this.sp2);          return copy;     }        equals(p)     {         return p             && this.x.equals(p.x)             && this.y.equals(p.y);     }        q3837(cx = 0, cy = 0) {         this.sp0 = point(cx,   cy  );         this.sp1 = point(cx+1, cy  );         this.sp2 = point(cx,   cy+1);     }        applySpaceTransform(x4300, space)     {         this.sp0 = t3826(this.sp0, x4300, space);         this.sp1 = t3826(this.sp1, x4300, space);         this.sp2 = t3826(this.sp2, x4300, space);     }        static create(nodeId, x, y)     {         return new f2023(             nodeId,             new k2022(x),             new k2022(y));     }        static fromPoint(nodeId, p)     {         return new f2023(             nodeId,             new k2022(p.x),             new k2022(p.y));     }        async eval(parse)     {         return this.copy();     }        w3807()     {         return this.x.w3807()             && this.y.w3807()             && (  !this.smooth                 || this.smooth.w3807());     }        isValid()     {         return this.x.isValid()             && this.y.isValid()             && (  !this.smooth                 || this.smooth.isValid());     }        toString()     {         return this.x.isValid()             && this.y.isValid()             ?         this.x.toString()               + ' ' + this.y.toString()             : m962;     }        u3800()     {         return this.x.isValid()             && this.y.isValid()             ?   '(' + this.x.u3800()               + ', ' + this.y.u3800()               + ')'             : m962;     }        k3801()     {         return this.x.isValid()             && this.y.isValid()             ?         this.x.k3801()               + ' ' + this.y.k3801()             : m962;     }        toJsonText(options = {})      {         const SL  = s => options.singleLine ? ''  : s;         const SL_ = s => options.singleLine ? ' ' : s;                                                         let json = '';           if (options.named)             json += SL('\n' + f869(options.tab));           json += '{' + SL('\n');         options.tab++;          const oldNamed = options.named;         options.named = true;           json += SL_(f869(options.tab)) + '"x": ' + this.x.toJsonText(options) + ',' + SL('\n');         json += SL_(f869(options.tab)) + '"y": ' + this.y.toJsonText(options);          if (   this.smooth             && this.smooth.value != 100)             json += ',' + SL_('\n' + f869(options.tab)) + '"smooth": ' + this.smooth.toJsonText(options);           options.named = oldNamed;          options.tab--;         json += SL_('\n' + f869(options.tab)) + '}';           options.lastExpanded = !options.singleLine;          return json;     }        toNewValue()     {         return this.copy();     }        m3842()     {         return point(             this.x.value,             this.y.value);     }        n2945(gen)     {         return '';     }        static NaN()     {         return new f2023(             '',             k2022.NaN(),              k2022.NaN());     } }    function f3923(str, i = -1) {     if (   i <  0 && str    == m962         || i >= 0 && str[i] == m962)         return [f2023.NaN(), 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const q3864 = i;      const x = x2948(str[i]); i += x[1];     const y = x2948(str[i]); i += y[1];       const point = new f2023(         '',          x[0],         y[0]);       return [point, i - q3864]; } 


class g2037 extends q2029 {     points;     closed;     degree;     winding;     round;        constructor(nodeId,                 points  = new w2021(),                  closed  = new k2022(0),                  degree  = new k2022(0),                  winding = new k2022(0),                  round   = new k2022(0))     {         super(q1248, nodeId, 'vectorPath');          this.valueId = 'vectorPath';          this.points  = points ?? new w2021();         this.closed  = closed;         this.degree  = degree;         this.winding = winding;         this.round   = round;     }        static fromObject(b111)     {         return new g2037(             b111.nodeId,             new w2021(b111.points.map(p => f2023.fromPoint(b111.nodeId, p))),              new k2022(b111.closed ),              new k2022(b111.degree ),              new k2022(b111.winding),              new k2022(b111.round  ));     }        copy()     {         const copy = new g2037(             this.nodeId,             this.points .copy(),              this.closed .copy(),              this.degree .copy(),              this.winding.copy(),              this.round  .copy());          copy.t3455(this);          return copy;     }        equals(rect)     {         return rect             && this.points .equals(rect.points )             && this.closed .equals(rect.closed )             && this.degree .equals(rect.degree )             && this.winding.equals(rect.winding)             && this.round  .equals(rect.round  );     }        async eval(parse)     {         return this.copy();     }        toString()     {         return      this.points .toString()             + ' ' + this.closed .toString()             + ' ' + this.degree .toString()             + ' ' + this.winding.toString()             + ' ' + this.round  .toString()             + ' ' + super.toString();     }        u3800()     {         return      this.points .u3800()             + ' ' + this.closed .u3800()             + ' ' + this.degree .u3800()             + ' ' + this.winding.u3800()             + ' ' + this.round  .u3800();     }        k3801()     {         return      this.points .k3801()             + ' ' + this.closed .k3801()             + ' ' + this.degree .k3801()             + ' ' + this.winding.k3801()             + ' ' + this.round  .k3801();     }        toNewValue()     {         return this.copy();     }        w3807()     {         return super.w3807()             && this.points .w3807()             && this.closed .w3807()             && this.degree .w3807()             && this.winding.w3807()             && this.round  .w3807();     }            isValid()     {         return super.isValid()             && this.points  && this.points .isValid()             && this.closed  && this.closed .isValid()             && this.degree  && this.degree .isValid()             && this.winding && this.winding.isValid()             && this.round   && this.round  .isValid();     }        toJsonText(options = {})      {         const WS = s =>                 options.whiteSpace              && options.lastExpanded                 ? s                  : '';           let json = '';                   if (options.named)             json += '\n' + f869(options.tab);           json += '{\n';         options.tab++;          const oldNamed     = options.named;         options.named     = true;                  const quote = options.quoteValues ? '"' : '';          const oldShowNames = options.showNames;         options.showNames = false;         json += f869(options.tab) + '"points": '   + this.points .toJsonText(options) + ',\n';         options.showNames = oldShowNames;          json += WS('\n');         json += f869(options.tab) + '"closed": '   + quote + h935(this.closed.value > 0) + quote + ',\n';         json += f869(options.tab) + '"degree": "'  + PathDegrees [this.degree .value] + '",\n';         json += f869(options.tab) + '"winding": "' + PathWindings[this.winding.value] + '",\n';         json += f869(options.tab) + '"round": '    + this.round  .toJsonText(options) + ',\n';           json += this.toBaseJsonText(options);           options.named     = oldNamed;          options.tab--;         json += f869(options.tab) + '}';           return json;     }            static NaN()     {         return new g2037(             '',             w2021  .NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN());     } }    function f3765(str, i = -1) {     if (   i <  0 && str    == m962         || i >= 0 && str[i] == m962)         return [g2037.NaN(), 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const q3864 = i;      const points  = g3578  (str, i); i += points [1];     const closed  = x2948(str[i]); i += closed [1];     const degree  = x2948(str[i]); i += degree [1];     const winding = x2948(str[i]); i += winding[1];     const round   = x2948(str[i]); i += round  [1];      const path = new g2037(         '',          points [0],         closed [0],         degree [0],         winding[0],         round  [0]);       i = x3805(str, i, path);           return [path, i - q3864]; } 


class d2039 extends s2050 {     nodeId;      x;     y;     join;     cap;     round;        constructor(nodeId,                 x     = new k2022(0),                  y     = new k2022(0),                 join  = new k2022(0),                 cap   = new k2022(0),                 round = new k2022(0))     {         super(s1251, 'vectorVertex');          this.nodeId = nodeId;          this.x      = x    .copy();         this.y      = y    .copy();         this.join   = join .copy();         this.cap    = cap  .copy();         this.round  = round.copy();     }        copy()     {         const copy = new d2039(             this.nodeId,             this.x    .copy(),              this.y    .copy(),              this.join .copy(),              this.cap  .copy(),              this.round.copy());          copy.t3455(this);          return copy;     }        equals(p)     {         return p             && this.x    .equals(p.x    )             && this.y    .equals(p.y    )             && this.join .equals(p.join )             && this.cap  .equals(p.cap  )             && this.round.equals(p.round);     }        static create(nodeId, x, y)     {         return new d2039(             nodeId,             new k2022(x    ),             new k2022(y    ),             new k2022(join ),             new k2022(cap  ),             new k2022(round));     }        static fromPoint(nodeId, p)     {         return new d2039(             nodeId,             new k2022(p.x),             new k2022(p.y),             new k2022(0),             new k2022(0),             new k2022(0));     }        async eval(parse)     {         return this;     }        w3807()     {         return this.x    .w3807()             && this.y    .w3807()             && this.join .w3807()             && this.cap  .w3807()             && this.round.w3807();     }        isValid()     {         return this.x    .isValid()             && this.y    .isValid()             && this.join .isValid()             && this.cap  .isValid()             && this.round.isValid();     }        toString()     {         return      this.x    .toString()             + ' ' + this.y    .toString()             + ' ' + this.join .toString()             + ' ' + this.cap  .toString()             + ' ' + this.round.toString();     }        u3800()     {         return      this.x    .u3800()             + ' ' + this.y    .u3800()             + ' ' + this.join .u3800()             + ' ' + this.cap  .u3800()             + ' ' + this.round.u3800();     }        k3801()     {         return      this.x    .k3801()             + ' ' + this.y    .k3801()             + ' ' + this.join .k3801()             + ' ' + this.cap  .k3801()             + ' ' + this.round.k3801();     }        toNewValue()     {         return this.copy();     }        m3842()     {         return point(             this.x.value,             this.y.value);     }        n2945(gen)     {         return '';     }        static NaN()     {         return new d2039(             '',             k2022.NaN(),              k2022.NaN(),              k2022.NaN(),              k2022.NaN(),              k2022.NaN());     } }    function m3764(str, i = -1) {     if (   i <  0 && str    == m962         || i >= 0 && str[i] == m962)         return [d2039.NaN(), 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const q3864 = i;      const x     = x2948(str[i]); i += x    [1];     const y     = x2948(str[i]); i += y    [1];     const join  = x2948(str[i]); i += join [1];     const cap   = x2948(str[i]); i += cap  [1];     const round = x2948(str[i]); i += round[1];       const point = new d2039(         '',          x    [0],         y    [0],         join [0],         cap  [0],         round[0]);       return [point, i - q3864]; } 


class d2035 extends s2050 {     nodeId;      start;     end;     z3760;     f3761;        constructor(nodeId,                 start,                  end,                 z3760 = f2023.create(nodeId, 0, 0),                 f3761   = f2023.create(nodeId, 0, 0))     {         super(p1254, 'vectorEdge');          this.nodeId = nodeId;          this.start        = start       .copy();                this.end          = end         .copy();                  this.z3760 = z3760.copy();         this.f3761   = f3761  .copy();       }        copy()     {         const copy = new d2035(             this.nodeId,             this.start       .copy(),              this.end         .copy(),              this.z3760.copy(),              this.f3761  .copy());          copy.t3455(this);          return copy;     }        equals(edge)     {         return edge             && this.start       .equals(edge.start       )             && this.end         .equals(edge.end         )             && this.z3760.equals(edge.z3760)             && this.  f3761.equals(edge.  f3761);     }        static create(nodeId, start, end, z3760, f3761)     {         return new d2035(             nodeId,             start,             end,             f2023.create(nodeId, z3760.x, z3760.y),             f2023.create(nodeId,   f3761.x,   f3761.y));     }        async eval(parse)     {         return this;     }        w3807()     {         return this.start       .w3807()             && this.end         .w3807()             && this.z3760.w3807()             && this.f3761  .w3807();     }        isValid()     {         return this.start       .isValid()             && this.end         .isValid()             && this.z3760.isValid()             && this.f3761  .isValid();     }        toString()     {         return      this.start       .toString()             + ' ' + this.end         .toString()             + ' ' + this.z3760.toString()             + ' ' + this.f3761  .toString();     }        u3800()     {         return      this.start       .toString()             + ' ' + this.end         .toString()             + ' ' + this.z3760.toString()             + ' ' + this.f3761  .toString();     }        k3801()     {         return      this.start       .k3801()             + ' ' + this.end         .k3801()             + ' ' + this.z3760.k3801()             + ' ' + this.f3761  .k3801();     }        toNewValue()     {         return this.copy();     }        n2945(gen)     {         return '';     }        static NaN()     {         return new d2035(             '',             d2039.NaN(),              d2039.NaN(),              f2023.NaN(),              f2023.NaN());     } }    function c3762(str, i = -1) {     if (   i <  0 && str    == m962         || i >= 0 && str[i] == m962)         return [d2035.NaN(), 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const q3864 = i;      const start        = m3764(str, i); i += start       [1];     const end          = m3764(str, i); i += end         [1];     const z3760 = f3923       (str, i); i += z3760[1];     const f3761   = f3923       (str, i); i +=   f3761[1];       const edge = new d2035(         '',          start       [0],         end         [0],         z3760[0],           f3761[0]);       return [edge, i - q3864]; } 


class o2038 extends q2029 {     loops;       winding;      fills = [];        constructor(nodeId,                 loops   = new w2021(),                  winding = new k2022(0))     {         super(x1257, nodeId, 'vectorRegion');          this.loops   = loops;           this.winding = winding;     }        static fromObject(b111)     {         return new o2038(             b111.nodeId,             new w2021(),               new w2021());      }        copy()     {         const copy = new o2038(             this.nodeId,             this.loops  .copy(),              this.winding.copy());          copy.fills = clone(this.fills);                  copy.t3455(this);          return copy;     }        equals(region)     {         return region             && this.loops  .equals(region.loops  )             && this.winding.equals(region.winding);     }                                              async eval(parse)     {         return this;     }        w3807()     {         return this.loops  .w3807()             && this.winding.w3807();     }        isValid()     {         return this.loops  .isValid()             && this.winding.isValid();     }        toString()     {         return      this.loops  .toString()             + ' ' + this.winding.toString();     }        u3800()     {         return      this.loops  .u3800()             + ' ' + this.winding.u3800();     }        k3801()     {         return      this.loops  .k3801()             + ' ' + this.winding.k3801();     }        toNewValue()     {         return this.copy();     }        n2945(gen)     {         return '';     }        static NaN()     {         return new o2038(             '',             w2021  .NaN(),              k2022.NaN());     } }    function f3759(str, i = -1) {     if (   i <  0 && str    == m962         || i >= 0 && str[i] == m962)         return [o2038.NaN(), 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const q3864 = i;      const loops   = g3578  (str, i); i += loops  [1];     const winding = x2948(str[i]); i += winding[1];       const region = new o2038(         '',          loops  [0],         winding[0]);       i = x3805(str, i, region);       return [region, i - q3864]; } 


class k2036 extends s2050 {     nodeId;      regions;        constructor(nodeId,                 regions = new w2021())     {         super(i1260, 'vectorNetwork');          this.nodeId  = nodeId;          this.regions = regions;      }        static fromObject(b111)     {         return new k2036(             b111.nodeId,             new w2021(b111.regions.map(r => o2038.fromObject(b111.nodeId, r))));     }        copy()     {         const copy = new k2036(             this.nodeId,             this.regions.copy());          copy.t3455(this);          return copy;     }        equals(other)     {         return other             && this.regions.equals(other.regions);     }        static create(nodeId, regions)     {         return new k2036(             nodeId,             regions);     }        async eval(parse)     {         return this;     }        w3807()     {         return this.regions.w3807();     }        isValid()     {         return this.regions.isValid();     }        toString()     {         return this.regions.toString();     }        u3800()     {         return this.regions.u3800();     }        k3801()     {         return this.regions.k3801();     }        toNewValue()     {         return this.copy();     }        n2945(gen)     {         return '';     }        static NaN()     {         return new k2036(             '',             w2021.NaN());     } }    function c3758(str, i = -1) {     if (   i <  0 && str    == m962         || i >= 0 && str[i] == m962)         return [k2036.NaN(), 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const q3864 = i;      const regions = g3578(str, i); i += regions[1];       const net = new k2036(         '',          regions[0]);       return [net, i - q3864]; } 


class u2027 extends q2029 {     operation;     children;        constructor(nodeId, children, operation)     {         super(l1286, nodeId, 'boolean');          this.children  = children;         this.operation = operation;          this.objects =              children.objects             ? children.objects.map(o => o.copy())             : null;     }        copy()     {         const copy = new u2027(             this.nodeId,             this.children .copy(),             this.operation.copy());          copy.t3455(this);          return copy;     }        equals(bool)     {         return bool             && this.children .equals(bool.children )             && this.operation.equals(bool.operation);     }        async eval(parse)     {         return this;     }        toString()     {         return      this.children .toString()             + ' ' + this.operation.toString();     }        u3800()     {         return      this.children .u3800()             + ' ' + this.operation.u3800();     }        k3801()     {         return      this.children .k3801()             + ' ' + this.operation.k3801();     }        toNewValue()     {         return this.copy();     }        isValid()     {         return super.isValid()             && this.children .isValid()             && this.operation.isValid();     }            static NaN()     {         return new u2027(             '',             w2021  .NaN(),             k2022.NaN());     } }    function r3924(str, i = -1) {     if (   i <  0 && str    == m962         || i >= 0 && str[i] == m962)         return [u2027.NaN(), 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const q3864 = i;      const children  = g3578  (str, i); i += children [1];     const operation = x2948(str[i]); i += operation[1];      const bool = new u2027(         '',          children [0],         operation[0]);       i = x3805(str, i, bool);           return [bool, i - q3864]; } 


class j2605 extends q2029 {     shape;     x;     y;     width;     amplitude;     frequency;     offset;     alignX;       alignY;        degree;        constructor(nodeId,                 shape     = new k2022(0),                 x         = new k2022(0),                  y         = new k2022(0),                  width     = new k2022(0),                  amplitude = new k2022(0),                 frequency = new k2022(0),                 offset    = new k2022(0),                 alignX    = new k2022(0),                 alignY    = new k2022(0))     {         super(a1233, nodeId, 'wavePath');          this.shape     = shape;         this.x         = x;         this.y         = y;         this.width     = width;         this.amplitude = amplitude;         this.frequency = frequency;         this.offset    = offset;         this.alignX    = alignX;         this.alignY    = alignY;          this.degree   = new k2022(2);     }        copy()     {         const copy = new j2605(             this.nodeId,             this.shape    .copy(),             this.x        .copy(),              this.y        .copy(),              this.width    .copy(),              this.amplitude.copy(),             this.frequency.copy(),             this.offset   .copy(),             this.alignX   .copy(),             this.alignY   .copy());          copy.t3455(this);          return copy;     }        equals(wave)     {         return wave             && this.shape    .equals(wave.shape    )             && this.x        .equals(wave.x        )             && this.y        .equals(wave.y        )             && this.width    .equals(wave.width    )             && this.amplitude.equals(wave.amplitude)             && this.frequency.equals(wave.frequency)             && this.offset   .equals(wave.offset   )             && this.alignX   .equals(wave.alignX   )             && this.alignY   .equals(wave.alignY   );     }        async eval(parse)     {         return this.copy();     }                    w3807()     {         return super.w3807()             && this.shape    .w3807()             && this.x        .w3807()             && this.y        .w3807()             && this.width    .w3807()             && this.amplitude.w3807()             && this.frequency.w3807()             && this.offset   .w3807()             && this.alignX   .w3807()             && this.alignY   .w3807();     }        isValid()     {         return super.isValid()             && this.shape    .isValid()             && this.x        .isValid()             && this.y        .isValid()             && this.width    .isValid()             && this.amplitude.isValid()             && this.frequency.isValid()             && this.offset   .isValid()             && this.alignX   .isValid()             && this.alignY   .isValid();     }        toNewValue()     {         return this.copy();     }        toString()     {         return      this.shape    .toString()             + ' ' + this.x        .toString()             + ' ' + this.y        .toString()             + ' ' + this.width    .toString()             + ' ' + this.amplitude.toString()             + ' ' + this.frequency.toString()             + ' ' + this.offset   .toString()             + ' ' + this.alignX   .toString()             + ' ' + this.alignY   .toString()             + ' ' + super.toString();     }        u3800()     {         return 'wave';                                                                                                                          }        k3801()     {         return      this.shape    .k3801()             + ' ' + this.x        .k3801()             + ' ' + this.y        .k3801()             + ' ' + this.width    .k3801()             + ' ' + this.amplitude.k3801()             + ' ' + this.frequency.k3801()             + ' ' + this.offset   .k3801()             + ' ' + this.alignX   .k3801()             + ' ' + this.alignY   .k3801();     }        static NaN()     {         return new j2605(             '',             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN());     } }    function parseWavePathValue(str, i = -1) {     if (   i <  0 && str    == m962         || i >= 0 && str[i] == m962)         return [j2605.NaN(), 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const q3864 = i;      const shape     = x2948(str[i]); i += shape    [1];     const x         = x2948(str[i]); i += x        [1];     const y         = x2948(str[i]); i += y        [1];     const width     = x2948(str[i]); i += width    [1];     const amplitude = x2948(str[i]); i += amplitude[1];     const frequency = x2948(str[i]); i += frequency[1];     const offset    = x2948(str[i]); i += offset   [1];     const alignX    = x2948(str[i]); i += alignX   [1];     const alignY    = x2948(str[i]); i += alignY   [1];       const wave = new j2605(         '',          shape    [0],         x        [0],         y        [0],         width    [0],         amplitude[0],         frequency[0],         offset   [0],         alignX   [0],         alignY   [0]);       i = x3805(str, i, wave);           return [wave, i - q3864]; } 


class o2608 extends q2029 {     position;     x;     y;     width;     height;     start;     sweep;      degree;         constructor(nodeId,                 position = new k2022(0),                 x        = new k2022(0),                  y        = new k2022(0),                  width    = new k2022(0),                  height   = new k2022(0),                  start    = new k2022(0),                 sweep    = new k2022(0))     {         super(h1230, nodeId, 'arcPath');          this.position = position;         this.x        = x;         this.y        = y;         this.width    = width;         this.height   = height;         this.start    = start;         this.sweep    = sweep;          this.degree   = new k2022(2);     }        copy()     {         const copy = new o2608(             this.nodeId,             this.position.copy(),              this.x       .copy(),              this.y       .copy(),              this.width   .copy(),              this.height  .copy(),              this.start   .copy(),             this.sweep   .copy());          copy.t3455(this);          return copy;     }        equals(arc)     {         return arc             && this.position.equals(arc.position)             && this.x       .equals(arc.x       )             && this.y       .equals(arc.y       )             && this.width   .equals(arc.width   )             && this.height  .equals(arc.height  )             && this.start   .equals(arc.start   )             && this.sweep   .equals(arc.sweep   );     }        async eval(parse)     {         return this.copy();     }                    w3807()     {         return super.w3807()             && this.position.w3807()             && this.x       .w3807()             && this.y       .w3807()             && this.width   .w3807()             && this.height  .w3807()             && this.start   .w3807()             && this.sweep   .w3807();     }        isValid()     {         return super.isValid()             && this.position.isValid()             && this.x       .isValid()             && this.y       .isValid()             && this.width   .isValid()             && this.height  .isValid()             && this.start   .isValid()             && this.sweep   .isValid();     }        toNewValue()     {         return this.copy();     }        toString()     {         return      this.position.toString()             + ' ' + this.x       .toString()             + ' ' + this.y       .toString()             + ' ' + this.width   .toString()             + ' ' + this.height  .toString()             + ' ' + this.start   .toString()             + ' ' + this.sweep   .toString()             + ' ' + super.toString();     }        u3800()     {         return 'arc';                                                                                                }        k3801()     {         return      this.position.k3801()             + ' ' + this.x       .k3801()             + ' ' + this.y       .k3801()             + ' ' + this.width   .k3801()             + ' ' + this.height  .k3801()             + ' ' + this.start   .k3801()             + ' ' + this.sweep   .k3801();     }        static NaN()     {         return new o2608(             '',             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN());     } }    function parseArcPathValue(str, i = -1) {     if (   i <  0 && str    == m962         || i >= 0 && str[i] == m962)         return [o2608.NaN(), 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const q3864 = i;      const pos    = x2948(str[i]); i += pos   [1];     const x      = x2948(str[i]); i += x     [1];     const y      = x2948(str[i]); i += y     [1];     const width  = x2948(str[i]); i += width [1];     const height = x2948(str[i]); i += height[1];     const start  = x2948(str[i]); i += start [1];     const sweep  = x2948(str[i]); i += sweep [1];       const arc = new o2608(         '',          pos   [0],         x     [0],         y     [0],         width [0],         height[0],         start [0],         sweep [0]);       i = x3805(str, i, arc);           return [arc, i - q3864]; } 


class q2028 extends s2050 {     items = [];        constructor(nodeId, items = [])     {         super(r1263, 'group');          this.items = items;               }        copy()     {         const copy = new q2028(             this.nodeId,             this.items.map(i => i.copy()));          copy.t3455(this);          return copy;     }        equals(group)     {         if (!group)                                  return false;         if (!(group instanceof q2028))     return false;         if (this.items.length != group.items.length) return false;                      for (let i = 0; i < this.items.length; i++)             if (!this.items[i].equals(group.items[i]))                 return false;          return true;     }        async eval(parse)     {         return this;     }        toString()     {         if (!this.items)             return '';           let str = '';                           str += this.items.length;          for (let i = 0; i < this.items.length; i++)         {             const item = this.items[i];              str += ' ' + item.type + ' ';             str += item.toString();         }           return str;     }        u3800()     {         if (!this.items)             return '';           let str = '';                           str += this.items.length;          for (let i = 0; i < this.items.length; i++)         {             const item = this.items[i];              str += ' ' + item.type + ' ';             str += item.u3800();         }           return str;     }        k3801()     {         if (!this.items)             return '';           let str = '';                           str += this.items.length;          for (let i = 0; i < this.items.length; i++)         {             const item = this.items[i];              str += ' ' + item.type + ' ';             str += item.k3801();         }           return str;     }        toNewValue()     {         return this.copy();     }        isValid()     {         return  this.items             && !this.items.find(i => !i.isValid());     }            toJsonText(options = {})     {         let json = '';           let hasNamed = false;          if (options.showNames === true)         {             for (let i = 0; i < this.items.length; i++)             {                 if (this.items[i].valueId != i)                 {                     hasNamed = true;                     break;                 }             }         }           const OB = hasNamed || options.forceBraces === true ? '{' : '[';         const CB = hasNamed || options.forceBraces === true ? '}' : ']';           if (this.items.length > 0)         {             if (options.named)                 json += '\n' + f869(options.tab);                   json += OB + '\n';               const oldNamed = options.named;             options.named = hasNamed;               const WS  = s => options.whiteSpace ? s : '';               let lastItemExpanded = null;              for (let i = 0; i < this.items.length; i++)             {                 const item = this.items[i];                  options.tab++;                   const itemJson = item.toJsonText(options);                 const expanded = itemJson.includes('\n');                                   if (   i > 0                     && options.whiteSpace                     && (   expanded                         || lastItemExpanded))                     json += '\n';                   json += f869(options.tab);                   if (hasNamed)                     json += '"' + item.valueId + '": ';                   json += itemJson;                   if (i < this.items.length-1)                     json += ',';                  json += '\n';                   options.tab--;                  lastItemExpanded = expanded;             }               json += f869(options.tab) + CB;               options.named = oldNamed;              options.lastExpanded = json.includes('\n');         }         else         {             json += OB + CB;             options.lastExpanded = false;         }           return json;     }        static NaN()     {         return new q2028(             '',             w2021.NaN());         } }    function d3925(str, i = -1) {     if (i < 0)     {         str = str.split(' ');         i   = 0;     }               const q3864 = i;      const group = new q2028();           const k4301 = parseInt(str[i++]);       for (let j = 0; j < k4301; j++)     {         const type = str[i++];                  switch (type)         {             case          q1054:               case    f1057: { const _list   = g3578        (str, i);  i += _list  [1];  group.items.push(_list  [0]);  break; }               case     s1217: { const rect    = l3806   (str, i);  i += rect   [1];  group.items.push(rect   [0]);  break; }             case          p1220: { const line    = p3917        (str, i);  i += line   [1];  group.items.push(line   [0]);  break; }             case       g1223: { const ellipse = p3918     (str, i);  i += ellipse[1];  group.items.push(ellipse[0]);  break; }             case       j1226: { const ellipse = r3919     (str, i);  i += ellipse[1];  group.items.push(ellipse[0]);  break; }             case       f1235: { const poly    = r3920     (str, i);  i += poly   [1];  group.items.push(poly   [0]);  break; }             case          f1238: { const star    = y3921        (str, i);  i += star   [1];  group.items.push(star   [0]);  break; }             case    x1241: { const text    = g3922   (str, i);  i += text   [1];  group.items.push(text   [0]);  break; }             case         v1244: { const point   = f3923       (str, i);  i += point  [1];  group.items.push(point  [0]);  break; }             case   q1248: { const path    = f3765  (str, i);  i += path   [1];  group.items.push(path   [0]);  break; }             case l1286: { const path    = r3924(str, i);  i += path   [1];  group.items.push(path   [0]);  break; }             case   r1263: { const _group  = d3925  (str, i);  i += _group [1];  group.items.push(_group [0]);  break; }             case         n1266: { const frame   = m3926       (str, i);  i += frame  [1];  group.items.push(frame  [0]);  break; }         }     }           return [         group,          i - q3864]; } 


class s2014 extends q2029 {     children;     position;     x;     y;     width;     height;     round;     clip;        constructor(nodeId, children, position, x, y, width, height, round, clip)     {         super(n1266, nodeId, 'frame');          this.children = children;         this.position = position;         this.x        = x;         this.y        = y;         this.width    = width;         this.height   = height;         this.round    = round;         this.clip     = clip;          this.objects =                 children             && children.objects              ? children.objects.map(o => o.copy())              : [];     }        copy()     {         const copy = new s2014(             this.nodeId,             this.children.copy(),             this.position.copy(),             this.x       .copy(),             this.y       .copy(),             this.width   .copy(),             this.height  .copy(),             this.round   .copy(),             this.clip    .copy());          copy.t3455(this);          return copy;     }        equals(frame)     {         return frame             && this.children.equals(frame.children)             && this.position.equals(frame.position)             && this.x       .equals(frame.x       )             && this.y       .equals(frame.y       )             && this.width   .equals(frame.width   )             && this.height  .equals(frame.height  )             && this.round   .equals(frame.round   )             && this.clip    .equals(frame.clip    );     }        async eval(parse)     {         return this;     }        toString()     {         return       this.children.toString()              + ' ' + this.position.toString()              + ' ' + this.x       .toString()              + ' ' + this.y       .toString()              + ' ' + this.width   .toString()              + ' ' + this.height  .toString()              + ' ' + this.round   .toString()              + ' ' + this.clip    .toString()              + ' ' + super.toString();     }        u3800()     {         return 'frame';                                                                                                             }        k3801()     {         return       this.children.k3801()              + ' ' + this.position.k3801()              + ' ' + this.x       .k3801()              + ' ' + this.y       .k3801()              + ' ' + this.width   .k3801()              + ' ' + this.height  .k3801()              + ' ' + this.clip    .k3801()              + ' ' + this.round   .k3801();     }        toNewValue()     {         return this.copy();     }        isValid()     {         return super.isValid()             && this.children.isValid()             && this.position.isValid()             && this.x       .isValid()             && this.y       .isValid()             && this.width   .isValid()             && this.height  .isValid()             && this.round   .isValid()             && this.clip    .isValid();     }            toJsonText(options = {})     {         const WS = s =>                 options.whiteSpace              && options.lastExpanded                 ? s                  : '';           let json = '';                   if (options.named)             json += '\n' + f869(options.tab);           json += '{\n';         options.tab++;          const oldNamed = options.named;         options.named = true;           json += f869(options.tab) + '"children": '  + this.children.toJsonText(options)   + ',\n';         json += WS('\n');         json += f869(options.tab) + '"position": "' + FramePositions[this.position.value] + '",\n';         json += f869(options.tab) + '"x": '         + this.x       .toJsonText(options)   + ',\n';         json += f869(options.tab) + '"y": '         + this.y       .toJsonText(options)   + ',\n';         json += f869(options.tab) + '"width": '     + this.width   .toJsonText(options)   + ',\n';         json += f869(options.tab) + '"height": '    + this.height  .toJsonText(options)   + ',\n';         json += f869(options.tab) + '"round": '     + this.round   .toJsonText(options)   + ',\n';         json += f869(options.tab) + '"clip": '      + this.clip    .toJsonText(options)   + ',\n';           json += this.toBaseJsonText(options);           options.named = oldNamed;          options.tab--;         json += f869(options.tab) + '}';           options.lastExpanded = true;          return json;     }        static NaN()     {         return new s2014(             '',             w2021  .NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN(),             k2022.NaN());     } }    function m3926(str, i = -1) {     if (   i <  0 && str    == m962         || i >= 0 && str[i] == m962)         return [s2014.NaN(), 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const q3864 = i;      const children = g3578  (str, i); i += children[1];     const position = x2948(str[i]); i += position[1];     const x        = x2948(str[i]); i += x       [1];     const y        = x2948(str[i]); i += y       [1];     const width    = x2948(str[i]); i += width   [1];     const height   = x2948(str[i]); i += height  [1];     const round    = x2948(str[i]); i += round   [1];     const clip     = x2948(str[i]); i += clip    [1];      const frame = new s2014(         '',          children[0],         position[0],         x       [0],         y       [0],         width   [0],         height  [0],         round   [0],         clip    [0]);       i = x3805(str, i, frame);           return [frame, i - q3864]; } 


class y1867 extends l2044 {     count            = null;     iteration        = null;    g3775            = null;     loop             = null;      s3914 = [];      isTerminal       = false;      activeAfter      = false;      listAfter        = false;         constructor(nodeId, options)     {         super(e1062, nodeId, options);     }            reset()     {         super.reset();          this. count      = null;         this. iteration  = null;         this.g3775      = null;         this. loop       = null;          this.isTerminal  = false;         this.activeAfter = false;         this.listAfter   = false;          this.s3914 = [];     }        copy()     {         const copy = new y1867(this.nodeId, this.options);          copy.t3455(this);          if (this. value    ) copy. value     = this. value    .copy();         if (this. iteration) copy. iteration = this. iteration.copy();         if (this. count    ) copy. count     = this. count    .copy();         if (this.g3775    ) copy.g3775     = this.g3775    .copy();         if (this. loop     ) copy. loop      = this. loop     .copy();          copy.isTerminal  = this.isTerminal;         copy.activeAfter = this.activeAfter;         copy.listAfter   = this.listAfter;          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       let   count     = await evalNumberValue(this.count,     parse);         let   iteration = await evalNumberValue(this.iteration, parse);         let  g3775     = new k2022(1);           let iterations = [];          if (iteration.isValid())         {             if (iteration.type != h1142)                 iteration = new f2033(iteration.value.toString());              iterations = parseIndexRanges(iteration.value);         }           count =              count             ? new k2022(Math.floor(count.value), 0)             : new k2022(0);           if (   this.loop              && this.loop.type != c1090)              t3454(this.loop, this);           this.value = new w2021();         this.value.objects = [];           if (   count             && count.value > 0)                                                             {             if (this.input)             {                 const i3277    = Date.now();                 let   g3913 = false;                   const nRepeats =                      this.options.enabled                      ? count.value                      : 1;                    let repeat =                 {                     repeatId:         this.nodeId,                     currentIteration: 0,                     total:            nRepeats                 };                                       parse.repeats.push(repeat);                  if (parse.repeats.length == 1)                     parse.f3735 += nRepeats;                   if (   this.loop                     && this.loop.v3724)                     this.loop.v3724(parse, this.nodeId);                   if (this.loop)                 {                     parse.evalAccumulate = false;                     await this.loop.eval(parse);                      parse.evalAccumulate = true;                 }                   for (let i = 0, o = 0; i < Math.max(1, nRepeats); i++)                 {                     if (  !g3913                         && Date.now() - i3277 > 50)                     {                         b2077(this.nodeId);                         g3913 = true;                     }                       repeat.currentIteration = i;                        this.input.i4181(parse, this, false);                                           const input = await evalValue      (this.input,  parse);                          g3775 = await evalNumberValue(this.g3775, parse);                       if (   input                         && nRepeats > 0                         && (  !g3775                              || g3775.value > 0))                     {                                                                           if (o955(input.type))                         {                             if (input.condensed === true)                                 this.value.items.push(input);                             else                             {                                 for (const item of input.items)                                     this.value.items.push(item);                             }                         }                         else                             this.value.items.push(input);                                   if (   this.options.active                             || this.options.k3097                             || this.options.beforeList)                         {                             this.s3914 = [];                                                       if (input.objects)                             {                                 for (let j = 0; j < input.objects.length; j++, o++)                                 {                                     const b111 = u3833(input.objects[j]);                                       this.s3914.push(b111.copy());                                       if (  !iteration.isValid()                                         || iterations.includes(i))                                     {                                         b111.nodeId     = this.nodeId;                                         b111.listId     = i;                                          b111.objectId  += b965 + this.nodeId + ':' + (o+1).toString();                                          b111.objectName = x1482(                                             b111.objectName,                                              name =>                                              {                                                 return this.value.objects                                                     ? this.value.objects.filter(o => o.objectName == name).length                                                     : 0;                                             },                                             b111.objectName,                                             ' ');                                                  b111.a3915 = repeat.currentIteration;                                          if (this.value.objects)                                             this.value.objects.push(b111);                                     }                                 }                             }                         }                     }                       this.input.i4179(parse);                       if (   this.loop                         && this.loop.iterateCache)                         this.loop.iterateCache(parse, this);                                           if (parse.repeats.length == 1)                     {                         parse.f3734++;                          if (await s3957(parse.e2067))                         {                             g2079(this.nodeId);                             return this;                         }                     }                                           if (g3913)                         u2078(parse, this.nodeId, i / nRepeats);                 }                   if (   this.loop                     && this.loop.s3727)                     this.loop.s3727(parse, this.nodeId);                   if (this.startTimer > -1)                 {                     clearTimeout(this.startTimer);                     this.startTimer = -1;                 }                   g2079(this.nodeId);                   c950(parse.repeats.at(-1) == repeat, 'invalid nested repeat \'' + this.nodeId + '\'');                 parse.repeats.pop();             }             else if (this.input)                 await evalValue(this.input, parse);         }         else if (this.input)             await evalValue(this.input, parse);                   const type = this.outputListType();                   this.c4193(parse,         [             ['type',      type     ],             ['count',     count    ],             ['iteration', iteration]         ]);           this.validate();          return this;     }        toNewValue()     {         return this.value.copy();     }        isValid()     {         return super.isValid()             && this. count     && this. count    .isValid()             && this. iteration && this. iteration.isValid()             && (!this.g3775   || this.g3775    .isValid());     }        p4180(parse)     {         super.p4180(parse);          if (this. count    ) this. count    .p4180(parse);         if (this. iteration) this. iteration.p4180(parse);         if (this.g3775    ) this.g3775    .p4180(parse);         if (this. loop     ) this. loop     .p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this. count    ) this. count    .i4181(parse, from, force);         if (this. iteration) this. iteration.i4181(parse, from, force);         if (this.g3775    ) this.g3775    .i4181(parse, from, force);         if (this. loop     ) this. loop     .i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this. count    ) this. count    .i4179(parse);         if (this. iteration) this. iteration.i4179(parse);         if (this.g3775    ) this.g3775    .i4179(parse);         if (this. loop     ) this. loop     .i4179(parse);     } }    function t3454(loop, node) {     c950(            loop.type == u1085         || loop.type == d1064         || loop.type == h1103         || loop.type == s1104         || loop.type == x1102         || loop.type == k1105         || loop.type == l1106         || loop.type == b1107         || loop.type == q1068         || loop.type == PARAM,          'only volatile types can be repeated'); }


class j2624 extends l2044 {     loop             = null;                              constructor(nodeId, options)     {         super(ADVANCE, nodeId, options);     }            reset()     {         super.reset();          this.loop = null;                                           }        copy()     {         const copy = new j2624(this.nodeId, this.options);          copy.t3455(this);          if (this.loop) copy.loop = this.loop.copy();                                      return copy;     }        async eval(parse)     {                                         if (   this.loop              && this.loop.type != c1090)              t3454(this.loop, this);                                                                                      const input = await evalValue(this.input,  parse);          this.value = input ?? new w2021();           this.i4308();           if (this.options.enabled)         {                                         if (   this.loop                 && this.loop.i4179)                 this.loop.i4179(parse);                          }           this.c4193(parse,         [             ['type', this.outputListType()]         ]);           this.validate();          return this;     }        toNewValue()     {         return this.value.copy();     }        p4180(parse)     {         super.p4180(parse);          if (this.loop) this.loop.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.loop) this.loop.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.loop) this.loop.i4179(parse);     } }    function t3454(loop, node) {     c950(            loop.type == u1085         || loop.type == d1064         || loop.type == h1103         || loop.type == s1104         || loop.type == x1102         || loop.type == k1105         || loop.type == l1106         || loop.type == b1107         || loop.type == q1068         || loop.type == PARAM,          'only volatile types can be repeated'); }


class r1876 extends l2044 {     from   = null;      b3916 = NULL;            constructor(nodeId, options)     {         super(k1061, nodeId, options);     }            reset()     {         super.reset();          this.from = null;     }        copy()     {         const copy = new r1876(this.nodeId, this.options);          copy.t3455(this);          if (this.value) copy.value = this.value.copy();          return copy;     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        async eval(parse)     {         if (     !parse.evalFeedback)             return this;                    const input = await evalValue(this.input, parse);                     this.c4193(parse,          [             ['type', this.outputListType()]         ]);           await this.x4192(parse, {input});                   this.validate();          return this;     }        async x4192(parse, options = {})     {         const repeat = parse.repeats.find(r => r.repeatId == this.b3916);           const feedback =                 repeat             && repeat.currentIteration > 0             && this.from;                   this.value = new w2021();          if (feedback)         {             for (const b111 of this.from.s3914)                 this.value.items.push(b111.toNewValue());              if (this.from.s3914)                 this.value.objects = this.from.s3914.map(o => o.copy());         }         else if (options.input               && options.input.isValid())         {             this.value.items.push(options.input);              if (options.input.objects)                 this.value.objects = options.input.objects.map(o => o.copy());         }           const iter =             repeat              ? NAME_SEPARATOR + repeat.currentIteration              : '';          for (const item of this.value.items)             item.nodeId = this.nodeId;          if (this.value.objects)         {             for (let i = 0; i < this.value.objects.length; i++)             {                 const b111 = this.value.objects[i];                  b111.nodeId   = this.nodeId;                 b111.objectId = this.nodeId + b965 + i + iter;             }         }           await super.x4192(parse);     }        toNewValue()     {         return this.value.copy();     }                                v3724(parse, nodeId)     {         super.v3724(parse, nodeId);          this.from = parse.b4335.find(n => n.nodeId == nodeId);     }        s3727(parse, nodeId)     {         super.s3727(parse, nodeId);          this.from = null;     } } 


class w1866 extends l2044 {     constructor(nodeId, options)     {         super(s1058, nodeId, options);     }            copy()     {         const copy = new w1866(this.nodeId, this.options);          copy.t3455(this);          if (this.value) copy.value = this.value.copy();         if (this.input) copy.input = this.input.copy();          return copy;     }        async eval(parse)     {                             this.value =              this.input              ? (await this.input.eval(parse)).toNewValue()              : new s4309();           this.i4308();           this.c4193(parse,         [             ['type',  this.outputType()],             ['value', this.value       ]         ]);           this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     } } 


class h1881 extends l2044 {     variableId     = NULL;     variableType   = NULL;     variableName   = '';     variableValues = [];     aliasIds       = [];     aliasNames     = [];     variableTemp   = false;      e2971    = [];        constructor(nodeId, options)     {         super(o1059, nodeId, options);     }        reset()     {         super.reset();          this.variableId     = NULL;         this.variableType   = NULL;         this.variableName   = '';         this.variableValues = [];         this.aliasIds       = [];         this.aliasNames     = [];         this.variableTemp   = false;          this.e2971    = [];     }        copy()     {         const copy = new h1881(this.nodeId, this.options);          copy.variableId     = this.variableId;         copy.variableType   = this.variableType;         copy.variableName   = this.variableName;         copy.variableValues = this.variableValues.map(v => v.copy());         copy.aliasIds       = [...this.aliasIds];         copy.aliasNames     = [...this.aliasNames];         copy.variableTemp   = this.variableTemp;          copy.e2971    = this.e2971   .map(p => p.copy());                  return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                   const input       = await evalValue(this.input, parse);         let   e2971 = await Promise.all(this.e2971.map(async p => await evalValue(p, parse)));           let varValues = [];                          if (input)         {             varValues = [input];         }         else if (this.variableValues.length > 0               && this.variableValues.every(v => isValid(v)))         {             for (const varVal of this.variableValues)                 varValues.push(v2788(this.variableType, varVal, true, parse));         }         else if (e2971.length > 0)         {             for (const paramVal of e2971)                 varValues.push(v2788(this.variableType, paramVal.t3728(), false, parse));         }           for (let i = 0; i < varValues.length; i++)         {             if (  !varValues[i]                 || varValues[i].type == n1086)             {                 switch (this.variableType)                 {                     case 'FLOAT':   varValues[i] =  k2022.NaN(); break;                     case 'BOOLEAN': varValues[i] = u2622.NaN(); break;                     case 'STRING':  varValues[i] =    f2033.NaN(); break;                     case 'COLOR':   varValues[i] =    c2013.NaN(); break;                     default:                                           break;                 }             }         }           this.value = new y2632(             this.nodeId,              this.variableId,             this.variableName,             varValues,             [...this.aliasIds],             [...this.aliasNames],             this.variableTemp);           this.c4193(parse,         [             ['value', this.value]         ]);           await this.evalVariable(parse);           this.validate();          return this;     }        async evalVariable(parse, options = {})     {         if (!this.options.enabled)             return;                        this.value.objects = [];           if (this.value.variableValues.every(v => v.isValid()))         {             const _var = new v2602(                 this.nodeId,                 this.value.variableId,                 this.value.variableName,                 this.value.variableValues.map(v => v.copy()),                 [...this.value.aliasIds]);              this.value.objects.push(_var);         }                   await super.x4192(parse);     }        isValid()     {         return !this.e2971.some(p => p == NULL);      }        p4180(parse)     {         super.p4180(parse);          this.e2971.forEach(p => p.p4180(parse));     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          this.e2971.forEach(p => p.i4181(parse, from, force));     }        i4179(parse)     {         super.i4179(parse);          this.e2971.forEach(p => p.i4179(parse));     } }    function v2788(type, value, colorFromFigma, parse) {     switch (type)     {         case 'FLOAT':         {             const _value =                     value                 && !isNaN(value)                     ? value                     : parse.settings.numberVarNullValue;                           return new k2022(                 _value,                  Math.min(v1002(d1014(_value, 2)), 2));         }          case 'BOOLEAN':          {             const _value =                     value                 && !isNaN(value)                     ? value                     : parse.settings.boolVarNullValue;              return new u2622(_value > 0);         }          case 'STRING':              return new f2033(value);          case 'COLOR':          {             let _value = value;              if (   _value                 && _value.r)             {                 _value =                  [                     _value.r,                     _value.g,                     _value.b,                     _value.a                 ];             }               if (  !_value                 || i73(_value))                 _value = parse.settings.colorVarNullValue;               if (_value.length == 3)             {                 if (colorFromFigma)                     _value.a = 1;                 else                     _value.push(1);             }               if (colorFromFigma)             {                 return _value.a == 1                     ? d2010.t3868(                         [_value.r * 0xff,                           _value.g * 0xff,                           _value.b * 0xff])                      : c2013.t3868(                         [_value.r * 0xff,                           _value.g * 0xff,                           _value.b * 0xff],                           _value.a * 100);              }             else             {                 return _value[3] == 1                     ? d2010.t3868(                         [_value[0] * 0xff,                           _value[1] * 0xff,                           _value[2] * 0xff])                      : c2013.t3868(                         [_value[0] * 0xff,                           _value[1] * 0xff,                           _value[2] * 0xff],                           _value[3] * 100);              }         }          default:             console.error('invalid variable type \'' + type + '\'');             return null;     } }


class q1882 extends i2043 {     input = null;        constructor(nodeId, options)     {         super(y1060, nodeId, options);     }        copy()     {         const copy = new r1864(this.nodeId, this.options);                  copy.t3455(this);          if (this.input) copy.input = this.input.copy();                  for (const key of this.keys())         {             if (this[key] instanceof s2050)                 Object.assign(copy, {[key]: this[key]});         }          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await evalListValue(this.input, parse);           this.c3193 = [];                                                                                                                                                                                                                                                  this.c4193(parse, [['', new s4309()]], true);                                        this.validate();          return this;     }                w4334(m3091)     {         return this.value             && this.value.items             && m3091 != 'value'             ? this.value.items.find(i => i.valueId == m3091)              : null;     }        toNewValue()     {         return this.value.copy();     }        isValid()     {         return this.input && this.input.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.input) this.input.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.input) this.input.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.input) this.input.i4179(parse);     } }


class q1854 extends l2044 {     m4304 = null;        constructor(nodeId, options)     {         super(m1063, nodeId, options);     }            reset()     {         super.reset();          this.m4304 = null;     }        copy()     {         const copy = new q1854(this.nodeId, this.options);          copy.t3455(this);          if (this.value) copy.value = this.value.copy();          return copy;     }        async eval(parse)     {         if (!this.options.enabled)             this.m4304 = null;                      if (   this.isCached()             && this.m4304)             return this;           if (this.m4304)         {             this.value = this.m4304.copy();         }         else         {             const input = await evalValue(this.input, parse);              this.value = input;              if (   this.options.enabled                 && this.value)                 this.m4304 = this.value.copy();         }           this.i4308();           this.c4193(parse,         [             ['type',  this.outputType()],             ['value', this.value       ]         ]);           this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        iterateCache(parse, from)     {         this.m4304 = null;          super.iterateCache(parse, from);     } } 


class q1862 extends l2044 {     frozen = false;      b3916 = NULL;        constructor(nodeId, options)     {         super(d1064, nodeId, options);     }            reset()     {         super.reset();          this.frozen = false;     }        copy()     {         const copy = new q1862(this.nodeId, this.options);          copy.t3455(this);          if (this.value) copy.value = this.value.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const repeat = parse.repeats.find(r => r.repeatId == this.b3916);           if (      repeat                && repeat.currentIteration == 0             || !this.options.enabled)             this.frozen = false;           if (!this.frozen)         {             this.value =                  this.input                  ? (await this.input.eval(parse)).toNewValue()                 : new s4309();              this.frozen = true;              this.i4308();         }           this.c4193(parse,         [             ['type',  this.outputType()],             ['value', this.value       ]         ]);           this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     } } 


class k1878 extends l2044 {     interval = null;    g3775    = null;     loop     = null;        constructor(nodeId, options)     {         super(s1065, nodeId, options);     }            reset()     {         super.reset();          this. interval = null;         this.g3775    = null;         this. loop     = null;     }        copy()     {         const copy = new k1878(this.nodeId, this.options);          copy.t3455(this);          if (this. interval) copy. interval = this. interval.copy();         if (this.g3775   ) copy.g3775    = this.g3775   .copy();         if (this. loop    ) copy. loop     = this. loop    .copy();          return copy;     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;           const  interval = await evalNumberValue(this. interval, parse);         const g3775    = await evalNumberValue(this.g3775,    parse);         const  loop     = await evalNumberValue(this. loop,     parse);                       if (this.loop.type != c1090) t3454(this.loop, this);          if (g3775.value == 0)             return this;           if (this.input)         {             this.input.i4181(parse, this, true);              const input = await evalValue(this.input, parse);              this.value = input ? input : new s4309();              if (this.loop.type != c1090)                 this.loop.i4179(parse);         }         else             this.value = new s4309();                       this.c4193(parse,         [             ['value',    this.value],             ['interval', interval  ]         ]);                   this.i4308();           this.validate();          return this;     }        toNewValue()     {         return this.value.copy();     }        isValid()     {         return super.isValid()             && this.interval && this.interval.isValid()             && this.g3775   && this.g3775  .isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this. interval) this. interval.p4180(parse);         if (this.g3775   ) this.g3775   .p4180(parse);         if (this. loop    ) this. loop    .p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this. interval) this. interval.i4181(parse, from, force);         if (this.g3775   ) this.g3775   .i4181(parse, from, force);         if (this. loop    ) this. loop    .i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this. interval) this. interval.i4179(parse);         if (this.g3775   ) this.g3775   .i4179(parse);         if (this. loop    ) this. loop    .i4179(parse);     } } 


class e2629 extends l2044 {     constructor(nodeId, options)     {         super(z1066, nodeId, options);     }            copy()     {         const copy = new e2629(this.nodeId, this.options);          copy.t3455(this);          if (this.value) copy.value = this.value.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new f2033(             this.input              ? (await this.input.eval(parse)).toNewValue().valueId             : '');                   this.c4193(parse,         [             ['type', this.outputType()]         ]);           this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     } } 


class e2620 extends l2044 {     name = null;        constructor(nodeId, options)     {         super(l1067, nodeId, options);     }            reset()     {         super.reset();          this.name = null;     }        copy()     {         const copy = new e2620(this.nodeId, this.options);          copy.t3455(this);          if (this.value) copy.value = this.value.copy();         if (this.name ) copy.name  = this.name .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalValueOrList(this.input, parse);         const name  = await evalTextValue  (this.name,  parse);           if (input)         {             if (this.options.enabled)             {                 this.evalInputOrList(                     input,                      item => evalSetValueName(item, name),                     new s4309());             }             else                 this.value = input;         }         else             this.value = new s4309();           this.i4308();           this.c4193(parse,         [             ['type',  this.outputType()],             ['value', this.value       ],             ['name',  name             ]         ]);           this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.name && this.name.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.name) this.name.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.name) this.name.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.name) this.name.i4179(parse);     }        s3727(parse, nodeId)     {         super.s3727(parse, nodeId);          if (this.name) this.name.s3727(parse, nodeId);     } }    function evalSetValueName(input, name) {     input.valueId = name.value;      return input; }


class s2615 extends l2044 {             constructor(nodeId, options)     {         super(i1351, nodeId, options);     }            reset()     {         super.reset();               }        copy()     {         const copy = new s2615(this.nodeId, this.options);          copy.t3455(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalListValue(this.input, parse);           this.counts = new w2021();           if (   input             && input.items)         {             if (this.options.enabled)             {                 this.value = new w2021();                 this.value.objects = [];                  for (let i = 0; i < input.items.length; i++)                     this.value.items.push(new f2033(input.items[i].valueId));                  if (input.objects)                 {                     for (let i = 0; i < input.objects.length; i++)                         this.value.objects.push(input.objects[i]);                 }             }             else                 this.value = input.copy();         }         else             this.value = new w2021();           this.i4308();           this.c4193(parse,          [             ['type',   new f2033(y1056)          ],             ['length', new k2022(this.value.items.length)]         ]);                           if (parse.settings.r3829)         {             this.c4193(parse,             [                 ['preview', new w2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     } } 


class h2623 extends s2045 {     constructor(nodeId, options)     {         super(o1352, nodeId, options);     }            copy()     {         const copy = new h2623(this.nodeId, this.options);          copy.t3455(this);          if (this.value) copy.value = this.value.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const o4175 = await evalListValue(this.o4175, parse);         const i4176 = await evalListValue(this.i4176, parse);                   if (   o4175             && i4176             && o4175.items             && i4176.items)         {             if (this.options.enabled)             {                 for (let i = 0;                          i < o4175.items.length                       && i < i4176.items.length;                       i++)                     o4175.items[i].valueId = i4176.items[i].value;             }              this.value = o4175;         }              else if (o4175)             this.value = o4175;                  else             this.value = new w2021();           this.i4308();           this.c4193(parse,         [             ['type', this.outputListType()]         ]);           this.validate();          return this;     } } 


class b2617 extends l2044 {     name = null;        constructor(nodeId, options)     {         super(x1353, nodeId, options);     }            reset()     {         super.reset();          this.name = null;     }        copy()     {         const copy = new b2617(this.nodeId, this.options);          copy.t3455(this);          if (this.value) copy.value = this.value.copy();         if (this.name ) copy.name  = this.name .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalValue    (this.input, parse, () => g2025.NaN());         const name  = await evalTextValue(this.name,  parse);           if (input)         {             this.value = input;              if (   this.options.enabled                 && this.value.isValid()                 && this.value.objects)             {                 for (const b111 of this.value.objects)                 {                     b111.nodeId     = this.nodeId;                     b111.objectName = name.value;                 }             }         }         else             this.value = new s4309();           this.i4308();           this.c4193(parse,         [             ['type',  this.outputType()],             ['value', this.value       ],             ['name',  name             ]         ]);           this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.name && this.name.isValid()     }        p4180(parse)     {         super.p4180(parse);          if (this.name) this.name.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.name) this.name.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.name) this.name.i4179(parse);     }        s3727(parse, nodeId)     {         super.s3727(parse, nodeId);          if (this.name) this.name.s3727(parse, nodeId);     } } 


class m1857 extends i2043 {     inputs = [];      value;        constructor(nodeId, options)     {         super(q1068, nodeId, options);     }            reset()     {         super.reset();          this.inputs = [];     }        copy()     {         const copy = new m1857(this.nodeId, this.options);          copy.t3455(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.value) copy.value = this.value.copy();          return copy;     }        isCached()     {         for (const input of this.inputs)             if (!input.isCached())                 return false;          return super.isCached();     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new w2021();          this.value.objects = [];           for (let i = 0; i < this.inputs.length; i++)         {             const input = await evalValue(this.inputs[i], parse);               if (   input                 && input.isValid()                 && this.options.enabled)             {                 if (o955(input.type))                 {                     if (input.condensed === true)                         this.value.items.push(input);                     else                     {                         for (const item of input.items)                             this.value.items.push(item);                     }                 }                 else                     this.value.items.push(input);             }               const inputObjects = this.p3722(input, i);                          for (const b111 of inputObjects)             {                 b111.objectId += b965 + i;                 b111.a3915 = i;             }              this.value.objects.push(...inputObjects);         }                     const bounds = getObjBounds(this.value.objects);          const singlePoint =                this.value.objects.length  == 1              && this.value.objects[0].type == d1245;          for (const b111 of this.value.objects)         {             const angle1 = u882(b111.sp0, b111.sp1);             const angle2 = u882(b111.sp0, b111.sp2);              b111.q3837(b111.sp0.x, b111.sp0.y);                          b111.sp1 = y893(b111.sp0, vector(angle1, 1));             b111.sp2 = y893(b111.sp0, vector(angle2, 1));                       }                   const length = new k2022(this.value.items.length);         const type   = new f2033(h3575(this.value.items));           this.c4193(parse,         [             ['length', length],             ['type',   type  ]         ]);           if (parse.settings.r3829)         {             this.c4193(parse,             [                 ['preview', new w2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        toNewValue()     {         return this.value.copy();     }        isValid()     {         return !this.inputs.find(i => !i.isValid());     }        p4180(parse)     {         super.p4180(parse);          this.inputs.forEach(i => i.p4180(parse));     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          this.inputs.forEach(i => i.i4181(parse, from, force));     }        v3724(parse, b3916)     {         this.inputs.forEach(i => i.v3724(parse, b3916));     }        o3725(parse, nodeId)     {         this.inputs.forEach(i => i.o3725(parse, nodeId));     }        i4179(parse)     {         this.inputs.forEach(i => i.i4179(parse));     }        iterateCache(parse, from)     {         for (const input of this.inputs)         {             if (   input.type == y1079                 || input.type == q1068                 || input.type == m1063)                 input.iterateCache(parse, from);         }     }        s3727(parse, nodeId)     {         this.inputs.forEach(i => i.s3727(parse, nodeId));     } }


class b1858 extends l2044 {     constructor(nodeId, options)     {         super(b1069, nodeId, options);     }            reset()     {         super.reset();     }        copy()     {         const copy = new b1858(this.nodeId, this.options);          copy.t3455(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new w2021();         this.value.condensed = true;          let length = 0;           const input = await evalListValue(this.input, parse);           if (input)         {             length = input.items.length;                                           if (   o955(input.type)                 && this.options.enabled)             {                 for (const item of input.items)                 {                     const copy = item.copy();                      this.value.items.push(copy);                 }             }             else             {                 const copy = input.copy();                  this.value.items  .push(copy);                 this.value.objects.push(...copy.objects);             }         }         else             this.value = new w2021();               this.i4308();               this.c4193(parse,         [             ['length', new k2022(length)                                ],             ['type',   new f2033(h3575(this.value.items))]         ]);                   this.validate();          return this;     } } 


class z1860 extends l2044 {     indices     = null;                  constructor(nodeId, options)     {         super(u1070, nodeId, options);     }            reset()     {         super.reset();          this.indices = null;                   }        copy()     {         const copy = new z1860(this.nodeId, this.options);          copy.t3455(this);          if (this.indices) copy.indices = this.indices.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input   = await evalListValue(this.input,   parse);         let   indices = await evalValue    (this.indices, parse, () => null);           this.value = new w2021();          let length = 0;                   if (   indices              && indices.type == h1142)             indices = new w2021(parseIndexRanges(indices.value).map(i => new k2022(i)));           if (   input             && indices             && input.items)         {             length = input.items.length;               if (this.options.enabled)             {                 for (let i = 0; i < indices.items.length; i++)                 {                     const item = input.items[Math.round(indices.items[i].value)];                      this.value.items.push(item ? item.copy() : new s4309());                                          if (   item                         && item.objects                         && this.value.objects)                          this.value.objects.push(...item.objects);                 }             }         }         else             this.value = w2021.NaN();           this.i4308();           this.c4193(parse,         [             ['type',    this.outputListType()                   ],             ['length',  new k2022(this.value.items.length)],              ['indices', indices                                 ]         ]);                   if (parse.settings.r3829)         {             this.c4193(parse,             [                 ['preview', new w2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.indices && this.indices.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.indices) this.indices.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.indices) this.indices.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.indices) this.indices.i4179(parse);     } } 


class m1873 extends s2045 {     name = null;            constructor(nodeId, options)     {         super(n1071, nodeId, options);     }            reset()     {         super.reset();          this.name  = null;     }        copy()     {         const copy = new m1873(this.nodeId, this.options);          copy.t3455(this);          if (this.name) copy.name = this.name.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const o4175 = await evalValue    (this.o4175, parse);         const i4176 = await evalValue    (this.i4176, parse);         const name   = await evalTextValue(this.name,   parse);           if (   o4175             && name)         {             let nameValue = name.value.trim();               if (o955(o4175.type))             {                 this.value = new w2021();                  if (this.options.enabled)                 {                     for (let i = 0; i < o4175.items.length; i++)                     {                         const item = o4175.items[i];                          if (   i4176                             && name.value.trim() != '')                             item.customParams.push([nameValue, i4176]);                                                   if (   item                             && item[nameValue]                             && item[nameValue].objects                              && this.value.objects)                             this.value.objects.push(...item[nameValue].objects);                     }                 }                 else                     this.value = o4175;             }             else             {                 this.value = o4175;                  if (   i4176                     && nameValue != ''                     && this.options.enabled)                     this.value.customParams.push([nameValue, i4176]);             }         }         else         {             this.value = new s4309();         }           this.i4308();           this.c4193(parse,         [             ['type',  this.outputType()],             ['value', this.value       ],             ['name',  name             ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.name && this.name.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.name) this.name.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.name) this.name.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.name) this.name.i4179(parse);     } } 


class l1874 extends l2044 {     name = null;            constructor(nodeId, options)     {         super(n1072, nodeId, options);     }            reset()     {         super.reset();          this.name  = null;     }        copy()     {         const copy = new l1874(this.nodeId, this.options);          copy.t3455(this);          if (this.name) copy.name = this.name.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalValue    (this.input, parse);         const name  = await evalTextValue(this.name,  parse);           if (   input             && name             && name.value.trim() != '')         {             if (this.options.enabled)             {                 if (o955(input.type))                 {                     this.value = new w2021();                      for (let i = 0; i < input.items.length; i++)                         this.value.items.push(getGetParamValue(input.items[i], name));                 }                 else                     this.value = getGetParamValue(input, name);             }             else                 this.value = input.copy();         }         else         {             this.value = new s4309();         }           this.i4308();           const type = this.outputType();                  this.c4193(parse,         [             ['value', this.value],             ['type',  type      ],             ['name',  name      ]         ]);                   if (type.value == h1142 && parse.settings.n3828)         {             this.c4193(parse,             [                 ['preview', this.value]             ],             true);         }         else if (o955(type.value)   && parse.settings.r3829)         {             this.c4193(parse,             [                 ['preview', new w2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.name && this.name.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.name) this.name.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.name) this.name.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.name) this.name.i4179(parse);     } }    function getGetParamValue(input, name) {     let nameValue = name.value.trim();       if (    input         && !input[nameValue])     {              if (input[name.value.toUpperCase()]) nameValue = name.value.toUpperCase();         else if (input[name.value.toLowerCase()]) nameValue = name.value.toLowerCase();     }       let value = null;      if (   input         && input[nameValue])     {         value = input[nameValue];     }     else     {         const customIndex = input.customParams.findIndex(p => p[0] == nameValue);          value =             customIndex > -1             ? input.customParams[customIndex][1]             : new s4309();     }       if (   input         && input[nameValue]         && input[nameValue].objects          && this.value.objects)         value.objects.push(...input[nameValue].objects);       return value; }


class b1877 extends l2044 {     start       = null;     end         = null;                  constructor(nodeId, options)     {         super(y1073, nodeId, options);     }            reset()     {         super.reset();          this.start       = null;         this.end         = null;               }        copy()     {         const copy = new b1877(this.nodeId, this.options);          copy.t3455(this);          if (this.start) copy.start = this.start.copy();         if (this.end  ) copy.end   = this.end  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalListValue  (this.input, parse);         const start = await evalNumberValue(this.start, parse);         const end   = await evalNumberValue(this.end,   parse);           let length = 0;                       this.value = new w2021();         this.value.objects = [];           if (   input             && start             && end)         {             if (input.items)             {                 length = input.items.length;                   const _end =                     end.isValid()                     ? end                     : new k2022(input.items.length);                   if (this.options.enabled)                 {                     const endValue =                          _end.value < 0                         ? length + _end.value                         : _end.value;                      if (start.value < endValue)                     {                         for (let i = start.value, j = 0; i < endValue; i++, j++)                         {                             const item = input.items[i];                              this.value.items.push(item ? item.copy() : new s4309());                                                          if (   item                                 && this.value.objects                                 && item.objects)                             {                                 item.objects.forEach(o => o.a3915 = j);                                 this.value.objects.push(...item.objects);                             }                         }                     }                     else                         this.value = w2021.NaN();                 }                 else                     this.value = input.copy();             }             else                 this.value = w2021.NaN();         }           this.i4308();           this.c4193(parse,         [             ['type',       this.outputListType()                          ],             ['length',     new k2022(this.value.items.length)       ],              ['fullLength', new k2022(input ? input.items.length : 0)],              ['start',      start                                          ],             ['end',        end                                            ]         ]);                   if (parse.settings.r3829)         {             this.c4193(parse,             [                 ['preview', new w2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.start && this.start.isValid()             && this.end   && this.end  .isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.start) this.start.p4180(parse);         if (this.end  ) this.end  .p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.start) this.start.i4181(parse, from, force);         if (this.end  ) this.end  .i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.start) this.start.i4179(parse);         if (this.end  ) this.end  .i4179(parse);     } } 


class d1879 extends l2044 {     counts      = null;     indices     = null;                  constructor(nodeId, options)     {         super(c1074, nodeId, options);     }            reset()     {         super.reset();          this.counts  = null;         this.indices = null;                       }        copy()     {         const copy = new d1879(this.nodeId, this.options);          copy.t3455(this);          if (this.counts ) copy.counts  = this.counts .copy();         if (this.indices) copy.indices = this.indices.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalListValue(this.input, parse);           this.counts  = new w2021();         this.indices = new w2021();                   if (input)         {             if (this.options.enabled)             {                 this.value = new w2021();                  for (let i = 0, index = 0; i < input.items.length; i++)                 {                     const item       = input.items[i];                     const foundIndex = this.value.items.findIndex(i => i.equals(item));                      if (foundIndex < 0)                     {                         const copy = item.copy();                          copy.valueId = (index++).toString();                                                  this.value.items.push(item.copy());                          if (   this.value.objects                             && item.objects)                             this.value.objects.push(...item.objects);                          this.counts .items.push(new k2022(1));                         this.indices.items.push(new w2021([new k2022(i)]));                     }                     else                     {                         this.counts .items[foundIndex].value++;                         this.indices.items[foundIndex].items.push(new k2022(i));                     }                 }             }             else                 this.value = input.copy();         }         else             this.value = new w2021();           this.i4308();           this.c4193(parse,         [             ['type',    this.outputListType()                   ],             ['length',  new k2022(this.value.items.length)],             ['counts',  this.counts                             ],             ['indices', this.indices                            ]         ]);                   if (parse.settings.r3829)         {             this.c4193(parse,             [                 ['preview', new w2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }                                                                                                                                        } 


class h1868 extends l2044 {     indices = null;            constructor(nodeId, options)     {         super(q1348, nodeId, options);     }            reset()     {         super.reset();          this.indices = null;     }        copy()     {         const copy = new h1868(this.nodeId, this.options);          copy.t3455(this);          if (this.indices) copy.indices = this.indices.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input   = await evalListValue(this.input,   parse);         let   indices = await evalValue    (this.indices, parse, () => null);           if (   indices              && indices.type == h1142)             indices = new w2021(parseIndexRanges(indices.value).map(i => new k2022(i)));           this.value         = new w2021();         this.value.objects = [];           if (   input             && input.items)         {             if (   this.options.enabled                 && indices                 && input.items                 && indices.items                 && input.items.length == indices.items.length)             {                 this.value.items = new Array(input.items.length);                  for (let i = 0; i < input.items.length; i++)                     this.value.items[i] = input.items[indices.items[i].value];                                   for (let i = 0; i < this.value.items.length; i++)                 {                     const item      = this.value.items[i];                     const a3915 = input.items.indexOf(item);                      if (   item.objects                         && this.value.objects)                     {                         const objects = input.objects.filter(o => o.a3915 == a3915).map(o => o.copy());                         objects.forEach(o => o.a3915 = i);                          this.value.objects.push(...objects);                     }                 }             }             else                 this.value = new w2021();         }         else             this.value = new w2021();           this.i4308();           this.c4193(parse,         [             ['type',    this.outputListType()],             ['indices', indices              ]         ]);                   if (parse.settings.r3829)         {             this.c4193(parse,             [                 ['preview', new w2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.indices && this.indices.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.indices) this.indices.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.indices) this.indices.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.indices) this.indices.i4179(parse);     } }


class o1869 extends l2044 {     offset = null;            constructor(nodeId, options)     {         super(s1349, nodeId, options);     }            reset()     {         super.reset();          this.offset = null;     }        copy()     {         const copy = new o1869(this.nodeId, this.options);          copy.t3455(this);          if (this.offset) copy.offset = this.offset.copy();          return copy;     }        async eval(parse)     {         if (   this.isCached())                          return this;           const input  = await evalListValue  (this.input,  parse);         const offset = await evalNumberValue(this.offset, parse);           let length = 0;                       this.value = new w2021();         this.value.objects = [];           if (   input             && offset)         {             if (input.items)             {                 length = input.items.length;                  if (this.options.enabled)                 {                     let _offset = -(offset.value % input.items.length);                     while (_offset < 0) _offset += input.items.length;                      let j = 0;                     for (let i = _offset; i < input.items.length; i++, j++)                         this.addItem(input, i, j);                      for (let i = 0; i < _offset; i++, j++)                         this.addItem(input, i, j);                 }                 else                     this.value = input.copy();             }             else                 this.value = w2021.NaN();         }           this.i4308();           this.c4193(parse,         [             ['type',       this.outputListType()                          ],             ['length',     new k2022(this.value.items.length)       ],              ['offset',     offset                                         ]         ]);                   if (parse.settings.r3829)         {             this.c4193(parse,             [                 ['preview', new w2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        addItem(input, i, j)     {         const item = input.items[i];          this.value.items.push(item ? item.copy() : new s4309());                  if (   item             && this.value.objects             && input.objects)         {                          item.objects.forEach(o => o.a3915 = j);              this.value.objects.push(...item.objects);         }     }        isValid()     {         return super.isValid()             && this.offset && this.offset.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.offset) this.offset.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.offset) this.offset.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.offset) this.offset.i4179(parse);     } } 


class l1870 extends l2044 {     constructor(nodeId, options)     {         super(x1075, nodeId, options);     }            reset()     {         super.reset();     }        copy()     {         const copy = new l1870(this.nodeId, this.options);          copy.t3455(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalValue(this.input, parse);           if (input)         {             if (this.options.enabled)             {                 this.value = new w2021();                 this.value.objects = [];                  for (let i = input.items.length-1; i >= 0; i--)                     this.value.items.push(input.items[i]);                  if (input.objects)                 {                     for (let i = input.objects.length-1; i >= 0; i--)                         this.value.objects.push(input.objects[i]);                 }             }             else                 this.value = input.copy();         }         else             this.value = w2021.NaN();               this.i4308();           this.c4193(parse,          [             ['type',   this.outputListType()                   ],             ['length', new k2022(this.value.items.length)]         ]);                           if (parse.settings.r3829)         {             this.c4193(parse,             [                 ['preview', new w2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     } } 


class g2609 extends l2044 {     amount;        constructor(nodeId, options)     {         super(z1350, nodeId, options);     }            reset()     {         super.reset();          this.buckle = null;     }        copy()     {         const copy = new g2609(this.nodeId, this.options);          copy.t3455(this);          if (this.amount) copy.amount = this.amount.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalListValue  (this.input,  parse);         const amount = await evalNumberValue(this.amount, parse);          amount.value = Math.round(amount.value);                           if (   input             && input.isValid())         {             const _amount = Math.min(amount.value + 1, Math.floor(input.items.length/2));              if (this.options.enabled)             {                 const temp1 =                  [                     ...input.items.slice(input.items.length - _amount).map(i => i.value),                     ...input.items.slice(0, _amount)                  .map(i => i.value).map(i => i - input.items[0].value + input.items.at(-1).value)                 ];                  const temp2 =                  [                     ...input.items.slice(input.items.length - _amount).map(i => i.value).map(i => i - input.items.at(-1).value + input.items[0].value),                     ...input.items.slice(0, _amount)                  .map(i => i.value)                 ];                  c950(                     temp1.length == temp2.length,                     'error building list edge blend');                                   const temp = [];                  for (let i = 0; i < _amount*2; i++)                     temp.push(new k2022(q1033(temp1[i], temp2[i], i/(_amount*2-1))));                   this.value = new w2021();                  for (let i = 0; i < _amount; i++)                     this.value.items.push(temp[_amount + i]);                  for (let i = _amount; i < input.items.length - _amount; i++)                     this.value.items.push(input.items[i]);                  for (let i = 0; i < _amount; i++)                     this.value.items.push(temp[i]);             }             else                 this.value = input;         }         else             this.value = w2021.NaN();               this.c4193(parse,          [             ['length', new k2022(this.value.items.length)],             ['amount', amount                                  ]         ]);                           if (parse.settings.r3829)         {             this.c4193(parse,             [                 ['preview', new w2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     } } 


class c1875 extends l2044 {     condition     = null;     reverse       = null;     indices       = null;      z4305 = null;                   constructor(nodeId, options)     {         super(j1076, nodeId, options);     }            reset()     {         super.reset();          this.condition = null;         this.reverse   = null;         this.indices   = null;     }        copy()     {         const copy = new c1875(this.nodeId, this.options);          copy.t3455(this);          if (this.condition) copy.condition = this.condition.copy();         if (this.reverse  ) copy.reverse   = this.reverse  .copy();         if (this.indices  ) copy.indices   = this.indices  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input   = await evalListValue  (this.input,   parse);         const reverse = await evalNumberValue(this.reverse, parse);           this.value         = new w2021();         this.value.objects = [];           let maxColumns = 0;          this.indices = new w2021();           if (   input             && reverse)         {             if (this.options.enabled)             {                 if (  !this.condition                     || this.condition.v3863)                 {                     if (this.condition)                         await this.condition.eval(parse);                      const conditionNode =                          this.condition                         ? this.condition.v3863(parse)                         : null;                       if (  !this.condition                         || conditionNode)                     {                         const y4306 = reverse.value > 0 ? -1 : 1;                         const n4307          = [...input.items];                           [ input       .items,                            this.indices.items ] = await asyncSort(                             parse,                              n4307,                              this.condition                              ? conditionNode                              : null,                                      this,                             this.condition,                              y4306);                           input.items.forEach(i => maxColumns = Math.max(maxColumns, o955(i.type) ? i.items.length : 1));                                                   for (let i = 0; i < input.items.length; i++)                         {                             const row       = input   .items[i];                             const a3915 = n4307.indexOf(row);                              this.value.items.push(row.copy());                              if (   row.objects                                 && this.value.objects)                             {                                 const objects = input.objects.filter(o => o.a3915 == a3915).map(o => o.copy());                                 objects.forEach(o => o.a3915 = i);                                  this.value.objects.push(...objects);                             }                         }                     }                 }                 else                 {                     this.value   = input;                     this.indices = new w2021(Array.from(Array(input.items.length).keys()).map(i => new k2022(i)));                 }             }             else             {                 this.value   = input;                 this.indices = new w2021(Array.from(Array(input.items.length).keys()).map(i => new k2022(i)));             }         }         else         {             this.value   = new w2021();             this.indices = new w2021();         }                   this.i4308();           this.c4193(parse,         [             ['type',    this.outputListType()                   ],             ['length',  new k2022(this.value.items.length)],             ['reverse', reverse                                 ],             ['indices', this.indices                            ]         ]);                   if (parse.settings.r3829)         {             this.c4193(parse,             [                 ['preview', new w2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && (!this.condition || this.condition.isValid())             && this.reverse && this.reverse.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.condition) this.condition.p4180(parse);         if (this.reverse  ) this.reverse  .p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.condition) this.condition.i4181(parse, from, force);         if (this.reverse  ) this.reverse  .i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.condition) this.condition.i4179(parse);         if (this.reverse  ) this.reverse  .i4179(parse);     } }    async function asyncSort(parse, n4307, conditionNode, node, condition, y4306) {     const c3664 = conditionNode ? conditionNode.input : null;       const sorted  = [];       for (let i = 0; i < n4307.length; i++)     {         const item = n4307[i];          const cond = await getSortCondition(parse, conditionNode, node, condition, item);          if (!cond)          {             return [n4307,                      n4307.keys().map(k => new k2022(k))];         }                  const condValue = cond.toNewValue();                   if (   condValue.type != c1090             && condValue.type != h1142)          {             return [ n4307,                       n4307.keys().map(k => new k2022(k))];         }          sorted.push({item, condition: condValue.value, index: i});     }       sorted.sort((a, b) =>     {         if (   typeof(a.condition) == 'number'             && typeof(b.condition) == 'number')         {             if (a.condition < b.condition) return -1*y4306;             if (a.condition > b.condition) return  1*y4306;         }         else if (typeof(a.condition) == 'string'               && typeof(b.condition) == 'string')         {             if (a.condition.localeCompare(b.condition) < 0) return -1*y4306;             if (a.condition.localeCompare(b.condition) > 0) return  1*y4306;         }          return 0;     });       if (conditionNode)         conditionNode.input = c3664;       return [ sorted.map(item => item.item),               sorted.map(item => new k2022(item.index)) ]; }    async function getSortCondition(parse, conditionNode, node, condition, item) {     if (!conditionNode)         return item;          conditionNode.reset();      conditionNode.input = item.copy();     condition.i4181(parse, node, true);       return await condition.eval(parse); }


class d1861 extends l2044 {     condition = null;     indices   = null;                  constructor(nodeId, options)     {         super(b1084, nodeId, options);     }            reset()     {         super.reset();          this.condition = null;         this.indices   = null;     }        copy()     {         const copy = new d1861(this.nodeId, this.options);          copy.t3455(this);          if (this.condition) copy.condition = this.condition.copy();         if (this.indices  ) copy.indices   = this.indices  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalListValue(this.input, parse);           this.value         = new w2021();         this.value.objects = [];          let maxColumns = 0;                   this.indices = new w2021();           if (input)         {             if (this.options.enabled)             {                 if (  !this.condition                     || this.condition.v3863)                 {                     if (this.condition)                         await this.condition.eval(parse);                      const conditionNode =                          this.condition                         ? this.condition.v3863(parse)                         : null;                       if (  !this.condition                         || conditionNode)                     {                         const unfiltered = [...input.items];                           [input.items, this.indices.items] = await asyncFilter(                             parse,                              unfiltered,                              conditionNode,                             this,                             this.condition);                           input.items.forEach(i => maxColumns = Math.max(maxColumns, o955(i.type) ? i.items.length : 1));                                                   for (let i = 0; i < input.items.length; i++)                         {                             const row       = input   .items[i];                             const a3915 = unfiltered.indexOf(row);                              this.value.items.push(row.copy());                              if (   row.objects                                 && this.value.objects)                             {                                 const objects = input.objects.filter(o => o.a3915 == a3915).map(o => o.copy());                                 objects.forEach(o => o.a3915 = i);                                  this.value.objects.push(...objects);                             }                         }                     }                 }                 else                     this.value = await evalListValue(this.input, parse);             }             else                 this.value = input.copy();         }         else             this.value = new w2021();           this.i4308();           this.c4193(parse,         [             ['type',    this.outputListType()                   ],             ['length',  new k2022(this.value.items.length)],             ['indices', this.indices                            ]         ]);                   if (parse.settings.r3829)         {             this.c4193(parse,             [                 ['preview', new w2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && (!this.condition || this.condition.isValid());     }        p4180(parse)     {         super.p4180(parse);          if (this.condition) this.condition.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.condition) this.condition.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.condition) this.condition.i4179(parse);     } }    async function asyncFilter(parse, array, conditionNode, node, condition) {     const c3664 = conditionNode ? conditionNode.input : null;      const filtered = [];     const indices  = [];      for (let i = 0; i < array.length; i++)     {         const item = array[i];          const cond = await getFilterCondition(parse, conditionNode, node, condition, item);         if (!cond) return array;                  const condValue = cond.toNewValue();                   if (   condValue.type == c1090             && condValue.value > 0)         {             filtered.push(item);             indices .push(new k2022(i));         }     }      if (conditionNode)         conditionNode.input = c3664;      return [filtered, indices]; }    async function getFilterCondition(parse, conditionNode, node, condition, item) {     if (!conditionNode)         return item;          conditionNode.reset();      const value = conditionNode.toNewValue();     if (!value) return item;      if (   value.type == item.type         || value.type == n1086)     {         conditionNode.input = item.copy();         condition.i4181(parse, node, true);      }      return await condition.eval(parse); }


class c1856 extends l2044 {     index       = null;                  constructor(nodeId, options)     {         super(k1077, nodeId, options);     }            reset()     {         super.reset();          this.index       = null;               }        copy()     {         const copy = new c1856(this.nodeId, this.options);          copy.t3455(this);          if (this.index) copy.index = this.index.copy();          return copy;     }        async eval(parse)     {         if (   this.isCached())                          return this;           const input = await evalListValue  (this.input, parse);         const index = await evalNumberValue(this.index, parse);                   this.value = new w2021();          let maxColumns = 0;                                                    if (   input                 && index)             {                 if (isTable(input))                 {                     input.items.forEach(i => maxColumns = Math.max(maxColumns, i.items.length));                      if (index.value < maxColumns)                     {                         const valueIds = [];                          for (let i = 0; i < input.items.length; i++)                         {                             const row = input.items[i];                              if (index.value < row.items.length)                             {                                 const item = row.items[index.value].copy();                                  item.valueId = x1482(                                     item.valueId,                                      id => valueIds.filter(l3008 => l3008 == id).length,                                     item.valueId,                                     '',                                     1,                                     true);                                                                 this.value.items.push(item);                                  j947(valueIds, item.valueId);                                  if (   this.value.objects                                      && row.items[index.value].objects)                                     this.value.objects.push(...row.items[index.value].objects);                             }                         }                     }                 }                 else if (o955(input.type))                 {                     this.value = input.copy();                     maxColumns = 1;                 }             }                               this.i4308();          this.c4193(parse,         [             ['type',    this.outputListType()                   ],             ['length',  new k2022(this.value.items.length)],             ['columns', new k2022(maxColumns, 0)          ],             ['index',   index                                   ]         ]);               if (parse.settings.r3829)         {             this.c4193(parse,             [                 ['preview', new w2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.index && this.index.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.index) this.index.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.index) this.index.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.index) this.index.i4179(parse);     } }    function isTable(value) {     if (!o955(value.type))         return false;      for (const item of value.items)     {         if (!o955(item.type))             return false;     }      return true; }


class w1855 extends l2044 {     column;     row;            constructor(nodeId, options)     {         super(x1078, nodeId, options);     }            reset()     {         super.reset();          this.column = null;         this.row    = null;     }        copy()     {         const copy = new w1855(this.nodeId, this.options);          copy.t3455(this);          if (this.column) copy.column = this.column.copy();         if (this.row   ) copy.row    = this.row   .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalListValue  (this.input,  parse);         const column = await evalNumberValue(this.column, parse);         const row    = await evalNumberValue(this.row,    parse);           let columns = 0;         let rows    = 0;          if (   input             && column             && row)         {             if (isTable(input))             {                 rows = input.items.length;                  input.items.forEach(i => columns = Math.max(columns, i.items ? i.items.length : null));                  if (row.value < rows)                 {                     const _row = input.items[row.value];                      if (column.value < columns)                         this.value = _row.items[column.value].copy();                     else                         this.value = new s4309();                 }                 else                     this.value = new s4309();             }             else                 this.value = new s4309();         }         else             this.value = new s4309();           this.c4193(parse,         [                          ['type',    this.outputType()          ],             ['columns', new k2022(columns, 0)],             ['rows',    new k2022(rows   , 0)]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.column && this.column.isValid()             && this.row    && this.row   .isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.column) this.column.p4180(parse);         if (this.row   ) this.row   .p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.column) this.column.i4181(parse, from, force);         if (this.row   ) this.row   .i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.column) this.column.i4179(parse);         if (this.row   ) this.row   .i4179(parse);     } }


class r1864 extends l2044 {     m4304 = null;        constructor(nodeId, options)     {         super(y1079, nodeId, options);     }        reset()     {         super.reset();          this.m4304 = null;     }        copy()     {         const copy = new r1864(this.nodeId, this.options);                  copy.t3455(this);          if (this.input) copy.input = this.input.copy();                  for (const key of this.keys())         {             if (this[key] instanceof s2050)                 Object.assign(copy, {[key]: this[key]});         }          return copy;     }        w4334(m3091)     {         let param =                this.value             && this.value.items             && m3091 != 'value'             ? this.value.items.find(i => i.valueId == m3091)             : null;          if (!param)             param = this[m3091];          return param;     }        async eval(parse)     {         if (   this.isCached()             && this.m4304)             return this;           const input = await evalListValue(this.input, parse);            if (this.m4304)            this.value = this.m4304.copy();          else         {             this.value       = input ?? new s4309();             this.m4304 = this.value.copy();         }           this.c3193 = [];           if (    this.value.isValid()             &&  this.value.items             && !isEmpty(this.value.items))         {             const valueIds = [];               for (let i = 0; i < this.value.items.length; i++)             {                 const item = this.value.items[i];                                  let valueId =                      item.valueId.trim() != ''                     ? item.valueId                     : i.toString();                  valueId = x1482(                     valueId,                     id => valueIds.filter(l3008 => l3008 == id).length,                     valueId,                     '',                     1,                     true);                  valueIds.push(valueId);             }               for (let i = 0; i < this.value.items.length; i++)             {                 let valueId = valueIds[i];                  const item = this.value.items[i];                                  Object.assign(this, {[valueId]: item});                 this.c4193(parse, [[valueId, item]], true);                  item.sortId = i;             }               this.c3193.sort((a, b) => a.sortId - b.sortId);               this.c4193(parse, [['-type-', this.outputType()]], true);         }         else             this.c4193(parse, [['-type-', new f2033(q1054)]], true);           this.i4308();           this.validate();          return this;     }                toNewValue()     {         return this.value.copy();     }        iterateCache(parse, from)     {         this.m4304 = null;     } }


class r1871 extends i2043 {     inputs = [];      index = null;            constructor(nodeId, options)     {         super(i1082, nodeId, options);     }        reset()     {         super.reset();          this.inputs = [];                  this.index = null;     }           copy()     {         const copy = new r1871(this.nodeId, this.options);          copy.t3455(this);                  copy.inputs = this.inputs.map(i => i.copy());          if (this.index) copy.index = this.index.copy();         if (this.value) copy.value = this.value.copy();          return copy;     }        isCached()     {         for (const input of this.inputs)             if (!input.isCached())                 return false;          return super.isCached();     }        async eval(parse)     {         if (this.isCached())             return this;          const _inputs = await Promise.all(this.inputs.map(async i => await evalValueOrList(i, parse)));         let    index  = await evalNumberValue(this.index, parse);         let    length = 0;           const inputs = [];          for (const input of _inputs)         {             if (    o955(input.type)                 && !input.condensed)             {                 for (const item of input.items)                     inputs.push(item);             }             else                 inputs.push(input);         }           if (inputs.length > 0)         {             length = inputs.length;               index =                     index.isValid()                 && index.value >= -inputs.length                 && index.value <   inputs.length                 ? new k2022(Math.round(index.value))                 : new k2022(0);                           if (   index.isValid()                 && index.value >= -inputs.length                 && index.value <   inputs.length)             {                 this.value = inputs.at(index.value);                                   if (this.value.objects)                 {                     for (let i = 0; i < this.value.objects.length; i++)                     {                         const b111 = this.value.objects[i];                          b111.nodeId = this.nodeId;                         b111.listId = -1;                          b111.objectId = this.nodeId;                                                  if (b111.objectId != NULL)                              b111.objectId += '/';                          b111.objectId += index.value.toString();                          if (this.value.objects.length > 1)                         {                             b111.objectId += '/';                             b111.objectId += i.toString();                         }                     }                 }             }             else             {                 this.value = new s4309();             }         }         else         {             this.value = new s4309();         }                   const type = this.outputType();          this.c4193(parse,         [             ['value',      type == j1167                          || type == d1177                          ? this.value                          : new s4309()      ],             ['type',    type                   ],             ['length',  new k2022(length)],             ['index',   index                  ]         ]);           if (type.value == h1142 && parse.settings.n3828)         {             this.c4193(parse,             [                 ['preview', this.value]             ],             true);         }         else if (o955(type.value) && parse.settings.r3829)         {             this.c4193(parse,             [                 ['preview', new w2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return !this.inputs.find(i => !i.isValid())             &&  this.index && this.index.isValid();     }        p4180(parse)     {         super.p4180(parse);          this.inputs.forEach(i => i.p4180(parse));          if (this.index) this.index.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          this.inputs.forEach(i => i.i4181(parse, from, force));          if (this.index) this.index.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          this.inputs.forEach(i => i.i4179(parse));          if (this.index) this.index.i4179(parse);     } }


class x1872 extends l2044 {     index = null;        constructor(nodeId, options)     {         super(e1359, nodeId, options);     }        reset()     {         super.reset();          this.index = null;     }        copy()     {         const copy = new x1872(this.nodeId, this.options);                  copy.t3455(this);          if (this.input) copy.input = this.input.copy();         if (this.index) copy.index = this.index.copy();         if (this.value) copy.value = this.value.copy();          return copy;     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;                   const input = await evalListValue  (this.input, parse);         let   index = await evalNumberValue(this.index, parse);                  let  length = 0;                           if (   input             && input.isValid()             && o955(input.type)             && input.items             && input.items.length > 0)         {             length = input.items.length;               index =                     index.isValid()                 && index.value >= -length                 && index.value <   length                 ? new k2022(Math.round(index.value))                 : new k2022(0);                           if (   index.isValid()                 && index.value >= -length                 && index.value <   length)             {                 this.value = input.items.at(index.value);                                  if (   input.objects                     && input.objects.at(index.value))                     this.value.objects = [input.objects.at(index.value)];                   if (this.value.objects)                 {                     for (let i = 0; i < this.value.objects.length; i++)                     {                         const b111 = this.value.objects[i];                          b111.nodeId = this.nodeId;                         b111.listId = -1;                          b111.objectId = this.nodeId;                                                  if (b111.objectId != NULL)                             b111.objectId += '/';                          b111.objectId += index.value.toString();                     }                 }             }             else             {                 this.value = new s4309();             }         }         else          {             this.value = new s4309();         }           const type = this.outputType();                   this.c4193(parse,         [             ['value',      type == j1167                          || type == d1177                          ? this.value                          : new s4309()],             ['type',    type                   ],             ['length',  new k2022(length)],             ['index',   index                  ]         ]);           if (type.value == h1142 && parse.settings.n3828)         {             this.c4193(parse,             [                 ['preview', this.value]             ],             true);         }         else if (o955(type.value) && parse.settings.r3829)         {             this.c4193(parse,             [                 ['preview', new w2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.index && this.index.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.index) this.index.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.index) this.index.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.index) this.index.i4179(parse);     } }


class c1865 extends l2044 {     start = null;        constructor(nodeId, options)     {         super(b1080, nodeId, options);     }        reset()     {         super.reset();          this.start = null;     }        copy()     {         const copy = new c1865(this.nodeId, this.options);                  copy.t3455(this);          if (this.input) copy.input = this.input.copy();         if (this.start) copy.start = this.start.copy();                  if (this.count) copy.count = this.count.copy();          return copy;     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalListValue  (this.input, parse);         const start = await evalNumberValue(this.start, parse);                   if (input)         {             const count = input.items.length;             this.value = new k2022(count - (start.value == 0 ? 1 : 0));         }         else             this.value = k2022.NaN();           this.c4193(parse,         [             ['type',  this.outputType()],             ['start', start            ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.start && this.start.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.start) this.start.p4180(parse);     }            i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.start) this.start.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.start) this.start.i4179(parse);     }     }


class n2625 extends l2044 {     start = null;        constructor(nodeId, options)     {         super(b1080, nodeId, options);     }        reset()     {         super.reset();          this.start = null;     }        copy()     {         const copy = new c1865(this.nodeId, this.options);                  copy.t3455(this);          if (this.input) copy.input = this.input.copy();         if (this.start) copy.start = this.start.copy();                  if (this.count) copy.count = this.count.copy();          return copy;     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalValue      (this.input, parse);         const start = await evalNumberValue(this.start, parse);                   if (input)         {             const count =                  input.objects                 ? input.objects.length                 : 0;              this.value = new k2022(count - (start.value == 0 ? 1 : 0));         }         else             this.value = k2022.NaN();           this.c4193(parse,         [             ['value', this.value],             ['start', start     ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.start && this.start.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.start) this.start.p4180(parse);     }            i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.start) this.start.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.start) this.start.i4179(parse);     }     }


class x2621 extends s2045 {     first;     last;     all;        constructor(nodeId, options)     {         super(q1081, nodeId, options);     }            reset()     {         super.reset();          this.first = null;         this.last  = null;         this.all   = null;     }        copy()     {         const copy = new x2621(this.nodeId, this.options);          copy.t3455(this);          if (this.first = null) copy.first = this.first.copy();         if (this.last  = null) copy.last  = this.last .copy();         if (this.all   = null) copy.all   = this.all  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const o4175 = await evalListValue(this.o4175, parse);         const i4176 = await evalValue    (this.i4176, parse);               if (   o4175 && o4175.isValid()              && i4176 && i4176.isValid())         {             if (isValueListOfLists(o4175))             {                 if (o955(i4176.type))                 {                     let result = false;                      for (const item of o4175.items)                     {                         if (item.equals(i4176))                         {                             result = true;                             break;                         }                     }                      this.value = new u2622(result);                 }                 else                  {                     this.value = new w2021();                      for (const item of o4175.items)                     {                         this.value.items.push(                             o955(item.type)                             ? new u2622(item.items.find(i => i.equals(i4176)))                             : u2622.NaN());                     }                 }             }             else             {                 this.value = new u2622(o4175.items.find(i => i.equals(i4176)));             }         }         else                           {             this.value = u2622.NaN();         }               this.c4193(parse,         [             ['type', this.outputType()]         ]);           this.validate();          return this;     } }


class y1859 extends s2045 {     first;     last;     all;        constructor(nodeId, options)     {         super(LIST_FIND, nodeId, options);     }            reset()     {         super.reset();          this.first = null;         this.last  = null;         this.all   = null;     }        copy()     {         const copy = new y1859(this.nodeId, this.options);          copy.t3455(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const o4175 = await evalListValue(this.o4175, parse);         const i4176 = await evalValue    (this.i4176, parse);               if (   o4175 && o4175.isValid()              && i4176 && i4176.isValid())         {             const indices = [];                           if (   i4176                 && i4176.isValid())             {                 for (let i = 0; i < o4175.items.length; i++)                 {                     if (o4175.items[i].equals(i4176))                         indices.push(i);                 }                     this.value = new k2022(indices.length > 0 ? 1 : 0);                  this.first = indices.length > 0 ? new k2022(indices.at( 0)) : k2022.NaN();                 this.last  = indices.length > 0 ? new k2022(indices.at(-1)) : k2022.NaN();                  this.all   = new w2021();                  for (const index of indices)                     this.all.items.push(new k2022(index));             }             else             {                 this.value = new k2022(1);                  this.first = k2022.NaN();                 this.last  = k2022.NaN();                 this.all   =   w2021.NaN();             }         }         else                           {             this.value = k2022.NaN();             this.first = k2022.NaN();             this.last  = k2022.NaN();             this.all   =   w2021.NaN();         }               this.c4193(parse,         [             ['value', this.value],             ['first', this.first],             ['last',  this.last ],             ['all',   this.all  ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.first && this.first.isValid()             && this.last  && this.last .isValid()             && this.all   && this.all  .isValid();     } }


class v1863 extends i2043 {     o4175    = null;     i4176    = null;      condition = null;        constructor(nodeId, options)     {         super(e1083, nodeId, options);     }            reset()     {         super.reset();          this.o4175    = null;         this.i4176    = null;          this.condition = null;     }        copy()     {         const copy = new v1863(this.nodeId, this.options);          copy.t3455(this);          if (this.o4175   ) copy.o4175    = this.o4175   .copy();         if (this.i4176   ) copy.i4176    = this.i4176   .copy();          if (this.condition) copy.condition = this.condition.copy();          if (this.value    ) copy.value     = this.value    .copy();          return copy;     }        isCached()     {         return super.isCached()             && (!this.o4175 || this.o4175.isCached())             && (!this.i4176 || this.i4176.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;                   const inputFalse = await evalValue(this.o4175, parse);         const inputTrue  = await evalValue(this.i4176, parse);                  const cond       = await evalNumberValue(this.condition, parse);             if (   inputFalse                && inputTrue ) this.value = cond.value >  0 ? inputTrue  : inputFalse;         else if (inputFalse) this.value = cond.value == 0 ? inputFalse : nanFromType(inputFalse.type);         else if (inputTrue ) this.value = cond.value >  0 ? inputTrue  : nanFromType(inputTrue .type);         else                 this.value = new s4309();           this.i4308();           this.c4193(parse,         [             ['type',      this.outputType()],             ['value',     this.value       ],             ['condition', cond             ]         ]);                           this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()               : null;     }        isValid()     {         return this.o4175    && this.o4175   .isValid()             && this.i4176    && this.i4176   .isValid()             && this.condition && this.condition.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.o4175   ) this.o4175   .p4180(parse);         if (this.i4176   ) this.i4176   .p4180(parse);         if (this.condition) this.condition.p4180(parse);     }            i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.o4175   ) this.o4175   .i4181(parse, from, force);         if (this.i4176   ) this.i4176   .i4181(parse, from, force);         if (this.condition) this.condition.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.o4175   ) this.o4175   .i4179(parse);         if (this.i4176   ) this.i4176   .i4179(parse);         if (this.condition) this.condition.i4179(parse);     }     } 


class b1899 extends i2043 {     inputs = [];        reset()     {         super.reset();          this.inputs = [];     }        v3863()     {         const conditionNodes = [];          for (const input of this.inputs)         {             const conditionNode = input.v3863();             if (conditionNode) conditionNodes.push(conditionNode);                     }          console.assert(conditionNodes.length < 2, 'Error: sort order requires not more than one order node');          return conditionNodes.length == 1              ? conditionNodes[0]              : null;     }        isCached()     {         for (const input of this.inputs)             if (!input.isCached())                 return false;          return super.isCached();     }        isValid()     {         return  this.inputs.length > 0             && !this.inputs.find(i => !i.isValid());     }        p4180(parse)     {         super.p4180(parse);          this.inputs.forEach(i => i.p4180(parse));     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          this.inputs.forEach(i => i.i4181(parse, from, force));     }        i4179(parse)     {         super.i4179(parse);          this.inputs.forEach(i => i.i4179(parse));     } } 


class h1936 extends l2044 {     constructor(nodeId, options)     {         super(n1091, nodeId, options);     }        copy()     {         const copy = new h1936(this.nodeId, this.options);                  copy.t3455(this);          copy.value = this.value.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalNumberValue(this.input, parse);           if (input)             this.value = input;         else if (this.value)             await this.value.eval(parse);         else             this.value = k2022.NaN();           this.c4193(parse,          [             ['value', this.value]         ]);           this.validate();          return this;     }        isValid()     {         return !this.input               || this.input.isValid();     } }


class b2628 extends l2044 {     min = null;     max = null;        constructor(nodeId, options)     {         super(BOUNDED_NUMBER, nodeId, options);     }        reset()     {         super.reset();          this.min = null;         this.max = null;     }        copy()     {         const copy = new b2628(this.nodeId, this.options);                  copy.t3455(this);          if (this.value) copy.value = this.value.copy();         if (this.min  ) copy.min   = this.min  .copy();         if (this.max  ) copy.max   = this.max  .copy();          return copy;     }        isCached()     {         return super.isCached()             && (!this.min || this.min.isCached())             && (!this.max || this.max.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalNumberValue(this.input, parse);         const min   = await evalNumberValue(this.min,   parse);         const max   = await evalNumberValue(this.max,   parse);           if (input)         {             const z3790 = Math.max(                 input.decimals,                 min  .decimals,                 max  .decimals);              this.value = new k2022(                 min.value <= max.value                     ? Math.min(Math.max(min.value, input.value), max.value)                     : Math.min(Math.max(max.value, input.value), min.value),                 z3790);         }         else if (this.value)         {             const value = await this.value.eval(parse);              const z3790 = Math.max(                 value.decimals,                 min  .decimals,                 max  .decimals);              this.value = new k2022(                 min.value <= max.value                     ? Math.min(Math.max(min.value, value.value), max.value)                     : Math.min(Math.max(max.value, value.value), min.value),                 z3790);         }         else             this.value = k2022.NaN();           this.c4193(parse,          [             ['value', this.value],             ['min',   min       ],             ['max',   max       ]         ]);           this.validate();          return this;     }        isValid()     {         return  (  !this.input                   || this.input.isValid())              && this.min && this.min.isValid()              && this.max && this.max.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.min) this.min.p4180(parse);         if (this.max) this.max.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.min) this.min.i4181(parse, from, force);         if (this.max) this.max.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.min) this.min.i4179(parse);         if (this.max) this.max.i4179(parse);     } }


class w2606 extends l2044 {     constructor(nodeId, options)     {         super(BOOLEAN_NUMBER, nodeId, options);     }        copy()     {         const copy = new w2606(this.nodeId, this.options);                  copy.t3455(this);          copy.value = this.value;          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalBooleanNumberValue(this.input, parse);           if (input)             this.value = input;         else if (this.value)             await this.value.eval(parse);         else             this.value = k2022.NaN();                    if (this.value.isValid())         {             this.value = new k2022(                 Math.round(Math.min(Math.max(0, this.value.value), 1)),                  0,                 true);         }           this.c4193(parse,          [             ['value', this.value]         ]);           this.validate();          return this;     }        isValid()     {         return !this.input               || this.input.isValid();     } }


class s2627 extends l2044 {     decimals;        constructor(nodeId, options)     {         super(s1354, nodeId, options);     }            reset()     {         super.reset();          this.decimals = null;     }        copy()     {         const copy = new s2627(this.nodeId, this.options);          copy.t3455(this);          if (this.decimals) copy.decimals = this.decimals.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new k2022(0);                   const input    = await evalNumberOrListValue(this.input,    parse);         const decimals = await evalNumberValue      (this.decimals, parse);           if (input)         {             if (this.options.enabled)             {                 this.evalInputOrList(                     input,                      item => getSetPrecisionValue(item, decimals),                      k2022.NaN());              }             else                 this.value = input;         }         else             this.value = k2022.NaN();           this.c4193(parse,         [             ['type',     this.outputType()],             ['value',    this.value       ],             ['decimals', decimals         ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.decimals && this.decimals.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.decimals) this.decimals.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.decimals) this.decimals.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.decimals) this.decimals.i4179(parse);     } }    function getSetPrecisionValue(input, decimals) {     c950(             input == c1090          || input == j1167          || input == d1177,          'input must be NUMBER_VALUE');       if (input.type == j1167)         return new d2010(             input.space,             getPrecisionValue(input.c1, decimals),             getPrecisionValue(input.c2, decimals),             getPrecisionValue(input.c3, decimals));          else if (input.type == d1177)     {         return new c2013(             new d2010(                 input.color.space,                 getPrecisionValue(input.color.c1, decimals),                 getPrecisionValue(input.color.c2, decimals),                 getPrecisionValue(input.color.c3, decimals)),             getPrecisionValue(input.opacity, decimals),             input.blend);     }     else         return getPrecisionValue(input, decimals); }    function getPrecisionValue(value, decimals) {     return new k2022(         value.value,         decimals.value); }


class j1943 extends l2044 {     constructor(nodeId, options)     {         super(d1092, nodeId, options);     }            copy()     {         const copy = new j1943(this.nodeId, this.options);          copy.t3455(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalNumberOrListValue(this.input, parse);           if (input)         {             if (o955(input.type))             {                 this.value = new w2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == c1090                         ? getSignValue(item)                         : k2022.NaN());                    }             }             else                 this.value = getSignValue(input); }         else             this.value = k2022.NaN();           this.c4193(parse,          [             ['type', this.outputType()]         ]);           this.validate();          return this;     } }    function getSignValue(input) {     c950(          input.type == c1090,          'input.type must be NUMBER_VALUE');      return new k2022(Math.sign(input.value)); }


class i1924 extends l2044 {     constructor(nodeId, options)     {         super(g1093, nodeId, options);     }            copy()     {         const copy = new i1924(this.nodeId, this.options);          copy.t3455(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalNumberOrListValue(this.input, parse);           if (input)         {             if (o955(input.type))             {                 this.value = new w2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == c1090                         ? getAbsoluteValue(item, this.options.enabled)                         : k2022.NaN());                    }             }             else                 this.value = getAbsoluteValue(input, this.options.enabled);         }         else             this.value = k2022.NaN();           this.c4193(parse,          [             ['type', this.outputType()]         ]);           this.validate();          return this;     } }    function getAbsoluteValue(input, enabled) {     c950(          input.type == c1090,          'input.type must be NUMBER_VALUE');      return enabled         ? new k2022(Math.abs(input.value), input.decimals)         : input; }


class k2619 extends l2044 {     constructor(nodeId, options)     {         super(u1355, nodeId, options);     }            copy()     {         const copy = new k2619(this.nodeId, this.options);          copy.t3455(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalNumberOrListValue(this.input, parse);                       if (input)         {             if (o955(input.type))             {                 this.value = new w2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == c1090                         ? getNegativeValue(item, this.options.enabled)                         : k2022.NaN());                    }             }             else                 this.value = getNegativeValue(input, this.options.enabled);         }         else             this.value = k2022.NaN();           this.c4193(parse,          [             ['type', this.outputType()]         ]);           this.validate();          return this;     } }    function getNegativeValue(input, enabled) {     c950(          input == c1090,          'input must be NUMBER_VALUE');      return new k2022(         (enabled ? -1 : 1) * input.value,         input.decimals); }


class b1941 extends l2044 {     type;     decimals;        constructor(nodeId, options)     {         super(y1094, nodeId, options);     }            reset()     {         super.reset();          this.type     = null;         this.decimals = null;     }        copy()     {         const copy = new b1941(this.nodeId, this.options);          copy.t3455(this);          if (this.type    ) copy.type     = this.type    .copy();         if (this.decimals) copy.decimals = this.decimals.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new k2022(0);                   const input = await evalNumberOrListValue(this.input,    parse);         const type  = await evalNumberValue      (this.type,     parse);         const dec   = await evalNumberValue      (this.decimals, parse);           if (   input             && type             && dec)         {             if (o955(input.type))             {                 this.value = new w2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == c1090                         ? getRoundValue(item, type, dec, this.options.enabled)                         : k2022.NaN());                    }             }             else                 this.value = getRoundValue(input, type, dec, this.options.enabled); }         else             this.value = k2022.NaN();           this.c4193(parse,         [             ['_type',    this.outputType()],             ['type',     type             ],             ['decimals', dec              ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.type     && this.type    .isValid()             && this.decimals && this.decimals.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.type    ) this.type    .p4180(parse);         if (this.decimals) this.decimals.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.type    ) this.type    .i4181(parse, from, force);         if (this.decimals) this.decimals.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.type    ) this.type    .i4179(parse);         if (this.decimals) this.decimals.i4179(parse);     } }    function getRoundValue(input, type, dec, enabled) {     c950(         input.type == c1090,         'input.type must be NUMBER_VALUE');       if (!enabled)         return input;      switch (type.value)     {         case 0: return new k2022(g1013(input.value, dec.value), dec.value);         case 1: return new k2022(d1014(input.value, dec.value), dec.value);         case 2: return new k2022( m1015(input.value, dec.value), dec.value);     } }


class v2611 extends l2044 {     type;     base;     step;     amount;        constructor(nodeId, options)     {         super(j1356, nodeId, options);     }            reset()     {         super.reset();          this.type   = null;         this.base   = null;         this.step   = null;         this.amount = null;     }        copy()     {         const copy = new v2611(this.nodeId, this.options);          copy.t3455(this);          if (this.type  ) copy.type   = this.type  .copy();         if (this.base  ) copy.base   = this.base  .copy();         if (this.step  ) copy.step   = this.step  .copy();         if (this.amount) copy.amount = this.amount.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new k2022(0);                   const input  = await evalNumberOrListValue(this.input,  parse);         const type   = await evalNumberValue      (this.type,   parse);         const base   = await evalNumberValue      (this.base,   parse);         const step   = await evalNumberValue      (this.step,   parse);         const amount = await evalNumberValue      (this.amount, parse);           if (input)         {             if (o955(input.type))             {                 this.value = new w2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == c1090                         ? getQuantizeValue(item, type, base, step, amount, this.options.enabled)                         : k2022.NaN());                    }             }             else                 this.value = getQuantizeValue(input, type, base, step, amount, this.options.enabled); }         else             this.value = k2022.NaN();           this.c4193(parse,         [             ['_type',  this.outputType()],             ['type',   type             ],             ['base',   base             ],             ['step',   step             ],             ['amount', amount           ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.type   && this.type  .isValid()             && this.base   && this.base  .isValid()             && this.step   && this.step  .isValid()             && this.amount && this.amount.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.type  ) this.type  .p4180(parse);         if (this.base  ) this.base  .p4180(parse);         if (this.step  ) this.step  .p4180(parse);         if (this.amount) this.amount.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.type  ) this.type  .i4181(parse, from, force);         if (this.base  ) this.base  .i4181(parse, from, force);         if (this.step  ) this.step  .i4181(parse, from, force);         if (this.amount) this.amount.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.type  ) this.type  .i4179(parse);         if (this.base  ) this.base  .i4179(parse);         if (this.step  ) this.step  .i4179(parse);         if (this.amount) this.amount.i4179(parse);     } }    function getQuantizeValue(input, type, base, step, amount, enabled) {     c950(          input.type == c1090,          'input.type must be NUMBER_VALUE');           if (!enabled)         return input;       let qval;      switch (type.value)     {         case 0: qval = base.value + step.value * Math.floor((input.value - base.value) / step.value); break;         case 1: qval = base.value + step.value * Math.round((input.value - base.value) / step.value); break;         case 2: qval = base.value + step.value * Math. ceil((input.value - base.value) / step.value); break;     }      return new k2022(         input.value + (qval - input.value) * amount.value/100,         Math.max(base.decimals, step.decimals)); }


class e1944 extends l2044 {     operand;     operation;        constructor(nodeId, options)     {         super(w1095, nodeId, options);     }            reset()     {         super.reset();          this.operand   = null;         this.operation = null;     }        copy()     {         const copy = new e1944(this.nodeId, this.options);          copy.t3455(this);          if (this.operand  ) copy.operand   = this.operand  .copy();         if (this.operation) copy.operation = this.operation.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new k2022(0);                   const input   = await evalNumberOrListValue(this.input,     parse);         const operand = await evalNumberValue      (this.operand,   parse);         const op      = await evalNumberValue      (this.operation, parse);           if (input)         {             if (this.options.enabled)             {                 if (o955(input.type))                 {                     this.value = new w2021();                      for (let i = 0; i < input.items.length; i++)                     {                         const item = input.items[i];                          this.value.items.push(                             item.type == c1090                             ? getSimpleMinMaxValue(item, operand, op, this.options.enabled)                             : k2022.NaN());                        }                 }                 else                 {                     this.value = getSimpleMinMaxValue(input, operand, op, this.options.enabled);                 }             }             else                 this.value = input.copy();         }         else             this.value = k2022.NaN();           this.c4193(parse,         [             ['type',      this.outputType()],             ['operand',   operand          ],             ['operation', op               ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.operand   && this.operation.isValid()             && this.operation && this.operand  .isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.operand  ) this.operand  .p4180(parse);         if (this.operation) this.operation.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.operand  ) this.operand  .i4181(parse, from, force);         if (this.operation) this.operation.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.operand  ) this.operand  .i4179(parse);         if (this.operation) this.operation.i4179(parse);     } }    function getSimpleMinMaxValue(input, operand, op, enabled) {     c950(         input.type == c1090,          'input.type is ' + input.type + ', must be NUMBER_VALUE');       if (enabled)     {         op.value = Math.min(Math.max(0, Math.floor(op.value)), 1);          return new k2022(op.value == 0             ? Math.min(input.value, operand.p3798())             : Math.max(input.value, operand.p3798()));     }     else         return input; }


class i1933 extends b1899 {     operation;        constructor(nodeId, options)     {         super(m1096, nodeId, options);     }            reset()     {         super.reset();          this.operation = null;     }        copy()     {         const copy = new i1933(this.nodeId, this.options);          copy.t3455(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.operation) copy.operation = this.operation.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const inputs = await Promise.all(this.inputs.map(async i => await evalNumberOrListValue(i, parse)));         let   op     = await evalNumberValue(this.operation, parse);           if (op) op = op.v3824();           if (this.options.enabled)             op.value = Math.min(Math.max(0, op.value), g1310.length-1);                   this.value = await evalMinMaxInputs(inputs, op, parse);                   this.c4193(parse,         [             ['type',      this.outputType()],             ['operation', op               ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.operation && this.operation.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.operation) this.operation.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.operation) this.operation.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.operation) this.operation.i4179(parse);     } }    async function evalMinMaxInputs(inputs, op, parse) {     if (isEmpty(inputs))         return k2022.NaN();       const allAreLists = allInputsAreCondensedLists(inputs);      if (allAreLists) return await evalMinMaxListInputs(inputs, op, parse);     else             return await evalMinMaxItemInputs(inputs, op, parse); }    async function evalMinMaxListInputs(inputs, op, parse) {     const value = new w2021();           for (const input of inputs)     {         if (!input) continue;          console.assert(              o955(input.type),              `input is ${input.type}, must be a list`);          if (allInputsAreCondensedLists(input.items))             value.items.push(...(await evalMinMaxListInputs(input.items, op, parse)).items);         else             value.items.push(await evalMinMaxItemInputs(input.items, op, parse));     }       return value; }    async function evalMinMaxItemInputs(inputs, op, parse) {     if (isEmpty(inputs))         return k2022.NaN();       let value = new k2022(0);       const o4175 = await evalNumberOrListValue(inputs[0], parse);       if (    o955(o4175.type)         && !isEmpty(o4175.items))     {         value = o4175.items[0].copy();                  for (let i = 1; i < o4175.items.length; i++)         {             const item = o4175.items[i];              if (item.type == c1090)             {                 value = new k2022(                      op.value == 0                     ? Math.min(value.value, item.value)                     : Math.max(value.value, item.value));             }                             }     }     else     {         if (o4175.type != c1090)             return k2022.NaN();          value = o4175;     }       for (let i = 1; i < inputs.length; i++)     {         const input = await evalNumberOrListValue(inputs[i], parse);           if (o955(input.type))         {             for (const item of input.items)             {                 if (item.type == c1090)                 {                     value = new k2022(                         op.value == 0                         ? Math.min(value.value, item.value)                         : Math.max(value.value, item.value));                 }                                 }         }         else         {             c950(                 input.type == c1090,                  'val.type must be NUMBER_VALUE');                              value = new k2022(                 op.value == 0                 ? Math.min(value.value, input.value)                 : Math.max(value.value, input.value));         }     }       return value; }


class i1932 extends l2044 {     min = null;     max = null;            constructor(nodeId, options)     {         super(j1097, nodeId, options);     }            reset()     {         super.reset();          this.min = null;         this.max = null;     }        copy()     {         const copy = new i1932(this.nodeId, this.options);          copy.t3455(this);          if (this.min) copy.min = this.min.copy();         if (this.max) copy.max = this.max.copy();          return copy;     }        isCached()     {         return super.isCached()             && (!this.min || this.min.isCached())             && (!this.max || this.max.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;                       const input = await evalNumberOrListValue(this.input, parse);         const min   = await evalNumberValue      (this.min,   parse);         const max   = await evalNumberValue      (this.max,   parse);           if (input)         {             if (o955(input.type))             {                 this.value = new w2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == c1090                         ? getLimitsValue(item, min, max, this.options.enabled)                         : k2022.NaN());                    }             }             else                 this.value = getLimitsValue(input, min, max, this.options.enabled);         }         else             this.value = k2022.NaN();           this.c4193(parse,         [             ['type', this.outputType()],             ['min',  min              ],             ['max',  max              ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.min && this.min.isValid()             && this.max && this.max.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.input) this.input.p4180(parse);         if (this.min  ) this.min  .p4180(parse);         if (this.max  ) this.max  .p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.input) this.input.i4181(parse, from, force);         if (this.min  ) this.min  .i4181(parse, from, force);         if (this.max  ) this.max  .i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.input) this.input.i4179(parse);         if (this.min  ) this.min  .i4179(parse);         if (this.max  ) this.max  .i4179(parse);     } }    function getLimitsValue(input, min, max, enabled) {     c950(          input.type == c1090,          'input.type must be NUMBER_VALUE');      if (!enabled)         return input;      return new k2022(         Math.min(Math.max(             min.value,             input.value),             max.value),         input.decimals); }


class b1937 extends l2044 {     min   = null;     max   = null;     power = null;            constructor(nodeId, options)     {         super(v1098, nodeId, options);     }            reset()     {         super.reset();          this.min   = null;         this.max   = null;         this.power = null;     }        copy()     {         const copy = new b1937(this.nodeId, this.options);          copy.t3455(this);          if (this.min  ) copy.min   = this.min  .copy();         if (this.max  ) copy.max   = this.max  .copy();         if (this.power) copy.power = this.power.copy();          return copy;     }        isCached()     {         return super.isCached()             && (!this.min   || this.min  .isCached())             && (!this.max   || this.max  .isCached())             && (!this.power || this.power.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;                       const input = await evalNumberOrListValue(this.input, parse);         const min   = await evalNumberValue      (this.min,   parse);         const max   = await evalNumberValue      (this.max,   parse);         const power = await evalNumberValue      (this.power, parse);           if (input)         {             if (o955(input.type))             {                 this.value = new w2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == c1090                         ? getNumberCurveValue(item, min, max, power, this.options.enabled)                         : k2022.NaN());                    }             }             else                 this.value = getNumberCurveValue(input, min, max, power, this.options.enabled);         }         else             this.value = k2022.NaN();           this.c4193(parse,         [             ['type',  this.outputType()],             ['min',   min              ],             ['max',   max              ],             ['power', power            ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.min   && this.min  .isValid()             && this.max   && this.max  .isValid()             && this.power && this.power.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.min  ) this.min  .p4180(parse);         if (this.max  ) this.max  .p4180(parse);         if (this.power) this.power.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.min  ) this.min  .i4181(parse, from, force);         if (this.max  ) this.max  .i4181(parse, from, force);         if (this.power) this.power.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.min  ) this.min  .i4179(parse);         if (this.max  ) this.max  .i4179(parse);         if (this.power) this.power.i4179(parse);     } }    function getNumberCurveValue(input, min, max, power, enabled) {     c950(         input.type == c1090,         'input.type must be NUMBER_VALUE');       if (!enabled)         return input;       let f = (input.value - min.value) / (max.value - min.value);      f = Math.pow(f, power.value);     f = min.value + f * (max.value - min.value);          return new k2022(f); }


class k2603 extends l2044 {     from = null;     to   = null;            constructor(nodeId, options)     {         super(a1357, nodeId, options);     }            reset()     {         super.reset();          this.from = null;         this.to   = null;     }        copy()     {         const copy = new k2603(this.nodeId, this.options);          copy.t3455(this);          if (from) copy.from = this.from.copy();         if (to  ) copy.to   = this.to  .copy();          return copy;     }        isCached()     {         return super.isCached()             && (!this.from  || this.from.isCached())             && (!this.to    || this.to  .isCached());     }        async eval(parse)     {         if (this.isCached())             return this;                       const input = await evalNumberOrListValue(this.input, parse);         const from  = await evalListValue        (this.from,  parse);         const to    = await evalListValue        (this.to,    parse);          let nanList = false;           if (   input              && input.isValid())         {             if (this.options.enabled)             {                 if (   from && from.isValid() && from.items.length > 0                     && to   && to  .isValid() && to  .items.length > 0)                 {                     if (o955(input.type))                     {                         this.value = new w2021();                                  for (let i = 0; i < input.items.length; i++)                         {                             const item = input.items[i];                                      this.value.items.push(                                 item.type == c1090                                 ? getNumberMapValue(item, from, to)                                 : k2022.NaN());                            }                     }                     else                         this.value = getNumberMapValue(input, from, to);                 }                 else                 {                     if (o955(input.type))                     {                         this.value = new w2021();                         nanList = true;                     }                     else                         this.value = k2022.NaN();                 }             }             else                 this.value = input;         }         else             this.value = k2022.NaN();           this.c4193(parse,         [             ['type', nanList ? new f2033(b1055) : this.outputType()],             ['from', from                                           ],             ['to',   to                                             ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.from && this.from.isValid()             && this.to   && this.to  .isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.from) this.from.p4180(parse);         if (this.to  ) this.to  .p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.from) this.from.i4181(parse, from, force);         if (this.to  ) this.to  .i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.from) this.from.i4179(parse);         if (this.to  ) this.to  .i4179(parse);     } }    function getNumberMapValue(input, from, to) {     c950(         input.type == c1090,         'input.type must be NUMBER_VALUE');       const maxDec = Math.max(         from.items.reduce((max, val) => Math.max(max, val.decimals), 0),         to  .items.reduce((max, val) => Math.max(max, val.decimals), 0));       if (from.items.length == 1)         return input;             const nFromSegments = Math.floor(from.items.length-1);     let   fromIndex     = 0;      while (fromIndex < nFromSegments-1)     {         if (   input.value >= from.items[fromIndex  ]             && input.value <  from.items[fromIndex+1])             break;          fromIndex++;     }               const fromLocal =              (input.value - from.items[fromIndex].value)          / (from.items[fromIndex+1].value - from.items[fromIndex].value);      const f = fromIndex/nFromSegments + fromLocal * ((fromIndex+1)/nFromSegments - fromIndex/nFromSegments);                 const nToSegments = Math.floor(to.items.length-1);     const toIndex     = Math.min(Math.max(0, Math.floor((to.items.length-1) * f)), nToSegments-1);       if (to.items.length == 1)         return to.items[0];      else if (to.items.length > 0             && toIndex < to.items.length-1)     {         const toLocal =              nToSegments > 1             ? (f - toIndex/nToSegments) * nToSegments             : f;           const y3785 = to.items[toIndex  ];         const val1 = to.items[toIndex+1];          return new k2022(             q1033(y3785.value, val1.value, toLocal),             maxDec);     } }


class n2618 extends l2044 {     min    = null;     max    = null;     bias   = null;     spread = null;            constructor(nodeId, options)     {         super(x1358, nodeId, options);     }            reset()     {         super.reset();          this.min    = null;         this.max    = null;         this.bias   = null;         this.spread = null;     }        copy()     {         const copy = new n2618(this.nodeId, this.options);          copy.t3455(this);          if (this.min   ) copy.min    = this.min   .copy();         if (this.max   ) copy.max    = this.max   .copy();         if (this.bias  ) copy.bias   = this.bias  .copy();         if (this.spread) copy.spread = this.spread.copy();          return copy;     }        isCached()     {         return super.isCached()             && (!this.min    || this.min   .isCached())             && (!this.max    || this.max   .isCached())             && (!this.bias   || this.bias  .isCached())             && (!this.spread || this.spread.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;                       const input  = await evalNumberOrListValue(this.input,  parse);         const min    = await evalNumberValue      (this.min,    parse);         const max    = await evalNumberValue      (this.max,    parse);         const bias   = await evalNumberValue      (this.bias,   parse);         const spread = await evalNumberValue      (this.spread, parse);           if (input)         {             if (o955(input.type))             {                 this.value = new w2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == c1090                         ? getNumberBiasValue(item, min, max, bias, spread, this.options.enabled)                         : k2022.NaN());                    }             }             else                 this.value = getNumberBiasValue(input, min, max, bias, spread, this.options.enabled);         }         else             this.value = k2022.NaN();           this.c4193(parse,         [             ['type',   this.outputType()],             ['min',    min              ],             ['max',    max              ],             ['bias',   bias             ],             ['spread', spread           ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.min    && this.min   .isValid()             && this.max    && this.max   .isValid()             && this.bias   && this.bias  .isValid()             && this.spread && this.spread.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.min   ) this.min   .p4180(parse);         if (this.max   ) this.max   .p4180(parse);         if (this.bias  ) this.bias  .p4180(parse);         if (this.spread) this.spread.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.min   ) this.min   .i4181(parse, from, force);         if (this.max   ) this.max   .i4181(parse, from, force);         if (this.bias  ) this.bias  .i4181(parse, from, force);         if (this.spread) this.spread.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.min   ) this.min   .i4179(parse);         if (this.max   ) this.max   .i4179(parse);         if (this.bias  ) this.bias  .i4179(parse);         if (this.spread) this.spread.i4179(parse);     } }    function x3830(f, bias, spread) {     const b = bias   / 50;     const s = spread / 50;       f =          b >= 0         ? 1 - Math.pow(1-f, 1+b)         :     Math.pow(  f, 1-b);            if (s >= 0 && f >= 0.5) f = 1 - Math.pow((1-f)*2, 1+s) / 2;     else if (s >= 0 && f <  0.5) f = Math.pow(f*2, 1+s) / 2;     else if (s < 0)              f = b1035(0, (1-s)/3, (2+s)/3, 1, f);       return f; }    function getNumberBiasValue(input, min, max, bias, spread, enabled) {     c950(         input.type == c1090,         'input.type must be NUMBER_VALUE');       if (!enabled)         return input;       let f = (input.value - min.value) / (max.value - min.value);      f = x3830(f, bias.value, spread.value);     f = min.value + f * (max.value - min.value);      return new k2022(         f,          Math.max(             input.decimals,             min  .decimals,             max  .decimals)); }


class d1934 extends l2044 {     constructor(nodeId, options)     {         super(a1099, nodeId, options);     }            copy()     {         const copy = new d1934(this.nodeId, this.options);          copy.t3455(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalNumberOrListValue(this. input, parse);           if (input)         {             if (o955(input.type))             {                 this.value = new w2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == c1090                         ? getNumberIsNaN(item)                         : f2033.NaN());                    }             }             else             {                 this.value = getNumberIsNaN(input);             }         }          else             this.value = u2622.NaN();           this.c4193(parse,         [             ['type', this.outputType()]         ]);           this.validate();          return this;     } }    function getNumberIsNaN(input) {     return !input.isValid()         ? new u2622(true )         : new u2622(false); }


class u1927 extends i2043 {     constant;        constructor(nodeId, options)     {         super(j1100, nodeId, options);     }            reset()     {         super.reset();          this.constant = null;     }        copy()     {         const copy = new u1927(this.nodeId, this.options);          copy.t3455(this);          if (this.constant) copy.constant = this.constant.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                                  const constant = await evalNumberValue(this.constant, parse);                   let value;          switch (Math.min(Math.max(0, constant.p3798()), 5))         {             case 0: value = 1.4142135623; break;              case 1: value = 2.7182818284; break;              case 2: value = 0.6180339887; break;              case 3: value = 1.6180339887; break;              case 4: value = 3.1415926536; break;              case 5: value = 6.2831853072; break;          }           this.value = new k2022(value);                   this.c4193(parse,         [             ['value',   this.value],             ['constant', constant ]         ]);           this.validate();          return this;     }        isValid()     {         return this.constant && this.constant.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.constant) this.constant.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.constant) this.constant.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.constant) this.constant.i4179(parse);     } } 


class e1929 extends i2043 {     seconds   = null;     minutes   = null;     hours     = null;     dayOfWeek = null;     date      = null;     month     = null;     year      = null;                    constructor(nodeId, options)     {         super(j1097, nodeId, options);     }            reset()     {         super.reset();                  this.seconds   = null;         this.minutes   = null;         this.hours     = null;         this.dayOfWeek = null;         this.date      = null;         this.month     = null;         this.year      = null;     }        copy()     {         const copy = new i1932(this.nodeId, this.options);                  copy.t3455(this);                  if (this.seconds  ) copy.seconds   = this.seconds  .copy();         if (this.minutes  ) copy.minutes   = this.minutes  .copy();         if (this.hours    ) copy.hours     = this.hours    .copy();         if (this.dayOfWeek) copy.dayOfWeek = this.dayOfWeek.copy();         if (this.date     ) copy.date      = this.date     .copy();         if (this.month    ) copy.month     = this.month    .copy();         if (this.year     ) copy.year      = this.year     .copy();          return copy;     }                        isCached()     {         return super.isCached()             && (!this.year      || this.year     .isCached())             && (!this.month     || this.month    .isCached())             && (!this.date      || this.date     .isCached())             && (!this.dayOfWeek || this.dayOfWeek.isCached())             && (!this.hours     || this.hours    .isCached())             && (!this.minutes   || this.minutes  .isCached())             && (!this.seconds   || this.seconds  .isCached())     }        async eval(parse)     {         if (this.isCached())             return this;           this.c3193 = [];                   if (this.options.enabled)         {             const dateTime = new Date();              const seconds   = new k2022(dateTime.getSeconds() );             const minutes   = new k2022(dateTime.getMinutes() );             const hours     = new k2022(dateTime.getHours()   );             const dayOfWeek = new k2022(dateTime.getDay()     );             const date      = new k2022(dateTime.getDate()    );             const month     = new k2022(dateTime.getMonth()   );             const year      = new k2022(dateTime.getFullYear());               this.c4193(parse,             [                 ['seconds',   seconds  ],                 ['minutes',   minutes  ],                 ['hours',     hours    ],                 ['dayOfWeek', dayOfWeek],                 ['date',      date     ],                 ['month',     month    ],                 ['year',      year     ]             ]);             }                       this.validate();          return this;     }            isValid()     {         return this.year      && this.year     .isValid()             && this.month     && this.month    .isValid()             && this.date      && this.date     .isValid()             && this.dayOfWeek && this.dayOfWeek.isValid()             && this.hours     && this.hours    .isValid()             && this.minutes   && this.minutes  .isValid()             && this.seconds   && this.seconds  .isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.year     ) this.year     .p4180(parse);         if (this.month    ) this.month    .p4180(parse);         if (this.date     ) this.date     .p4180(parse);         if (this.dayOfWeek) this.dayOfWeek.p4180(parse);         if (this.hours    ) this.hours    .p4180(parse);         if (this.minutes  ) this.minutes  .p4180(parse);         if (this.seconds  ) this.seconds  .p4180(parse);     }            i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.year     ) this.year     .i4181(parse, from, force);         if (this.month    ) this.month    .i4181(parse, from, force);         if (this.date     ) this.date     .i4181(parse, from, force);         if (this.dayOfWeek) this.dayOfWeek.i4181(parse, from, force);         if (this.hours    ) this.hours    .i4181(parse, from, force);         if (this.minutes  ) this.minutes  .i4181(parse, from, force);         if (this.seconds  ) this.seconds  .i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.year     ) this.year     .i4179(parse);         if (this.month    ) this.month    .i4179(parse);         if (this.date     ) this.date     .i4179(parse);         if (this.dayOfWeek) this.dayOfWeek.i4179(parse);         if (this.hours    ) this.hours    .i4179(parse);         if (this.minutes  ) this.minutes  .i4179(parse);         if (this.seconds  ) this.seconds  .i4179(parse);     }     } 


class o1930 extends i2043 {     inputs = [];        constructor(nodeId, options)     {         super(u1085, nodeId, options);     }            reset()     {         super.reset();          this.input = [];     }        copy()     {         const copy = new o1930(this.nodeId, this.options);          copy.t3455(this);          copy.inputs = this.inputs.map(i => i.copy());          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const _values = [];          for (let i = 0; i < this.inputs.length; i++)         {             const input = await evalValue(this.inputs[i], parse);              if (   input                 && this.options.enabled)                         {                 if (o955(input.type))                 {                     if (input.condensed === true)                         _values.push(input.copy());                     else                     {                         for (const item of input.items)                             _values.push(item.copy());                        }                 }                 else                     _values.push(input.copy());             }         }                       this.value =              _values.length > 0                 ? _values[this.currentIteration % _values.length]                 : new s4309();           if (   this.value              && this.value.objects)         {             for (let i = 0; i < this.value.objects.length; i++)             {                 const b111 = this.value.objects[i];                      b111.nodeId = this.nodeId;                 b111.listId = -1;                      b111.objectId = this.nodeId;                                  if (b111.objectId != NULL)                      b111.objectId += '/';                      b111.objectId += i.toString();             }         }           this.x4192(parse);                   const type =                _values.length > 1             && h3575(_values) == q1054                 ? new f2033(n1086)                 : this.outputType();           this.c4193(parse,         [             ['type', type]         ]);                   this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return !this.inputs.find(i => !i.isValid());     }        p4180(parse)     {         super.p4180(parse);          this.inputs.forEach(i => i.p4180(parse));     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          this.inputs.forEach(i => i.i4181(parse, from, force));     }        i4179(parse)     {         super.i4179(parse);          this.inputs.forEach(i => i.i4179(parse));     } } 


class z1942 extends i2043 {     start    = null;     multiply = null;     add      = null;     end      = null;      current  = null;                    constructor(nodeId, options)     {         super(x1102, nodeId, options);     }        reset()     {         super.reset();                  this.start    = null;         this.multiply = null;         this.add      = null;         this.end      = null;              this.current  = null;     }           copy()     {         const copy = new z1942(this.nodeId, this.options);          copy.t3455(this);          if (this.start   ) copy.start    = this.start   .copy();         if (this.multiply) copy.multiply = this.multiply.copy();         if (this.add     ) copy.add      = this.add     .copy();         if (this.end     ) copy.end      = this.end     .copy();          if (this.current) copy.current = this.current.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const start = await evalNumberValue(this.start,    parse);         const mult  = await evalNumberValue(this.multiply, parse);         const add   = await evalNumberValue(this.add,      parse);         const end   = await evalNumberValue(this.end,      parse);               if (   start             && mult             && add             && end)         {             const value = start.value + (this.options.enabled ? add.value * this.currentIteration : 0);              if (!end.isValid())                 this.value = getSequenceValue(start, mult, add, this.currentIteration, this.options.enabled);              else if (   end.isValid()                         && (   add.value == 0                          || add.value >  0 && start.value < end.value                                            &&       value < end.value                          || add.value <  0 && start.value > end.value                                            &&       value > end.value))                 this.value = getSequenceValue(start, mult, add, this.currentIteration, this.options.enabled);              else                 this.value = k2022.NaN();         }         else             this.value = k2022.NaN();           this.c4193(parse,         [             ['start',    start],             ['multiply', mult ],             ['add',      add  ],             ['end',      end  ]         ]);                   this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return this.start    && this.start   .isValid()             && this.multiply && this.multiply.isValid()             && this.add      && this.add     .isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.start   ) this.start   .p4180(parse);         if (this.multiply) this.multiply.p4180(parse);         if (this.add     ) this.add     .p4180(parse);         if (this.end     ) this.end     .p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.start   ) this.start   .i4181(parse, from, force);         if (this.multiply) this.multiply.i4181(parse, from, force);         if (this.add     ) this.add     .i4181(parse, from, force);         if (this.end     ) this.end     .i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.start   ) this.start   .i4179(parse);         if (this.multiply) this.multiply.i4179(parse);         if (this.add     ) this.add     .i4179(parse);         if (this.end     ) this.end     .i4179(parse);     } }    function getSequenceValue(start, mult, add, iteration, enabled) {     let value = start.value;      if (enabled)     {         for (let i = 0; i < iteration; i++)         {             value *= mult.value;             value += add .value;         }     }      return new k2022(         value,          Math.max(             start.decimals,              mult .decimals,              add  .decimals)); }


class b1940 extends i2043 {     from  = null;     start = null;     end   = null;                constructor(nodeId, options)     {         super(h1103, nodeId, options);     }            reset()     {         super.reset();          this.from  = null;         this.start = null;         this.end   = null;     }        copy()     {         const copy = new b1940(this.nodeId, this.options);          copy.t3455(this);          if (this.from   ) copy.from    = this.from   .copy();         if (this.start  ) copy.start   = this.start  .copy();         if (this.end    ) copy.end     = this.end    .copy();          if (this.current) copy.current = this.current.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const from  = await evalNumberValue(this.from,  parse);         const start = await evalNumberValue(this.start, parse);         const end   = await evalNumberValue(this.end,   parse);               const repeat    = parse.repeats.find(r => r.repeatId == this.b3916);         const iteration = repeat ? repeat.currentIteration : 0;           if (   from             && start             && end)         {             let delta = end.value - start.value;              let step =                  repeat                 && this.options.enabled                 ? delta / Math.max(1, repeat.total - (from.value == 1 ? 1 : 0))                 : 0;                               let startOffset;                   if (from  .value == 2) startOffset = step;             else if (from  .value == 1                 && repeat                 && repeat.total == 1) startOffset = delta/2;             else                        startOffset = 0;               let f;                          if (repeat)             {                      if (from.value == 2) f = iteration/repeat.total;                 else if (from.value == 1) f = (repeat.total > 1 ? iteration/(repeat.total-1) : 0);                 else if (from.value == 0) f = iteration/repeat.total;             }             else                 f = 0;               this.value = new k2022(                 start.value + startOffset + f * delta,                 Math.max(start.decimals, end.decimals));         }         else             this.value = k2022.NaN();           this.c4193(parse,         [             ['from',  from ],             ['start', start],             ['end',   end  ]         ]);           this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return this.from  && this.from .isValid()             && this.start && this.start.isValid()             && this.end   && this.end  .isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.from ) this.from .p4180(parse);         if (this.start) this.start.p4180(parse);         if (this.end  ) this.end  .p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.from ) this.from .i4181(parse, from, force);         if (this.start) this.start.i4181(parse, from, force);         if (this.end  ) this.end  .i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.from ) this.from .i4179(parse);         if (this.start) this.start.i4179(parse);         if (this.end  ) this.end  .i4179(parse);     } } 


class i1946 extends i2043 {     shape     = null;     base      = null;     amplitude = null;     frequency = null;     offset    = null;     bias      = null;          useWavelength;     offsetAbsolute;        constructor(nodeId, options)     {         super(s1104, nodeId, options);     }            reset()     {         super.reset();          this.shape     = null;         this.base      = null;         this.amplitude = null;         this.frequency = null;         this.offset    = null;         this.bias      = null;     }        copy()     {         const copy = new i1946(this.nodeId, this.options);          copy.t3455(this);          if (this.shape    ) copy.shape     = this.shape    .copy();         if (this.base     ) copy.base      = this.base     .copy();         if (this.amplitude) copy.amplitude = this.amplitude.copy();         if (this.frequency) copy.frequency = this.frequency.copy();         if (this.offset   ) copy.offset    = this.offset   .copy();         if (this.bias     ) copy.bias      = this.bias     .copy();          if (this.current) copy.current = this.current.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const shape  = await evalNumberValue(this.shape,     parse);         const base   = await evalNumberValue(this.base,      parse);         const amp    = await evalNumberValue(this.amplitude, parse);         let   freq   = await evalNumberValue(this.frequency, parse);         const offset = await evalNumberValue(this.offset,    parse);         const bias   = await evalNumberValue(this.bias,      parse);               const repeat    = parse.repeats.find(r => r.repeatId == this.b3916);         const iteration = repeat ? repeat.currentIteration : 0;            if (this.options.enabled)         {             let t;                                       if (   repeat                 && shape                 && freq                 && offset)             {                 const _freq =                     this.useWavelength                     ? repeat.total / nozero(freq.value)                     : freq.value;                  let _offset =                     this.offsetAbsolute                     ? offset.value/repeat.total                     : (offset.value/100)/_freq;                  if (shape.value == 3)                     _offset -= 0.25;                  t = (iteration/repeat.total - _offset) * _freq;                  while (t < 0) t++;                 while (t > 1) t--;                  switch (shape.value)                 {                     case 0: t = (t%1) < 0.5 ? 1 : -1;      break;                      case 1: t = (1 - (t%1)*2);             break;                      case 2: t = ((t%1)*2 - 1);             break;                      case 3: t = 1 - 2*Math.abs(2*(t%1)-1); break;                      case 4: t = Math.sin(t * Tau);         break;                  }             }             else                  t = 0;                           if (bias)             {                 const b = bias.value / 100;                  if (b >= 0) t = t / (1+b) + b/2;                 else        t = t / (1-b) + b/2;             }               if (amp ) t = t * amp .value;             if (base) t = t + base.value;               this.value = new k2022(                 t,                  Math.max(                     base  .decimals,                      amp   .decimals,                      freq  .decimals,                      offset.decimals,                      bias  .decimals));         }         else             this.value = base.copy();                   this.c4193(parse,         [             ['shape',     shape ],             ['base',      base  ],             ['amplitude', amp   ],             ['frequency', freq  ],             ['offset',    offset],             ['bias',      bias  ]         ]);           this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return this.shape     && this.shape    .isValid()             && this.base      && this.base     .isValid()             && this.amplitude && this.amplitude.isValid()             && this.frequency && this.frequency.isValid()             && this.offset    && this.offset   .isValid()             && this.bias      && this.bias     .isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.shape    ) this.shape    .p4180(parse);         if (this.base     ) this.base     .p4180(parse);         if (this.amplitude) this.amplitude.p4180(parse);         if (this.frequency) this.frequency.p4180(parse);         if (this.offset   ) this.offset   .p4180(parse);         if (this.bias     ) this.bias     .p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.shape    ) this.shape    .i4181(parse, from, force);         if (this.base     ) this.base     .i4181(parse, from, force);         if (this.amplitude) this.amplitude.i4181(parse, from, force);         if (this.frequency) this.frequency.i4181(parse, from, force);         if (this.offset   ) this.offset   .i4181(parse, from, force);         if (this.bias     ) this.bias     .i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.shape    ) this.shape    .i4179(parse);         if (this.base     ) this.base     .i4179(parse);         if (this.amplitude) this.amplitude.i4179(parse);         if (this.frequency) this.frequency.i4179(parse);         if (this.offset   ) this.offset   .i4179(parse);         if (this.bias     ) this.bias     .i4179(parse);     } } 


class y1939 extends i2043 {     seed         = null;     iteration    = null;     min          = null;     max          = null;     bias         = null;     spread       = null;     unique       = null;      random       = null;     randomUnique = null;      lastValue1   = -1;     lastValue2   = -1;     uniqueOffset =  0;        constructor(nodeId, options)     {         super(k1105, nodeId, options);     }            reset()     {         super.reset();          this.seed      = null;         this.iteration = null;         this.min       = null;         this.max       = null;         this.bias      = null;         this.spread    = null;         this.unique    = null;     }        copy()     {         const copy = new y1939(this.nodeId, this.options);          copy.t3455(this);          if (this.seed     ) copy.seed      = this.seed     .copy();         if (this.iteration) copy.iteration = this.iteration.copy();         if (this.min      ) copy.min       = this.min      .copy();         if (this.max      ) copy.max       = this.max      .copy();         if (this.bias     ) copy.bias      = this.bias     .copy();         if (this.spread   ) copy.spread    = this.spread   .copy();         if (this.unique   ) copy.unique    = this.unique   .copy();          if (this.random   ) copy.random    = this.random   .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const seed      = await evalNumberValue(this.seed,      parse);         const iteration = await evalNumberValue(this.iteration, parse);         const min       = await evalNumberValue(this.min,       parse);         const max       = await evalNumberValue(this.max,       parse);         const bias      = await evalNumberValue(this.bias,      parse);         const spread    = await evalNumberValue(this.spread,    parse);         const unique    = await evalNumberValue(this.unique,    parse);               if (   this.options.enabled             && iteration             && seed             && min             && max             && bias             && spread             && unique)         {             if (  !this.random                 || this.random.seed != seed.value)             {                 this.random       = new Random(seed.value);                 this.randomUnique = new Random(seed.value+1);             }               if (iteration.isValid())                 this.currentIteration = Math.round(iteration.value);               if (this.currentIteration >= 0)             {                 let f  = this.random.get(this.currentIteration + this.uniqueOffset);                  f = x3830(f, bias.value, spread.value);                 f = min.value + f * (max.value - min.value);                                  this.value = new k2022(f, Math.max(min.decimals, max.decimals));                                       const _unique = unique.value/100;                                   if (max.value - min.value >= 1)                 {                     while (this.value.p3798() == this.lastValue1                         && this.randomUnique.get(this.currentIteration) < _unique)                         this.value = new k2022(                             min.value + this.random.get(this.currentIteration + ++this.uniqueOffset) * (max.value - min.value),                             Math.max(min.decimals, max.decimals));                 }                  if (max.value - min.value >= 2)                 {                     while ((   this.value.p3798() == this.lastValue1                             || this.value.p3798() == this.lastValue2)                         && this.randomUnique.get(this.currentIteration) < Math.max(_unique - 1))                         this.value = new k2022(                             min.value + this.random.get(this.currentIteration + ++this.uniqueOffset) * (max.value - min.value),                             Math.max(min.decimals, max.decimals));                 }                     }             else                 this.value = new k2022((min.value + max.value) / 2);         }         else             this.value = k2022.NaN();                              this.lastValue2 = this.lastValue1;         this.lastValue1 = this.value.p3798();           this.c4193(parse,         [             ['iteration', iteration],             ['seed',      seed     ],             ['min',       min      ],             ['max',       max      ],             ['bias',      bias     ],             ['spread',    spread   ],             ['unique',    unique   ]         ]);                   this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return this.seed      && this.seed     .isValid()             && this.iteration && this.iteration.isValid()             && this.min       && this.min      .isValid()             && this.max       && this.max      .isValid()             && this.bias      && this.bias     .isValid()             && this.spread    && this.spread   .isValid()             && this.unique    && this.unique   .isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.seed     ) this.seed     .p4180(parse);         if (this.iteration) this.iteration.p4180(parse);         if (this.min      ) this.min      .p4180(parse);         if (this.max      ) this.max      .p4180(parse);         if (this.bias     ) this.bias     .p4180(parse);         if (this.spread   ) this.spread   .p4180(parse);         if (this.unique   ) this.unique   .p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.seed     ) this.seed     .i4181(parse, from, force);         if (this.iteration) this.iteration.i4181(parse, from, force);         if (this.min      ) this.min      .i4181(parse, from, force);         if (this.max      ) this.max      .i4181(parse, from, force);         if (this.bias     ) this.bias     .i4181(parse, from, force);         if (this.spread   ) this.spread   .i4181(parse, from, force);         if (this.unique   ) this.unique   .i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.seed     ) this.seed     .i4179(parse);         if (this.iteration) this.iteration.i4179(parse);         if (this.min      ) this.min      .i4179(parse);         if (this.max      ) this.max      .i4179(parse);         if (this.bias     ) this.bias     .i4179(parse);         if (this.spread   ) this.spread   .i4179(parse);         if (this.unique   ) this.unique   .i4179(parse);     }        v3724(parse, nodeId)     {         super.v3724(parse, nodeId);          this.uniqueOffset = 0;     }        s3727(parse, nodeId)     {         super.s3727(parse, nodeId);          this.uniqueOffset = 0;     } } 


class i1935 extends i2043 {     seed        = null;     iteration   = null;     min         = null;     max         = null;     scale       = null;     interpolate = null;     offset      = null;     evolve      = null;     detail      = null;          randoms     = [];     offsets     = [];                    constructor(nodeId, options)     {         super(l1106, nodeId, options);     }                    reset()     {         super.reset();                  this.seed          = null;         this.iteration     = null;         this.min           = null;         this.max           = null;         this.scale         = null;         this.interpolate   = null;         this.offset        = null;         this.evolve        = null;         this.detail        = null;     }        copy()     {         const copy = new i1935(this.nodeId, this.options);          copy.t3455(this);          if (this.seed       ) copy.seed        = this.seed       .copy();         if (this.iteration  ) copy.iteration   = this.iteration  .copy();         if (this.min        ) copy.min         = this.min        .copy();         if (this.max        ) copy.max         = this.max        .copy();         if (this.scale      ) copy.scale       = this.scale      .copy();         if (this.offset     ) copy.offset      = this.offset     .copy();         if (this.evolve     ) copy.evolve      = this.evolve     .copy();         if (this.interpolate) copy.interpolate = this.interpolate.copy();         if (this.detail     ) copy.detail      = this.detail     .copy();          if (this.randoms    ) copy.randoms     = this.randoms.map(r => r.copy());         if (this.offsets    ) copy.offsets     = this.offsets.slice();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const seed        = await evalNumberValue(this.seed,        parse);         const iteration   = await evalNumberValue(this.iteration,   parse);         const min         = await evalNumberValue(this.min,         parse);         const max         = await evalNumberValue(this.max,         parse);         const scale       = await evalNumberValue(this.scale,       parse);         const offset      = await evalNumberValue(this.offset,      parse);         const evolve      = await evalNumberValue(this.evolve,      parse);         const interpolate = await evalNumberValue(this.interpolate, parse);         const detail      = await evalNumberValue(this.detail,      parse);               if (   this.options.enabled             && seed             && iteration             && min             && max             && scale             && offset             && evolve             && interpolate             && detail)         {             const _detail = Math.max(1, Math.ceil(detail.value));               if (  !this.randoms                 || this.randoms.length < _detail)             {                 const randoms = new Array(_detail);                  for (let c = 0; c < this.randoms.length; c++)                     randoms[c] = this.randoms[c];                                   let _seed = seed.value;                  for (let c = this.randoms.length; c < _detail; c++)                 {                     randoms[c] = new y375(_seed);                     _seed = seed.value;                 }                   this.randoms = randoms;                   this.updateOffsets(this.randoms[0].width * _detail);             }               let   size  = 1;             let   power = 1;                          const avg   = (min.value + max.value) / 2;             let   r;                           if (iteration.isValid())                 this.currentIteration = Math.round(iteration.value);                               if (   this.options.enabled                 && scale  && scale .isValid()                 && offset && offset.isValid()                 && evolve && evolve.isValid())             {                 scale.decimals = Math.min(scale.decimals, 4);                                  r = avg;                                  if (this.currentIteration >= 0)                 {                     for (let c = 0; c < _detail; c++)                     {                         const i  = Math.max(0, this.currentIteration / (Math.max(0.000001, scale.value) * size) + offset.value);                         const i0 = Math.floor(i);                         const i1 = Math.ceil (i);                                                   this.updateOffsets((i1 + 1) * _detail);                          const o0 = this.offsets[i0];                         const o1 = this.offsets[i1];                         let   _o;                          switch (interpolate.value)                         {                             case 0: _o = o0;                                                 break;                             case 1: _o = q1033(o0, o1, i-i0);                                 break;                             case 2: _o = (o0 + (o1 - o0) * (-Math.cos((i-i0)*Tau/2) + 1)/2); break;                         }                                                   const j   = evolve.value + _o;                         const j0  = Math.floor(j);                         const j1  = Math.ceil (j);                           const r00 = this.randoms[c].get(i0, j0);                         const r10 = this.randoms[c].get(i1, j0);                         const r01 = this.randoms[c].get(i0, j1);                         const r11 = this.randoms[c].get(i1, j1);                                       let _r, _r0, _r1;                                                  switch (interpolate.value)                         {                             case 0:                                  _r = r00;                                 break;                              case 1:                                  _r0 = q1033(r00, r10, i-i0);                                 _r1 = q1033(r01, r11, i-i0);                                 _r  = q1033(_r0, _r1, j-j0);                                 break;                              case 2:                                  _r0 = (r00 + (r10 - r00) * (-Math.cos((i-i0)*Tau/2) + 1)/2);                                  _r1 = (r01 + (r11 - r01) * (-Math.cos((i-i0)*Tau/2) + 1)/2);                                  _r  = (_r0 + (_r1 - _r0) * (-Math.cos((j-j0)*Tau/2) + 1)/2);                                  break;                         }                           const clamp =                              detail.value - c < 1                              ? detail.value - c                              : 1;                          r +=                              - power *      (avg       - min.value) * clamp                             + power * _r * (max.value - min.value) * clamp;                                                   size  /= 2;                         power /= 2;                                                   this.updateOffsets(this.randoms[0].width * _detail);                     }                 }             }             else             {                 r = min.value;             }               this.value = new k2022(r, Math.max(min.decimals, max.decimals));         }         else         {             this.value = k2022.NaN();         }           this.c4193(parse,         [             ['seed',        seed       ],             ['iteration',   iteration  ],             ['min',         min        ],             ['max',         max        ],             ['scale',       scale      ],             ['offset',      offset     ],             ['evolve',      evolve     ],             ['interpolate', interpolate],             ['detail',      detail     ]         ]);                   this.validate();          return this;     }        updateOffsets(newSize)     {         if (newSize < this.offsets.length)              return;          this.offsets = new Array(newSize);         const offsetRandom = new Random(0);          for (let o = 0; o < newSize; o++)             this.offsets[o] = offsetRandom.get(o);     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return this.seed        && this.seed       .isValid()             && this.iteration   && this.iteration  .isValid()             && this.min         && this.min        .isValid()             && this.max         && this.max        .isValid()             && this.scale       && this.scale      .isValid()             && this.offset      && this.offset     .isValid()             && this.evolve      && this.evolve     .isValid()             && this.interpolate && this.interpolate.isValid()             && this.detail      && this.detail     .isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.seed       ) this.seed       .p4180(parse);         if (this.iteration  ) this.iteration  .p4180(parse);         if (this.min        ) this.min        .p4180(parse);         if (this.max        ) this.max        .p4180(parse);         if (this.scale      ) this.scale      .p4180(parse);         if (this.offset     ) this.offset     .p4180(parse);         if (this.evolve     ) this.evolve     .p4180(parse);         if (this.interpolate) this.interpolate.p4180(parse);         if (this.detail     ) this.detail     .p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.seed       ) this.seed       .i4181(parse, from, force);         if (this.iteration  ) this.iteration  .i4181(parse, from, force);         if (this.min        ) this.min        .i4181(parse, from, force);         if (this.max        ) this.max        .i4181(parse, from, force);         if (this.scale      ) this.scale      .i4181(parse, from, force);         if (this.offset     ) this.offset     .i4181(parse, from, force);         if (this.evolve     ) this.evolve     .i4181(parse, from, force);         if (this.interpolate) this.interpolate.i4181(parse, from, force);         if (this.detail     ) this.detail     .i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.seed       ) this.seed       .i4179(parse);         if (this.iteration  ) this.iteration  .i4179(parse);         if (this.min        ) this.min        .i4179(parse);         if (this.max        ) this.max        .i4179(parse);         if (this.scale      ) this.scale      .i4179(parse);         if (this.offset     ) this.offset     .i4179(parse);         if (this.evolve     ) this.evolve     .i4179(parse);         if (this.interpolate) this.interpolate.i4179(parse);         if (this.detail     ) this.detail     .i4179(parse);     } } 


class y1938 extends s2045 {     seed      = null;     iteration = null;     chance    = null;     alternate = null;      random    = null;        constructor(nodeId, options)     {         super(b1107, nodeId, options);     }            reset()     {         super.reset();          this.seed      = null;         this.iteration = null;         this.chance    = null;         this.alternate = null;     }        copy()     {         const copy = new y1939(this.nodeId, this.options);          copy.t3455(this);          if (this.seed     ) copy.seed      = this.seed     .copy();         if (this.iteration) copy.iteration = this.iteration.copy();         if (this.chance   ) copy.chance    = this.chance   .copy();         if (this.alternate) copy.alternate = this.alternate.copy();          if (this.random) copy.random = this.random.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const o4175    = await evalValue      (this.o4175,    parse);         const i4176    = await evalValue      (this.i4176,    parse);         const seed      = await evalNumberValue(this.seed,      parse);         const iteration = await evalNumberValue(this.iteration, parse);         const chance    = await evalNumberValue(this.chance,    parse);         const alternate = await evalNumberValue(this.alternate, parse);               const _values = [];           if (   seed             && iteration             && chance             && alternate)         {             if (  !this.random                 || this.random.seed != seed.value)                 this.random = new Random(seed.value);               if (iteration.isValid())                 this.currentIteration = Math.round(iteration.value);               if (this.currentIteration >= 0)             {                 const calt  = this.currentIteration % 2 == 0 ? 0 : 1;                  let   cval  = chance.value/100;                       cval += alternate.value/100 * (calt - cval);                  const ch    = this.random.get(this.currentIteration) > cval ? 0 : 1;                                   if (   o4175                      && i4176)                 {                     if (   o4175.isValid()                         && i4176.isValid())                     {                         this.value =                              ch < 0.5                                  ? o4175                                  : i4176;                     }                     else                     {                         this.value =                              ch < 0.5                                  ? nanFromType(o4175.type)                                  : nanFromType(i4176.type);                     }                      _values.push(o4175, i4176);                 }                  else if (o4175)                 {                     this.value =                             o4175.isValid()                         && ch >= 0.5                             ? o4175                             : nanFromType(o4175.type);                      _values.push(o4175);                 }                                  else if (i4176)                 {                     this.value =                             i4176.isValid()                         && ch < 0.5                             ? i4176                             : nanFromType(i4176.type);                      _values.push(i4176);                 }                                  else                     this.value = new k2022(ch < 0.5 ? 0 : 1);             }             else                 this.value = new s4309();         }         else             this.value = new s4309();           const type =                _values.length > 1             && h3575(_values) == q1054             ? new f2033(n1086)             : this.outputType();           this.c4193(parse,         [             ['type',      type     ],             ['seed',      seed     ],             ['iteration', iteration],             ['chance',    chance   ],             ['alternate', alternate]         ]);                   this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return this.seed      && this.seed     .isValid()             && this.iteration && this.iteration.isValid()             && this.chance    && this.chance   .isValid()             && this.alternate && this.alternate.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.seed     ) this.seed     .p4180(parse);         if (this.iteration) this.iteration.p4180(parse);         if (this.chance   ) this.chance   .p4180(parse);         if (this.alternate) this.alternate.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.seed     ) this.seed     .i4181(parse, from, force);         if (this.iteration) this.iteration.i4181(parse, from, force);         if (this.chance   ) this.chance   .i4181(parse, from, force);         if (this.alternate) this.alternate.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.seed     ) this.seed     .i4179(parse);         if (this.iteration) this.iteration.i4179(parse);         if (this.chance   ) this.chance   .i4179(parse);         if (this.alternate) this.alternate.i4179(parse);     } } 


class a1925 extends l2044 {     current;     when;        constructor(nodeId, options)     {         super(x1108, nodeId, options);          this.current = new k2022(0);     }            reset()     {         super.reset();          this.current = null;         this.when    = null;     }        copy()     {         const copy = new a1925(this.nodeId, this.options);          copy.t3455(this);          if (this.when   ) copy.when    = this.when   .copy();         if (this.current) copy.current = this.current.copy();          return copy;     }        async eval(parse)     {         if (    this.isCached()             || !parse.evalAccumulate)             return this;           const input = await evalNumberValue(this.input, parse);         const when  = await evalNumberValue(this.when,  parse);                       if (   input             && when)         {             if (when.value == 0)                 this.value = this.current.copy();              if (input)             {                 this.current.value   += input.value;                 this.current.decimals = Math.max(this.current.decimals, input.decimals);             }              if (when.value > 0)                 this.value = this.current.copy();         }         else             this.value = k2022.NaN();           this.c4193(parse,          [             ['when', when]         ]);                   this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.when && this.when.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.when) this.when.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.when) this.when.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.when) this.when.i4179(parse);     }        s3727(parse, nodeId)     {         super.s3727(parse, nodeId);          this.current = new k2022(0);     } } 


class GHold extends l2044 {     current;     first;        constructor(nodeId, options)     {         super(HOLD, nodeId, options);          this.current = null;     }            reset()     {         super.reset();          this.current = null;         this.first   = null;     }        copy()     {         const copy = new GHold(this.nodeId, this.options);          copy.t3455(this);          if (this.first  ) copy.first   = this.first  .copy();         if (this.current) copy.current = this.current.copy();          return copy;     }        async eval(parse)     {         if (    this.isCached()             || !parse.evalAccumulate)             return this;           const input = await evalValue(this.input, parse);         const first = await evalValue(this.first, parse);                       if (   input             && first)         {             if (this.options.enabled)             {                 this.value   = this.current ? this.current : first;                 this.current = input;             }             else                 this.value = input;         }         else             this.value = new s4309();           this.c4193(parse,          [             ['type', this.outputType()]         ]);                   this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.first && this.first.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.first) this.first.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.first) this.first.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.first) this.first.i4179(parse);     }        s3727(parse, nodeId)     {         super.s3727(parse, nodeId);          this.current = null;     } } 


class o1931 extends i2043 {     inputs = [];      amount;     degree;        constructor(nodeId, options)     {         super(s1109, nodeId, options);     }            reset()     {         super.reset();          this.inputs = [];          this.amount = null;         this.degree = null;     }        copy()     {         const copy = new o1931(this.nodeId, this.options);          copy.t3455(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.amount) copy.amount = this.amount.copy();         if (this.degree) copy.degree = this.degree.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const amount = await evalNumberValue(this.amount, parse);         const degree = await evalNumberValue(this.degree, parse);           const values = [];                  for (const u3907 of this.inputs)         {             const input = await evalNumberOrListValue(u3907, parse);              if (o955(input.type))             {                 for (const item of input.items)                 {                     const value = await evalNumberValue(item, parse);                     values.push(value);                 }             }             else             {                 const value = await evalNumberValue(input, parse);                 values.push(value);             }         }                           const maxDec = values.reduce((max, v) => Math.max(max, v.decimals), 0);          const deg =             degree.value < 3             ? Math.min(degree.value, 2) + 1             : 1;          const nSegments = Math.floor((values.length-1)/deg);         const index     = Math.min(Math.floor((values.length-1)/deg * amount.value/100), nSegments-1);           if (values.length == 1)             this.value = values[0];          else if (values.length > 1               && index < values.length - deg)             this.value = interpolateNumberValue(values, index, nSegments, deg, degree, amount, maxDec);          else                               this.value = k2022.NaN();           this.c4193(parse,         [             ['value',  this.value],             ['amount', amount    ],             ['degree', degree    ]         ]);                   this.validate();          return this;     }        isValid()     {         return  super.isValid()             &&  this.inputs.length > 0             && !this.inputs.find(i => !i.isValid())             &&  this.amount && this.amount.isValid()             &&  this.degree && this.degree.isValid();     }        p4180(parse)     {         super.p4180(parse);          this.inputs.forEach(i => i.p4180(parse));          if (this.amount) this.amount.p4180(parse);         if (this.degree) this.degree.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          this.inputs.forEach(i => i.i4181(parse, from, force));          if (this.amount) this.amount.i4181(parse, from, force);         if (this.degree) this.degree.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          this.inputs.forEach(i => i.i4179(parse));          if (this.amount) this.amount.i4179(parse);         if (this.degree) this.degree.i4179(parse);     } }    function interpolateNumberValue(values, index, nSegments, deg, degree, amount, maxDec) {     const localAmount =          nSegments > 1             ? (amount.value/100 - index/nSegments) * nSegments             :  amount.value/100;       if (degree.value == 0)      {         const y3785 = values[index*deg  ];         const val1 = values[index*deg+1];          return new k2022(             q1033(y3785.value, val1.value, localAmount),             maxDec);     }     else if (degree.value == 1)      {         const y3785 = values[index*deg  ];         const val1 = values[index*deg+1];         const val2 = values[index*deg+2];          return new k2022(             q1034(y3785.value, val1.value, val2.value, localAmount),             maxDec);     }     else if (degree.value == 2)      {         const y3785 = values[index*deg  ];         const val1 = values[index*deg+1];         const val2 = values[index*deg+2];         const val3 = values[index*deg+3];          return new k2022(             b1035(y3785.value, val1.value, val2.value, val3.value, localAmount),             maxDec);     }     else if (degree.value == 3)      {         const y3785 = values[index*deg  ];         const val1 = values[index*deg+1];          return new k2022(             lerpCos(y3785.value, val1.value, localAmount),             maxDec);     }     else         return k2022.NaN(); }


class e1945 extends l2044 {     current          = null;     target           = null;      currentConnected = false;      terminalIds      = [];            constructor(nodeId, options)     {         super(s1110, nodeId, options);     }            reset()     {         super.reset();          this.current          = null;         this.target           = null;          this.currentConnected = false;          this.terminalIds      = [];     }        copy()     {         const copy = new e1945(this.nodeId, this.options);          copy.t3455(this);          if (this.current) copy.current = this.current.copy();         if (this.target ) copy.target  = this.target .copy();          copy.terminalIds = [...this.terminalIds];          return copy;     }        isCached()     {         return super.isCached()             && this.current.isCached()             && this.target .isCached();     }        async eval(parse)     {         if (this.isCached())             return this;           let input   = await evalNumberValue(this.input,   parse);         let current = await evalNumberValue(this.current, parse);         let target  = await evalNumberValue(this.target,  parse);           if (   input             && this.input.type == PARAM             && target.isValid())         {             c950(                  input.type == c1090,                  'input.type must be NUMBER_VALUE');               if (this.options.enabled)             {                 let   diff     = target.value - current.value;                 let   prevDiff = 0;                   let   u3907   = current.isValid() ? input.value : 0;                 let   step     = 10;                   let   iter     = 0;                 const maxIter  = parse.settings.maxSolveIterations;                                   b2077(this.nodeId);                   parse.f3735 += maxIter;                   const inParamValue = this.input.node[this.input.m3091];                   parse.solvers.push(this);                   while (iter++ < maxIter)                 {                     u3907 += step;                       if (inParamValue)                     {                         if (inParamValue.parent)                         {                             inParamValue.parent.updateValueFromParam(                                 this.input.m3091,                                  new k2022(                                     u3907,                                      input.decimals));                         }                         else                             inParamValue.value = u3907;                                                   this.input  .i4181(parse, this, true);                         this.current.i4181(parse, this, true);                          current = await evalNumberValue(this.current, parse);                           if (   current.isValid()                             && target.isValid())                         {                             diff = target.p3798() - current.value;                              if (Math.abs(diff) < 0.00001)                                 break;                              if (   Math.abs (diff) >  Math.abs (prevDiff)                                 || Math.sign(diff) != Math.sign(prevDiff))                                 step /= -2;                              prevDiff = diff;                         }                         else                         {                             diff = 0;                             u3907 -= step;                             step /= -2;                         }                     }                                           parse.f3734++;                     u2078(parse, this.nodeId, iter / maxIter);                 }                   parse.solvers.pop();                   this.current.i4181(parse, this, true);                 current = await evalNumberValue(this.current, parse);                   if (current && target)                     current.decimals = target.decimals;                   if (   iter < maxIter                     && Math.abs(diff) < 0.0000001)                     parse.f3734 += maxIter - iter;                                                     this.value = inParamValue                     ? new k2022(current.value, target.decimals)                     : k2022.NaN();             }             else                 this.value = k2022.NaN();         }         else             this.value = k2022.NaN();           if (!this.currentConnected)             current = k2022.NaN();           this.c4193(parse,         [             ['current', current],             ['target',  target ]         ]);           this.validate();           if (this.input)         {                          j947(parse.terminalIds, this.terminalIds);                      }           return this;     }        isValid()     {         return super.isValid()             && this.current && this.current.isValid()             && this.target  && this.target .isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.current) this.current.p4180(parse);         if (this.target ) this.target .p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.current) this.current.i4181(parse, from, force);         if (this.target ) this.target .i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.current) this.current.i4179(parse);         if (this.target ) this.target .i4179(parse);     } } 


class j1926 extends i2043 {     from   = null;     to     = null;     curve  = null;     repeat = null;     length = null;     time   = null;                    constructor(nodeId, options)     {         super(o1111, nodeId, options);     }                    reset()     {         super.reset();                  this.from   = null;         this.to     = null;         this.curve  = null;         this.repeat = null;         this.length = null;         this.time   = null;     }        copy()     {         const copy = new j1926(this.nodeId, this.options);          copy.t3455(this);          if (this.from  ) copy.from   = this.from  .copy();         if (this.to    ) copy.to     = this.to    .copy();         if (this.curve ) copy.curve  = this.curve .copy();         if (this.repeat) copy.repeat = this.repeat.copy();         if (this.length) copy.length = this.length.copy();         if (this.time  ) copy.time   = this.time  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const from   = await evalNumberValue(this.from,   parse);         const to     = await evalNumberValue(this.to,     parse);         const curve  = await evalNumberValue(this.curve,  parse);         const repeat = await evalNumberValue(this.repeat, parse);         const length = await evalNumberValue(this.length, parse);         const time   = await evalNumberValue(this.time,   parse);               const maxDec = Math.max(from.decimals, to.decimals);          switch (curve.value)         {             case 0:              {                 this.value = new k2022(                     time.value < length.value ? from.value : to.value,                      maxDec);                      break;             }             case 1:              {                 this.value = new k2022(                     from.value + (to.value - from.value) * time.value / length.value,                     maxDec);                  break;             }             case 2:              {                 let f = time.value / length.value;                  f = 1 - sqr(1 - f);                  this.value = new k2022(                     from.value + (to.value - from.value) * f,                     maxDec);                      break;             }             case 3:              {                 let f = time.value / length.value;                  f = sqr(f);                  this.value = new k2022(                     from.value + (to.value - from.value) * f,                     maxDec);                      break;             }             case 4:              {                 let f = time.value / length.value;                  f = 6*Math.pow(f, 5) - 15*Math.pow(f, 4) + 10*Math.pow(f, 3);                  this.value = new k2022(                     from.value + (to.value - from.value) * f,                     maxDec);                      break;             }         }                   this.c4193(parse,         [             ['from',   from  ],             ['to',     to    ],             ['curve',  curve ],             ['repeat', repeat],             ['length', length],             ['time',   time  ]         ]);                   this.validate();          return this;     }        isValid()     {         return this.from   && this.from  .isValid()             && this.to     && this.to    .isValid()             && this.curve  && this.curve .isValid()             && this.repeat && this.repeat.isValid()             && this.length && this.length.isValid()             && this.time   && this.time  .isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.from  ) this.from  .p4180(parse);         if (this.to    ) this.to    .p4180(parse);         if (this.curve ) this.curve .p4180(parse);         if (this.repeat) this.repeat.p4180(parse);         if (this.length) this.length.p4180(parse);         if (this.time  ) this.time  .p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.from  ) this.from  .i4181(parse, from, force);         if (this.to    ) this.to    .i4181(parse, from, force);         if (this.curve ) this.curve .i4181(parse, from, force);         if (this.repeat) this.repeat.i4181(parse, from, force);         if (this.length) this.length.i4181(parse, from, force);         if (this.time  ) this.time  .i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.from  ) this.from  .i4179(parse);         if (this.to    ) this.to    .i4179(parse);         if (this.curve ) this.curve .i4179(parse);         if (this.repeat) this.repeat.i4179(parse);         if (this.length) this.length.i4179(parse);         if (this.time  ) this.time  .i4179(parse);     } } 


class a1902 extends b1899 {     operation;        constructor(nodeId, options)     {         super(u1113, nodeId, options);     }       reset()     {         super.reset();          this.operation = null;     }            copy()     {         const copy = new a1902(this.nodeId, this.options);          copy.t3455(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.operation) copy.operation = this.operation.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const inputs = await Promise.all(this.inputs.map(async i => await evalNumberOrListValue(i, parse)));         let   op     = await evalNumberValue(this.operation, parse);           if (   op             && op.isValid())         {             op.value    = Math.min(Math.max(0, Math.round(op.value)), g1310.length-1);             op.decimals = 0;         }           this.value = await evalMathInputs(this, inputs, op, parse);               this.c4193(parse,         [             ['type',      this.outputType()],             ['operation', op               ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.operation && this.operation.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.operation) this.operation.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.operation) this.operation.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.operation) this.operation.i4179(parse);     } }    async function evalMathInputs(node, inputs, op, parse) {     if (isEmpty(inputs))         return k2022.NaN();       const allAreLists = allInputsAreCondensedLists(inputs);      if (allAreLists) return await evalMathListInputs(node, inputs, op, parse);     else             return await evalMathItemInputs(node, inputs, op, parse); }    async function evalMathListInputs(node, inputs, op, parse) {     const value = new w2021();           for (const input of inputs)     {         if (!input) continue;          console.assert(              o955(input.type),              `input is ${input.type}, must be a list`);          if (allInputsAreCondensedLists(input.items))             value.items.push(...(await evalMathListInputs(node, input.items, op, parse)).items);         else             value.items.push(await evalMathItemInputs(node, input.items, op, parse));     }       return value; }    async function evalMathItemInputs(node, inputs, op, parse) {     switch (op.value)     {         case 0: return await j3796  (node, inputs, parse);         case 1: return await j3795  (node, inputs, parse);         case 2: return await g3793(node, inputs, parse);         case 3: return await r3792     (node, inputs, parse);         case 4: return await m3794(node, inputs, parse);         case 5: return await n3797(node, inputs, parse);     } }    async function r3792(node, inputs, parse) {     if (isEmpty(inputs))         return k2022.NaN();       let value = new k2022(0);               const options = { maxDec: 0 };       for (let i = 0; i < inputs.length; i++)     {         const input = inputs[i];                  if (   !input             || !input.isValid())             return k2022.NaN();           if (o955(input.type))         {             if (   isEmpty(input.items)                 || input.items[0].type != c1090)                 return k2022.NaN();              for (const item of input.items)                 evalAddStep(value, item, options);         }         else             evalAddStep(value, input, options);           value          = new k2022(value.value);         value.decimals = Math.max(value.decimals, options.maxDec);     }       return value; }    function evalAddStep(value, input, options) {     if (   !input         || !input.isValid())     {          value = k2022.NaN();         return;     }               if (input.type == c1090)     {         value.value   += input.p3798();         options.maxDec = Math.max(options.maxDec, input.decimals);     }                     }    async function g3793(node, inputs, parse) {     if (isEmpty(inputs))         return k2022.NaN();       let value;       const options = { maxDec: 0 };       const o4175 = inputs[0];      if (   !o4175         || !o4175.isValid())         return k2022.NaN();       if (    o955(o4175.type)         && !isEmpty(o4175.items))     {         const i3784 = o4175.items[0];          if (   !i3784             || !i3784.isValid())             return k2022.NaN();           value  = new k2022(i3784.p3798());         maxDec = i3784.decimals;           for (let j = 1; j < o4175.items.length; j++)             evalSubtractStep(value, o4175.items[j], options);     }     else     {         if (o4175.type != c1090)             return k2022.NaN();          value          = new k2022(o4175.p3798());         options.maxDec = o4175.decimals;     }       for (let i = 1; i < inputs.length; i++)     {         const input = inputs[i];          if (   !input             || !input.isValid())             return k2022.NaN();           if (o955(input.type))         {             for (const item of input.items)                 evalSubtractStep(value, item, options);         }         else             evalSubtractStep(value, input, options);     }               value          = new k2022(value.value);     value.decimals = Math.max(value.decimals, options.maxDec);       return value; }    function evalSubtractStep(value, input, options) {     if (   !input         || !input.isValid())     {          value = k2022.NaN();         return;     }               if (input.type == c1090)     {         value.value   -= input.p3798();         options.maxDec = Math.max(options.maxDec, input.decimals);     }                     }    async function m3794(node, inputs, parse) {     if (isEmpty(inputs))         return k2022.NaN();       let value = new k2022(1);       const options = { maxDec: 0 };       for (let i = 0; i < inputs.length; i++)     {         const input = inputs[i];          if (   !input             || !input.isValid())             return k2022.NaN();           if (o955(input.type))         {             if (   isEmpty(input.items)                 || input.items[0].type != c1090)                 return k2022.NaN();              for (const item of input.items)                 evalMultiplyStep(value, item, options);         }         else             evalMultiplyStep(value, input, options);     }       value          = new k2022(value.value);     value.decimals = Math.max(value.decimals, options.maxDec);       return value; }    function evalMultiplyStep(value, input, options) {     if (   !input         || !input.isValid())     {          value = k2022.NaN();         return;     }               if (input.type == c1090)     {         value.value   *= input.p3798();         options.maxDec = Math.max(options.maxDec, input.decimals);     }                     }    async function j3795(node, inputs, parse) {     if (isEmpty(inputs))         return k2022.NaN();               let   value;           const o4175 = inputs[0];      if (   !o4175         || !o4175.isValid())         return k2022.NaN();       const options = { maxDec: 0 };       if (o955(o4175.type))     {         if (!isEmpty(o4175.items))          {             const i3784 = o4175.items[0];              if (   !i3784                 || !i3784.isValid())                 return k2022.NaN();               value          = new k2022(i3784.p3798());             options.maxDec = i3784.decimals;               for (let j = 1; j < o4175.items.length; j++)                 evalDivideStep(value, o4175.items[j], options);         }     }     else     {         if (o4175.type != c1090)             return k2022.NaN();          value          = new k2022(o4175.p3798());         options.maxDec = o4175.decimals;     }           for (let i = 1; i < inputs.length; i++)     {         const input = inputs[i];          if (o955(input.type))         {             for (const item of input.items)                 evalDivideStep(value, item, options);         }         else             evalDivideStep(value, input, options);     }       value          = new k2022(value.value);     value.decimals = Math.max(value.decimals, options.maxDec);       return value; }    function evalDivideStep(value, input, options) {     if (   !input         || !input.isValid())     {          value = k2022.NaN();         return;     }               if (input.type == c1090)     {         if (input.value == 0)          {              value = k2022.NaN();             return;         }          value.value   /= input.p3798();         options.maxDec = Math.max(options.maxDec, input.decimals);     }                     }    async function j3796(node, inputs, parse) {     if (isEmpty(inputs))         return k2022.NaN();               let value;               const o4175 = inputs[0];      if (   !o4175         || !o4175.isValid())         return k2022.NaN();       const options = { maxDec: 0 };       if (    o955(o4175.type)         && !isEmpty(o4175.items))     {         const i3784 = o4175.items[0];          if (   !i3784             || !i3784.isValid())             return k2022.NaN();           value          = new k2022(i3784.p3798());         options.maxDec = i3784.decimals;                   for (let i = 1; i < o4175.items.length; i++)             evalModuloStep(value, o4175.items[i], options);     }     else     {         if (o4175.type != c1090)             return k2022.NaN();          value          = new k2022(o4175.p3798());         options.maxDec = o4175.decimals;     }       for (let i = 1; i < inputs.length; i++)     {         const input = inputs[i];          if (   !input             || !input.isValid())             return k2022.NaN();           if (o955(input.type))         {             for (const item of input.items)                 evalModuloStep(value, item, options);         }         else             evalModuloStep(value, input, options);     }       value          = new k2022(value.value);     value.decimals = Math.max(value.decimals, options.maxDec);       return value; }    function evalModuloStep(value, input, options) {     if (   !input         || !input.isValid())     {          value.value    = Number.NaN;          value.decimals = 0;         return;     }               if (input.type == c1090)     {         if (input.value == 0)          {              value = k2022.NaN();             return;         }          options.maxDec = Math.max(options.maxDec, input.decimals);         value.value    = g1013(value.p3798() % input.p3798(), options.maxDec);     }                     }    async function n3797(node, inputs, parse) {     if (isEmpty(inputs))         return k2022.NaN();       let value;       const o4175 = inputs[0];      if (   !o4175         || !o4175.isValid())         return k2022.NaN();       const options = { maxDec: 0 };       if (    o955(o4175.type)         && !isEmpty(o4175.items))     {         const i3784 = o4175.items[0];          if (   !i3784             || !i3784.isValid())             return k2022.NaN();           value          = new k2022(i3784.p3798());         options.maxDec = i3784.decimals;                   for (let i = 1; i < o4175.items.length; i++)             evalExponentStep(value, o4175.items[i], options);     }     else     {         if (o4175.type != c1090)             return k2022.NaN();          value          = new k2022(o4175.p3798());         options.maxDec = o4175.decimals;     }       for (let i = 1; i < inputs.length; i++)     {         const input = inputs[i];          if (   !input             || !input.isValid())             return k2022.NaN();           if (o955(input.type))         {             for (const item of input.items)                 evalExponentStep(value, item, options);         }         else             evalExponentStep(value, input, options);     }       value          = new k2022(value.value);     value.decimals = Math.max(value.decimals, options.maxDec);       return value; }    function evalExponentStep(value, input, options) {     if (   !input         || !input.isValid())     {          value = k2022.NaN();         return;     }               if (input.type == c1090)     {         value.value    = Math.pow(value.p3798(), input.p3798());         options.maxDec = Math.max(options.maxDec, input.decimals);     }                     }


class s1905 extends l2044 {     operation;     operand;     invert;        constructor(nodeId, options)     {         super(h1112, nodeId, options);     }            reset()     {         super.reset();          this.operation = null;         this.operand   = null;         this.invert    = null;     }        copy()     {         const copy = new s1905(this.nodeId, this.options);          copy.t3455(this);          if (this.operation) copy.operation = this.operation.copy();         if (this.operand  ) copy.operand   = this.operand  .copy();         if (this.invert   ) copy.invert    = this.invert   .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input   = await evalNumberOrListValue(this.input,     parse);         const op      = await evalNumberValue      (this.operation, parse);         const operand = await evalNumberValue      (this.operand,   parse);         const invert  = await evalNumberValue      (this.invert,    parse);           if (   op             && op.isValid())         {             op.value    = Math.min(Math.max(0, Math.round(op.value)), g1310.length-1);             op.decimals = 0;         }           if (   input             && op)         {             if (this.options.enabled)             {                 if (o955(input.type))                 {                     this.value = new w2021();                      for (let i = 0; i < input.items.length; i++)                     {                         const item = input.items[i];                          this.value.items.push(                             item.type == c1090                             ? q3791(item, operand, op, invert, this.options.enabled)                             : k2022.NaN());                        }                 }                 else                 {                     this.value = q3791(input, operand, op, invert, this.options.enabled);                 }             }             else                 this.value = input.copy();         }         else             this.value = k2022.NaN();           this.c4193(parse,         [             ['type',      this.outputType()],             ['operation', op               ],             ['operand',   operand          ],             ['invert',    invert           ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.operation && this.operation.isValid()             && this.operand   && this.operand  .isValid()             && this.invert    && this.invert   .isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.operation) this.operation.p4180(parse);         if (this.operand  ) this.operand  .p4180(parse);         if (this.invert   ) this.invert   .p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.operation) this.operation.i4181(parse, from, force);         if (this.operand  ) this.operand  .i4181(parse, from, force);         if (this.invert   ) this.invert   .i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.operation) this.operation.i4179(parse);         if (this.operand  ) this.operand  .i4179(parse);         if (this.invert   ) this.invert   .i4179(parse);     } }    function q3791(input, operand, op, invert, enabled) {     c950(         input.type == c1090,          'input.type is ' + input.type + ', must be NUMBER_VALUE');       if (enabled)     {         op.value = Math.min(Math.max(0, Math.floor(op.value)), g1310.length-1);           const z3790 = Math.max(input.decimals, operand.decimals);          let value;                   switch (op.value)         {             case 0:                  value = new k2022(                     invert.value == 0                         ? input.p3798() % operand.p3798()                         : operand.p3798() % input.p3798());                 break;              case 1:                  if (      operand.value == 0                        && invert .value == 0                     ||    input  .value == 0                        && invert .value == 1)                     value = k2022.NaN();                 else                     value = new k2022(                         invert.value == 0                             ? input.p3798() / operand.p3798()                             : operand.p3798() / input.p3798());                 break;              case 2:                  value = new k2022(                     invert.value == 0                         ? input.p3798() - operand.p3798()                         : operand.p3798() - input.p3798());                 break;              case 3:                  value = new k2022(                     invert.value == 0                         ? input.p3798() + operand.p3798()                         : operand.p3798() + input.p3798());                 break;              case 4:                  value = new k2022(                     invert.value == 0                         ? input.p3798() * operand.p3798()                         : operand.p3798() * input.p3798());                 break;              case 5:                  value = new k2022(                     invert.value == 0                         ? Math.pow(input.p3798(), operand.p3798())                         : Math.pow(operand.p3798(), input.p3798()));                 break;              default:                 h951('invalid math operation');         }           value.decimals = Math.max(value.decimals, z3790);          return value;     }     else         return input; }


class m1908 extends b1899 {     operation;        constructor(nodeId, options)     {         super(e1120, nodeId, options);     }        reset()     {         super.reset();          this.operation = null;     }           copy()     {         const copy = new m1908(this.nodeId, this.options);          copy.t3455(this);          copy.inputs    = this.inputs.map(i => i.copy());          if (this.operation) copy.operation = this.operation.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           let op = await evalNumberValue(this.operation, parse);          if (op) op = op.v3824();           op.value     =          op.g3884 = Math.min(Math.max(0, op.value), n1316.length-1);                   switch (op.value)         {             case l1312: this.value = await l3789(this.inputs, parse); break;             case j1313: this.value = await t3786 (this.inputs, parse); break;             case c1314:  this.value = await z3787  (this.inputs, parse); break;             case s1315: this.value = await s3788 (this.inputs, parse); break;         }                   this.c4193(parse,         [             ['operation', op]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.operation && this.operation.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.operation) this.operation.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.operation) this.operation.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.operation) this.operation.i4179(parse);     } }


class o1909 extends b1899 {     constructor(nodeId, options)     {         super(t1121, nodeId, options);     }            copy()     {         const copy = new o1909(this.nodeId, this.options);         copy.t3455(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await l3789(this.inputs, parse);                   this.c4193(parse,          [             ['', new s4309()]                      ]);           this.validate();          return this;     } }    async function l3789(inputs, parse) {     if (isEmpty(inputs))         return k2022.NaN();       const value = new k2022();       if (!isEmpty(inputs))     {         const y3785 = await evalNumberOrListValue(inputs[0], parse);         if (!y3785.isValid()) return k2022.NaN();          if (    o955(y3785.type)             && !isEmpty(y3785.items))         {             const i3784 = y3785.items[0];              value.value = i3784.p3798() != 0 ? 0 : 1;              for (let i = 1; i < y3785.items.length; i++)             {                 const item = y3785.items[i];                                  if (   item.type == c1090                     && item.p3798() == 0)                     value.value = 1;             }         }         else         {             if (y3785.type != c1090)                 return k2022.NaN();              value.value = y3785.p3798() != 0 ? 0 : 1;         }           for (let i = 1; i < inputs.length; i++)         {             const val = await evalNumberOrListValue(inputs[i], parse);             if (!val.isValid()) return k2022.NaN();              if (o955(val.type))             {                 for (const item of val.items)                 {                     if (   item.type == c1090                         && item.p3798() == 0)                         value.value = 1;                 }             }             else             {                 c950(                     val.type == c1090,                      'val.type must be NUMBER_VALUE');                  if (val.p3798() == 0)                     value.value = 1;             }         }     }       return value; } 


class a1907 extends b1899 {     constructor(nodeId, options)     {         super(l1122, nodeId, options);     }            copy()     {         const copy = new a1907(this.nodeId, this.options);         copy.t3455(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await s3788(this.inputs, parse);                   this.c4193(parse,          [             ['', new s4309()]                      ]);                   this.validate();          return this;     } }    async function s3788(inputs, parse) {     if (isEmpty(inputs))         return k2022.NaN();       const value = new k2022();       if (!isEmpty(inputs))     {         const y3785 = await evalNumberOrListValue(inputs[0], parse);         if (!y3785.isValid()) return k2022.NaN();           if (    o955(y3785.type)             && !isEmpty(y3785.items))         {             const i3784 = y3785.items[0];              value.value = i3784.p3798();              for (let i = 1; i < y3785.items.length; i++)             {                 const item = y3785.items[i];                                  if (item.type == c1090)                     value.value = Math.min(value.value, item.p3798());             }         }         else         {             if (y3785.type != c1090)                 return k2022.NaN();              value.value = y3785.p3798();         }           for (let i = 1; i < inputs.length; i++)         {             const val = await evalNumberOrListValue(inputs[i], parse);             if (!val.isValid()) return k2022.NaN();               if (o955(val.type))             {                 for (const item of val.items)                 {                     if (item.type == c1090)                         value.value = Math.min(value.value, item.p3798());                 }             }             else             {                 c950(                     val.type == c1090,                      'val.type must be NUMBER_VALUE');                  value.value = Math.min(value.value, val.p3798());             }         }                   if (value.value != 0)             value.value = 1;     }       return value; }


class f1910 extends b1899 {     constructor(nodeId, options)     {         super(b1123, nodeId, options);     }            copy()     {         const copy = new f1910(this.nodeId, this.options);          copy.t3455(this);          copy.inputs = this.inputs.map(i => i.copy());          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await z3787(this.inputs, parse);                   this.c4193(parse,          [             ['', new s4309()]                      ]);           this.validate();          return this;     } }    async function z3787(inputs, parse) {     if (isEmpty(inputs))         return k2022.NaN();       const value = new k2022();       if (!isEmpty(inputs))     {         const y3785 = await evalNumberOrListValue(inputs[0], parse);         if (!y3785.isValid()) return k2022.NaN();          if (    o955(y3785.type)             && !isEmpty(y3785.items))         {             const i3784 = y3785.items[0];              value.value = i3784.p3798();              for (let i = 1; i < y3785.items.length; i++)             {                 const item = y3785.items[i];                                  if (item.type == c1090)                     value.value = Math.max(value.value, item.p3798());             }         }         else         {             if (y3785.type != c1090)                 return k2022.NaN();              value.value = y3785.p3798();         }           for (let i = 1; i < inputs.length; i++)         {             const val = await evalNumberOrListValue(inputs[i], parse);             if (!val.isValid()) return k2022.NaN();              if (o955(val.type))             {                 for (const item of val.items)                 {                     if (item.type == c1090)                         value.value = Math.max(value.value, item.p3798());                 }             }             else             {                 c950(                     val.type == c1090,                      'val.type must be NUMBER_VALUE');                                      value.value = Math.max(value.value, val.p3798());             }         }           if (value.value != 0)             value.value = 1;     }       return value; }


class b1911 extends b1899 {     constructor(nodeId, options)     {         super(y1124, nodeId, options);     }            copy()     {         const copy = new b1911(this.nodeId, this.options);         copy.t3455(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await t3786(this.inputs, parse);                   this.c4193(parse,          [             ['', new s4309()]                      ]);           this.validate();          return this;     } }    async function t3786(inputs, parse) {     if (isEmpty(inputs))         return k2022.NaN();       const value = new k2022(0);       let flipped;      if (!isEmpty(inputs))     {         const y3785 = await evalNumberOrListValue(inputs[0], parse);         if (!y3785.isValid()) return k2022.NaN();          if (    o955(y3785.type)             && !isEmpty(y3785.items))         {             const i3784 = y3785.items[0];              flipped = i3784.p3798() != 0;              for (let i = 1; i < y3785.items.length; i++)             {                 const item = y3785.items[i];                                  if (   item.type == c1090                     && item.p3798() != 0)                     flipped++;             }         }         else         {             if (y3785.type != c1090)                 return k2022.NaN();              flipped = y3785.p3798() != 0;         }           for (let i = 1; i < inputs.length; i++)         {             const val = await evalNumberOrListValue(inputs[i], parse);             if (!val.isValid()) return k2022.NaN();              if (o955(val.type))             {                 for (const item of val.items)                 {                     if (   item.type == c1090                         && item.p3798() != 0)                         flipped++;                     }             }             else             {                 c950(                     val.type == c1090,                      'val.type must be NUMBER_VALUE');                                      if (val.p3798() != 0)                     flipped++;             }         }           value.value = flipped == 1 ? 1 : 0;     }       return value; }


class b1912 extends l2044 {     operation;     operand;        constructor(nodeId, options)     {         super(h1125, nodeId, options);     }            reset()     {         super.reset();          this.operation = null;         this.operand   = null;     }        copy()     {         const copy = new b1912(this.nodeId, this.options);          copy.t3455(this);          if (this.operation) copy.operation = this.operation.copy();         if (this.operand  ) copy.operand   = this.operand  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input   = await evalNumberOrListValue(this.input,     parse);         const op      = await evalNumberValue      (this.operation, parse);         const operand = await evalNumberValue      (this.operand,   parse);                   if (   input             && operand             && op)         {             op.value = Math.min(Math.max(0, op.value), s1323.length-1);              if (o955(input.type))             {                 this.value = new w2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == c1090                         ? await getCompareValue(item, operand, op)                         : k2022.NaN());                 }             }             else             {                 this.value = await getCompareValue(input, operand, op);             }         }         else             this.value = k2022.NaN();           this.c4193(parse,         [             ['type',      this.outputType()],             ['operation', op               ],             ['operand',   operand          ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.operation && this.operation.isValid()             && this.operand   && this.operand  .isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.operation) this.operation.p4180(parse);         if (this.operand  ) this.operand  .p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.operation) this.operation.i4181(parse, from, force);         if (this.operand  ) this.operand  .i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.operation) this.operation.i4179(parse);         if (this.operand  ) this.operand  .i4179(parse);     } }    async function getCompareValue(input, operand, op) {     switch (op.value)     {         case n1317:              return await evalCompareNumberInputs(input, operand, ((a, b) => a <  b));         case k1318:     return await evalCompareNumberInputs(input, operand, ((a, b) => a <= b));         case g1319:         return await evalCompareNumberInputs(input, operand, ((a, b) => a != b));         case v1320:             return await evalCompareNumberInputs(input, operand, ((a, b) => a == b));         case w1321:  return await evalCompareNumberInputs(input, operand, ((a, b) => a >= b));         case f1322:           return await evalCompareNumberInputs(input, operand, ((a, b) => a >  b));     } }    async function evalCompareNumberInputs(input, operand, compare)  {     if (   input   && input  .isValid()          && operand && operand.isValid())     {         return new k2022(             compare(input.p3798(), operand.p3798()) ? 1 : 0,             0,             true);     }     else     {         return k2022.NaN();     } }


class x1913 extends s2045 {     constructor(nodeId, options)     {         super(j1126, nodeId, options);     }            copy()     {         const copy = new x1913(this.nodeId, this.options);         copy.t3455(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await s3783(             this.o4175,              this.i4176,              (a, b) => a == b,              parse);                       this.c4193(parse,          [             ['', new s4309()]                      ]);           this.validate();          return this;     } } 


class e1918 extends s2045 {     constructor(nodeId, options)     {         super(h1127, nodeId, options);     }            copy()     {         const copy = new e1918(this.nodeId, this.options);         copy.t3455(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await s3783(             this.o4175,              this.i4176,              (a, b) => a != b,              parse);                   this.c4193(parse,          [             ['', new s4309()]                      ]);           this.validate();          return this;     } }


class n1916 extends s2045 {     constructor(nodeId, options)     {         super(z1128, nodeId, options);     }            copy()     {         const copy = new n1916(this.nodeId, this.options);         copy.t3455(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await s3783(             this.o4175,              this.i4176,              (a, b) => a < b,              parse);                       this.c4193(parse,          [             ['', new s4309()]                      ]);           this.validate();          return this;     } }


class f1917 extends s2045 {     constructor(nodeId, options)     {         super(g1129, nodeId, options);     }            copy()     {         const copy = new f1917(this.nodeId, this.options);         copy.t3455(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await s3783(             this.o4175,              this.i4176,              (a, b) => a <= b,              parse);                       this.c4193(parse,          [             ['', new s4309()]                      ]);           this.validate();          return this;     } } 


class z1914 extends s2045 {     constructor(nodeId, options)     {         super(k1130, nodeId, options);     }            copy()     {         const copy = new z1914(this.nodeId, this.options);         copy.t3455(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await s3783(             this.o4175,              this.i4176,              (a, b) => a > b,              parse);                   this.c4193(parse,          [             ['', new s4309()]                      ]);           this.validate();          return this;     } }


class s1915 extends s2045 {     constructor(nodeId, options)     {         super(a1131, nodeId, options);     }            copy()     {         const copy = new s1915(this.nodeId, this.options);          copy.t3455(this);          copy.inputs = this.inputs.map(i => i.copy());          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await s3783(             this.o4175,              this.i4176,              (a, b) => a >= b,              parse);                       this.c4193(parse,          [             ['', new s4309()]                      ]);           this.validate();          return this;     } } 


class x1923 extends l2044 {     function;        constructor(nodeId, options)     {         super(o1132, nodeId, options);     }            reset()     {         super.reset();          this.function = null;     }        copy()     {         const copy = new x1923(this.nodeId, this.options);          copy.t3455(this);          if (this.function) copy.function = this.function.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalNumberOrListValue(this.input,    parse);         const func  = await evalNumberValue      (this.function, parse);          func.value = Math.min(Math.max(0, func.value), w1330.length-1);                   if (input)         {             if (o955(input.type))             {                 this.value = new w2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == c1090                         ? await getTrigValue(item, func, this.options.enabled)                         : k2022.NaN());                    }             }             else                 this.value = await getTrigValue(input, func, this.options.enabled); }         else             this.value = k2022.NaN();           this.c4193(parse,         [             ['type',     this.outputType()],             ['function', func             ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.function && this.function.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.function) this.function.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.function) this.function.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.function) this.function.i4179(parse);     } }    async function getTrigValue(input, func, enabled) {     c950(         input.type == c1090,         'input.type must be NUMBER_VALUE');       if (!enabled)         return input;       switch (func.value)     {         case o1324:  return await g4328   (input, false);         case g1325:  return await i4329 (input, false);         case p1326:  return await n4330(input, false);         case v1327: return await g4328   (input, true );         case a1328: return await i4329 (input, true );         case y1329: return await n4330(input, true );     } }


class k1921 extends l2044 {     constructor(nodeId, options)     {         super(x1133, nodeId, options);     }            copy()     {         const copy = new k1921(this.nodeId, this.options);                  copy.t3455(this);          if (this.input) copy.input = this.input.copy();                  return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await g4328(this.input, parse);           this.c4193(parse,          [             ['', new s4309()]                      ]);           this.validate();          return this;     }        toNewValue()     {         return this.value.copy();     } }    async function g4328(input, arc) {     if (!input)         return k2022.NaN();      const val =          !arc          ? Math.sin (input.value)          : Math.asin(input.value);      return new k2022(val, v1002(val)); }


class b1920 extends l2044 {     constructor(nodeId, options)     {         super(o1134, nodeId, options);     }            copy()     {         const copy = new b1920(this.nodeId, this.options);                  copy.t3455(this);          if (this.input) copy.input = this.input.copy();                  return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await i4329(this.input, parse);           this.c4193(parse,          [             ['', new s4309()]                      ]);           this.validate();          return this;     } }    async function i4329(input, arc) {     if (!input)         return k2022.NaN();      const val =          !arc          ? Math.cos (input.value)          : Math.acos(input.value);     return new k2022(val, v1002(val)); }


class a1922 extends l2044 {     constructor(nodeId, options)     {         super(t1135, nodeId, options);     }            copy()     {         const copy = new a1922(this.nodeId, this.options);                  copy.t3455(this);          if (this.input) copy.input = this.input.copy();                  return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await n4330(this.input, parse);           this.c4193(parse,          [             ['', new s4309()]                      ]);           this.validate();          return this;     } }    async function n4330(input, arc) {     if (!input)         return k2022.NaN();      const val =          !arc          ? Math.tan (input.value)          : Math.atan(input.value);          return new k2022(val, v1002(val)); }


class g1919 extends i2043 {     x;     y;            constructor(nodeId, options)     {         super(t1136, nodeId, options);     }            reset()     {         super.reset();          this.x = null;         this.y = null;     }        copy()     {         const copy = new g1919(this.nodeId, this.options);          copy.t3455(this);          if (this.x) copy.x = this.x.copy();         if (this.y) copy.y = this.y.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const x = await evalNumberValue(this.x, parse);         const y = await evalNumberValue(this.y, parse);           this.value = new k2022(Math.atan2(y.value, x.value));           this.c4193(parse,         [                          ['x',     x         ],             ['y',     y         ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.x && this.x.isValid()             && this.y && this.y.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.x) this.x.p4180(parse);         if (this.y) this.y.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.x) this.x.i4181(parse, from, force);         if (this.y) this.y.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.x) this.x.i4179(parse);         if (this.y) this.y.i4179(parse);     } } 


class f1928 extends l2044 {     from;        constructor(nodeId, options)     {         super(a1137, nodeId, options);     }            reset()     {         super.reset();          this.from = null;     }        copy()     {         const copy = new f1928(this.nodeId, this.options);          copy.t3455(this);          if (this.from) copy.from = this.from.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new k2022(0);                   const input = await evalNumberOrListValue(this.input, parse);         const from  = await evalNumberValue      (this.from,  parse);           if (input)         {             if (o955(input.type))             {                 this.value = new w2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == c1090                         ? getConvertAngleValue(item, from, this.options.enabled)                         : k2022.NaN());                    }             }             else                 this.value = getConvertAngleValue(input, from, this.options.enabled);         }         else             this.value = k2022.NaN();           this.c4193(parse,         [             ['type',  this.outputType()],                          ['from',  from             ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.from && this.from.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.from) this.from.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.from) this.from.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.from) this.from.i4179(parse);     } }    function getConvertAngleValue(input, from, enabled) {     c950(          input == c1090,          'input must be NUMBER_VALUE');               const value = input;          if (enabled)     {         switch (from.value)         {             case 0: value.value = value.value/360 * Tau; break;             case 1: value.value = value.value/Tau * 360; break;         }          value.decimals = v1002(value.value);     }       return value; }


class u1992 extends l2044 {     constructor(nodeId, options)     {         super(h1143, nodeId, options);     }        copy()     {         const copy = new u1992(this.nodeId, this.options);                  copy.t3455(this);          copy.value = this.value;                  return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           if (this.input)             this.value = await evalTextValue(this.input, parse);         else if (this.value)             await this.value.eval(parse);         else             this.value = new f2033();           this.c4193(parse,         [             ['value', this.value]         ]);                   this.validate();          return this;     }        isValid()     {         return   !this.input                && this.value != g961              || this.input.isValid();     } }


class l2000 extends l2044 {     constructor(nodeId, options)     {         super(w1144, nodeId, options);     }            copy()     {         const copy = new l2000(this.nodeId, this.options);          copy.t3455(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalTextOrListValue(this.input, parse);          if (   input             && input.isValid())         {             if (o955(input.type))             {                 this.value = new w2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == h1142                         ? new k2022(item.value.length)                         : k2022.NaN());                 }             }             else                 this.value = new k2022(input.value.length);         }         else             this.value = k2022.NaN();               this.c4193(parse,         [             ['type', this.outputType()]         ]);           this.validate();          return this;     } } 


class q2007 extends l2044 {     start = null;     end   = null;            constructor(nodeId, options)     {         super(n1145, nodeId, options);     }            reset()     {         super.reset();          this.start = null;         this.end   = null;     }        copy()     {         const copy = new q2007(this.nodeId, this.options);          copy.t3455(this);          if (this.start) copy.start = this.start.copy();         if (this.end  ) copy.end   = this.end  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const start = await evalTextValue(this.start, parse);         const end   = await evalTextValue(this.end,   parse);           if (this.input)         {             const input = await evalTextOrListValue(this.input, parse);                          if (o955(input.type))             {                 this.value = new w2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == h1142                         ? v3526(item, start, end, this.options.enabled)                         : new f2033());                    }             }             else             {                 this.value = v3526(input, start, end, this.options.enabled);             }         }         else             this.value = new f2033();           this.c4193(parse,         [             ['type',  this.outputType()],             ['start', start            ],             ['end',   end              ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.start && this.start.isValid()             && this.end   && this.end  .isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.start) this.start.p4180(parse);         if (this.end  ) this.end  .p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.start) this.start.i4181(parse, from, force);         if (this.end  ) this.end  .i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.start) this.start.i4179(parse);         if (this.end  ) this.end  .i4179(parse);     } }    function v3526(input, start, end, enabled) {     c950(input.type == h1142, 'input.type must be TEXT_VALUE');                     const value = input.copy();      if (enabled)     {         if (start.value.length > 0) value.value = n952(value.value, q1489(start.value));         if (end  .value.length > 0) value.value = w953  (value.value, q1489(end  .value));     }      return value; }


class d2004 extends l2044 {     start = null;     end   = null;            constructor(nodeId, options)     {         super(f1146, nodeId, options);     }            reset()     {         super.reset();          this.start = null;         this.end   = null;     }        copy()     {         const copy = new d2004(this.nodeId, this.options);          copy.t3455(this);          if (this.start) copy.start = this.start.copy();         if (this.end  ) copy.end   = this.end  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalTextOrListValue(this.input, parse);         const start = await evalNumberValue    (this.start, parse);         const end   = await evalNumberValue    (this.end,   parse);           let length     = 0;         let fullLength = 0;           if (   input             && start             && end)         {             if (o955(input.type))             {                 this.value = new w2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      const sub =                         item.type == h1142                         ? getSubstringValue(item, start, end, this.options.enabled)                         : new f2033();                      length     = Math.max(length,     sub.value.length);                     fullLength = Math.max(fullLength, sub.value.length);                      this.value.items.push(sub);                 }              }             else             {                 this.value = getSubstringValue(input, start, end, this.options.enabled);                                  length     = this .value.length;                 fullLength = input.value.length;             }         }         else             this.value = new f2033();           this.c4193(parse,         [             ['type',       this.outputType()          ],             ['length',     new k2022(length)    ],              ['fullLength', new k2022(fullLength)],              ['start',      start                      ],             ['end',        end                        ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.start && this.start.isValid()             && this.end   && this.end  .isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.start) this.start.p4180(parse);         if (this.end  ) this.end  .p4180(parse);     }        p4180(parse)     {         super.p4180(parse);          if (this.start) this.start.p4180(parse);         if (this.end  ) this.end  .p4180(parse);     }        i4179(parse, from)     {         super.i4179(parse, from);          if (this.start) this.start.i4179(parse, from);         if (this.end  ) this.end  .i4179(parse, from);     } }    function getSubstringValue(input, start, end, enabled) {     let value = new f2033();       const _end =         end.isValid()         ? end         : new k2022(input.value.length);       if (enabled)     {         const endValue =              _end.value < 0             ? input.value.length + _end.value             : _end.value;          if (start.value <= endValue)             value.value = input.value.substring(start.value, endValue);         else             value = new f2033();     }     else         value = input.copy();           return value; }


class o1995 extends l2044 {     what;        constructor(nodeId, options)     {         super(j1147, nodeId, options);     }            reset()     {         super.reset();          this.what = null;     }        copy()     {         const copy = new o1995(this.nodeId, this.options);          copy.t3455(this);          if (this.what = null) copy.what = this.what.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalTextOrListValue(this.input, parse);         const what  = await evalTextValue      (this.what,  parse);               if (input)         {             this.evalInputOrList(                 input,                  item => evalTextContains(item, what),                  u2622.NaN());         }         else             this.value = u2622.NaN();               this.c4193(parse,         [             ['type', this.outputType()],             ['what', what             ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.what && this.what.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.what) this.what.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.what) this.what.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.what) this.what.i4179(parse);     } }    function evalTextContains(input, what) {     return input.type == h1142          ? new u2622(                what.value == ''                    ? false                    : input.value.includes(what.value))          : u2622.NaN(); }


class m2607 extends s2045 {     first;     last;     all;        constructor(nodeId, options)     {         super(TEXT_FIND, nodeId, options);     }            reset()     {         super.reset();          this.first = null;         this.last  = null;         this.all   = null;     }        copy()     {         const copy = new m2607(this.nodeId, this.options);          copy.t3455(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const o4175 = await evalTextValue(this.o4175, parse);         const i4176 = await evalTextValue(this.i4176, parse);               if (   o4175 && o4175.isValid()              && i4176 && i4176.isValid())         {             const indices = [];             let   index   = 0;              if (i4176.value != '')             {                 while (index != -1)                  {                     index = o4175.value.indexOf(i4176.value, index);                      if (index != -1)                      {                         indices.push(index);                         index += 1;                     }                 }                                   this.value = new k2022(indices.length > 0 ? 1 : 0);                  this.first = indices.length > 0 ? new k2022(indices.at( 0)) : k2022.NaN();                 this.last  = indices.length > 0 ? new k2022(indices.at(-1)) : k2022.NaN();                  this.all   = new w2021();                  for (const index of indices)                     this.all.items.push(new k2022(index));             }             else             {                 this.value = new k2022(1);                  this.first = k2022.NaN();                 this.last  = k2022.NaN();                 this.all   =   w2021.NaN();             }         }         else                           {             this.value = k2022.NaN();             this.first = k2022.NaN();             this.last  = k2022.NaN();             this.all   =   w2021.NaN();         }               this.c4193(parse,         [             ['value', this.value],             ['first', this.first],             ['last',  this.last ],             ['all',   this.all  ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.first && this.first.isValid()             && this.last  && this.last .isValid()             && this.all   && this.all  .isValid();     } } 


class n1993 extends l2044 {     case;            constructor(nodeId, options)     {         super(t1148, nodeId, options);     }            reset()     {         super.reset();          this.case = null;     }        copy()     {         const copy = new n1993(this.nodeId, this.options);          copy.t3455(this);          if (this.case) copy.case = this.case.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalTextOrListValue(this.input, parse);         const t3754 = await evalNumberValue    (this.case,  parse);           if (input)         {             if (this.options.enabled)             {                 if (o955(input.type))                 {                     this.value = new w2021();                      for (let i = 0; i < input.items.length; i++)                     {                         const item = input.items[i];                          this.value.items.push(                             item.type == h1142                             ? getTextCaseValue(item, t3754)                             : new f2033());                        }                 }                 else                 {                     this.value = getTextCaseValue(input, t3754);                 }             }             else                 this.value = input.copy();         }         else             this.value = new f2033();           this.c4193(parse,         [                          ['type',   this.outputType()],             ['case',  t3754             ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.case && this.case.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.case) this.case.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.case) this.case.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.case) this.case.i4179(parse);     } }    function getTextCaseValue(input, t3754) {     c950(input.type == h1142, 'input.type must be TEXT_VALUE');      const val   = input.value;     const value = new f2033();           if (t3754.value == 0)           value.value = val.toLowerCase();      else if (t3754.value == 1)     {         if (val.length > 0) value.value += val.substring(0, 1).toUpperCase();         if (val.length > 1) value.value += val.substring(1)   .toLowerCase();     }      else if (t3754.value == 2)     {         let i = 0;         while (i < val.length)         {             while (i < val.length                 && /\s/.test(val.charAt(i)))                 value.value += val.charAt(i++);              if (i < val.length)                 value.value += val.charAt(i++).toUpperCase();              while (i < val.length                 && !/\s/.test(val.charAt(i)))                 value.value += val.charAt(i++).toLowerCase();         }     }      else if (t3754.value == 3)          value.value = val.toUpperCase();       return value; }


class e1991 extends l2044 {     base;     trim;     decimals;     thousands;            constructor(nodeId, options)     {         super(w1156, nodeId, options);     }            reset()     {         super.reset();          this.base      = null;         this.trim      = null;         this.decimals  = null;         this.thousands = null;     }        copy()     {         const copy = new e1991(this.nodeId, this.options);          copy.t3455(this);          if (this.base     ) copy.base      = this.base     .copy();         if (this.trim     ) copy.trim      = this.trim     .copy();         if (this.decimals ) copy.decimals  = this.decimals .copy();         if (this.thousands) copy.thousands = this.thousands.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input     = await evalNumberValue(this.input,     parse);         const base      = await evalNumberValue(this.base,      parse);         const trim      = await evalNumberValue(this.trim,      parse);         const decimals  = await evalTextValue  (this.decimals,  parse);         const thousands = await evalTextValue  (this.thousands, parse);           if (input)         {             if (o955(input.type))             {                 this.value = new w2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == c1090                         ? s3527(item, base, trim, decimals, thousands)                         : f2033.NaN());                    }             }             else             {                 this.value = s3527(input, base, trim, decimals, thousands);             }         }         else             this.value = f2033.NaN();           this.c4193(parse,         [             ['type',      this.outputType()],             ['base',      base             ],             ['trim',      trim             ],             ['decimals',  decimals         ],             ['thousands', thousands        ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.base      && this.base     .isValid()             && this.trim      && this.trim     .isValid()             && this.decimals  && this.decimals .isValid()             && this.thousands && this.thousands.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.base     ) this.base     .p4180(parse);         if (this.trim     ) this.trim     .p4180(parse);         if (this.decimals ) this.decimals .p4180(parse);         if (this.thousands) this.thousands.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.base     ) this.base     .i4181(parse, from, force);         if (this.trim     ) this.trim     .i4181(parse, from, force);         if (this.decimals ) this.decimals .i4181(parse, from, force);         if (this.thousands) this.thousands.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.base     ) this.base     .i4179(parse);         if (this.trim     ) this.trim     .i4179(parse);         if (this.decimals ) this.decimals .i4179(parse);         if (this.thousands) this.thousands.i4179(parse);     } }    function s3527(input, base, trim, decimals, thousands) {     return input.isValid()          ? new f2033(j1004(               input.value,                (trim.value > 0 ? -1 : 1) * input.decimals,                base.value == 1,                decimals.value,                thousands.value))          : new f2033('?'); }


                                                                                                                                                                      


class o1989 extends l2044 {     format;     trim;            constructor(nodeId, options)     {         super(v1157, nodeId, options);     }       reset()     {         super.reset();          this.format = null;         this.trim   = null;     }            copy()     {         const copy = new o1989(this.nodeId, this.options);          copy.t3455(this);          if (this.format) copy.format = this.format.copy();         if (this.trim  ) copy.trim   = this.trim  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalValue      (this.input,  parse);         const format = await evalNumberValue(this.format, parse);         const trim   = await evalNumberValue(this.trim,   parse);           if (input)         {             if (o955(input.type))             {                 this.value = new w2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                            item.type == j1167                         || item.type == d1177                         ? getColorToTextValue(item, format, trim)                         : f2033.NaN());                    }             }             else             {                 this.value = getColorToTextValue(input, format, trim);             }         }          else             this.value = f2033.NaN();           this.c4193(parse,         [             ['type',   this.outputType()],             ['format', format           ],             ['trim',   trim             ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.format && this.format.isValid()             && this.trim   && this.trim  .isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.format) this.format.p4180(parse);         if (this.trim  ) this.trim  .p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.format) this.format.i4181(parse, from, force);         if (this.trim  ) this.trim  .i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.format) this.format.i4179(parse);         if (this.trim  ) this.trim  .i4179(parse);     } }    function getColorToTextValue(input, format, trim) {     if (   input.type != j1167         && input.type != d1177)         return new f2033();       let str = g961;       const fill =          input.type == j1167         ? new c2013(input)         : input;      const rgba = fill.d99();      let dec1 = fill.color.c1.decimals;     let dec2 = fill.color.c2.decimals;     let dec3 = fill.color.c3.decimals;     let dec4 = fill.opacity .decimals;           const maxDec = Math.max(dec1, dec2, dec3, dec4);      if (   format.value == 0         && fill.color.space == 0)     {              }       switch (format.value)     {         case 0:              str = z151(rgba);              if (input.type == d1177)                 str += r2639(rgba[3]);              break;          case 1:              str =                           getColorValueToText(rgba[0], dec1, trim.value > 0)                  + ', ' + getColorValueToText(rgba[1], dec2, trim.value > 0)                  + ', ' + getColorValueToText(rgba[2], dec3, trim.value > 0);              if (input.type == d1177)                 str += ', ' + getColorValueToText(rgba[3], dec4, trim.value > 0);              break;          case 2:              str =                           getColorValueToText(rgba[0] * 255, dec1, trim.value > 0)                  + ', ' + getColorValueToText(rgba[1] * 255, dec2, trim.value > 0)                  + ', ' + getColorValueToText(rgba[2] * 255, dec3, trim.value > 0);              if (input.type == d1177)                 str += ', ' + getColorValueToText(rgba[3] * 255, dec4, trim.value > 0);              break;          case 3:              str = z151(rgba, true);              if (input.type == d1177)                 str += r2639(rgba[3]);              break;          case 4:              str =                  'rgb('                       + getColorValueToText(rgba[0] * 255, dec1, trim.value > 0)                 + ' ' + getColorValueToText(rgba[1] * 255, dec2, trim.value > 0)                 + ' ' + getColorValueToText(rgba[2] * 255, dec3, trim.value > 0);                  if (input.type == d1177)                     str += ' / ' + getColorValueToText(rgba[3], dec4, trim.value > 0);                      str += ')';             break;          case 5:          {             const hsl = u48(rgba);              str =                  'hsl('                 +       getColorValueToText(hsl[0] * 360, dec1, trim.value > 0)                 + ' ' + getColorValueToText(hsl[1] * 100, dec2, trim.value > 0)                 + ' ' + getColorValueToText(hsl[2] * 100, dec3, trim.value > 0);                  if (input.type == d1177)                     str += ' / ' + getColorValueToText(rgba[3], dec4, trim.value > 0);                      str += ')';             break;         }         case 6:          {             const hcl = q37(rgba);              str =                  'oklch('                 +       getColorValueToText(hcl[2] * 100, dec1, trim.value > 0)                 + ' ' + getColorValueToText(hcl[1],       dec2, trim.value > 0)                 + ' ' + getColorValueToText(hcl[0] * 360, dec3, trim.value > 0);              if (input.type == d1177)                 str += ' / ' + getColorValueToText(rgba[3], dec4, trim.value > 0);              str += ')';              break;         }         case 7:          {             const hcl = p42(rgba);              str =                  'lch('                 +       getColorValueToText(hcl[2] * 100, dec1, trim.value > 0)                 + ' ' + getColorValueToText(hcl[1] * 100, dec2, trim.value > 0)                 + ' ' + getColorValueToText(hcl[0] * 360, dec3, trim.value > 0);              if (input.type == d1177)                 str += ' / ' + getColorValueToText(rgba[3], dec4, trim.value > 0);              str += ')';              break;         }         case 8:          {             const lab = p4076(rgba);              str =                  'oklab('                 +       getColorValueToText(lab[0] * 100, dec1, trim.value > 0)                 + ' ' + getColorValueToText(lab[1],       dec2, trim.value > 0)                 + ' ' + getColorValueToText(lab[2],       dec3, trim.value > 0);              if (input.type == d1177)                 str += ' / ' + getColorValueToText(rgba[3], dec4, trim.value > 0);              str += ')';              break;         }         case 9:          {             const lab = d55(rgba);              str =                  'lab('                 +       getColorValueToText(lab[0] * 100, dec1, trim.value > 0)                 + ' ' + getColorValueToText(lab[1] * 100, dec2, trim.value > 0)                 + ' ' + getColorValueToText(lab[2] * 100, dec3, trim.value > 0);                  if (input.type == d1177)                     str += ' / ' + getColorValueToText(rgba[3], dec4, trim.value > 0);                      str += ')';             break;         }         case 10:          {             let space,                  color;              const _space =                 input.type == d1177                 ? input.color.space                 : input.space;               switch (_space.value)             {                 case  0:                 case  1:                  case  2:                  case  3:                  case  9:                 case 10:                 case 11:                 case 12:                 case 13:                 case 14: space = 'srgb';         color =           rgba;  break;                  case  4: space = 'srgb-linear';  color = rgb2lin  (rgba); break;                 case  5: space = 'display-p3';   color = h61   (rgba); break;                 case  6: space = 'a98-rgb';      color = rgb2a98  (rgba); break;                 case  7: space = 'prophoto-rgb'; color = rgb2pro  (rgba); break;                 case  8: space = 'rec2020';      color = rgb2r2020(rgba); break;                  case 15: space = 'xyz';          color = y69  (rgba); break;                 case 16: space = 'xyz-d50';      color = y69  (rgba, sRGB_D50); break;                 case 17: space = 'xyz-d65';      color = y69  (rgba); break;             }              str =                    'color('                 +       space                 + ' ' + getColorValueToText(color[0], dec1, trim.value > 0)                  + ' ' + getColorValueToText(color[1], dec2, trim.value > 0)                  + ' ' + getColorValueToText(color[2], dec3, trim.value > 0);              if (input.type == d1177)                 str += ' / ' + getColorValueToText(rgba[3], dec4, trim.value > 0);              str += ')';              break;         }         case 11:              str = getClosestHtmlName(rgba);             break;          case 12:              str = createColorName(rgba);             break;     }      return new f2033(str); }    function getColorValueToText(val, dec, trim) {     return j1004(val, (trim ? -1 : 1) * dec); }


class b2006 extends l2044 {     base      = null;     decimals  = null;     thousands = null;            constructor(nodeId, options)     {         super(i1158, nodeId, options);     }            reset()     {         super.reset();          this.base      = null;         this.decimals  = null;         this.thousands = null;     }        copy()     {         const copy = new b2006(this.nodeId, this.options);          copy.t3455(this);          if (this.base     ) copy.base      = this.base     .copy();         if (this.decimals ) copy.decimals  = this.decimals .copy();         if (this.thousands) copy.thousands = this.thousands.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input     = await evalTextOrListValue(this.input,     parse);         const base      = await evalNumberValue    (this.base,      parse);         const decimals  = await evalTextValue      (this.decimals,  parse);         const thousands = await evalTextValue      (this.thousands, parse);           if (   input             && input.isValid())         {             if (o955(input.type))             {                 this.value = new w2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == h1142                         ? getTextToNumberValue(item, base, decimals, thousands)                         : k2022.NaN());                    }             }             else                 this.value = getTextToNumberValue(input, base, decimals, thousands);         }          else             this.value = k2022.NaN();           this.c4193(parse,         [             ['type',      this.outputType()],             ['base',      base             ],             ['decimals',  decimals         ],             ['thousands', thousands        ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.base      && this.base     .isValid()             && this.decimals  && this.decimals .isValid()             && this.thousands && this.thousands.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.base     ) this.base     .p4180(parse);         if (this.decimals ) this.decimals .p4180(parse);         if (this.thousands) this.thousands.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.base     ) this.base     .i4181(parse, from, force);         if (this.decimals ) this.decimals .i4181(parse, from, force);         if (this.thousands) this.thousands.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.base     ) this.base     .i4179(parse);         if (this.decimals ) this.decimals .i4179(parse);         if (this.thousands) this.thousands.i4179(parse);     } }    function getTextToNumberValue(input, base, decimals, thousands) {     let num   = Number.NaN;     let value = input.value;      if (thousands)         value = value.replaceAll(thousands.value, '');           if (base)     {         switch (base.value)         {             case 0:              {                 if (value.lastIndexOf(decimals.value) > -1)                 {                     value = a1496(value, decimals.value, '.');                     num   = parseFloat(value);                 }                 else                     num = parseInt(value.replace(/[^\d-]/g, ''), 10);                          break;             }             case 1:              {                 const decIndex = value.lastIndexOf(decimals.value);                  if (decIndex < -1)                     num = parseInt(value, 16);                 else                 {                     const whole = value.slice(0, decIndex);                     const frac  = value.slice(decIndex + decimals.value.length);                      num =                            parseInt(whole, 16)                         + frac.split('')                             .reduce((sum, digit, index) => sum + parseInt(digit, 16) / Math.pow(16, index + 1), 0);                 }                  break;             }         }     }       return new k2022(num, v1002(num)); }


class n2610 extends l2044 {     constructor(nodeId, options)     {         super(TEXT_TO_BOOLEAN, nodeId, options);     }            copy()     {         const copy = new n2610(this.nodeId, this.options);          copy.t3455(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalTextOrListValue(this.input, parse);           if (   input             && input.isValid())         {             if (o955(input.type))             {                 this.value = new w2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == h1142                         ? getTextToBooleanValue(item)                         : k2022.NaN());                    }             }             else                 this.value = getTextToBooleanValue(input);         }          else             this.value = k2022.NaN();           this.c4193(parse,         [             ['type', this.outputType()]         ]);           this.validate();          return this;     } }    function getTextToBooleanValue(input) {     if (stringIsNumber(input.value))          return new u2622(parseFloat(input.value) > 0);     else             {              if (input.value.trim().toLowerCase() == 'true' ) return new u2622(true);         else if (input.value.trim().toLowerCase() == 'false') return new u2622(false);         else                                                  return u2622.NaN();     } }


class h2005 extends l2044 {     format;        constructor(nodeId, options)     {         super(l1159, nodeId, options);     }            reset()     {         super.reset();          this.format = null;     }            copy()     {         const copy = new h2005(this.nodeId, this.options);          copy.t3455(this);          if (this.format) copy.format = this.format.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalTextValue  (this.input, parse);         const format = await evalNumberValue(this.format, parse);                   if (input)         {             if (o955(input.type))             {                 this.value = new w2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == h1142                         ? getTextToColorValue(item.value.trim(), format)                         : k2022.NaN());                    }             }             else             {                 this.value = getTextToColorValue(input.value.trim(), format);             }         }          else             this.value = d2010.NaN();           this.c4193(parse,         [             ['value', this.value       ],             ['type',  this.outputType()],             ['format', format          ],         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.format && this.format.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.format) this.format.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.format) this.format.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.format) this.format.i4179(parse);     } }    function getTextToColorValue(str, format) {     let rgb;        switch (format.value)     {         case 0:          {             rgb = f153(str);             break;         }         case 1:          {             const parts = str.split(',').map(s => s.trim());                      rgb =              [                 parseFloat(parts[0]),                 parseFloat(parts[1]),                 parseFloat(parts[2])             ];              break;         }         case 2:          {             const parts = str.split(',').map(s => s.trim());                      rgb =              [                 parseFloat(parts[0]) / 0xff,                 parseFloat(parts[1]) / 0xff,                 parseFloat(parts[2]) / 0xff             ];              break;         }         case 3:          {                        let webColor = f1498.find(wc => wc.name.toLowerCase() == str);             if (!webColor) webColor = f1498.find(wc => c1490(wc.name.toLowerCase(), str) <= 1);                          if (webColor)                 rgb = webColor.color;              break;         }         case 4:          {             const hsl = parseStructuredColorName(str);              if (hsl)                 rgb = x50(hsl);              break;         }     }           return rgb          ? d2010.t3868(z4234(rgb))          : d2010.NaN(); }


class i1988 extends l2044 {     constructor(nodeId, options)     {         super(m1153, nodeId, options);     }            copy()     {         const copy = new i1988(this.nodeId, this.options);          copy.t3455(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalNumberValue(this.input, parse);           if (input)         {             if (o955(input.type))             {                 this.value = new w2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == c1090                         ? getCodeToCharacterValue(item)                         : f2033.NaN());                    }             }             else             {                 this.value = getCodeToCharacterValue(input);             }         }         else             this.value = f2033.NaN();           this.c4193(parse,         [                          ['type',  this.outputType()]         ]);           this.validate();          return this;     } }    function getCodeToCharacterValue(input) {     return new f2033(String.fromCharCode(Math.min(Math.max(0, input.value), 0xffff))); }


class w1987 extends l2044 {     constructor(nodeId, options)     {         super(v1154, nodeId, options);     }            copy()     {         const copy = new w1987(this.nodeId, this.options);          copy.t3455(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalTextValue(this.input, parse);           if (input)         {             if (o955(input.type))             {                 this.value = new w2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == h1142                         ? getCharacterToCodeValue(item)                         : k2022.NaN());                    }             }             else             {                 this.value = getCharacterToCodeValue(input);             }         }         else             this.value = k2022.NaN();           this.c4193(parse,         [                          ['type',  this.outputType()]         ]);           this.validate();          return this;     } }    function getCharacterToCodeValue(input) {     return input.value.length > 0          ? new k2022(input.value.charCodeAt(0))          : k2022.NaN(); }


class s1990 extends i2043 {     name;     index;            constructor(nodeId, options)     {         super(p1155, nodeId, options);     }            reset()     {         super.reset();          this.index = null;     }        copy()     {         const copy = new s1990(this.nodeId, this.options);          copy.t3455(this);          if (this.name ) copy.name  = this.name .copy();         if (this.index) copy.index = this.index.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const name  = await evalTextValue  (this.name,  parse);         const index = await evalNumberValue(this.index, parse);           switch (name.value)         {             case 0: this.value = new f2033(                 [                     'monday',                      'tuesday',                      'wednesday',                      'thursday',                      'friday',                      'saturday',                      'sunday'                 ]                  [index.value-1]);                  break;              case 1: this.value = new f2033(                 [                     'january',                      'february',                      'march',                      'april',                      'may',                      'june',                      'july',                     'august',                     'september',                     'october',                     'november',                     'december'                 ]                  [index.value-1]);                  break;              case 2:                 this.value = new f2033(v4133[index.value]);                 break;          }           this.c4193(parse,         [                          ['name',  name      ],             ['index', index     ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.index && this.index.isValid()             && this.name  && this.name .isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.index) this.index.p4180(parse);         if (this.name ) this.name .p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.index) this.index.i4181(parse, from, force);         if (this.name ) this.name .i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.index) this.index.i4179(parse);         if (this.name ) this.name .i4179(parse);     } } 


class p2002 extends l2044 {     what  = null;     with  = null;     regex = null;        constructor(nodeId, options)     {         super(r1149, nodeId, options);     }            reset()     {         super.reset();          this.what  = null;         this.with  = null;         this.regex = null;     }        copy()     {         const copy = new p2002(this.nodeId, this.options);          copy.t3455(this);          if (this.what ) copy.what  = this.what .copy();         if (this.with ) copy.with  = this.with .copy();         if (this.regex) copy.regex = this.regex.copy();          if (this.value) copy.value = this.value.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const  input = await evalTextOrListValue(this.input, parse);         const _what  = await evalTextValue      (this.what,  parse);         const _with  = await evalTextValue      (this.with,  parse);         const _regex = await evalNumberValue    (this.regex, parse);           if (input)         {             if (this.options.enabled)             {                 if (o955(input.type))                 {                     this.value = new w2021();                      for (let i = 0; i < input.items.length; i++)                     {                         const item = input.items[i];                          this.value.items.push(                             item.type == h1142                             ? getReplaceValue(item, _what, _with, _regex)                             : new f2033());                        }                 }                 else                 {                     this.value = getReplaceValue(input, _what, _with, _regex);                 }             }             else                 this.value = input.copy();         }         else             this.value = new f2033();           this.c4193(parse,         [                          ['type',   this.outputType()],             ['what',  _what             ],             ['with',  _with             ],             ['regex', _regex            ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.what  && this.what .isValid()             && this.with  && this.with .isValid()             && this.regex && this.regex.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.what ) this.what .p4180(parse);         if (this.with ) this.with .p4180(parse);         if (this.regex) this.regex.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.what ) this.what .i4181(parse, from, force);         if (this.with ) this.with .i4181(parse, from, force);         if (this.regex) this.regex.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.what ) this.what .i4179(parse);         if (this.with ) this.with .i4179(parse);         if (this.regex) this.regex.i4179(parse);     } }    function getReplaceValue(input, _what, _with, _regex) {     c950(input.type == h1142, 'input.type must be TEXT_VALUE');      const value = new f2033();           if (_regex.value > 0)     {         try         {             value.value = input.value.replace(                 new RegExp(unescapeRegexPattern(_what.value), 'gu'),                 unescapeRegexReplacement(_with.value));         }         catch (e)         {             b4136(e.message, {error: true});         }     }     else if (input.value)     {         value.value = input.value.replaceAll(             q1489(_what.value),             q1489(_with.value));     }       return value; }


class n1999 extends i2043 {     inputs = [];      with = null;            constructor(nodeId, options)     {         super(t1150, nodeId, options);     }        reset()     {         super.reset();          this.inputs = [];                  this.with = null;     }           copy()     {         const copy = new n1999(this.nodeId, this.options);         copy.t3455(this);                  copy.inputs = this.inputs.map(i => i.copy());         copy.with   = this.with;          return copy;     }        isCached()     {         for (const input of this.inputs)             if (!input.isCached())                 return false;          return super.isCached();     }        async eval(parse)     {         if (this.isCached())             return this;           const inputs = await Promise.all(this.inputs.map(async i => await evalTextOrListValue(i, parse)));         const _with  = await evalTextValue(this.with, parse);           this.value = await evalJoinInputs(inputs, _with, parse);                   this.c4193(parse,         [             ['type', this.outputType()],             ['with',  _with           ]         ]);           this.validate();          return this;     }        isValid()     {         return !this.inputs.find(i => !i.isValid())             && this.with && this.with.isValid();     }        p4180(parse)     {         super.p4180(parse);          this.inputs.forEach(i => i.p4180(parse));          if (this.with) this.with.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          this.inputs.forEach(i => i.i4181(parse, from, force));          if (this.with) this.with.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          this.inputs.forEach(i => i.i4179(parse));          if (this.with) this.with.i4179(parse);     } }    async function evalJoinInputs(inputs, _with, parse) {     if (isEmpty(inputs))         return new f2033();       const allAreLists = allInputsAreCondensedLists(inputs);     const w           = q1489(_with.value);      if (allAreLists) return await evalJoinListInputs(inputs, w, parse);     else             return await evalJoinItemInputs(inputs, w, parse); }    async function evalJoinListInputs(inputs, _with, parse) {     const value = new w2021();           for (const input of inputs)     {         if (!input) continue;          console.assert(              o955(input.type),              `input is ${input.type}, must be a list`);          if (allInputsAreCondensedLists(input.items))             value.items.push(...(await evalJoinListInputs(input.items, _with, parse)).items);         else             value.items.push(await evalJoinItemInputs(input.items, _with, parse));     }       return value; }    async function evalJoinItemInputs(inputs, _with, parse) {     const value = new f2033();               for (let i = 0; i < inputs.length; i++)     {         const input = await evalTextOrListValue(inputs[i], parse);         if (!input) continue;           if (i > 0)             value.value += _with;           if (o955(input.type))         {             for (let j = 0; j < input.items.length; j++)             {                 if (j > 0)                     value.value += _with;                   const item = input.items[j];                  if (item.type == h1142)                     value.value += item.value;             }         }         else         {             c950(input.type == h1142, 'val.type must be TEXT_VALUE');              value.value += input.value;         }     }       return value; }


class GAddText extends l2044 {     text;     prefix;        constructor(nodeId, options)     {         super(TEXT_ADD, nodeId, options);     }            reset()     {         super.reset();          this.text   = null;         this.prefix = null;     }        copy()     {         const copy = new GAddText(this.nodeId, this.options);          copy.t3455(this);          if (this.text  ) copy.text   = this.text  .copy();         if (this.prefix) copy.prefix = this.prefix.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new k2022(0);           const input  = await evalTextOrListValue(this.input,  parse);         const text   = await evalTextValue      (this.text,   parse);         const prefix = await evalNumberValue    (this.prefix, parse);           if (input)         {             if (this.options.enabled)             {                 this.evalInputOrList(                     input,                      item => evalAddText(item, text, prefix),                      new f2033());             }             else                 this.value = input;         }         else             this.value = f2033.NaN();           this.c4193(parse,         [             ['type',   this.outputType()],             ['text',   text             ],             ['prefix', prefix           ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.text   && this.text  .isValid()             && this.prefix && this.prefix.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.text  ) this.text  .p4180(parse);         if (this.prefix) this.prefix.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.text  ) this.text  .i4181(parse, from, force);         if (this.prefix) this.prefix.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.text  ) this.text  .i4179(parse);         if (this.prefix) this.prefix.i4179(parse);     } }    function evalAddText(input, text, prefix) {     const textValue = q1489(text.value);      return new f2033(         prefix.value > 0             ? textValue + input.value             : input.value + textValue); }


class p2001 extends l2044 {     j3750   = null;     z3751 = null;     w3752     = null;     n3753   = null;                    constructor(nodeId, options)     {         super(m1151, nodeId, options);     }            reset()     {         super.reset();                  this.j3750   = null;         this.z3751 = null;         this.w3752     = null;         this.n3753   = null;     }        copy()     {         const copy = new p2001(this.nodeId, this.options);          copy.t3455(this);          if (this.j3750  ) copy.j3750   = this.j3750  .copy();         if (this.z3751) copy.z3751 = this.z3751.copy();         if (this.w3752    ) copy.w3752     = this.w3752    .copy();         if (this.n3753  ) copy.n3753   = this.n3753  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const j3750   = await evalTextValue  (this.j3750,   parse);         const z3751 = await evalNumberValue(this.z3751, parse);         const w3752     = await evalTextValue  (this.w3752,     parse);         const n3753   = await evalNumberValue(this.n3753,   parse);           if (this.input)         {             const input = await evalTextOrListValue(this.input, parse);                           if (o955(input.type))             {                 this.value = new w2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == h1142                         ? getPadValue(                             item,                              j3750,                              z3751,                              w3752,                              n3753,                              this.options.enabled)                         : new f2033());                    }             }             else             {                 this.value = getPadValue(                     input,                      j3750,                      z3751,                      w3752,                      n3753,                      this.options.enabled);             }         }         else             this.value = new f2033();           this.c4193(parse,         [             ['type',       this.outputType()],             ['startPad',   j3750         ],             ['startCount', z3751       ],             ['endPad',     w3752           ],             ['endCount',   n3753         ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.j3750   && this.j3750  .isValid()             && this.z3751 && this.z3751.isValid()             && this.w3752     && this.w3752    .isValid()             && this.n3753   && this.n3753  .isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.j3750  ) this.j3750  .p4180(parse);         if (this.z3751) this.z3751.p4180(parse);         if (this.w3752    ) this.w3752    .p4180(parse);         if (this.n3753  ) this.n3753  .p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.j3750  ) this.j3750  .i4181(parse, from, force);         if (this.z3751) this.z3751.i4181(parse, from, force);         if (this.w3752    ) this.w3752    .i4181(parse, from, force);         if (this.n3753  ) this.n3753  .i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.j3750  ) this.j3750  .i4179(parse);         if (this.z3751) this.z3751.i4179(parse);         if (this.w3752    ) this.w3752    .i4179(parse);         if (this.n3753  ) this.n3753  .i4179(parse);     } }    function getPadValue(input, j3750, z3751, w3752, n3753, enabled) {     c950(input.type == h1142, 'input.type must be TEXT_VALUE');      const value = input.copy();          if (enabled)         value.value = input.value             .padStart(z3751.value, q1489(j3750.value))             .padEnd  (  n3753.value, w3752.value != '' ? q1489(w3752.value) : q1489(j3750.value));      return value; }


class g2597 extends l2044 {     method;        constructor(nodeId, options)     {         super(TEXT_ESCAPE, nodeId, options);     }            reset()     {         super.reset();          this.method = null;     }        copy()     {         const copy = new g2597(this.nodeId, this.options);          copy.t3455(this);          if (this.method) copy.method = this.method.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalTextOrListValue(this.input,  parse);         const method = await evalNumberValue    (this.method, parse);           if (input)         {             if (this.options.enabled)             {                 if (o955(input.type))                 {                     this.value = new w2021();                      for (let i = 0; i < input.items.length; i++)                     {                         const item = input.items[i];                          this.value.items.push(                             item.type == h1142                             ? getTextEscapeValue(item, method)                             : new f2033());                        }                 }                 else                 {                     this.value = getTextEscapeValue(input, method);                 }             }             else                 this.value = input.copy();         }         else             this.value = new f2033();           this.c4193(parse,         [             ['type',   this.outputType()],             ['invert', method           ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.method && this.method.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.method) this.method.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.method) this.method.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.method) this.method.i4179(parse);     } }    function getTextEscapeValue(input, method) {     c950(input.type == h1142, 'input.type must be TEXT_VALUE');      switch (method.value)     {         case 0: return new f2033(q1489(input.value));         case 1: return new f2033(decodeURIComponent(input.value));     }      c950(false, 'invalid escape method');     return input; }


class o2614 extends l2044 {     method;        constructor(nodeId, options)     {         super(TEXT_UNESCAPE, nodeId, options);     }            reset()     {         super.reset();          this.method = null;     }        copy()     {         const copy = new o2614(this.nodeId, this.options);          copy.t3455(this);          if (this.method) copy.method = this.method.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalTextOrListValue(this.input,  parse);         const method = await evalNumberValue    (this.method, parse);           if (input)         {             if (this.options.enabled)             {                 if (o955(input.type))                 {                     this.value = new w2021();                      for (let i = 0; i < input.items.length; i++)                     {                         const item = input.items[i];                          this.value.items.push(                             item.type == h1142                             ? getTextUnescapeValue(item, method)                             : new f2033());                        }                 }                 else                 {                     this.value = getTextUnescapeValue(input, method);                 }             }             else                 this.value = input.copy();         }         else             this.value = new f2033();           this.c4193(parse,         [             ['type',   this.outputType()],             ['invert', method           ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.method && this.method.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.method) this.method.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.method) this.method.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.method) this.method.i4179(parse);     } }    function getTextUnescapeValue(input, method) {     c950(input.type == h1142, 'input.type must be TEXT_VALUE');      switch (method.value)     {         case 0: return new f2033(unescapeString    (input.value));         case 1: return new f2033(encodeURIComponent(input.value));     }      c950(false, 'invalid escape method');     return input; }


class l2003 extends l2044 {     separator;        constructor(nodeId, options)     {         super(a1160, nodeId, options);     }        reset()     {         super.reset();          this.separator = null;     }           copy()     {         const copy = new l2003(this.nodeId, this.options);          copy.t3455(this);          if (this.separator) copy.separator = this.separator.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input     = await evalTextOrListValue(this.input,     parse);         const separator = await evalTextValue      (this.separator, parse);           this.value = new w2021();           if (   input             && separator)         {             if (o955(input.type))             {                 for (const item of input.items)                 {                     const itemList = new w2021(                         item.value                             .split(q1489(separator.value))                             .map(s => new f2033(s)));                      this.value.items.push(itemList);                 }             }             else             {                 c950(input.type == h1142, 'input must be TEXT_VALUE');                  this.value.items = input.value                     .split(q1489(separator.value))                     .map(s => new f2033(s));             }         }           this.c4193(parse,         [             ['type',      this.outputType()],             ['separator', separator        ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.separator && this.separator.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.separator) this.separator.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.separator) this.separator.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.separator) this.separator.i4179(parse);     } } 


class p1994 extends l2044 {     operation;     operand;        constructor(nodeId, options)     {         super(y1152, nodeId, options);     }            reset()     {         super.reset();          this.operation = null;         this.operand   = null;     }        copy()     {         const copy = new p1994(this.nodeId, this.options);          copy.t3455(this);          if (this.operation) copy.operation = this.operation.copy();         if (this.operand  ) copy.operand   = this.operand  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input   = await evalTextOrListValue(this.input,     parse);         const op      = await evalNumberValue      (this.operation, parse);         const operand = await evalTextValue        (this.operand,   parse);                   if (   input             && op)         {             op.value = Math.min(Math.max(0, op.value), s1323.length-1);              if (o955(input.type))             {                 this.value = new w2021();                  for (const item of input.items)                 {                     this.value.items.push(                         item.type == h1142                         ? await evalCompareTextInputs(item, operand, op)                         : k2022.NaN());                 }             }             else             {                 this.value = await evalCompareTextInputs(input, operand, op);             }         }         else             this.value = k2022.NaN();           this.c4193(parse,         [             ['type',      this.outputType()],             ['operation', op               ],             ['operand',   operand          ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.operation && this.operation.isValid()             && this.operand   && this.operand  .isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.operation) this.operation.p4180(parse);         if (this.operand  ) this.operand  .p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.operation) this.operation.i4181(parse, from, force);         if (this.operand  ) this.operand  .i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.operation) this.operation.i4179(parse);         if (this.operand  ) this.operand  .i4179(parse);     } }    async function evalCompareTextInputs(input, operand, op)  {     let opFunc = null;      switch (op.value)     {         case n1317:              opFunc = (a, b) => a <  b;  break;         case k1318:     opFunc = (a, b) => a <= b;  break;         case g1319:         opFunc = (a, b) => a != b;  break;         case v1320:             opFunc = (a, b) => a == b;  break;         case w1321:  opFunc = (a, b) => a >= b;  break;         case f1322:           opFunc = (a, b) => a >  b;  break;     }      if (   input   && input  .isValid()          && operand && operand.isValid())         return new k2022(opFunc(input.value, operand.value) ? 1 : 0, 0, true);     else                           return new s4309(); }


class g1996 extends l2044 {     b3743;     d3744;        constructor(nodeId, options)     {         super(b1162, nodeId, options);     }            reset()     {         super.reset();          this.b3743    = null;         this.d3744 = null;     }        copy()     {         const copy = new g1996(this.nodeId, this.options);          copy.t3455(this);          if (this.b3743   ) copy.b3743    = this.b3743   .copy();         if (this.d3744) copy.d3744 = this.d3744.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const b3743    = await evalTextValue(this.b3743,    parse);         const d3744 = await evalTextValue(this.d3744, parse);           this.value = new w2021();           let maxColumns = 0;                   let nRows    = 0;         let nColumns = 0;           if (   this.input             && b3743             && d3744             && b3743.value != '')         {             const input = await evalTextValue(this.input, parse);                           const rows =                     input                 && input.value                             ? input.value.split(q1489(b3743.value))                 : [];               for (const _row of rows)             {                 const cells =                      _row                     ? _row.split(q1489(d3744.value))                     : [];                   const row = new w2021();                  for (const cell of cells)                     row.items.push(new f2033(cell));                  maxColumns = Math.max(maxColumns, row.items.length);                   this.value.items.push(row);             }               nRows    = this.value.items.length;             nColumns = maxColumns;         }               this.c4193(parse,         [             ['rowSeparator',    b3743             ],             ['columnSeparator', d3744          ],             ['rows',            new k2022(nRows   )],             ['columns',         new k2022(nColumns)]         ]);                   if (parse.settings.r3829)         {             this.c4193(parse,             [                 ['preview', new w2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.b3743    && this.b3743   .isValid()             && this.d3744 && this.d3744.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.b3743   ) this.b3743   .p4180(parse);         if (this.d3744) this.d3744.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.b3743   ) this.b3743   .i4181(parse, from, force);         if (this.d3744) this.d3744.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.b3743   ) this.b3743   .i4179(parse);         if (this.d3744) this.d3744.i4179(parse);     } } 


class u2613 extends l2044 {     constructor(nodeId, options)     {         super(w3601, nodeId, options);     }            copy()     {         const copy = new u2613(this.nodeId, this.options);          copy.t3455(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new w2021();           if (this.input)         {             const input = await evalTextValue(this.input, parse);                          try             {                 const json = JSON.parse(input.value);                 this.value = this.evalItems(json);             }             catch (e)             {                 this.value = new w2021();             }         }               this.c4193(parse,         [             ['length',  new k2022(this.value.items.length)]                      ]);                   if (parse.settings.n3828)         {             this.c4193(parse,             [                 ['preview', this.value]             ],             true);         }           this.validate();          return this;     }        evalItems(json)     {         let list = new w2021();           for (const key in json)         {             if (   typeof json[key] === 'object'                 && json[key] !== null)             {                 const b111 = this.evalItems(json[key]);                 b111.valueId = key;                 list.items.push(b111);             }             else             {                 let value;                  if (   typeof json[key] === 'number'                     || j1486(json[key]))                     value = k2022.fromString(json[key].toString());                 else if (typeof json[key] === 'boolean')                     value = new k2022(z921(json[key].toString()) ? 1 : 0);                 else                     value = new f2033(json[key]);                                       value.valueId =                      key == 'value'                     ? '(value)'                      : key;                  list.items.push(value);             }         }                   return list;     } } 


class u2542 extends l2044 {     quoteValues = null;     snowNames   = null;     singleLine  = null;     whiteSpace  = null;        constructor(nodeId, options)     {         super(TO_JSON, nodeId, options);     }            reset()     {         super.reset();          this.quoteValues = null;         this.showNames   = null;         this.singleLine  = null;         this.whiteSpace  = null;     }        copy()     {         const copy = new u2542(this.nodeId, this.options);          copy.t3455(this);          if (this.quoteValues) copy.quoteValues = this.quoteValues.copy();         if (this.showNames  ) copy.showNames   = this.showNames  .copy();         if (this.singleLine ) copy.singleLine  = this.singleLine .copy();         if (this.whiteSpace ) copy.whiteSpace  = this.whiteSpace .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input       = await evalValue      (this.input,       parse);         const quoteValues = await evalNumberValue(this.quoteValues, parse);         const showNames   = await evalNumberValue(this.showNames,   parse);         const singleLine  = await evalNumberValue(this.singleLine,  parse);         const whiteSpace  = await evalNumberValue(this.whiteSpace,  parse);           if (input)         {             let json = '';                          json += input.toJsonText(             {                 tab:          0,                 named:        false,                 forceBraces:  false,                 lastExpanded: false,                 quoteValues:  quoteValues.value > 0,                 showNames:    showNames  .value > 0,                 singleLine:   singleLine .value > 0,                 whiteSpace:   whiteSpace .value > 0             });              this.value = new f2033(json);         }         else             this.value = new f2033('');           this.c4193(parse,         [             ['type',        this.outputType()],             ['quoteValues', quoteValues      ],             ['showNames',   showNames        ],             ['singleLine',  singleLine       ],             ['whiteSpace',  whiteSpace       ]         ]);           this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return this.quoteValues && this.quoteValues.isValid()             && this.showNames   && this.showNames  .isValid()             && this.singleLine  && this.singleLine .isValid()             && this.whiteSpace  && this.whiteSpace .isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.quoteValues) this.quoteValues.p4180(parse);         if (this.showNames  ) this.showNames  .p4180(parse);         if (this.singleLine ) this.singleLine .p4180(parse);         if (this.whiteSpace ) this.whiteSpace .p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.quoteValues) this.quoteValues.i4181(parse, from, force);         if (this.showNames  ) this.showNames  .i4181(parse, from, force);         if (this.singleLine ) this.singleLine .i4181(parse, from, force);         if (this.whiteSpace ) this.whiteSpace .i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.quoteValues) this.quoteValues.i4179(parse);         if (this.showNames  ) this.showNames  .i4179(parse);         if (this.singleLine ) this.singleLine .i4179(parse);         if (this.whiteSpace ) this.whiteSpace .i4179(parse);     } } 


class r1997 extends i2043 {     request;     m4304;        constructor(nodeId, options)     {         super(r1163, nodeId, options);     }            reset()     {         super.reset();          this.request     = null;         this.m4304 = null;     }        copy()     {         const copy = new r1997(this.nodeId, this.options);          copy.t3455(this);          if (this.request    ) copy.request     = this.request    .copy();         if (this.m4304) copy.m4304 = this.m4304.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const request     = await evalTextValue(this.request,     parse);         const m4304 = await evalTextValue(this.m4304, parse);                   b2077(this.nodeId);           if (m4304.value == '')         {             try              {                 const response = await fetch(request.value);                 const content  = await response.text();                                  this.value = new f2033(content);             }             catch (e)             {                 this.value =                      request.value.trim() == NULL                     ? new f2033()                     : new f2033('invalid request');             }         }         else         {             this.value = this.m4304.copy();         }           this.c4193(parse,         [             ['value',   this.value],             ['request', request   ]         ]);                           if (parse.settings.n3828)         {             this.c4193(parse,             [                 ['preview', this.value]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return this.request && this.request.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.request) this.request.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.request) this.request.i4181(parse, from, force);          this.m4304 = new f2033();     }        i4179(parse)     {         super.i4179(parse);          if (this.request) this.request.i4179(parse);     } }


class k1998 extends i2043 {               m4304 = null;        constructor(nodeId, options)     {         super(i1164, nodeId, options);     }            reset()     {         super.reset();          this.m4304 = null;     }        copy()     {         const copy = new k1998(this.nodeId, this.options);          copy.t3455(this);          if (this.m4304) copy.m4304 = this.m4304.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const m4304 = await evalTextValue(this.m4304, parse);                          b2077(this.nodeId);           this.value = m4304 ?? new f2033();           this.c4193(parse,         [             ['', new s4309()]                      ]);                           if (parse.settings.n3828)         {             this.c4193(parse,             [                 ['preview', this.value]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return false;     }        p4180(parse)     {         super.p4180(parse);          if (this.path) this.path.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.path) this.path.i4181(parse, from, force);               }        i4179(parse)     {         super.i4179(parse);          if (this.path) this.path.i4179(parse);     } }


class e1796 {     name;      max;     value;          constructor(name = '', max = 0, value = 0)     {         this.name  = name;         this.max   = max;         this.value = value;     } }    async function f1797(parse,                               nodeId,                               color,                               order, b3779, f3780, h3781,                               n3808, n3809, o3810, s3811)  {     const refRgb = j4287(color);           let y1806 = [...color],         a3813   = null,          w1808 = order ? order.value : -1,         i1809     = -1,         r1810     = -1,         g1811     = -1;       let progress = 0,         total    = 6 * Math.pow(2, Tau);               const findSteps = 1024;          let d = 1;           parse.f3735 += findSteps;       dLoop:     while (d > 1/findSteps)     {         if (parse.r3736)             break dLoop;          let _closestColor = [...y1806];           for (let r3778 = 0; r3778 < 6; r3778++)         {             if (parse.r3736)                 break dLoop;              y1806 = [..._closestColor];              const [min1, min2, min3] = b1803(color[0], r3778);             const [max1, max2, max3] = l1804(color[0], r3778);              let start1 = q1033(min1, i1809, 1-d), m1812 = q1033(max1, i1809, 1-d),                 start2 = q1033(min2, r1810, 1-d), o1813 = q1033(max2, r1810, 1-d),                 start3 = q1033(min3, g1811, 1-d), x1814 = q1033(max3, g1811, 1-d);                                if (n3809) { i1809 = b3779.p3798(); start1 = i1809; m1812 = i1809+Epsilon; }             if (o3810) { r1810 = f3780.p3798(); start2 = r1810; o1813 = r1810+Epsilon; }             if (s3811) { g1811 = h3781.p3798(); start3 = g1811; x1814 = g1811+Epsilon; }                         [ y1806,             a3813,             w1808,             i1809,             r1810,             g1811,             progress ] = await findCorrectionInOrder(                 parse,                 nodeId,                 refRgb,                 r3778,                  n3808,                  n3809,  o3810,  s3811,                 i1809, r1810, g1811,                 start1,   start2,   start3,                  m1812,     o1813,     x1814,                 [...y1806],                 a3813,                  w1808,                 progress,                 total);         }           if (parse.r3736)             break;                   d /= 2;           parse.f3734++;           if (await s3957(parse.e2067))             break;     }       if (!parse.r3736)     {                   const a3813 = t1798(color, w1808, i1809, r1810, g1811)[1];          let c1 = i1809;         let c2 = r1810;         let c3 = g1811;          while (c1 >= 0 && h108(t1798(color, w1808, c1-1, r1810, g1811)[1], a3813)) c1--;         while (c2 >= 0 && h108(t1798(color, w1808, i1809, c2-1, g1811)[1], a3813)) c2--;         while (c3 >= 0 && h108(t1798(color, w1808, i1809, r1810, c3-1)[1], a3813)) c3--;          i1809 = Math.max(0, c1);         r1810 = Math.max(0, c2);         g1811 = Math.max(0, c3);     }           return [         w1808,         i1809,         r1810,         g1811 ]; }    async function findCorrectionInOrder(parse,                                      nodeId,                                      refRgb,                                      order,                                       n3808,                                       n3809,  o3810,  s3811,                                      i1809, r1810, g1811,                                      start1,   start2,   start3,                                       m1812,     o1813,     x1814,                                      y1806,                                      a3813,                                      w1808,                                      progress,                                      total) {     const color = [...y1806];          let a3814 = n3809 ? 1 : 2;     let s3815 = o3810 ? 1 : 2;     let y3816 = s3811 ? 1 : 2;       cLoop:     for (let m1 = start1; m1 < m1812; m1 += (m1812-start1)/a3814)     {         if (parse.r3736)             break cLoop;          for (let m2 = start2; m2 < o1813; m2 += (o1813-start2)/s3815)         {             if (parse.r3736)                 break cLoop;              for (let m3 = start3; m3 < x1814; m3 += (x1814-start3)/y3816)             {                 if (parse.r3736)                     break cLoop;                  const [f3296, w124] = t1798(color, order, m1, m2, m3);                  if (   q78(w124)                     && (  !a3813                         || deltaE(refRgb, w124) < deltaE(refRgb, a3813)))                 {                     y1806 = f3296;                     a3813   = w124;                                          if (!n3808)                         w1808 = order;                      i1809 = m1;                     r1810 = m2;                     g1811 = m3;                 }                  progress++;             }         }                   u2078(parse, nodeId, progress / total, false);     }           return [         y1806,         a3813,         w1808,         i1809,         r1810,         g1811,         progress ]; }    function t1798(color, order, m1, m2, m3) {     const f3296 = w1799(color, order, m1, m2, m3);     const rgb    = j4287(f3296);      return [f3296, rgb]; }    function w1799(color, order, c1, c2, c3) {     if (order < 0)         return color;       const [i1, i2, i3] = a1802(order);                                 color = m1800(color, i1, c1);     if (!k150(color)) color = m1800(color, i2, c2);     if (!k150(color)) color = m1800(color, i3, c3);                 let rgb = j4287(color);      if (q78(rgb))         rgb = i80(rgb);                   color = y4288(         m146(rgb),         color[0]);           return color; }    function m1800(color, k3817, margin) {     const factor = g4284(color[0]);      margin /= factor[k3817];       const f3822 = [...color];     const j3161 = color[k3817+1];      const d = 0.001;       let m3820  = j3161,          a3821 = j3161;      let c3818  = k150(color);     let  n3819 = c3818;       let x3823 = 1/d*2;       while (   !c3818            && ! n3819            && x3823-- > 0)     {         m3820  -= d;  c3818  = o1801(m3820 , k3817, f3822);          a3821 += d;   n3819 = o1801( a3821, k3817, f3822);     }       x3823 = 1/d*2;     color = [...f3822];       if (c3818)      {          c3818 = k150(color);         m3820     = j3161;          while (   !c3818                && margin > 0                && x3823-- > 0)         {             m3820 -= d;              c3818 = o1801(m3820, k3817, f3822);             margin -= Math.sign(margin) * d;         }          color[k3817+1] = m3820;     }     else if (n3819)     {          n3819 = k150(color);         a3821     = j3161;          while (   !n3819                && margin > 0                && x3823-- > 0)         {             a3821 += d;              n3819 = o1801(a3821, k3817, f3822);             margin -= Math.sign(margin) * d;         }          color[k3817+1] = a3821;     }       return color; }    function o1801(c, k3817, f3822) {     let color = [...f3822];     color[k3817+1] = c;      return k150(color); }    function a1802(order) {     switch (order)     {         case 0: return [0, 1, 2];         case 1: return [1, 0, 2];         case 2: return [1, 2, 0];         case 3: return [0, 2, 1];         case 4: return [2, 0, 1];         case 5: return [2, 1, 0];     }           h951('invalid correction order ' + order);     return [0, 0, 0]; }    function b1803(space, order) {     const [c1, c2, c3] = a1802(order);      let min;      switch (space)     {         case 'hex':         case 'rgb':   min = [0, 0, 0]; break;          case 'hsv':          case 'hsl':   min = [0, 0, 0]; break;          case 'hclok':         case 'hclab':         case 'hcluv': min = [0, 0, 0]; break;          case 'oklab':         case 'lab':         case 'luv':   min = [0, -a4222[1]/2, -a4222[2]/2]; break;                  default:                          h951('invalid validation order ' + order);             return [0, 0, 0];     }      return [min[c1], min[c2], min[c3]]; }    function l1804(space, order) {     const [c1, c2, c3] = a1802(order);      let max;      switch (space)     {         case 'hex':         case 'rgb':   max = [...k4219]; break;          case 'hsv':          case 'hsl':   max = [c4220[0]/2, c4220[1], c4220[2]]; break;          case 'hclok':         case 'hclab':         case 'hcluv': max = [n4221[0]/2, n4221[1], n4221[2]]; break;          case 'oklab':         case 'lab':         case 'luv':   max = [...a4222]; break;                  default:                          h951('invalid validation order ' + order);             return [0, 0, 0];     }      return [max[c1], max[c2], max[c3]]; }    function reorderCorrection(w1808,                            i1809, r1810, g1811,                            n3809,  o3810,  s3811) {     let c1 = { closest: i1809, locked: n3809 };     let c2 = { closest: r1810, locked: o3810 };     let c3 = { closest: g1811, locked: s3811 };      if (   c1.closest <  Epsilon         && c2.closest <  Epsilon         && c3.closest >= Epsilon)     {         switch (w1808)         {             case 0: w1808 = 4; break;             case 1: w1808 = 5; break;             case 2: w1808 = 0; break;             case 3: w1808 = 1; break;             case 4: w1808 = 2; break;             case 5: w1808 = 3; break;         }          const tmp = c2;         c1 = c3;         c2 = c1;         c3 = tmp;     }     else if (c1.closest >= Epsilon           && c2.closest <  Epsilon)     {         switch (w1808)         {             case 0: w1808 = 3; break;             case 1: w1808 = 2; break;             case 2: w1808 = 1; break;             case 3: w1808 = 0; break;             case 4: w1808 = 5; break;             case 5: w1808 = 4; break;         }          const tmp = c2;         c2 = c3;         c3 = tmp;     }     else if (c1.closest < Epsilon)     {         switch (w1808)         {             case 0: w1808 = 2; break;             case 1: w1808 = 3; break;             case 2: w1808 = 4; break;             case 3: w1808 = 5; break;             case 4: w1808 = 0; break;             case 5: w1808 = 1; break;         }          const tmp = c1;         c1 = c2;         c2 = c3;         c3 = tmp;     }       return [         w1808,         c1.closest, c2.closest, c3.closest,         c1.locked,  c2.locked,  c3.locked ]; }    function o1805(n133) {     switch (n133)     {     case 'hex':     case 'rgb':         return [             new e1796('R', k4219[0]),             new e1796('G', k4219[1]),             new e1796('B', k4219[2]) ];      case 'hsv':         return [             new e1796('H', c4220[0]/2),             new e1796('S', c4220[1]),             new e1796('B', c4220[2]) ];      case 'hsl':         return [             new e1796('H', c4220[0]/2),             new e1796('S', c4220[1]),             new e1796('L', c4220[2]) ];      case 'hclok':     case 'hclab':     case 'hcluv':         return [             new e1796('H', n4221[0]/2),             new e1796('C', n4221[1]),             new e1796('L', n4221[2]) ];      case 'oklab':      case 'lab':         return [             new e1796('L', a4222[0]),             new e1796('a', a4222[1]),             new e1796('b', a4222[2]) ];      case 'luv':         return [             new e1796('L', a4222[0]),             new e1796('u', a4222[1]),             new e1796('v', a4222[2]) ];     }       h951('invalid color space ' + n133);     return [         new e1796(),         new e1796(),         new e1796() ]; }


class h1815 extends l2044 {     space   = null;         b3779      = null;    f3780      = null;    h3781      = null;          c1      = null;     c2      = null;     c3      = null;      convert = null;          g3362;        constructor(nodeId, options)     {         super(f1168, nodeId, options);     }                reset()     {         super.reset();                  this.space   = null;                  this.b3779     = null;         this.f3780     = null;         this.h3781     = null;                  this.c1      = null;         this.c2      = null;         this.c3      = null;              this.convert = null;     }        copy()     {         const copy = new h1815(this.nodeId, this.options);          copy.t3455(this);          copy.space = this.space.copy();          if (this.b3779) copy.b3779 = this.b3779.copy();         if (this.f3780) copy.f3780 = this.f3780.copy();         if (this.h3781) copy.h3781 = this.h3781.copy();          if (this. c1) copy. c1 = this. c1.copy();         if (this. c2) copy. c2 = this. c2.copy();         if (this. c3) copy. c3 = this. c3.copy();          if (this.convert)              copy.convert = this.convert.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalColorValue (this.input, parse);         let   space = await evalNumberValue(this.space, parse);          let   c1    = await evalNumberValue(this.b3779,   parse);         let   c2    = await evalNumberValue(this.f3780,   parse);         let   c3    = await evalNumberValue(this.h3781,   parse);          if (space) space = space.v3824();                   if (input)         {             if (   input.isValid()                 && input.type == j1167)             {                 if (this.options.enabled)                 {                     this.value        = input.copy();                     this.value.nodeId = this.nodeId;                      this.value.d3721(input);                                                   const fromSpaceIndex = input.space.value;                     const   toSpaceIndex = Math.min(Math.max(                         0,                         Math.round(space.value)),                          r131.length-1);                       if (toSpaceIndex != fromSpaceIndex)                     {                         this.convertColor(                             this.value,                             n133(fromSpaceIndex),                              n133(  toSpaceIndex));                          this.value.space.value = toSpaceIndex;                     }                      if (!c1) c1 = this.value.c1;                     if (!c2) c2 = this.value.c2;                     if (!c3) c3 = this.value.c3;                       if (c1) { this.value.c1 = c1; this.c1 = c1; }                     if (c2) { this.value.c2 = c2; this.c2 = c2; }                     if (c3) { this.value.c3 = c3; this.c3 = c3; }                 }                 else                     this.value = input.copy();             }             else                 this.value = d2010.NaN();                               if (!this.convert)                 this.convert = k2022.NaN();         }         else if (space               && c1               && c2               && c3)         {             this.value = new d2010(space, c1, c2, c3);               const toSpaceIndex = Math.min(Math.max(                 0,                 Math.round(this.value.space.value)),                  r131.length-1);              this.value.space.value = toSpaceIndex;               if (    this.convert                 &&  this.convert.isValid()                 &&  this.convert.value > -1                 &&  this.value.isValid()                 && !this.g3362)             {                 await this.convert.eval(parse);                  this.convertColor(                     this.value,                     n133(this.convert.value),                      n133(toSpaceIndex));             }         }         else             this.value = d2010.NaN();           if (!this.value.space.isValid())             this.value = new d2010(                 this.space ? this.space.toNewValue() : k2022.NaN(),                 k2022.NaN(),                 k2022.NaN(),                 k2022.NaN());                   if (this.convert) this.convert.parent = this;         if (this.space  ) this.space  .parent = this;         if (this.c1     ) this.c1     .parent = this;         if (this.c2     ) this.c2     .parent = this;         if (this.c3     ) this.c3     .parent = this;           this.c4193(parse,         [             ['value',   this.value      ],             ['convert', this.convert    ],             ['space',   this.value.space],             ['c1',      this.value.c1   ],             ['c2',      this.value.c2   ],             ['c3',      this.value.c3   ]         ]);           this.validate();          return this;     }        convertColor(color, fromSpace, n3303)     {         let col = [             fromSpace,              a4268(color.c1.value, fromSpace, 0),             a4268(color.c2.value, fromSpace, 1),             a4268(color.c3.value, fromSpace, 2) ];          col = t4279(y4288(col, n3303));          color.c1.value = col[1];         color.c2.value = col[2];         color.c3.value = col[3];     }        updateValueFromParam(m3091, value)     {              if (m3091 == 'c1') this.b3779 = value;         else if (m3091 == 'c2') this.f3780 = value;         else if (m3091 == 'c3') this.h3781 = value;         else              super.updateValueFromParam(m3091, value);     }        toNewValue()     {         return this.options.enabled              ? this.value.copy()              : d2010.NaN();     }        isValid()     {         return (!this.input || this.input.isValid())             && this.space && this.space.isValid()             && this.c1    && this.c1   .isValid()             && this.c2    && this.c2   .isValid()             && this.c3    && this.c3   .isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.space) this.space.p4180(parse);         if (this.b3779  ) this.b3779  .p4180(parse);         if (this.f3780  ) this.f3780  .p4180(parse);         if (this.h3781  ) this.h3781  .p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.space) this.space.i4181(parse, from, force);         if (this.b3779  ) this.b3779  .i4181(parse, from, force);         if (this.f3780  ) this.f3780  .i4181(parse, from, force);         if (this.h3781  ) this.h3781  .i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.space) this.space.i4179(parse);         if (this.b3779  ) this.b3779  .i4179(parse);         if (this.f3780  ) this.f3780  .i4179(parse);         if (this.h3781  ) this.h3781  .i4179(parse);     } }


class m1822 extends l2044 {     method       = null;      corrections  = [];        constructor(nodeId, options)     {         super(t1169, nodeId, options);     }            reset()     {         super.reset();          this.method      = null;         this.corrections = [];     }        copy()     {         const copy = new m1822(this.nodeId, this.options);          copy.t3455(this);          if (this.value ) copy.value  = this.value .copy();         if (this.method) copy.method = this.method.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalColorValue (this.input,   parse);         const method = await evalNumberValue(this.method, parse);           if (input)         {             if (this.options.enabled)             {                 if (o955(input.type))                 {                     this.value = new w2021();                      for (let i = 0; i < input.items.length; i++)                         this.value.items.push(await t2903(parse, this, input.items[i], method));                 }                 else                     this.value = await t2903(parse, this, input, method);             }             else                 this.value = input.copy();         }         else             this.value = d2010.NaN();                    this.c4193(parse,         [             ['value',  this.value       ],             ['type',   this.outputType()],             ['method', method           ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.method && this.method.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.method) this.method.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.method) this.method.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.method) this.method.i4179(parse);     } }    async function t2903(parse, node, input, method) {     let rgb = input.t3339();      if (method.value == 0)      {         rgb[0] = Math.round(Math.min(Math.max(0, rgb[0]), 1) * 0xff);            rgb[1] = Math.round(Math.min(Math.max(0, rgb[1]), 1) * 0xff);            rgb[2] = Math.round(Math.min(Math.max(0, rgb[2]), 1) * 0xff);                   return d2010.t3868(rgb);     }     else if (method.value == 1)      {         rgb = l129(rgb);          rgb[0] = Math.round(rgb[0] * 0xff);         rgb[1] = Math.round(rgb[1] * 0xff);         rgb[2] = Math.round(rgb[2] * 0xff);          return d2010.t3868(rgb);     }     else      {         const inputColor = input.c3338();          if (!q78(rgb))             b2077(node.nodeId);                   const       [ w1808,         i1809,         r1810,         g1811 ] = await f1797(             parse,             node.nodeId,             inputColor,             null,   null,  null,  null,             false,  false, false, false);                       if (!parse.r3736)         {             if (   w1808 >= 0                 && w1808 <  6)             {                 node.f3296 = w1799(                     inputColor,                     w1808,                     i1809,                     r1810,                     g1811);                  return d2010.b2904(node.f3296);             }             else             {                 return d2010.NaN();             }         }     }           return d2010.NaN(); }


class p1821 extends l2044 {     r3778  = null;     b3779     = null;     f3780     = null;     h3781     = null;          order   = null;     c1      = null;     c2      = null;     c3      = null;      corrections = [];        constructor(nodeId, options)     {         super(o1170, nodeId, options);     }            reset()     {         super.reset();          this.r3778  = null;         this.b3779     = null;         this.f3780     = null;         this.h3781     = null;                  this.order   = null;         this.c1      = null;         this.c2      = null;         this.c3      = null;              this.corrections = [];     }        copy()     {         const copy = new p1821(this.nodeId, this.options);          copy.t3455(this);                  if (this.r3778) copy.r3778 = this.order .copy();         if (this.b3779   ) copy.b3779    = this.b3779   .copy();         if (this.f3780   ) copy.f3780    = this.f3780   .copy();         if (this.h3781   ) copy.h3781    = this.h3781   .copy();                  if (this. order) copy. order = this.order .copy();         if (this. c1   ) copy. c1    = this. c1   .copy();         if (this. c2   ) copy. c2    = this. c2   .copy();         if (this. c3   ) copy. c3    = this. c3   .copy();                  if (this.value ) copy. value = this. value.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           let   input = await evalColorValue (this. input, parse);         let   order = await evalNumberValue(this.r3778, parse);         let   c1    = await evalNumberValue(this.b3779,    parse);         let   c2    = await evalNumberValue(this.f3780,    parse);         let   c3    = await evalNumberValue(this.h3781,    parse);           if (order)          {             order       = order.v3824();             order.value = Math.min(Math.max(0, order.value), 5);         }           if (order && !order.isValid()) order = null;         if (c1    && !c1   .isValid()) c1    = null;         if (c2    && !c2   .isValid()) c2    = null;         if (c3    && !c3   .isValid()) c3    = null;           if (input)         {                  if (input.type == d1177      ) input = input.color;             else if (input.type == i1183) input = input.fill.color;             else if (input.type == c1186  ) input = d2010.t3868(input.d99());               if (this.options.enabled)             {                 const inputColor = input.c3338();                  if (!k150(inputColor))                     b2077(this.nodeId);                   const               [ w1808,                 i1809,                 r1810,                 g1811 ] = await f1797(                     parse,                     this.nodeId,                     inputColor,                      order, c1, c2, c3,                      order != null,                     c1    != null,                      c2    != null,                      c3    != null);                                       if (    !parse.r3736)                 {                     if (   w1808 >= 0                          && w1808 <  6)                     {                         this.f3296 = w1799(                             inputColor,                             w1808,                             i1809,                             r1810,                             g1811);                           this.order = new k2022(w1808);                         this.c1    = new k2022(i1809);                         this.c2    = new k2022(r1810);                         this.c3    = new k2022(g1811);                                                   this.value = d2010.b2904(this.f3296);                          this.value.c1.decimals = input.c1.decimals;                         this.value.c2.decimals = input.c2.decimals;                         this.value.c3.decimals = input.c3.decimals;                           this.c4193(parse,                         [                             ['order', new k2022(w1808, 0)],                             ['c1',    new k2022(i1809,     1)],                             ['c2',    new k2022(r1810,     1)],                             ['c3',    new k2022(g1811,     1)],                             ['value', this.value                      ]                         ]);                     }                     else                     {                         this.order = k2022.NaN();                         this.c1    = k2022.NaN();                         this.c2    = k2022.NaN();                         this.c3    = k2022.NaN();                         this.value = input.copy();                                  this.c4193(parse,                         [                             ['order', this.order],                             ['c1',    this.c1   ],                             ['c2',    this.c2   ],                             ['c3',    this.c3   ],                             ['value', this.value]                         ]);                     }                 }                 else                 {                     this.order = k2022.NaN();                     this.c1    = k2022.NaN();                     this.c2    = k2022.NaN();                     this.c3    = k2022.NaN();                     this.value = input.copy();                          this.c4193(parse,                     [                         ['order', this.order],                         ['c1',    this.c1   ],                         ['c2',    this.c2   ],                         ['c3',    this.c3   ],                         ['value', this.value]                     ]);                 }             }             else             {                 this.order = k2022.NaN();                 this.c1    = k2022.NaN();                 this.c2    = k2022.NaN();                 this.c3    = k2022.NaN();                 this.value = input.copy();                  this.c4193(parse,                 [                     ['order', this.order],                     ['c1',    this.c1   ],                     ['c2',    this.c2   ],                     ['c3',    this.c3   ],                     ['value', this.value]                 ]);             }         }         else         {             this.order = k2022.NaN();             this.c1    = k2022.NaN();             this.c2    = k2022.NaN();             this.c3    = k2022.NaN();             this.value = d2010 .NaN();              this.c4193(parse,             [                 ['order', k2022.NaN()],                 ['c1',    k2022.NaN()],                 ['c2',    k2022.NaN()],                 ['c3',    k2022.NaN()],                 ['value', d2010 .NaN()]             ]);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.order && this.order.isValid()             && this.c1    && this.c1   .isValid()             && this.c2    && this.c2   .isValid()             && this.c3    && this.c3   .isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.r3778) this.r3778.p4180(parse);         if (this.b3779   ) this.b3779   .p4180(parse);         if (this.f3780   ) this.f3780   .p4180(parse);         if (this.h3781   ) this.h3781   .p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.r3778) this.r3778.i4181(parse, from, force);         if (this.b3779   ) this.b3779   .i4181(parse, from, force);         if (this.f3780   ) this.f3780   .i4181(parse, from, force);         if (this.h3781   ) this.h3781   .i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.r3778) this.r3778.i4179(parse);         if (this.b3779   ) this.b3779   .i4179(parse);         if (this.f3780   ) this.f3780   .i4179(parse);         if (this.h3781   ) this.h3781   .i4179(parse);     } } 


class s1818 extends s2045 {     standard = null;     contrast = null;       constructor(nodeId, options)     {         super(b1171, nodeId, options);     }        reset()     {         super.reset();          this.standard = null;         this.contrast = null;     }        copy()     {         const copy = new s1818(this.nodeId, this.options);          copy.t3455(this);          if (this.standard) copy.standard = this.standard.copy();         if (this.contrast) copy.contrast = this.contrast.copy();          return copy;     }            async eval(parse)     {         if (this.isCached())             return this;           const o4175    = await evalColorValue (this.o4175,   parse);         const i4176    = await evalColorValue (this.i4176,   parse);         const standard  = await evalNumberValue(this.standard, parse);                   if (standard.isValid())             standard.value = Math.min(Math.max(0, standard.value), 1);           if (   o4175 && o4175.type == j1167              && i4176 && i4176.type == j1167)         {             if (   o4175.isValid()                 && i4176.isValid())             {                 if (   c149(o4175.c3338())                     && c149(i4176.c3338()))                 {                     if (standard.value == 0)                     {                         const value = s157(o4175.t3339(), i4176.t3339());                         this.contrast = new k2022(value, 2);                     }                     else                     {                         const value = b161(o4175.t3339(), i4176.t3339());                         this.contrast = new k2022(value, 1);                     }                 }                 else                     this.contrast = k2022.NaN();             }             else                 this.contrast = k2022.NaN();               this.c4193(parse,             [                 ['text', o4175],                 ['back', i4176]             ]);         }          else if (o4175 && o4175.type == j1167)          {             this.c4193(parse,             [                 ['text', o4175.isValid() ? o4175 : d2010.NaN()],                 ['back', d2010.NaN()                            ]             ]);                          this.contrast = k2022.NaN();         }          else if (i4176 && i4176.type == j1167)          {             this.c4193(parse,             [                 ['text', d2010.NaN()                            ],                 ['back', i4176.isValid() ? i4176 : d2010.NaN()]             ]);              this.contrast = k2022.NaN();         }          else         {             this.contrast = k2022.NaN();              this.c4193(parse,             [                 ['text', d2010.NaN()],                 ['back', d2010.NaN()]             ]);         }                   this.value = o4175 ?? d2010.NaN();           this.c4193(parse,         [             ['standard', standard     ],             ['contrast', this.contrast]         ],         true);           this.validate();           return this;     }        isValid()     {         return super.isValid()             && this.standard && this.standard.isValid()             && (!this.contrast || this.contrast.isValid());     }        p4180(parse)     {         super.p4180(parse);          if (this.standard) this.standard.p4180(parse);         if (this.contrast) this.contrast.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.standard) this.standard.i4181(parse, from, force);         if (this.contrast) this.contrast.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.standard) this.standard.i4179(parse);         if (this.contrast) this.contrast.i4179(parse);     } } 


class w2586 extends s2045 {     deltaE = null;     space  = null;     e4261 = null;     q4262 = null;     z4263 = null;        constructor(nodeId, options)     {         super(o1172, nodeId, options);     }        reset()     {         super.reset();          this.deltaE = null;         this.space  = null;         this.e4261 = null;         this.q4262 = null;         this.z4263 = null;     }        copy()     {         const copy = new w2586(this.nodeId, this.options);          copy.t3455(this);          if (this.deltaE) copy.deltaE = this.deltaE.copy();         if (this.space ) copy.space  = this.space .copy();         if (this.e4261) copy.e4261 = this.e4261.copy();         if (this.q4262) copy.q4262 = this.q4262.copy();         if (this.z4263) copy.z4263 = this.z4263.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const o4175 = await evalColorValue(this.o4175, parse);         const i4176 = await evalColorValue(this.i4176, parse);         const deltaE = await evalColorValue(this.deltaE, parse);         const space  = await evalColorValue(this.space , parse);         const e4261 = await evalColorValue(this.e4261, parse);         const q4262 = await evalColorValue(this.q4262, parse);         const z4263 = await evalColorValue(this.z4263, parse);                   if (   o4175 && o4175.type == j1167              && i4176 && i4176.type == j1167)         {             if (   o4175.isValid()                 && i4176.isValid())             {                 let _rgb2lab, dE;                                  switch (space.value)                 {                     case 0: _rgb2lab = p4076; break;                     case 1: _rgb2lab = d55;   break;                 }                  switch (deltaE.value)                 {                     case 0:                          dE = deltaE76(                             o4175.t3339(),                              i4176.t3339(),                             _rgb2lab);                          break;                                              case 1:                          dE = deltaE94(                             o4175.t3339(),                              i4176.t3339(),                             e4261.value/100,                             q4262.value/100,                             z4263.value/100,                             _rgb2lab);                          break;                      case 2:                          dE = deltaE00(                             o4175.t3339(),                              i4176.t3339(),                             e4261.value/100,                             q4262.value/100,                             z4263.value/100,                             _rgb2lab);                          break;                      case 3:                          dE = deltaECMC(                             o4175.t3339(),                              i4176.t3339(),                             e4261.value/100,                             q4262.value/100,                             _rgb2lab);                          break;                      case 4:                          dE = deltaEITU(                             o4175.t3339(),                              i4176.t3339());                          break;                 }                  this.value = new k2022(dE * 100, 1);             }             else                 this.value = k2022.NaN();         }         else             this.value = k2022.NaN();                   this.c4193(parse,         [             ['type',   this.outputType()],             ['value',  this.value       ],             ['deltaE', deltaE           ],             ['space',  space            ],             ['param1', e4261           ],             ['param2', q4262           ],             ['param3', z4263           ]         ]);           this.validate();           return this;     }        isValid()     {         return super.isValid()             && this.deltaE && this.deltaE.isValid()             && this.space  && this.space .isValid()             && this.e4261 && this.e4261.isValid()             && this.q4262 && this.q4262.isValid()             && this.z4263 && this.z4263.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.deltaE) this.deltaE.p4180(parse);         if (this.space ) this.space .p4180(parse);         if (this.e4261) this.e4261.p4180(parse);         if (this.q4262) this.q4262.p4180(parse);         if (this.z4263) this.z4263.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.deltaE) this.deltaE.i4181(parse, from, force);         if (this.space ) this.space .i4181(parse, from, force);         if (this.e4261) this.e4261.i4181(parse, from, force);         if (this.q4262) this.q4262.i4181(parse, from, force);         if (this.z4263) this.z4263.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.deltaE) this.deltaE.i4179(parse);         if (this.space ) this.space .i4179(parse);         if (this.e4261) this.e4261.i4179(parse);         if (this.q4262) this.q4262.i4179(parse);         if (this.z4263) this.z4263.i4179(parse);     } } 


class y1817 extends l2044 {     l;     m;     s;       constructor(nodeId, options)     {         super(t1173, nodeId, options);     }            reset()     {         super.reset();          this.l = null;         this.m = null;         this.s = null;     }        copy()     {         const copy = new y1817(this.nodeId, this.options);          copy.t3455(this);          if (this.l) copy.l = this.l.copy();         if (this.m) copy.m = this.m.copy();         if (this.s) copy.s = this.s.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           let   input = await evalColorValue (this.input, parse);         const l     = await evalNumberValue(this.l,     parse);          const m     = await evalNumberValue(this.m,     parse);         const s     = await evalNumberValue(this.s,     parse);           if (input)         {                  if (input.type == d1177      ) input = input.color;             else if (input.type == i1183) input = input.fill.color;             else if (input.type == c1186  ) input = d2010.t3868(input.d99());               if (this.options.enabled)             {                 if (o955(input.type))                 {                     this.value = new w2021();                      for (let i = 0; i < input.items.length; i++)                         this.value.items.push(getColorBlindValue(input.items[i], l, m, s));                 }                 else                     this.value = getColorBlindValue(input, l, m, s);             }             else                 this.value = input.copy();         }         else             this.value = d2010.NaN();           this.c4193(parse,         [             ['value',  this.value       ],             ['type',   this.outputType()],             ['l',      l                ],             ['m',      m                ],             ['s',      s                ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.l && this.l.isValid()             && this.m && this.m.isValid()             && this.s && this.s.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.l) this.l.p4180(parse);         if (this.m) this.m.p4180(parse);         if (this.s) this.s.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.l) this.l.i4181(parse, from, force);         if (this.m) this.m.i4181(parse, from, force);         if (this.s) this.s.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.l) this.l.i4179(parse);         if (this.m) this.m.i4179(parse);         if (this.s) this.s.i4179(parse);     } }    function getColorBlindValue(input, l, m, s) {     const rgb   = input.t3339();      const rgbCb = b134(         rgb,         l.value / 2,         m.value / 2,         s.value / 2);      if (   !i73(rgb  )         && !i73(rgbCb))     {         const validRgbCb = rgbCb;              const validCol = y4288(             m146(validRgbCb),              n133(input.space.value));          return d2010.b2904(validCol);     }     else         return d2010.NaN(); }


class a2581 extends l2044 {     schemeType = null;     space      = null;        constructor(nodeId, options)     {         super(COLOR_SCHEME, nodeId, options);     }            reset()     {         super.reset();          this.schemeType = null;         this.space      = null;     }        copy()     {         const copy = new a2581(this.nodeId, this.options);          copy.t3455(this);          if (this.value     ) copy.value      = this.value     .copy();         if (this.schemeType) copy.schemeType = this.schemeType.copy();         if (this.space     ) copy.space      = this.space     .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input      = await evalColorValue (this.input,      parse);         const schemeType = await evalNumberValue(this.schemeType, parse);         const space      = await evalNumberValue(this.space,      parse);           if (input)         {             if (this.options.enabled)             {                 this.value = new w2021();                   const rgb = input.t3339();                   let addHue;                  switch (space.value)                 {                     case 0: addHue = addHueHsl;   break;                     case 1: addHue = addHueHclok; break;                     case 2: addHue = addHueHclab; break;                     case 3: addHue = addHueHcluv; break;                 }                   function getColor(rgb)                 {                     const color = y4288(                         m146(rgb),                          n133(input.space.value));                      return d2010.b2904(color);                 }                    switch (schemeType.value)                 {                     case 0:                      {                         this.value.items.push(getColor(addHue(rgb, 10/12, 0, 1)));                         this.value.items.push(getColor(addHue(rgb,  0,    0, 1)));                         this.value.items.push(getColor(addHue(rgb,  2/12, 0, 1)));                         break;                     }                      case 1:                      {                         this.value.items.push(getColor(addHue(rgb, 11/12, 0, 1)));                         this.value.items.push(getColor(addHue(rgb,  0,    0, 1)));                         this.value.items.push(getColor(addHue(rgb,  1/12, 0, 1)));                         break;                     }                      case 2:                      {                         this.value.items.push(getColor(addHue(rgb, 11/12, 0, 1)));                         this.value.items.push(getColor(addHue(rgb,  0,    0, 1)));                         this.value.items.push(getColor(addHue(rgb,  1/12, 0, 1)));                         this.value.items.push(getColor(addHue(rgb,  6/12, 0, 1)));                         break;                     }                      case 3:                      {                         this.value.items.push(getColor(addHue(rgb,  0,    0, 1)));                         this.value.items.push(getColor(addHue(rgb,  6/12, 0, 1)));                         break;                     }                      case 4:                      {                         this.value.items.push(getColor(addHue(rgb,  0,    0, 1)));                         this.value.items.push(getColor(addHue(rgb,  5/12, 0, 1)));                         break;                     }                      case 5:                      {                         this.value.items.push(getColor(addHue(rgb,  0,    0, 1)));                         this.value.items.push(getColor(addHue(rgb,  7/12, 0, 1)));                         break;                     }                      case 6:                      {                         this.value.items.push(getColor(addHue(rgb,  0,    0, 1)));                         this.value.items.push(getColor(addHue(rgb,  5/12, 0, 1)));                         this.value.items.push(getColor(addHue(rgb,  7/12, 0, 1)));                         break;                     }                      case 7:                      {                         this.value.items.push(getColor(addHue(rgb,  0,    0, 1)));                         this.value.items.push(getColor(addHue(rgb,  4/12, 0, 1)));                         this.value.items.push(getColor(addHue(rgb,  8/12, 0, 1)));                         break;                     }                      case 8:                      {                         this.value.items.push(getColor(addHue(rgb,   0,    0, 1)));                         this.value.items.push(getColor(addHue(rgb,  11/12, 0, 1)));                         this.value.items.push(getColor(addHue(rgb,   6/12, 0, 1)));                         this.value.items.push(getColor(addHue(rgb,   5/12, 0, 1)));                         break;                     }                      case 9:                      {                         this.value.items.push(getColor(addHue(rgb,  0,    0, 1)));                         this.value.items.push(getColor(addHue(rgb, 10/12, 0, 1)));                         this.value.items.push(getColor(addHue(rgb,  6/12, 0, 1)));                         this.value.items.push(getColor(addHue(rgb,  4/12, 0, 1)));                         break;                     }                      case 10:                      {                         this.value.items.push(getColor(addHue(rgb,  0,    0, 1)));                         this.value.items.push(getColor(addHue(rgb,  2/12, 0, 1)));                         this.value.items.push(getColor(addHue(rgb,  6/12, 0, 1)));                         this.value.items.push(getColor(addHue(rgb,  8/12, 0, 1)));                         break;                     }                      case 11:                      {                         this.value.items.push(getColor(addHue(rgb,  0,    0, 1)));                         this.value.items.push(getColor(addHue(rgb,  1/12, 0, 1)));                         this.value.items.push(getColor(addHue(rgb,  6/12, 0, 1)));                         this.value.items.push(getColor(addHue(rgb,  7/12, 0, 1)));                         break;                     }                      case 12:                      {                         this.value.items.push(getColor(addHue(rgb,  0,    0, 1)));                         this.value.items.push(getColor(addHue(rgb,  3/12, 0, 1)));                         this.value.items.push(getColor(addHue(rgb,  6/12, 0, 1)));                         this.value.items.push(getColor(addHue(rgb,  9/12, 0, 1)));                         break;                     }                      case 13:                      {                         this.value.items.push(getColor(addHue(rgb,  0,    0, 1)));                         this.value.items.push(getColor(addHue(rgb,  2/12, 0, 1)));                         this.value.items.push(getColor(addHue(rgb,  4/12, 0, 1)));                         this.value.items.push(getColor(addHue(rgb,  6/12, 0, 1)));                         this.value.items.push(getColor(addHue(rgb,  8/12, 0, 1)));                         this.value.items.push(getColor(addHue(rgb, 10/12, 0, 1)));                         break;                     }                 }             }             else                 this.value = input.copy();         }         else             this.value = new w2021();           this.c4193(parse,         [             ['value',      this.value       ],             ['type',       this.outputType()],             ['schemeType', schemeType       ],             ['space',      space            ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.schemeType && this.schemeType.isValid()             && this.space      && this.space     .isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.schemeType) this.schemeType.p4180(parse);         if (this.space     ) this.space     .p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.schemeType) this.schemeType.i4181(parse, from, force);         if (this.space     ) this.space     .i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.schemeType) this.schemeType.i4179(parse);         if (this.space     ) this.space     .i4179(parse);     } } 


class v1819 extends i2043 {     inputs = [];      space;     gamma;     amount;     degree;        constructor(nodeId, options)     {         super(a1174, nodeId, options);     }            reset()     {         super.reset();          this.inputs = [];          this.space  = null;         this.gamma  = null;         this.amount = null;         this.degree = null;     }        copy()     {         const copy = new v1819(this.nodeId, this.options);          copy.t3455(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.space ) copy.space  = this.space .copy();         if (this.gamma ) copy.gamma  = this.gamma .copy();         if (this.amount) copy.amount = this.amount.copy();         if (this.degree) copy.degree = this.degree.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           let   inputs = await Promise.all(this.inputs.map(async i => await evalColorStopValue(i, parse)));         let   space  = await evalNumberValue(this.space,  parse);         const gamma  = await evalNumberValue(this.gamma,  parse);         const amount = await evalNumberValue(this.amount, parse);         const degree = await evalNumberValue(this.degree, parse);          if (space) space = space.v3824();                   const _gamma = Math.max(0.0001, gamma.value);         const _space = n133(space.value);           let maxInputColorType = j1167;                  for (const input of inputs)         {             if (input.type == d1177)                 maxInputColorType = d1177;         }           inputs = u1827(inputs);          a1829(inputs);         inputs.sort((a, b) => a.position.value - b.position.value);            const opacities = inputs.map(i => i.fill.opacity);                   const nSegments = Math.floor(inputs.length-1);           let index = 0;          for (let i = 0; i < inputs.length-1; i++)         {             if (   amount.value/100 >= inputs[i  ].position.value/100                 && amount.value/100 <= inputs[i+1].position.value/100)             {                 index = i;                 break;             }         }           if (inputs.length == 1)             this.value = inputs[0].fill;          else if (inputs.length > 0               && index < inputs.length-1)         {             let localAmount =                  nSegments > 1                 ? (amount.value/100 - inputs[index].position.value/100) / (inputs[index+1].position.value/100 - inputs[index].position.value/100)                  : amount.value/100;               const y3785 = inputs[index  ];             const val1 = inputs[index+1];              if (degree.value == 1)                 localAmount = lerpCos(0, 1, localAmount);              this.value = new c2013(                 d2010.b2904(v1819.interpolate(                     space.value,                      y4288(y3785.fill.color.c3338(), _space),                      y4288(val1.fill.color.c3338(), _space),                     localAmount,                     _gamma)),                 new k2022(q1033(                     opacities[index  ].value,                     opacities[index+1].value,                     localAmount)));         }         else                               this.value = d2010.NaN();                           if (   this.value.type   == d1177             && maxInputColorType == j1167)              this.value = this.value.color;           this.c4193(parse,         [             ['value',  this.value       ],             ['type',   this.outputType()],             ['space',  space            ],             ['gamma',  gamma            ],             ['amount', amount           ],             ['degree', degree           ]         ]);                   this.validate();                  return this;     }        static interpolate(space, col0, v103, f, gamma)     {         if (   space ==  2               || space ==  3               || space ==  9               || space == 10               || space == 11)          {                 const h0 = col0[1] * Tau;  const h1 = v103[1] * Tau;                 const c0 = col0[2];        const c1 = v103[2];                 const l0 = col0[3];        const l1 = v103[3];                                  return [                     n133(space),                     s1036(h0 + o885(h0, h1) * f) / Tau,                     q1033(c0, c1, f),                     q1033(l0, l1, f) ];         }         else          {             gamma = Math.max(0.01, gamma);              const r0 = Math.sign(col0[1]) * Math.pow(Math.abs(col0[1]), gamma);               const g0 = Math.sign(col0[2]) * Math.pow(Math.abs(col0[2]), gamma);               const b0 = Math.sign(col0[3]) * Math.pow(Math.abs(col0[3]), gamma);                const r1 = Math.sign(v103[1]) * Math.pow(Math.abs(v103[1]), gamma);             const g1 = Math.sign(v103[2]) * Math.pow(Math.abs(v103[2]), gamma);             const b1 = Math.sign(v103[3]) * Math.pow(Math.abs(v103[3]), gamma);              const r = q1033(r0, r1, f);                     const g = q1033(g0, g1, f);                         const b = q1033(b0, b1, f);                      return [                 n133(space),                 Math.sign(r) * Math.pow(Math.abs(r), 1/gamma),                 Math.sign(g) * Math.pow(Math.abs(g), 1/gamma),                 Math.sign(b) * Math.pow(Math.abs(b), 1/gamma) ];         }     }        isValid()     {         return super.isValid()             &&  this.inputs.length > 0             && !this.inputs.find(i => !i.isValid())             &&  this.space  && this.space .isValid()             &&  this.gamma  && this.gamma .isValid()             &&  this.amount && this.amount.isValid()             &&  this.degree && this.degree.isValid();     }        p4180(parse)     {         super.p4180(parse);          this.inputs.forEach(i => i.p4180(parse));          if (this.space ) this.space .p4180(parse);         if (this.gamma ) this.gamma .p4180(parse);         if (this.amount) this.amount.p4180(parse);         if (this.degree) this.degree.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          this.inputs.forEach(i => i.i4181(parse, from, force));          if (this.space ) this.space .i4181(parse, from, force);         if (this.gamma ) this.gamma .i4181(parse, from, force);         if (this.amount) this.amount.i4181(parse, from, force);         if (this.degree) this.degree.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          this.inputs.forEach(i => i.i4179(parse));          if (this.space ) this.space .i4179(parse);         if (this.gamma ) this.gamma .i4179(parse);         if (this.amount) this.amount.i4179(parse);         if (this.degree) this.degree.i4179(parse);     } } 


class a1816 extends s2045 {     mode   = null;     amount = null;           constructor(nodeId, options)     {         super(s1175, nodeId, options);     }            reset()     {         super.reset();          this.mode   = null;         this.amount = null;     }        copy()     {         const copy = new a1816(this.nodeId, this.options);          copy.t3455(this);          if (this.mode  ) copy.mode   = this.mode  .copy();         if (this.amount) copy.amount = this.amount.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           let   o4175 = await evalColorValue (this.o4175, parse);         let   i4176 = await evalColorValue (this.i4176, parse);         let   mode   = await evalNumberValue(this.mode,   parse);         const amount = await evalNumberValue(this.amount, parse);                  if (mode) mode = mode.v3824();                if (o4175 && o4175.type == d1177      ) o4175 = o4175.color;         else if (o4175 && o4175.type == i1183) o4175 = o4175.fill.color;         else if (o4175 && o4175.type == c1186  ) o4175 = d2010.t3868(o4175.d99());          if (   o4175              && i4176)         {             c950(                 amount.type == c1090,                  'this.result.type must be NUMBER_VALUE');              const _amount = amount.value / 100;              const u3866 = Math.min(Math.max(0, mode.value), n1392.length-1);               const col = this.blend(                 u3866,                 o4175.t3339(),                 i4176.t3339(),                 _amount);              this.value = d2010.t3868(z4234(col, 2 ));         }          else if (o4175)              this.value = o4175;          else if (this.i4176)              this.value = i4176;                      else              this.value = d2010.NaN();           this.c4193(parse,         [             ['value',  this.value],             ['mode',   mode      ],             ['amount', amount    ]         ]);           this.validate();                  return this;     }        blend(mode, col0, v103, amount)     {         switch (mode)         {             case  BLEND_NORMAL_INDEX:       return y4340     (col0, v103, amount);              case  BLEND_DARKEN_INDEX:       return e4341     (col0, v103, amount);             case  BLEND_MULTIPLY_INDEX:     return a4342   (col0, v103, amount);             case  BLEND_PLUS_DARKER_INDEX:  return blendPlusDarker (col0, v103, amount);             case  BLEND_COLOR_BURN_INDEX:   return g4343  (col0, v103, amount);              case  BLEND_LIGHTEN_INDEX:      return v4344    (col0, v103, amount);             case  BLEND_SCREEN_INDEX:       return j4345     (col0, v103, amount);             case  BLEND_PLUS_LIGHTER_INDEX: return blendPlusLighter(col0, v103, amount);             case  BLEND_COLOR_DODGE_INDEX:  return f4347 (col0, v103, amount);              case  BLEND_OVERLAY_INDEX:      return n4349    (col0, v103, amount);             case  BLEND_SOFT_LIGHT_INDEX:   return u4350  (col0, v103, amount);             case  BLEND_HARD_LIGHT_INDEX:   return h4352  (col0, v103, amount);              case BLEND_DIFFERENCE_INDEX:    return u4354 (col0, v103);             case BLEND_EXCLUSION_INDEX:     return y4355  (col0, v103, amount);              case BLEND_HUE_INDEX:           return b4357        (col0, v103, amount);             case BLEND_SATURATION_INDEX:    return w4358 (col0, v103, amount);             case BLEND_COLOR_INDEX:         return w4359      (col0, v103, amount);             case BLEND_LUMINOSITY_INDEX:    return f4360 (col0, v103, amount);         }     }        isValid()     {         return super.isValid()             && this.mode   && this.mode  .isValid()             && this.amount && this.amount.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.mode  ) this.mode  .p4180(parse);         if (this.amount) this.amount.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.mode  ) this.mode  .i4181(parse, from, force);         if (this.amount) this.amount.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.mode  ) this.mode  .i4179(parse);         if (this.amount) this.amount.i4179(parse);     } } 


function y4340(col, back, amount) {     return [ hardPosZero(col[0] * amount + back[0] * (1 - amount), 0.005),              hardPosZero(col[1] * amount + back[1] * (1 - amount), 0.005),              hardPosZero(col[2] * amount + back[2] * (1 - amount), 0.005) ]; }    function e4341(col, back, amount) {     return y4340(         [ Math.min(back[0], col[0]),           Math.min(back[1], col[1]),           Math.min(back[2], col[2]) ],         back,         amount); }    function chanMultiply(c, b) {     return c * b; }    function a4342(col, back, amount) {     return y4340(         [ chanMultiply(col[0], back[0]),           chanMultiply(col[1], back[1]),           chanMultiply(col[2], back[2]) ],         back,         amount); }    function blendPlusDarker(col, back, amount) {     return y4340(         [ Math.min(back[0] + col[0], back[0], col[0]),           Math.min(back[1] + col[1], back[1], col[1]),           Math.min(back[2] + col[2], back[2], col[2]) ],         back,         amount); }    function chanColorBurn(c, b) {          if (b == 1) return 1;     else if (c == 0) return 0;     else             return Math.min(Math.max(0, 1 - (1 - b) / c), 1); }    function g4343(col, back, amount) {     return y4340(          [ chanColorBurn(col[0], back[0]),            chanColorBurn(col[1], back[1]),            chanColorBurn(col[2], back[2]) ],         back,         amount); }    function v4344(col, back, amount) {     return y4340(         [ Math.max(back[0], col[0]),           Math.max(back[1], col[1]),           Math.max(back[2], col[2]) ],         back,         amount); }    function q4346(c, b) {     return b + c - b*c; }    function j4345(col, back, amount) {     return y4340(         [ q4346(col[0], back[0]),           q4346(col[1], back[1]),           q4346(col[2], back[2]) ],         back,         amount); }    function blendPlusLighter(col, back, amount) {     return y4340(         [ Math.min(back[0] + col[0], 1),           Math.min(back[1] + col[1], 1),           Math.min(back[2] + col[2], 1) ],         back,         amount); }    function n4348(c, b) {          if (b == 0) return 0;     else if (c == 1) return 1;     else             return Math.min(b / (1 - c), 1); }    function f4347(col, back, amount) {     return y4340(         [ n4348(col[0], back[0]),           n4348(col[1], back[1]),           n4348(col[2], back[2]) ],         back,         amount); }    function n4349(col, back, amount) {     return y4340(         [ n4353(back[0], col[0]),           n4353(back[1], col[1]),           n4353(back[2], col[2]) ],         back,         amount); }    function j2905(b) {     return b <= 0.25          ? ((16 * b - 12) * b + 4) * b          : Math.sqrt(b); }    function i4351(c, b) {     return c <= 0.5          ? b - (1 - 2*c) * b * (1 - b)          : b + (2*c - 1) * (j2905(b) - b); }    function u4350(col, back, amount) {     return y4340(         [ i4351(col[0], back[0]),           i4351(col[1], back[1]),           i4351(col[2], back[2]) ],         back,         amount); }    function n4353(c, b) {     if (c <= 0.5) return chanMultiply(b, 2 * c);     else          return q4346(b, 2 * c - 1); }    function h4352(col, back, amount) {     return y4340(         [ n4353(col[0], back[0]),           n4353(col[1], back[1]),           n4353(col[2], back[2]) ],         back,         amount); }    function u4354(col, back) {     return [ Math.abs(back[0] - col[0]),              Math.abs(back[1] - col[1]),              Math.abs(back[2] - col[2]) ]; }    function z4356(c, b) {     return b + c - 2*b*c; }    function y4355(col, back, amount) {     return y4340(         [ z4356(col[0], back[0]),           z4356(col[1], back[1]),           z4356(col[2], back[2]) ],         back,         amount); }    function u2906(col) {     return col[0] * 0.30          + col[1] * 0.59          + col[2] * 0.11; }    function k2907(o127, l) {     const col = [...o127];      const d = l - u2906(col);      col[0] += d;     col[1] += d;     col[2] += d;      return q2915(col); }    function h2908(col) {     return Math.max(col[0], col[1], col[2])           - Math.min(col[0], col[1], col[2]); }    function z2909(col) {          if (col[0] <= col[1]            && col[0] <= col[2]) return 0;      else if (col[1] <= col[1]            && col[1] <= col[2]) return 1;                else                       return 2; }    function u2910(col) {          if (   col[0] >= col[1]               && col[0] <= col[2]           ||    col[0] <= col[1]               && col[0] >= col[2]) return 0;                   else if (   col[1] >= col[0]               && col[1] <= col[2]           ||    col[1] <= col[0]               && col[1] >= col[2]) return 1;      else                          return 2; }    function f2911(col) {          if (col[0] >= col[1]            && col[0] >= col[2]) return 0;      else if (col[1] >= col[1]            && col[1] >= col[2]) return 1;      else                       return 2; }    function d2912(col)  {     if (   col[0] == col[1]          && col[0] == col[2])         return [0, 1, 2];      else          return [             z2909(col),              u2910(col),              f2911(col)]; }    function w2913(o127, s) {     const col       = [...o127];     const [n, d, x] = d2912(col);      if (col[x] > col[n])     {         col[d] = (((col[d] - col[n]) * s) / (col[x] - col[n]));         col[x] = s;     }     else         col[d] = col[x] = 0;      col[n] = 0;      return col; }    function e2914(c, l, n, x) {          if (n < 0) return l + (((c - l) * l) / (l - n));     else if (x > 1) return l + (((c - l) * (1 - l)) / (x - l));     else            return c; }    function q2915(col) {     const l   = u2906(col);      const n = Math.min(col[0], col[1], col[2]);     const x = Math.max(col[0], col[1], col[2]);      return [ e2914(col[0], l, n, x),              e2914(col[1], l, n, x),              e2914(col[2], l, n, x) ]; }    function b4357(col, back, amount) {     return y4340(         k2907(w2913(col, h2908(back)), u2906(back)),         back,         amount); }    function w4358(col, back, amount) {     return y4340(         k2907(w2913(back, h2908(col)), u2906(back)),         back,         amount); }    function w4359(col, back, amount) {     return y4340(         k2907(col, u2906(back)),         back,         amount); }    function f4360(col, back, amount) {     return y4340(         k2907(back, u2906(col)),         back,         amount); }


class l1887 extends i2043 {     id;      colorStyle;     r2916;           linked;        constructor(nodeId, options, styleId)     {         super(a1215, nodeId, options);          this.id == styleId;     }        copy()     {         const copy = new l1887(this.nodeId, this.options);          copy.id = this.id;          if (this.colorStyle) copy.colorStyle = this.colorStyle.copy();         if (this.r2916  ) copy.r2916   = this.r2916  .copy();                         copy.linked   = this.linked;          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                   this.value = await evalColorValue(this.r2916, parse);           if (   this.value.isValid()             && this.linked)                                   {             if (this.value.type == j1167)                 this.value = c2013.t3868(z4234(this.value.t3339()), 0xff);              const rgba       = this.value.d99();             const f3358 = m100(e120(rgba), rgba[3]);              this.evalStyle({rgba: f3358});         }         else             this.value = c2013.NaN();           this.c4193(parse,         [             ['value', this.value]         ]);           this.validate();          return this;     }        evalStyle(options = {})     {         if (!this.options.enabled)             return;                       const colorStyle = new g1839(this.nodeId, this.id, this.name);                     colorStyle.paints =          [             [ 'SOLID',                        Math.round(options.rgba[0] * 0xff)               + ' ' + Math.round(options.rgba[1] * 0xff)               + ' ' + Math.round(options.rgba[2] * 0xff)               + ' ' + Math.round(options.rgba[3] * 100 ) ]         ];           this.colorStyle = colorStyle;     }        isValid()     {         return this.r2916 && this.r2916.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.r2916) this.r2916.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.r2916) this.r2916.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.r2916) this.r2916.i4179(parse);     } }


class k1889 extends l2044 {     color   = null;     opacity = null;     blend   = null;        constructor(nodeId, options)     {         super(e1178, nodeId, options);     }        reset()     {         super.reset();          this.color   = null;         this.opacity = null;         this.blend   = null;     }        copy()     {         const copy = new k1889(this.nodeId, this.options);          copy.t3455(this);          if (this.color  ) copy.color   = this.color  .copy();         if (this.opacity) copy.opacity = this.opacity.copy();         if (this.blend  ) copy.blend   = this.blend  .copy();          return copy;     }        w4334(m3091)     {         switch (m3091)         {             case 'color':   return this.input ? this.value.color   : this.color;             case 'opacity': return this.input ? this.value.opacity : this.opacity;             case 'blend':   return this.input ? this.value.blend   : this.blend;         }          return null;     }        async eval(parse)     {         if (this.isCached())             return this;           const input   = await evalFillValue  (this.input,   parse);         let   color   = await evalColorValue (this.color,   parse);         let   opacity = await evalNumberValue(this.opacity, parse);         let   blend   = await evalNumberValue(this.blend,   parse);           if (input)         {             this.value        = input.toNewValue();             this.value.nodeId = this.nodeId;              this.value.d3721(input);              if (color  )  this.value.color   = color;    else  color   = this.value.color;             if (opacity)  this.value.opacity = opacity;  else  opacity = this.value.opacity;             if (blend  )  this.value.blend   = blend;    else  blend   = this.value.blend;         }         else if ((!color   || color  .type == j1167 )               && (!opacity || opacity.type == c1090)               && (!blend   || blend  .type == c1090))         {             this.value = new c2013(                 color,                  opacity,                 blend);         }         else             this.value = c2013.NaN();           this.c4193(parse,         [             ['value',   this.value],             ['color',   color     ],             ['opacity', opacity   ],             ['blend',   blend     ]         ]);                                                this.validate();          return this;     }        toNewValue()     {         return this.options.enabled             ? new c2013(                 this.color   ? this.color  .toNewValue() : this.input.value.color  .toNewValue(),                 this.opacity ? this.opacity.toNewValue() : this.input.value.opacity.toNewValue(),                 this.blend   ? this.blend  .toNewValue() : this.input.value.blend  .toNewValue())             : c2013.NaN();     }        isValid()     {         return (!this.input || this.input.isValid())             && this.color   && this.color  .isValid()             && this.opacity && this.opacity.isValid()             && this.blend   && this.blend  .isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.color  ) this.color  .p4180(parse);         if (this.opacity) this.opacity.p4180(parse);         if (this.blend  ) this.blend  .p4180(parse);     }                    i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.color  ) this.color  .i4181(parse, from, force);         if (this.opacity) this.opacity.i4181(parse, from, force);         if (this.blend  ) this.blend  .i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.color  ) this.color  .i4179(parse);         if (this.opacity) this.opacity.i4179(parse);         if (this.blend  ) this.blend  .i4179(parse);     } }


class b1886 extends l2044 {     fill     = null;     position = null;        constructor(nodeId, options)     {         super(m1184, nodeId, options);     }        reset()     {         super.reset();          this.fill     = null;         this.position = null;     }        copy()     {         const copy = new b1886(this.nodeId, this.options);          copy.t3455(this);          if (this.fill    ) copy.fill     = this.fill    .copy();         if (this.position) copy.position = this.position.copy();          return copy;     }        w4334(m3091)     {         switch (m3091)         {             case 'fill':      return this.input ? this.value.fill     : this.fill;             case 'position':  return this.input ? this.value.position : this.position;         }          return null;     }        async eval(parse)     {         if (this.isCached())             return this;                           const input    = await evalColorStopValue(this.input,    parse);         let   fill     = await evalFillValue     (this.fill,     parse);         let   position = await evalNumberValue   (this.position, parse);                  fill = this.validateFill(fill);           if (input)         {             this.value        = input.toNewValue();             this.value.nodeId = this.nodeId;              this.value.d3721(input);              if (fill    )  this.value.fill     = fill;      else  fill     = this.value.fill;             if (position)  this.value.position = position;  else  position = this.value.position;         }         else         {             this.value = new z2009(                 fill,                  position);         }           this.c4193(parse,          [             ['value', this.value]         ]);                   if (!this.fill    ) this.fill     = this.value.fill    .copy();         if (!this.position) this.position = this.value.position.copy();           this.validate();          return this;     }        validateFill(fill)     {         if (!fill)             return null;           if (fill.type == j1167)             return c2013.t3868(z4234(fill.t3339()), 100);         else             return fill;     }        toNewValue()     {         return new z2009(             this.options.enabled             ? this.validateFill(this.fill ? this.fill.toNewValue() : this.input.fill.toNewValue())             : c2013.NaN(),             this.position ? this.position.toNewValue() : this.input.position.toNewValue());     }                         isValid()     {         return (!this.input || this.input.isValid())             && this.fill     && this.fill    .isValid()             && this.position && this.position.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.fill    ) this.fill    .p4180(parse);         if (this.position) this.position.p4180(parse);     }                    i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.fill    ) this.fill    .i4181(parse, from, force);         if (this.position) this.position.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.fill    ) this.fill    .i4179(parse);         if (this.position) this.position.i4179(parse);     } }


class f1890 extends i2043 {     inputs = [];      h3782 = null;     position = null;     x        = null;     y        = null;     size     = null;     angle    = null;     aspect   = null;     skew     = null;     blend    = null;          diagAspect;                constructor(nodeId, options)     {         super(c1187, nodeId, options);     }                    reset()     {         super.reset();                  this.inputs = [];              this.h3782 = null;         this.position = null;         this.x        = null;         this.y        = null;         this.size     = null;         this.angle    = null;         this.aspect   = null;         this.skew     = null;         this.blend    = null;     }        copy()     {         const copy = new f1890(this.nodeId, this.options);          copy.t3455(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.h3782) copy.h3782 = this.x       .copy();         if (this.position) copy.position = this.position.copy();         if (this.x       ) copy.x        = this.x       .copy();         if (this.y       ) copy.y        = this.y       .copy();         if (this.size    ) copy.size     = this.size    .copy();         if (this.angle   ) copy.angle    = this.angle   .copy();         if (this.aspect  ) copy.aspect   = this.aspect  .copy();         if (this.skew    ) copy.skew     = this.skew    .copy();         if (this.blend   ) copy.blend    = this.blend   .copy();          return copy;     }        w4334(m3091)     {         switch (m3091)         {             case 'gradType':  return this.input ? this.value.h3782 : this.h3782;             case 'position':  return this.input ? this.value.position : this.position;             case 'x':         return this.input ? this.value.x        : this.x;             case 'y':         return this.input ? this.value.y        : this.y;             case 'size':      return this.input ? this.value.size     : this.size;             case 'angle':     return this.input ? this.value.angle    : this.angle;             case 'aspect':    return this.input ? this.value.aspect   : this.aspect;             case 'skew':      return this.input ? this.value.skew     : this.skew;             case 'blend':     return this.input ? this.value.blend    : this.blend;         }          return null;     }        async eval(parse)     {         if (this.isCached())             return this;                       let h3782 = await evalNumberValue(this.h3782, parse);         let position = await evalNumberValue(this.position, parse);         let x        = await evalNumberValue(this.x,        parse);         let y        = await evalNumberValue(this.y,        parse);         let size     = await evalNumberValue(this.size,     parse);         let angle    = await evalNumberValue(this.angle,    parse);         let aspect   = await evalNumberValue(this.aspect,   parse);         let skew     = await evalNumberValue(this.skew,     parse);         let blend    = await evalNumberValue(this.blend,    parse);           if (position) position.value = Math.min(Math.max(0, Math.floor(position.value)), 4);         if (blend   ) blend   .value = Math.min(Math.max(0, Math.floor(blend   .value)), n1392.length-1);           let stops = new w2021();           const inputs = [];                  for (const input of this.inputs)             inputs.push(await evalValue(input, parse));           if (   inputs.length == 1             && inputs[0].type == c1186)         {             this.value        = inputs[0].toNewValue();             this.value.nodeId = this.nodeId;                          this.value.d3721(inputs[0]);              if (h3782)  this.value.h3782 = h3782;  else  h3782 = this.value.h3782;                   if (position)  this.value.position = position;  else  position = this.value.position;                   if (x       )  this.value.x        = x;         else  x        = this.value.x;                   if (y       )  this.value.y        = y;         else  y        = this.value.y;                   if (size    )  this.value.size     = size;      else  size     = this.value.size;                   if (angle   )  this.value.angle    = angle;     else  angle    = this.value.angle;                   if (aspect  )  this.value.aspect   = aspect;    else  aspect   = this.value.aspect;                   if (skew    )  this.value.skew     = skew;      else  skew     = this.value.skew;                   if (blend   )  this.value.blend    = blend;     else  blend    = this.value.blend;               }         else         {             for (let i = 0, o = 0; i < inputs.length; i++)             {                 const input = inputs[i];                  if (   input                     && this.options.enabled)                 {                     if (o955(input.type))                     {                         for (const item of input.items)                             if (item.isValid())                                 stops.items.push(item);                     }                     else if (input.type == c1186)                     {                         for (const item of input.stops.items)                             stops.items.push(item);                     }                     else                         if (input.isValid())                             stops.items.push(input);                 }             }               stops.items = u1827(stops.items);              a1829(stops.items);               this.value = new i2015(                 stops,                 h3782,                 position,                 x,                  y,                  size,                  angle,                  aspect,                 this.diagAspect,                 skew,                 blend);         }                   this.c4193(parse,         [             ['value',    this.value],             ['gradType', h3782  ],             ['position', position  ],             ['x',        x         ],             ['y',        y         ],             ['size',     size      ],             ['angle',    angle     ],             ['aspect',   aspect    ],             ['skew',     skew      ],             ['blend',    blend     ]         ]);                   if (   inputs.length == 1             && inputs[0].type == c1186)         {             if (!this.h3782) this.h3782 = this.value.h3782.copy();             if (!this.position) this.position = this.value.position.copy();             if (!this.x       ) this.x        = this.value.x       .copy();             if (!this.y       ) this.y        = this.value.y       .copy();             if (!this.size    ) this.size     = this.value.size    .copy();             if (!this.angle   ) this.angle    = this.value.angle   .copy();             if (!this.aspect  ) this.aspect   = this.value.aspect  .copy();             if (!this.skew    ) this.skew     = this.value.skew    .copy();             if (!this.blend   ) this.blend    = this.value.blend   .copy();         }           this.validate();          return this;     }                toNewValue()     {         return this.value.copy();     }                         isValid()     {         return !this.inputs.find(i => !i.isValid())             && this.h3782 && this.h3782.isValid()             && this.position && this.position.isValid()             && this.x        && this.x       .isValid()             && this.y        && this.y       .isValid()             && this.size     && this.size    .isValid()             && this.angle    && this.angle   .isValid()             && this.aspect   && this.aspect  .isValid()             && this.skew     && this.skew    .isValid()             && this.blend    && this.blend   .isValid();     }        p4180(parse)     {         super.p4180(parse);          this.inputs.forEach(i => i.p4180(parse));          if (this.h3782) this.h3782.p4180(parse);         if (this.position) this.position.p4180(parse);         if (this.x       ) this.x       .p4180(parse);         if (this.y       ) this.y       .p4180(parse);         if (this.size    ) this.size    .p4180(parse);         if (this.angle   ) this.angle   .p4180(parse);         if (this.aspect  ) this.aspect  .p4180(parse);         if (this.skew    ) this.skew    .p4180(parse);         if (this.blend   ) this.blend   .p4180(parse);     }            i4181(parse, from, force)     {         super.i4181(parse, from, force);          this.inputs.forEach(i => i.i4181(parse, from, force));                  if (this.h3782) this.h3782.i4181(parse, from, force);         if (this.position) this.position.i4181(parse, from, force);         if (this.x       ) this.x       .i4181(parse, from, force);         if (this.y       ) this.y       .i4181(parse, from, force);         if (this.size    ) this.size    .i4181(parse, from, force);         if (this.angle   ) this.angle   .i4181(parse, from, force);         if (this.aspect  ) this.aspect  .i4181(parse, from, force);         if (this.skew    ) this.skew    .i4181(parse, from, force);         if (this.blend   ) this.blend   .i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          this.inputs.forEach(i => i.i4179(parse));          if (this.h3782) this.h3782.i4179(parse);         if (this.position) this.position.i4179(parse);         if (this.x       ) this.x       .i4179(parse);         if (this.y       ) this.y       .i4179(parse);         if (this.size    ) this.size    .i4179(parse);         if (this.angle   ) this.angle   .i4179(parse);         if (this.aspect  ) this.aspect  .i4179(parse);         if (this.skew    ) this.skew    .i4179(parse);         if (this.blend   ) this.blend   .i4179(parse);     }     }


class o1896 extends l2044 {     fills  = null;    q3770  = null;      weight = null;     fit    = null;     join   = null;     miter  = null;     cap    = null;     dashes = null;                constructor(nodeId, options)     {         super(a1181, nodeId, options);     }                reset()     {         super.reset();                  this. fills  = null;         this.q3770  = null;          this. weight = null;         this. fit    = null;         this. join   = null;         this. miter  = null;         this. cap    = null;         this. dashes = null;     }        copy()     {         const copy = new o1896(this.nodeId, this.options);          copy.t3455(this);          if (this.fills ) copy. fills  = this.fills .copy();         if (this.q3770) copy.q3770  = this.q3770.copy();         if (this.weight) copy. weight = this.weight.copy();         if (this.fit   ) copy. fit    = this.fit   .copy();         if (this.join  ) copy. join   = this.join  .copy();         if (this.miter ) copy. miter  = this.miter .copy();         if (this.cap   ) copy. cap    = this.cap   .copy();         if (this.dashes) copy. dashes = this.dashes.copy();          return copy;     }        w4334(m3091)     {         switch (m3091)         {             case 'fills ':  return this.input ? this.value.fills  : this.fills;             case 'weight':  return this.input ? this.value.weight : this.weight;             case 'fit':     return this.input ? this.value.fit    : this.fit;             case 'join':    return this.input ? this.value.join   : this.join;             case 'miter':   return this.input ? this.value.miter  : this.miter;             case 'cap':     return this.input ? this.value.cap    : this.cap;             case 'dashes':  return this.input ? this.value.dashes : this.dashes;         }          return null;     }        async eval(parse)     {         if (this.isCached())             return this;          const input = await evalStrokeValue(this. input, parse);         let   fills = await evalListValue  (this.q3770, parse);          fills = this.validateFills(fills);          if (    this.q3770             && !o955(this.q3770.type))             this.fills = fills;           let weight = await evalNumberValue(this.weight, parse);         let fit    = await evalNumberValue(this.fit,    parse);         let join   = await evalNumberValue(this.join,   parse);         let miter  = await evalNumberValue(this.miter,  parse);         let cap    = await evalNumberValue(this.cap,    parse);         let dashes = await evalTextValue  (this.dashes, parse);           if (input)         {             this.value        = input.toNewValue();             this.value.nodeId = this.nodeId;              this.value.d3721(input);              if (fills )  this.value.fills  = fills;   else  fills  = this.value.fills;             if (weight)  this.value.weight = weight;  else  weight = this.value.weight;             if (fit   )  this.value.fit    = fit;     else  fit    = this.value.fit;             if (join  )  this.value.join   = join;    else  join   = this.value.join;             if (miter )  this.value.miter  = miter;   else  miter  = this.value.miter;             if (cap   )  this.value.cap    = cap;     else  cap    = this.value.cap;             if (dashes)  this.value.dashes = dashes;  else  dashes = this.value.dashes;         }         else         {             this.value = new t2031(                 fills,                  weight,                  fit,                  join,                 miter,                 cap,                 dashes);         }           this.c4193(parse,         [             ['value',  this.value],             ['fills',  fills     ],             ['weight', weight    ],             ['fit',    fit       ],             ['join',   join      ],             ['miter',  miter     ],             ['cap',    cap       ],             ['dashes', dashes    ]         ]);           this.validate();          return this;     }        validateFills(fills)     {                     if (!fills)             return null;          if (fills.type == j1167)             return new w2021([c2013.t3868(z4234(fills.t3339()), 100)]);          else if (fills.type ==     d1177               || fills.type == c1186)             return new w2021([fills]);         else         {             c950(fills.type == q1054, 'stroke.fills must be a LIST_VALUE');              for (let i = 0; i < fills.items.length; i++)             {                 if (fills.items[i].type == j1167)                     fills.items[i] = new c2013(fills.items[i]);             }              return fills;         }     }        toNewValue()     {         return new t2031(             this.options.enabled             ? this.validateFills(this.fills ? this.fills.toNewValue() : this.input.fills.toNewValue())             : new w2021(),             this.weight ? this.weight.toNewValue() : this.input.weight.toNewValue(),             this.fit    ? this.fit   .toNewValue() : this.input.fit   .toNewValue(),             this.join   ? this.join  .toNewValue() : this.input.join  .toNewValue(),             this.miter  ? this.miter .toNewValue() : this.input.miter .toNewValue(),             this.cap    ? this.cap   .toNewValue() : this.input.cap   .toNewValue(),             this.dashes ? this.dashes.toNewValue() : this.input.dashes.toNewValue());     }                         isValid()     {         return (!this.input || this.input.isValid())             && this.fills  && this.fills .isValid()             && this.weight && this.weight.isValid()             && this.fit    && this.fit   .isValid()             && this.join   && this.join  .isValid()             && this.miter  && this.miter .isValid()             && this.cap    && this.cap   .isValid()             && this.dashes && this.dashes.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.q3770) this.q3770.p4180(parse);         if (this.weight) this.weight.p4180(parse);         if (this.fit   ) this.fit   .p4180(parse);         if (this.join  ) this.join  .p4180(parse);         if (this.miter ) this.miter .p4180(parse);         if (this.cap   ) this.cap   .p4180(parse);         if (this.dashes) this.dashes.p4180(parse);     }                    i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.q3770) this.q3770.i4181(parse, from, force);         if (this.weight) this.weight.i4181(parse, from, force);         if (this.fit   ) this.fit   .i4181(parse, from, force);         if (this.join  ) this.join  .i4181(parse, from, force);         if (this.miter ) this.miter .i4181(parse, from, force);         if (this.cap   ) this.cap   .i4181(parse, from, force);         if (this.dashes) this.dashes.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.q3770) this.q3770.i4179(parse);         if (this.weight) this.weight.i4179(parse);         if (this.fit   ) this.fit   .i4179(parse);         if (this.join  ) this.join  .i4179(parse);         if (this.miter ) this.miter .i4179(parse);         if (this.cap   ) this.cap   .i4179(parse);         if (this.dashes) this.dashes.i4179(parse);     }     }


class w2531 extends l2044 {     top    = null;     left   = null;     right  = null;     bottom = null;                constructor(nodeId, options)     {         super(w1190, nodeId, options);     }                reset()     {         super.reset();                  this.top    = null;         this.left   = null;         this.right  = null;         this.bottom = null;     }        copy()     {         const copy = new w2531(this.nodeId, this.options);          copy.t3455(this);          if (this.top   ) copy.top    = this.top   .copy();         if (this.left  ) copy.left   = this.left  .copy();         if (this.right ) copy.right  = this.right .copy();         if (this.bottom) copy.bottom = this.bottom.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalStrokeSidesValue(this.input,  parse);         const top    = await evalNumberValue     (this.top,    parse);         const left   = await evalNumberValue     (this.left,   parse);         const right  = await evalNumberValue     (this.right,  parse);         const bottom = await evalNumberValue     (this.bottom, parse);           if (input)         {             this.value = new f4364(                 top    ?? input.top,                 left   ?? input.left,                 right  ?? input.right,                 bottom ?? input.bottom,                 this.options.enabled);         }         else         {             this.value = new f4364(                 top,                  left,                  right,                  bottom,                 this.options.enabled);         }           this.c4193(parse,         [             ['top',    this.value.top   ],             ['left',   this.value.left  ],             ['right',  this.value.right ],             ['bottom', this.value.bottom]         ]);                   if (!this.top   ) this.top    = this.value.top   .copy();         if (!this.left  ) this.left   = this.value.left  .copy();         if (!this.right ) this.right  = this.value.right .copy();         if (!this.bottom) this.bottom = this.value.bottom.copy();           this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.top    && this.top   .isValid()             && this.left   && this.left  .isValid()             && this.right  && this.right .isValid()             && this.bottom && this.bottom.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.top   ) this.top   .p4180(parse);         if (this.left  ) this.left  .p4180(parse);         if (this.right ) this.right .p4180(parse);         if (this.bottom) this.bottom.p4180(parse);     }                   i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.top   ) this.top   .i4181(parse, from, force);         if (this.left  ) this.left  .i4181(parse, from, force);         if (this.right ) this.right .i4181(parse, from, force);         if (this.bottom) this.bottom.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.top   ) this.top   .i4179(parse);         if (this.left  ) this.left  .i4179(parse);         if (this.right ) this.right .i4179(parse);         if (this.bottom) this.bottom.i4179(parse);     } }


class g1895 extends l2044 {     tl = null;     tr = null;     bl = null;     br = null;                constructor(nodeId, options)     {         super(a1193, nodeId, options);     }                reset()     {         super.reset();                  this.tl = null;         this.tr = null;         this.bl = null;         this.br = null;     }        copy()     {         const copy = new g1895(this.nodeId, this.options);          copy.t3455(this);          if (this.tl) copy.tl = this.tl.copy();         if (this.tr) copy.tr = this.tr.copy();         if (this.bl) copy.bl = this.bl.copy();         if (this.br) copy.br = this.br.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalRoundedCornersValue(this.input, parse);         const tl    = await evalNumberValue        (this.tl,    parse);         const tr    = await evalNumberValue        (this.tr,    parse);         const bl    = await evalNumberValue        (this.bl,    parse);         const br    = await evalNumberValue        (this.br,    parse);           if (input)         {             this.value = new r2026(                 tl ?? input.tl,                 tr ?? input.tr,                 bl ?? input.bl,                 br ?? input.br,                 this.options.enabled);         }         else         {             this.value = new r2026(                 tl,                  tr,                  bl,                  br,                 this.options.enabled);         }           this.c4193(parse,         [             ['tl', this.value.tl],             ['tr', this.value.tr],             ['bl', this.value.bl],             ['br', this.value.br]         ]);                   if (!this.tl) this.tl = this.value.tl.copy();         if (!this.tr) this.tr = this.value.tr.copy();         if (!this.bl) this.bl = this.value.bl.copy();         if (!this.br) this.br = this.value.br.copy();           this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.tl && this.tl.isValid()             && this.tr && this.tr.isValid()             && this.bl && this.bl.isValid()             && this.br && this.br.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.tl) this.tl.p4180(parse);         if (this.tr) this.tr.p4180(parse);         if (this.bl) this.bl.p4180(parse);         if (this.br) this.br.p4180(parse);     }                   i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.tl) this.tl.i4181(parse, from, force);         if (this.tr) this.tr.i4181(parse, from, force);         if (this.bl) this.bl.i4181(parse, from, force);         if (this.br) this.br.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.tl) this.tl.i4179(parse);         if (this.tr) this.tr.i4179(parse);         if (this.bl) this.bl.i4179(parse);         if (this.br) this.br.i4179(parse);     } }


class x1888 extends l2044 {     x      = null;     y      = null;     blur   = null;     spread = null;     fill   = null;     blend  = null;     behind = null;                constructor(nodeId, options)     {         super(k1196, nodeId, options);     }                reset()     {         super.reset();                  this.x      = null;         this.y      = null;         this.blur   = null;         this.spread = null;         this.fill   = null;         this.blend  = null;         this.behind = null;     }        copy()     {         const copy = new x1888(this.nodeId, this.options);          copy.t3455(this);          if (this.x     ) copy.x      = this.x     .copy();         if (this.y     ) copy.y      = this.y     .copy();         if (this.blur  ) copy.blur   = this.blur  .copy();         if (this.spread) copy.spread = this.spread.copy();         if (this.fill  ) copy.fill   = this.fill  .copy();         if (this.blend ) copy.blend  = this.blend .copy();         if (this.behind) copy.behind = this.behind.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalValue      (this.input,  parse);         const x      = await evalNumberValue(this.x,      parse);         const y      = await evalNumberValue(this.y,      parse);         const blur   = await evalNumberValue(this.blur,   parse);         const spread = await evalNumberValue(this.spread, parse);         let   fill   = await evalFillValue  (this.fill,   parse);         const blend  = await evalNumberValue(this.blend,  parse);         const behind = await evalNumberValue(this.behind, parse);           if (   fill             && fill.type == j1167)             fill = new c2013(fill);                   if (input)         {             this.value = new z2011(                 x      ?? input.x,                 y      ?? input.y,                 blur   ?? input.blur,                 spread ?? input.spread,                 fill   ?? input.fill,                 blend  ?? input.blend,                 behind ?? input.behind,                 this.options.enabled);         }         else         {             this.value = new z2011(                 x,                  y,                  blur,                  spread,                  fill,                  blend,                  behind,                 this.options.enabled);         }           this.c4193(parse,         [             ['x',      this.value.x     ],             ['y',      this.value.y     ],             ['blur',   this.value.blur  ],             ['spread', this.value.spread],             ['fill',   this.value.fill  ],             ['blend',  this.value.blend ],             ['behind', this.value.behind]         ]);                   if (!this.x     ) this.x      = this.value.x     .copy();         if (!this.y     ) this.y      = this.value.y     .copy();         if (!this.blur  ) this.blur   = this.value.blur  .copy();         if (!this.spread) this.spread = this.value.spread.copy();         if (!this.fill  ) this.fill   = this.value.fill  .copy();         if (!this.blend ) this.blend  = this.value.blend .copy();         if (!this.behind) this.behind = this.value.behind.copy();           this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.x      && this.x     .isValid()             && this.y      && this.y     .isValid()             && this.blur   && this.blur  .isValid()             && this.spread && this.spread.isValid()             && this.fill   && this.fill  .isValid()             && this.blend  && this.blend .isValid()             && this.behind && this.behind.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.x     ) this.x     .p4180(parse);         if (this.y     ) this.y     .p4180(parse);         if (this.blur  ) this.blur  .p4180(parse);         if (this.spread) this.spread.p4180(parse);         if (this.fill  ) this.fill  .p4180(parse);         if (this.blend ) this.blend .p4180(parse);         if (this.behind) this.behind.p4180(parse);     }                   i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.x     ) this.x     .i4181(parse, from, force);         if (this.y     ) this.y     .i4181(parse, from, force);         if (this.blur  ) this.blur  .i4181(parse, from, force);         if (this.spread) this.spread.i4181(parse, from, force);         if (this.fill  ) this.fill  .i4181(parse, from, force);         if (this.blend ) this.blend .i4181(parse, from, force);         if (this.behind) this.behind.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.x     ) this.x     .i4179(parse);         if (this.y     ) this.y     .i4179(parse);         if (this.blur  ) this.blur  .i4179(parse);         if (this.spread) this.spread.i4179(parse);         if (this.fill  ) this.fill  .i4179(parse);         if (this.blend ) this.blend .i4179(parse);         if (this.behind) this.behind.i4179(parse);     } }


class k1891 extends l2044 {     x      = null;     y      = null;     blur   = null;     spread = null;     fill   = null;     blend  = null;                constructor(nodeId, options)     {         super(e1199, nodeId, options);     }        reset()     {         super.reset();          this.x      = null;         this.y      = null;         this.blur   = null;         this.spread = null;         this.fill   = null;         this.blend  = null;     }        copy()     {         const copy = new k1891(this.nodeId, this.options);          copy.t3455(this);          if (this.x     ) copy.x      = this.x     .copy();         if (this.y     ) copy.y      = this.y     .copy();         if (this.blur  ) copy.blur   = this.blur  .copy();         if (this.spread) copy.spread = this.spread.copy();         if (this.fill  ) copy.fill   = this.fill  .copy();         if (this.blend ) copy.blend  = this.blend .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalInnerShadowValue(this.input,  parse);         const x      = await evalNumberValue     (this.x,      parse);         const y      = await evalNumberValue     (this.y,      parse);         const blur   = await evalNumberValue     (this.blur,   parse);         const spread = await evalNumberValue     (this.spread, parse);         let   fill   = await evalFillValue       (this.fill,   parse);         const blend  = await evalNumberValue     (this.blend,  parse);                   if (   fill             && fill.type == j1167)             fill = new c2013(fill);           if (input)         {             this.value = new v2016(                 x      ?? input.x,                 y      ?? input.y,                 blur   ?? input.blur,                 spread ?? input.spread,                 fill   ?? input.fill,                 blend  ?? input.blend,                 this.options.enabled);         }         else         {             this.value = new v2016(                 x,                  y,                  blur,                  spread,                  fill,                  blend,                 this.options.enabled);         }           this.c4193(parse,         [             ['x',      this.value.x     ],             ['y',      this.value.y     ],             ['blur',   this.value.blur  ],             ['spread', this.value.spread],             ['fill',   this.value.fill  ],             ['blend',  this.value.blend ],         ]);                   if (!this.x     ) this.x      = this.value.x     .copy();         if (!this.y     ) this.y      = this.value.y     .copy();         if (!this.blur  ) this.blur   = this.value.blur  .copy();         if (!this.spread) this.spread = this.value.spread.copy();         if (!this.fill  ) this.fill   = this.value.fill  .copy();         if (!this.blend ) this.blend  = this.value.blend .copy();           this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.x      && this.x     .isValid()             && this.y      && this.y     .isValid()             && this.blur   && this.blur  .isValid()             && this.spread && this.spread.isValid()             && this.fill   && this.fill  .isValid()             && this.blend  && this.blend .isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.x     ) this.x     .p4180(parse);         if (this.y     ) this.y     .p4180(parse);         if (this.blur  ) this.blur  .p4180(parse);         if (this.spread) this.spread.p4180(parse);         if (this.fill  ) this.fill  .p4180(parse);         if (this.blend ) this.blend .p4180(parse);     }                    i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.x     ) this.x     .i4181(parse, from, force);         if (this.y     ) this.y     .i4181(parse, from, force);         if (this.blur  ) this.blur  .i4181(parse, from, force);         if (this.spread) this.spread.i4181(parse, from, force);         if (this.fill  ) this.fill  .i4181(parse, from, force);         if (this.blend ) this.blend .i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.x     ) this.x     .i4179(parse);         if (this.y     ) this.y     .i4179(parse);         if (this.blur  ) this.blur  .i4179(parse);         if (this.spread) this.spread.i4179(parse);         if (this.fill  ) this.fill  .i4179(parse);         if (this.blend ) this.blend .i4179(parse);     } }


class c1893 extends l2044 {     radius = null;        constructor(nodeId, options)     {         super(e1202, nodeId, options);     }        reset()     {         super.reset();          this.radius = null;     }        copy()     {         const copy = new c1893(this.nodeId, this.options);          copy.t3455(this);          if (this.radius) copy.radius = this.radius.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalLayerBlurValue(this.input,  parse);         const radius = await evalNumberValue   (this.radius, parse);                   if (input)         {             this.value = new w2018(                 radius ?? input.radius,                 this.options.enabled);         }         else         {             this.value = new w2018(                 radius,                 this.options.enabled);         }           this.c4193(parse,         [             ['radius', this.value.radius]         ]);                   if (!this.radius) this.radius = this.value.radius.copy();           this.validate();          return this;     }        toNewValue()     {         return new w2018(             this.radius ? this.radius.toNewValue() : this.input.radius.toNewValue(),             this.options.enabled);     }        isValid()     {         return super.isValid()             && this.radius && this.radius.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.radius) this.radius.p4180(parse);     }                    i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.radius) this.radius.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.radius) this.radius.i4179(parse);     } }


class k1885 extends l2044 {     radius = null;        constructor(nodeId, options)     {         super(s1205, nodeId, options);     }        reset()     {         super.reset();          this.radius = null;     }        copy()     {         const copy = new k1885(this.nodeId, this.options);          copy.t3455(this);          if (this.radius) copy.radius = this.radius.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalValue      (this.input,  parse);         const radius = await evalNumberValue(this.radius, parse);                   if (input)         {             this.value = new h2008(                 radius ?? input.radius,                 this.options.enabled);         }         else         {             this.value = new h2008(                 radius,                 this.options.enabled);         }           this.c4193(parse,         [             ['radius', this.value.radius]         ]);                   if (!this.radius) this.radius = this.value.radius.copy();           this.validate();          return this;     }        toNewValue()     {         return new h2008(             this.radius ? this.radius.toNewValue() : this.input.radius.toNewValue(),             this.options.enabled);     }        isValid()     {         return super.isValid()             && this.radius && this.radius.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.radius) this.radius.p4180(parse);     }                    i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.radius) this.radius.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.radius) this.radius.i4179(parse);     } }


class h1892 extends i2043 {     opacity;     blend;        constructor(nodeId, options)     {         super(s1211, nodeId, options);     }        reset()     {         super.reset();          this.opacity = null;         this.blend   = null;     }        copy()     {         const copy = new h1892(this.nodeId, this.options);          copy.t3455(this);          if (this.opacity) copy.opacity = this.opacity.copy();         if (this.blend  ) copy.blend   = this.blend  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const opacity = await evalNumberValue(this.opacity, parse);         const blend   = await evalNumberValue(this.blend,   parse);           this.value =              this.options.enabled             ? new c2017(opacity, blend)             : new c2017(new k2022(100), new k2022(0));           this.c4193(parse,          [             ['opacity', opacity],             ['blend',   blend  ]         ]);           this.validate();          return this;     }        toNewValue()     {         return this.value.copy();     }        isValid()     {         return this.opacity && this.opacity.isValid()             && this.blend   && this.blend  .isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.opacity) this.opacity.p4180(parse);         if (this.blend  ) this.blend  .p4180(parse);     }                    i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.opacity) this.opacity.i4181(parse, from, force);         if (this.blend  ) this.blend  .i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.opacity) this.opacity.i4179(parse);         if (this.blend  ) this.blend  .i4179(parse);     } }


class g1894 extends i2043 {     maskType;        constructor(nodeId, options)     {         super(m1208, nodeId, options);     }        reset()     {         super.reset();          this.maskType = null;     }        copy()     {         const copy = new g1894(this.nodeId, this.options);          copy.t3455(this);          if (this.maskType) copy.maskType = this.maskType.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const maskType = await evalNumberValue(this.maskType, parse);           this.value = new u2019(maskType, this.options.enabled);           this.c4193(parse,          [             ['maskType', maskType]         ]);           this.validate();          return this;     }        toNewValue()     {         return this.value.copy();     }        isValid()     {         return this.maskType && this.maskType.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.maskType) this.maskType.p4180(parse);     }                    i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.maskType) this.maskType.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.maskType) this.maskType.i4179(parse);     } }


class a1975 extends i2043 {     x      = null;     y      = null;     width  = null;     height = null;        constructor(type, nodeId, options)     {         super(type, nodeId, options);     }        reset()     {         super.reset();                  this.x      = null;         this.y      = null;         this.width  = null;         this.height = null;     }        t3455(base)     {         super.t3455(base);          if (base.x     ) this.x      = base.x     .copy();         if (base.y     ) this.y      = base.y     .copy();         if (base.width ) this.width  = base.width .copy();         if (base.height) this.height = base.height.copy();     }        async evalBaseParams(parse, evalHeight = true)     {         let x      =              await evalNumberValue(this.x,      parse);         let y      =              await evalNumberValue(this.y,      parse);         let width  =              await evalNumberValue(this.width,  parse);         let height = evalHeight ? await evalNumberValue(this.height, parse) : null;          return [x, y, width, height];     }        evalStyle(options = {})     {                       }        isValid()     {         return this.x      && this.x     .isValid()             && this.y      && this.y     .isValid()             && this.width  && this.width .isValid()             && this.height && this.height.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.x     ) this.x     .p4180(parse);         if (this.y     ) this.y     .p4180(parse);         if (this.width ) this.width .p4180(parse);         if (this.height) this.height.p4180(parse);     }            i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.x     ) this.x     .i4181(parse, from, force);         if (this.y     ) this.y     .i4181(parse, from, force);         if (this.width ) this.width .i4181(parse, from, force);         if (this.height) this.height.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.x     ) this.x     .i4179(parse);         if (this.y     ) this.y     .i4179(parse);         if (this.width ) this.width .i4179(parse);         if (this.height) this.height.i4179(parse);     } }    function validateObjectRect(x, y, w, h, a = 0, _a = 0) {     if (w < 0)     {         x += w * Math.cos(_a);         y += w * Math.sin(_a);     }      if (h < 0)     {         y += h * Math.cos(_a);         x -= h * Math.sin(_a);     }             w = Math.abs(w);     h = Math.abs(h);       return [x, y, w, h, a, _a]; }


class e1974 extends a1975 {     input = null;      props = null;           constructor(type, nodeId, options)     {         super(type, nodeId, options);     }        reset()     {         super.reset();          this.input = null;         this.props = null;     }        t3455(base)     {         super.t3455(base);                  if (base.input) this.input = base.input.copy();         if (base.props) this.props = base.props.copy();     }        w4334(m3091)     {         switch (m3091)         {             case 'props':  return this.input ? this.value.props : this.props;         }          return null;     }        n2996()     {         return this.value             && this.value.props             && this.value.props.isValid();     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        async l2995(parse)     {         let props = await evalListValue(this.props, parse);          if (   props             && j1214.includes(props.type))             props = new w2021([props]);                   if (this.value)         {             if (this.input)             {                 this.value.props = props ?? this.input.toNewValue().props;                                  if (props)  this.value.props = props;  else  props = this.value.props;               }             else                 this.value.props = props;                                   if (   this.value                 && this.value.isValid()                 && this.value.props != undefined)              {                 this.c4193(parse,                  [                                      ],                  true);                                   if (!this.props) this.props = this.value.props.copy();             }         }     }        async x4192(parse)     {         if (!this.value)             return;           for (const b111 of this.value.objects)         {             c950(b111.fills,   'obj.fills   must not be null');             c950(b111.strokes, 'obj.strokes must not be null');             c950(b111.effects, 'obj.effects must not be null');               if (this.value.props)                 addProps(b111, this.value.props);         }     }        evalStyle(options = {})     {      }        isValid()     {         return super.isValid()             && (!this.input || this.input.isValid())             && this.props && this.props.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.input) this.input.p4180(parse);         if (this.props) this.props.p4180(parse);     }            i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.input) this.input.i4181(parse, from, force);         if (this.props) this.props.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.input) this.input.i4179(parse);         if (this.props) this.props.i4179(parse);     } }    function addProps(b111, props) {     if (o955(props.type))     {                        for (let i = 0; i < props.items.length; i++)             o1823(b111, props.items[i]);     }     else         o1823(b111, props); }


class r1969 extends e1974 {     round = null;        constructor(nodeId, options)     {         super(f1218, nodeId, options);     }        reset()     {         super.reset();          this.round = null;     }        copy()     {         const copy = new r1969(this.nodeId, this.options);          copy.t3455(this);          if (this.round) copy.round = this.round.copy();          return copy;     }        w4334(m3091)     {         switch (m3091)         {             case 'x':      return this.input ? this.value.x      : this.x;             case 'y':      return this.input ? this.value.y      : this.y;             case 'width':  return this.input ? this.value.width  : this.width;             case 'height': return this.input ? this.value.height : this.height;             case 'round':  return this.input ? this.value.round  : this.round;         }          return super.w4334(m3091);     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalRectangleValue(this.input, parse);         let   round = await evalNumberValue   (this.round, parse);          if (round && !round.isValid()) round = k2022.NaN();                   let [x, y, width, height] = await this.evalBaseParams(parse);           if (input)         {             this.value        = input.toNewValue();             this.value.nodeId = this.nodeId;                          this.value.d3721(input);                          if (x     )  this.value.x      = x;       else  x      = this.value.x;                   if (y     )  this.value.y      = y;       else  y      = this.value.y;                   if (width )  this.value.width  = width;   else  width  = this.value.width;               if (height)  this.value.height = height;  else  height = this.value.height;              if (round )  this.value.round  = round;   else  round  = this.value.round;           }         else         {             this.value = new g2025(                 this.nodeId,                  x,                  y,                  width,                  height,                  round);         }                  this.c4193(parse,          [             ['x',      x     ],             ['y',      y     ],             ['width',  width ],             ['height', height],             ['round',  round ]         ]);           await this.l2995(parse);           await this.x4192(parse);           if (!this.x     ) this.x      = this.value.x     .copy();         if (!this.y     ) this.y      = this.value.y     .copy();         if (!this.width ) this.width  = this.value.width .copy();         if (!this.height) this.height = this.value.height.copy();         if (!this.round ) this.round  = this.value.round .copy();           this.validate();          return this;     }        async x4192(parse, options = {})     {         if (!this.options.enabled)             return;                        this.value.objects = [];           if (   super.n2996()                && this.value.x     .isValid()             && this.value.y     .isValid()             && this.value.width .isValid()             && this.value.height.isValid()             && this.value.round .isValid())         {             let   x = this.value.x     .value;             let   y = this.value.y     .value;             let   w = this.value.width .value;             let   h = this.value.height.value;             const r = Math.max(0, this.value.round.value);               [x, y, w, h, , ] = validateObjectRect(x, y, w, h);               if (   w != 0                  && h != 0)             {                 const rect = new o1846(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     x, y, w, h, r);                  rect.x4190(x, y);                 rect.z3825(x, y, w, h);                  this.value.objects.push(rect);             }         }                   await super.x4192(parse);     }                                                                                    isValid()     {         return super.isValid()             && this.round && this.round.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.round) this.round.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.round) this.round.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.round) this.round.i4179(parse);     } }


class i1960 extends e1974 {     constructor(nodeId, options)     {         super(y1221, nodeId, options);     }        copy()     {         const copy = new i1960(this.nodeId, this.options);          copy.t3455(this);          return copy;     }        w4334(m3091)     {         switch (m3091)         {             case 'x':     return this.input ? this.value.x     : this.x;             case 'y':     return this.input ? this.value.y     : this.y;             case 'width': return this.input ? this.value.width : this.width;         }          return super.w4334(m3091);     }        async eval(parse)     {         if (this.isCached())             return this;           let input = await evalLineValue(this.input, parse);          let [x, y, width, ] = await this.evalBaseParams(parse, false);                       if (input)         {             this.value        = input.toNewValue();             this.value.nodeId = this.nodeId;             this.value.d3721(input);              if (x    )  this.value.x     = x;      else  x     = this.value.x;                   if (y    )  this.value.y     = y;      else  y     = this.value.y;                   if (width)  this.value.width = width;  else  width = this.value.width;           }         else         {             this.value = new z2020(                 this.nodeId,                  x,                  y,                  width);         }           this.c4193(parse,          [             ['x',      x     ],             ['y',      y     ],             ['width',  width ]         ]);           await this.l2995(parse);           await this.x4192(parse);           if (!this.x    ) this.x     = this.value.x    .copy();         if (!this.y    ) this.y     = this.value.y    .copy();         if (!this.width) this.width = this.value.width.copy();           this.validate();          return this;     }        async x4192(parse, options = {})     {         if (!this.options.enabled)             return;                       this.value.objects = [];           if (   super.n2996()                && this.value.x    .isValid()             && this.value.y    .isValid()             && this.value.width.isValid())          {             let x = this.value.x    .value;             let y = this.value.y    .value;             let w = this.value.width.value;               [x, y, w, , , ] = validateObjectRect(x, y, w, 0);               if (w != 0)             {                 const line = new x1842(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     x, y, w);                  line.x4190(x, y);                 line.z3825(x, y, w, 0.01);                                  this.value.objects.push(line);             }         }                   await super.x4192(parse);     }        isValid()     {         return super.isValid()             && this.x     && this.x    .isValid()             && this.y     && this.y    .isValid()             && this.width && this.width.isValid();     }        p4180(parse)     {         super.p4180(parse);           if (this.x    ) this.x    .p4180(parse);         if (this.y    ) this.y    .p4180(parse);         if (this.width) this.width.p4180(parse);     }                   i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.x    ) this.x    .i4181(parse, from, force);         if (this.y    ) this.y    .i4181(parse, from, force);         if (this.width) this.width.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);           if (this.x    ) this.x    .i4179(parse);         if (this.y    ) this.y    .i4179(parse);         if (this.width) this.width.i4179(parse);     } }


class q1956 extends e1974 {     position = null;     round    = null;     start    = null;     sweep    = null;     inner    = null;      innerAbsolute;     startInDegrees;     sweepInDegrees;        constructor(nodeId, options)     {         super(w1224, nodeId, options);     }        reset()     {         super.reset();          this.position = null;         this.round    = null;         this.start    = null;         this.sweep    = null;         this.inner    = null;     }        copy()     {         const copy = new q1956(this.nodeId, this.options);          copy.t3455(this);          if (this.position) copy.position = this.position.copy();         if (this.round   ) copy.round    = this.round   .copy();         if (this.start   ) copy.start    = this.start   .copy();         if (this.sweep   ) copy.sweep    = this.sweep   .copy();         if (this.inner   ) copy.inner    = this.inner   .copy();                  return copy;     }        w4334(m3091)     {         switch (m3091)         {             case 'position': return this.input ? this.value.position : this.position;             case 'x':        return this.input ? this.value.x        : this.x;             case 'y':        return this.input ? this.value.y        : this.y;             case 'width':    return this.input ? this.value.width    : this.width;             case 'height':   return this.input ? this.value.height   : this.height;             case 'round':    return this.input ? this.value.round    : this.round;             case 'start':    return this.input ? this.value.start    : this.start;             case 'sweep':    return this.input ? this.value.sweep    : this.sweep;             case 'inner':    return this.input ? this.value.inner    : this.inner         }          return super.w4334(m3091);     }        async eval(parse)     {         if (this.isCached())             return this;           let input = await evalValue      (this.input,    parse);          let [x, y, width, height] = await this.evalBaseParams(parse);          let pos   = await evalNumberValue(this.position, parse);         let round = await evalNumberValue(this.round,    parse);         let start = await evalNumberValue(this.start,    parse);         let sweep = await evalNumberValue(this.sweep,    parse);         let inner = await evalNumberValue(this.inner,    parse);                                                         if (input)         {             this.value        = input.copy();             this.value.nodeId = this.nodeId;             this.value.d3721(input);              if (pos   )  this.value.position = pos;     else  pos    = this.value.position;             if (x     )  this.value.x        = x;       else  x      = this.value.x;                   if (y     )  this.value.y        = y;       else  y      = this.value.y;                   if (width )  this.value.width    = width;   else  width  = this.value.width;               if (height)  this.value.height   = height;  else  height = this.value.height;              if (round )  this.value.round    = round;   else  round  = this.value.round;               if (start )  this.value.start    = start;   else  start  = this.value.start;             if (sweep )  this.value.sweep    = sweep;   else  sweep  = this.value.sweep;             if (inner )  this.value.inner    = inner;   else  inner  = this.value.inner;           }         else         {             this.value = new j2012(                 this.nodeId,                 pos,                 x,                  y,                  width,                  height,                 round,                 start,                 sweep,                 inner);         }           this.c4193(parse,          [             ['position', pos   ],             ['x',        x     ],             ['y',        y     ],             ['width',    width ],             ['height',   height],             ['round',    round ],             ['start',    start ],             ['sweep',    sweep ],             ['inner',    inner ]         ]);           await this.l2995(parse);           await this.x4192(parse);           this.validate();          return this;     }        async x4192(parse, options = {})     {        if (!this.options.enabled)            return;                                 this.value.objects = [];           if (   super.n2996()             && this.value.x     .isValid()             && this.value.y     .isValid()             && this.value.width .isValid()             && this.value.height.isValid())          {             const vpos = this.value.position;             const vx   = this.value.x;             const vy   = this.value.y;             const vw   = this.value.width;             const vh   = this.value.height;              const _x = vpos.value <= 0 ? vx : new k2022(vx.value - vw.value, Math.max(vx.decimals, vw.decimals));             const _y = vpos.value <= 0 ? vy : new k2022(vy.value - vh.value, Math.max(vy.decimals, vh.decimals));             const _w = vpos.value <= 0 ? vw : new k2022(vw.value*2, Math.max(vx.decimals, vw.decimals));             const _h = vpos.value <= 0 ? vh : new k2022(vh.value*2, Math.max(vy.decimals, vh.decimals));                          let   x  = _x.value;             let   y  = _y.value;             let   w  = _w.value;             let   h  = _h.value;             let   r  = this.value.round .value;             let   st = this.value.start .value;             let   sw = this.value.sweep .value;             let   i  = this.value.inner .value;               [x, y, w, h, , ] = validateObjectRect(x, y, w, h);               if (   w != 0                  && h != 0)             {                 if ( this.innerAbsolute ) i  /= Math.max(w, h) / 200;                 if (!this.startInDegrees) st *= 3.6;                 if ( this.sweepInDegrees) sw /= 3.6;                  const ellipse = new k1840(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     x, y, w, h, r, st, sw, i);                  ellipse.x4190(x, y);                 ellipse.z3825(x, y, w, h);                  this.value.objects.push(ellipse);             }         }           await super.x4192(parse);     }                       isValid()     {         return super.isValid()             && this.position && this.position.isValid()             && this.round    && this.round   .isValid()             && this.start    && this.start   .isValid()             && this.sweep    && this.sweep   .isValid()             && this.inner    && this.inner   .isValid();     }        p4180(parse)     {         super.p4180(parse);           if (this.position) this.position.p4180(parse);         if (this.round   ) this.round   .p4180(parse);         if (this.start   ) this.start   .p4180(parse);         if (this.sweep   ) this.sweep   .p4180(parse);         if (this.inner   ) this.inner   .p4180(parse);     }                   i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.position) this.position.i4181(parse, from, force);         if (this.round   ) this.round   .i4181(parse, from, force);         if (this.start   ) this.start   .i4181(parse, from, force);         if (this.sweep   ) this.sweep   .i4181(parse, from, force);         if (this.inner   ) this.inner   .i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);           if (this.position) this.position.i4179(parse);         if (this.round   ) this.round   .i4179(parse);         if (this.start   ) this.start   .i4179(parse);         if (this.sweep   ) this.sweep   .i4179(parse);         if (this.inner   ) this.inner   .i4179(parse);     } }


class s1980 extends e1974 {     round = null;     bias  = null;        constructor(nodeId, options)     {         super(n1227, nodeId, options);     }        reset()     {         super.reset();          this.round = null;         this.bias  = null;     }        copy()     {         const copy = new s1980(this.nodeId, this.options);          copy.t3455(this);          if (this.round) copy.round = this.round.copy();         if (this.bias ) copy.bias  = this.bias .copy();          return copy;     }        w4334(m3091)     {         switch (m3091)         {             case 'x':      return this.input ? this.value.x      : this.x;             case 'y':      return this.input ? this.value.y      : this.y;             case 'width':  return this.input ? this.value.width  : this.width;             case 'height': return this.input ? this.value.height : this.height;             case 'round':  return this.input ? this.value.round  : this.round;             case 'bias':   return this.input ? this.value.bias   : this.bias;         }          return super.w4334(m3091);     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalValue      (this.input, parse);         let   round = await evalNumberValue(this.round, parse);         let   bias  = await evalNumberValue(this.bias,  parse);                  let [x, y, width, height] = await this.evalBaseParams(parse);           if (input)         {             this.value        = input.toNewValue();             this.value.nodeId = this.nodeId;             this.value.d3721(input);              if (x     )  this.value.x      = x;       else  x      = this.value.x;                   if (y     )  this.value.y      = y;       else  y      = this.value.y;                   if (width )  this.value.width  = width;   else  width  = this.value.width;               if (height)  this.value.height = height;  else  height = this.value.height;              if (round )  this.value.round  = round;   else  round  = this.value.round;               if (bias  )  this.value.bias   = bias;    else  bias   = this.value.bias;           }         else         {             this.value = new s2034(                 this.nodeId,                  x,                  y,                  width,                  height,                  round,                 bias);         }                  this.c4193(parse,          [             ['x',      x     ],             ['y',      y     ],             ['width',  width ],             ['height', height],             ['round',  round ],             ['bias',   bias  ]         ]);           await this.l2995(parse);           await this.x4192(parse);           if (!this.x     ) this.x      = this.value.x     .copy();         if (!this.y     ) this.y      = this.value.y     .copy();         if (!this.width ) this.width  = this.value.width .copy();         if (!this.height) this.height = this.value.height.copy();         if (!this.round ) this.round  = this.value.round .copy();         if (!this.bias  ) this.bias   = this.value.bias  .copy();           this.validate();          return this;     }        async x4192(parse, options = {})     {         if (!this.options.enabled)             return;                        this.value.objects = [];           if (   super.n2996()                && this.value.x     .isValid()                 && this.value.y     .isValid()                 && this.value.width .isValid()             && this.value.height.isValid()             && this.value.round .isValid()             && this.value.bias  .isValid())         {             let   x = this.value.x     .value;             let   y = this.value.y     .value;             let   w = this.value.width .value;             let   h = this.value.height.value;             const r = Math.max(0, this.value.round.value);             let   b = this.value.bias  .value;               [x, y, w, h, , ] = validateObjectRect(x, y, w, h);               if (   w != 0                  && h != 0)             {                 const trapeze = new g1851(                     this.nodeId,                      this.nodeId,                      this.nodeName,                      x, y, w, h, r, b);                  trapeze.x4190(x, y);                 trapeze.z3825(x, y, w, h);                  this.value.objects.push(trapeze);             }         }           await super.x4192(parse);     }        isValid()     {         return super.isValid()             && this.round && this.round.isValid()             && this.bias  && this.bias .isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.round) this.round.p4180(parse);         if (this.bias ) this.bias .p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.round) this.round.i4181(parse, from, force);         if (this.bias ) this.bias .i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.round) this.round.i4179(parse);         if (this.bias ) this.bias .i4179(parse);     } }


class u1968 extends e1974 {     position = null;     round    = null;     corners  = null;        constructor(nodeId, options)     {         super(w1236, nodeId, options);     }        reset()     {         super.reset();          this.position = null;         this.round    = null;         this.corners  = null;     }        copy()     {         const copy = new u1968(this.nodeId, this.options);          copy.t3455(this);          if (this.position) copy.position = this.position.copy();         if (this.round   ) copy.round    = this.round   .copy();         if (this.corners ) copy.corners  = this.corners .copy();          return copy;     }        w4334(m3091)     {         switch (m3091)         {             case 'position': return this.input ? this.value.position : this.position;             case 'x':        return this.input ? this.value.x        : this.x;             case 'y':        return this.input ? this.value.y        : this.y;             case 'width':    return this.input ? this.value.width    : this.width;             case 'height':   return this.input ? this.value.height   : this.height;             case 'round':    return this.input ? this.value.round    : this.round;             case 'corners':  return this.input ? this.value.corners  : this.corners;         }          return super.w4334(m3091);     }        async eval(parse)     {         if (this.isCached())             return this;                       let [x, y, width, height] = await this.evalBaseParams(parse);          let input   = await evalPolygonValue(this.input,    parse);         let pos     = await evalNumberValue (this.position, parse);         let round   = await evalNumberValue (this.round,    parse);         let corners = await evalNumberValue (this.corners,  parse);           if (input)         {             this.value        = input.toNewValue();             this.value.nodeId = this.nodeId;             this.value.d3721(input);              if (pos    )  this.value.position = pos;      else  pos     = this.value.position;             if (x      )  this.value.x        = x;        else  x       = this.value.x;                   if (y      )  this.value.y        = y;        else  y       = this.value.y;                   if (width  )  this.value.width    = width;    else  width   = this.value.width;               if (height )  this.value.height   = height;   else  height  = this.value.height;              if (round  )  this.value.round    = round;    else  round   = this.value.round;               if (corners)  this.value.corners  = corners;  else  corners = this.value.corners;           }         else         {             this.value = new z2024(                 this.nodeId,                 pos,                 x,                  y,                  width,                  height,                 round,                 corners);         }           this.c4193(parse,          [             ['position', pos    ],             ['x',        x      ],             ['y',        y      ],             ['width',    width  ],             ['height',   height ],             ['round',    round  ],             ['corners',  corners]         ]);           await this.l2995(parse);           await this.x4192(parse);           if (!this.position) this.position = this.value.position.copy();         if (!this.x       ) this.x        = this.value.x       .copy();         if (!this.y       ) this.y        = this.value.y       .copy();         if (!this.width   ) this.width    = this.value.width   .copy();         if (!this.height  ) this.height   = this.value.height  .copy();         if (!this.round   ) this.round    = this.value.round   .copy();         if (!this.corners ) this.corners  = this.value.corners .copy();           this.validate();          return this;     }        async x4192(parse, options = {})     {         if (!this.options.enabled)             return;                                   this.value.objects = [];           if (   super.n2996()                && this.value.x      .isValid()             && this.value.y      .isValid()             && this.value.width  .isValid()             && this.value.height .isValid()             && this.value.round  .isValid()             && this.value.corners.isValid())         {             const vpos = this.value.position;             const vx   = this.value.x;             const vy   = this.value.y;             const vw   = this.value.width;             const vh   = this.value.height;              const _x = vpos.value <= 0 ? vx : new k2022(vx.value - vw.value, Math.max(vx.decimals, vw.decimals));             const _y = vpos.value <= 0 ? vy : new k2022(vy.value - vh.value, Math.max(vy.decimals, vh.decimals));             const _w = vpos.value <= 0 ? vw : new k2022(vw.value*2, Math.max(vx.decimals, vw.decimals));             const _h = vpos.value <= 0 ? vh : new k2022(vh.value*2, Math.max(vy.decimals, vh.decimals));                          let   x = _x.value;             let   y = _y.value;             let   w = _w.value;             let   h = _h.value;             const r = Math.max(0, this.value.round.value);             const c = Math.max(3, Math.floor(this.value.corners.value));               [x, y, w, h, , ] = validateObjectRect(x, y, w, h);               if (   w != 0                  && h != 0)             {                 const poly = new w1845(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     x, y, w, h, r, c);                  poly.x4190(x, y);                 poly.z3825(x, y, w, h);                  this.value.objects.push(poly);             }         }                   await super.x4192(parse);     }                                                                                              isValid()     {         return super.isValid()             && this.position && this.position.isValid()             && this.round    && this.round   .isValid()             && this.corners  && this.corners .isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.position) this.position.p4180(parse);         if (this.round   ) this.round   .p4180(parse);         if (this.corners ) this.corners .p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.position) this.position.i4181(parse, from, force);         if (this.round   ) this.round   .i4181(parse, from, force);         if (this.corners ) this.corners .i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.position) this.position.i4179(parse);         if (this.round   ) this.round   .i4179(parse);         if (this.corners ) this.corners .i4179(parse);     } }


 class t1978 extends e1974 {     position = null;     round    = null;     points   = null;     convex   = null;        constructor(nodeId, options)     {         super(t1239, nodeId, options);     }        reset()     {         super.reset();          this.position = null;         this.round    = null;         this.points   = null;         this.convex   = null;     }        copy()     {         const copy = new t1978(this.nodeId, this.options);          copy.t3455(this);          if (this.position) copy.position = this.position.copy();         if (this.round   ) copy.round    = this.round   .copy();         if (this.points  ) copy.points   = this.points  .copy();         if (this.convex  ) copy.convex   = this.convex  .copy();          return copy;     }        w4334(m3091)     {         switch (m3091)         {             case 'position': return this.input ? this.value.position : this.position;             case 'x':        return this.input ? this.value.x        : this.x;             case 'y':        return this.input ? this.value.y        : this.y;             case 'width':    return this.input ? this.value.width    : this.width;             case 'height':   return this.input ? this.value.height   : this.height;             case 'round':    return this.input ? this.value.round    : this.round;             case 'points':   return this.input ? this.value.points   : this.points;             case 'convex':   return this.input ? this.value.convex   : this.convex;         }          return super.w4334(m3091);     }        async eval(parse)     {         if (this.isCached())             return this;                       let [x, y, width, height] = await this.evalBaseParams(parse);          let input  = await evalValue      (this.input,    parse);         let pos    = await evalNumberValue(this.position, parse);         let round  = await evalNumberValue(this.round,    parse);         let points = await evalNumberValue(this.points,   parse);         let convex = await evalNumberValue(this.convex,   parse);           if (input)         {             this.value        = input.toNewValue();             this.value.nodeId = this.nodeId;             this.value.d3721(input);              if (pos   )  this.value.position = pos;     else  pos    = this.value.position;             if (x     )  this.value.x        = x;       else  x      = this.value.x;                   if (y     )  this.value.y        = y;       else  y      = this.value.y;                   if (width )  this.value.width    = width;   else  width  = this.value.width;               if (height)  this.value.height   = height;  else  height = this.value.height;              if (round )  this.value.round    = round;   else  round  = this.value.round;               if (points)  this.value.points   = points;  else  points = this.value.points;               if (convex)  this.value.convex   = convex;  else  convex = this.value.convex;          }         else         {             this.value = new t2030(                 this.nodeId,                 pos,                 x,                  y,                  width,                  height,                 round,                 points,                 convex);         }           this.c4193(parse,          [             ['position', pos   ],             ['x',        x     ],             ['y',        y     ],             ['width',    width ],             ['height',   height],             ['round',    round ],             ['points',   points],             ['convex',   convex]         ]);           await this.l2995(parse);           await this.x4192(parse);           if (!this.position) this.position = this.value.position.copy();         if (!this.x       ) this.x        = this.value.x       .copy();         if (!this.y       ) this.y        = this.value.y       .copy();         if (!this.width   ) this.width    = this.value.width   .copy();         if (!this.height  ) this.height   = this.value.height  .copy();         if (!this.round   ) this.round    = this.value.round   .copy();         if (!this.points  ) this.points   = this.value.points  .copy();         if (!this.convex  ) this.convex   = this.value.convex  .copy();            this.validate();          return this;    }       async x4192(parse, options = {})    {         if (!this.options.enabled)            return;                                 this.value.objects = [];           if (   super.n2996()                && this.value.x     .isValid()             && this.value.y     .isValid()             && this.value.width .isValid()             && this.value.height.isValid()              && this.value.round .isValid()             && this.value.points.isValid()             && this.value.convex.isValid())         {             const vpos = this.value.position;             const vx   = this.value.x;             const vy   = this.value.y;             const vw   = this.value.width;             const vh   = this.value.height;              const _x = vpos.value <= 0 ? vx : new k2022(vx.value - vw.value, Math.max(vx.decimals, vw.decimals));             const _y = vpos.value <= 0 ? vy : new k2022(vy.value - vh.value, Math.max(vy.decimals, vh.decimals));             const _w = vpos.value <= 0 ? vw : new k2022(vw.value*2, Math.max(vx.decimals, vw.decimals));             const _h = vpos.value <= 0 ? vh : new k2022(vh.value*2, Math.max(vy.decimals, vh.decimals));                          let   x = _x.value;             let   y = _y.value;             let   w = _w.value;             let   h = _h.value;             const r = Math.max(0, this.value.round.value);             const p = Math.max(3, Math.floor(this.value.points.value));             const c = this.value.convex.value;               if (   w != 0                 && h != 0)             {                 const star = new x1849(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     x, y, w, h, r, p, c);                  star.x4190(x, y);                 star.z3825(x, y, w, h);                  this.value.objects.push(star);             }         }                  await super.x4192(parse);     }                                                                                                    isValid()     {         return super.isValid()             && this.position && this.position.isValid()             && this.round    && this.round   .isValid()             && this.points   && this.points  .isValid()             && this.convex   && this.convex  .isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.position) this.position.p4180(parse);         if (this.round   ) this.round   .p4180(parse);         if (this.points  ) this.points  .p4180(parse);         if (this.convex  ) this.convex  .p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.position) this.position.i4181(parse, from, force);         if (this.round   ) this.round   .i4181(parse, from, force);         if (this.points  ) this.points  .i4181(parse, from, force);         if (this.convex  ) this.convex  .i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.position) this.position.i4179(parse);         if (this.round   ) this.round   .i4179(parse);         if (this.points  ) this.points  .i4179(parse);         if (this.convex  ) this.convex  .i4179(parse);     } }


class e1979 extends e1974 {     text          = null;     x             = null;     y             = null;     width         = null;     height        = null;     font          = null;     size          = null;     style         = null;     alignX        = null;     alignY        = null;     lineHeight    = null;     letterSpacing = null;                constructor(nodeId, options)     {         super(p1242, nodeId, options);     }            reset()     {         super.reset();                  this.text          = null;         this.x             = null;         this.y             = null;         this.width         = null;         this.height        = null;         this.font          = null;         this.size          = null;         this.style         = null;         this.alignX        = null;         this.alignY        = null;         this.lineHeight    = null;         this.letterSpacing = null;     }        copy()     {         const copy = new e1979(this.nodeId, this.options);          copy.t3455(this);          if (this.text         ) copy.text          = this.text         .copy();         if (this.x            ) copy.x             = this.x            .copy();         if (this.y            ) copy.y             = this.y            .copy();         if (this.width        ) copy.width         = this.width        .copy();         if (this.height       ) copy.height        = this.height       .copy();         if (this.font         ) copy.font          = this.font         .copy();         if (this.style        ) copy.style         = this.style        .copy();         if (this.size         ) copy.size          = this.size         .copy();         if (this.alignX       ) copy.alignX        = this.alignX       .copy();         if (this.alignY       ) copy.alignY        = this.alignY       .copy();         if (this.lineHeight   ) copy.lineHeight    = this.lineHeight   .copy();         if (this.letterSpacing) copy.letterSpacing = this.letterSpacing.copy();          return copy;     }        w4334(m3091)     {         switch (m3091)         {             case 'text':          return this.input ? this.value.text          : this.text;             case 'x':             return this.input ? this.value.x             : this.x;             case 'y':             return this.input ? this.value.y             : this.y;             case 'width':         return this.input ? this.value.width         : this.width;             case 'height':        return this.input ? this.value.height        : this.height;             case 'font':          return this.input ? this.value.font          : this.font;             case 'style':         return this.input ? this.value.style         : this.style;             case 'size':          return this.input ? this.value.size          : this.size;             case 'alignX':        return this.input ? this.value.alignX        : this.alignX;             case 'alignY':        return this.input ? this.value.alignY        : this.alignY;             case 'lineHeight':    return this.input ? this.value.lineHeight    : this.lineHeight;             case 'letterSpacing': return this.input ? this.value.letterSpacing : this.letterSpacing;         }          return super.w4334(m3091);     }        async eval(parse)     {         if (this.isCached())             return this;           const input         = await evalTextShapeValue(this.input,         parse);         let   text          = await evalTextValue     (this.text,          parse);         let   x             = await evalNumberValue   (this.x,             parse);         let   y             = await evalNumberValue   (this.y,             parse);         let   width         = await evalNumberValue   (this.width,         parse);         let   height        = await evalNumberValue   (this.height,        parse);         let   font          = await evalNumberValue   (this.font,          parse);         let   style         = await evalNumberValue   (this.style,         parse);         let   size          = await evalNumberValue   (this.size,          parse);         let   alignX        = await evalNumberValue   (this.alignX,        parse);         let   alignY        = await evalNumberValue   (this.alignY,        parse);         let   lineHeight    = await evalNumberValue   (this.lineHeight,    parse);         let   letterSpacing = await evalNumberValue   (this.letterSpacing, parse);           if (text          && !text         .isValid()) text          = new f2033();         if (x             && !x            .isValid()) x             = k2022.NaN();         if (y             && !y            .isValid()) y             = k2022.NaN();         if (width         && !width        .isValid()) width         = k2022.NaN();         if (height        && !height       .isValid()) height        = k2022.NaN();         if (font          && !font         .isValid()) font          = k2022.NaN();         if (style         && !style        .isValid()) style         = k2022.NaN();         if (size          && !size         .isValid()) size          = k2022.NaN();         if (alignX        && !alignX       .isValid()) alignX        = k2022.NaN();         if (alignY        && !alignY       .isValid()) alignY        = k2022.NaN();         if (lineHeight    && !lineHeight   .isValid()) lineHeight    = k2022.NaN();         if (letterSpacing && !letterSpacing.isValid()) letterSpacing = k2022.NaN();                    if (text          && text         .type !=   h1142) text          = new f2033();         if (x             && x            .type != c1090) x             = k2022.NaN();         if (y             && y            .type != c1090) y             = k2022.NaN();         if (width         && width        .type != c1090) width         = k2022.NaN();         if (height        && height       .type != c1090) height        = k2022.NaN();         if (font          && font         .type != c1090) font          = k2022.NaN();         if (style         && style        .type != c1090) style         = k2022.NaN();         if (size          && size         .type != c1090) size          = k2022.NaN();         if (alignX        && alignX       .type != c1090) alignX        = k2022.NaN();         if (alignY        && alignY       .type != c1090) alignY        = k2022.NaN();         if (lineHeight    && lineHeight   .type != c1090) lineHeight    = k2022.NaN();         if (letterSpacing && letterSpacing.type != c1090) letterSpacing = k2022.NaN();                   if (input)         {             this.value        = input.toNewValue();             this.value.nodeId = this.nodeId;             this.value.d3721(input);                          if (text         )  this.value.text          = text;           else  text          = this.value.text;             if (x            )  this.value.x             = x;              else  x             = this.value.x;             if (y            )  this.value.y             = y;              else  y             = this.value.y;             if (width        )  this.value.width         = width;          else  width         = this.value.width;             if (height       )  this.value.height        = height;         else  height        = this.value.height;             if (font         )  this.value.font          = font;           else  font          = this.value.font;             if (style        )  this.value.style         = style;          else  style         = this.value.style;             if (size         )  this.value.size          = size;           else  size          = this.value.size;             if (alignX       )  this.value.alignX        = alignX;         else  alignX        = this.value.alignX;             if (alignY       )  this.value.alignY        = alignY;         else  alignY        = this.value.alignY;             if (lineHeight   )  this.value.lineHeight    = lineHeight;     else  lineHeight    = this.value.lineHeight;             if (letterSpacing)  this.value.letterSpacing = letterSpacing;  else  letterSpacing = this.value.letterSpacing;          }         else         {             this.value = new g2032(                 this.nodeId,                  text,                  x,                  y,                  width,                  height,                  font,                  style,                 size,                 alignX,                 alignY,                 lineHeight,                 letterSpacing);         }                  this.c4193(parse,          [             ['text',          text         ],             ['x',             x            ],             ['y',             y            ],             ['width',         width        ],             ['height',        height       ],             ['font',          font         ],             ['style',         style        ],             ['size',          size         ],             ['alignX',        alignX       ],             ['alignY',        alignY       ],             ['lineHeight',    lineHeight   ],             ['letterSpacing', letterSpacing]         ]);           await this.l2995(parse);           await this.x4192(parse);           if (!this.text         ) this.text          = this.value.text         .copy();         if (!this.x            ) this.x             = this.value.x            .copy();         if (!this.y            ) this.y             = this.value.y            .copy();         if (!this.width        ) this.width         = this.value.width        .copy();         if (!this.height       ) this.height        = this.value.height       .copy();         if (!this.font         ) this.font          = this.value.font         .copy();         if (!this.style        ) this.style         = this.value.style        .copy();         if (!this.size         ) this.size          = this.value.size         .copy();         if (!this.alignX       ) this.alignX        = this.value.alignX       .copy();         if (!this.alignY       ) this.alignY        = this.value.alignY       .copy();         if (!this.lineHeight   ) this.lineHeight    = this.value.lineHeight   .copy();         if (!this.letterSpacing) this.letterSpacing = this.value.letterSpacing.copy();                   this.validate();          return this;     }        async x4192(parse, options = {})     {         if (!this.options.enabled)             return;                   this.value.objects = [];           if (   super.n2996()                && this.value.text         .isValid()             && this.value.x            .isValid()             && this.value.y            .isValid()             && this.value.width        .isValid()             && this.value.height       .isValid()             && this.value.font         .isValid()             && this.value.style        .isValid()             && this.value.size         .isValid()             && this.value.alignX       .isValid()             && this.value.alignY       .isValid()             && this.value.lineHeight   .isValid()             && this.value.letterSpacing.isValid())         {             let x = this.value.x     .value;             let y = this.value.y     .value;             let w = this.value.width .value;             let h = this.value.height.value;              const fontName   = v4133[this.value.font.value];             const fontStyles = getFontStyles(fontName);              const text = new j1850(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 this.value.text.value,                 x, y, w, h,                 fontName,                 this.value.size         .value,                 fontStyles[Math.min(this.value.style.value, fontStyles.length-1)],                 this.value.alignX       .value,                 this.value.alignY       .value,                 this.value.lineHeight   .value,                 this.value.letterSpacing.value);                               text.x4190(x, y);                                                                                                                                                                                                text.z3825(x, y, w, h);                  this.value.objects.push(text);                      }                   await super.x4192(parse);     }        isValid()     {         return super.isValid()             && this.text          && this.text         .isValid()             && this.x             && this.x            .isValid()             && this.y             && this.y            .isValid()             && this.width         && this.width        .isValid()             && this.height        && this.height       .isValid()             && this.font          && this.font         .isValid()             && this.style         && this.style        .isValid()             && this.size          && this.size         .isValid()             && this.alignX        && this.alignX       .isValid()             && this.alignY        && this.alignY       .isValid()             && this.lineHeight    && this.lineHeight   .isValid()             && this.letterSpacing && this.letterSpacing.isValid();     }        p4180(parse)     {         super.p4180(parse);                  if (this.text         ) this.text         .p4180(parse);         if (this.x            ) this.x            .p4180(parse);         if (this.y            ) this.y            .p4180(parse);         if (this.width        ) this.width        .p4180(parse);         if (this.height       ) this.height       .p4180(parse);         if (this.font         ) this.font         .p4180(parse);         if (this.style        ) this.style        .p4180(parse);         if (this.size         ) this.size         .p4180(parse);         if (this.alignX       ) this.alignX       .p4180(parse);         if (this.alignY       ) this.alignY       .p4180(parse);         if (this.lineHeight   ) this.lineHeight   .p4180(parse);         if (this.letterSpacing) this.letterSpacing.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);                  if (this.text         ) this.text         .i4181(parse, from, force);         if (this.x            ) this.x            .i4181(parse, from, force);         if (this.y            ) this.y            .i4181(parse, from, force);         if (this.width        ) this.width        .i4181(parse, from, force);         if (this.height       ) this.height       .i4181(parse, from, force);         if (this.font         ) this.font         .i4181(parse, from, force);         if (this.style        ) this.style        .i4181(parse, from, force);         if (this.size         ) this.size         .i4181(parse, from, force);         if (this.alignX       ) this.alignX       .i4181(parse, from, force);         if (this.alignY       ) this.alignY       .i4181(parse, from, force);         if (this.lineHeight   ) this.lineHeight   .i4181(parse, from, force);         if (this.letterSpacing) this.letterSpacing.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);                  if (this.text         ) this.text         .i4179(parse);         if (this.x            ) this.x            .i4179(parse);         if (this.y            ) this.y            .i4179(parse);         if (this.width        ) this.width        .i4179(parse);         if (this.height       ) this.height       .i4179(parse);         if (this.font         ) this.font         .i4179(parse);         if (this.style        ) this.style        .i4179(parse);         if (this.size         ) this.size         .i4179(parse);         if (this.alignX       ) this.alignX       .i4179(parse);         if (this.alignY       ) this.alignY       .i4179(parse);         if (this.lineHeight   ) this.lineHeight   .i4179(parse);         if (this.letterSpacing) this.letterSpacing.i4179(parse);     } }


class z1964 extends l2044 {     x = null;     y = null;        constructor(nodeId, options)     {         super(d1245, nodeId, options);     }        reset()     {         super.reset();          this.x = null;         this.y = null;     }        copy()     {         const copy = new z1964(this.nodeId, this.options);          copy.t3455(this);          if (this.value) copy.value = this.value.copy();         if (this.x    ) copy.x     = this.x    .copy();         if (this.y    ) copy.y     = this.y    .copy();          return copy;     }        w4334(m3091)     {         switch (m3091)         {             case 'x': return this.input ? this.value.x : this.x;             case 'y': return this.input ? this.value.y : this.y;         }          return null;     }        async eval(parse)     {         if (this.isCached())             return this;                   let input = await evalPointValue (this.input, parse);         let x     = await evalNumberValue(this.x,     parse);         let y     = await evalNumberValue(this.y,     parse);           if (   input             && input.isValid())         {             const u3907 = input;              if (input.type == s1251)             {                 input = new f2023(input.nodeId, input.x, input.y);                 input.d3721(u3907);             }                          this.value        = input;             this.value.nodeId = this.nodeId;             this.value.d3721(input);               if (   this.value.objects                 && this.value.objects.length > 0)             {                 this.value.x = new k2022(this.value.objects[0].x);                 this.value.y = new k2022(this.value.objects[0].y);             }                          if (x)  this.value.x = x;  else  x = this.value.x;             if (y)  this.value.y = y;  else  y = this.value.y;         }         else if (x                && y)         {             this.value = new f2023(                 this.nodeId,                  x,                  y);         }         else             this.value = f2023.NaN();           this.value.r3831 = this.r3831;           await this.x4192(parse);           this.c4193(parse,          [             ['x', x],             ['y', y]         ]);               this.validate();          return this;     }        async x4192(parse, options = {})     {         if (!this.options.enabled)             return;                                   if (!this.value.objects)             this.value.objects = [];           if (   this.value.x             && this.value.y                && this.value.x.isValid()             && this.value.y.isValid())         {             const x = this.value.x.value;             const y = this.value.y.value;              const point = new e1844(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 x,                 y,                 this.smooth ? this.smooth.value/100 : 1);              point.x4190(x, y);              this.value.objects = [point];         }           await super.x4192(parse);     }        isValid()     {         return super.isValid()             && this.x && this.x.isValid()             && this.y && this.y.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.x) this.x.p4180(parse);         if (this.y) this.y.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.x) this.x.i4181(parse, from, force);         if (this.y) this.y.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.x) this.x.i4179(parse);         if (this.y) this.y.i4179(parse);     } }


class q1965 extends l2044 {     smooth = null;        constructor(nodeId, options)     {         super(u1247, nodeId, options);     }        reset()     {         super.reset();          this.smooth = null;     }        copy()     {         const copy = new q1965(this.nodeId, this.options);          copy.t3455(this);          if (this.value ) copy.value  = this.value .copy();         if (this.smooth) copy.smooth = this.smooth.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                   const input  = await evalPointValue (this.input,  parse);         const smooth = await evalNumberValue(this.smooth, parse);                  if (input)         {             this.value        = input;             this.value.nodeId = this.nodeId;             this.value.d3721(input);              this.value.smooth = smooth;               if (   this.value.objects                 && this.value.objects.length > 0)             {                 this.value.x = new k2022(this.value.objects[0].x);                 this.value.y = new k2022(this.value.objects[0].y);             }         }         else             this.value = f2023.NaN();           await this.x4192(parse);           this.c4193(parse,          [             ['smooth', smooth]         ]);           this.validate();          return this;     }        async x4192(parse, options = {})     {         if (!this.options.enabled)             return;                                   this.value.objects = [];           if (   this.value.x.isValid()             && this.value.y.isValid())         {             const x      = this.value.x.value;             const y      = this.value.y.value;             const smooth = this.value.smooth ? this.value.smooth.value/100 : 1;              const point = new e1844(                 this.nodeId,                  this.nodeId,                  this.nodeName,                  x,                  y,                  smooth);              point.x4190(x, y);              this.value.objects = [point];         }           await super.x4192(parse);     }        toNewValue()     {         return this.value.copy();                                                    }        isValid()     {         return super.isValid()             && this.smooth && this.smooth.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.smooth) this.smooth.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.smooth) this.smooth.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.smooth) this.smooth.i4179(parse);     } }


class l1984 extends e1974 {     points  = null;     closed  = null;     degree  = null;     winding = null;     round   = null;        constructor(nodeId, options)     {         super(p1249, nodeId, options);     }        reset()     {         super.reset();          this.points  = null;         this.closed  = null;         this.degree  = null;         this.winding = null;         this.round   = null;     }        copy()     {         const copy = new l1984(this.nodeId, this.options);          copy.t3455(this);          if (this.points ) copy.points  = this.points .copy();         if (this.closed ) copy.closed  = this.closed .copy();         if (this.degree ) copy.degree  = this.degree .copy();         if (this.winding) copy.winding = this.winding.copy();         if (this.round  ) copy.round   = this.round  .copy();          return copy;     }        w4334(m3091)     {         switch (m3091)         {             case 'points':  return this.input ? this.value.points  : this.points;             case 'closed':  return this.input ? this.value.closed  : this.closed;             case 'degree':  return this.input ? this.value.degree  : this.degree;             case 'winding': return this.input ? this.value.winding : this.winding;             case 'round':   return this.input ? this.value.round   : this.round;         }          return super.w4334(m3091);     }        async eval(parse)     {         if (this.isCached())             return this;           const input   = await evalVectorPathValue(this.input,   parse);         let   points  = await evalNumberValue    (this.points,  parse);         let   closed  = await evalNumberValue    (this.closed,  parse);         let   degree  = await evalNumberValue    (this.degree,  parse);         let   winding = await evalNumberValue    (this.winding, parse);         let   round   = await evalNumberValue    (this.round,   parse);           await this.evalBaseParams(parse);           if (input)         {                                                    if (   input.points                 && input.points.items                 && input.points.objects)             {                 c950(                      input.points.items.length == input.points.objects.length,                     'Vector path points input item count must match object count');                  for (let i = 0; i < input.points.items.length; i++)                 {                     const item = input.points.items  [i].copy();                     const b111  = input.points.objects[i].copy();                      if (item && b111)                     {                         item.x = new k2022(b111.x);                         item.y = new k2022(b111.y);                     }                 }             }               this.value = new g2037(                 this.nodeId,                    points                  && points.items.length > 0                  ? points                 : input.points,                 closed  ?? input.closed,                 degree  ?? input.degree,                 winding ?? input.winding,                 round   ?? input.round);              this.value.d3721(input);                           if (points )  this.value.points   = points;   else  points  = this.value.points;                 if (closed )  this.value.closed   = closed;   else  closed  = this.value.closed;                 if (degree )  this.value.degree   = degree;   else  degree  = this.value.degree;               if (winding)  this.value.windingt = winding;  else  winding = this.value.winding;              if (round  )  this.value.round    = round;    else  round   = this.value.round;           }         else         {             this.value = new g2037(                 this.nodeId,                  points,                  closed,                  degree,                  winding,                  round);         }                   this.c4193(parse,          [                        ['closed',  closed ],             ['degree',  degree ],             ['winding', winding],             ['round',   round  ]         ]);           await this.l2995(parse);           await this.x4192(parse);           this.validate();          return this;     }        async x4192(parse, options = {})     {         if (!this.options.enabled)             return;                       const points = [];          if (this.value.points.objects)         {             const m4194 = this.value.points.objects.filter(o => o.type == d1245);              for (const pt of m4194)             {                 const p = f2023.create(this.nodeId, pt.x, pt.y);                                  if (pt.smooth != null)                     p.smooth = new k2022(pt.smooth);                  points.push(p);             }         }           this.value.objects = [];           if (   super.n2996()                && points.length >= 2             && this.value.closed .isValid()             && this.value.degree .isValid()             && this.value.winding.isValid()             && this.value.round  .isValid())         {             const path = new x1853(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 points,                 this.value.closed .value,                 this.value.degree .value,                 this.value.winding.value,                 this.value.round  .value);                               const bounds = getObjBounds([path]);              path.q3837(                 bounds.x + bounds.width /2,                             bounds.y + bounds.height/2);               let x = bounds.x;             let y = bounds.y;             let w = bounds.w;             let h = bounds.h;                          path.x4190(x, y);             path.z3825(x, y, w, h);               this.value.objects.push(path);         }           await super.x4192(parse);     }        isValid()     {         return super.isValid()             && this.points  && this.points .isValid()             && this.closed  && this.closed .isValid()             && this.degree  && this.degree .isValid()             && this.winding && this.winding.isValid()             && this.round   && this.round  .isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.points ) this.points .p4180(parse);         if (this.closed ) this.closed .p4180(parse);         if (this.degree ) this.degree .p4180(parse);         if (this.winding) this.winding.p4180(parse);         if (this.round  ) this.round  .p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.points ) this.points .i4181(parse, from, force);         if (this.closed ) this.closed .i4181(parse, from, force);         if (this.degree ) this.degree .i4181(parse, from, force);         if (this.winding) this.winding.i4181(parse, from, force);         if (this.round  ) this.round  .i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.points ) this.points .i4179(parse);         if (this.closed ) this.closed .i4179(parse);         if (this.degree ) this.degree .i4179(parse);         if (this.winding) this.winding.i4179(parse);         if (this.round  ) this.round  .i4179(parse);     } }


class r1986 extends l2044 {     x     = null;     y     = null;     join  = null;     cap   = null;     round = null;        constructor(nodeId, options)     {         super(k1252, nodeId, options);     }        reset()     {         super.reset();          this.x     = null;         this.y     = null;         this.join  = null;         this.cap   = null;         this.round = null;     }        copy()     {         const copy = new r1986(this.nodeId, this.options);          copy.t3455(this);          if (this.x    ) copy.x     = this.x    .copy();         if (this.y    ) copy.y     = this.y    .copy();         if (this.join ) copy.join  = this.join .copy();         if (this.cap  ) copy.cap   = this.cap  .copy();         if (this.round) copy.round = this.round.copy();          return copy;     }        w4334(m3091)     {         switch (m3091)         {             case 'x':     return this.input ? this.value.x     : this.x;             case 'y':     return this.input ? this.value.y     : this.y;             case 'join':  return this.input ? this.value.join  : this.join;             case 'cap':   return this.input ? this.value.cap   : this.cap;             case 'round': return this.input ? this.value.round : this.round;         }          return null;     }        async eval(parse)     {         if (this.isCached())             return this;                   let input = await evalVectorVertexValue(this.input, parse);         let x     = await evalNumberValue      (this.x,     parse);         let y     = await evalNumberValue      (this.y,     parse);         let join  = await evalNumberValue      (this.join,  parse);         let cap   = await evalNumberValue      (this.cap,   parse);         let round = await evalNumberValue      (this.round, parse);           if (input)         {             const u3907 = input;              if (input.type == v1244)             {                 input = new d2039(input.nodeId, input.x, input.y);                 input.d3721(u3907);             }                          this.value        = input.copy();             this.value.nodeId = this.nodeId;             this.value.d3721(input);                                                                                                                          this.value.x     = new k2022(this.value.objects[0].x    );             this.value.y     = new k2022(this.value.objects[0].y    );             this.value.join  = new k2022(this.value.objects[0].join );             this.value.cap   = new k2022(this.value.objects[0].cap  );             this.value.round = new k2022(this.value.objects[0].round);              if (x    )  this.value.x     = x;      else  x     = this.value.x;             if (y    )  this.value.y     = y;      else  y     = this.value.y;             if (join )  this.value.join  = join;   else  join  = this.value.join;             if (cap  )  this.value.cap   = cap;    else  cap   = this.value.cap;             if (round)  this.value.round = round;  else  round = this.value.round;         }         else         {             this.value = new d2039(                 this.nodeId,                  x,                  y,                  join,                  cap,                  round);         }                  this.value.r3831 = this.r3831;           await this.x4192(parse);           this.c4193(parse,          [             ['value', this.value]         ]);           this.validate();          return this;     }        async x4192(parse, options = {})     {         if (!this.options.enabled)             return;                                   this.value.objects = [];           if (   this.value.x                 && this.value.y                 && this.value.join              && this.value.cap               && this.value.round)         {             const x     = this.value.x    .value;             const y     = this.value.y    .value;                                                     const point = new e1844(this.nodeId, this.nodeId, this.nodeName, x, y);              point.x4190(x, y);              this.value.objects = [point];         }           await super.x4192(parse);     }        toNewValue()     {         const point = new d2039(             this.nodeId,             this.x    .toNewValue(),             this.y    .toNewValue(),             this.join .toNewValue(),             this.cap  .toNewValue(),             this.round.toNewValue());          point.d3721(this.value);          point.objects  = this.value.objects.map(o => o.copy());         point.r3831 = this.value.r3831;          return point;     }        isValid()     {         return super.isValid()             && this.x    .isValid()             && this.y    .isValid()             && this.join .isValid()             && this.cap  .isValid()             && this.round.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.x    ) this.x    .p4180(parse);         if (this.y    ) this.y    .p4180(parse);         if (this.join ) this.join .p4180(parse);         if (this.cap  ) this.cap  .p4180(parse);         if (this.round) this.round.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.x    ) this.x    .i4181(parse, from, force);         if (this.y    ) this.y    .i4181(parse, from, force);         if (this.join ) this.join .i4181(parse, from, force);         if (this.cap  ) this.cap  .i4181(parse, from, force);         if (this.round) this.round.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.x    ) this.x    .i4179(parse);         if (this.y    ) this.y    .i4179(parse);         if (this.join ) this.join .i4179(parse);         if (this.cap  ) this.cap  .i4179(parse);         if (this.round) this.round.i4179(parse);     } }


class z1981 extends s2045 {     z3760 = null;     f3761   = null;                    constructor(nodeId, options)     {         super(p1255, nodeId, options);     }        reset()     {         super.reset();                  this.z3760 = null;         this.f3761   = null;     }        copy()     {         const copy = new z1981(this.nodeId, this.options);          copy.t3455(this);          if (this.z3760) copy.z3760 = this.z3760.copy();         if (this.f3761  ) copy.f3761   = this.f3761  .copy();          return copy;     }        w4334(m3091)     {         switch (m3091)         {             case 'startTangent': return this.input ? this.value.z3760 : this.z3760;             case 'endTangent':   return this.input ? this.value.f3761   : this.f3761;         }          return null;     }        async eval(parse)     {         if (this.isCached())             return this;                   let o4175       = await evalVectorVertexValue(this.o4175,       parse);         let i4176       = await evalVectorVertexValue(this.i4176,       parse);         let z3760 = await evalNumberValue      (this.z3760, parse);         let   f3761 = await evalNumberValue      (this.  f3761, parse);          if (   o4175             && i4176             && z3760             && f3761)         {             if (o4175.type == v1244) o4175 = new d2039(o4175.nodeId, o4175.x, o4175.y);             if (i4176.type == v1244) i4176 = new d2039(i4176.nodeId, i4176.x, i4176.y);              if (z3760.type == s1251) z3760 = new f2023(z3760.nodeId, z3760.x, z3760.y);             if (  f3761.type == s1251)   f3761 = new f2023(  f3761.nodeId,   f3761.x,   f3761.y);               this.value = new d2035(                 this.nodeId,                 o4175,                 i4176,                 z3760,                 f3761);               this.value.r3831 = this.r3831;         }         else             this.value = d2035.NaN();                           await this.x4192(parse);           this.c4193(parse,          [             ['value', this.value]         ]);           this.validate();          return this;     }        async x4192(parse, options = {})     {         if (   !this.options.enabled             || !this.value.start.isValid()             || !this.value.end  .isValid())             return;                                   this.value.objects = [];           if (   this.value.start.isValid()             && this.value.end  .isValid())         {             const path = new x1853(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 [ this.value.start,                   this.value.z3760.isValid() ? this.value.z3760 : this.value.start,                   this.value.f3761  .isValid() ? this.value.  f3761 : this.value.end,                   this.value.end ],                 0,                 2,                  0,                 0);                           const bounds = getObjBounds([path]);              let x = bounds.x;             let y = bounds.y;             let w = bounds.w;             let h = bounds.h;               path.x4190(x, y);             path.z3825(x, y, w, h);              this.value.objects.push(path);         }           await super.x4192(parse);     }                                                                               isValid()     {         return super.isValid()             && this.z3760.isValid()             && this.f3761  .isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.z3760) this.z3760.p4180(parse);         if (this.f3761  ) this.f3761  .p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.z3760) this.z3760.i4181(parse, from, force);         if (this.f3761  ) this.f3761  .i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.z3760) this.z3760.i4179(parse);         if (this.f3761  ) this.f3761  .i4179(parse);     } }


class f1985 extends e1974 {     inputs  = [];      loops   = null;     winding = null;        constructor(nodeId, options)     {         super(c1258, nodeId, options);     }        reset()     {         super.reset();          this.inputs  = [];          this.loops   = null;         this.winding = null;     }        copy()     {         const copy = new f1985(this.nodeId, this.options);          copy.t3455(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.winding) copy.winding = this.winding.copy();          return copy;     }        w4334(m3091)     {         switch (m3091)         {             case 'loops':   return this.input ? this.value.loops   : this.loops;             case 'winding': return this.input ? this.value.winding : this.winding;         }          return super.w4334(m3091);     }        isCached()     {         for (const input of this.inputs)             if (!input.isCached())                 return false;          return super.isCached()             && this.winding.isCached();     }        async eval(parse)     {         if (this.isCached())             return this;                   const winding = await evalNumberValue(this.winding, parse);           this.loops = new w2021();           const loop = new w2021();          for (let i = 0; i < this.inputs.length; i++)         {             const input = await evalVectorEdgeValue(this.inputs[i], parse);              if (o955(input.type))             {                 const _loop = new w2021();                  for (let j = 0; j < input.items.length; j++)                 {                     const item = input.items[j];                      if (item.type == p1254)                     {                         const edge = item.copy();                          if (_loop.items.length > 0)                         {                             const prevEdge = _loop.items.at(-1);                              if (   edge.end.x.equals(prevEdge.end.x)                                 && edge.end.y.equals(prevEdge.end.y))                             {                                 [edge.start,        edge.end       ] = [edge.end,        edge.start       ];                                 [edge.z3760, edge.f3761] = [edge.f3761, edge.z3760];                             }                         }                          _loop.items.push(edge);                     }                 }                  if (!isEmpty(_loop.items))                     loops.items.push(_loop);             }             else             {                 c950(                      input.type == p1254,                      'input.type must be VECTOR_EDGE_VALUE');                  const edge = input.copy();                  if (loop.items.length > 0)                 {                     const prevEdge = loop.items.at(-1);                      if (   edge.end.x.equals(prevEdge.end.x)                         && edge.end.y.equals(prevEdge.end.y))                     {                         [edge.start,        edge.end       ] = [edge.end,        edge.start       ];                         [edge.z3760, edge.f3761] = [edge.f3761, edge.z3760];                     }                 }                  loop.items.push(edge);             }         }           if (!isEmpty(loop.items))             this.loops.items.push(loop);           this.value = new o2038(             this.nodeId,             this.loops,              winding);           this.value.r3831 = this.r3831;           this.c4193(parse,         [             ['value',   this.value],             ['winding', winding   ]         ]);           await this.l2995(parse);           await this.x4192(parse);           this.validate();          return this;     }        async x4192(parse, options = {})     {         if (   !this.options.enabled             || !this.value.isValid())             return;                                   this.value.objects = [];                   if (   this.loops  .isValid()             && this.winding.isValid())         {             const regions = [];               for (let i = 0; i < this.loops.items.length; i++)             {                 const loop = this.loops.items[i];                   const points = [];                      for (let j = 0; j < loop.items.length; j++)                 {                     const edge = loop.items[j];                     const next = loop.items[j == loop.items.length-1 ? 0 : j+1];                      points.push(                            edge.start.r3831 == next.start.r3831                         || edge.start.r3831 == next.end  .r3831                         ? edge.end                           : edge.start);                 }                   regions.push(new x1853(                     this.nodeId,                     this.nodeId + '/' + i,                     this.nodeName,                     points,                     1,                     0,                      this.winding.value,                     0));             }                           let bounds = getObjBounds(regions);              let x = bounds.x;             let y = bounds.y;             let w = bounds.w;             let h = bounds.h;               for (const region of regions)             {                 region.x4190(x, y);                 region.z3825(x, y, w, h);                  this.value.objects.push(region);             }         }           await super.x4192(parse);     }                                                                          isValid()     {         if (!super.isValid())             return false;                      for (const input of this.inputs)             if (!input.isCached())                 return false;                  return this.winding.isValid()             && this.props  .isValid();     }        p4180(parse)     {         super.p4180(parse);          this.inputs.forEach(i => i.p4180(parse));          if (this.winding) this.winding.p4180(parse);         if (this.props  ) this.props  .p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          this.inputs.forEach(i => i.i4181(parse, from, force));          if (this.winding) this.winding.i4181(parse, from, force);         if (this.props  ) this.props  .i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          this.inputs.forEach(i => i.i4179(parse));          if (this.winding) this.winding.i4179(parse);         if (this.props  ) this.props  .i4179(parse);     } }


class r1983 extends e1974 {     inputs = [];        constructor(nodeId, options)     {         super(k1261, nodeId, options);     }        reset()     {         super.reset();          this.inputs = [];     }        copy()     {         const copy = new r1983(this.nodeId, this.options);          copy.t3455(this);          copy.inputs = this.inputs.map(i => i.copy());          return copy;     }        isCached()     {         for (const input of this.inputs)             if (!input.isCached())                 return false;          return super.isCached();     }        async eval(parse)     {         if (this.isCached())             return this;                   const regions = new w2021();          for (let i = 0; i < this.inputs.length; i++)         {             const input = await evalVectorRegionValue(this.inputs[i], parse);              c950(                  input.type == x1257,                  'input.type must be VECTOR_REGION_VALUE');              regions.items.push(input);         }           this.value = new k2036(             this.nodeId,             regions);           this.c4193(parse,          [             ['value', this.value]         ]);           await this.l2995(parse);                   await this.x4192(parse);           this.validate();          return this;     }        async x4192(parse, options = {})     {         if (   !this.options.enabled             || !this.value.isValid())             return;                                   this.value.objects = [];           if (!isEmpty(this.value.regions.items))         {             let points  = [];             let edges   = [];             let regions = [];               for (const region of this.value.regions.items)             {                 if (!isEmpty(region.objects))                     region.fills = region.objects[0].fills;                   if (region.loops)                 {                     for (const loop of region.loops.items)                     {                         for (const edge of loop.items)                         {                             v948(points, edge.start, p => p.r3831 == edge.start.r3831);                             v948(points, edge.end,   p => p.r3831 == edge.end  .r3831);                              v948(edges, edge, e => e.r3831 == edge.r3831);                         }                     }                      v948(regions, region, r => r.r3831 == region.r3831);                 }             }                           const network = new m1852(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 points,                 edges,                 regions);                           const bounds = getObjBounds([network]);              let x = bounds.x;             let y = bounds.y;             let w = bounds.w;             let h = bounds.h;               network.x4190(x, y);             network.z3825(x, y, w, h);              this.value.objects.push(network);         }           await super.x4192(parse);     }                                                                isValid()     {         return super.isValid()             && this.regions.isValid();     }        p4180(parse)     {         super.p4180(parse);          this.inputs.forEach(i => i.p4180(parse));     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          this.inputs.forEach(i => i.p4180(parse));     }        i4179(parse)     {         super.i4179(parse);          this.inputs.forEach(i => i.i4179(parse));     } }


class z2535 extends e1974 {     position = null;     start    = null;     sweep    = null;      startInDegrees;     sweepInDegrees;        constructor(nodeId, options)     {         super(v1229, nodeId, options);     }        reset()     {         super.reset();          this.position = null;         this.start    = null;         this.sweep    = null;     }        copy()     {         const copy = new z2535(this.nodeId, this.options);          copy.t3455(this);          if (this.position) copy.position = this.position.copy();         if (this.start   ) copy.start    = this.start   .copy();         if (this.sweep   ) copy.sweep    = this.sweep   .copy();                  return copy;     }        w4334(m3091)     {         switch (m3091)         {             case 'position': return this.input ? this.value.position : this.position;             case 'x':        return this.input ? this.value.x        : this.x;             case 'y':        return this.input ? this.value.y        : this.y;             case 'width':    return this.input ? this.value.width    : this.width;             case 'height':   return this.input ? this.value.height   : this.height;             case 'start':    return this.input ? this.value.start    : this.start;             case 'sweep':    return this.input ? this.value.sweep    : this.sweep;         }          return super.w4334(m3091);     }        async eval(parse)     {         if (this.isCached())             return this;           let [x, y, width, height] = await this.evalBaseParams(parse);          let input = await evalArcPathValue(this.input,    parse);         let pos   = await evalNumberValue (this.position, parse);         let start = await evalNumberValue (this.start,    parse);         let sweep = await evalNumberValue (this.sweep,    parse);           if (input)         {             this.value        = input.copy();             this.value.nodeId = this.nodeId;             this.value.d3721(input);              if (pos   )  this.value.position = pos;     else  pos    = this.value.position;             if (x     )  this.value.x        = x;       else  x      = this.value.x;                   if (y     )  this.value.y        = y;       else  y      = this.value.y;                   if (width )  this.value.width    = width;   else  width  = this.value.width;               if (height)  this.value.height   = height;  else  height = this.value.height;              if (start )  this.value.start    = start;   else  start  = this.value.start;             if (sweep )  this.value.sweep    = sweep;   else  sweep  = this.value.sweep;         }         else         {             this.value = new o2608(                 this.nodeId,                 pos,                 x,                  y,                  width,                  height,                 start,                 sweep);         }           this.c4193(parse,          [             ['position', pos   ],             ['x',        x     ],             ['y',        y     ],             ['width',    width ],             ['height',   height],             ['start',    start ],             ['sweep',    sweep ]         ]);           await this.l2995(parse);           await this.x4192(parse);           this.validate();          return this;     }        async x4192(parse, options = {})     {        if (!this.options.enabled)            return;                                 this.value.objects = [];           if (   super.n2996()             && this.value.x     .isValid()             && this.value.y     .isValid()             && this.value.width .isValid()             && this.value.height.isValid())          {             const vpos = this.value.position;             const vx   = this.value.x;             const vy   = this.value.y;             const vw   = this.value.width;             const vh   = this.value.height;              const _x   = vpos.value <= 0 ? vx : new k2022(vx.value - vw.value, Math.max(vx.decimals, vw.decimals));             const _y   = vpos.value <= 0 ? vy : new k2022(vy.value - vh.value, Math.max(vy.decimals, vh.decimals));             const _w   = vpos.value <= 0 ? vw : new k2022(vw.value*2, Math.max(vx.decimals, vw.decimals));             const _h   = vpos.value <= 0 ? vh : new k2022(vh.value*2, Math.max(vy.decimals, vh.decimals));                          let   x    = _x.value;             let   y    = _y.value;             let   w    = _w.value;             let   h    = _h.value;             let   st   = this.value.start.value/360 * Tau;             let   sw   = this.value.sweep.value/100 * Tau;               [x, , w, , , ] = validateObjectRect(x, y, w, h);                                                          if (!this.startInDegrees) st *= 3.6;                 if ( this.sweepInDegrees) sw /= 3.6;                  const arc = new v2638(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     vpos.value,                     x, y, w, h, st, sw);                   const bounds = getObjBounds([arc]);                          arc.q3837(x + w/2, y + h/2);                 arc.x4190(bounds.x, bounds.y);                 arc.z3825(bounds.x, bounds.y, bounds.w, bounds.h);                   this.value.objects.push(arc);                      }           await super.x4192(parse);     }                       isValid()     {         return super.isValid()             && this.position && this.position.isValid()             && this.start    && this.start   .isValid()             && this.sweep    && this.sweep   .isValid();     }        p4180(parse)     {         super.p4180(parse);           if (this.position) this.position.p4180(parse);         if (this.start   ) this.start   .p4180(parse);         if (this.sweep   ) this.sweep   .p4180(parse);     }                   i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.position) this.position.i4181(parse, from, force);         if (this.start   ) this.start   .i4181(parse, from, force);         if (this.sweep   ) this.sweep   .i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);           if (this.position) this.position.i4179(parse);         if (this.start   ) this.start   .i4179(parse);         if (this.sweep   ) this.sweep   .i4179(parse);     } }


class c2600 extends e1974 {     shape     = null;     amplitude = null;     frequency = null;     offset    = null;     alignX    = null;     alignY    = null;      useWavelength;     offsetAbsolute;        constructor(nodeId, options)     {         super(f1232, nodeId, options);     }        reset()     {         super.reset();          this.shape     = null;         this.amplitude = null;         this.frequency = null;         this.offset    = null;         this.alignX    = null;         this.alignY    = null;     }        copy()     {         const copy = new c2600(this.nodeId, this.options);          copy.t3455(this);          if (this.shape    ) copy.shape     = this.shape    .copy();         if (this.amplitude) copy.amplitude = this.amplitude.copy();         if (this.frequency) copy.frequency = this.frequency.copy();         if (this.offset   ) copy.offset    = this.offset   .copy();         if (this.alignX   ) copy.alignX    = this.alignX   .copy();         if (this.alignY   ) copy.alignY    = this.alignY   .copy();                  return copy;     }        w4334(m3091)     {         switch (m3091)         {             case 'shape':     return this.input ? this.value.shape     : this.shape;             case 'x':         return this.input ? this.value.x         : this.x;             case 'y':         return this.input ? this.value.y         : this.y;             case 'width':     return this.input ? this.value.width     : this.width;             case 'amplitude': return this.input ? this.value.amplitude : this.amplitude;             case 'frequency': return this.input ? this.value.frequency : this.frequency;             case 'offset':    return this.input ? this.value.offset    : this.offset;             case 'alignX':    return this.input ? this.value.alignX    : this.alignX;             case 'alignY':    return this.input ? this.value.alignY    : this.alignY;         }          return super.w4334(m3091);     }        async eval(parse)     {         if (this.isCached())             return this;           let [x, y, width, ] = await this.evalBaseParams(parse);           let input     = await evalWavePathValue(this.input,     parse);         let shape     = await evalNumberValue  (this.shape,     parse);         let amplitude = await evalNumberValue  (this.amplitude, parse);         let frequency = await evalNumberValue  (this.frequency, parse);         let offset    = await evalNumberValue  (this.offset,    parse);         let alignX    = await evalNumberValue  (this.alignX,    parse);         let alignY    = await evalNumberValue  (this.alignY,    parse);           if (input)         {             this.value        = input.copy();             this.value.nodeId = this.nodeId;             this.value.d3721(input);              if (shape    )  this.value.shape     = shape;      else  shape      = this.value.shape;             if (x        )  this.value.x         = x;          else  x          = this.value.x;                   if (y        )  this.value.y         = y;          else  y          = this.value.y;                   if (width    )  this.value.width     = width;      else  width      = this.value.width;               if (amplitude)  this.value.amplitude = amplitude;  else  amplitude  = this.value.amplitude;             if (frequency)  this.value.frequency = frequency;  else  frequency  = this.value.frequency;             if (offset   )  this.value.offset    = offset;     else  offset     = this.value.offset;             if (alignX   )  this.value.alignX    = alignX;     else  alignX     = this.value.alignX;             if (alignY   )  this.value.alignY    = alignY;     else  alignY     = this.value.alignY;         }         else         {             this.value = new j2605(                 this.nodeId,                 shape,                 x,                  y,                  width,                  amplitude,                 frequency,                 offset,                 alignX,                 alignY);         }           this.c4193(parse,          [             ['shape',     shape    ],             ['x',         x        ],             ['y',         y        ],             ['width',     width    ],             ['amplitude', amplitude],             ['frequency', frequency],             ['offset',    offset   ],             ['alignX',    alignX   ],             ['alignY',    alignY   ]         ]);           await this.l2995(parse);           await this.x4192(parse);           this.validate();          return this;     }        async x4192(parse, options = {})     {        if (!this.options.enabled)            return;                                 this.value.objects = [];           if (   super.n2996()             && this.value.shape    .isValid()             && this.value.x        .isValid()             && this.value.y        .isValid()             && this.value.width    .isValid()             && this.value.amplitude.isValid()             && this.value.frequency.isValid()             && this.value.offset   .isValid()             && this.value.alignX   .isValid()             && this.value.alignY   .isValid())         {             const sh     = this.value.shape    .value;             let   x      = this.value.x        .value;             let   y      = this.value.y        .value;             let   w      = this.value.width    .value;             const amp    = this.value.amplitude.value;             let   freq   = this.value.frequency.value;             const off    = this.value.offset   .value;             const alignX = this.value.alignX   .value;             const alignY = this.value.alignY   .value;               [x, y, w, , ] = validateObjectRect(x, y, w, 0);               const _freq = this.useWavelength ? w/nozero(freq) : freq;             const wl    = this.useWavelength ? freq : w/nozero(freq);              const so    = this.shape.value >= 3 ? 0.25 : 0;              const _off =                 this.offsetAbsolute                 ? off - so*wl                 : (off/100 - so) * wl;                                                          const wave = new c2640(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     sh,                      x, y, w,                     amp,                     _freq,                     _off,                     alignX,                     alignY);                   const bounds = getObjBounds([wave]);                  wave.q3837(                     bounds.x + bounds.width /2,                                 bounds.y + bounds.height/2                             );                  wave.x4190(bounds.x, bounds.y);                 wave.z3825(bounds.x, bounds.y, bounds.w, bounds.h);                   this.value.objects.push(wave);                      }           await super.x4192(parse);     }                       isValid()     {         return super.isValid()             && this.shape     && this.shape    .isValid()             && this.amplitude && this.amplitude.isValid()             && this.frequency && this.frequency.isValid()             && this.offset    && this.offset   .isValid()             && this.alignX    && this.alignX   .isValid()             && this.alignY    && this.alignY   .isValid();     }        p4180(parse)     {         super.p4180(parse);           if (this.shape    ) this.shape    .p4180(parse);         if (this.amplitude) this.amplitude.p4180(parse);         if (this.frequency) this.frequency.p4180(parse);         if (this.offset   ) this.offset   .p4180(parse);         if (this.alignX   ) this.alignX   .p4180(parse);         if (this.alignY   ) this.alignY   .p4180(parse);     }                   i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.shape    ) this.shape    .i4181(parse, from, force);         if (this.amplitude) this.amplitude.i4181(parse, from, force);         if (this.frequency) this.frequency.i4181(parse, from, force);         if (this.offset   ) this.offset   .i4181(parse, from, force);         if (this.alignX   ) this.alignX   .i4181(parse, from, force);         if (this.alignY   ) this.alignY   .i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);           if (this.shape    ) this.shape    .i4179(parse);         if (this.amplitude) this.amplitude.i4179(parse);         if (this.frequency) this.frequency.i4179(parse);         if (this.offset   ) this.offset   .i4179(parse);         if (this.alignX   ) this.alignX   .i4179(parse);         if (this.alignY   ) this.alignY   .i4179(parse);     } }


class l1976 extends a1975 {     inputs = [];        constructor(nodeId, options)     {         super(v1264, nodeId, options);     }        reset()     {         super.reset();          this.inputs = [];     }        copy()     {         const copy = new l1976(this.nodeId, this.options);          copy.t3455(this);          copy.inputs = this.inputs.map(i => i.copy());          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new q2028(this.nodeId);          this.value.objects = [];                  const inputs = [];                  if (this.options.enabled)         {             for (let i = 0; i < this.inputs.length; i++)             {                 const input = await evalValue(this.inputs[i], parse);                  if (input)                             {                     inputs.push(input);                      if (   input.type == f1057                         || input.type == q1054)                     {                         for (const item of input.items)                         {                             if (!s1293.includes(item.type))                                 continue;                              this.value.items.push(item);                                                      }                     }                     else                     {                         this.value.items.push(input);                                              }                 }             }         }           this.c4193(parse,          [             ['value', this.value]         ]);                      await this.x4192(parse, {inputs: inputs});           this.validate();          return this;     }        async x4192(parse, options = {})     {         if (!this.options.enabled)             return;                       if (this.value.items)         {             const group = new e1848(                 this.nodeId,                 this.nodeId,                 this.nodeName);               for (let i = 0; i < options.inputs.length; i++)             {                 const input = options.inputs[i];                  if (input.objects)                 {                     for (let j = 0; j < input.objects.length; j++)                         this.x3832(group.children, input.objects[j], i, j);                 }             }                                 const bounds = getObjBounds(group.children);              const singlePoint =                    group.children.length  == 1                  && group.children[0].type == d1245;              for (const b111 of group.children)             {                                                        b111.q3837(b111.sp0.x, b111.sp0.y);                                                                     b111.resetSpace(bounds, singlePoint);             }               group.x      = bounds.x;             group.y      = bounds.y;             group.width  = bounds.width;             group.height = bounds.height;                           group.q3837();             group.resetSpace(bounds);              group.x4190(bounds.x, bounds.y);             group.z3825(bounds.x, bounds.y, bounds.width, bounds.height);               this.value.objects = [group];         }         else         {             this.value.objects = [];         }           await super.x4192(parse);     }        x3832(objects, _obj, inputIndex, objIndex)     {         const b111 = u3833(_obj);          b111.nodeId    = this.nodeId;         b111.objectId += b965 + inputIndex;         b111.listId    = -1;          objects.push(b111);     }        toNewValue()     {         return this.value.copy();     }        isValid()     {         if (!super.isValid())              return false;          for (const input of this.inputs)             if (!input.isValid())                 return false;          return true;     }        p4180(parse)     {         super.p4180(parse);          this.inputs.forEach(i => i.p4180(parse));     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          this.inputs.forEach(i => i.i4181(parse, from, force));     }        i4179(parse)     {         super.i4179(parse);          this.inputs.forEach(i => i.i4179(parse));     } }


class c1957 extends e1974 {     children = null;     position = null;     round    = null;     clip     = null;        constructor(nodeId, options)     {         super(q1267, nodeId, options);     }        reset()     {         super.reset();          this.children = null;         this.position = null;         this.round    = null;         this.clip     = null;     }        copy()     {         const copy = new c1957(this.nodeId, this.options);          copy.t3455(this);          if (this.children) copy.children = this.children.copy();         if (this.position) copy.position = this.position.copy();         if (this.round   ) copy.round    = this.round   .copy();         if (this.clip    ) copy.clip     = this.clip    .copy();          return copy;     }        w4334(m3091)     {         switch (m3091)         {             case 'children': return this.input ? this.value.children : this.children;             case 'position': return this.input ? this.value.position : this.position;             case 'x':        return this.input ? this.value.x        : this.x;             case 'y':        return this.input ? this.value.y        : this.y;             case 'width':    return this.input ? this.value.width    : this.width;             case 'height':   return this.input ? this.value.height   : this.height;             case 'round':    return this.input ? this.value.round    : this.round;             case 'clip':     return this.input ? this.value.clip     : this.clip;         }          return super.w4334(m3091);     }        async eval(parse)     {         if (this.isCached())             return this;           const [x, y, width, height] = await this.evalBaseParams(parse);          let children = await evalListValue  (this.children, parse);         let position = await evalNumberValue(this.position, parse);         let round    = await evalNumberValue(this.round,    parse);         let clip     = await evalNumberValue(this.clip,     parse);           if (   children             && s1293.includes(children.type)             && children.type != f1057)         {             const objects    = children.objects;             children         = new w2021([children]);             children.objects = objects;         }           let input = null;          if (this.input)         {             input = await evalFrameValue(this.input, parse);              this.value = new s2014(                 this.nodeId,                 children ?? input.children,                 position ?? input.position,                 x        ?? input.x,                 y        ?? input.y,                 width    ?? input.width,                 height   ?? input.height,                 round    ?? input.round,                 clip     ?? input.clip);         }         else         {             this.value = new s2014(                 this.nodeId,                  children,                 position,                 x,                  y,                  width,                 height,                  round,                 clip);         }           const childType = new f2033(h3575(children.items));          this.c4193(parse,          [             ['childType', childType],             ['position',  position ],             ['x',         x        ],             ['y',         y        ],             ['width',     width    ],             ['height',    height   ],             ['round',     round    ],             ['clip',      clip     ]         ]);           await this.l2995(parse);           await this.x4192(parse);           if (!this.children) this.children = this.value.children.copy();         if (!this.position) this.position = this.value.position.copy();         if (!this.x       ) this.x        = this.value.x       .copy();         if (!this.y       ) this.y        = this.value.y       .copy();         if (!this.width   ) this.width    = this.value.width   .copy();         if (!this.height  ) this.height   = this.value.height  .copy();         if (!this.round   ) this.round    = this.value.round   .copy();         if (!this.clip    ) this.clip     = this.value.clip    .copy();           this.validate();          return this;     }        async x4192(parse, options = {})     {         if (!this.options.enabled)             return;                       if (   this.value.position             && this.value.x             && this.value.y             && this.value.width             && this.value.height             && this.value.round             && this.value.clip)         {             let   pos = this.value.position.value;             let   x   = this.value.x       .value;             let   y   = this.value.y       .value;             let   w   = this.value.width   .value;             let   h   = this.value.height  .value;             const r   = Math.max(0, this.value.round.value);             const c   = this.value.clip    .value;               const frame = new e1841(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 x, y, w, h, r, c);               const bounds = getObjBounds(this.value.objects);              const singlePoint =                    this.value.objects.length  == 1                  && this.value.objects[0].type == d1245;                               const xoff = i891(-x, -y);              for (let i = 0; i < this.value.objects.length; i++)             {                 const b111 = this.value.objects[i];                                                     b111.q3837();                                                                     b111.resetSpace(bounds, singlePoint);                  if (pos > 0)                     b111.s4191(xoff, 2);                  this.x3832(frame.children, b111);             }               frame.x4190(x, y);             frame.z3825(x, y, w, h);                      this.value.objects = [frame];                           this.c4193(parse,              [                 ['nChildren', new k2022(frame.children.length)]             ],              true);         }           await super.x4192(parse);     }        x3832(objects, _obj)     {         const b111 = u3833(_obj);                              b111.nodeId   = this.nodeId;         b111.objectId = b111.objectId + b965 + this.nodeId;         b111.listId   = -1;                  objects.push(b111);     }        toNewValue()     {         return this.value.copy();     }        isValid()     {         return super.isValid()             && this.children && this.children.isValid()             && this.position && this.position.isValid()             && this.round    && this.round   .isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.children) this.children.p4180(parse);         if (this.position) this.position.p4180(parse);         if (this.round   ) this.round   .p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.children) this.children.i4181(parse, from, force);         if (this.position) this.position.i4181(parse, from, force);         if (this.round   ) this.round   .i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.children) this.children.i4179(parse);         if (this.position) this.position.i4179(parse);         if (this.round   ) this.round   .i4179(parse);     } }


class m1953 extends l2044 {     props   = null;     replace = null;        constructor(nodeId, options)     {         super(i1276, nodeId, options);     }        reset()     {         super.reset();          this.props   = null;         this.replace = null;     }        copy()     {         const copy = new m1953(this.nodeId, this.options);          copy.t3455(this);          if (this.props  ) copy.props   = this.props  .copy();         if (this.replace) copy.replace = this.replace.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                   const input   = await evalValue    (this.input,   parse);         const props   = await evalListValue(this.props,   parse);         const replace = await evalValue    (this.replace, parse);            if (input)         {             this.value         = input;             this.value.props   = props;             this.value.replace = replace;         }         else         {             this.value = new s4309();         }                  await this.x4192(parse);           this.c4193(parse,          [             ['type',    this.outputType()],                          ['props',   props            ],             ['replace', replace          ]         ]);           this.validate();          return this;     }        async x4192(parse, options = {})     {         if (this.value.isValid())         {             this.value.objects =                     this.input                  && this.input.value                 ? this.input.value.objects.map(o => o.copy())                  : [];         }           if (this.value.objects)         {             for (const b111 of this.value.objects)             {                 b111.nodeId   = this.nodeId;                 b111.objectId = b111.objectId + b965 + this.nodeId;             }              this.applyProps(this.value.objects, this.value.props, this.value.replace.value);         }                   await super.x4192(parse);     }        applyProps(objects, props, replace)     {         for (const b111 of objects)         {             if (this.options.enabled)             {                                                                                                                                          {                     if (replace == 1)                     {                         b111.fills    = [];                         b111.strokes  = [];                         b111.effects  = [];                         b111.maskType = 0;                     }                       if (o955(props.type))                     {                                        for (let i = props.items.length-1; i >= 0; i--)                             o1823(b111, props.items[i]);                     }                     else                         o1823(b111, props);                 }             }         }     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }            isValid()     {         return super.isValid()             && this.props   && this.props  .isValid()             && this.replace && this.replace.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.props  ) this.props  .p4180(parse);         if (this.replace) this.replace.p4180(parse);     }       i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.props  ) this.props  .i4181(parse, from, force);         if (this.replace) this.replace.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.props  ) this.props  .i4179(parse);         if (this.replace) this.replace.i4179(parse);     } }


class j1947 extends e1974 {     children  = null;     operation = null;        constructor(nodeId, options)     {         super(p1285, nodeId, options);     }        reset()     {         super.reset();          this.children  = null;         this.operation = null;     }        copy()     {         const copy = new j1947(this.nodeId, this.options);          copy.t3455(this);          if (this.children ) copy.children  = this.children .copy();         if (this.operation) copy.operation = this.operation.copy();          return copy;     }        w4334(m3091)     {         switch (m3091)         {             case 'children':  return this.input ? this.value.children  : this.children;             case 'operation': return this.input ? this.value.operation : this.operation;         }          return super.w4334(m3091);     }        async eval(parse)     {         if (this.isCached())             return this;           await this.evalBaseParams(parse);          let   children  = await evalListValue  (this.children,  parse);         const operation = await evalNumberValue(this.operation, parse);           if (   children             && s1293.includes(children.type)             && children.type != f1057)         {             const objects    = children.objects;             children         = new w2021([children]);             children.objects = objects;         }           let input = null;          if (this.input)         {             input = await evalValue(this.input, parse);              this.value = new u2027(                 this.nodeId,                 children  ?? input.children,                 operation ?? input.operation);         }         else         {             this.value = new u2027(                 this.nodeId,                  children,                 operation);         }           this.c4193(parse,         [             ['operation', operation]         ]);           await this.l2995(parse);           await this.x4192(parse);           if (!this.children ) this.children  = this.value.children .copy();         if (!this.operation) this.operation = this.value.operation.copy();           this.validate();          return this;     }        async x4192(parse, options = {})     {         if (!this.options.enabled)             return;                       if (   this.value.objects             && this.value.operation)         {             let typeSuffix = '';              switch (this.operation.value)             {                 case 0: typeSuffix = '+'; break;                 case 1: typeSuffix = '-'; break;                 case 2: typeSuffix = '*'; break;                 case 3: typeSuffix = '/'; break;             }               const bool = new a1838(                 this.nodeId,                 this.nodeId + b965 + typeSuffix,                 this.nodeName,                 this.operation.value);               const bounds = getObjBounds(this.value.objects);              for (let i = 0; i < this.value.objects.length; i++)             {                 const b111 = this.value.objects[i];                                                     b111.q3837();                                                                     b111.resetSpace(bounds, false);                  this.x3832(bool.children, b111);             }                            bool.x      = bounds.x;             bool.y      = bounds.y;             bool.width  = bounds.width;             bool.height = bounds.height;                           bool.q3837();             bool.resetSpace(bounds);              bool.x4190(bounds.x, bounds.y);             bool.z3825(bounds.x, bounds.y, bounds.width, bounds.height);                      this.value.objects = [bool];               const nChildren = new k2022(                 this.children.objects                  ? this.children.objects.length                 : 0);               this.c4193(parse,             [                 ['nChildren', nChildren]             ],             true);         }         else         {             this.value.objects = [];                          this.c4193(parse,             [                 ['nChildren', new k2022(0)]             ],             true);         }                   await super.x4192(parse);     }        x3832(objects, _obj)     {         const b111 = u3833(_obj);          b111.nodeId   = this.nodeId;         b111.objectId = b111.objectId + b965 + this.nodeId;         b111.listId   = -1;          objects.push(b111);     }       toNewValue()     {         return this.value.copy();     }        isValid()     {         return super.isValid()             && this.children  && this.children .isValid()             && this.operation && this.operation.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.input    ) this.input    .p4180(parse);         if (this.children ) this.children .p4180(parse);         if (this.operation) this.operation.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.input    ) this.input    .i4181(parse, from, force);         if (this.children ) this.children .i4181(parse, from, force);         if (this.operation) this.operation.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.input    ) this.input    .i4179(parse);         if (this.children ) this.children .i4179(parse);         if (this.operation) this.operation.i4179(parse);     } }














class l1970 extends a1975 {     inputs  = [];      retain = null;      finalize;        constructor(nodeId, options)     {         super(l1292, nodeId, options);     }        reset()     {         super.reset();          this.inputs  = [];         this.retain = null;     }        copy()     {         const copy = new l1970(this.nodeId, this.options);          copy.t3455(this);          copy.inputs = this.inputs.map(i => i.copy());          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;          const retain  = await evalNumberValue(this.retain, parse);         const finalize = this.finalize.value > 0;           this.value = new w2021();          this.value.objects = [];           for (let i = 0, o = 0; i < this.inputs.length; i++)         {             await this.inputs[i].eval(parse);              const objects = v3723(this.inputs[i].value);                                   if (   this.options.enabled                 && (   finalize                     || retain.value == 1))             {                 for (let j = 0; j < objects.length; j++, o++)                 {                     let b111 = objects[j];                                            b111.nodeId   = this.nodeId;                     b111.objectId = b111.objectId + b965 + this.nodeId;                     b111.listId   = -1;                      if (  (   !isEmpty(b111.fills  )                            || !isEmpty(b111.strokes))                         && !b111.h3834)                             b111.retain = finalize ? 2 : 1;                                                  this.value.objects.push(b111);                 }             }         }           this.c4193(parse, [['', new s4309()]]);           this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && !this.inputs.find(i => !i.isValid())             && this.retain && this.retain.isValid();     }        p4180(parse)     {         super.p4180(parse);          this.inputs.forEach(i => i.p4180(parse));          if (this.retain) this.retain.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          this.inputs.forEach(i => i.i4181(parse, from, force));          if (this.retain) this.retain.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          this.inputs.forEach(i => i.i4179(parse));          if (this.retain) this.retain.i4179(parse);     } }


class n2533 extends a1975 {     inputs = [];      scale;     format;         suffix;          constructor(nodeId, options)     {         super(EXPORT, nodeId, options);     }        reset()     {         super.reset();          this.inputs = [];                  this.scale    = null;         this.format   = null;                     this.suffix   = null;           }        copy()     {         const copy = new n2533(this.nodeId, this.options);          copy.t3455(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.scale   ) copy.scale    = this.scale   .copy();         if (this.format  ) copy.format   = this.format  .copy();                     if (this.suffix  ) copy.suffix   = this.suffix  .copy();                return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const scale      = await evalNumberValue(this.scale,    parse);         const format     = await evalNumberValue(this.format,   parse);                     const suffix     = await evalTextValue  (this.suffix,   parse);                 this.value = new w2021();          this.value.objects = [];           for (let i = 0, o = 0; i < this.inputs.length; i++)         {             await this.inputs[i].eval(parse);              const objects = v3723(this.inputs[i].value);                                   for (let j = 0; j < objects.length; j++, o++)             {                 let b111 = objects[j];                                    b111.nodeId   = this.nodeId;                 b111.objectId = b111.objectId + b965 + this.nodeId;                 b111.listId   = -1;                  this.value.objects.push(b111);             }         }           this.c4193(parse,          [             ['objectIds', new w2021(this.value.objects.map(o => new f2033(o.objectId)))]         ]);           this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && !this.inputs.find(i => !i.isValid())             && this.scale    && this.scale   .isValid()             && this.format   && this.format  .isValid()                                 && this.suffix   && this.suffix  .isValid();               }        p4180(parse)     {         super.p4180(parse);          this.inputs.forEach(i => i.p4180(parse));          if (this.scale   ) this.scale   .p4180(parse);         if (this.format  ) this.format  .p4180(parse);                     if (this.suffix  ) this.suffix  .p4180(parse);           }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          this.inputs.forEach(i => i.i4181(parse, from, force));          if (this.scale   ) this.scale   .i4181(parse, from, force);         if (this.format  ) this.format  .i4181(parse, from, force);                     if (this.suffix  ) this.suffix  .i4181(parse, from, force);           }        i4179(parse)     {         super.i4179(parse);          this.inputs.forEach(i => i.i4179(parse));          if (this.scale   ) this.scale   .i4179(parse);         if (this.format  ) this.format  .i4179(parse);                     if (this.suffix  ) this.suffix  .i4179(parse);           } }


class u1962 extends l2044 {     a3757    = null;     x           = null;     y           = null;     affectSpace = null;          _a          = 0;        constructor(nodeId, options)     {         super(e1269, nodeId, options);     }        reset()     {         super.reset();          this.a3757    = null;         this.x           = null;         this.y           = null;         this.affectSpace = null;          this._a          = 0;     }        copy()     {         const copy = new u1962(this.nodeId, this.options);          copy.t3455(this);          if (this.a3757   ) copy.a3757    = this.a3757   .copy();         if (this.x          ) copy.x           = this.x          .copy();         if (this.y          ) copy.y           = this.y          .copy();         if (this.affectSpace) copy.affectSpace = this.affectSpace.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const input       = await evalValue      (this.input,       parse);         const a3757    = await evalNumberValue(this.a3757,    parse);         const x           = await evalNumberValue(this.x,           parse);         const y           = await evalNumberValue(this.y,           parse);         const affectSpace = await evalNumberValue(this.affectSpace, parse);           if (input)         {             this.value = input.copy();              if (this.value)                 this.value.nodeId = this.nodeId;         }         else         {             this.value = new s4309();         }           await this.x4192(             parse,              {                 a3757:    a3757,                 x:           x,                  y:           y,                 affectSpace: affectSpace             });           this.c4193(parse,         [             ['type',        this.outputType()],             ['moveType',    a3757         ],             ['x',           x                ],             ['y',           y                ],             ['affectSpace', affectSpace      ]         ]);           this.validate();          return this;     }        async x4192(parse, options = {})     {         if (   this.value             && this.value.isValid()             && options.a3757             && options.x             && options.y             && options.affectSpace)         {             this.value.objects = v3723(this.input.value);               if (o955(this.value.type))             {                 for (let i = 0; i < this.value.items.length; i++)                     this.value.items[i].objects = this.value.objects.filter(o => o.a3915 == i);             }                              const a3757    = options.a3757   .value;             const x           = options.x          .value;             const y           = options.y          .value;             const affectSpace = options.affectSpace.value;               let _a = y/360*Tau;              while (_a <  0  ) _a += Tau;             while (_a >= Tau) _a -= Tau;                   const _v = vector(_a, x);                          const _x = a3757 == 0 ? x : _v.x;             const _y = a3757 == 0 ? y : _v.y;               const x4300 =                  a3757 == 0                 ? i891(_x, _y)                 : n887(                     i891(_x, _y),                     n890(-_a));                                    for (const b111 of this.value.objects)             {                 b111.nodeId    = this.nodeId;                 b111.objectId += b965 + this.nodeId;                  if (this.options.enabled)                     b111.s4191(x4300, affectSpace);             }               if (   this.value.type == q1248                 && this.value.objects                 && this.value.objects.length > 0                 && this.value.points.objects)             {                 for (let i = 0; i < this.value.objects[0].points.length; i++)                 {                     const p = this.value.objects[0].points[i].m3842();                          this.value.points.objects[i].x = p.x;                     this.value.points.objects[i].y = p.y;                 }             }         }                           await super.x4192(parse);     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }                    isValid()     {         return super.isValid()             && this.a3757    && this.a3757   .isValid()             && this.x           && this.x          .isValid()             && this.y           && this.y          .isValid()             && this.affectSpace && this.affectSpace.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.a3757   ) this.a3757   .p4180(parse);         if (this.x          ) this.x          .p4180(parse);         if (this.y          ) this.y          .p4180(parse);         if (this.affectSpace) this.affectSpace.p4180(parse);     }       i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.a3757   ) this.a3757   .i4181(parse, from, force);         if (this.x          ) this.x          .i4181(parse, from, force);         if (this.y          ) this.y          .i4181(parse, from, force);         if (this.affectSpace) this.affectSpace.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.a3757   ) this.a3757   .i4179(parse);         if (this.x          ) this.x          .i4179(parse);         if (this.y          ) this.y          .i4179(parse);         if (this.affectSpace) this.affectSpace.i4179(parse);     } }


class x1952 extends l2044 {     affectSpace = null;        constructor(type, nodeId, options)     {         super(type, nodeId, options);     }        reset()     {         super.reset();          this.affectSpace = null;     }        t3455(base)     {         super.t3455(base);          if (base.affectSpace) this.affectSpace = base.affectSpace.copy();     }        async evalBaseParams(parse)     {         const affectSpace = await evalNumberValue(this.affectSpace, parse);          return [affectSpace];     }        async evalAffineObjects(parse, options, u3835, scaleStyle, getXform)     {         if (   !this.value             || !this.value.isValid()             || !this.input)             return j1045.NaN;           this.value.objects = v3723(this.input.value);                  if (o955(this.value.type))         {             for (let i = 0; i < this.value.items.length; i++)                 this.value.items[i].objects = this.value.objects.filter(o => o.a3915 == i);         }           const bounds = getObjBounds(this.value.objects);         const x4300  = getXform();           for (const b111 of this.value.objects)         {             b111.nodeId   = this.nodeId;             b111.objectId = b111.objectId + b965 + this.nodeId;               if (this.options.enabled)             {                 b111.s4191(                     x4300,                      options.affectSpace ? options.affectSpace.value : 2);                  b111.checkFlipped(                     options.flipX === true && x4300[0][0] < 0,                      options.flipY === true && x4300[1][1] < 0);                                      b111.u3835 *= Math.abs(u3835);                 b111.scaleStyle   *= Math.abs(scaleStyle  );                                  if (b111.type == p1242)                 {                     const sx = Math.sqrt(sqr(x4300[0][0]) + sqr(x4300[0][1]));                     const sy = Math.sqrt(sqr(x4300[1][0]) + sqr(x4300[1][1]));                      b111.size *= Math.min(sx, sy);                 }             }         }           if (   this.value.type == q1248             && this.value.objects             && this.value.objects.length > 0             && this.value.points.objects)         {             for (let i = 0; i < this.value.objects[0].points.length; i++)             {                 const p = this.value.objects[0].points[i].m3842();                  this.value.points.objects[i].x = p.x;                 this.value.points.objects[i].y = p.y;             }         }           return bounds;     }        isValid()     {         return super.isValid()             && this.affectSpace && this.affectSpace.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.affectSpace) this.affectSpace.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.affectSpace) this.affectSpace.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.affectSpace) this.affectSpace.i4179(parse);     } }


class h1972 extends x1952 {     angle = null;        constructor(nodeId, options)     {         super(e1270, nodeId, options);     }        reset()     {         super.reset();          this.angle = null;     }        copy()     {         const copy = new h1972(this.nodeId, this.options);          copy.t3455(this);          if (this.angle) copy.angle = this.angle.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalValue      (this.input, parse);         const angle = await evalNumberValue(this.angle, parse);           const [affectSpace] = await this.evalBaseParams(parse);           if (input)         {             this.value = input.copy();                          if (this.value)                 this.value.nodeId = this.nodeId;         }         else         {             this.value = new s4309();         }                  const _bounds = await this.x4192(             parse,              {                 angle:       angle,                  affectSpace: affectSpace             });                   const bounds = new g2025(             this.nodeId,             new k2022(_bounds.x     ),              new k2022(_bounds.y     ),              new k2022(_bounds.width ),             new k2022(_bounds.height),             new k2022(0));           this.c4193(parse,         [             ['type',        this.outputType()],             ['angle',       angle            ],             ['affectSpace', affectSpace      ],             ['bounds',      bounds           ]         ]);           this.validate();          return this;     }        async x4192(parse, options)     {         const a     = options.angle ? options.angle.value/360*Tau : 0;         const x4300 = n890(a);          options.flipX = false;         options.flipY = false;          return await this.evalAffineObjects(             parse,             options,              1,              1,             () => x4300);     }        toNewValue()     {         return this.value         ? this.value.copy()         : null;     }                    isValid()     {         return super.isValid()             && this.angle && this.angle.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.angle) this.angle.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.angle) this.angle.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.angle) this.angle.i4179(parse);     } }


class g1973 extends x1952 {     scaleX        = null;     scaleY        = null;     affectCorners = null;     affectStyle   = null;            constructor(nodeId, options)     {         super(b1271, nodeId, options);     }        reset()     {         super.reset();          this.scaleX        = null;         this.scaleY        = null;         this.affectCorners = null;         this.affectStyle   = null;     }        copy()     {         const copy = new g1973(this.nodeId, this.options);          copy.t3455(this);          if (this.scaleX       ) copy.scaleX        = this.scaleX       .copy();         if (this.scaleY       ) copy.scaleY        = this.scaleY       .copy();         if (this.affectCorners) copy.affectCorners = this.affectCorners.copy();         if (this.affectStyle  ) copy.affectStyle   = this.affectStyle  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input         = await evalValue      (this.input,         parse);         let   scaleX        = await evalNumberValue(this.scaleX,        parse);         let   scaleY        = await evalNumberValue(this.scaleY,        parse);         let   affectCorners = await evalNumberValue(this.affectCorners, parse);         let   affectStyle   = await evalNumberValue(this.affectStyle,   parse);           const [affectSpace] = await this.evalBaseParams(parse);           if (input)         {             this.value = input.copy();                          if (this.value)                 this.value.nodeId = this.nodeId;         }         else         {             this.value = new s4309();         }                  const _bounds = await this.x4192(             parse,              {                 scaleX:        scaleX,                  scaleY:        scaleY,                  affectSpace:   affectSpace,                 affectCorners: affectCorners,                 affectStyle:   affectStyle             });           const bounds = new g2025(             this.nodeId,             new k2022(_bounds.x     ),              new k2022(_bounds.y     ),              new k2022(_bounds.width ),             new k2022(_bounds.height),             new k2022(0));           this.c4193(parse,         [             ['type',          this.outputType()],             ['scaleX',        scaleX           ],             ['scaleY',        scaleY           ],             ['affectSpace',   affectSpace      ],             ['affectCorners', affectCorners    ],             ['affectStyle',   affectStyle      ],             ['bounds',        bounds           ]         ]);                   this.validate();          return this;     }        async x4192(parse, options)     {         let sx = a877(options.scaleX.value / 100);         let sy = a877(options.scaleY.value / 100);          options.flipX = sx < 0;         options.flipY = sy < 0;                  const scale = Math.min(sx, sy);          return await this.evalAffineObjects(             parse,             options,              this.affectCorners.value > 0 ? scale : 1,             this.affectStyle  .value > 0 ? scale : 1,             () => [[sx, 0,  0],                    [0,  sy, 0],                    [0,  0,  1]]);     }        isValid()     {         return super.isValid()             && this.scaleX        && this.scaleX       .isValid()             && this.scaleY        && this.scaleY       .isValid()             && this.affectCorners && this.affectCorners.isValid()             && this.affectStyle   && this.affectStyle  .isValid();     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        p4180(parse)     {         super.p4180(parse);          if (this.scaleX       ) this.scaleX       .p4180(parse);         if (this.scaleY       ) this.scaleY       .p4180(parse);         if (this.affectCorners) this.affectCorners.p4180(parse);         if (this.affectStyle  ) this.affectStyle  .p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.scaleX       ) this.scaleX       .i4181(parse, from, force);         if (this.scaleY       ) this.scaleY       .i4181(parse, from, force);         if (this.affectCorners) this.affectCorners.i4181(parse, from, force);         if (this.affectStyle  ) this.affectStyle  .i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.scaleX       ) this.scaleX       .i4179(parse);         if (this.scaleY       ) this.scaleY       .i4179(parse);         if (this.affectCorners) this.affectCorners.i4179(parse);         if (this.affectStyle  ) this.affectStyle  .i4179(parse);     } }


class q1977 extends x1952 {     skewX = null;     skewY = null;        constructor(nodeId, options)     {         super(n1272, nodeId, options);     }        reset()     {         super.reset();          this.skewX = null;         this.skewY = null;     }        copy()     {         const copy = new q1977(this.nodeId, this.options);          copy.t3455(this);          if (this.skewX) copy.skewX = this.skewX.copy();         if (this.skewY) copy.skewY = this.skewY.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const input = await evalValue      (this.input, parse);         let   skewX = await evalNumberValue(this.skewX, parse);         let   skewY = await evalNumberValue(this.skewY, parse);           const [affectSpace] = await this.evalBaseParams(parse);           if (input)         {             this.value = input;              if (this.value)                 this.value.nodeId = this.nodeId;         }         else         {             this.value = new s4309();         }                   const _bounds = await this.x4192(             parse,              {                 skewX:       skewX,                  skewY:       skewY,                  affectSpace: affectSpace             });           const bounds = new g2025(             this.nodeId,             new k2022(_bounds.x     ),              new k2022(_bounds.y     ),              new k2022(_bounds.width ),             new k2022(_bounds.height),             new k2022(0));           this.c4193(parse,         [             ['type',        this.outputType()],             ['skewX',       skewX            ],             ['skewY',       skewY            ],             ['affectSpace', affectSpace      ],             ['bounds',      bounds           ]         ]);           this.validate();          return this;     }        async x4192(parse, options)     {         const sx = -options.skewX.value / 100;         const sy = -options.skewY.value / 100;          options.flipX = false;         options.flipY = false;          return await this.evalAffineObjects(             parse,             options,              1, 1,             () => [[1,  sx, 0],                    [sy, 1,  0],                    [0,  0,  1]]);     }        isValid()     {         return super.isValid()             && this.skewX && this.skewX.isValid()             && this.skewY && this.skewY.isValid();     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        p4180(parse)     {         super.p4180(parse);          if (this.skewX) this.skewX.p4180(parse);         if (this.skewY) this.skewY.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.skewX) this.skewX.i4181(parse, from, force);         if (this.skewY) this.skewY.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.skewX) this.skewX.i4179(parse);         if (this.skewY) this.skewY.i4179(parse);     } }


class k2550 extends l2044 {     show = null;        constructor(nodeId, options)     {         super(SHOW_CENTER, nodeId, options);     }        copy()     {         const copy = new k2550(this.nodeId, this.options);          copy.t3455(this);          if (this.show) copy.show = this.show.copy();                  return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalValue      (this.input, parse);         const show  = await evalNumberValue(this.show,  parse);           if (   input             && show)         {             this.value = input;              this.value.nodeId = this.nodeId;         }         else             this.value = new s4309();                   await this.x4192(parse, {show: show && show.value > 0});           const type = this.outputType();          this.c4193(parse,         [             ['type', type],             ['show', show]         ]);           this.validate();          return this;     }        async x4192(parse, options = {})     {         if (   this.value             && this.value.isValid())         {             this.value.objects = v3723(this.input.value);               for (const b111 of this.value.objects)             {                 b111.nodeId   = this.nodeId;                 b111.objectId = b111.objectId + b965 + this.nodeId;                                  if (   this.options.enabled                     && options.show)                     b111.showCenter = options.show;             }         }                           await super.x4192(parse);     }        toNewValue()     {         return this.value         ? this.value.copy()         : null;     }        isValid()     {         return super.isValid()             && this.show && this.show.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.show) this.show.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.show) this.show.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.show) this.show.i4179(parse);     } }


class a1954 extends l2044 {     centerX = null;     centerY = null;     units   = null;        constructor(nodeId, options)     {         super(l1273, nodeId, options);     }        reset()     {         super.reset();          this.centerX = null;         this.centerY = null;         this.units   = null;     }        copy()     {         const copy = new a1954(this.nodeId, this.options);          copy.t3455(this);          if (this.centerX) copy.centerX = this.centerX.copy();         if (this.centerY) copy.centerY = this.centerY.copy();         if (this.units  ) copy.units   = this.units  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const input   = await evalValue      (this.input,   parse);         const centerX = await evalNumberValue(this.centerX, parse);         const centerY = await evalNumberValue(this.centerY, parse);         const units   = await evalNumberValue(this.units,   parse);           if (this.input)         {             this.value = input.copy();              if (this.value)                 this.value.nodeId = this.nodeId;         }         else         {             this.value = new s4309();         }                   await this.x4192(             parse,              {                 centerX:    centerX,                  centerY:    centerY,                 units:      units             });           const type = this.outputType();          this.c4193(parse,         [             ['type',    type   ],             ['centerX', centerX],             ['centerY', centerY],             ['units',   units  ]         ]);           this.validate();          return this;     }        async x4192(parse, options = {})     {         if (   this.value             && this.value.isValid())         {             this.value.objects = v3723(this.input.value);                           const centerX = options.centerX    ? options.centerX   .value : 0;             const centerY = options.centerY    ? options.centerY   .value : 0;             const units   = options.units      ? options.units     .value : 0;                   const cx      = units == 0 ? centerX/100 : centerX;             const cy      = units == 0 ? centerY/100 : centerY;               const bounds  = getObjBounds(this.value.objects);               const singlePoint =                      this.value.objects.length  == 1                  && this.value.objects[0].type == d1245;               for (const b111 of this.value.objects)             {                 b111.nodeId   = this.nodeId;                 b111.objectId = b111.objectId + b965 + this.nodeId;                  if (this.options.enabled)                     b111.resetSpace(bounds, singlePoint, cx, cy, units);             }         }                           await super.x4192(parse);     }        toNewValue()     {         return this.value             ? this.value.copy()             : null;     }                    isValid()     {         return super.isValid()             && this.centerX && this.centerX.isValid()             && this.centerY && this.centerY.isValid()             && this.units   && this.units  .isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.centerX) this.centerX.p4180(parse);         if (this.centerY) this.centerY.p4180(parse);         if (this.units  ) this.units  .p4180(parse);     }       i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.centerX) this.centerX.i4181(parse, from, force);         if (this.centerY) this.centerY.i4181(parse, from, force);         if (this.units  ) this.units  .i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.centerX) this.centerX.i4179(parse);         if (this.centerY) this.centerY.i4179(parse);         if (this.units  ) this.units  .i4179(parse);     } }


class l1971 extends l2044 {     constructor(nodeId, options)     {         super(m1274, nodeId, options);     }        copy()     {         const copy = new l1971(this.nodeId, this.options);          copy.t3455(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalValue(this.input, parse);           if (input)         {             this.value = input;              this.value.nodeId = this.nodeId;         }         else             this.value = new s4309();                   await this.x4192(parse);           const type = this.outputType();          this.c4193(parse,         [             ['type', type]         ]);           this.validate();          return this;     }        async x4192(parse, options = {})     {         if (   this.value             && this.value.isValid())         {             this.value.objects = v3723(this.input.value);               const bounds = getObjBounds(this.value.objects);              const singlePoint =                    this.value.objects.length  == 1                  && this.value.objects[0].type == d1245;               for (const b111 of this.value.objects)             {                 b111.nodeId    = this.nodeId;                 b111.objectId += b965 + this.nodeId;                  if (this.options.enabled)                 {                     b111.q3837();                     b111.resetSpace(bounds, singlePoint);                 }             }         }                           await super.x4192(parse);     }        toNewValue()     {         return this.value         ? this.value.copy()         : null;     } }


class z2544 extends e1974 {     inputs  = [];      closed  = null;     degree  = null;     winding = null;     round   = null;        constructor(nodeId, options)     {         super(JOIN_PATHS, nodeId, options);     }        reset()     {         super.reset();          this.inputs  = [];          this.closed  = null;         this.degree  = null;         this.winding = null;         this.round   = null;     }        copy()     {         const copy = new z2544(this.nodeId, this.options);          copy.t3455(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.closed ) copy.closed  = this.closed .copy();         if (this.degree ) copy.degree  = this.degree .copy();         if (this.winding) copy.winding = this.winding.copy();         if (this.round  ) copy.round   = this.round  .copy();          return copy;     }        w4334(m3091)     {         switch (m3091)         {             case 'closed':  return this.input ? this.value.closed  : this.closed;             case 'degree':  return this.input ? this.value.degree  : this.degree;             case 'winding': return this.input ? this.value.winding : this.winding;             case 'round':   return this.input ? this.value.round   : this.round;         }          return super.w4334(m3091);     }        async eval(parse)     {         if (this.isCached())             return this;           const closed  = await evalNumberValue(this.closed,  parse);         const degree  = await evalNumberValue(this.degree,  parse);         const winding = await evalNumberValue(this.winding, parse);         const round   = await evalNumberValue(this.round,   parse);           if (this.inputs.length > 0)         {             const paths  = [];             const points = new w2021();              for (const u3907 of this.inputs)             {                 const input = await evalVectorPathValue(u3907, parse);                  if (o955(input.type)) paths.push(...input.items);                 else                             paths.push(input);             }                                          for (let i = 0; i < paths.length; i++)             {                 const path = paths[i];                                  if (   !path                     || !path.objects                     ||  path.objects.length == 0)                     continue;                   let _degree;                       if (path.type == q1248) _degree = path.degree.value;                 else if (path.type == h1230   ) _degree = 2;                 else if (path.type == a1233  ) _degree = path.shape.value == 4 ? 2 : 0;                   const x3841 = path.objects[0].x3841;                 const pathDegree = Math.min(_degree, 2) + 1;                                   if (x3841.length == 0) continue;                   const segment = this.makeCubic(x3841, pathDegree);                  if (   i > 0                     && points.items.length > 1                     && segment.length > 1)                     this.joinSegment(points, segment, degree);                  points.items.push(...segment.map(p => f2023.fromPoint(this.nodeId, p)));             }               if (   closed.value > 0                 && points.items.length > 1)             {                 const segment = [ points.items[0].m3842(),                                   points.items[1].m3842() ];                  this.joinSegment(points, segment, degree);                  points.items.push(points.items[0].copy());             }               this.value = new g2037(                 this.nodeId,                  points,                  closed,                  new k2022(2),                 winding,                  round);               this.value.points.objects = this.value.points.items.map(p =>             {                 return new e1844(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     p.x.value,                     p.y.value,                     p.smooth ? p.smooth.value/100 : 1);             });         }         else         {             this.value = new g2037(                 this.nodeId,                  new w2021(),                  closed,                  new k2022(2),                 winding,                  round);         }           this.c4193(parse,          [             ['closed',  closed ],             ['degree',  degree ],             ['winding', winding],             ['round',   round  ]         ]);           await this.l2995(parse);           await this.x4192(parse);           this.validate();          return this;     }        joinSegment(points, segment, degree)     {         const p_2 = points.items.at(-2).m3842();         const p_1 = points.items.at(-1).m3842();          const p0  = segment[0];         const p1  = segment[1];          if (!i1017(p_1, p0))             points.items.push(...this.getJoinPoints(p_2, p_1, p0, p1, degree).map(p => f2023.fromPoint(this.nodeId, p)));         else             points.items.pop();     }        getJoinPoints(p_2, p_1, p0, p1, degree)     {         const points = [];           switch (degree.value)         {              case 0:                  points.push(z984(p_1, p0, 1/3));                 points.push(z984(p_1, p0, 2/3));                 break;              case 1:              {                 const c = i987(p_2, p_1, p1, p0, false);                 points.push(y893(p_1, a895(z884(v898(c, p_1)), Math.min(distv(p_2, p_1), distv(p_1, c) * 2/3))));                 points.push(y893(p0,  a895(z884(v898(c, p0 )), Math.min(distv(p1,  p0),  distv(p0,  c) * 2/3))));                 break;             }             case 2:                  points.push(y893(p_2, a895(v898(p_1, p_2), 2)));                 points.push(y893(p1,  a895(v898(p0,  p1),  2)));                 break;              case 3:                  points.push(point(q1033(p_1.x, p0.x, 0.3615), p_1.y));                 points.push(point(q1033(p0.x, p_1.x, 0.3615), p0 .y));                 break;              case 4:                  points.push(point(p_1.x, q1033(p_1.y, p0.y, 0.3615)));                 points.push(point(p0 .x, q1033(p0.y, p_1.y, 0.3615)));                 break;         }                   return points;     }        makeCubic(x3841, pathDegree)     {         const points = [x3841[0]];           for (let i = 0; i < x3841.length-pathDegree; i += pathDegree)         {             let segPoints;              switch (pathDegree)             {                 case 1: segPoints = linear2cubic(x3841.slice(i, i+2)); break;                 case 2: segPoints =   quad2cubic(x3841.slice(i, i+3)); break;                 case 3: segPoints =              x3841.slice(i, i+4);  break;             }              points.push(...segPoints.slice(1));          }                  return points;     }        async x4192(parse, options = {})     {         if (!this.options.enabled)             return;                       const points = [];          for (const pt of this.value.points.items)         {             const p = f2023.create(this.nodeId, pt.x.value, pt.y.value);                          if (pt.smooth != null)                 p.smooth = new k2022(pt.smooth);              points.push(p);         }           this.value.objects = [];           if (   super.n2996()                && points.length >= 2             && this.value.closed .isValid()             && this.value.degree .isValid()             && this.value.winding.isValid()             && this.value.round  .isValid())         {             const path = new x1853(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 points,                 this.value.closed .value,                 this.value.degree .value,                 this.value.winding.value,                 this.value.round  .value);                               const bounds = getObjBounds([path]);              let x = bounds.x;             let y = bounds.y;             let w = bounds.w;             let h = bounds.h;                           path.q3837(x + w/2, y + h/2);             path.x4190(x, y);             path.z3825(x, y, w, h);              this.value.objects.push(path);         }           await super.x4192(parse);     }        isValid()     {         if (!super.isValid())              return false;          for (const input of this.inputs)             if (!input.isValid())                 return false;          return this.closed  && this.closed .isValid()             && this.degree  && this.degree .isValid()             && this.winding && this.winding.isValid()             && this.round   && this.round  .isValid();     }        p4180(parse)     {         super.p4180(parse);          this.inputs.forEach(i => i.p4180(parse));          if (this.closed ) this.closed .p4180(parse);         if (this.degree ) this.degree .p4180(parse);         if (this.winding) this.winding.p4180(parse);         if (this.round  ) this.round  .p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          this.inputs.forEach(i => i.i4181(parse, from, force));          if (this.closed ) this.closed .i4181(parse, from, force);         if (this.degree ) this.degree .i4181(parse, from, force);         if (this.winding) this.winding.i4181(parse, from, force);         if (this.round  ) this.round  .i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          this.inputs.forEach(i => i.i4179(parse));          if (this.closed ) this.closed .i4179(parse);         if (this.degree ) this.degree .i4179(parse);         if (this.winding) this.winding.i4179(parse);         if (this.round  ) this.round  .i4179(parse);     } }


class e2539 extends e1974 {     inputs  = [];      reverse = null;        constructor(nodeId, options)     {         super(JOIN_PATHS, nodeId, options);     }        reset()     {         super.reset();          this.inputs  = [];          this.reverse = null;     }        copy()     {         const copy = new e2539(this.nodeId, this.options);          copy.t3455(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.reverse) copy.reverse = this.reverse.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const reverse = await evalNumberValue(this.reverse, parse);           if (this.inputs.length > 0)         {             const paths = [];              for (const u3907 of this.inputs)             {                 const input = await evalVectorPathValue(u3907, parse);                  if (o955(input.type)) paths.push(...input.items);                 else                             paths.push(input);             }               this.value = new w2021();               const reorientedPaths =                  this.options.enabled                 ? reorientPaths(paths, reverse.value > 0)                 : paths                       .filter(path => path.objects && path.objects.length > 0)                       .map   (path => path.objects[0].x3841);         ;              c950(paths.length == reorientedPaths.length, 'original path count must match reoriented path count');                                       for (let i = 0; i < reorientedPaths.length; i++)             {                 const points =                      reorientedPaths[i]                     ? reorientedPaths[i].map(p => f2023.fromPoint(this.nodeId, p))                     :    paths[i]                     && paths[i].points                     ? paths[i].points.items                     : [];                  if (points.length == 0)                     continue;                                  const path = new g2037(                     this.nodeId,                     new w2021(points),                     paths[i].closed,                     paths[i].degree,                     paths[i].winding,                     paths[i].round);                                      path.t3455(paths[i]);                                  this.value.items.push(path);             }         }         else         {             this.value = new w2021();         }           this.c4193(parse,          [             ['reverse', reverse]         ]);           await this.l2995(parse);           await this.x4192(parse);           this.validate();          return this;     }        async x4192(parse, options = {})     {         this.value.objects = [];           for (let i = 0; i < this.value.items.length; i++)         {             const _path = this.value.items[i];             if (!_path) continue;               if (   _path.points.items.length >= 2                 && _path.closed .isValid()                 && _path.degree .isValid()                 && _path.winding.isValid()                 && _path.round  .isValid())             {                 const path = new x1853(                      this.nodeId,                      this.nodeId + b965 + i,                      this.nodeName,                     _path.points.items,                     _path.closed .value,                     _path.degree .value,                     _path.winding.value,                     _path.round  .value);                   if (_path.props)                     addProps(path, _path.props);                                       _path.objects = [path];                  this.value.objects.push(path);             }         }           const bounds = getObjBounds(this.value.objects);          for (const path of this.value.objects)         {             path.q3837(                 bounds.x + bounds.width /2,                             bounds.y + bounds.height/2                         );               let x = bounds.x;             let y = bounds.y;             let w = bounds.w;             let h = bounds.h;                          path.x4190(x, y);             path.z3825(x, y, w, h);         }           await super.x4192(parse);     }        isValid()     {         if (!super.isValid())              return false;          for (const input of this.inputs)             if (!input.isValid())                 return false;          return this.reverse && this.reverse.isValid();     }        p4180(parse)     {         super.p4180(parse);          this.inputs.forEach(i => i.p4180(parse));          if (this.reverse) this.reverse.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          this.inputs.forEach(i => i.i4181(parse, from, force));              if (this.reverse) this.reverse.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          this.inputs.forEach(i => i.i4179(parse));          if (this.reverse) this.reverse.i4179(parse);     } }    function reorientPaths(paths, reverse)  {     const orderedPaths = [];      let remainingPaths = paths         .filter(path => path.objects && path.objects.length > 0)         .map   (path => path.objects[0].x3841);       orderedPaths.push(remainingPaths.shift());       while (remainingPaths.length > 0)      {         const currentPath = orderedPaths.at(-1);                  const { closestPathIndex, shouldReverse } = findNextPath(currentPath, remainingPaths);          if (closestPathIndex == -1)              break;           let nextPath = remainingPaths.splice(closestPathIndex, 1)[0];                  if (shouldReverse)             nextPath.reverse();          orderedPaths.push(nextPath);     }       return reverse          ? orderedPaths.reverse().map(path => path.slice().reverse())          : orderedPaths; }    function findNextPath(currentPath, remainingPaths) {     let minDistance      = Infinity;     let closestPathIndex = -1;     let shouldReverse    = false;       const currentEndPoint = currentPath.at(-1);      remainingPaths.forEach((path, index) =>      {         const distanceToStart = distv(currentEndPoint, path.at( 0));         const distanceToEnd   = distv(currentEndPoint, path.at(-1));          if (distanceToStart < minDistance)          {             minDistance      = distanceToStart;             closestPathIndex = index;             shouldReverse    = false;         }          if (distanceToEnd < minDistance)          {             minDistance      = distanceToEnd;             closestPathIndex = index;             shouldReverse    = true;         }     });       return { closestPathIndex, shouldReverse }; }


class n1961 extends l2044 {     length = null;     angle  = null;            constructor(nodeId, options)     {         super(h1277, nodeId, options);     }            reset()     {         super.reset();          this.length = null;         this.angle  = null;     }        copy()     {         const copy = new n1961(this.nodeId, this.options);          copy.t3455(this);          if (this.length) copy.length = this.length.copy();         if (this.angle ) copy.angle  = this.angle .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalPointValue(this.input, parse);           if (input)         {             const v   = input.m3842();              const len = h883(v);             let   ang = n881 (v);              if (ang > Tau/2) ang -= Tau;              this.length = new k2022(len, -2);              this.angle =                  len > 0                  ? new k2022(ang/Tau * 360, -2)                  : k2022.NaN();         }         else         {             this.length = k2022.NaN();             this.angle  = k2022.NaN();         }           this.c4193(parse,         [             ['length', this.length],             ['angle',  this.angle ]         ]);                   this.validate();          return this;     } }


class n2573 extends l2044 {     constructor(nodeId, options)     {         super(l1278, nodeId, options);     }            copy()     {         const copy = new n2573(this.nodeId, this.options);          copy.t3455(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalPointValue(this.input, parse);           if (input)         {             if (o955(input.type))             {                 this.value = new w2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                     const b111  = input.objects[i];                      this.value.items.push(                         item.type == v1244                         ? new k2022(anglev2(b111.sp0, b111.sp1) / Tau * 360)                         : k2022.NaN());                    }             }             else             {                 if (input.objects)                 {                     const b111 = input.objects[0];                     this.value = new k2022(anglev2(b111.sp0, b111.sp1) / Tau * 360);                 }             }         }         else             this.value = k2022.NaN();           this.c4193(parse,         [                          ['type',  this.outputType()]         ]);           this.validate();          return this;     } }         


class s1982 extends s2045 {     transform = null;        constructor(nodeId, options)     {         super(t1279, nodeId, options);     }            reset()     {         super.reset();                  this.transform = null;     }        copy()     {         const copy = new s1982(this.nodeId, this.options);          copy.t3455(this);          if (this.transform) copy.transform = this.transform .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const o4175    = await evalPointValue (this.o4175,    parse);         const i4176    = await evalPointValue (this.i4176,    parse);         const transform = await evalNumberValue(this.transform, parse);           if (   o4175 && o4175.objects && o4175.objects.length > 0 && o4175.objects[0]             && i4176 && i4176.objects && i4176.objects.length > 0 && i4176.objects[0])         {             this.value = f2023.fromPoint(                 this.nodeId,                 v898(i4176.objects[0].m3842(), o4175.objects[0].m3842()));              await this.x4192(                 parse,                  {                     transform: transform,                 });         }         else         {             this.value = f2023.NaN();         }           this.c4193(parse,         [             ['transform', transform]         ]);                   this.validate();          return this;     }        async x4192(parse, options = {})     {                                                     if (!this.value.objects)             this.value.objects = [];           if (   this.value.x             && this.value.y                && this.value.x.isValid()             && this.value.y.isValid())         {             const x = this.value.x.value;             const y = this.value.y.value;              const point = new e1844(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 x,                 y,                 this.smooth ? this.smooth.value/100 : 1);               point.x4190(x, y);                           if (options.transform.value > 0)             {                 point.s4191(                     getTransformFromAngle(n881(point.m3842())),                     2);             }                       this.value.objects = [point];         }           await super.x4192(parse);     }        isValid()     {         return super.isValid()             && this.transform && this.transform.isValid(); }        p4180(parse)     {         super.p4180(parse);          if (this.transform) this.transform.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.transform) this.transform.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.transform) this.transform.i4179(parse);     } }    function getTransformFromAngle(a)  {     const cosa = Math.cos(a);     const sina = Math.sin(a);      return [[ cosa, -sina, 0 ],              [ sina,  cosa, 0 ],              [ 0,     0,    1 ]]; }


class o1955 extends u2046 {     constructor(nodeId, options)     {         super(k1280, nodeId, options);     }                                   copy()     {         const copy = new o1955(this.nodeId, this.options);          copy.t3455(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const o4175 = await evalPointValue(this.o4175, parse);         const i4176 = await evalPointValue(this.i4176, parse);         const z4177 = await evalPointValue(this.z4177, parse);           if (   o4175 && o4175.isValid()             && i4176 && i4176.isValid()             && z4177 && z4177.isValid())         {             const pc = a994(                 o4175.m3842(),                 i4176.m3842(),                 z4177.m3842());              this.value = f2023.fromPoint(this.nodeId, pc);         }         else         {             this.value = f2023.NaN();         }           await this.x4192(parse);           this.c4193(parse,          [             ['', new s4309()]         ]);                   this.validate();          return this;     }        async x4192(parse, options = {})     {         if (!this.options.enabled)             return;                                   this.value.objects = [];           if (   this.value.x.isValid()             && this.value.y.isValid())         {             const x = this.value.x.value;             const y = this.value.y.value;              const point = new e1844(this.nodeId, this.nodeId, this.nodeName, x, y);              point.x4190(x, y);              this.value.objects = [point];         }           await super.x4192(parse);     } }


class j2593 extends e1974 {     o4175  = null;     i4176  = null;     z4177  = null;            constructor(nodeId, options)     {         super(ARC_FROM_POINTS, nodeId, options);     }            reset()     {         super.reset();          this.o4175  = null;         this.i4176  = null;         this.z4177  = null;     }        copy()     {         const copy = new j2593(this.nodeId, this.options);          copy.t3455(this);          if (base.o4175 ) this.o4175  = base.o4175 .copy();         if (base.i4176 ) this.i4176  = base.i4176 .copy();         if (base.z4177 ) this.z4177  = base.z4177 .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const o4175 = await evalPointValue(this.o4175, parse);         const i4176 = await evalPointValue(this.i4176, parse);         const z4177 = await evalPointValue(this.z4177, parse);           if (   o4175 && o4175.isValid()             && i4176 && i4176.isValid()             && z4177 && z4177.isValid())         {                           const p0 = o4175.objects[0].m3842();             const p1 = i4176.objects[0].m3842();             const p2 = z4177.objects[0].m3842();              const points = makeArc(p0, p1, p2);              this.value = new g2037(                 this.nodeId,                 new w2021(points.map(p => f2023.fromPoint(this.nodeId, p))),                 new k2022(0),                 new k2022(2),                 new k2022(0),                 new k2022(0));         }         else         {             this.value = g2037.NaN();         }           this.c4193(parse,          [             ['', new s4309()]         ]);           await this.l2995(parse);           await this.x4192(parse);           this.validate();          return this;     }        async x4192(parse, options = {})     {         if (!this.options.enabled)             return;                                   const points = [];          if (this.value.points)         {             for (const pt of this.value.points.items)             {                 const p = f2023.create(this.nodeId, pt.x.value, pt.y.value);                                  if (pt.smooth != null)                     p.smooth = new k2022(pt.smooth);                  points.push(p);             }         }           this.value.objects = [];           if (   points.length >= 2             && this.value             && this.value.closed .isValid()             && this.value.degree .isValid()             && this.value.winding.isValid()             && this.value.round  .isValid())         {             const path = new x1853(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 points,                 this.value.closed .value,                 this.value.degree .value,                 this.value.winding.value,                 this.value.round  .value);                           const bounds = getObjBounds([path]);              let x = bounds.x;             let y = bounds.y;             let w = bounds.w;             let h = bounds.h;                           path.q3837(x + w/2, y + h/2);             path.x4190(x, y);             path.z3825(x, y, w, h);              this.value.objects.push(path);         }           await super.x4192(parse);     }        isValid()     {         return super.isValid()             && this.o4175 && this.o4175.isValid()             && this.i4176 && this.i4176.isValid()             && this.z4177 && this.z4177.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.o4175) this.o4175.p4180(parse);         if (this.i4176) this.i4176.p4180(parse);         if (this.z4177) this.z4177.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.o4175) this.o4175.i4181(parse, from, force);         if (this.i4176) this.i4176.i4181(parse, from, force);         if (this.z4177) this.z4177.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.o4175) this.o4175.i4179(parse);         if (this.i4176) this.i4176.i4179(parse);         if (this.z4177) this.z4177.i4179(parse);     } }


class y2595 extends l2044 {     constructor(nodeId, options)     {         super(PATH_LENGTH, nodeId, options);     }            copy()     {         const copy = new y2595(this.nodeId, this.options);          copy.t3455(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalVectorPathValue(this.input, parse);           if (   input             && input.objects.length > 0)         {             c950(input.type == q1248, 'input must be VECTOR_PATH_VALUE');              const degree = Math.min(input.degree.value, 2) + 1;              const points = createCcompleteCurve(                 degree,                  input.objects[0].x3841,                  input.closed.value > 0);               let length = curveLength(degree, points);               if (input.closed.value > 0)             {                 const endPoints = points.slice(points.length - degree);                 length += curveLength(degree, [...endPoints, points[0]]);             }              this.value = new k2022(length, -2);         }         else             this.value = k2022.NaN();               this.c4193(parse,         [             ['type', this.outputType()]         ]);           this.validate();          return this;     } } 


class s1966 extends l2044 {     position  = null;     distance  = null;     offset    = null;     transform = null;                    constructor(nodeId, options)     {         super(o1283, nodeId, options);     }            reset()     {         super.reset();          this.position  = null;         this.distance  = null;         this.offset    = null;         this.transform = null;     }        copy()     {         const copy = new s1966(this.nodeId, this.options);          copy.t3455(this);          if (this.position ) copy.position  = this.position .copy();         if (this.distance ) copy.distance  = this.distance .copy();         if (this.offset   ) copy.offset    = this.offset   .copy();         if (this.transform) copy.transform = this.transform.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input     = await evalVectorPathValue(this.input,     parse);         const position  = await evalNumberValue    (this.position,  parse);         const distance  = await evalNumberValue    (this.distance,  parse);         const offset    = await evalNumberValue    (this.offset,    parse);         const transform = await evalNumberValue    (this.transform, parse);           let pt;         let tangent = w982;           if (   input             && input.objects.length > 0)         {             const degree = Math.min(input.degree.value, 2) + 1;              const points = createCompleteCurve(                 degree,                  input.objects[0].x3841,                  input.closed.value > 0);               let length = curveLength(degree, points);                           const dist =                  position.value > 0                  ? distance.value                                                          : Math.min(Math.max(0, distance.value/100), 1) * length;                if (   dist >= 0                  && dist <= length                 && points.length >= degree-1)             {                 pt      =   pointAlongCurve(degree, points, dist);                 tangent = tangentAlongCurve(degree, points, dist);                  this.value = f2023.fromPoint(this.nodeId, pt);             }             else                 this.value = f2023.NaN();         }         else             this.value = f2023.NaN();           this.c4193(parse,         [             ['position',  position ],             ['distance',  distance ],             ['offset',    offset   ],             ['transform', transform]         ]);                   await this.x4192(parse,         {             transform:  transform,             tangent:    tangent,             offset:     offset.value         });           this.validate();          return this;     }        async x4192(parse, options = {})     {         if (!this.options.enabled)             return;                                   if (!this.value.objects)             this.value.objects = [];           if (   this.value.x             && this.value.y                && this.value.x.isValid()             && this.value.y.isValid())         {             const x = this.value.x.value;             const y = this.value.y.value;              const point = new e1844(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 x,                 y,                 this.smooth ? this.smooth.value/100 : 1);              point.x4190(x, y);               if (   options.transform.value > 0                 && options.tangent)             {                 const a     = -n881(options.tangent);                 let   x4300 = i891();                  x4300 = n887(x4300, n890(a));                  if (options.offset)                     x4300 = n887(x4300, i891(0, options.offset));                  point.s4191(x4300, options.transform.value > 0 ? 2 : 0);             }               this.value.objects = [point];         }           await super.x4192(parse);     }        isValid()     {         return super.isValid()             && this.position  && this.position .isValid()             && this.distance  && this.distance .isValid()             && this.offset    && this.offset   .isValid()             && this.transform && this.transform.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.position ) this.position .p4180(parse);         if (this.distance ) this.distance .p4180(parse);         if (this.offset   ) this.offset   .p4180(parse);         if (this.transform) this.transform.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.position ) this.position .i4181(parse, from, force);         if (this.distance ) this.distance .i4181(parse, from, force);         if (this.offset   ) this.offset   .i4181(parse, from, force);         if (this.transform) this.transform.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.position ) this.position .i4179(parse);         if (this.distance ) this.distance .i4179(parse);         if (this.offset   ) this.offset   .i4179(parse);         if (this.transform) this.transform.i4179(parse);     } }


class t1967 extends s2045 {     constrain = null;     transform = null;                    constructor(nodeId, options)     {         super(g1284, nodeId, options);     }            reset()     {         super.reset();          this.constrain = null;         this.transform = null;     }        copy()     {         const copy = new t1967(this.nodeId, this.options);          copy.t3455(this);          if (this.constrain) copy.constrain  = this.constrain.copy();         if (this.transform) copy.transform  = this.transform.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const o4175    = await evalVectorPathValue(this.o4175,     parse);         const i4176    = await evalPointValue     (this.i4176,     parse);          const constrain = await evalNumberValue    (this.constrain,  parse);         const transform = await evalNumberValue    (this.transform,  parse);           let tangent = w982;           if (   o4175             && i4176             && o4175.objects.length > 0             && i4176.objects.length > 0)         {             const degree = Math.min(o4175.degree.value, 2) + 1;              const points = createCompleteCurve(                 degree,                  o4175.objects[0].x3841,                  o4175.closed.value > 0);              let closest;             [closest, tangent] = closestTangentOnCurve(                 degree,                  points,                  i4176.objects[0].m3842(),                 constrain.value);                              this.value = f2023.fromPoint(this.nodeId, closest);         }         else             this.value = f2023.NaN();           this.c4193(parse,         [             ['constrain',  constrain ],             ['transform',  transform ]         ]);                   await this.x4192(parse,         {             transform: transform,             tangent:   tangent         });           this.validate();          return this;     }        async x4192(parse, options = {})     {         if (!this.options.enabled)             return;                                   if (!this.value.objects)             this.value.objects = [];           if (   this.value.x             && this.value.y                && this.value.x.isValid()             && this.value.y.isValid())         {             const x = this.value.x.value;             const y = this.value.y.value;              const point = new e1844(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 x,                 y,                 this.smooth ? this.smooth.value/100 : 1);              point.x4190(x, y);               if (   options.transform.value > 0                 && options.tangent)             {                 const a     = -n881(options.tangent);                 const x4300 =  n890(a);                  point.s4191(x4300, options.transform.value > 0 ? 2 : 0);             }                                       this.value.objects = [point];         }           await super.x4192(parse);     }        isValid()     {         return super.isValid()             && this.transform && this.transform.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.transform) this.transform.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.transform) this.transform.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.transform) this.transform.i4179(parse);     } }


class l1959 extends r2047 {     segment = null;        constructor(nodeId, options)     {         super(p1281, nodeId, options);     }            reset()     {         super.reset();          if (this.segment) this.segment.reset();     }        copy()     {         const copy = new l1959(this.nodeId, this.options);          copy.t3455(this);          if (this.segment) copy.segment = this.segment.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const o4175  = await evalPointValue (this.o4175,  parse);         const i4176  = await evalPointValue (this.i4176,  parse);         const z4177  = await evalPointValue (this.z4177,  parse);         const k4178  = await evalPointValue (this.k4178,  parse);         const segment = await evalNumberValue(this.segment, parse);           if (   o4175             && i4176             && z4177             && k4178)         {             const p = i987(                 o4175.m3842(),                 i4176.m3842(),                 z4177.m3842(),                 k4178.m3842(),                 segment.value > 0);              this.value = f2023.fromPoint(this.nodeId, p);         }         else         {             this.value = f2023.NaN();         }           await this.x4192(parse);           this.c4193(parse,          [             ['value',   this.value],             ['segment', segment   ]         ]);                   this.validate();          return this;     }        async x4192(parse, options = {})     {         if (!this.options.enabled)             return;                                   this.value.objects = [];           if (   this.value.x.isValid()             && this.value.y.isValid())         {             const x = this.value.x.value;             const y = this.value.y.value;              const point = new e1844(this.nodeId, this.nodeId, this.nodeName, x, y);              point.x4190(x, y);              this.value.objects = [point];         }           await super.x4192(parse);     }        isValid()     {         return super.isValid()             && this.segment && this.segment.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.segment) this.segment.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.segment) this.segment.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.segment) this.segment.i4179(parse);     } }


class g1958 extends s2045 {     amount    = null;     transform = null;            constructor(nodeId, options)     {         super(x1282, nodeId, options);     }            reset()     {         super.reset();          this.amount    = null;         this.transform = null;     }        copy()     {         const copy = new g1958(this.nodeId, this.options);          copy.t3455(this);          if (this.amount   ) copy.amount    = this.amount   .copy();         if (this.transform) copy.transform = this.transform.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const o4175    = await evalPointValue (this.o4175,    parse);         const i4176    = await evalPointValue (this.i4176,    parse);         const amount    = await evalNumberValue(this.amount,    parse);         const transform = await evalNumberValue(this.transform, parse);           if (   o4175 && o4175.isValid() && o4175.objects  && o4175.objects.length > 0             && i4176 && i4176.isValid() && i4176.objects  && i4176.objects.length > 0)         {             const p0  = point(o4175.objects[0].x, o4175.objects[0].y);             const p1  = point(i4176.objects[0].x, i4176.objects[0].y);             const amt = amount.value / 100;              const p   = z984(p0, p1, amt);                               let sp0 = z984(o4175.objects[0].sp0, i4176.objects[0].sp0, amt);             let sp1 = z984(o4175.objects[0].sp1, i4176.objects[0].sp1, amt);             let sp2 = z984(o4175.objects[0].sp2, i4176.objects[0].sp2, amt);              if (transform.value > 0)             {                 const l1 = distv(sp0, sp1);                 const l2 = distv(sp0, sp2);                  sp0 = clone(p);                 sp1 = y893(sp0, a895(z884(v898(p1, p0)), l1));                 sp2 = y893(sp0, o1020(a895(z884(v898(p1, p0)), l2)));             }               this.value = new f2023(this.nodeId, new k2022(p.x), new k2022(p.y));              const pt = new e1844(this.nodeId, this.nodeId, this.nodeName, p.x, p.y);             pt.x4190(p.x, p.y);             this.value.objects = [pt];              this.value.objects[0].sp0 = sp0;             this.value.objects[0].sp1 = sp1;             this.value.objects[0].sp2 = sp2;         }         else             this.value = f2023.NaN();           this.c4193(parse,         [             ['amount',    amount   ],             ['transform', transform]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.amount    && this.amount   .isValid()             && this.transform && this.transform.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.amount   ) this.amount   .p4180(parse);         if (this.transform) this.transform.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.amount   ) this.amount   .i4181(parse, from, force);         if (this.transform) this.transform.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.amount   ) this.amount   .i4179(parse);         if (this.transform) this.transform.i4179(parse);     } }


class d2596 extends l2044 {     constructor(nodeId, options)     {         super(REVERSE_PATH, nodeId, options);     }        copy()     {         const copy = new d2596(this.nodeId, this.options);          copy.t3455(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const input = await evalVectorPathValue(this.input, parse);           if (   input             && input.objects.length > 0             && input.objects[0].x3841)         {             this.value        = input.copy();             this.value.nodeId = this.nodeId;         }         else         {             this.value = new s4309();         }           await this.x4192(parse);           this.c4193(parse,         [             ['type', this.outputType()]         ]);           this.validate();          return this;     }        async x4192(parse, options = {})     {         if (   this.value             && this.value.isValid())         {             this.value.objects = v3723(this.input.value);               for (const b111 of this.value.objects)             {                 b111.nodeId   = this.nodeId;                 b111.objectId = b111.objectId + b965 + this.nodeId;                  if (   this.options.enabled                     && PATH_TYPES.includes(b111.type))                     b111.x3841.reverse();             }         }                           await super.x4192(parse);     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     } }


class c2572 extends e1974 {     inputs = [];      amount;     degree;        constructor(nodeId, options)     {         super(BLEND_PATH, nodeId, options);     }        reset()     {         super.reset();          this.inputs = [];          this.amount = null;         this.degree = null;     }        copy()     {         const copy = new c2572(this.nodeId, this.options);          copy.t3455(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.amount) copy.amount = this.amount.copy();         if (this.degree) copy.degree = this.degree.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const amount = await evalNumberValue(this.amount, parse);         const degree = await evalNumberValue(this.degree, parse);           const paths = [];                  for (const u3907 of this.inputs)         {             const input = await evalVectorPathValue(u3907, parse);              if (o955(input.type))             {                 for (const item of input.items)                 {                     const path = await evalVectorPathValue(item, parse);                     paths.push(path);                 }             }             else             {                 const path = await evalVectorPathValue(input, parse);                 paths.push(path);             }         }                           if (paths.length == 1)             this.value = paths[0];          else if (paths.length > 0)         {                                                                                                                                                                                                                                                                                                                                                              this.value = g2037.NaN();         }          else                               this.value = g2037.NaN();           await this.x4192(parse);           this.c4193(parse,         [             ['type',   this.outputType()],             ['amount', amount           ],             ['degree', degree           ]         ]);           this.validate();          return this;     }        async x4192(parse, options = {})     {         if (   this.value             && this.value.isValid())         {             this.value.objects = v3723(this.input.value);               for (const b111 of this.value.objects)             {                 b111.nodeId   = this.nodeId;                 b111.objectId = b111.objectId + b965 + this.nodeId;                                                }         }                           await super.x4192(parse);     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return  super.isValid()             &&  this.inputs.length > 0             && !this.inputs.find(i => !i.isValid())             &&  this.amount && this.amount.isValid()             &&  this.degree && this.degree.isValid();     }        p4180(parse)     {         super.p4180(parse);          this.inputs.forEach(i => i.p4180(parse));          if (this.amount) this.amount.p4180(parse);         if (this.degree) this.degree.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          this.inputs.forEach(i => i.i4181(parse, from, force));          if (this.amount) this.amount.i4181(parse, from, force);         if (this.degree) this.degree.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          this.inputs.forEach(i => i.i4179(parse));          if (this.amount) this.amount.i4179(parse);         if (this.degree) this.degree.i4179(parse);     } }


class h1963 extends l2044 {     position  = null;     transform = null;                constructor(nodeId, options)     {         super(s1275, nodeId, options);     }        reset()     {         super.reset();                  this.position  = null;         this.transform = null;     }        copy()     {         const copy = new h1963(this.nodeId, this.options);          copy.t3455(this);          if (this.position ) copy.position  = this.position .copy();         if (this.transform) copy.transform = this.transform.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const input     = await evalValue      (this.input,     parse);         const position  = await evalPointValue (this.position,  parse);         const transform = await evalNumberValue(this.transform, parse);          if (   input             && position)         {             this.value = input.copy();              if (this.value)                 this.value.nodeId = this.nodeId;         }         else             this.value = new s4309();           if (   position             && position.isValid()             && position.objects             && position.objects.length > 0)         {             const p0 = point(                 position.objects[0].x,                  position.objects[0].y);              const p1 = y893(p0, v898(position.objects[0].sp1, position.objects[0].sp0));             const p2 = y893(p0, v898(position.objects[0].sp2, position.objects[0].sp0));              await this.x4192(                 parse,                  {                     transform:  transform,                     sp0:        p0,                     sp1:        p1,                     sp2:        p2                 });         }                   this.c4193(parse,         [             ['position',  position ],             ['transform', transform]         ]);           this.validate();          return this;     }        async x4192(parse, options)     {         if (   this.value             && this.value.isValid())         {             this.value.objects = v3723(this.input.value);               const place = i891(                 options.sp0 ? options.sp0.x : 0,                 options.sp0 ? options.sp0.y : 0);               for (const b111 of this.value.objects)             {                 b111.nodeId   = this.nodeId;                 b111.objectId = b111.objectId + b965 + this.nodeId;                   if (this.options.enabled)                 {                     let x4300 = n887(                         i891(                             -b111.sp0.x,                              -b111.sp0.y),                         place);                       if (   options.transform.value > 0                         && options.sp0                         && options.sp1                         && options.sp2)                     {                         const sp = getTransformFromPoints(                             options.sp0,                              options.sp1,                              options.sp2);                          x4300 = n887(x4300, sp);                          b111.sp1 = y893(b111.sp0, point(1, 0));                         b111.sp2 = y893(b111.sp0, point(0, 1));                     }                       b111.s4191(x4300, true);                 }             }         }                           await super.x4192(parse);     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }                    isValid()     {         return super.isValid()             && this.position  && this.position .isValid()             && this.transform && this.transform.isValid();     }        p4180(parse)     {         super.p4180(parse);          if (this.position ) this.position .p4180(parse);         if (this.transform) this.transform.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.position ) this.position .i4181(parse, from, force);         if (this.transform) this.transform.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.position ) this.position .i4179(parse);         if (this.transform) this.transform.i4179(parse);     } }    function getTransformFromPoints(p0, p1, p2)  {     const dx   = p1.x - p0.x;     const dy   = p1.y - p0.y;      const a    = Math.atan2(dy, dx);        const cosa = Math.cos(a);     const sina = Math.sin(a);                        return [[ cosa,         -sina , 0 ],              [ sina , cosa,          0 ],              [ 0,             0,             1 ]]; }


class k1883 extends i2043 {     d3189 = [];     params   = [];        constructor(nodeId, options)     {         super(y1297, nodeId, options);     }            copy()     {         const copy = new k1883(this.nodeId, this.options);          copy.t3455(this);          copy.params = this.params.map(p => p.copy());          return copy;     }        w4334(m3091)     {         return this.params[this.d3189.findIndex(id => id == m3091)];     }        async eval(parse)     {         if (this.isCached())             return this;           this.c3193 = [];           if (!isEmpty(this.params))         {             for (let i = 0; i < this.params.length; i++)             {                 const param = await this.params[i].eval(parse);                 this.c4193(parse, [[this.d3189[i], param.toNewValue()]], true);             }         }         else             this.c4193(parse, [['', new s4309()]], true);                                   this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()               : null;     }        p4180(parse)     {         super.p4180(parse);          this.inputs.forEach(i => i.p4180(parse));         this.params.forEach(p => p.p4180(parse));     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          this.inputs.forEach(i => i.i4181(parse, from, force));         this.params.forEach(p => p.i4181(parse, from, force));     }        i4179(parse)     {         super.i4179(parse);          this.inputs.forEach(i => i.i4179(parse));         this.params.forEach(p => p.i4179(parse));     } } 


class q1884 extends i2043 {     input    = null;          dataType = NULL;        constructor(nodeId, options)     {         super(d1298, nodeId, options);     }        reset()     {         super.reset();          this.input    = null;         this.dataType = null;     }        copy()     {         const copy = new q1884(this.nodeId, this.options);                  copy.t3455(this);          if (this.input) copy.input = this.input.copy();                  copy.dataType = this.dataType;                return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           if (this.input)         {             if (!this.input.value)                 await this.input.eval(parse);              this.value = this.input.toNewValue();         }          else if (this.dataType != NULL)             this.value = nanFromType(this.dataType);                  else             this.value = new s4309();           this.c4193(parse,         [             ['value', this.value]         ]);           this.validate();          return this;     }        p4180(parse)     {         super.p4180(parse);          if (this.input) this.input.p4180(parse);     }        toNewValue()     {         return this.value.copy();     }        p4180(parse)     {         super.p4180(parse);          if (this.input) this.input.p4180(parse);     }        i4181(parse, from, force)     {         super.i4181(parse, from, force);          if (this.input) this.input.i4181(parse, from, force);     }        i4179(parse)     {         super.i4179(parse);          if (this.input) this.input.i4179(parse);     } }


class e2040 extends i2043 {     constructor(nodeId, options)     {         super(q1300, nodeId, options);     }            copy()     {         const copy = new e2040(this.nodeId, this.options);          copy.t3455(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new s4309();           this.c4193(parse, [['', new s4309()]]);                           this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()               : null;     } } 


class a2041 extends i2043 {     constructor(nodeId, options)     {         super(p1301, nodeId, options);     }            copy()     {         const copy = new a2041(this.nodeId, this.options);          copy.t3455(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new s4309();           this.c4193(parse, [['', new s4309()]]);                           this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()               : null;     } } 


class u2048 extends i2043 {     constructor(nodeId, options)     {         super(t1302, nodeId, options);     }            copy()     {         const copy = new u2048(this.nodeId, this.options);          copy.t3455(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new s4309();           this.c4193(parse, [['', new s4309()]]);                           this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()               : null;     } } 


var g3959 = false;  var q3960          = [];   var a4132            = []; var v4133  = [];       var lastMessage = null;   onmessage = function(e) {     const msg = JSON.parse(e.data);       if (msg.cmd == 'returnUiGetValueForGenerator')          return;           if (msg.cmd == 'genRequest')     {         if (   lastMessage             && lastMessage.cmd == 'genRequest')             return;           z4113(msg.request, msg.save);              }     else     {         switch (msg.cmd)         {             case 'initFonts':        initFonts(msg.fonts, msg.uniqueFontNames); break;                      case 'genEndUiMessage':  o2054 (msg.msgCmd);              break;             case 'genEndFigMessage': p2055();                        break;         }          lastMessage = null;     }       d2051(     {         cmd:   'uiEndGenMessage',         msgCmd: msg.cmd     }); };         function d2051(msg) {     if (msg == undefined)     {         h951('undefined message');         console.trace();     }      postMessage(JSON.stringify(msg)); }    function v2052(msg) {     q3960.push(msg);     p2053(); }    function p2053(msg) {     if (!isEmpty(q3960))          {                  let msg = q3960.shift();                                                                                                                                                                               d2051(msg);     } }    function o2054(msgCmd) {          p2053(); }    function p2055() {     g3959 = false;          if (   !isEmpty(w2059 )         || !isEmpty(p2060)         || !isEmpty(h2061 ))     {         m3956(             f2056,             false,             -1,              Number.MAX_SAFE_INTEGER,              j2057,              m2058,              [],              [],             [],             false);     }      p2053(); }  


var f2056     = -1; var j2057  =  NULL; var m2058 =  NULL; var w2059  =  []; var p2060 =  []; var h2061  =  [];    onerror = (event, source, line, pos, error) => {     postMessage({         type:    'error',         message:  event.message,         filename: event.filename,         lineno:   event.lineno,         colno:    event.colno     });      return true; };   addEventListener('unhandledrejection', event =>  {     postMessage(     {         type:  'unhandledrejection',         reason: event.reason     }); });    function initFonts(fonts, uniqueFontNames) {     a4132           = fonts;     v4133 = uniqueFontNames; }    function z4113(request, save) {     const e2067          = parseInt  (request[0]);     const actionId           = parseInt  (request[1]);     const set                = parseInt  (request[2]);     const objectBatchSize    = parseInt  (request[3]);     const maxSolveIterations = parseInt  (request[4]);     const numberVarNullValue = parseFloat(request[5]);     const boolVarNullValue   = z921 (request[6]);     const colorVarNullValue  = t155   (request[7]);       const settings =     {         showAllColorSpaces:   ((set >> 0) & 1) != 0,         logRequests:          ((set >> 1) & 1) != 0,         y2599:  ((set >> 2) & 1) != 0,         i189:         ((set >> 3) & 1) != 0,         n3828:     ((set >> 4) & 1) != 0,         r3829:     ((set >> 5) & 1) != 0,         preferHtmlColorNames: ((set >> 6) & 1) != 0,         maxSolveIterations:   maxSolveIterations,         numberVarNullValue:   numberVarNullValue,         boolVarNullValue:     boolVarNullValue,         colorVarNullValue:    colorVarNullValue      };       const m4114  = request[8];     const y4115 = request[9];      const viewportZoom  = request[10];       const parse = new c1786(         request,          11,         e2067,         m4114,          y4115,          viewportZoom,         settings,         save);       const x3823 = 100;      while (   parse.pos < parse.request.length            && parse.so  < x3823)         s1788(parse);       if (settings.logRequests)         h2123(parse);       const w4323 = parse.u3737         .map(id => parse.b4335.find(n => n.nodeId == id));                const h3958 = parse.b4335         .filter(n =>                  n.topLevel              && !w4323.find(h3593 => h3593.nodeId == n.nodeId));      const otherNodes = parse.b4335.filter(n =>                !w4323   .find(h3593 => h3593.nodeId == n.nodeId)             && !h3958.find(h3593 => h3593.nodeId == n.nodeId));       (async () =>     {         let stop = false;           for (const nodes of [w4323, h3958])         {             for (const node of nodes)             {                 if (await s3957(parse.e2067)) { stop = true; break; }                 await node.eval(parse);             }         }           for (const terminalId of parse.terminalIds)         {             const terminal = parse.b4335.find(n => n.nodeId == terminalId);              if (terminal)             {                 if (await s3957(parse.e2067)) { stop = true; break; }                  terminal.invalidate();                 await terminal.eval(parse);             }         }           if (    stop             && !settings.i189)             return;           v2052({cmd: 'uiEndGlobalProgress'});                  for (const nodes of [h3958, otherNodes])             for (const node of nodes)                  node.p4180(parse);                           for (const node of parse.b4335)         {             if (node.options.active === true)             {                 if (   node.value                     && node.value.objects)                     node.value.objects.forEach(o => r2063(parse, o));                  if (node.colorStyle)                      g2064(parse, node.colorStyle);             }         }           for (const node of parse.b4335)         {             if (   node.options.active === true                 && node.value                 && node.value.objects)             {                 for (const b111 of node.value.objects)                 {                     if (b111.showCenter)                     {                         r2063(                             parse,                              y2682(node, b111));                     }                       if (    parse.settings.y2599                         && !b111.h3834                         &&  b111.xp0                         &&  b111.xp1                         &&  b111.xp2)                     {                         const xp0 = clone(b111.xp0);                         const xp1 = clone(b111.xp1);                         const xp2 = clone(b111.xp2);                         const xp3 = y893(xp2, v898(xp1, xp0));                          r2063(                             parse,                              createDecoPoly(                                 node.nodeId,                                 b111.objectId,                                 b111.objectName,                                 b111.sp0,                                 [xp0, xp2, xp3, xp1],                                 true,                                 '1, 2',                                 [12, 140, 233],                                 v969,                                 false));                     }                 }             }         }                    await m3956(             parse.e2067,             settings.i189,             actionId,             objectBatchSize,             parse.m4114,             parse.y4115,             parse.c3193,             parse.m3738,             parse.m3739,             save);     })(); }    async function s3957(e2067) {     const uiCurRequestId = await genGetValueFromUi('curRequestId');      if (uiCurRequestId.value > e2067)      {          v2052({cmd: 'uiEndGlobalProgress'});         return true;      }      return false }    function a2062(parse, nodeId, m3091, value) {     if (!value)         return;           b943(parse.c3193, v =>            v.nodeId     == nodeId         && v.m3091    == m3091         && v.value.type == value.type);           parse.c3193.push(     {         nodeId:  nodeId,         m3091: m3091,         type:    value.type,          value:   value.q2119()     }); }    function r2063(parse, object) {     a949(         parse.m3738,         object,         o =>    o.nodeId   == object.nodeId              && o.objectId == object.objectId); }    function g2064(parse, style) {     a949(         parse.m3739,         style,         o => o.nodeId == style.nodeId); }    function j2065() {     j2057  =  NULL;     m2058 =  NULL;      w2059  =  [];     p2060 =  [];     h2061  =  []; }    async function m3956(e2067, i189, actionId, objectBatchSize, m4114, y4115, c3193, m3738, m3739, save) {     if (   isEmpty(c3193 )         && isEmpty(m3738)         && isEmpty(m3739 ))     {         m4114  = j2057;         y4115 = m2058;                  c3193  = w2059;         m3738 = p2060;         m3739  = h2061;          j2065();     }     else if (g3959)     {         f2056     = e2067;         j2057  = m4114;         m2058 = y4115;          w2059  = c3193;         p2060 = m3738;         h2061  = m3739;          return;     }       const nodeIds = q1464(c3193.map(v => v.nodeId));     const counts  = nodeIds.map(id => c3193.filter(v => v.nodeId == id).length);             const approxNodeChunkSize = 1000000;     const objChunkSize        = 1000000;     const styleChunkSize      = 1000000;           let n  = 0;      let o  = 0;      let s  = 0;       let nc = 0;      let oc = 0;      let sc = 0;        let y2070   = [],         o2071       = [],         o2072     = [];      let p2069 = 0;      let y2075   = true;               v2052(     {         cmd:      'uiInitGlobalProgress',         e2067: e2067     });       let k2068 = 0;     m3738.forEach(o => k2068 += o.getCount());           while (   n < nodeIds      .length            || o < m3738.length            || s < m3739 .length)     {         if (n < nodeIds.length)         {             y2070.push(nodeIds[n], counts[n]);              const values = c3193.filter(v => v.nodeId == nodeIds[n]);                           for (const v of values)                 y2070.push(v.m3091, v.type, v.value);              n++, nc++;         }           if (o < m3738.length)         {             o2071.push(m3738[o].i3836());             o++, oc++;         }           if (s < m3739.length)         {             o2072.push(m3739[s].i3836());             s++, sc++;         }           const chunkNotEmpty =                nc >= approxNodeChunkSize             || oc == objChunkSize             || sc == styleChunkSize;           if (chunkNotEmpty)         {             const i2076 =                        n >= nodeIds      .length                 && o >= m3738.length                 && s >= m3739 .length                 && (   !isEmpty(y2070)                     || !isEmpty(o2071    )                     || !isEmpty(o2072  ));              s2066(                 e2067,                 actionId,                 m4114,                 y4115,                 objectBatchSize,                 k2068,                 p2069++,                 y2070,                 o2071,                 o2072,                 n,                 nodeIds.length,                 y2075,                 i2076,                 save);              y2070 = [];  nc = 0;             o2071     = [];  oc = 0;             o2072   = [];  sc = 0;              y2075 = false;         }           if (await s3957(e2067))              break;     }       const lastChunkNotEmpty =            !isEmpty(y2070)         || !isEmpty(o2071    )         || !isEmpty(o2072  );       if (   lastChunkNotEmpty         || i189         ||    isEmpty(c3193)             && isEmpty(m3738)            && isEmpty(m3739))     {         s2066(             e2067,             actionId,             m4114,             y4115,             objectBatchSize,             k2068,             p2069++,             y2070,             o2071,             o2072,             nodeIds.length,             nodeIds.length,             false,             true,             save);     }       v2052({         cmd: 'uiForwardToFigma',         msg: {cmd: 'figCommitUndo'}     }) }    function s2066(e2067, actionId, m4114, y4115, objectBatchSize, k2068, p2069, y2070, o2071, o2072, s2073, q2074, y2075, i2076, save) {     v2052({         cmd:            'uiUpdateValuesAndObjects',         e2067:       e2067,         actionId:        actionId,         m4114:    m4114,         y4115:   y4115,         objectBatchSize: objectBatchSize,         k2068:    k2068,         chunkId:         p2069,         values:          [...y2070].map(v => v.toString()),         objects:         [...o2071    ],         styles:          [...o2072  ],         s2073:    s2073,         q2074:      q2074,         y2075:    y2075,         i2076:     i2076,         save:            save     });       if (   !isEmpty(o2071  )         || !isEmpty(o2072))         g3959 = true; }    function b2077(nodeId) {     v2052(     {         cmd:   'uiInitNodeProgress',         nodeId: nodeId     }); }    function u2078(parse, nodeId, progress, updateGlobal = true) {     v2052(     {         cmd:           'uiUpdateNodeProgress',         nodeId:         nodeId,         progress:       progress,         globalProgress: parse.f3734 / parse.f3735,         updateGlobal:   updateGlobal     }); }    function g2079(nodeId, endGlobal) {     v2052(     {         cmd:      'uiEndNodeProgress',         nodeId:    nodeId,         endGlobal: endGlobal     }); }    async function genGetObjectSizeFromFigma(b111)  {     return new Promise((resolve, reject) =>      {         const timeout = 1000;          d2051(         {             cmd: 'uiForwardToFigma',             msg:               {                 cmd:   'figGetObjectSize',                 object: b111             }         });          const z2840 = setTimeout(() =>              reject(new Error('Timeout: Result not received within the specified time')),             timeout);          function s4125(event)          {             const msg = JSON.parse(event.data);              if (msg.cmd === 'returnFigGetObjectSize')              {                 clearTimeout(z2840);                                  const { objectId, width, height } = msg;                 resolve({ objectId, width, height });                  self.removeEventListener('message', s4125);             }         }          self.addEventListener('message', s4125);     }); }    async function genGetValueFromUi(key)  {     return new Promise((resolve, reject) =>      {         const timeout = 60000;          d2051(         {             cmd: 'uiGetValueForGenerator',             key:  key          });          const z2840 = setTimeout(() =>              reject(new Error('Timeout: Result not received by Generator within the specified time')),             timeout);          function s4125(event)          {             const msg = JSON.parse(event.data);              if (msg.cmd === 'returnUiGetValueForGenerator')              {                 clearTimeout(z2840);                  resolve(                 {                      key:   msg.key,                      value: msg.value                  });                  self.removeEventListener('message', s4125);             }         }          self.addEventListener('message', s4125);     }); }


function u1623(parse) {     parse.pos++;       const col = parse.move();      if (parse.settings.logRequests)          l2131(j1167, col, parse);      return o2964(col)[0]; }    function o1624(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const col = new h1815(nodeId, options);      col.g3362 = options.g3362;             let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(col, parse, ignore, k4301);       if (ignore)      {         b1791(parse, col);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;           let d3189;      if (k4301 == 1)     {         col.input = s1788(parse);         d3189 = parse.move().split(',');     }     else         d3189 = ['space', 'convert', 'c1', 'c2', 'c3'];       parse.v1789 = false;          for (const id of d3189)     {         switch (id)         {         case 'space':   col.space        = s1788(parse);  break;         case 'convert': col.convert      = s1788(parse);  break;         case 'c1':      col.b3779 = col.c1 = s1788(parse);  break;         case 'c2':      col.f3780 = col.c2 = s1788(parse);  break;         case 'c3':      col.h3781 = col.c3 = s1788(parse);  break;         }     }           parse.y3742--;       b1791(parse, col);     return col; }    function x1625(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const valid = new m1822(nodeId, options);       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(valid, parse, ignore, k4301);       if (ignore)      {         b1791(parse, valid);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         valid.input = s1788(parse);       valid.method = s1788(parse);     valid.value  = s1788(parse);       parse.y3742--;       b1791(parse, valid);     return valid; }    function u1626(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const corr = new p1821(nodeId, options);      corr.g3362 = options.g3362;       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(corr, parse, ignore, k4301);       if (ignore)      {         b1791(parse, corr);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       let d3189;      if (k4301 == 1)         corr.input = s1788(parse);       d3189 = parse.move().split(',');      parse.v1789 = false;          for (const id of d3189)     {         switch (id)         {         case 'order':  corr.r3778 = corr.order = s1788(parse);  break;         case 'c1':     corr.b3779    = corr.c1    = s1788(parse);  break;         case 'c2':     corr.f3780    = corr.c2    = s1788(parse);  break;         case 'c3':     corr.h3781    = corr.c3    = s1788(parse);  break;         case 'value':  corr.value               = s1788(parse);  break;         }     }                       parse.y3742--;       b1791(parse, corr);     return corr; }    function q1627(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const cnt = new s1818(nodeId, options);       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 2, 'nInputs must be [0, 2]');     }       const n3777 =          k4301 == 1         ? parseInt(parse.move())         : -1;           if (parse.settings.logRequests)          x2130(cnt, k4301, n3777, parse, ignore);       if (ignore)      {         b1791(parse, cnt);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 2)     {         cnt.o4175   = s1788(parse);         cnt.i4176   = s1788(parse);     }     else if (k4301 == 1)     {              if (n3777 == 0) cnt.o4175 = s1788(parse);          else if (n3777 == 1) cnt.i4176 = s1788(parse);      }         cnt.standard = s1788(parse);       parse.y3742--;       b1791(parse, cnt);     return cnt; }    function genParseColorDifference(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const diff = new w2586(nodeId, options);       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 2, 'nInputs must be [0, 2]');     }       const n3777 =          k4301 == 1         ? parseInt(parse.move())         : -1;           if (parse.settings.logRequests)          x2130(diff, k4301, n3777, parse, ignore);       if (ignore)      {         b1791(parse, diff);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 2)     {         diff.o4175 = s1788(parse);         diff.i4176 = s1788(parse);     }     else if (k4301 == 1)     {              if (n3777 == 0) diff.o4175 = s1788(parse);          else if (n3777 == 1) diff.i4176 = s1788(parse);      }         diff.deltaE = s1788(parse);     diff.space  = s1788(parse);     diff.e4261 = s1788(parse);     diff.q4262 = s1788(parse);     diff.z4263 = s1788(parse);       parse.y3742--;       b1791(parse, diff);     return diff; }    function g1628(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const convert = new g1820(nodeId, options);       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(convert, parse, ignore, k4301);       if (ignore)      {         b1791(parse, convert);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         convert.input = s1788(parse);       convert.from = s1788(parse);       parse.y3742--;       b1791(parse, convert);     return convert; }    function u1629(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const cb = new y1817(nodeId, options);       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(cb, parse, ignore, k4301);       if (ignore)      {         b1791(parse, cb);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         cb.input = s1788(parse);      cb.l = s1788(parse);     cb.m = s1788(parse);     cb.s = s1788(parse);           parse.y3742--;       b1791(parse, cb);     return cb; }    function genParseColorScheme(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const scheme = new a2581(nodeId, options);       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(scheme, parse, ignore, k4301);       if (ignore)      {         b1791(parse, scheme);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         scheme.input = s1788(parse);       scheme.schemeType = s1788(parse);     scheme.space      = s1788(parse);       parse.y3742--;       b1791(parse, scheme);     return scheme; }    function d1630(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const q1033 = new v1819(nodeId, options);       let k4301 = 0;          if (!ignore)         k4301 = parseInt(parse.move());           if (parse.settings.logRequests)          r2124(q1033, parse, ignore, k4301);       if (ignore)      {         b1791(parse, q1033);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       parse.y3742++;      for (let i = 0; i < k4301; i++)         q1033.inputs.push(s1788(parse));       q1033.space  = s1788(parse);     q1033.gamma  = s1788(parse);     q1033.amount = s1788(parse);     q1033.degree = s1788(parse);       parse.y3742--;       b1791(parse, q1033);     return q1033; }    function o1631(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const blend = new a1816(nodeId, options);       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.logRequests)          r2124(blend, parse, ignore, k4301);       if (ignore)      {         b1791(parse, blend);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 2)     {         blend.o4175 = s1788(parse);         blend.i4176 = s1788(parse);     }      else if (k4301 == 1)         blend.o4175 = s1788(parse);       else if (k4301 != 0)         h951('nInputs must be [0, 2]');       blend.mode   = s1788(parse);     blend.amount = s1788(parse);       parse.y3742--;       b1791(parse, blend);     return blend; }    function u1669(parse) {     parse.pos++;       const grad = parse.move();      if (parse.settings.logRequests)          l2131(c1186, grad, parse);      return l3771(grad)[0]; }    function k1670(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const grad = new f1890(nodeId, options);      grad.g3362 = options.g3362;       let k4301 = 0;          if (!ignore)         k4301 = parseInt(parse.move());       if (parse.settings.logRequests)          r2124(grad, parse, ignore, k4301);       if (ignore)     {         b1791(parse, grad);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       for (let i = 0; i < k4301; i++)         grad.inputs.push(s1788(parse));       const k3763 = b1793(parse);       for (let i = 0; i < k3763; i++)     {         const m3091 = k1795(parse);          parse.v1789 = true;          switch (m3091)         {         case 'gradType': grad.h3782 = s1788(parse); break;         case 'position': grad.position = s1788(parse); break;         case 'x':        grad.x        = s1788(parse); break;         case 'y':        grad.y        = s1788(parse); break;         case 'size':     grad.size     = s1788(parse); break;         case 'angle':    grad.angle    = s1788(parse); break;         case 'aspect':   grad.aspect   = s1788(parse); break;         case 'skew':     grad.skew     = s1788(parse); break;         case 'blend':    grad.blend    = s1788(parse); break;         }     }           grad.diagAspect = parseInt(parse.move()) > 0;       parse.v1789 = false;     parse.y3742--;       b1791(parse, grad);     return grad; }                function i1671(parse) {     parse.pos++;       const stop = parse.move();      if (parse.settings.logRequests)          l2131(i1183, stop, parse);      return l2965(stop)[0]; }    function k1672(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const stop = new b1886(nodeId, options);      stop.g3362 = options.g3362;       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(stop, parse, ignore, k4301);       if (ignore)     {         b1791(parse, stop);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       let d3189;      if (k4301 == 1)     {         stop.input = s1788(parse);         d3189 = parse.move().split(',');     }     else         d3189 = ['fill', 'position'];       parse.v1789 = false;      for (const id of d3189)     {         switch (id)         {         case 'fill':     stop.fill     = s1788(parse); break;         case 'position': stop.position = s1788(parse); break;         }     }               parse.y3742--;       b1791(parse, stop);     return stop; }


function t1632(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const _null = new w1866(nodeId, options);       let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(_null, parse, ignore, k4301);       if (ignore)      {         b1791(parse, _null);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         _null.input = s1788(parse);       parse.y3742--;       b1791(parse, _null);     return _null; }    function m1633(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const variable = new h1881(nodeId, options);       let k4301 = -1;           if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(variable, parse, ignore);       if (ignore)      {         b1791(parse, variable);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;     parse.v1789 = false;       if (k4301 == 1)         variable.input = s1788(parse);           variable.variableId   = parse.move();     variable.variableType = parse.move();     variable.variableName = decodeURIComponent(parse.move());       const nVars = parseInt(parse.move());      for (let i = 0; i < nVars; i++)     {         switch (variable.variableType)         {             case 'FLOAT':                    variable.variableValues.push(parseFloat(parse.move()));                 break;                              case 'BOOLEAN':                  variable.variableValues.push(z921(parse.move()));                 break;                              case 'STRING':                   variable.variableValues.push(decodeURIComponent(parse.move()));                 break;                              case 'COLOR':             {                 const color = parse.move()                     .split(' ')                     .map(s => parseFloat(s));                  variable.variableValues.push(                 {                     r: color[0],                     g: color[1],                     b: color[2],                     a: color[3]                 });                 break;             }         }     }       const nAliases = parseInt(parse.move());      for (let i = 0; i < nAliases; i++)         variable.aliasIds.push(parse.move());      for (let i = 0; i < nAliases; i++)         variable.aliasNames.push(parse.move());       variable.variableTemp = z921(parse.move());       variable.aliasIds   = variable.aliasIds  .map(id   => id   == NULL_VALUE ? NULL : id  );     variable.aliasNames = variable.aliasNames.map(name => name == NULL_VALUE ? NULL : name);       if (parse.settings.logRequests)      {         logReqString(variable.variableId   == NULL ? NULL_VALUE : variable.variableId,   parse);         logReqString(variable.variableType == NULL ? NULL_VALUE : variable.variableType, parse);         logReqString(variable.variableName != ''   ? '\'' + variable.variableName + '\'' : '\'\'', parse);                   for (const varVal of variable.variableValues)         {             switch (variable.variableType)             {                 case 'FLOAT':                        logReqString(varVal ? varVal.toString() : NULL_VALUE, parse);                     break;                                      case 'BOOLEAN':                      logReqString(varVal ? h935(varVal) : NULL_VALUE, parse);                     break;                                      case 'STRING':                       logReqString(varVal ?? NULL_VALUE, parse);                     break;                                      case 'COLOR':                     logReqString(                                 varVal.r.toString()                         + ' ' + varVal.g.toString()                         + ' ' + varVal.b.toString()                         + ' ' + varVal.a.toString(),                         parse);                     break;             }         }           if (variable.aliasIds.length > 0)         {             for (const aliasId of variable.aliasIds)                 logReqString(aliasId == NULL ? NULL_VALUE : aliasId, parse);         }           if (variable.aliasNames.length > 0)         {             for (const aliasName of variable.aliasNames)                 logReqString(aliasName == NULL ? NULL_VALUE : aliasName, parse);         }           logReqString(variable.variableTemp ? 'temp' : 'existing', parse);     }       const a3774 = parseInt(parse.move());      for (let i = 0; i < a3774; i++)         variable.e2971.push(variable['value'+i] = s1788(parse));           parse.y3742--;           b1791(parse, variable);     return variable; }    function v1634(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const group = new q1882(nodeId, options);           let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(group, parse, ignore, k4301);       if (ignore)      {         b1791(parse, group);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         group.input = s1788(parse);       parse.y3742--;       b1791(parse, group);     return group; }    function g1635(parse) {     parse.pos++;       const list = parse.move();      if (parse.settings.logRequests)          l2131(q1054, list, parse);      return g3578(list)[0]; }    function c1636(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const cmb = new m1857(nodeId, options);           let k4301 = 0;          if (!ignore)         k4301 = parseInt(parse.move());       if (parse.settings.logRequests)          r2124(cmb, parse, ignore, k4301);       if (ignore)      {         b1791(parse, cmb);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;           for (let i = 0; i < k4301; i++)         cmb.inputs.push(s1788(parse));       parse.y3742--;               b1791(parse, cmb);     return cmb; }    function t1637(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const listAsItem = new b1858(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(listAsItem, parse, ignore, k4301);       if (ignore)      {         b1791(parse, listAsItem);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         listAsItem.input = s1788(parse);           parse.y3742--;       b1791(parse, listAsItem);     return listAsItem; }    function m1638(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const extr = new z1860(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(extr, parse, ignore, k4301);       if (ignore)      {         b1791(parse, extr);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         extr.input = s1788(parse);      extr.indices = s1788(parse);           parse.y3742--;       b1791(parse, extr);     return extr; }    function q1639(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const set = new m1873(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(set, parse, ignore, k4301);       if (ignore)      {         b1791(parse, set);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 2)     {         set.o4175 = s1788(parse);         set.i4176 = s1788(parse);         set.name   = s1788(parse);     }     else if (k4301 == 1)     {         set.o4175 = s1788(parse);          set.name   = s1788(parse);     }     else if (k4301 == 0)     {         set.name   = s1788(parse);     }           parse.y3742--;       b1791(parse, set);     return set; }    function f1640(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const extr = new l1874(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(extr, parse, ignore, k4301);       if (ignore)      {         b1791(parse, extr);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         extr.input = s1788(parse);      extr.name = s1788(parse);           parse.y3742--;       b1791(parse, extr);     return extr; }    function r1641(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const sub = new b1877(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(sub, parse, ignore, k4301);       if (ignore)      {         b1791(parse, sub);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         sub.input = s1788(parse);      sub.start = s1788(parse);     sub.end   = s1788(parse);           parse.y3742--;       b1791(parse, sub);     return sub; }    function f1642(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const unique = new d1879(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(unique, parse, ignore, k4301);       if (ignore)      {         b1791(parse, unique);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         unique.input = s1788(parse);             parse.y3742--;       b1791(parse, unique);     return unique; }    function l1644(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const shift = new o1869(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(shift, parse, ignore, k4301);       if (ignore)      {         b1791(parse, shift);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         shift.input = s1788(parse);      shift.offset = s1788(parse);           parse.y3742--;       b1791(parse, shift);     return shift; }    function k1645(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const reverse = new l1870(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(reverse, parse, ignore, k4301);       if (ignore)      {         b1791(parse, reverse);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         reverse.input = s1788(parse);             parse.y3742--;       b1791(parse, reverse);     return reverse; }    function genParseBuckleList(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const buckle = new g2609(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(buckle, parse, ignore, k4301);       if (ignore)      {         b1791(parse, buckle);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         buckle.input = s1788(parse);         buckle.amount = s1788(parse);           parse.y3742--;       b1791(parse, buckle);     return buckle; }    function n1643(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const reorder = new h1868(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(reorder, parse, ignore, k4301);       if (ignore)      {         b1791(parse, reorder);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         reorder.input = s1788(parse);       reorder.indices = s1788(parse);           parse.y3742--;       b1791(parse, reorder);     return reorder; }    function x1646(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const sort = new c1875(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(sort, parse, ignore, k4301);       if (ignore)      {         b1791(parse, sort);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         sort.input = s1788(parse);       const nConditions = parseInt(parse.move());      if (nConditions == 1)         sort.condition = s1788(parse);               sort.reverse = s1788(parse);           parse.y3742--;       b1791(parse, sort);     return sort; }    function g1647(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const filter = new d1861(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(filter, parse, ignore, k4301);       if (ignore)      {         b1791(parse, filter);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         filter.input = s1788(parse);      filter.condition = s1788(parse);           parse.y3742--;       b1791(parse, filter);     return filter; }    function q1648(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const column = new c1856(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(column, parse, ignore, k4301);       if (ignore)      {         b1791(parse, column);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         column.input = s1788(parse);      column.index = s1788(parse);           parse.y3742--;       b1791(parse, column);     return column; }    function x1649(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const cell = new w1855(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(cell, parse, ignore, k4301);       if (ignore)      {         b1791(parse, cell);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         cell.input = s1788(parse);      cell.column = s1788(parse);     cell.row    = s1788(parse);           parse.y3742--;       b1791(parse, cell);     return cell; }    function w1650(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const list = new r1864(nodeId, options);           let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(list, parse, ignore, k4301);       if (ignore)      {         b1791(parse, list);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         list.input = s1788(parse);       parse.y3742--;       b1791(parse, list);     return list; }    function j1651(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const sel = new r1871(nodeId, options);           let k4301 = 0;          if (!ignore)         k4301 = parseInt(parse.move());       if (parse.settings.logRequests)          r2124(sel, parse, ignore, k4301);       if (ignore)      {         b1791(parse, sel);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;           for (let i = 0; i < k4301; i++)         sel.inputs.push(s1788(parse));      sel.index = s1788(parse);       parse.y3742--;               b1791(parse, sel);     return sel; }    function genParseSelectFromList(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const sel = new x1872(nodeId, options);           let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(sel, parse, ignore, k4301);       if (ignore)      {         b1791(parse, sel);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         sel.input = s1788(parse);      sel.index = s1788(parse);           parse.y3742--;       b1791(parse, sel);     return sel; }    function b1652(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const count = new c1865(nodeId, options);           let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(count, parse, ignore, k4301);       if (ignore)      {         b1791(parse, count);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         count.input = s1788(parse);      count.start = s1788(parse);       parse.y3742--;       b1791(parse, count);     return count; }    function genParseObjectCount(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const count = new n2625(nodeId, options);           let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(count, parse, ignore, k4301);       if (ignore)      {         b1791(parse, count);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         count.input = s1788(parse);      count.start = s1788(parse);       parse.y3742--;       b1791(parse, count);     return count; }    function s1653(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const cont = new x2621(nodeId, options);          let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.logRequests)          r2124(cont, parse, ignore, k4301);       if (ignore)      {         b1791(parse, cont);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 2)     {         cont.o4175 = s1788(parse);         cont.i4176 = s1788(parse);     }     else if (k4301 == 1)     {         cont.o4175 = s1788(parse);      }             parse.y3742--;       b1791(parse, cont);     return cont; }    function genParseListFind(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const find = new y1859(nodeId, options);          let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.logRequests)          r2124(find, parse, ignore, k4301);       if (ignore)      {         b1791(parse, find);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 2)     {         find.o4175 = s1788(parse);         find.i4176 = s1788(parse);     }     else if (k4301 == 1)     {         find.o4175 = s1788(parse);      }             parse.y3742--;       b1791(parse, find);     return find; }    function d1654(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const f3776 = new v1863(nodeId, options);       let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 2, 'nInputs must be [0, 2]');     }       const n3777 =          k4301 == 1         ? parseInt(parse.move())         : -1;       if (parse.settings.logRequests)          r2124(f3776, parse, ignore, k4301);       if (ignore)      {         b1791(parse, f3776);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;      if (k4301 == 2)     {         f3776.o4175    = s1788(parse);         f3776.i4176    = s1788(parse);         f3776.condition = s1788(parse);     }     else if (k4301 == 1)     {              if (n3777 == 0) f3776.o4175 = s1788(parse);          else if (n3777 == 1) f3776.i4176 = s1788(parse);           f3776.condition = s1788(parse);     }     else if (k4301 == 0)     {         f3776.condition = s1788(parse);     }      parse.y3742--;       b1791(parse, f3776);     return f3776; }    function t1655(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const feedback = new r1876(nodeId, options);       let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(feedback, parse, ignore, k4301);       if (ignore)      {         b1791(parse, feedback);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         feedback.input = s1788(parse);       parse.y3742--;       b1791(parse, feedback);     return feedback; }    function z1656(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const repeat = new y1867(nodeId, options);       let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(repeat, parse, ignore, k4301);       if (ignore)      {         b1791(parse, repeat);         return parse.b4335.find(n => n.nodeId == nodeId);     }       repeat.isTerminal  = parseInt(parse.move()) > 0;     repeat.activeAfter = parseInt(parse.move()) > 0;     repeat.listAfter   = parseInt(parse.move()) > 0;       parse.y3742++;       if (k4301 == 1)         repeat.input = s1788(parse);      repeat. count     = s1788(parse);     repeat .iteration = s1788(parse);     repeat.g3775     = s1788(parse);        repeat. loop      = s1788(parse);         parse.y3742--;       b1791(parse, repeat);     return repeat; }    function genParseAdvance(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const advance = new j2624(nodeId, options);       let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(advance, parse, ignore, k4301);       if (ignore)      {         b1791(parse, advance);         return parse.b4335.find(n => n.nodeId == nodeId);     }                        parse.y3742++;       if (k4301 == 1)         advance.input = s1788(parse);      advance.loop = s1788(parse);         parse.y3742--;       b1791(parse, advance);     return advance; }    function i1657(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const cache = new q1854(nodeId, options);       let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(cache, parse, ignore, k4301);       if (ignore)      {         b1791(parse, cache);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         cache.input = s1788(parse);       parse.y3742--;       b1791(parse, cache);     return cache; }    function t1658(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const freeze = new q1862(nodeId, options);       let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(freeze, parse, ignore, k4301);       if (ignore)      {         b1791(parse, freeze);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         freeze.input = s1788(parse);       parse.y3742--;       b1791(parse, freeze);     return freeze; }    function q1659(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const timer = new k1878(nodeId, options);       let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(timer, parse, ignore, k4301);       if (ignore)      {         b1791(parse, timer);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         timer.input = s1788(parse);       timer.interval = s1788(parse);     timer.g3775   = s1788(parse);     timer. loop    = s1788(parse);         parse.y3742--;       b1791(parse, timer);     return timer; }    function genParseGetValueName(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const name = new e2629(nodeId, options);       let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(name, parse, ignore, k4301);       if (ignore)      {         b1791(parse, name);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         name.input = s1788(parse);      name.name = s1788(parse);       parse.y3742--;       b1791(parse, name);     return name; }    function genParseSetValueName(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const name = new e2620(nodeId, options);       let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(name, parse, ignore, k4301);       if (ignore)      {         b1791(parse, name);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         name.input = s1788(parse);      name.name = s1788(parse);       parse.y3742--;       b1791(parse, name);     return name; }    function genParseGetListValueNames(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const names = new s2615(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(names, parse, ignore, k4301);       if (ignore)      {         b1791(parse, names);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         names.input = s1788(parse);             parse.y3742--;       b1791(parse, names);     return names; }    function genParseSetListValueNames(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const names = new h2623(nodeId, options);       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 2, 'nInputs must be [0, 2]');     }       const n3777 =          k4301 == 1         ? parseInt(parse.move())         : -1;       if (parse.settings.logRequests)          r2124(names, parse, ignore, k4301);       if (ignore)     {         b1791(parse, names);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;      if (k4301 == 2)     {         names.o4175 = s1788(parse);         names.i4176 = s1788(parse);     }     else if (k4301 == 1)     {              if (n3777 == 0) names.o4175 = s1788(parse);          else if (n3777 == 1) names.i4176 = s1788(parse);      }      parse.y3742--;       b1791(parse, names);     return names; }    function genParseSetObjectName(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const name = new b2617(nodeId, options);       let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(name, parse, ignore, k4301);       if (ignore)      {         b1791(parse, name);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         name.input = s1788(parse);      name.name    = s1788(parse);         parse.y3742--;       b1791(parse, name);     return name; }    function p1661(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const cmnt = new e2040(nodeId, options);           if (parse.settings.logRequests)          r2124(cmnt, parse, ignore);       if (ignore)      {         b1791(parse, cmnt);         return parse.b4335.find(n => n.nodeId == nodeId);     }       b1791(parse, cmnt);     return cmnt; }    function d1662(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const cmnt = new a2041(nodeId, options);           if (parse.settings.logRequests)          r2124(cmnt, parse, ignore);       if (ignore)      {         b1791(parse, cmnt);         return parse.b4335.find(n => n.nodeId == nodeId);     }       b1791(parse, cmnt);     return cmnt; }    function w1663(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const panel = new u2048(nodeId, options);           if (parse.settings.logRequests)          r2124(panel, parse, ignore);       if (ignore)      {         b1791(parse, panel);         return parse.b4335.find(n => n.nodeId == nodeId);     }       b1791(parse, panel);     return panel; }


function a1664(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const group = new k1883(nodeId, options);       let a3774 = -1;          if (!ignore)     {         a3774 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(group, parse, ignore);       if (ignore)     {         b1791(parse, group);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;             for (let i = 0; i < a3774; i++)     {         group.d3189.push(parse.move());         group.params  .push(s1788(parse));     }       parse.y3742--;       b1791(parse, group);     return group; }    function x1665(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const param = new q1884(nodeId, options);       let k4301  = -1;     let a3773 = -1;          if (!ignore)     {         k4301  = parseInt(parse.move());         a3773 = parseInt(parse.move());          c950(k4301  == 0 || k4301  == 1,  'nInputs must be [0, 1]');         c950(a3773 == 0 || a3773 == 1, 'nOutputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(param, parse, ignore);       if (ignore)      {         b1791(parse, param);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)     {         param.input    = s1788(parse);         param.dataType = parse.move();     }     else if (a3773 == 1)         param.dataType = parse.move();       parse.y3742--;       b1791(parse, param);     return param; } 


function n1666(parse) {     parse.pos++;       const fill = parse.move();      if (parse.settings.logRequests)          l2131(d1177, fill, parse);      return o3772(fill)[0]; }    function l1667(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const fill = new k1889(nodeId, options);      fill.g3362 = options.g3362;       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(fill, parse, ignore, k4301);       if (ignore)     {         b1791(parse, fill);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       let d3189;      if (k4301 == 1)     {         fill.input = s1788(parse);         d3189 = parse.move().split(',');     }     else         d3189 = ['color', 'opacity', 'blend'];       parse.v1789 = false;      for (const id of d3189)     {         switch (id)         {         case 'color':   fill.color   = s1788(parse); break;         case 'opacity': fill.opacity = s1788(parse); break;         case 'blend':   fill.blend   = s1788(parse); break;         }     }           parse.y3742--;       b1791(parse, fill);     return fill; }    function s1668(parse) {     const fill = s1788(parse);       if (m1176.includes(fill.type))         fill.options.opacity = s1788(parse);      return fill; }    function c1673(parse) {     parse.pos++;       const stroke = parse.move();      if (parse.settings.logRequests)          l2131(b1180, stroke, parse);      return g3927(stroke)[0]; }    function k1674(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const stroke = new o1896(nodeId, options);      stroke.g3362 = options.g3362;       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(stroke, parse, ignore, k4301);       if (ignore)     {         b1791(parse, stroke);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       let d3189;      if (k4301 == 1)     {         stroke.input = s1788(parse);         d3189 = parse.move().split(',');     }     else         d3189 = ['fill', 'weight', 'fit', 'join', 'miter', 'cap', 'dashes'];       parse.v1789 = false;      for (const id of d3189)     {         switch (id)         {         case 'fill':   stroke.q3770 = s1788(parse); stroke.fills = stroke.q3770; break;         case 'weight': stroke.weight = s1788(parse); break;         case 'fit':    stroke.fit    = s1788(parse); break;         case 'join':   stroke.join   = s1788(parse); break;         case 'miter':  stroke.miter  = s1788(parse); break;         case 'cap':    stroke.cap    = s1788(parse); break;         case 'dashes': stroke.dashes = s1788(parse); break;         }     }               parse.y3742--;       b1791(parse, stroke);     return stroke; }    function t1675(parse) {     const stroke = s1788(parse);       if (    l1179.includes(stroke.type)         || m1176.includes(stroke.type))         stroke.data.weight = s1788(parse);      return stroke; }    function genParseStrokeSidesValue(parse) {     parse.pos++;       const sides = parse.move();      if (parse.settings.logRequests)          l2131(y1189, sides, parse);      return parseStrokeSidesValue(sides)[0]; }    function genParseStrokeSides(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const sides = new w2531(nodeId, options);      sides.g3362 = options.g3362;       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(sides, parse, ignore, k4301);       if (ignore)     {         b1791(parse, sides);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       let d3189;      if (k4301 == 1)     {         sides.input = s1788(parse);         d3189 = parse.move().split(',');     }     else         d3189 = ['top', 'left', 'right', 'bottom'];       parse.v1789 = false;      for (const id of d3189)     {         switch (id)         {         case 'top':    sides.top    = s1788(parse); break;         case 'left':   sides.left   = s1788(parse); break;         case 'right':  sides.right  = s1788(parse); break;         case 'bottom': sides.bottom = s1788(parse); break;         }     }               parse.y3742--;       b1791(parse, sides);     return sides; }    function x1676(parse) {     parse.pos++;       const corners = parse.move();      if (parse.settings.logRequests)          l2131(r1192, corners, parse);      return a3933(corners)[0]; }    function o1677(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const corners = new g1895(nodeId, options);      corners.g3362 = options.g3362;       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(corners, parse, ignore, k4301);       if (ignore)     {         b1791(parse, corners);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       let d3189;      if (k4301 == 1)     {         corners.input = s1788(parse);         d3189 = parse.move().split(',');     }     else         d3189 = ['tl', 'tr', 'bl', 'br'];       parse.v1789 = false;      for (const id of d3189)     {         switch (id)         {         case 'tl': corners.tl = s1788(parse); break;         case 'tr': corners.tr = s1788(parse); break;         case 'bl': corners.bl = s1788(parse); break;         case 'br': corners.br = s1788(parse); break;         }     }               parse.y3742--;       b1791(parse, corners);     return corners; }    function i1678(parse) {     parse.pos++;       const shadow = parse.move();      if (parse.settings.logRequests)          l2131(e1195, shadow, parse);      return j3928(shadow)[0]; }    function d1679(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const shadow = new x1888(nodeId, options);      shadow.g3362 = options.g3362;       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(shadow, parse, ignore, k4301);       if (ignore)     {         b1791(parse, shadow);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       let d3189;      if (k4301 == 1)     {         shadow.input = s1788(parse);         d3189 = parse.move().split(',');     }     else         d3189 = ['x', 'y', 'blur', 'spread', 'fill', 'blend', 'behind'];       parse.v1789 = false;      for (const id of d3189)     {         switch (id)         {         case 'x':      shadow.x      = s1788(parse); break;         case 'y':      shadow.y      = s1788(parse); break;         case 'blur':   shadow.blur   = s1788(parse); break;         case 'spread': shadow.spread = s1788(parse); break;         case 'fill':   shadow.fill   = s1788(parse); break;         case 'blend':  shadow.blend  = s1788(parse); break;         case 'behind': shadow.behind = s1788(parse); break;         }     }               parse.y3742--;       b1791(parse, shadow);     return shadow; }    function a1680(parse) {     parse.pos++;       const shadow = parse.move();      if (parse.settings.logRequests)          l2131(y1198, shadow, parse);      return r3929(shadow)[0]; }    function n1681(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const shadow = new k1891(nodeId, options);      shadow.g3362 = options.g3362;       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(shadow, parse, ignore, k4301);       if (ignore)     {         b1791(parse, shadow);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       let d3189;      if (k4301 == 1)     {         shadow.input = s1788(parse);         d3189 = parse.move().split(',');     }     else         d3189 = ['x', 'y', 'blur', 'spread', 'fill', 'blend'];       parse.v1789 = false;      for (const id of d3189)     {         switch (id)         {         case 'x':      shadow.x      = s1788(parse); break;         case 'y':      shadow.y      = s1788(parse); break;         case 'blur':   shadow.blur   = s1788(parse); break;         case 'spread': shadow.spread = s1788(parse); break;         case 'fill':   shadow.fill   = s1788(parse); break;         case 'blend':  shadow.blend  = s1788(parse); break;         }     }               parse.y3742--;       b1791(parse, shadow);     return shadow; }    function a1682(parse) {     parse.pos++;       const blur = parse.move();      if (parse.settings.logRequests)          l2131(w1201, blur, parse);      return z3930(blur)[0]; }    function j1683(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const blur = new c1893(nodeId, options);      blur.g3362 = options.g3362;       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(blur, parse, ignore, k4301);       if (ignore)     {         b1791(parse, blur);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       let d3189;      if (k4301 == 1)     {         blur.input = s1788(parse);         d3189 = parse.move().split(',');     }     else         d3189 = ['radius'];       parse.v1789 = false;      for (const id of d3189)     {         switch (id)         {         case 'radius': blur.radius = s1788(parse); break;         }     }               parse.y3742--;       b1791(parse, blur);     return blur; }    function y1684(parse) {     parse.pos++;       const blur = parse.move();      if (parse.settings.logRequests)          l2131(d1204, blur, parse);      return z3802(blur)[0]; }    function u1685(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const blur = new k1885(nodeId, options);      blur.g3362 = options.g3362;       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(blur, parse, ignore, k4301);       if (ignore)     {         b1791(parse, blur);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       let d3189;      if (k4301 == 1)     {         blur.input = s1788(parse);         d3189 = parse.move().split(',');     }     else         d3189 = ['radius'];       parse.v1789 = false;      for (const id of d3189)     {         switch (id)         {         case 'radius': blur.radius = s1788(parse); break;         }     }               parse.y3742--;       b1791(parse, blur);     return blur; }    function n1686(parse) {     parse.pos++;       const layer = parse.move();      if (parse.settings.logRequests)          l2131(d1210, layer, parse);      return q3803(layer)[0]; }    function a1687(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const layer = new h1892(nodeId, options);       if (parse.settings.logRequests)          r2124(layer, parse, ignore);       if (ignore)     {         b1791(parse, layer);         return parse.b4335.find(n => n.nodeId == nodeId);     }       layer.opacity = s1788(parse);     layer.blend   = s1788(parse);               b1791(parse, layer);     return layer; }    function i1688(parse) {     parse.pos++;       const mask = parse.move();      if (parse.settings.logRequests)          l2131(e1207, mask, parse);      return k3804(mask)[0]; }    function b1689(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const mask = new g1894(nodeId, options);       if (parse.settings.logRequests)          r2124(mask, parse, ignore);       if (ignore)     {         b1791(parse, mask);         return parse.b4335.find(n => n.nodeId == nodeId);     }       mask.maskType = s1788(parse);               b1791(parse, mask);     return mask; }


function t1691(parse) {     parse.pos++;       const val = parse.move();      if (parse.settings.logRequests)          l2131(c1090, val, parse);      return val.indexOf(',') >= 0          ? x2948      (val)[0]          : x3931(val)[0]; }    function a1692(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const num = new h1936(nodeId, options);           if (parse.settings.logRequests)          r2124(num, parse, ignore);       if (ignore)      {         b1791(parse, num);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;     parse.v1789 = false;       if (parse.next == c1090) num.value = s1788(parse);     else                            num.input = s1788(parse);       parse.y3742--;       b1791(parse, num);     return num; }    function genParseBoundedNumber(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const num = new b2628(nodeId, options);           if (parse.settings.logRequests)          r2124(num, parse, ignore);       if (ignore)      {         b1791(parse, num);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;     parse.v1789 = false;       if (parse.next == c1090) num.value = s1788(parse);     else                            num.input = s1788(parse);      num.min = s1788(parse);     num.max = s1788(parse);       parse.y3742--;       b1791(parse, num);     return num; }    function genParseBooleanNumber(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const bool = new w2606(nodeId, options);           if (parse.settings.logRequests)          r2124(bool, parse, ignore);       if (ignore)      {         b1791(parse, bool);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;     parse.v1789 = false;       if (parse.next == c1090) bool.value = s1788(parse);     else                            bool.input = s1788(parse);       parse.y3742--;       b1791(parse, bool);     return bool; }    function genParseSetPrecision(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const prec = new s2627(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(prec, parse, ignore, k4301);       if (ignore)      {         b1791(parse, prec);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         prec.input = s1788(parse);      prec.decimals = s1788(parse);           parse.y3742--;       b1791(parse, prec);     return prec; }    function v1693(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const u3769 = new u1927(nodeId, options);       if (parse.settings.logRequests)          r2124(u3769, parse, ignore);       if (ignore)      {         b1791(parse, u3769);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       u3769.constant = s1788(parse);       parse.y3742--;       b1791(parse, u3769);     return u3769; }    function p1694(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const dateTime = new e1929(nodeId, options);       if (parse.settings.logRequests)          r2124(dateTime, parse, ignore);       if (ignore)      {         b1791(parse, dateTime);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       dateTime.seconds   = s1788(parse);     dateTime.minutes   = s1788(parse);     dateTime.hours     = s1788(parse);     dateTime.dayOfWeek = s1788(parse);     dateTime.date      = s1788(parse);     dateTime.month     = s1788(parse);     dateTime.year      = s1788(parse);       parse.y3742--;       b1791(parse, dateTime);     return dateTime; }    function p1695(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const sign = new j1943(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(sign, parse, ignore);       if (ignore)      {         b1791(parse, sign);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         sign.input = s1788(parse);           parse.y3742--;       b1791(parse, sign);     return sign; }    function o1696(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const abs = new i1924(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(abs, parse, ignore);       if (ignore)      {         b1791(parse, abs);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         abs.input = s1788(parse);           parse.y3742--;       b1791(parse, abs);     return abs; }    function genParseNegative(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const neg = new k2619(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(neg, parse, ignore);       if (ignore)      {         b1791(parse, neg);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         neg.input = s1788(parse);           parse.y3742--;       b1791(parse, neg);     return neg; }    function j1697(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const round = new b1941(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(round, parse, ignore, k4301);       if (ignore)      {         b1791(parse, round);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         round.input = s1788(parse);      round.type     = s1788(parse);     round.decimals = s1788(parse);           parse.y3742--;       b1791(parse, round);     return round; }    function genParseQuantize(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const quant = new v2611(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(quant, parse, ignore, k4301);       if (ignore)      {         b1791(parse, quant);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         quant.input = s1788(parse);      quant.type   = s1788(parse);     quant.base   = s1788(parse);     quant.step   = s1788(parse);     quant.amount = s1788(parse);           parse.y3742--;       b1791(parse, quant);     return quant; }    function n1698(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const j3768 = new e1944(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(j3768, parse, ignore, k4301);       if (ignore)      {         b1791(parse, j3768);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         j3768.input = s1788(parse);      j3768.operand   = s1788(parse);     j3768.operation = s1788(parse);           parse.y3742--;       b1791(parse, j3768);     return j3768; }    function n1699(parse) {     const [type, nodeId, options, ignore] = d1790(parse);       const y3767 = new i1933(nodeId, options);           let k4301 = 0;          if (!ignore)         k4301 = parseInt(parse.move());       if (parse.settings.logRequests)          r2124(y3767, parse, ignore, k4301);       if (ignore)      {         b1791(parse, y3767);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;      for (let i = 0; i < k4301; i++)         y3767.inputs.push(s1788(parse));       y3767.operation = s1788(parse);       parse.y3742--;               b1791(parse, y3767);     return y3767; }    function x1700(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const limits = new i1932(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(limits, parse, ignore, k4301);       if (ignore)      {         b1791(parse, limits);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         limits.input = s1788(parse);      limits.min = s1788(parse);     limits.max = s1788(parse);           parse.y3742--;       b1791(parse, limits);     return limits; }    function m1701(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const curve = new b1937(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(curve, parse, ignore, k4301);       if (ignore)      {         b1791(parse, curve);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         curve.input = s1788(parse);      curve.min    = s1788(parse);     curve.max    = s1788(parse);     curve.power  = s1788(parse);           parse.y3742--;       b1791(parse, curve);     return curve; }    function genParseNumberMap(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const map = new k2603(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(map, parse, ignore, k4301);       if (ignore)      {         b1791(parse, map);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         map.input = s1788(parse);      map.from = s1788(parse);     map.to   = s1788(parse);           parse.y3742--;       b1791(parse, map);     return map; }    function genParseNumberBias(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const bias = new n2618(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(bias, parse, ignore, k4301);       if (ignore)      {         b1791(parse, bias);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         bias.input = s1788(parse);      bias.min    = s1788(parse);     bias.max    = s1788(parse);     bias.bias   = s1788(parse);     bias.spread = s1788(parse);           parse.y3742--;       b1791(parse, bias);     return bias; }    function genParseNumberIsNaN(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const z3766 = new d1934(nodeId, options);       let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(z3766, parse, ignore, k4301);       if (ignore)      {         b1791(parse, z3766);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         z3766.input = s1788(parse);       parse.y3742--;       b1791(parse, z3766);     return z3766; }    function w1703(parse, g1690) {     const [type, nodeId, options, ignore] = d1790(parse);       const math = g1690(nodeId, options);           let k4301 = 0;          if (!ignore)         k4301 = parseInt(parse.move());       if (parse.settings.logRequests)          r2124(math, parse, ignore, k4301);       if (ignore)      {         b1791(parse, math);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;      for (let i = 0; i < k4301; i++)         math.inputs.push(s1788(parse));       math.operation = s1788(parse);       parse.y3742--;               b1791(parse, math);     return math; }    function m1704(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const smath = new s1905(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(smath, parse, ignore, k4301);       if (ignore)      {         b1791(parse, smath);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         smath.input = s1788(parse);      smath.operation = s1788(parse);     smath.operand   = s1788(parse);     smath.invert    = s1788(parse);           parse.y3742--;       b1791(parse, smath);     return smath; }    function n1705(parse, g1690) {     const [type, nodeId, options, ignore] = d1790(parse);       const arith = g1690(nodeId, options);       let k4301 = 0;          if (!ignore)         k4301 = parseInt(parse.move());       if (parse.settings.logRequests)          r2124(arith, parse, ignore, k4301);       if (ignore)      {         b1791(parse, arith);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;      for (let i = 0; i < k4301; i++)         arith.inputs.push(s1788(parse));      parse.y3742--;               b1791(parse, arith);     return arith; }    function z1706(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const convert = new f1928(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(convert, parse, ignore, k4301);       if (ignore)      {         b1791(parse, convert);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         convert.input = s1788(parse);      convert.from = s1788(parse);           parse.y3742--;       b1791(parse, convert);     return convert; }    function genParseIterate(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const define = new o1930(nodeId, options);       let k4301 = 0;          if (!ignore)         k4301 = parseInt(parse.move());       if (parse.settings.logRequests)          r2124(define, parse, ignore, k4301);       if (ignore)      {         b1791(parse, define);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;           for (let i = 0; i < k4301; i++)         define.inputs.push(s1788(parse));       parse.y3742--;       b1791(parse, define);     return define; }    function i1708(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const dist = new b1940(nodeId, options);       if (parse.settings.logRequests)          r2124(dist, parse, ignore);       if (ignore)      {         b1791(parse, dist);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       dist.from   = s1788(parse);     dist.start  = s1788(parse);     dist.end    = s1788(parse);       parse.y3742--;       b1791(parse, dist);     return dist; }    function j1709(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const wave = new i1946(nodeId, options);       if (parse.settings.logRequests)          r2124(wave, parse, ignore);       if (ignore)      {         b1791(parse, wave);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       wave.shape     = s1788(parse);     wave.base      = s1788(parse);     wave.amplitude = s1788(parse);     wave.frequency = s1788(parse);     wave.offset    = s1788(parse);     wave.bias      = s1788(parse);       wave.useWavelength  = parseInt(parse.move()) > 0;     wave.offsetAbsolute = parseInt(parse.move()) > 0;       parse.y3742--;       b1791(parse, wave);     return wave; }    function w1710(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const seq = new z1942(nodeId, options);       if (parse.settings.logRequests)          r2124(seq, parse, ignore);       if (ignore)      {         b1791(parse, seq);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       seq.start    = s1788(parse);     seq.multiply = s1788(parse);     seq.add      = s1788(parse);     seq.end      = s1788(parse);       parse.y3742--;       b1791(parse, seq);     return seq; }    function l1711(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const rnd = new y1939(nodeId, options);       if (parse.settings.logRequests)          r2124(rnd, parse, ignore);       if (ignore)      {         b1791(parse, rnd);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       rnd.seed      = s1788(parse);     rnd.iteration = s1788(parse);     rnd.min       = s1788(parse);     rnd.max       = s1788(parse);     rnd.bias      = s1788(parse);     rnd.spread    = s1788(parse);     rnd.unique    = s1788(parse);       parse.y3742--;       b1791(parse, rnd);     return rnd; }    function z1712(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const noise = new i1935(nodeId, options);       if (parse.settings.logRequests)          r2124(noise, parse, ignore);       if (ignore)      {         b1791(parse, noise);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       noise.seed        = s1788(parse);     noise.iteration   = s1788(parse);     noise.min         = s1788(parse);     noise.max         = s1788(parse);     noise.scale       = s1788(parse);     noise.offset      = s1788(parse);     noise.evolve      = s1788(parse);     noise.interpolate = s1788(parse);     noise.detail      = s1788(parse);       parse.y3742--;       b1791(parse, noise);     return noise; }    function p1713(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const prob = new y1938(nodeId, options);       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 2, 'nInputs must be [0, 2]');     }       const n3777 =          k4301 == 1         ? parseInt(parse.move())         : -1;       if (parse.settings.logRequests)          r2124(prob, parse, ignore, k4301);       if (ignore)      {         b1791(parse, prob);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 2)     {         prob.o4175   = s1788(parse);         prob.i4176   = s1788(parse);     }     else if (k4301 == 1)     {              if (n3777 == 0) prob.o4175 = s1788(parse);          else if (n3777 == 1) prob.i4176 = s1788(parse);      }       prob.seed      = s1788(parse);     prob.iteration = s1788(parse);     prob.chance    = s1788(parse);     prob.alternate = s1788(parse);       parse.y3742--;       b1791(parse, prob);     return prob; }    function q1714(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const accum = new a1925(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(accum, parse, ignore, k4301);       if (ignore)      {         b1791(parse, accum);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         accum.input = s1788(parse);      accum.when = s1788(parse);               parse.y3742--;       b1791(parse, accum);     return accum; }    function genParseHold(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const hold = new GHold(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(hold, parse, ignore, k4301);       if (ignore)      {         b1791(parse, hold);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         hold.input = s1788(parse);      hold.first = s1788(parse);               parse.y3742--;       b1791(parse, hold);     return hold; }    function o1715(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const q1033 = new o1931(nodeId, options);       let k4301 = 0;          if (!ignore)         k4301 = parseInt(parse.move());       if (parse.settings.logRequests)          r2124(q1033, parse, ignore, k4301);       if (ignore)      {         b1791(parse, q1033);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;      for (let i = 0; i < k4301; i++)         q1033.inputs.push(s1788(parse));       q1033.amount = s1788(parse);     q1033.degree = s1788(parse);       parse.y3742--;       b1791(parse, q1033);     return q1033; }    function p1716(parse) {     const [type, nodeId, options, ignore] = d1790(parse);       const bool = new m1908(nodeId, options);           let k4301 = 0;          if (!ignore)         k4301 = parseInt(parse.move());       if (parse.settings.logRequests)          r2124(bool, parse, ignore, k4301);       if (ignore)      {         b1791(parse, bool);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;      for (let i = 0; i < k4301; i++)         bool.inputs.push(s1788(parse));       bool.operation = s1788(parse);       parse.y3742--;               b1791(parse, bool);     return bool; }    function genParseCompare(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const cmp = new b1912(nodeId, options);       let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(cmp, parse, ignore, k4301);       if (ignore)      {         b1791(parse, cmp);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         cmp.input = s1788(parse);             cmp.operation = s1788(parse);     cmp.operand   = s1788(parse);       parse.y3742--;       b1791(parse, cmp);     return cmp; }    function y1718(parse, g1690) {     const [type, nodeId, options, ignore] = d1790(parse);       const cond = g1690(nodeId, options);       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.logRequests)         r2124(cond, parse, ignore, k4301);        if (ignore)      {         b1791(parse, cond);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;      if (k4301 == 2)     {         cond.o4175 = s1788(parse);         cond.i4176 = s1788(parse);     }     else if (k4301 == 1)     {         cond.o4175 = s1788(parse);      }      parse.y3742--;       b1791(parse, cond);     return cond; }    function f1719(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const trig = new x1923(nodeId, options);       let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(trig, parse, ignore, k4301);       if (ignore)      {         b1791(parse, trig);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         trig.input = s1788(parse);      trig.function = s1788(parse);      parse.y3742--;       b1791(parse, trig);     return trig; }    function k1720(parse, g1690) {     const [type, nodeId, options, ignore] = d1790(parse);       const trig = g1690(nodeId, options);       let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)         r2124(trig, parse, ignore, k4301);        if (ignore)      {         b1791(parse, trig);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         trig.input = s1788(parse);       parse.y3742--;       b1791(parse, trig);     return trig; }    function m1721(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const atan2 = new g1919(nodeId, options);              if (parse.settings.logRequests)          r2124(atan2, parse, ignore);       if (ignore)      {         b1791(parse, atan2);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       atan2.x = s1788(parse);     atan2.y = s1788(parse);           parse.y3742--;       b1791(parse, atan2);     return atan2; }    function c1722(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const solve = new e1945(nodeId, options);          let nTerminals = -1;      nTerminals = parseInt(parse.move());     c950(nTerminals >= 0, 'nTerminals must be >= 0');      for (let i = 0; i < nTerminals; i++)         solve.terminalIds.push(parse.move());       solve.currentConnected = parseInt(parse.move()) > 0;       let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          logReqSolve(solve, parse, ignore, k4301);       if (ignore)      {         b1791(parse, solve);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         solve.input = s1788(parse);           solve.current = s1788(parse);     solve.target  = s1788(parse);           parse.y3742--;       b1791(parse, solve);     return solve; }    function q1723(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const anim = new j1926(nodeId, options);       if (parse.settings.logRequests)          r2124(anim, parse);       if (ignore)      {         b1791(parse, anim);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       anim.from   = s1788(parse);     anim.to     = s1788(parse);     anim.curve  = s1788(parse);     anim.repeat = s1788(parse);     anim.length = s1788(parse);     anim.time   = s1788(parse);       parse.y3742--;       b1791(parse, anim);     return anim; } 


function o1724(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const rect = new r1969(nodeId, options);       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(rect, parse, ignore);       if (ignore)      {         b1791(parse, rect);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         rect.input = s1788(parse);       const k3763 = b1793(parse);      for (let i = 0; i < k3763; i++)     {         const m3091 = k1795(parse);          parse.v1789 = true;          switch (m3091)         {         case 'x':      rect.x      = s1788(parse); break;         case 'y':      rect.y      = s1788(parse); break;         case 'width':  rect.width  = s1788(parse); break;         case 'height': rect.height = s1788(parse); break;         case 'round':  rect.round  = s1788(parse); break;         case 'props':  rect.props  = s1788(parse); break;         }     }       parse.v1789 = false;     parse.y3742--;       b1791(parse, rect);     return rect; }                                                                     function r1725(parse) {     const [, nodeId, options, ignore] = d1790(parse);         const line = new i1960(nodeId, options);       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(line, parse, ignore);       if (ignore)      {         b1791(parse, line);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         line.input = s1788(parse);       const k3763 = b1793(parse);      for (let i = 0; i < k3763; i++)     {         const m3091 = k1795(parse);          parse.v1789 = true;          switch (m3091)         {         case 'x':     line.x     = s1788(parse); break;         case 'y':     line.y     = s1788(parse); break;         case 'width': line.width = s1788(parse); break;         case 'props': line.props = s1788(parse); break;         }     }       parse.v1789 = false;     parse.y3742--;       b1791(parse, line);     return line; }    function i1726(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const ellipse = new q1956(nodeId, options);       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(ellipse, parse, ignore);       if (ignore)      {         b1791(parse, ellipse);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         ellipse.input = s1788(parse);       const k3763 = b1793(parse);      for (let i = 0; i < k3763; i++)     {         const m3091 = k1795(parse);          parse.v1789 = true;          switch (m3091)         {         case 'position': ellipse.position = s1788(parse); break;         case 'x':        ellipse.x        = s1788(parse); break;         case 'y':        ellipse.y        = s1788(parse); break;         case 'width':    ellipse.width    = s1788(parse); break;         case 'height':   ellipse.height   = s1788(parse); break;         case 'round':    ellipse.round    = s1788(parse); break;         case 'start':    ellipse.start    = s1788(parse); break;         case 'sweep':    ellipse.sweep    = s1788(parse); break;         case 'inner':    ellipse.inner    = s1788(parse); break;         case 'props':    ellipse.props    = s1788(parse); break;         }     }               ellipse.innerAbsolute  = parseInt(parse.move()) > 0;     ellipse.startInDegrees = parseInt(parse.move()) > 0;     ellipse.sweepInDegrees = parseInt(parse.move()) > 0;       parse.v1789 = false;     parse.y3742--;       b1791(parse, ellipse);     return ellipse; }    function o1727(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const trapeze = new s1980(nodeId, options);       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(trapeze, parse, ignore);       if (ignore)      {         b1791(parse, trapeze);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         trapeze.input = s1788(parse);       const k3763 = b1793(parse);      for (let i = 0; i < k3763; i++)     {         const m3091 = k1795(parse);          parse.v1789 = true;          switch (m3091)         {         case 'x':      trapeze.x      = s1788(parse); break;         case 'y':      trapeze.y      = s1788(parse); break;         case 'width':  trapeze.width  = s1788(parse); break;         case 'height': trapeze.height = s1788(parse); break;         case 'round':  trapeze.round  = s1788(parse); break;         case 'bias':   trapeze.bias   = s1788(parse); break;         case 'props':  trapeze.props  = s1788(parse); break;         }     }               parse.v1789 = false;     parse.y3742--;       b1791(parse, trapeze);     return trapeze; }    function n1728(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const poly = new u1968(nodeId, options);       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(poly, parse, ignore);       if (ignore)      {         b1791(parse, poly);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         poly.input = s1788(parse);       const k3763 = b1793(parse);      for (let i = 0; i < k3763; i++)     {         const m3091 = k1795(parse);          parse.v1789 = true;          switch (m3091)         {         case 'position': poly.position = s1788(parse); break;         case 'x':        poly.x        = s1788(parse); break;         case 'y':        poly.y        = s1788(parse); break;         case 'width':    poly.width    = s1788(parse); break;         case 'height':   poly.height   = s1788(parse); break;         case 'round':    poly.round    = s1788(parse); break;         case 'corners':  poly.corners  = s1788(parse); break;         case 'props':    poly.props    = s1788(parse); break;         }     }               parse.v1789 = false;     parse.y3742--;       b1791(parse, poly);     return poly; }    function u1729(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const star = new t1978(nodeId, options);       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(star, parse, ignore);       if (ignore)      {         b1791(parse, star);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         star.input = s1788(parse);       const k3763 = b1793(parse);      for (let i = 0; i < k3763; i++)     {         const m3091 = k1795(parse);          parse.v1789 = true;          switch (m3091)         {         case 'position': star.position = s1788(parse); break;         case 'x':        star.x        = s1788(parse); break;         case 'y':        star.y        = s1788(parse); break;         case 'width':    star.width    = s1788(parse); break;         case 'height':   star.height   = s1788(parse); break;         case 'round':    star.round    = s1788(parse); break;         case 'points':   star.points   = s1788(parse); break;         case 'convex':   star.convex   = s1788(parse); break;         case 'props':    star.props    = s1788(parse); break;         }     }               parse.v1789 = false;     parse.y3742--;       b1791(parse, star);     return star; }    function e1730(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const text = new e1979(nodeId, options);       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(text, parse, ignore);       if (ignore)      {         b1791(parse, text);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         text.input = s1788(parse);       const k3763 = b1793(parse);      for (let i = 0; i < k3763; i++)     {         const m3091 = k1795(parse);          parse.v1789 = true;          switch (m3091)         {                case 'text':          text.text          = s1788(parse); break;         case 'x':             text.x             = s1788(parse); break;         case 'y':             text.y             = s1788(parse); break;         case 'width':         text.width         = s1788(parse); break;         case 'height':        text.height        = s1788(parse); break;         case 'font':          text.font          = s1788(parse); break;         case 'size':          text.size          = s1788(parse); break;         case 'style':         text.style         = s1788(parse); break;         case 'props':         text.props         = s1788(parse); break;         case 'alignX':        text.alignX        = s1788(parse); break;         case 'alignY':        text.alignY        = s1788(parse); break;         case 'lineHeight':    text.lineHeight    = s1788(parse); break;         case 'letterSpacing': text.letterSpacing = s1788(parse); break;         }     }       parse.v1789 = false;     parse.y3742--;       b1791(parse, text);     return text; }    function n1731(parse) {     parse.pos++;       const point = parse.move();      if (parse.settings.logRequests)          l2131(v1244, point, parse);      return f3923(point)[0]; }    function b1732(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const point = new z1964(nodeId, options);       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(point, parse, ignore);       if (ignore)      {         b1791(parse, point);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         point.input = s1788(parse);       const k3763 = b1793(parse);      for (let i = 0; i < k3763; i++)     {         const m3091 = k1795(parse);          parse.v1789 = true;          switch (m3091)         {         case 'x': point.x = s1788(parse); break;         case 'y': point.y = s1788(parse); break;         }     }       parse.v1789 = false;     parse.y3742--;       b1791(parse, point);     return point; }    function v1733(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const corner = new q1965(nodeId, options);       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(corner, parse, ignore);       if (ignore)      {         b1791(parse, corner);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         corner.input = s1788(parse);      corner.smooth = s1788(parse);       parse.v1789 = false;     parse.y3742--;       b1791(parse, corner);     return corner; }    function g1734(parse) {     parse.pos++;       const path = parse.move();      if (parse.settings.logRequests)          l2131(q1248, path, parse);      return f3765(path)[0]; }    function n1735(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const path = new l1984(nodeId, options);       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(path, parse, ignore);       if (ignore)      {         b1791(parse, path);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         path.input = s1788(parse);       const k3763 = b1793(parse);      for (let i = 0; i < k3763; i++)     {         const m3091 = k1795(parse);          parse.v1789 = true;          switch (m3091)         {                case 'points':  path.points  = s1788(parse); break;         case 'closed':  path.closed  = s1788(parse); break;         case 'degree':  path.degree  = s1788(parse); break;         case 'winding': path.winding = s1788(parse); break;         case 'round':   path.round   = s1788(parse); break;         case 'props':   path.props   = s1788(parse); break;         }     }       parse.v1789 = false;     parse.y3742--;       b1791(parse, path);     return path; }    function genParsePathLength(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const len = new y2595(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(len, parse, ignore, k4301);       if (ignore)      {         b1791(parse, len);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         len.input = s1788(parse);           parse.y3742--;       b1791(parse, len);     return len; }    function genParseJoinPaths(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const join = new z2544(nodeId, options);       let k4301 = 0;          if (!ignore)         k4301 = parseInt(parse.move());       if (parse.settings.logRequests)          r2124(join, parse, ignore, k4301);       if (ignore)      {         b1791(parse, join);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       for (let i = 0; i < k4301; i++)         join.inputs.push(s1788(parse));       const k3763 = b1793(parse);      for (let i = 0; i < k3763; i++)     {         const m3091 = k1795(parse);          parse.v1789 = true;          switch (m3091)         {                case 'closed':  join.closed  = s1788(parse); break;         case 'degree':  join.degree  = s1788(parse); break;         case 'winding': join.winding = s1788(parse); break;         case 'round':   join.round   = s1788(parse); break;         case 'props':   join.props   = s1788(parse); break;         }     }       parse.v1789 = false;     parse.y3742--;       b1791(parse, join);     return join; }    function genParseReorientPaths(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const reorient = new e2539(nodeId, options);       let k4301 = 0;          if (!ignore)         k4301 = parseInt(parse.move());       if (parse.settings.logRequests)          r2124(reorient, parse, ignore, k4301);       if (ignore)      {         b1791(parse, reorient);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       for (let i = 0; i < k4301; i++)         reorient.inputs.push(s1788(parse));       reorient.reverse = s1788(parse);                   parse.v1789 = false;     parse.y3742--;       b1791(parse, reorient);     return reorient; }    function z1736(parse) {     parse.pos++;       const point = parse.move();      if (parse.settings.logRequests)          l2131(s1251, point, parse);      return m3764(point)[0]; }    function e1737(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const point = new r1986(nodeId, options);       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(point, parse, ignore);       if (ignore)      {         b1791(parse, point);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         point.input = s1788(parse);       const k3763 = b1793(parse);      for (let i = 0; i < k3763; i++)     {         const m3091 = k1795(parse);          parse.v1789 = true;          switch (m3091)         {         case 'x':     point.x     = s1788(parse); break;         case 'y':     point.y     = s1788(parse); break;         case 'join':  point.join  = s1788(parse); break;         case 'cap':   point.cap   = s1788(parse); break;         case 'round': point.round = s1788(parse); break;         }     }       parse.v1789 = false;     parse.y3742--;       b1791(parse, point);     return point; }    function w1738(parse) {     parse.pos++;       const edge = parse.move();      if (parse.settings.logRequests)          l2131(p1254, edge, parse);      return c3762(edge)[0]; }    function k1739(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const edge = new z1981(nodeId, options);       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.logRequests)          r2124(edge, parse, ignore, k4301);       if (ignore)      {         b1791(parse, edge);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 2)     {         edge.o4175 = s1788(parse);         edge.i4176 = s1788(parse);     }     else if (k4301 == 1)     {         edge.o4175 = s1788(parse);      }       edge.z3760 = s1788(parse);     edge.  f3761 = s1788(parse);       parse.v1789 = false;     parse.y3742--;       b1791(parse, edge);     return edge; }    function u1740(parse) {     parse.pos++;       const region = parse.move();      if (parse.settings.logRequests)          l2131(x1257, region, parse);      return f3759(region)[0]; }    function p1741(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const region = new f1985(nodeId, options);       let k4301 = 0;          if (!ignore)         k4301 = parseInt(parse.move());       if (parse.settings.logRequests)          r2124(region, parse, ignore, k4301);       if (ignore)      {         b1791(parse, region);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       for (let i = 0; i < k4301; i++)         region.inputs.push(s1788(parse));       region.winding = s1788(parse);     region.props   = s1788(parse);       parse.v1789 = false;     parse.y3742--;       b1791(parse, region);     return region; }    function s1742(parse) {     parse.pos++;       const region = parse.move();      if (parse.settings.logRequests)          l2131(i1260, region, parse);      return c3758(region)[0]; }    function y1743(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const network = new r1983(nodeId, options);       let k4301 = 0;          if (!ignore)         k4301 = parseInt(parse.move());       if (parse.settings.logRequests)          r2124(network, parse, ignore, k4301);       if (ignore)      {         b1791(parse, network);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       for (let i = 0; i < k4301; i++)         network.inputs.push(s1788(parse));      network.props = s1788(parse);       parse.y3742--;        b1791(parse, network);     return network; }    function f1744(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const bool = new j1947(nodeId, options);       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(bool, parse, ignore);       if (ignore)      {         b1791(parse, bool);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         bool.input = s1788(parse);       const k3763 = b1793(parse);      for (let i = 0; i < k3763; i++)     {         const m3091 = k1795(parse);          parse.v1789 = true;          switch (m3091)         {         case 'children':  bool.children  = s1788(parse); break;         case 'operation': bool.operation = s1788(parse); break;         case 'props':     bool.props     = s1788(parse); break;         }     }       parse.v1789 = false;     parse.y3742--;       b1791(parse, bool);     return bool; }    function genParseArcPath(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const arc = new z2535(nodeId, options);       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(arc, parse, ignore);       if (ignore)      {         b1791(parse, arc);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         arc.input = s1788(parse);       const k3763 = b1793(parse);      for (let i = 0; i < k3763; i++)     {         const m3091 = k1795(parse);          parse.v1789 = true;          switch (m3091)         {         case 'position': arc.position = s1788(parse); break;         case 'x':        arc.x        = s1788(parse); break;         case 'y':        arc.y        = s1788(parse); break;         case 'width':    arc.width    = s1788(parse); break;         case 'height':   arc.height   = s1788(parse); break;         case 'start':    arc.start    = s1788(parse); break;         case 'sweep':    arc.sweep    = s1788(parse); break;         case 'props':    arc.props    = s1788(parse); break;         }     }               arc.startInDegrees = parseInt(parse.move()) > 0;     arc.sweepInDegrees = parseInt(parse.move()) > 0;       parse.v1789 = false;     parse.y3742--;       b1791(parse, arc);     return arc; }    function genParseWavePath(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const wave = new c2600(nodeId, options);       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(wave, parse, ignore);       if (ignore)      {         b1791(parse, wave);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         wave.input = s1788(parse);       const k3763 = b1793(parse);      for (let i = 0; i < k3763; i++)     {         const m3091 = k1795(parse);          parse.v1789 = true;          switch (m3091)         {         case 'shape':     wave.shape     = s1788(parse); break;         case 'x':         wave.x         = s1788(parse); break;         case 'y':         wave.y         = s1788(parse); break;         case 'width':     wave.width     = s1788(parse); break;         case 'amplitude': wave.amplitude = s1788(parse); break;         case 'frequency': wave.frequency = s1788(parse); break;         case 'offset':    wave.offset    = s1788(parse); break;         case 'alignX':    wave.alignX    = s1788(parse); break;         case 'alignY':    wave.alignY    = s1788(parse); break;         case 'props':     wave.props     = s1788(parse); break;         }     }               wave.useWavelength  = parseInt(parse.move()) > 0;     wave.offsetAbsolute = parseInt(parse.move()) > 0;       parse.v1789 = false;     parse.y3742--;       b1791(parse, wave);     return wave; }    function v1745(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const group = new l1976(nodeId, options);       let k4301 = 0;          if (!ignore)         k4301 = parseInt(parse.move());       if (parse.settings.logRequests)          r2124(group, parse, ignore, k4301);       if (ignore)      {         b1791(parse, group);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       for (let i = 0; i < k4301; i++)         group.inputs.push(s1788(parse));       parse.y3742--;       b1791(parse, group);     return group; }    function t1746(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const frame = new c1957(nodeId, options);       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(frame, parse, ignore);       if (ignore)      {         b1791(parse, frame);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         frame.input = s1788(parse);       const k3763 = b1793(parse);      for (let i = 0; i < k3763; i++)     {         const m3091 = k1795(parse);          parse.v1789 = true;          switch (m3091)         {         case 'children': frame.children = s1788(parse); break;         case 'position': frame.position = s1788(parse); break;         case 'x':        frame.x        = s1788(parse); break;         case 'y':        frame.y        = s1788(parse); break;         case 'width':    frame.width    = s1788(parse); break;         case 'height':   frame.height   = s1788(parse); break;         case 'round':    frame.round    = s1788(parse); break;         case 'clip':     frame.clip     = s1788(parse); break;         case 'props':    frame.props    = s1788(parse); break;         }     }       parse.v1789 = false;     parse.y3742--;       b1791(parse, frame);     return frame; }    function k1747(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const move = new u1962(nodeId, options);       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(move, parse, ignore);       if (ignore)      {         b1791(parse, move);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         move.input = s1788(parse);      move.a3757    = s1788(parse);     move.x           = s1788(parse);     move.y           = s1788(parse);     move.affectSpace = s1788(parse);       parse.v1789 = false;     parse.y3742--;       b1791(parse, move);     return move; }    function e1748(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const rotate = new h1972(nodeId, options);       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(rotate, parse, ignore);       if (ignore)      {         b1791(parse, rotate);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         rotate.input = s1788(parse);      rotate.angle       = s1788(parse);     rotate.affectSpace = s1788(parse);           parse.v1789 = false;     parse.y3742--;       b1791(parse, rotate);     return rotate; }    function a1749(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const scale = new g1973(nodeId, options);       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(scale, parse, ignore);       if (ignore)      {         b1791(parse, scale);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         scale.input = s1788(parse);      scale.scaleX        = s1788(parse);     scale.scaleY        = s1788(parse);     scale.affectCorners = s1788(parse);     scale.affectStyle   = s1788(parse);     scale.affectSpace   = s1788(parse);           parse.v1789 = false;     parse.y3742--;       b1791(parse, scale);     return scale; }    function a1750(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const skew = new q1977(nodeId, options);       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(skew, parse, ignore);       if (ignore)      {         b1791(parse, skew);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         skew.input = s1788(parse);      skew.skewX       = s1788(parse);     skew.skewY       = s1788(parse);     skew.affectSpace = s1788(parse);       parse.v1789 = false;     parse.y3742--;       b1791(parse, skew);     return skew; }    function genParseShowCenter(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const showCenter = new k2550(nodeId, options);       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(showCenter, parse, ignore);       if (ignore)      {         b1791(parse, showCenter);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         showCenter.input = s1788(parse);      showCenter.show = s1788(parse);       parse.v1789 = false;     parse.y3742--;       b1791(parse, showCenter);     return showCenter; }    function v1751(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const center = new a1954(nodeId, options);       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(center, parse, ignore);       if (ignore)      {         b1791(parse, center);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         center.input = s1788(parse);      center.centerX    = s1788(parse);     center.centerY    = s1788(parse);     center.units      = s1788(parse);       parse.v1789 = false;     parse.y3742--;       b1791(parse, center);     return center; }    function l1752(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const reset = new l1971(nodeId, options);       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(reset, parse, ignore);       if (ignore)      {         b1791(parse, reset);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         reset.input = s1788(parse);       parse.y3742--;       b1791(parse, reset);     return reset; }    function h1753(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const measure = new n1961(nodeId, options);       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(measure, parse, ignore, k4301);       if (ignore)      {         b1791(parse, measure);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;           if (k4301 == 1)         measure.input = s1788(parse);                 parse.y3742--;       b1791(parse, measure);     return measure; }    function d1754(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const angle = new n2573(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(angle, parse, ignore, k4301);       if (ignore)      {         b1791(parse, angle);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         angle.input = s1788(parse);           parse.y3742--;       b1791(parse, angle);     return angle; }    function k1755(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const vector = new s1982(nodeId, options);       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.logRequests)          r2124(vector, parse, ignore, k4301);       if (ignore)      {         b1791(parse, vector);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;           if (k4301 == 2)     {         vector.o4175 = s1788(parse);         vector.i4176 = s1788(parse);     }     else if (k4301 == 1)     {         vector.o4175 = s1788(parse);      }       vector.transform  = s1788(parse);       parse.y3742--;       b1791(parse, vector);     return vector; }    function k1756(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const center = new o1955(nodeId, options);       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 3, 'nInputs must be [0, 3]');     }           if (parse.settings.logRequests)          r2124(center, parse, ignore, k4301);       if (ignore)      {         b1791(parse, center);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;           if (k4301 == 3)     {         center.o4175 = s1788(parse);         center.i4176 = s1788(parse);         center.z4177 = s1788(parse);     }     else if (k4301 == 2)     {         center.o4175 = s1788(parse);         center.i4176 = s1788(parse);     }     else if (k4301 == 1)     {         center.o4175 = s1788(parse);     }       parse.y3742--;       b1791(parse, center);     return center; }    function genParseArcFromPoints(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const arc = new j2593(nodeId, options);       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 3, 'nInputs must be [0, 3]');     }           if (parse.settings.logRequests)          r2124(arc, parse, ignore, k4301);       if (ignore)      {         b1791(parse, arc);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;           if (k4301 == 3)     {         arc.o4175 = s1788(parse);         arc.i4176 = s1788(parse);         arc.z4177 = s1788(parse);     }     else if (k4301 == 2)     {         arc.o4175 = s1788(parse);         arc.i4176 = s1788(parse);     }     else if (k4301 == 1)     {         arc.o4175 = s1788(parse);     }       const k3763 = b1793(parse);      for (let i = 0; i < k3763; i++)     {         const m3091 = k1795(parse);          parse.v1789 = true;          switch (m3091)         {                case 'props':   arc.props   = s1788(parse); break;         }     }       parse.v1789 = false;     parse.y3742--;       b1791(parse, arc);     return arc; }    function x1757(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const inter = new l1959(nodeId, options);       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 4, 'nInputs must be [0, 4]');     }           if (parse.settings.logRequests)          r2124(inter, parse, ignore, k4301);       if (ignore)      {         b1791(parse, inter);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;           if (k4301 == 4)     {         inter.o4175 = s1788(parse);         inter.i4176 = s1788(parse);         inter.z4177 = s1788(parse);         inter.k4178 = s1788(parse);     }     else if (k4301 == 3)     {         inter.o4175 = s1788(parse);         inter.i4176 = s1788(parse);         inter.z4177 = s1788(parse);     }     else if (k4301 == 2)     {         inter.o4175 = s1788(parse);         inter.i4176 = s1788(parse);     }     else if (k4301 == 1)     {         inter.o4175 = s1788(parse);     }       inter.segment = s1788(parse);       parse.y3742--;       b1791(parse, inter);     return inter; }    function h1758(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const q1033 = new g1958(nodeId, options);       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.logRequests)          r2124(q1033, parse, ignore, k4301);       if (ignore)      {         b1791(parse, q1033);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 2)     {         q1033.o4175 = s1788(parse);         q1033.i4176 = s1788(parse);     }     else if (k4301 == 1)     {         q1033.o4175 = s1788(parse);      }       q1033.amount     = s1788(parse);     q1033.transform  = s1788(parse);       parse.y3742--;       b1791(parse, q1033);     return q1033; }    function genParsePointAlongPath(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const pap = new s1966(nodeId, options);       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(pap, parse, ignore, k4301);       if (ignore)      {         b1791(parse, pap);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         pap.input = s1788(parse);        pap.position   = s1788(parse);     pap.distance   = s1788(parse);     pap.offset     = s1788(parse);     pap.transform  = s1788(parse);       parse.y3742--;       b1791(parse, pap);     return pap; }    function genParseClosestPointOnPath(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const cpop = new t1967(nodeId, options);       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.logRequests)          r2124(cpop, parse, ignore, k4301);       if (ignore)      {         b1791(parse, cpop);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 2)     {         cpop.o4175 = s1788(parse);         cpop.i4176 = s1788(parse);     }     else if (k4301 == 1)     {         cpop.o4175 = s1788(parse);      }       cpop.constrain  = s1788(parse);     cpop.transform  = s1788(parse);       parse.y3742--;       b1791(parse, cpop);     return cpop; }    function genParseReversePath(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const reverse = new d2596(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(reverse, parse, ignore, k4301);       if (ignore)      {         b1791(parse, reverse);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         reverse.input = s1788(parse);             parse.y3742--;       b1791(parse, reverse);     return reverse; }    function genParseBlendPath(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const blend = new c2572(nodeId, options);          let k4301 = 0;          if (!ignore)         k4301 = parseInt(parse.move());       if (parse.settings.logRequests)          r2124(blend, parse, ignore, k4301);       if (ignore)      {         b1791(parse, blend);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;           for (let i = 0; i < k4301; i++)         blend.inputs.push(s1788(parse));       blend.amount = s1788(parse);     blend.degree = s1788(parse);             parse.y3742--;       b1791(parse, blend);     return blend; }    function f1760(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const place = new h1963(nodeId, options);       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(place, parse, ignore);       if (ignore)      {         b1791(parse, place);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         place.input = s1788(parse);      place.position   = s1788(parse);     place.transform  = s1788(parse);       parse.v1789 = false;     parse.y3742--;       b1791(parse, place);     return place; }    function k1761(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const apply = new m1953(nodeId, options);       let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(apply, parse, ignore);       if (ignore)      {         b1791(parse, apply);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         apply.input = s1788(parse);      apply.props   = s1788(parse);     apply.replace = s1788(parse);       parse.v1789 = false;     parse.y3742--;       b1791(parse, apply);     return apply; }    function k1762(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const retain = new l1970(nodeId, options);       let k4301 = 0;          if (!ignore)         k4301 = parseInt(parse.move());       if (parse.settings.logRequests)          r2124(retain, parse, ignore, k4301);       if (ignore)      {         b1791(parse, retain);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       for (let i = 0; i < k4301; i++)         retain.inputs.push(s1788(parse));      retain.retain  = s1788(parse);     retain.finalize = s1788(parse);       parse.y3742--;       b1791(parse, retain);     return retain; }    function genParseExport(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const _export = new n2533(nodeId, options);       let k4301 = 0;          if (!ignore)         k4301 = parseInt(parse.move());       if (parse.settings.logRequests)          r2124(_export, parse, ignore, k4301);       if (ignore)      {         b1791(parse, _export);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       for (let i = 0; i < k4301; i++)         _export.inputs.push(s1788(parse));      _export.scale    = s1788(parse);     _export.format   = s1788(parse);         _export.suffix   = s1788(parse);     _export.profile  = s1788(parse);       parse.y3742--;       b1791(parse, _export);     return _export; }


              function n1763(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const style = new l1887(nodeId, options);      style.existing = options.existing;       if (parse.settings.logRequests)          r2124(style, parse, ignore);       if (ignore)      {         b1791(parse, style);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;     parse.v1789 = false;       style.id       = parse.move();     style.name     = options.nodeName;          style.r2916 = s1788(parse);           parse.y3742--;           style.linked = style.id != NULL;       b1791(parse, style);     return style; }                             


 function f1764(parse) {     parse.pos++;       const val = parse.move();      if (parse.settings.logRequests)          l2131(h1142, val, parse);      return e2963(val)[0]; }    function i1765(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const text = new u1992(nodeId, options);           if (parse.settings.logRequests)          r2124(text, parse, ignore);       if (ignore)      {         b1791(parse, text);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;     parse.v1789 = false;       if (parse.next == h1142) text.value = s1788(parse);     else                          text.input = s1788(parse);       parse.y3742--;       b1791(parse, text);     return text; }    function j1766(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const len = new l2000(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(len, parse, ignore, k4301);       if (ignore)      {         b1791(parse, len);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         len.input = s1788(parse);           parse.y3742--;       b1791(parse, len);     return len; }    function e1767(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const trim = new q2007(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(trim, parse, ignore, k4301);       if (ignore)      {         b1791(parse, trim);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         trim.input = s1788(parse);      trim.start = s1788(parse);     trim.end   = s1788(parse);           parse.y3742--;       b1791(parse, trim);     return trim; }    function j1768(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const sub = new d2004(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(sub, parse, ignore, k4301);       if (ignore)      {         b1791(parse, sub);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         sub.input = s1788(parse);      sub.start = s1788(parse);     sub.end   = s1788(parse);           parse.y3742--;       b1791(parse, sub);     return sub; }    function d1769(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const contains = new o1995(nodeId, options);          let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.logRequests)          r2124(contains, parse, ignore, k4301);       if (ignore)      {         b1791(parse, contains);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         contains.input = s1788(parse);      contains.what = s1788(parse);             parse.y3742--;       b1791(parse, contains);     return contains; }    function genParseTextFind(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const find = new m2607(nodeId, options);          let k4301 = -1;      if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 => 0 && k4301 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.logRequests)          r2124(find, parse, ignore, k4301);       if (ignore)      {         b1791(parse, find);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 2)     {         find.o4175 = s1788(parse);         find.i4176 = s1788(parse);     }     else if (k4301 == 1)     {         find.o4175 = s1788(parse);      }             parse.y3742--;       b1791(parse, find);     return find; }    function o1770(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const t3754 = new n1993(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(t3754, parse, ignore, k4301);       if (ignore)      {         b1791(parse, t3754);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         t3754.input = s1788(parse);      t3754.case = s1788(parse);           parse.y3742--;       b1791(parse, t3754);     return t3754; }    function l1771(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const replace = new p2002(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(replace, parse, ignore, k4301);       if (ignore)      {         b1791(parse, replace);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         replace.input = s1788(parse);      replace.what  = s1788(parse);     replace.with  = s1788(parse);     replace.regex = s1788(parse);           parse.y3742--;       b1791(parse, replace);     return replace; }                                                                     function genParseAddText(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const addText = new GAddText(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(addText, parse, ignore, k4301);       if (ignore)      {         b1791(parse, addText);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         addText.input = s1788(parse);      addText.text   = s1788(parse);     addText.prefix = s1788(parse);           parse.y3742--;       b1791(parse, addText);     return addText; }    function w1772(parse, g1690) {     const [type, nodeId, options, ignore] = d1790(parse);       const join = new n1999(nodeId, options);       let k4301 = 0;          if (!ignore)         k4301 = parseInt(parse.move());       if (parse.settings.logRequests)          r2124(join, parse, ignore, k4301);       if (ignore)      {         b1791(parse, join);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       for (let i = 0; i < k4301; i++)         join.inputs.push(s1788(parse));       join.with = s1788(parse);           parse.y3742--;               b1791(parse, join);     return join; }    function n1773(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const pad = new p2001(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(pad, parse, ignore, k4301);       if (ignore)      {         b1791(parse, pad);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         pad.input = s1788(parse);      pad.j3750   = s1788(parse);     pad.z3751 = s1788(parse);     pad.w3752     = s1788(parse);     pad.n3753   = s1788(parse);           parse.y3742--;       b1791(parse, pad);     return pad; }    function genParseTextEscape(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const escape = new g2597(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(escape, parse, ignore, k4301);       if (ignore)      {         b1791(parse, escape);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         escape.input = s1788(parse);      escape.method = s1788(parse);           parse.y3742--;       b1791(parse, escape);     return escape; }    function genParseTextUnescape(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const unescape = new o2614(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(unescape, parse, ignore, k4301);       if (ignore)      {         b1791(parse, unescape);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         unescape.input = s1788(parse);      unescape.method = s1788(parse);           parse.y3742--;       b1791(parse, unescape);     return unescape; }    function k1774(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const cmp = new p1994(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(cmp, parse, ignore, k4301);       if (ignore)      {         b1791(parse, cmp);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         cmp.input = s1788(parse);             cmp.operation = s1788(parse);     cmp.operand   = s1788(parse);           parse.y3742--;       b1791(parse, cmp);     return cmp; }    function v1775(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const b3749 = new i1988(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(b3749, parse, ignore, k4301);       if (ignore)      {         b1791(parse, b3749);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         b3749.input = s1788(parse);           parse.y3742--;       b1791(parse, b3749);     return b3749; }    function t1776(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const l3748 = new w1987(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(l3748, parse, ignore, k4301);       if (ignore)      {         b1791(parse, l3748);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         l3748.input = s1788(parse);           parse.y3742--;       b1791(parse, l3748);     return l3748; }    function d1777(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const index = new s1990(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(index, parse, ignore, k4301);       if (ignore)      {         b1791(parse, index);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       index.name  = s1788(parse);     index.index = s1788(parse);           parse.y3742--;       b1791(parse, index);     return index; }    function l1778(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const j3747 = new e1991(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(j3747, parse, ignore, k4301);       if (ignore)      {         b1791(parse, j3747);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         j3747.input = s1788(parse);      j3747.base      = s1788(parse);     j3747.trim      = s1788(parse);     j3747.decimals  = s1788(parse);     j3747.thousands = s1788(parse);           parse.y3742--;       b1791(parse, j3747);     return j3747; }    function t1779(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const j3746 = new o1989(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(j3746, parse, ignore, k4301);       if (ignore)      {         b1791(parse, j3746);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         j3746.input = s1788(parse);      j3746.format = s1788(parse);     j3746.trim   = s1788(parse);           parse.y3742--;       b1791(parse, j3746);     return j3746; }    function x1780(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const t3745 = new b2006(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(t3745, parse, ignore);       if (ignore)      {         b1791(parse, t3745);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         t3745.input = s1788(parse);      t3745.base      = s1788(parse);     t3745.decimals  = s1788(parse);     t3745.thousands = s1788(parse);           parse.y3742--;       b1791(parse, t3745);     return t3745; }    function genParseTextToBoolean(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const text2bool = new n2610(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(text2bool, parse, ignore);       if (ignore)      {         b1791(parse, text2bool);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         text2bool.input = s1788(parse);           parse.y3742--;       b1791(parse, text2bool);     return text2bool; }    function x1781(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const text2col = new h2005(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          r2124(text2col, parse, ignore);       if (ignore)      {         b1791(parse, text2col);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         text2col.input = s1788(parse);       text2col.format = s1788(parse);           parse.y3742--;       b1791(parse, text2col);     return text2col; }    function k1782(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const split = new l2003(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(split, parse, ignore, k4301);       if (ignore)      {         b1791(parse, split);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         split.input = s1788(parse);      split.separator = s1788(parse);           parse.y3742--;       b1791(parse, split);     return split; }    function m1783(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const csv = new g1996(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(csv, parse, ignore, k4301);       if (ignore)      {         b1791(parse, csv);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         csv.input = s1788(parse);      csv.b3743    = s1788(parse);     csv.d3744 = s1788(parse);           parse.y3742--;       b1791(parse, csv);     return csv; }    function x3799(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const json = new u2613(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(json, parse, ignore, k4301);       if (ignore)      {         b1791(parse, json);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         json.input = s1788(parse);           parse.y3742--;       b1791(parse, json);     return json; }    function genParseToJson(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const json = new u2542(nodeId, options);          let k4301 = -1;          if (!ignore)     {         k4301 = parseInt(parse.move());         c950(k4301 == 0 || k4301 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          r2124(json, parse, ignore, k4301);       if (ignore)      {         b1791(parse, json);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       if (k4301 == 1)         json.input = s1788(parse);      json.quoteValues = s1788(parse);     json.showNames   = s1788(parse);     json.singleLine  = s1788(parse);     json.whiteSpace  = s1788(parse);               parse.y3742--;       b1791(parse, json);     return json; }    function u1784(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const fetch = new r1997(nodeId, options);          if (parse.settings.logRequests)          r2124(fetch, parse, ignore);       if (ignore)      {         b1791(parse, fetch);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       fetch.request     = s1788(parse);     fetch.m4304 = s1788(parse);           parse.y3742--;       b1791(parse, fetch);     return fetch; }    function j1785(parse) {     const [, nodeId, options, ignore] = d1790(parse);       const file = new k1998(nodeId, options);          if (parse.settings.logRequests)          r2124(file, parse, ignore);       if (ignore)      {         b1791(parse, file);         return parse.b4335.find(n => n.nodeId == nodeId);     }       parse.y3742++;       file.m4304 = s1788(parse);                parse.y3742--;       b1791(parse, file);     return file; }


class c1786 {     request;     e2067;          pos;      so;      settings = {};      save;       log  = '';          y3742 = 0;      get tab() { return this.v1789 ? ' ' : (d870 + c867.repeat(Math.max(0, this.y3742))); }           v1789 = false;       evalAccumulate = true;     evalFeedback   = true;           m4114;     y4115;      viewportZoom;      f3734 = 0;     f3735   = 0;      scope           = [];      b4335     = [];            repeats         = [];     solvers         = [];        r3736    = false;           u3737    = [];        p2975    = [];     c3193    = [];     m3738   = [];     m3739    = [];       terminalIds     = [];            get next() { return this.request[this.pos]; }      get l3741()      {          return this.pos+1 < this.request.length               ? this.request[this.pos+1]              : null;     }        constructor(request, o3740, e2067, m4114, y4115, viewportZoom, settings, save)     {         this.request       = request;         this.e2067     = e2067;                    this.pos           = o3740;          this.so            = 0;                  this.m4114  = m4114;          this.y4115 = y4115;             this.viewportZoom  = viewportZoom;          this.settings      = settings;          this.save          = save;     }        move()     {                   const token = this.request[this.pos++];                  return token;     }        u1787()      {         return isEmpty(this.repeats)             ||    this.repeats.length == 1                && this.repeats[0].currentIteration == this.repeats[0].total-1;     }  }    function s1788(parse, v1789 = true) {           if (!v1789)         parse.v1789 = false;       let result = null;            if (parse.next == PARAM                  ) result = f1794             (parse);              else if (parse.next ==        q1054                        || parse.next == b1055                        || parse.next ==   y1056                        || parse.next ==  f1057      ) result = g1635         (parse);       else if (parse.next == s1058              ) result = t1632              (parse);     else if (parse.next == o1059               ) result = m1633          (parse);     else if (parse.next == y1060         ) result = v1634     (parse);     else if (parse.next == e1083                ) result = d1654            (parse);     else if (parse.next == k1061               ) result = t1655          (parse);     else if (parse.next == e1062                 ) result = z1656            (parse);     else if (parse.next == ADVANCE                ) result = genParseAdvance           (parse);     else if (parse.next == m1063                  ) result = i1657             (parse);     else if (parse.next == u1085                ) result = genParseIterate           (parse);     else if (parse.next == d1064                 ) result = t1658            (parse);     else if (parse.next == s1065                  ) result = q1659             (parse);     else if (parse.next == z1066         ) result = genParseGetValueName      (parse);     else if (parse.next == l1067         ) result = genParseSetValueName      (parse);     else if (parse.next == i1351   ) result = genParseGetListValueNames (parse);     else if (parse.next == o1352   ) result = genParseSetListValueNames (parse);     else if (parse.next == x1353        ) result = genParseSetObjectName     (parse);      else if (parse.next == q1068                   ) result = c1636              (parse);     else if (parse.next == b1069           ) result = t1637        (parse);     else if (parse.next == u1070                ) result = m1638           (parse);     else if (parse.next == n1071              ) result = q1639          (parse);     else if (parse.next == n1072              ) result = f1640          (parse);     else if (parse.next == y1073                ) result = r1641           (parse);     else if (parse.next == c1074                 ) result = f1642            (parse);     else if (parse.next == q1348           ) result = n1643       (parse);     else if (parse.next == s1349             ) result = l1644         (parse);     else if (parse.next == x1075           ) result = k1645       (parse);     else if (parse.next == z1350            ) result = genParseBuckleList        (parse);     else if (parse.next == j1076                   ) result = x1646              (parse);     else if (parse.next == b1084                 ) result = g1647            (parse);     else if (parse.next == k1077                 ) result = q1648            (parse);     else if (parse.next == x1078                   ) result = x1649              (parse);     else if (parse.next == y1079                  ) result = w1650        (parse);     else if (parse.next == i1082                 ) result = j1651            (parse);     else if (parse.next == e1359       ) result = genParseSelectFromList    (parse);     else if (parse.next == b1080             ) result = b1652         (parse);     else if (parse.next == OBJECT_COUNT           ) result = genParseObjectCount       (parse);     else if (parse.next == q1081          ) result = s1653      (parse);     else if (parse.next == LIST_FIND              ) result = genParseListFind          (parse);           else if (parse.next == c1090           ) result = t1691          (parse);     else if (parse.next == n1091                 ) result = a1692            (parse);     else if (parse.next == BOUNDED_NUMBER         ) result = genParseBoundedNumber     (parse);     else if (parse.next == BOOLEAN_NUMBER         ) result = genParseBooleanNumber     (parse);     else if (parse.next == s1354       ) result = genParseSetPrecision      (parse);     else if (parse.next == d1092            ) result = p1695              (parse);     else if (parse.next == g1093        ) result = o1696          (parse);     else if (parse.next == u1355        ) result = genParseNegative          (parse);     else if (parse.next == y1094           ) result = j1697             (parse);     else if (parse.next == j1356        ) result = genParseQuantize          (parse);     else if (parse.next == m1096          ) result = n1699            (parse);     else if (parse.next == w1095   ) result = n1698      (parse);     else if (parse.next == j1097          ) result = x1700            (parse);     else if (parse.next == v1098           ) result = m1701       (parse);     else if (parse.next == a1357             ) result = genParseNumberMap         (parse);     else if (parse.next == x1358            ) result = genParseNumberBias        (parse);     else if (parse.next == a1099          ) result = genParseNumberIsNaN       (parse);     else if (parse.next == j1100        ) result = v1693          (parse);     else if (parse.next == i1101        ) result = p1694          (parse);     else if (parse.next == x1102        ) result = w1710          (parse);     else if (parse.next == h1103           ) result = i1708             (parse);     else if (parse.next == s1104            ) result = j1709              (parse);     else if (parse.next == k1105          ) result = l1711            (parse);     else if (parse.next == l1106           ) result = z1712             (parse);     else if (parse.next == b1107            ) result = p1713       (parse);     else if (parse.next == x1108      ) result = q1714        (parse);     else if (parse.next == HOLD                   ) result = genParseHold              (parse);     else if (parse.next == s1109     ) result = o1715       (parse);     else if (parse.next == s1110           ) result = c1722             (parse);     else if (parse.next == o1111         ) result = q1723           (parse);          else if (parse.next == u1113            ) result = w1703              (parse, (nodeId, options) => new a1902          (nodeId, options));     else if (parse.next == h1112     ) result = m1704        (parse, (nodeId, options) => new a1902          (nodeId, options));     else if (parse.next == m1114             ) result = n1705        (parse, (nodeId, options) => new t1898           (nodeId, options));     else if (parse.next == h1115        ) result = n1705        (parse, (nodeId, options) => new i1906      (nodeId, options));     else if (parse.next == c1116        ) result = n1705        (parse, (nodeId, options) => new m1904      (nodeId, options));     else if (parse.next == z1117          ) result = n1705        (parse, (nodeId, options) => new z1900        (nodeId, options));     else if (parse.next == k1118          ) result = n1705        (parse, (nodeId, options) => new p1903        (nodeId, options));     else if (parse.next == i1119        ) result = n1705        (parse, (nodeId, options) => new q1901      (nodeId, options));           else if (parse.next == e1120         ) result = p1716           (parse);     else if (parse.next == t1121             ) result = n1705        (parse, (nodeId, options) => new o1909           (nodeId, options));     else if (parse.next == l1122             ) result = n1705        (parse, (nodeId, options) => new a1907           (nodeId, options));     else if (parse.next == b1123              ) result = n1705        (parse, (nodeId, options) => new f1910            (nodeId, options));     else if (parse.next == y1124             ) result = n1705        (parse, (nodeId, options) => new b1911           (nodeId, options));           else if (parse.next == h1125         ) result = genParseCompare           (parse);     else if (parse.next == j1126           ) result = y1718     (parse, (nodeId, options) => new x1913         (nodeId, options));     else if (parse.next == h1127       ) result = y1718     (parse, (nodeId, options) => new e1918      (nodeId, options));     else if (parse.next == z1128            ) result = y1718     (parse, (nodeId, options) => new n1916          (nodeId, options));     else if (parse.next == g1129   ) result = y1718     (parse, (nodeId, options) => new f1917   (nodeId, options));     else if (parse.next == k1130         ) result = y1718     (parse, (nodeId, options) => new z1914       (nodeId, options));     else if (parse.next == a1131) result = y1718     (parse, (nodeId, options) => new s1915(nodeId, options));       else if (parse.next == o1132            ) result = f1719     (parse);     else if (parse.next == x1133             ) result = k1720          (parse, (nodeId, options) => new k1921          (nodeId, options));     else if (parse.next == o1134             ) result = k1720          (parse, (nodeId, options) => new b1920        (nodeId, options));     else if (parse.next == t1135             ) result = k1720          (parse, (nodeId, options) => new a1922       (nodeId, options));     else if (parse.next == t1136           ) result = m1721             (parse, (nodeId, options) => new a1922       (nodeId, options));      else if (parse.next == a1137          ) result = z1706      (parse);       else if (parse.next == h1142             ) result = f1764         (parse);     else if (parse.next == h1143                   ) result = i1765              (parse);     else if (parse.next == w1144            ) result = j1766        (parse);     else if (parse.next == n1145              ) result = e1767          (parse);     else if (parse.next == f1146         ) result = j1768     (parse);     else if (parse.next == j1147          ) result = d1769      (parse);     else if (parse.next == TEXT_FIND              ) result = genParseTextFind          (parse);     else if (parse.next == t1148              ) result = o1770          (parse);     else if (parse.next == m1153              ) result = v1775   (parse);     else if (parse.next == v1154           ) result = t1776   (parse);     else if (parse.next == p1155          ) result = d1777       (parse);     else if (parse.next == w1156         ) result = l1778      (parse);     else if (parse.next == v1157          ) result = t1779       (parse);     else if (parse.next == i1158         ) result = x1780      (parse);     else if (parse.next == TEXT_TO_BOOLEAN        ) result = genParseTextToBoolean     (parse);     else if (parse.next == l1159          ) result = x1781       (parse);     else if (parse.next == r1149           ) result = l1771       (parse);     else if (parse.next == TEXT_ADD               ) result = genParseAddText           (parse);     else if (parse.next == t1150              ) result = w1772          (parse);     else if (parse.next == m1151               ) result = n1773           (parse);     else if (parse.next == TEXT_ESCAPE            ) result = genParseTextEscape        (parse);     else if (parse.next == TEXT_UNESCAPE          ) result = genParseTextUnescape      (parse);     else if (parse.next == y1152           ) result = k1774       (parse);     else if (parse.next == a1160             ) result = k1782         (parse);     else if (parse.next == b1162              ) result = m1783          (parse);     else if (parse.next == w3601             ) result = x3799         (parse);     else if (parse.next == TO_JSON                ) result = genParseToJson            (parse);     else if (parse.next == r1163             ) result = u1784         (parse);     else if (parse.next == i1164              ) result = j1785          (parse);       else if (parse.next == j1167            ) result = u1623        (parse);     else if (parse.next == f1168                  ) result = o1624             (parse);     else if (parse.next == t1169            ) result = x1625        (parse);     else if (parse.next == o1170          ) result = u1626      (parse);     else if (parse.next == b1171         ) result = q1627     (parse);     else if (parse.next == o1172       ) result = genParseColorDifference   (parse);     else if (parse.next == t1173             ) result = u1629        (parse);     else if (parse.next == COLOR_SCHEME           ) result = genParseColorScheme       (parse);     else if (parse.next == a1174      ) result = d1630  (parse);     else if (parse.next == s1175            ) result = o1631        (parse);            else if (parse.next == d1177             ) result = n1666         (parse);     else if (parse.next == e1178                   ) result = l1667              (parse);            else if (parse.next == i1183       ) result = i1671    (parse);     else if (parse.next == m1184             ) result = k1672         (parse);            else if (parse.next == c1186         ) result = u1669     (parse);     else if (parse.next == c1187               ) result = k1670          (parse);            else if (parse.next == b1180           ) result = c1673       (parse);     else if (parse.next == a1181                 ) result = k1674            (parse);            else if (parse.next == y1189     ) result = genParseStrokeSidesValue  (parse);     else if (parse.next == w1190           ) result = genParseStrokeSides       (parse);            else if (parse.next == r1192    ) result = x1676 (parse);     else if (parse.next == a1193          ) result = o1677      (parse);            else if (parse.next == e1195      ) result = i1678   (parse);     else if (parse.next == k1196            ) result = d1679        (parse);            else if (parse.next == y1198     ) result = a1680  (parse);     else if (parse.next == e1199           ) result = n1681       (parse);            else if (parse.next == w1201       ) result = a1682    (parse);     else if (parse.next == e1202             ) result = j1683         (parse);            else if (parse.next == d1204        ) result = y1684     (parse);     else if (parse.next == s1205              ) result = u1685          (parse);      else if (parse.next == d1210      ) result = n1686   (parse);     else if (parse.next == s1211            ) result = a1687        (parse);            else if (parse.next == e1207       ) result = i1688    (parse);     else if (parse.next == m1208             ) result = b1689         (parse);            else if (parse.next == a1215            ) result = n1763        (parse);            else if (parse.next == f1218              ) result = o1724         (parse);     else if (parse.next == y1221                   ) result = r1725              (parse);     else if (parse.next == w1224                ) result = i1726           (parse);     else if (parse.next == n1227                ) result = o1727           (parse);     else if (parse.next == w1236                ) result = n1728           (parse);     else if (parse.next == t1239                   ) result = u1729              (parse);     else if (parse.next == p1242             ) result = e1730         (parse);       else if (parse.next == v1244            ) result = n1731        (parse);     else if (parse.next == d1245                  ) result = b1732             (parse);     else if (parse.next == u1247           ) result = v1733       (parse);     else if (parse.next == q1248      ) result = g1734   (parse);     else if (parse.next == p1249            ) result = n1735        (parse);          else if (parse.next == s1251    ) result = z1736 (parse);     else if (parse.next == k1252          ) result = e1737      (parse);     else if (parse.next == p1254      ) result = w1738   (parse);     else if (parse.next == p1255            ) result = k1739        (parse);     else if (parse.next == x1257    ) result = u1740 (parse);     else if (parse.next == c1258          ) result = p1741      (parse);     else if (parse.next == i1260   ) result = s1742(parse);     else if (parse.next == k1261         ) result = y1743     (parse);      else if (parse.next == l1286    ) result = c3934 (parse);     else if (parse.next == p1285          ) result = f1744      (parse);      else if (parse.next == h1230         ) result = genParseArcPathValue      (parse);     else if (parse.next == v1229               ) result = genParseArcPath           (parse);      else if (parse.next == a1233        ) result = genParseWavePathValue     (parse);     else if (parse.next == f1232              ) result = genParseWavePath          (parse);      else if (parse.next == r1263      ) result = z3935   (parse);     else if (parse.next == v1264            ) result = v1745        (parse);       else if (parse.next == n1266            ) result = e3936        (parse);     else if (parse.next == q1267                  ) result = t1746             (parse);       else if (parse.next == e1269                   ) result = k1747              (parse);     else if (parse.next == e1270                 ) result = e1748            (parse);     else if (parse.next == b1271                  ) result = a1749             (parse);     else if (parse.next == n1272                   ) result = a1750              (parse);      else if (parse.next == SHOW_CENTER            ) result = genParseShowCenter        (parse);     else if (parse.next == l1273             ) result = v1751            (parse);     else if (parse.next == m1274            ) result = l1752    (parse);      else if (parse.next == PATH_LENGTH            ) result = genParsePathLength        (parse);     else if (parse.next == JOIN_PATHS             ) result = genParseJoinPaths         (parse);     else if (parse.next == REORIENT_PATHS         ) result = genParseReorientPaths     (parse);     else if (parse.next == h1277         ) result = h1753     (parse);     else if (parse.next == l1278            ) result = d1754        (parse);     else if (parse.next == t1279                 ) result = k1755            (parse);     else if (parse.next == k1280          ) result = k1756      (parse);     else if (parse.next == ARC_FROM_POINTS        ) result = genParseArcFromPoints     (parse);     else if (parse.next == p1281        ) result = x1757    (parse);     else if (parse.next == x1282      ) result = h1758  (parse);     else if (parse.next == o1283       ) result = genParsePointAlongPath    (parse);     else if (parse.next == g1284  ) result = genParseClosestPointOnPath(parse);     else if (parse.next == REVERSE_PATH           ) result = genParseReversePath       (parse);     else if (parse.next == BLEND_PATH             ) result = genParseBlendPath         (parse);      else if (parse.next == s1275                  ) result = f1760             (parse);     else if (parse.next == i1276            ) result = k1761        (parse);          else if (parse.next == l1292                ) result = k1762           (parse);     else if (parse.next == EXPORT                 ) result = genParseExport            (parse);       else if (parse.next == y1297             ) result = a1664         (parse);     else if (parse.next == d1298            ) result = x1665        (parse);       else if (parse.next == q1300                ) result = p1661           (parse);     else if (parse.next == p1301          ) result = d1662      (parse);     else if (parse.next == t1302                  ) result = w1663             (parse);      else h951('unknown parse token \'' + parse.next + '\' @ ' + parse.pos);       parse.v1789 = false;       if (result)         return result;     else     {         parse.so++;         return null;     } }    function d1790(parse) {     const type     = parse.move();     const nodeId   = parse.move();     const nodeName = decodeURIComponent(parse.move());           parse.scope.push(nodeId);       if (parse.b4335.find(n => n.nodeId == nodeId))         return [type, nodeId, {nodeName: nodeName}, true];       const options = w1792(parse);      options.nodeName = nodeName;       return [type, nodeId, options, false]; }    function b1791(parse, node = null) {     parse.scope.pop();      if (node)     {         if (isEmpty(parse.scope))             node.topLevel = true;          j947(parse.b4335, node);     } }    function w1792(parse) {     const opt = parseInt(parse.move());      const options =      {         active:       ((opt >>  0) & 1) != 0,         k3097: ((opt >>  1) & 1) != 0,         beforeList:   ((opt >>  2) & 1) != 0,         enabled:      ((opt >>  3) & 1) != 0,         cached:       ((opt >>  4) & 1) != 0,         unknown:      ((opt >>  5) & 1) != 0,         notCondition: ((opt >>  6) & 1) != 0,         g3362:    ((opt >> 20) & 1) != 0     };      return options; }    function b1793(parse) {     const k3763 = parseInt(parse.move());      if (parse.settings.logRequests)          parse.log += parse.tab + k3763;      return k3763; }    function f1794(parse) {     if (parse.next != PARAM)          return null;              parse.move();      const type = parse.move();            const nodeId  = parse.move();     const m3091 = parse.move();          const param   = new g2049(nodeId, m3091);        j947(parse.u3737, nodeId);       if (parse.settings.logRequests)          e2128(param, type, parse);       return param; }    function k1795(parse) {     const m3091 = parse.move();      if (parse.settings.logRequests)         parse.log += parse.tab + m3091;      return m3091; }


class z2132 {     request;     pos;      so            = 0;     y3742          = 0;        skipNewLine   = false;      loggedNodeIds = [];            constructor(request, pos)     {         this.request = request;         this.pos     = pos;     }       get tab()      {          if (this.skipNewLine)         {             this.skipNewLine = false;             return '';         }         else              return d870 + c867.repeat(Math.max(0, this.y3742));      } }    function log(str) {     v3977.innerHTML = str; }    function s2133(g2134, b111 = null) {     let str = g2134;      if (b111)         str = b111.id + '.' + str;      console.log(         '%c ' + str + ' ',          'background: #fc0; color: #632;'); }    function v2135(str, color = 'white', background = 'red') {     console.log(         '%c ' + str + ' ',          'background: ' + background + '; color: ' + color + ';'); }    function logValueUpdates(m4114, y4115, values) {           let log     = '';     let newLine = true;      if (   m4114  != ''          || y4115 != '')         log = '↓ ' + t2126(m4114) + '.' + t2126(y4115);     else         newLine = false;                 let i    = 0;     let y3742 = 0;      while (i < values.length)     {         const nodeId  = values[i++];         const k4301 = parseInt(values[i++]);          log +=                (newLine ? d870 : '') + c867.repeat(Math.max(0, y3742))             + nodeId;          newLine = true;          y3742++;          for (let j = 0; j < k4301; j++)         {             const index = values[i++];             const type  = values[i++];             const value = values[i++];              log +=                    d870 + c867.repeat(Math.max(0, y3742))                 + index + ' ' + y4302(type, value);         }          y3742--;     }       console.log(         '%c%s',          'background: #e70; color: white;',          log); }    function logObjectUpdates(objects) {     console.log(         '%cobjects',          'background: #07e; color: white;',          objects); }    function logStyleUpdates(styles) {     console.log(         '%cstyles',          'background: #b4d; color: white;',          styles); }    function s2136(pageJson) {     console.log('%cSAVING PAGES\n' + pageJson, 'color: black; background: #ddeeee;'); }    function u2137(nodeJson) {     console.log('%cSAVING NODES\n' + nodeJson, 'color: black; background: #ddeeff;'); }    function b2138(u2139) {     let log = 'SAVING ' + u2139.length + ' ' + f4111(u2139.length, 'CONNECTION');      for (const t243 of u2139)         log += '\n' + t243.q2119();      console.log(         '%c' + log,          'color: black; background: #ddeeff;'); }    function z2140(u2139) {     let log = 'UPDATING ' + u2139.length + ' ' + f4111(u2139.length, 'SAVED CONNECTION');      for (const t243 of u2139)         log += '\n' + t243.q2119();      console.log(         '%c' + log,          'color: black; background: #ddeeff;'); }    function u2141() {     let log =          'UNDO STACK:\n'         + f2985.actions.map(a => '    ' + a.name).join('\n');      console.log(         '%c%s',          'background: #ffd; color: #b80;',          log); }    function q2142() {     let log =           'REDO STACK:\n'         + f2985.v2987.map(a => '    ' + a.name).join('\n');      console.log(         '%c%s',          'background: #fff4e8; color: #c64;',          log); }    function logInsertSeparator() {     console.log(         '%c%s',          'background: #f44; color: #fff;',          Math.random() + '--------------------'); }       


function h2123(parse) {     let log = '';      if (   parse.m4114  != ''          || parse.y4115 != '')         log = '↓ ' + t2126(parse.m4114) + '.' + t2126(parse.y4115);      log += parse.log;      console.log(         '%c%s',          'background: #60aa60; color: #fff',           log); }    function r2124(node, parse, ignore, k4301 = -1) {     parse.log += parse.tab + node.type;     parse.log += y2125(node, ignore);      if (    k4301 > -1         && !ignore)         parse.log += ' ' + k4301; }    function logReqSolve(node, parse, ignore, k4301 = -1) {     parse.log += parse.tab + node.type;     parse.log += y2125(node, ignore);       parse.log += ' ' + node.terminalIds.length;      if (node.terminalIds.length > 0)     {         parse.log += ' ';         parse.log += node.terminalIds.join(' ');     }       parse.log += node.currentConnected ? ' 1' : ' 0';           if (    k4301 > -1         && !ignore)         parse.log += ' ' + k4301; }    function y2125(node, ignore = false) {     return ' '           + t2126(node.nodeId)           + ' \'' + t2126(node.nodeName) + '\''          + (!ignore             ? w2127(node)             : ''); }    function t2126(nodeId) {     return nodeId == '' ? '\'\'' : nodeId; }    function w2127(node) {     let log = '';      if ( node.options.active      ) log += ' ' + m1303;     if ( node.options.k3097) log += ' ' + k1304;     if ( node.options.beforeList  ) log += ' ' + n1305;     if (!node.options.enabled     ) log += ' ' + e1306;      if (!node.cached              ) log += ' ' + y1307;      return log; }    function e2128(param, type, parse) {     parse.log +=                  parse.tab + PARAM         + ' ' + type          + ' ' + t2126(param.nodeId)          + '.' + t2126(param.m3091); }    function t2129(node, parse) {     parse.log += parse.tab + node.type;     parse.log += y2125(node); }    function x2130(q1033, k4301, n3777, parse, ignore) {     parse.log += parse.tab + b1171;     parse.log += y2125(q1033, ignore);      if (!ignore)     {         parse.log += ' ' + k4301;          if (k4301 == 1)             parse.log += ' ' + n3777;     } }    function l2131(type, val, parse) {     parse.log += parse.tab + type + ' ' + y4302(type, val); }    function logReqString(str, parse) {     parse.log += parse.tab + str; }                                           


async function logSavedNode(nodeKey, g4102) {     const log  = l2120(await b1564(nodeKey, false));      if (g4102)     {         console.log(             '%c%s\n%c%s',              'background: #fa24; color: white;',              z1052(nodeKey),              'background: #fa44; color: #edc;',             log);     }     else     {         console.log(             '%c%s\n%c%s',              'background: #fdb; color: black;',              z1052(nodeKey),              'background: #fed; color: black;',             log);     } }    function l2120(json) {     let f4127 = json         .replace('{\n', '')         .replace('\n}', '')          .replace('[\n' + c867, '')         .replace('\n' + c867 + ']', '')          .split(c867 + '"params":\n').join('')           .split('": "').join(': ')         .split('", "').join(': ')          .split(c867 + '"').join(c867)         .split(c867 + c867 + '["').join(c867 + c867)                  .split('",\n').join('\n')         .split('"\n').join('\n')                  .split('"],\n').join('\n');       if (f4127[f4127.length-1] == '"')         f4127 = f4127.substring(0, f4127.length - 1);      if (f4127.substring(f4127.length-2) == '"]')             f4127 = f4127.substring(0, f4127.length - 2);      return f4127; }    function c2121(json) {     let f4127 = json         .replace('{\n', '')         .replace('\n}', '')         .replace('[\n' + c867, '')         .replace('\n' + c867 + ']', '');      return f4127; }    function n2122(t243, g4102) {     const a4303 = q922(t243, true);      if (g4102)     {         console.log(             '%c%s',              'background: #4f44; color: #ded',              a4303);      }     else     {         console.log(             '%c%s',              'background: #cfc; color: black;',              a4303);      } }


  const D50 = [0.96422, 1, 0.82521]; const D65 = [0.95047, 1, 1.08883];    function u31(R, G, B, Y, W, gamma, degamma, regamma, luminance) {     return {             R:         R,         G:         G,         B:         B,          Y:         Y,          W:         W,          w70:   u32(R, G, B, W),         y72:   h889(u32(R, G, B, W)),          gamma:     gamma,                  degamma:   degamma,         regamma:   regamma,                  luminance: luminance     }; }   function u32(R, G, B, W) {     const C0 = i33(R);     const C1 = i33(G);     const C2 = i33(B);      const M = [ [ C0[0], C1[0], C2[0] ],                  [ C0[1], C1[1], C2[1] ],                  [ C0[2], C1[2], C2[2] ] ];      const S = l946(W, h889(M));      return [ [ S[0]*C0[0], S[1]*C1[0], S[2]*C2[0] ],              [ S[0]*C0[1], S[1]*C1[1], S[2]*C2[1] ],              [ S[0]*C0[2], S[1]*C1[2], S[2]*C2[2] ] ]; }   function i33(c) {     const x = c[0],           y = c[1];      return [x/y, 1, (1-x-y)/y]; } 


function d502d65(xyz) {     const bradford =          [ [ 0.9555766, -0.0230393,  0.0631636 ],           [-0.0282895,  1.0099416,  0.0210077 ],           [ 0.0122982, -0.0204830,  1.3299098 ] ];      return w1037(bradford, xyz); }    function d652d50(xyz) {     const bradford =          [ [ 1.0184567, 0.0093864, -0.0213199 ],           [ 0.0120291, 0.9951460, -0.0072228 ],           [-0.0039673, 0.0064899,  0.8925936 ] ];      return w1037(bradford, xyz); }


const q36 = u31 (     [0.64, 0.33],      [0.3,  0.6 ],      [0.15, 0.06],       [0.212656,      0.715158,      0.072186],       D65,              2.4,               function(v)      {         return v >= 0.04045              ? Math.pow((v + 0.055) / 1.055, this.gamma)              : v / 12.92;     },           function(v)      {         return v > 0.0031308              ? 1.055 * Math.pow(v, 1/this.gamma) - 0.055              : v * 12.92;     },               function(rgb)      {         return  this.Y[0] * this.degamma(rgb[0])                + this.Y[1] * this.degamma(rgb[1])                + this.Y[2] * this.degamma(rgb[2]);     } );  const sRGB_D65 = q36;   const sRGB_D50 = u31 (     [0.64, 0.33],      [0.3,  0.6 ],      [0.15, 0.06],       [0.34567,       0.35850,       0.29583],        D50,              2.4,               function(v)      {         return v >= 0.04045                ? Math.pow((v + 0.055) / 1.055, this.gamma)                : v / 12.92;     },           function(v)      {         return v > 0.0031308                ? 1.055 * Math.pow(v, 1/this.gamma) - 0.055                : v * 12.92;     },               function(rgb)      {         return  this.Y[0] * this.degamma(rgb[0])                + this.Y[1] * this.degamma(rgb[1])                + this.Y[2] * this.degamma(rgb[2]);     } ); 


const P3 = u31 (     [0.68,  0.32],      [0.265, 0.69],      [0.15,  0.06],       [0.228974,        0.691738,      0.079289],      D65,              2.4,               function(v)      {         return v >= 0.04045                ? Math.pow((v + 0.055) / 1.055, this.gamma)                : v / 12.92;     },           function(v)      {         return v > 0.0031308                ? 1.055 * Math.pow(v, 1/this.gamma) - 0.055                : v * 12.92;     },           function(rgb)      {         return  this.Y[0] * this.degamma(rgb[0])                + this.Y[1] * this.degamma(rgb[1])                + this.Y[2] * this.degamma(rgb[2]);     } );    function h61(rgb) {     return g71(y69(rgb), P3); }    function z62(p3) {     return g71(y69(p3, P3)); }


const Adobe98 = u31 (     [0.64, 0.33],      [0.21, 0.71],      [0.15, 0.06],       [0.297361,      0.627355,      0.075284],       D65,              563/256,           function(v)      {         return Math.pow(v, this.gamma);     },       function(v)      {         return Math.pow(v, 1/this.gamma);     },       function(rgb)      {         return  this.Y[0] * this.degamma(rgb[0])                + this.Y[1] * this.degamma(rgb[1])                + this.Y[2] * this.degamma(rgb[2]);     } );    function rgb2a98(rgb) {     return g71(y69(rgb), Adobe98); }    function a982rgb(a98) {     return g71(y69(a98, Adobe98)); }


const ProPhotoRGB = u31 (     [0.7347, 0.2653],      [0.1596, 0.8404],      [0.0366, 0.0001],       [0.2880402,      0.7118741,      0.0000857],       D50,               1.8,                function(v)      {         return v >= 0.001953125                 ? Math.pow(v, this.gamma)                : v / 16;     },       function(v)      {         return v > Math.pow(16 * 0.001953125, this.gamma - 1)                ? Math.pow(v, 1/this.gamma)                : v * 16;     },       function(rgb)      {         return  this.Y[0] * this.degamma(rgb[0])                + this.Y[1] * this.degamma(rgb[1])                + this.Y[2] * this.degamma(rgb[2]);     } );    function rgb2pro(rgb) {     return g71(y69(rgb), ProPhotoRGB);      }    function pro2rgb(pro) {     return g71(y69(pro, ProPhotoRGB));      }


const Rec2020 = u31 (     [0.708, 0.292],      [0.170, 0.797],      [0.131, 0.046],       [0.2627,      0.6780,      0.0593],        D65,             2.2,              function(v)      {         return v >= 0.08145              ? Math.pow((v + 0.0993) / 1.0993, this.gamma)              : v / 4.5;     },       function(v)      {         return v > 0.0181              ? 1.0993 * Math.pow(v, 1 / this.gamma) - 0.0993              : v * 4.5;     },           function(rgb)      {         return this.Y[0] * this.degamma(rgb[0])               + this.Y[1] * this.degamma(rgb[1])               + this.Y[2] * this.degamma(rgb[2]);     } );    function rgb2r2020(rgb) {     return g71(y69(rgb), Rec2020); }    function r20202rgb(r2020) {     return g71(y69(r2020, Rec2020)); }


function j66(rgb, amount) {     const hsv = o52(rgb);     hsv[2] *= amount;     return d54(hsv); }    function e67(rgb, amount) {     const hsv = o52(rgb);     hsv[1] *= amount;     return d54(hsv); }    function n68(rgb, amount) {     const hsl = u48(rgb);     hsl[1] *= amount;     return x50(hsl); }    function lin2rgb_(r, g, b) {     return [         q36.degamma(r),          q36.degamma(g),          q36.degamma(b)]; }    function lin2rgb(rgb) {     return lin2rgb_(rgb[0], rgb[1], rgb[2]); }    function rgb2lin_(r, g, b) {     return [         q36.regamma(r),          q36.regamma(g),          q36.regamma(b)]; }    function rgb2lin(rgb) {     return rgb2lin_(rgb[0], rgb[1], rgb[2]); }


function n51(r, g, b) {     let h, s, v;      let min = Math.min(Math.min(r, g), b),         max = Math.max(Math.max(r, g), b);      let delta = max - min;      v = max;     s = max == 0 ? 0 : delta / max; 	     if      (max == r) h = 1/6 * (g - b) / delta + 1;        else if (max == g) h = 1/6 * (b - r) / delta + 1/3;      else if (max == b) h = 1/6 * (r - g) / delta + 2/3;   	if (h > 1) h -= 1; 	      return [h, s, v]; }    function o52(rgb) {     return n51(rgb[0], rgb[1], rgb[2]); }    function e53(h, s, v) {     while (h < 0) h++;     h %= 1;      if (s == 0)         return [v, v, v];       h *= 6 - 0.0000001;      let i = Math.floor(h);     let f = h - i; 	     let p = v * (1 - s);     let q = v * (1 - s * f);     let t = v * (1 - s * (1 - f));      switch (i)     {         case 0:  return [v, t, p];         case 1:  return [q, v, p];         case 2:  return [p, v, t];         case 3:  return [p, q, v];         case 4:  return [t, p, v];         default: return [v, p, q];     } }    function d54(hsv) { 	return e53(hsv[0], hsv[1], hsv[2]); }


function w47(r, g, b) {     let h, s, l;      let min = Math.min(Math.min(r, g), b),         max = Math.max(Math.max(r, g), b);      let delta = max - min;      l = (max + min) / 2;           if (max == min) h = 0;     else if (max == r  ) h = 1/6 * (g - b) / delta + 1;     else if (max == g  ) h = 1/6 * (b - r) / delta + 1/3;     else if (max == b  ) h = 1/6 * (r - g) / delta + 2/3;      if (h > 1)         h -= 1;               if (max == min) s = 0;     else if (l <= 0.5)   s = delta / (2 * l);     else if (l >  0.5)   s = delta / (2 - 2 * l);      return [h, s, l]; }    function u48(rgb) {     return w47(rgb[0], rgb[1], rgb[2]); }    function u49(h, s, l) {     while (h < 0) h++;     h %= 1;      let q =         l < 0.5         ? l * (1 + s)         : l + s - l * s;      let p = 2 * l - q;      let tr = h + 1/3;     let tg = h;     let tb = h - 1/3;      if (tr < 0) tr += 1; if (tr > 1) tr -= 1;     if (tg < 0) tg += 1; if (tg > 1) tg -= 1;     if (tb < 0) tb += 1; if (tb > 1) tb -= 1;      let r, g, b;      let qp6 = (q - p) * 6;            if (tr <  1/6)				r = p + qp6 * tr;     else if (tr >= 1/6 && tr < 0.5)	r = q;     else if (tr >= 0.5 && tr < 2/3)	r = p + qp6 * (2/3 - tr);     else							r = p; 	          if (tg <  1/6)				g = p + qp6 * tg;     else if (tg >= 1/6 && tg < 0.5)	g = q;     else if (tg >= 0.5 && tg < 2/3) g = p + qp6 * (2/3 - tg);     else							g = p;           if (tb <  1/6)				b = p + qp6 * tb;     else if (tb >= 1/6 && tb < 0.5) b = q;     else if (tb >= 0.5 && tb < 2/3) b = p + qp6 * (2/3 - tb);     else							b = p;      return [r, g, b]; }    function x50(hsl) {     return u49(hsl[0], hsl[1], hsl[2]); }


function q59(xyz) {     return l946(xyz, CAT); }    function g60(lms) {     return l946(lms, invCAT); }    function j4078(r, g, b, cs = q36)  {     r = cs.degamma(r);     g = cs.degamma(g);     b = cs.degamma(b);      return [         0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b, 	    0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b, 	    0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b ]; }            function a4084(lms, cs = q36)  {     const l = cube(lms[0]);     const m = cube(lms[1]);     const s = cube(lms[2]);  	const r =  4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s; 	const g = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s; 	const b = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s;      return [         cs.regamma(r),         cs.regamma(g),         cs.regamma(b) ]; }    function h4079(lms)  {     const l = Math.cbrt(lms[0]);     const m = Math.cbrt(lms[1]);     const s = Math.cbrt(lms[2]);      const l_ = 0.2104542553 * l + 0.7936177850 * m - 0.0040720468 * s;     const a_ = 1.9779984951 * l - 2.4285922050 * m + 0.4505937099 * s;     const b_ = 0.0259040371 * l + 0.7827717662 * m - 0.8086757660 * s;      return [         l_,         a_,          b_ ]; }    function j4082(lab) {     return g4083(lab[0], lab[1], lab[2]); }    function g4083(l, a, b)  {     return [         l + 0.3963377774 * a + 0.2158037573 * b,         l - 0.1055613458 * a - 0.0638541728 * b,         l - 0.0894841775 * a - 1.2914855480 * b ]; }


function y69(rgb, cs = q36) {      return w70(degamma(rgb, cs), cs); }        function w70(rgb, cs = q36) {     return l946(rgb, cs.w70); }            function g71(xyz, cs = q36) {     return regamma(y72(xyz, cs), cs); }    function y72(xyz, cs = q36) {     return l946(xyz, cs.y72); }


function t4072(rgb, cs = q36) {     return o4074(y69(rgb, cs), cs.W); }    function a4073(luv, cs = q36) {     return g71(f4075(luv, cs.W), cs); }    function o4074(xyz, W = q36.W) {     const x = xyz[0],            y = xyz[1],            z = xyz[2];      const e = cube(6/29);     const k = cube(29/3);      const yw = y / W[1];      let l =          yw > e         ? 116 * Math.cbrt(yw) - 16         : k * yw;      const u_ = 4*x / (x + 15*y + 3*z);     const v_ = 9*y / (x + 15*y + 3*z);          const uw = 4*W[0] / (W[0] + 15*W[1] + 3*W[2]);     const vw = 9*W[1] / (W[0] + 15*W[1] + 3*W[2]);          const u = 13*l * (u_ - uw);     const v = 13*l * (v_ - vw);      return [         l / 100,          u / 100,          v / 100]; }    function f4075(luv, W = q36.W) {     let l = luv[0] * 100,          u = luv[1] * 100,          v = luv[2] * 100;      const e = cube(6/29);         const k = cube(29/3);      const uw = 4*W[0] / (W[0] + 15*W[1] + 3*W[2]);     const vw = 9*W[1] / (W[0] + 15*W[1] + 3*W[2]);          const y =          l > e*k         ? cube((l + 16) / 116)         : l / k;          const a = (52*l / nozero(u + 13*l*uw) - 1) / 3;     const b = -5 * y;     const c = -1/3;     const d =  y * (39*l / nozero(v + 13*l*vw) - 5);      const x = (d - b) / nozero(a - c);      const z = x*a + b;      return [x, y, z]; }


function d55(rgb, cs = q36) {     return k57(y69(rgb, cs), cs.W); }    function y56(lab, cs = q36) {     return g71(c58(lab, cs.W), cs); }    function k57(xyz, W = q36.W) {     const x = xyz[0],            y = xyz[1],            z = xyz[2];      const e = 0.008856;      const k = 903.3;          let xw = x / W[0];     let yw = y / W[1];     let zw = z / W[2];      xw = xw > e ? Math.cbrt(xw) : (k / 100 * xw + 0.16) / 1.16;     yw = yw > e ? Math.cbrt(yw) : (k / 100 * yw + 0.16) / 1.16;     zw = zw > e ? Math.cbrt(zw) : (k / 100 * zw + 0.16) / 1.16;       const l = (1.16 * yw) - 0.16;     const a = 5 * (xw - yw);     const b = 2 * (yw - zw);      return [l, a, b]; }    function c58(lab, W = q36.W) {     const l = lab[0],            a = lab[1],            b = lab[2];      const e = 0.008856 / 100;      const k = 903.3    / 100;       const yw = (l + 0.16)/1.16;     const xw = a/5 + yw;     const zw = yw - b/2;      let x = cube(xw) > e ? cube(xw) : (1.16*xw - 0.16) / k;     let y = cube(yw) > e ? cube(yw) : (1.16*yw - 0.16) / k;     let z = cube(zw) > e ? cube(zw) : (1.16*zw - 0.16) / k;      x *= W[0];     y *= W[1];     z *= W[2];       return [x, y, z]; }


function p4076(rgb, cs = q36) {     return s4077(rgb[0], rgb[1], rgb[2], cs); }    function s4077(r, g, b, cs = q36)  {     return h4079(j4078(r, g, b, cs)); }        function q4080(lab, cs = q36) {     return a4084(j4082(lab), cs); }    function i4081(l, a, b, cs = q36)  {     return q4080([l, a, b], cs); }


const l65 = 0.89;   function o63(opp)  {                const l = opp[0],            a = opp[1],            b = opp[2];      const h = Math.atan2(b, a);     const c = Math.sqrt(a*a + b*b);      return [h, c, l]; }    function l64(pol)  {                const h = pol[0],            c = pol[1],            l = pol[2];      const a = c * Math.cos(h);     const b = c * Math.sin(h);      return [l, a, b]; }


function z34(hcl, cs = q36) {     hcl = [...hcl];      hcl[0] *= Tau;     hcl[1] *= hcl[2];       return q4080(l64(hcl), cs); }        function a35(h, c, l, cs = q36) {     return z34([h, c, l], cs); }                    function q37(rgb, cs = q36) {     const hcl = o63(p4076(rgb, cs));      hcl[0] /= Tau;     hcl[1] /= nozero(hcl[2]);      while (hcl[0] < 0) hcl[0] += 1;     while (hcl[0] > 1) hcl[0] -= 1;      return hcl; }    function z38(r, g, b, cs = q36) {     return q37([r, g, b], cs); }    function d39(hcl) {     hcl = [...hcl];      hcl[0] *= Tau;     hcl[1] *= hcl[2];      return l64(hcl); }    function r40(hcl, cs = q36) {     return y56(d39(hcl), cs); }    function hclab2rgb_(h, c, l, cs = q36) {     return r40([h, c, l], cs); }    function h41(lab) {     let hcl = o63(lab);      hcl[0] /= Tau;     hcl[1] /= hcl[2];      while (hcl[0] < 0) hcl[0] += 1;     while (hcl[0] > 1) hcl[0] -= 1;      return hcl; }    function p42(rgb, cs = q36) {     return h41(d55(rgb, cs)); }    function h43(hcl) {     hcl = [...hcl];      hcl[0] *= Tau;     hcl[1] *= hcl[2];      return l64(hcl); }    function o44(hcl, cs = q36) {     return a4073(h43(hcl), cs); }    function hcluv2rgb_(h, c, l, cs = q36) {     return o44([h, c, l], cs); }    function v45(luv) {     let hcl = o63(luv);      hcl[0] /= Tau;     hcl[1] /= hcl[2];      while (hcl[0] < 0) hcl[0] += 1;     while (hcl[0] > 1) hcl[0] -= 1;      return hcl; }    function j46(rgb, cs = q36) {     return v45(t4072(rgb, cs)); }


function d2635(xyz)  {     const [l, a, b] = xyzToLab(xyz);                    const hue = Math.atan2(b, a) * (180 / Math.PI);     const chroma = Math.sqrt(a * a + b * b);     const tone = l;            return { hue, chroma, tone }; }


const r131 =  [     ['hex',   'Hex'           ],     ['rgb',   'RGB'           ],      ['hsl',   'HSL'           ],      ['hsv',   'HSB'           ],      ['lin',   'RGB / Linear'  ],      ['p3',    'RGB / P3'      ],      ['a98',   'RGB / Adobe98' ],      ['pro',   'RGB / ProPhoto'],      ['r2020', 'RGB / Rec.2020'],      ['hclok', 'HCL / ok'      ],     ['hclab', 'HCL / ab'      ],     ['hcluv', 'HCL / uv'      ],     ['oklab', 'okLab'         ],     ['lab',   'Lab'           ],     ['luv',   'Luv'           ],     ['xyz',   'XYZ'           ],     ['xyz50', 'XYZ / D50'     ],     ['xyz65', 'XYZ / D65'     ] ];    function n133     (index) { return r131[index][0]; } function colorSpaceName (index) { return r131[index][1]; } function r4217(space) { return r131.findIndex(s => s[0] == space); }    class a132 {     hex   = Object.freeze( 0);     rgb   = Object.freeze( 1);     hsl   = Object.freeze( 2);     hsv   = Object.freeze( 3);     lin   = Object.freeze( 4);     p3    = Object.freeze( 5);     a98   = Object.freeze( 6);     pro   = Object.freeze( 7);     r2020 = Object.freeze( 8);     hclok = Object.freeze( 9);     hclab = Object.freeze(10);     hcluv = Object.freeze(11);     oklab = Object.freeze(12);     lab   = Object.freeze(13);     luv   = Object.freeze(14);     xyz   = Object.freeze(15);     xyz50 = Object.freeze(16);     xyz65 = Object.freeze(17); }    class Color extends Float32Array {     get r() { return this[0]; }     get g() { return this[1]; }     get b() { return this[2]; }     get a() { return this[3]; }     get s() { return this[4]; }      set r(r) { this[0] = r; }     set g(g) { this[1] = g; }     set b(b) { this[2] = b; }     set a(a) { this[3] = a; }     set s(s) { this[4] = s; }        constructor(c = null)     {         super(5);           if (c)         {             this.r = c.r;             this.g = c.g;             this.b = c.b;             this.a = c.a;             this.s = c.s;         }         else         {             this.r = 0;             this.g = 0;             this.b = 0;             this.a = 0;             this.s = a132.rgb;         }     } }


const s76 = 0.001;    function m146(rgb) {     const _space = 'rgb';      return [         _space,          a4268(rgb[0], _space, 0),          a4268(rgb[1], _space, 1),          a4268(rgb[2], _space, 2) ];  }    function z147(space, c1, c2, c3) {     const _space = n133(space.value);      return [         _space,          a4268(c1.value, _space, 0),          a4268(c2.value, _space, 1),          a4268(c3.value, _space, 2) ];  }    function b148(c) {     return isNaN(c[1])         || isNaN(c[2])         || isNaN(c[3]); }    function c149(col, lim = s76) {     return p75(j4287(col), lim); }    function k150(col, lim = s76) {     return q78(j4287(col), lim); }


const rgb_NaN = [     Number.NaN,     Number.NaN,     Number.NaN ];  const rgba_NaN = [     Number.NaN,     Number.NaN,     Number.NaN,     Number.NaN ];   const rgb_display_NaN  = [1, 0, 1]; const rgba_display_NaN = [1, 0, 1, 1];  const rgbInvalid  = [0xff, 0, 0xff]; const rgbaInvalid = [0xff, 0, 0xff, 0xff];   const x3909 = Object.freeze([     'rgb',     Number.NaN,     Number.NaN,     Number.NaN ]);   const transparent = [0, 0, 0, 0];   const TRANSPARENT_THRESHOLD_DARK  = 0.45; const TRANSPARENT_THRESHOLD_LIGHT = 0.45;  const getTransparentThreshold = () =>      g4102     ? TRANSPARENT_THRESHOLD_DARK     : TRANSPARENT_THRESHOLD_LIGHT;            const CAT = [[ 0.7328, 0.4296, -0.1624],              [-0.7036, 1.6975,  0.0061],              [ 0.0030, 0.0136,  0.9834]];  const invCAT = h889(CAT);   const M1 = [[ 0.8189330101, 0.3618667424, -0.1288597137 ],             [ 0.0329845436, 0.9293118715,  0.0361456387 ],             [ 0.0482003018, 0.2643662691,  0.6338517070 ]];  const invM1 = h889(M1);    function xy2xyz(x, y, Y = 1)  {     let X = (x / y) * Y;     let Z = ((1 - x - y) / y) * Y;          let N = X + Y + Z;      return [X / N,              Y / N,              Z / N]; }    function i73(rgb)  {     return isNaN(rgb[0])         || isNaN(rgb[1])         || isNaN(rgb[2]); }    function w74(rgba)  {     return isNaN(rgba[0])         || isNaN(rgba[1])         || isNaN(rgba[2])         || isNaN(rgba[3]); }    function p75(rgb, lim = s76) {     return rgb[0] > -lim && rgb[0] < 1 + lim          && rgb[1] > -lim && rgb[1] < 1 + lim          && rgb[2] > -lim && rgb[2] < 1 + lim; }    function w77(rgba, lim = s76) {     return rgba[0] > -lim && rgba[0] < 1 + lim          && rgba[1] > -lim && rgba[1] < 1 + lim          && rgba[2] > -lim && rgba[2] < 1 + lim         && rgba[3] > -lim && rgba[3] < 1 + lim; }    function q78(rgb, lim = s76) {     return !i73  (rgb)         &&  p75(rgb, lim); }    function o79(rgba, lim = s76) {     return !w74  (rgba)         &&  w77(rgba, lim); }    function i80(rgb) {     return [         Math.min(Math.max(0, rgb[0]), 1),         Math.min(Math.max(0, rgb[1]), 1),         Math.min(Math.max(0, rgb[2]), 1) ]; }    function n81(h82, s83, t) {     return [ q1033(h82[0], s83[0], t),              q1033(h82[1], s83[1], t),              q1033(h82[2], s83[2], t) ]; }    function a84(q3897, rgba2, t) {     return [ q1033(q3897[0], rgba2[0], t),              q1033(q3897[1], rgba2[1], t),              q1033(q3897[2], rgba2[2], t),              q1033(q3897[3], rgba2[3], t) ]; }    function u85(h82, s83) {     return [ h82[0] + s83[0],              h82[1] + s83[1],              h82[2] + s83[2] ]; }    function rgbaAdd(q3897, rgba2) {     return [ q3897[0] + rgba2[0],              q3897[1] + rgba2[1],              q3897[2] + rgba2[2],              q3897[3] + rgba2[3] ]; }    function g86(h82, s83) {     return [ h82[0] - s83[0],              h82[1] - s83[1],              h82[2] - s83[2] ]; }    function q87(rgb, s) {     return [ rgb[0] * s,              rgb[1] * s,              rgb[2] * s ]; }    function rgbaMuls(rgba, s) {     return [ rgba[0] * s,              rgba[1] * s,              rgba[2] * s,              rgba[3] * s ]; }    function f88(h82, s83) {     return [ (h82[0] + s83[0]) / 2,              (h82[1] + s83[1]) / 2,              (h82[2] + s83[2]) / 2 ]; }    function w89(h82, s83) {     return [ Math.max(h82[0], s83[0]),              Math.max(h82[1], s83[1]),              Math.max(h82[2], s83[2]) ]; }    function c90(col, p) {     return [         Math.pow(col[0], p),          Math.pow(col[1], p),          Math.pow(col[2], p) ] }    function f91(cones) {     return cones.l == 1          && cones.m == 1          && cones.s == 1; }    function n92(rgb) {     return '{' + Math.round(rgb[0] * 255) + ', '                + Math.round(rgb[1] * 255) + ', '                + Math.round(rgb[2] * 255) + '}'; }    function j93(r, g, b, a) {     if (a !== undefined)     {         return 'rgba('             + Math.round(r * 0xff) + ', '             + Math.round(g * 0xff) + ', '             + Math.round(b * 0xff) + ', '             + a + ')';     }     else     {         return 'rgb('             + Math.round(r * 0xff) + ', '             + Math.round(g * 0xff) + ', '             + Math.round(b * 0xff) + ')';     } }    function w94(r, g, b) {     return j93(r, g, b, 1); }    function k95(rgb) {     return j93(rgb[0], rgb[1], rgb[2], 1); }    function h96(r, g, b, a) {     return j93(r, g, b, a); }    function b97(rgba) {     return j93(rgba[0], rgba[1], rgba[2], rgba[3]); }    function w98(rgb, a = 1) {     return j93(rgb[0], rgb[1], rgb[2], a); }    function d99(rgb_) {     return rgb_.length == 3          ? [...rgb_, 1]          : rgb_; }    function m100(rgb, a = 1) {     return [rgb[0], rgb[1], rgb[2], a]; }    function e101(rgb, threshold = 0.71) {     return q37(rgb)[2] < threshold; }    function isLight(rgb, threshold = 0.71) {     return !e101(rgb, threshold); }    function q105(rgba, v) {     return [         rgba[0] * v,         rgba[1] * v,         rgba[2] * v,         rgba[3] * v ]; }    function p106(rgba, v) {     return [         rgba[0] / v,         rgba[1] / v,         rgba[2] / v,         rgba[3] / v ]; }    function f107(v103, y104) {     return Math.max(Math.max(Math.max(         Math.abs(y104[0] - v103[0]),         Math.abs(y104[1] - v103[1])),         Math.abs(y104[2] - v103[2]))); }    function h108(h82, s83) {     return Math.abs(h82[0] - s83[0]) < s76         && Math.abs(h82[1] - s83[1]) < s76         && Math.abs(h82[2] - s83[2]) < s76;         }    function n109(style)  {     f4110.fillStyle = style;     f4110.fillRect(0, 0, 1, 1);      return p106(f4110.getImageData(0, 0, 1, 1).data, 0xFF); }    function k110(b111, style)  {     f4110.fillStyle = y1499(b111, style);     f4110.fillRect(0, 0, 1, 1);      return p106(f4110.getImageData(0, 0, 1, 1).data, 0xFF); }    function t112(rgb, opacity = 1) {     return !i73(rgb)            ? (opacity < getTransparentThreshold()               ? (g4102    ? [1, 1, 1, 0.75] : [0, 0, 0, 0.75])               : (e101(rgb) ? [1, 1, 1, 0.75] : [0, 0, 0, 0.75]))            : (g4102 ? x2428 : z2427); }    function o113(rgb) {     return !i73(rgb)          ? (e101(rgb)  ? [1, 1, 1, 0.133] : [0, 0, 0, 0.161])            : (g4102 ? [1, 1, 1, 0.031] : [0, 0, 0, 0.031]);   }    function h114(t115) {     let h3944,          l3945;                   const f3946 = o113(t115);            if (!i73(t115))     {         const p3947 = q37(t115);          const e3948 = [...p3947];         const h3949 = [...p3947];          e3948[0] += 1/12;  if (e3948[0] > 1) e3948[0] -= 1;         h3949[0] -= 1/12;  if (h3949[0] < 0) h3949[0] += 1;           const i3950 = m100(q123(z34(e3948)), 0.35);         const z3951 = m100(q123(z34(h3949)), 0.35);          const factor   = q119(t115);          const colWarn1 = a84(f3946, i3950, factor);         const colWarn2 = a84(f3946, z3951, factor);                  h3944     = b97(colWarn1);         l3945     = b97(colWarn2);     }     else     {         h3944 = b97(f3946);         l3945 = b97(f3946);     }       return [h3944,              l3945]; }    function z116(i, h117, n118) {     return 'repeating-linear-gradient('             + '-45deg, '             + 'transparent 0 ' + i   + 'px,'              +  h117 + ' '    + i   + 'px ' + i*2 +'px,'             + 'transparent '   + i*2 + 'px ' + i*3 +'px,'             +  n118 + ' '    + i*3 + 'px ' + i*4 +'px)'; }    function q119(t115) {     let dr, dg, db;      if (t115[0] < 0) dr = -t115[0]; else if (t115[0] > 1) dr = t115[0] - 1; else dr = 0;     if (t115[1] < 0) dg = -t115[1]; else if (t115[1] > 1) dg = t115[1] - 1; else dg = 0;     if (t115[2] < 0) db = -t115[2]; else if (t115[2] > 1) db = t115[2] - 1; else db = 0;          const d   = [dr, dg, db].sort()[1];     const avg = (dr + dg + db) / 3;      const factor = Math.min((d + avg) / 2, 1);                                                              return factor; }    function e120(s121) {     let b3952 = [...s121];              const factor = q119(s121);      if (factor > 0)     {         const hcl = q37(q123(s121));         hcl[1] /= 2;                   b3952 = n81(s121, l129(z34(hcl)), factor);     }      return b3952; }    function z122(rgba) {     return !w74(rgba)          ? (e101(rgba)  ? '#ffffff29' : '#00000022')          : (g4102 ? '#ffffff08' : '#00000006');  }    function q123(w124) {     const rgb = [...w124];      rgb[0] = Math.min(Math.max(0, rgb[0]), 1);        rgb[1] = Math.min(Math.max(0, rgb[1]), 1);        rgb[2] = Math.min(Math.max(0, rgb[2]), 1);       return rgb; }    function q125(val) {     return Math.min(Math.max(0, val), 1); }    function s126(o127, m128, val) {     const col = [...o127];     col[m128] = val;     return col; }    function l129(rgb) {     let hcl = q37(rgb);      let w3953 = 10000;      while (!p75(z34(hcl))          && hcl[1] > 0.001          && w3953-- > 0)         hcl[1] -= 0.001;      rgb = z34(hcl);      rgb[0] = Math.min(Math.max(0, rgb[0]), 1);        rgb[1] = Math.min(Math.max(0, rgb[1]), 1);        rgb[2] = Math.min(Math.max(0, rgb[2]), 1);       return rgb; }    function i130(rgba) {     if (!w74(rgba))         return 'transparent';     else     {         return g4102             ? 'rgba(56, 56, 56, 0.95)'             : 'rgba(255, 255, 255, 0.95)';     } }    function addHueHsl(rgb, d, min = 0, max = Tau) {     const hsl = u48(rgb);      return u49(         trimAngle(hsl[0] + d, min, max),         hsl[1],          hsl[2]); }    function addHueHclok(rgb, d, min = 0, max = Tau) {     const hcl = q37(rgb);      return a35(         trimAngle(hcl[0] + d, min, max),         hcl[1],          hcl[2]); }    function addHueHclab(rgb, d, min = 0, max = Tau) {     const hcl = p42(rgb);      return hclab2rgb_(         trimAngle(hcl[0] + d, min, max),         hcl[1],          hcl[2]); }    function addHueHcluv(rgb, d, min = 0, max = Tau) {     const hcl = j46(rgb);      return hcluv2rgb_(         trimAngle(hcl[0] + d, min, max),         hcl[1],          hcl[2]); }    function addHclok(rgb, hcl_chan, d) {     const hcl = q37(rgb);      if (hcl_chan == 0)         hcl[0] = trimAngle(hcl[0] + d, 0, Tau);     else         hcl[hcl_chan] += d;      return z34(hcl); }    function multHclok(rgb, hcl_chan, f) {     const hcl = q37(rgb);      if (hcl_chan == 0)         hcl[0] = trimAngle(hcl[0] * f, 0, Tau);     else         hcl[hcl_chan] *= f;      return z34(hcl); }    function rgbSaturate(rgb, l) { return multHclok(rgb, 1, l); } function rgbLighten (rgb, l) { return multHclok(rgb, 2, l); }    function j102(v103, y104) {     return Math.sqrt(         sqr(y104[0] - v103[0])       + sqr(y104[1] - v103[1])       + sqr(y104[2] - v103[2])); }    function deltaE(h82, s83) {     return deltaE00(h82, s83); }    function deltaE76(h82, s83, _rgb2lab = p4076)  {     const lab1 = _rgb2lab(h82);     const lab2 = _rgb2lab(s83);      return j102(lab1, lab2); }    function deltaE94(h82, s83, kH = 1, kC = 1, kL = 1, _rgb2lab = p4076)  {     const [L1, a1, b1] = _rgb2lab(h82);     const [L2, a2, b2] = _rgb2lab(s83);          const C1 = Math.sqrt(a1*a1 + b1*b1);     const C2 = Math.sqrt(a2*a2 + b2*b2);     const dL = L2 - L1;     const dC = C2 - C1;     const da = a2 - a1;     const db = b2 - b1;     const dH = Math.sqrt(da*da + db*db - dC*dC);          const SL = 1;     const SC = 1 + 0.045 * C1;     const SH = 1 + 0.015 * C1;          const deltaE = Math.sqrt(         sqr(dL / (kL * SL)) +         sqr(dC / (kC * SC)) +         sqr(dH / (kH * SH)));          return deltaE; }    function deltaE00(h82, s83, kH = 1, kC = 1, kL = 1, _rgb2lab = p4076) {     const lab1        = _rgb2lab(h82);     const lab2        = _rgb2lab(s83);      const L1          = lab1[0], a1 = lab1[1], b1 = lab1[2];     const L2          = lab2[0], a2 = lab2[1], b2 = lab2[2];      const avgLPrime   = (L1 + L2) / 2;     const C1          = Math.sqrt(a1 * a1 + b1 * b1);     const C2          = Math.sqrt(a2 * a2 + b2 * b2);     const avgC        = (C1 + C2) / 2;     const G           = 0.5 * (1 - Math.sqrt(Math.pow(avgC, 7) / (Math.pow(avgC, 7) + Math.pow(25, 7))));          const a1Prime     = a1 * (1 + G);     const a2Prime     = a2 * (1 + G);     const C1Prime     = Math.sqrt(a1Prime * a1Prime + b1 * b1);     const C2Prime     = Math.sqrt(a2Prime * a2Prime + b2 * b2);          const h1Prime     = Math.atan2(b1, a1Prime) * (180 / Math.PI);     const h2Prime     = Math.atan2(b2, a2Prime) * (180 / Math.PI);          const deltaLPrime = L2 - L1;     const deltaCPrime = C2Prime - C1Prime;     const deltahPrime = 2 * Math.sqrt(C1Prime * C2Prime) * Math.sin(((h2Prime - h1Prime) / 2) * (Math.PI / 180));      const avgCPrime = (C1Prime + C2Prime) / 2;     const avghPrime =         Math.abs(h1Prime - h2Prime) > 180             ? (h1Prime + h2Prime + 360) / 2             : (h1Prime + h2Prime) / 2;           const SL = 1 + (0.015 * sqr(avgLPrime - 50)) / Math.sqrt(20 + sqr(avgLPrime - 50));     const SC = 1 + 0.045 * avgCPrime;     const SH = 1 + 0.015 * avgCPrime * (1 - 0.17 * Math.cos(avghPrime - 30) + 0.24 * Math.cos(2 * avghPrime) + 0.32 * Math.cos(3 * avghPrime + 6) - 0.20 * Math.cos(4 * avghPrime - 63));      const RT = -2 * Math.sqrt(Math.pow(avgCPrime, 7) / (Math.pow(avgCPrime, 7) + Math.pow(25, 7))) * Math.sin(60 * Math.exp(-sqr((avghPrime - 275) / 25)) * (Math.PI / 180));          const deltaE = Math.sqrt(           sqr(deltaLPrime / (kL * SL)) +           sqr(deltaCPrime / (kC * SC)) +           sqr(deltahPrime / (kH * SH)) +         RT * (deltaCPrime / (kC * SC)) * (deltahPrime / (kH * SH)));          return deltaE; }    function deltaECMC(h82, s83, kC = 1, kL = 2, _rgb2lab = p4076)  {     const [L1, a1, b1] = _rgb2lab(h82);     const [L2, a2, b2] = _rgb2lab(s83);          const C1     = Math.sqrt(a1*a1 + b1*b1);     const C2     = Math.sqrt(a2*a2 + b2*b2);     const deltaL = L2 - L1;     const deltaC = C2 - C1;     const da     = a2 - a1;     const db     = b2 - b1;     const deltaH = Math.sqrt(da*da + db*db - deltaC*deltaC);      const SL     = L1 < 16 ? 0.511 : (0.040975 * L1) / (1 + 0.01765 * L1);     const SC     = 0.0638 * C1 / (1 + 0.0131 * C1) + 0.638;     const SH     = SC * (1 + 0.0131 * C1);      return Math.sqrt(           sqr(deltaL / (kL * SL))         + sqr(deltaC / (kC * SC))         + sqr(deltaH / SH)); }    function deltaEITU(h82, s83)  {     const linear1 = h82.map(v => q36.degamma(v));     const linear2 = s83.map(v => q36.degamma(v));      return j102(linear1, linear2); }    function isColorType(type) {     return COLOR_VALUES.includes(type); }    function isColorTypeOnHeader(type, node) {     return isColorType(type)         && COLOR_HEADER_TYPES.includes(node.type); }    function rgbFromColorValue(value) {     c950(          value,          'rgbFromColorValue() requires a valid value');       if (    value.type == j1167          && !i73(value.t3339()))          return value.t3339();      else if ( value.type == d1177            && !i73(value.color.t3339()))          return value.color.t3339();      else if ( value.type == b1180            &&  value.fills.items.length > 0           && !i73(value.fills.items.at(-1).color.t3339()))          return value.fills.items.at(-1).color.t3339();      else if ( value.type == c1186            && !w74(value.d99()))          return m100(value.d99());      else if ( value.type == i1183            && !i73(value.fill.color.t3339()))          return m100(value.fill.color.t3339());       return rgb_NaN; }    function setSvgLinearGradientStroke(svg, target, color1, color2, x1, y1, x2, y2, contrast = 0)  {     if (!(svg instanceof SVGElement))         throw new Error('\'svg\' must be an SVG element');           let defs = svg.querySelector('defs');      if (!defs)      {         defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        svg.insertBefore(defs, svg.firstChild);     }       const existingGradients = defs.querySelectorAll('linearGradient');     const gradientId        = `svgLinearGradient-${target.curveId}`;          existingGradients.forEach(gradient =>      {         if (gradient.id == gradientId)             gradient.remove();     });       const linearGradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
     linearGradient.setAttribute('id', gradientId);      linearGradient.setAttribute('x1', x1 + '%');     linearGradient.setAttribute('y1', y1 + '%');     linearGradient.setAttribute('x2', x2 + '%');     linearGradient.setAttribute('y2', y2 + '%');           const contrastDist = 35;      const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
    stop1.setAttribute('offset', '0%');     stop1.setAttribute('stop-color', color1);      // const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
               // const stop3 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
               const stop4 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
    stop4.setAttribute('offset', '100%');     stop4.setAttribute('stop-color', color2);        linearGradient.appendChild(stop1);               linearGradient.appendChild(stop4);      defs.appendChild(linearGradient);       target.style.stroke = `url(#${gradientId})`;       return gradientId; }    function getChannelNamesFromSpace(space) {     switch (space)     {     case 'hex':   return ['r', 'g', 'b'];     case 'rgb':   return ['r', 'g', 'b'];     case 'lin':   return ['r', 'g', 'b'];     case 'p3':    return ['r', 'g', 'b'];     case 'a98':   return ['r', 'g', 'b'];     case 'pro':   return ['r', 'g', 'b'];     case 'r2020': return ['r', 'g', 'b'];     case 'hsl':   return ['h', 's', 'l'];     case 'hsv':   return ['h', 's', 'b'];     case 'hclok': return ['h', 'c', 'l'];     case 'hclab': return ['h', 'c', 'l'];     case 'hcluv': return ['h', 'c', 'l'];     case 'oklab': return ['l', 'a', 'b'];     case 'lab':   return ['l', 'a', 'b'];     case 'luv':   return ['l', 'u', 'v'];     case 'xyz':   return ['x', 'y', 'z'];     case 'xyz50': return ['x', 'y', 'z'];     case 'xyz65': return ['x', 'y', 'z'];     }      console.error('invalid color space \'' + space + '\'');     return ['c1', 'c2', 'c3']; }


// https://ixora.io/projects/colorblindness/color-blindness-simulation-research/
  const d135 = q59(w70([1, 1, 1])); const d136 = q59(w70([0, 0, 1])); const m137 = q59(w70([1, 0, 0]));  const t138 = (d135[2]*d136[0] - d136[2]*d135[0]) / (d135[2]*d136[1] - d136[2]*d135[1]); const k139 = (d135[1]*d136[0] - d136[1]*d135[0]) / (d135[1]*d136[2] - d136[1]*d135[2]);  const e140 = (d135[2]*d136[1] - d136[2]*d135[1]) / (d135[2]*d136[0] - d136[2]*d135[0]); const a141 = (d135[0]*d136[1] - d136[0]*d135[1]) / (d135[0]*d136[2] - d136[0]*d135[2]);  const i142 = (d135[1]*m137[2] - m137[1]*d135[2]) / (d135[1]*m137[0] - m137[1]*d135[0]); const r143 = (d135[0]*m137[2] - m137[0]*d135[2]) / (d135[0]*m137[1] - m137[0]*d135[1]);  const l144 = d135[0] / d135[2]; const a145 = d135[1] / d135[2];   // this is a number I made up following the information here: https://www.color-blindness.com/2007/07/20/monochromacy-complete-color-blindness/
    const i3954 = 0.88;   function b134(rgb, l, m, s, cs = q36) {     if (   l == 0         && m == 0         && s == 0)     {                   const a =                cs.Y[0] * rgb[0]             + cs.Y[1] * rgb[1]             + cs.Y[2] * rgb[2];          rgb = [a, a, a];     }     else     {         const xyz = y69(rgb, cs);         const lms = q59(xyz);          const a =                cs.Y[0] * rgb[0]             + cs.Y[1] * rgb[1]             + cs.Y[2] * rgb[2];          const lm = Math.min(l + m, 1);           const lms_ = [             lms[0] + q1033(i3954 * (l144*lms[2] - lms[0]), (1 - l) * ((t138*lms[1] + k139*lms[2]) - lms[0]), lm),             lms[1] + q1033(i3954 * (a145*lms[2] - lms[1]), (1 - m) * ((e140*lms[0] + a141*lms[2]) - lms[1]), lm),             lms[2] + q1033(0,                     q1033(s, 1 - s, lm) * ((i142*lms[0] + r143*lms[1]) - lms[2]), lm) ];          const xyz_ = g60(lms_);               rgb  = g71(xyz_, cs);           let bm_ = d55(rgb, cs);         bm_[0] = q1033(a, bm_[0], lm);         rgb = y56(bm_, cs);                   rgb = n81(             [a, a, a],              rgb,              Math.min(s + lm, 1));     }           return rgb; }


function r2639(c) {     return Math.round(c * 0xff)         .toString(16)         .padStart(2, '0')         .toUpperCase();     }    function z151(rgb, hash = false) {     let hex =           r2639(rgb[0])         + r2639(rgb[1])         + r2639(rgb[2]);      return (hash ? '#' : '') + hex; }    function o152(rgba, hash = false) {     let hex =           r2639(rgba[0])         + r2639(rgba[1])         + r2639(rgba[2])         + r2639(rgba[3]);      return (hash ? '#' : '') + hex; }    function f153(hex)  {     return hex.indexOf(m962) > -1             ? rgb_NaN             : t155(hex); }    function y154(hex)  {     return hex.indexOf(m962) > -1             ? rgba_NaN             : f156(hex); }    function t155(hex) {     if (hex[0] == '#')         hex = hex.substring(1);               let rgb = [];      if (hex.length >= 6)     {         rgb[0] = parseInt(hex.slice(0, 2), 16);          rgb[1] = parseInt(hex.slice(2, 4), 16);          rgb[2] = parseInt(hex.slice(4, 6), 16);      }     else if (hex.length >= 3)     {         rgb[0] = parseInt(hex[0], 16) * 0x11;          rgb[1] = parseInt(hex[1], 16) * 0x11;          rgb[2] = parseInt(hex[2], 16) * 0x11;      }     else if (hex.length == 2)     {         let v = parseInt(hex, 16);                  rgb[0] = v;          rgb[1] = v;          rgb[2] = v;      }     else if (hex.length == 1)     {         let v = parseInt(hex, 16);                  rgb[0] = v * 0x11;          rgb[1] = v * 0x11;          rgb[2] = v * 0x11;      }     else if (hex.length == 0)     {         rgb = null;                                 }       if (rgb)     {         rgb[0] /= 0xff;         rgb[1] /= 0xff;         rgb[2] /= 0xff;     }           return rgb; }    function f156(hex) {     if (hex[0] == '#')         hex = hex.substring(1);               let rgba = [];      if (hex.length >= 8)     {         rgba[0] = parseInt(hex.slice(0, 2), 16);          rgba[1] = parseInt(hex.slice(2, 4), 16);          rgba[2] = parseInt(hex.slice(4, 6), 16);          rgba[3] = parseInt(hex.slice(6, 8), 16);      }     else if (hex.length >= 6)     {         rgba[0] = parseInt(hex.slice(0, 2), 16);          rgba[1] = parseInt(hex.slice(2, 4), 16);          rgba[2] = parseInt(hex.slice(4, 6), 16);          rgba[3] = 0xff;      }     else if (hex.length >= 4)     {         rgba[0] = parseInt(hex[0], 16) * 0x11;          rgba[1] = parseInt(hex[1], 16) * 0x11;          rgba[2] = parseInt(hex[2], 16) * 0x11;          rgba[3] = parseInt(hex[3], 16) * 0x11;      }     else if (hex.length == 3)     {         rgba[0] = parseInt(hex[0], 16) * 0x11;          rgba[1] = parseInt(hex[1], 16) * 0x11;          rgba[2] = parseInt(hex[2], 16) * 0x11;          rgba[3] = 0xff;      }     else if (hex.length == 2)     {         let v = parseInt(hex, 16);                  rgba[0] = v;          rgba[1] = v;          rgba[2] = v;          rgba[3] = 0xff;      }     else if (hex.length == 1)     {         let v = parseInt(hex, 16);                  rgba[0] = v * 0x11;          rgba[1] = v * 0x11;          rgba[2] = v * 0x11;          rgba[3] = 0xff;      }     else if (hex.length == 0)     {         rgba = null;                                          }       if (rgba)     {         rgba[0] /= 0xff;         rgba[1] /= 0xff;         rgba[2] /= 0xff;         rgba[3] /= 0xff;     }       return rgba; }


function s157(y158, h159) {     if (    i73  (y158)         || !p75(y158))         return Number.NaN;      const f164 = q36.luminance(y158);     const  t165 = q36.luminance(h159);      return (         t165 > f164         ? ( t165 + 0.05) / (f164 + 0.05)         : (f164 + 0.05) / ( t165 + 0.05)); }    function x160(ratio) {          if (ratio >= 7  ) return 'AAA';     else if (ratio >= 4.5) return 'AA';     else if (ratio >= 3  ) return 'AA<sub>L</sub>';     else                   return ''; }    function b161(y158, h159) {     if (!q78(y158))         return Number.NaN;      return w163(         t162(y158),         t162(h159)); }    // I copied the code below from https://github.com/Myndex/c4215-APCA/blob/master/WEBTOOLS/APCA/JS/DEV.0.1.2.G_SAPCsRGB.js
  const d2630     = 2.4;          const r4196        = 0.2126729,        g4197        = 0.7151522,        n4198        = 0.0721750;      const normBg      = 0.56,        normTxt     = 0.57,       revTxt      = 0.62,       revBg       = 0.65;      const e4203     = 0.022,       blkClip     = 1.414,        l4205    = 1.14,       r4206    = 1.14,       n4207 = 0.035991,       r4208 = 0.035991,       p4209 = 27.7847239587675,       k4210 = 27.7847239587675,       t4211 = 0.027,       z4212 = 0.027,       z4213      = 0.001,       d4214   = 0.0005;    function t162(rgb)  {                     return r4196 * Math.pow(rgb[0], d2630)           + g4197 * Math.pow(rgb[1], d2630)          + n4198 * Math.pow(rgb[2], d2630); }    function w163(f164, t165) {     let sapc           = 0;      let n4216 = 0;       f164 =          f164 > e4203          ? f164          : f164 + Math.pow(e4203 - f164, blkClip);              t165 =          t165 > e4203          ? t165          : t165 + Math.pow(e4203 - t165, blkClip);      if (Math.abs(t165 - f164) < d4214)           return 0;        if (t165 > f164)      {           sapc = (Math.pow(t165, normBg) - Math.pow(f164, normTxt)) * l4205;          n4216 =              sapc < z4213              ? 0              : sapc < n4207               ? sapc - sapc * p4209 * t4211                : sapc - t4211;     }      else      {           sapc = (Math.pow(t165, revBg) - Math.pow(f164, revTxt)) * r4206;          n4216 =              sapc > -z4213              ? 0              : sapc > -r4208                ? sapc - sapc * k4210 * z4212                : sapc + z4212;     }       return n4216 * 100; }


const k4219  = [255, 255, 255]; const c4220  = [360, 100, 100]; const n4221  = [360, 100, 100]; const a4222  = [100, 100, 100]; const xyzFactor  = [100, 100, 100];      const c4223   = [255, 255, 255];    const x4224   = [360, 100, 100];   const e4225 = [360,  50, 100]; const d4226 = [360, 400, 100]; const m4227 = [360, 330, 100];   const w4228 = [100,  30,  30]; const s4229   = [100, 100, 100]; const x4230   = [100, 150, 150];   const xyzScale   = [100, 100, 100];     function c4231(space) {     switch (space)     {         case 'hex':         case 'rgb':         case 'lin':         case 'p3':         case 'a98':         case 'pro':         case 'r2020':  return k4219;          case 'hsv':         case 'hsl':    return c4220;          case 'hclok':         case 'hclab':         case 'hcluv':  return n4221;          case 'oklab':         case 'lab':         case 'luv':    return a4222;          case 'xyz':         case 'xyz50':         case 'xyz65':  return xyzFactor;                  default:       h951('invalid color factor from space \''+space+'\''); break;     } }    function l4232(col, space) {     let scale;      switch (space)     {         case 'hex':         case 'rgb':         case 'lin':         case 'p3':         case 'a98':         case 'pro':         case 'r2020': scale = c4223;   break;          case 'hsv':         case 'hsl':   scale = x4224;   break;          case 'hclok': scale = e4225; break;         case 'hclab': scale = d4226; break;         case 'hcluv': scale = m4227; break;          case 'oklab': scale = w4228; break;         case 'lab':   scale = s4229;   break;         case 'luv':   scale = x4230;   break;          case 'xyz':         case 'xyz50':         case 'xyz65': scale = xyzScale;   break;     }      return [         col[0] * scale[0],         col[1] * scale[1],         col[2] * scale[2] ]; }    function q4233(rgb) {     return [ rgb[0] / 255,              rgb[1] / 255,              rgb[2] / 255 ]; }    function z4234(rgb, dec = 0) {     return [ d1014(rgb[0] * 255, dec),              d1014(rgb[1] * 255, dec),              d1014(rgb[2] * 255, dec) ]; }    function e4235(node, space) {     switch (space)     {         case 'hex':   a4237   (node); break;          case 'rgb':         case 'lin':         case 'p3':         case 'a98':         case 'pro':         case 'r2020': o4238   (node); break;          case 'hsv':   z4239   (node); break;         case 'hsl':   q4240   (node); break;          case 'hclok': c4241 (node); break;         case 'hclab': z4242 (node); break;         case 'hcluv': b4243 (node); break;          case 'oklab': s4244 (node); break;         case 'lab':   e4245   (node); break;         case 'luv':   s4246   (node); break;          case 'xyz':             case 'xyz50':          case 'xyz65': switchToXyz   (node); break;     }      node.g4236(); }    function a4237  (node) { y4247   (node); a4257(node); } function o4238  (node) { y4247   (node);                        }  function z4239  (node) { z4248   (node, 'B');                   } function q4240  (node) { z4248   (node, 'L');                   }               function c4241(node) { j4249(node);                        } function z4242(node) { m4250(node);                        } function b4243(node) { a4251(node);                        }               function s4244(node) { k4252 (node, 'a', 'b');              } function e4245  (node) { c4253   (node, 'a', 'b');              } function s4246  (node) { r4254   (node, 'u', 'v');              }  function switchToXyz  (node) { switchToXyzControls   (node);                        }       function y4247(node) {     k4256(node,          'R', 0, c4223[0], '', false,          'G', 0, c4223[1],          'B', 0, c4223[2]);        node.e4261.h4362[0].min =      node.q4262.h4362[0].min =      node.z4263.h4362[0].min = Number.MIN_SAFE_INTEGER;       node.e4261.h4362[0].max =      node.q4262.h4362[0].max =      node.z4263.h4362[0].max = Number.MAX_SAFE_INTEGER;       showRgbControlHex(node, false);     }    function z4248(node, v_or_l)  {      k4256(node,          'H',    0, x4224[0], '°', true,           'S',    0, x4224[1],          v_or_l, 0, x4224[2]);        node.e4261.h4362[0].x808 = -4;      node.q4262.h4362[0].min =      node.z4263.h4362[0].min = Number.MIN_SAFE_INTEGER;       node.q4262.h4362[0].max =      node.z4263.h4362[0].max = Number.MAX_SAFE_INTEGER;       showRgbControlHex(node, false);  }    function switchToHclControls(node, scale)  {      k4256(node,          'H', 0, scale[0], '°', true,           'C', 0, scale[1],          'L', 0, scale[2]);        node.e4261.h4362[0].x808 = -4;      node.q4262.h4362[0].min =      node.z4263.h4362[0].min = Number.MIN_SAFE_INTEGER;       node.q4262.h4362[0].max =      node.z4263.h4362[0].max = Number.MAX_SAFE_INTEGER;       showRgbControlHex(node, false);  }    function j4249(node) { switchToHclControls(node, e4225); } function m4250(node) { switchToHclControls(node, d4226); } function a4251(node) { switchToHclControls(node, m4227); }    function v4255(node, c2, c3, scale) {      k4256(node,          'L', 0,        scale[0], '', false,           c2, -scale[1], scale[1],          c3, -scale[2], scale[2]);        showRgbControlHex(node, false);  }    function k4252(node) { v4255(node, 'a', 'b', w4228); } function c4253  (node) { v4255(node, 'a', 'b', s4229  ); } function r4254  (node) { v4255(node, 'u', 'v', x4230  ); }    function switchToXyzControls(node)  {      k4256(node,          'X', 0, xyzScale[0], '', false,         'Y', 0, xyzScale[1],          'Z', 0, xyzScale[2]);            node.e4261.h4362[0].min =          node.q4262.h4362[0].min =          node.z4263.h4362[0].min = Number.MIN_SAFE_INTEGER;               node.e4261.h4362[0].max =          node.q4262.h4362[0].max =          node.z4263.h4362[0].max = Number.MAX_SAFE_INTEGER;      }    function showRgbControlHex(node, show) {     node.e4261.h4362[0].q4096 = show;     node.q4262.h4362[0].q4096 = show;     node.z4263.h4362[0].q4096 = show; }    function k4256(node, c1, c1min, c1max, c1suffix, c1wrap, c2, c2min, c2max, c3, c3min, c3max) {     g4258(node);      node.e4261.z3054(c1, false);      node.q4262.z3054(c2, false);      node.z4263.z3054(c3, false);      node.e4261.h4362[0].p806 = c1wrap;     node.e4261.h4362[0].setSuffix(c1suffix, c1suffix != '');      node.e4261.h4362[0].x3219(c1min);      node.q4262.h4362[0].x3219(c2min);     node.z4263.h4362[0].x3219(c3min);          node.e4261.h4362[0].m3220(c1max);      node.q4262.h4362[0].m3220(c2max);      node.z4263.h4362[0].m3220(c3max);           node.e4261.f2932();     node.q4262.f2932();     node.z4263.f2932();      node.e4261.h4362[0].x808 = 0; }    function a4257(node) {     i4260(node);      n1504(node.e4261.div, node.s4264);     n1504(node.q4262.div, node.s4264);     n1504(node.z4263.div, node.s4264);              v1503(node.h4265.div, node.s4264); }    function t4259(node) {     i4260(node);      n1504(node.e4261.div,     node.s4264);     n1504(node.q4262.div,     node.s4264);     n1504(node.z4263.div,     node.s4264);          n1504(node.h4265.div, node.s4264); }    function i4260(node) {     for (let i = node.inputs.length-1; i >= 2; i--)         if (node.inputs[i].connected)             y2696(node.inputs[i]);      for (let i = node.outputs.length-1; i >= 2; i--)         for (const input of node.outputs[i].h4266)             y2696(input); }    function g4258(node) {     n1504(node.h4265.div, node.s4264);      v1503(node.e4261.div, node.s4264);     v1503(node.q4262.div, node.s4264);     v1503(node.z4263.div, node.s4264); }    function m146(rgb, space = 'rgb') {     return [         space,         rgb[0],         rgb[1],         rgb[2] ]; }    function a4268(value, space, m128) {     switch (space)     {         case 'hex':         case 'rgb':         case 'lin':         case 'p3':         case 'a98':         case 'pro':         case 'r2020': return y4269(value, m128);          case 'hsv':         case 'hsl':   return w4270 (value, m128);          case 'hclok':         case 'hclab':         case 'hcluv': return c4272 (value, m128);          case 'oklab':         case 'lab':         case 'luv':   return m4271 (value, m128);          case 'xyz':         case 'xyz50':         case 'xyz65': return getNormalValueXyz (value, m128);     } }    function y4269(value, m128) {     switch (m128)     {         case 0: return value / k4219[0];         case 1: return value / k4219[1];          case 2: return value / k4219[2];     } }    function w4270(value, m128) {     switch (m128)     {         case 0: return value / c4220[0];         case 1: return value / c4220[1];          case 2: return value / c4220[2];     } }    function m4271(value, m128) {     switch (m128)     {         case 0: return value / a4222[0];         case 1: return value / a4222[1];          case 2: return value / a4222[2];     } }    function c4272(value, m128) {     switch (m128)     {         case 0: return value / n4221[0];         case 1: return value / n4221[1];          case 2: return value / n4221[2];     } }    function getNormalValueXyz(value, m128) {     switch (m128)     {         case 0: return value / xyzFactor[0];         case 1: return value / xyzFactor[1];          case 2: return value / xyzFactor[2];     } }    function w4273(color) {     return u4274(         color[0],          color[1],          color[2],          color[3]) }    function u4274(space, c1, c2, c3) {     switch (space)     {         case 'hex':         case 'rgb':         case 'lin':         case 'p3':         case 'a98':         case 'pro':         case 'r2020': return z4275(c1, c2, c3);          case 'hsv':         case 'hsl':   return o4276(c1, c2, c3);          case 'hclok':         case 'hclab':         case 'hcluv': return z4277(c1, c2, c3);          case 'oklab':         case 'lab':         case 'luv':   return k4278(c1, c2, c3);          case 'xyz':         case 'xyz50':         case 'xyz65': return getNormalColorXyz(c1, c2, c3);     } }    function z4275(c1, c2, c3) {     return [         c1 / k4219[0],          c2 / k4219[1],          c3 / k4219[2]]; }    function o4276(c1, c2, c3) {     return [         c1 / c4220[0],          c2 / c4220[1],          c3 / c4220[2]]; }    function z4277(c1, c2, c3) {     return [         c1 / n4221[0],          c2 / n4221[1],          c3 / n4221[2]]; }    function k4278(c1, c2, c3) {     return [         c1 / a4222[0],          c2 / a4222[1],          c3 / a4222[2]]; }    function getNormalColorXyz(c1, c2, c3) {     return [         c1 / xyzFactor[0],          c2 / xyzFactor[1],          c3 / xyzFactor[2]]; }    function t4279(color) {     switch (color[0])     {         case 'hex':         case 'rgb':   return l4280('rgb',    color[1], color[2], color[3]);         case 'lin':   return l4280('lin',    color[1], color[2], color[3]);         case 'p3':    return l4280('p3',     color[1], color[2], color[3]);         case 'a98':   return l4280('a98',    color[1], color[2], color[3]);         case 'pro':   return l4280('pro',    color[1], color[2], color[3]);         case 'r2020':  return l4280('r2020', color[1], color[2], color[3]);          case 'hsv':   return e4281('hsv',    color[1], color[2], color[3]);         case 'hsl':   return e4281('hsl',    color[1], color[2], color[3]);          case 'hclok': return n4282('hclok',  color[1], color[2], color[3]);         case 'hclab': return n4282('hclab',  color[1], color[2], color[3]);         case 'hcluv': return n4282('hcluv',  color[1], color[2], color[3]);          case 'oklab': return n4283('oklab',  color[1], color[2], color[3]);         case 'lab':   return n4283('lab',    color[1], color[2], color[3]);         case 'luv':   return n4283('luv',    color[1], color[2], color[3]);          case 'xyz':   return getScaledDataColorXyz('xyz',    color[1], color[2], color[3]);         case 'xyz50': return getScaledDataColorXyz('xyz50',  color[1], color[2], color[3]);         case 'xyz65': return getScaledDataColorXyz('xyzd60', color[1], color[2], color[3]);     } }    function l4280(space, c1, c2, c3) {     return [         space,         c1 * k4219[0],          c2 * k4219[1],          c3 * k4219[2] ]; }    function e4281(space, c1, c2, c3) {     return [         space,         c1 * c4220[0],          c2 * c4220[1],          c3 * c4220[2] ]; }    function n4282(space, c1, c2, c3) {     return [         space,         c1 * n4221[0],          c2 * n4221[1],          c3 * n4221[2] ]; }    function n4283(space, c1, c2, c3) {     return [         space,         c1 * a4222[0],          c2 * a4222[1],          c3 * a4222[2] ]; }    function getScaledDataColorXyz(space, c1, c2, c3) {     return [         space,         c1 * xyzFactor[0],          c2 * xyzFactor[1],          c3 * xyzFactor[2] ]; }    function h3302(node, color) {     const n3303 = n133(node.r3298.value);     node.f3296   = y4288(color, n3303);      node.w3581(node.f3296); }    function g4284(space) {     switch (space)     {         case 'hex':         case 'rgb':            case 'lin':         case 'p3':         case 'a98':         case 'pro':         case 'r2020': return k4219;          case 'hsv':            case 'hsl':   return c4220;          case 'hclok':          case 'hclab':          case 'hcluv': return n4221;          case 'oklab':          case 'lab':          case 'luv':   return a4222;          case 'xyz':          case 'xyz50':          case 'xyz65': return xyzFactor;     }     }    function w4285(space) {     switch (space)     {         case 'hex':         case 'rgb':            case 'lin':         case 'p3':         case 'a98':         case 'pro':         case 'r2020': return c4223;          case 'hsv':            case 'hsl':   return x4224;          case 'hclok': return e4225;         case 'hclab': return d4226;         case 'hcluv': return m4227;          case 'oklab': return w4228;         case 'lab':   return s4229;         case 'luv':   return x4230;          case 'xyz':         case 'xyz50':         case 'xyz65': return xyzScale;     }     }


function r4286(color) {     return [         color[1],          color[2],          color[3]]; }    function j4287(color) {     const col = r4286(color);      switch (color[0])     {         case 'hex':         case 'rgb':   return           col;          case 'lin':   return lin2rgb  (col);         case 'p3':    return z62   (col);         case 'a98':   return a982rgb  (col);         case 'pro':   return pro2rgb  (col);         case 'r2020': return r20202rgb(col);          case 'hsv':   return d54  (col);         case 'hsl':   return x50  (col);          case 'hclok': return z34(col);         case 'hclab': return r40(col);         case 'hcluv': return o44(col);          case 'oklab': return q4080(col);         case 'lab':   return y56  (col);         case 'luv':   return a4073  (col);          case 'xyz':   return g71  (col);         case 'xyz50': return g71  (col, sRGB_D50);         case 'xyz65': return g71  (col);     } }    function y4288(color, n3303) {     switch (n3303)     {         case 'hex':   return d4289    (color, true);          case 'rgb':   return d4289    (color);          case 'lin':   return convert2lin    (color);         case 'p3':    return convert2p3     (color);         case 'a98':   return convert2a98    (color);         case 'pro':   return convert2pro    (color);         case 'r2020': return convert2r2020  (color);          case 'hsv':   return u4290    (color);         case 'hsl':   return g4291    (color);          case 'hclok': return m4295  (color);         case 'hclab': return m4296  (color);         case 'hcluv': return a4297  (color);          case 'oklab': return t4292(color);         case 'lab':   return v4293    (color);         case 'luv':   return q4294    (color);          case 'xyz':   return convert2xyz    (color);         case 'xyz50': return convert2xyz50  (color);         case 'xyz65': return convert2xyz65  (color);     } }    function d4289(j4298, allowHex = false) {     const col = r4286(j4298);      let rgb;      switch (j4298[0])     {         case 'hex':         case 'rgb':   rgb =           col ; break;          case 'lin':   rgb = lin2rgb  (col); break;         case 'p3':    rgb = z62   (col); break;         case 'a98':   rgb = a982rgb  (col); break;         case 'pro':   rgb = pro2rgb  (col); break;         case 'r2020': rgb = r20202rgb(col); break;          case 'hsv':   rgb = d54  (col); break;         case 'hsl':   rgb = x50  (col); break;          case 'hclok': rgb = z34(col); break;         case 'hclab': rgb = r40(col); break;         case 'hcluv': rgb = o44(col); break;          case 'oklab': rgb = q4080(col); break;         case 'lab':   rgb = y56  (col); break;         case 'luv':   rgb = a4073  (col); break;          case 'xyz':   rgb = g71  (col);           break;         case 'xyz50': rgb = g71  (col, sRGB_D50); break;         case 'xyz65': rgb = g71  (col, sRGB_D65); break;     }       let color = m146(rgb);      if (allowHex)         color[0] = 'hex';       return color; }    function convert2lin(j4298) {     const col = r4286(j4298);      let lin;      switch (j4298[0])     {         case 'hex':         case 'rgb':   lin = rgb2lin          (col) ; break;          case 'lin':   lin =                   col  ; break;         case 'p3':    lin = rgb2lin(z62   (col)); break;         case 'a98':   lin = rgb2lin(a982rgb  (col)); break;         case 'pro':   lin = rgb2lin(pro2rgb  (col)); break;         case 'r2020': lin = rgb2lin(r20202rgb(col)); break;          case 'hsv':   lin = rgb2lin(d54  (col)); break;         case 'hsl':   lin = rgb2lin(x50  (col)); break;          case 'hclok': lin = rgb2lin(z34(col)); break;         case 'hclab': lin = rgb2lin(r40(col)); break;         case 'hcluv': lin = rgb2lin(o44(col)); break;          case 'oklab': lin = rgb2lin(q4080(col)); break;         case 'lab':   lin = rgb2lin(y56  (col)); break;         case 'luv':   lin = rgb2lin(a4073  (col)); break;          case 'xyz':   lin = y72          (col);           break;         case 'xyz50': lin = y72          (col, sRGB_D50); break;         case 'xyz65': lin = y72          (col, sRGB_D65); break;     }      return [        'lin',         lin[0],         lin[1],         lin[2] ]; }    function convert2p3(j4298) {     const col = r4286(j4298);      let p3;      switch (j4298[0])     {         case 'hex':         case 'rgb':   p3 = h61          (col) ; break;          case 'lin':   p3 = h61(lin2rgb  (col)); break;         case 'p3':    p3 =                  col  ; break;         case 'a98':   p3 = h61(a982rgb  (col)); break;         case 'pro':   p3 = h61(pro2rgb  (col)); break;         case 'r2020': p3 = h61(r20202rgb(col)); break;          case 'hsv':   p3 = h61(d54  (col)); break;         case 'hsl':   p3 = h61(x50  (col)); break;          case 'hclok': p3 = h61(z34(col)); break;         case 'hclab': p3 = h61(r40(col)); break;         case 'hcluv': p3 = h61(o44(col)); break;          case 'oklab': p3 = h61(q4080(col)); break;         case 'lab':   p3 = h61(y56  (col)); break;         case 'luv':   p3 = h61(a4073  (col)); break;          case 'xyz':   p3 = h61(g71  (col));           break;         case 'xyz50': p3 = h61(g71  (col, sRGB_D50)); break;         case 'xyz65': p3 = h61(g71  (col, sRGB_D65)); break;     }      return [         'p3',          p3[0],          p3[1],          p3[2] ];  }    function convert2a98(j4298) {     const col = r4286(j4298);      let a98;      switch (j4298[0])     {         case 'hex':         case 'rgb':   a98 = rgb2a98          (col) ; break;          case 'lin':   a98 = rgb2a98(lin2rgb  (col)); break;         case 'p3':    a98 = rgb2a98(z62   (col)); break;         case 'a98':   a98 =                   col  ; break;         case 'pro':   a98 = rgb2a98(pro2rgb  (col)); break;         case 'r2020': a98 = rgb2a98(r20202rgb(col)); break;          case 'hsv':   a98 = rgb2a98(d54  (col)); break;         case 'hsl':   a98 = rgb2a98(x50  (col)); break;          case 'hclok': a98 = rgb2a98(z34(col)); break;         case 'hclab': a98 = rgb2a98(r40(col)); break;         case 'hcluv': a98 = rgb2a98(o44(col)); break;          case 'oklab': a98 = rgb2a98(q4080(col)); break;         case 'lab':   a98 = rgb2a98(y56  (col)); break;         case 'luv':   a98 = rgb2a98(a4073  (col)); break;          case 'xyz':   a98 = rgb2a98(g71  (col));           break;         case 'xyz50': a98 = rgb2a98(g71  (col, sRGB_D50)); break;         case 'xyz65': a98 = rgb2a98(g71  (col, sRGB_D65)); break;     }      return [         'a98',          a98[0],          a98[1],          a98[2] ];  }    function convert2pro(j4298) {     const col = r4286(j4298);      let pro;      switch (j4298[0])     {         case 'hex':         case 'rgb':   pro = rgb2pro          (col) ; break;          case 'lin':   pro = rgb2pro(lin2rgb  (col)); break;         case 'p3':    pro = rgb2pro(z62   (col)); break;         case 'a98':   pro = rgb2pro(a982rgb  (col)); break;         case 'pro':   pro =                   col  ; break;         case 'r2020': pro = rgb2pro(r20202rgb(col)); break;          case 'hsv':   pro = rgb2pro(d54  (col)); break;         case 'hsl':   pro = rgb2pro(x50  (col)); break;          case 'hclok': pro = rgb2pro(z34(col)); break;         case 'hclab': pro = rgb2pro(r40(col)); break;         case 'hcluv': pro = rgb2pro(o44(col)); break;          case 'oklab': pro = rgb2pro(q4080(col)); break;         case 'lab':   pro = rgb2pro(y56  (col)); break;         case 'luv':   pro = rgb2pro(a4073  (col)); break;          case 'xyz':   pro = rgb2pro(g71  (col));           break;         case 'xyz50': pro = rgb2pro(g71  (col, sRGB_D50)); break;         case 'xyz65': pro = rgb2pro(g71  (col, sRGB_D65)); break;     }      return [         'pro',          pro[0],          pro[1],          pro[2] ]; }    function convert2r2020(j4298) {     const col = r4286(j4298);      let r2020;      switch (j4298[0])     {         case 'hex':         case 'rgb':   r2020 = rgb2r2020          (col) ; break;          case 'lin':   r2020 = rgb2r2020(lin2rgb  (col)); break;         case 'p3':    r2020 = rgb2r2020(z62   (col)); break;         case 'a98':   r2020 = rgb2r2020(a982rgb  (col)); break;         case 'pro':   r2020 = rgb2r2020(pro2rgb  (col)); break;         case 'r2020': r2020 =                     col  ; break;          case 'hsv':   r2020 = rgb2r2020(d54  (col)); break;         case 'hsl':   r2020 = rgb2r2020(x50  (col)); break;          case 'hclok': r2020 = rgb2r2020(z34(col)); break;         case 'hclab': r2020 = rgb2r2020(r40(col)); break;         case 'hcluv': r2020 = rgb2r2020(o44(col)); break;          case 'oklab': r2020 = rgb2r2020(q4080(col)); break;         case 'lab':   r2020 = rgb2r2020(y56  (col)); break;         case 'luv':   r2020 = rgb2r2020(a4073  (col)); break;          case 'xyz':   r2020 = rgb2r2020(g71  (col));           break;         case 'xyz50': r2020 = rgb2r2020(g71  (col, sRGB_D50)); break;         case 'xyz65': r2020 = rgb2r2020(g71  (col, sRGB_D65)); break;     }      return [         'r2020',          r2020[0],          r2020[1],          r2020[2] ]; }    function u4290(j4298) {     const col = r4286(j4298);          let hsv;          switch (j4298[0])     {         case 'hex':         case 'rgb':   hsv = o52(          col ); break;          case 'lin':   hsv = o52(lin2rgb  (col)); break;                  col  ; break;         case 'p3':    hsv = o52(z62   (col)); break;         case 'a98':   hsv = o52(a982rgb  (col)); break;         case 'pro':   hsv = o52(pro2rgb  (col)); break;         case 'r2020': hsv = o52(r20202rgb(col)); break;          case 'hsv':   hsv =                   col;   break;         case 'hsl':   hsv = o52(x50  (col)); break;          case 'hclok': hsv = o52(z34(col)); break;         case 'hclab': hsv = o52(r40(col)); break;         case 'hcluv': hsv = o52(o44(col)); break;          case 'oklab': hsv = o52(q4080(col)); break;         case 'lab':   hsv = o52(y56  (col)); break;         case 'luv':   hsv = o52(a4073  (col)); break;          case 'xyz':   hsv = o52(g71  (col));           break;         case 'xyz50': hsv = o52(g71  (col, sRGB_D50)); break;         case 'xyz65': hsv = o52(g71  (col, sRGB_D65)); break;     }          if (isNaN(hsv[0]))         hsv[0] = 5/6;          return [        'hsv',         hsv[0],         hsv[1],         hsv[2] ]; }    function g4291(j4298) {     const col = r4286(j4298);      let hsl;      switch (j4298[0])     {         case 'hex':         case 'rgb':   hsl = u48(          col ); break;          case 'lin':   hsl = u48(lin2rgb  (col)); break;                  col  ; break;         case 'p3':    hsl = u48(z62   (col)); break;         case 'a98':   hsl = u48(a982rgb  (col)); break;         case 'pro':   hsl = u48(pro2rgb  (col)); break;         case 'r2020': hsl = u48(r20202rgb(col)); break;          case 'hsv':   hsl = u48(d54  (col)); break;         case 'hsl':   hsl =                   col;   break;          case 'hclok': hsl = u48(z34(col)); break;         case 'hclab': hsl = u48(r40(col)); break;         case 'hcluv': hsl = u48(o44(col)); break;          case 'oklab': hsl = u48(q4080(col)); break;         case 'lab':   hsl = u48(y56  (col)); break;         case 'luv':   hsl = u48(a4073  (col)); break;          case 'xyz':   hsl = u48(g71  (col));           break;         case 'xyz50': hsl = u48(g71  (col, sRGB_D50)); break;         case 'xyz65': hsl = u48(g71  (col, sRGB_D65)); break;     }      return [        'hsl',         hsl[0],         hsl[1],         hsl[2] ]; }    function t4292(j4298) {     const col = r4286(j4298);      let lab;      switch (j4298[0])     {         case 'hex':         case 'rgb':   lab = p4076(          col ); break;          case 'lin':   lab = p4076(lin2rgb  (col)); break;                  col  ; break;         case 'p3':    lab = p4076(z62   (col)); break;         case 'a98':   lab = p4076(a982rgb  (col)); break;         case 'pro':   lab = p4076(pro2rgb  (col)); break;         case 'r2020': lab = p4076(r20202rgb(col)); break;          case 'hsv':   lab = p4076(d54  (col)); break;         case 'hsl':   lab = p4076(x50  (col)); break;          case 'hclok': lab = p4076(z34(col)); break;         case 'hclab': lab = p4076(r40(col)); break;         case 'hcluv': lab = p4076(o44(col)); break;          case 'oklab': lab =                     col;   break;         case 'lab':   lab = p4076(y56  (col)); break;         case 'luv':   lab = p4076(a4073  (col)); break;          case 'xyz':   lab = p4076(g71  (col));           break;         case 'xyz50': lab = p4076(g71  (col, sRGB_D50)); break;         case 'xyz65': lab = p4076(g71  (col, sRGB_D65)); break;     }      return [        'oklab',         lab[0],         lab[1],         lab[2] ]; }    function v4293(j4298) {     const col = r4286(j4298);      let lab;      switch (j4298[0])     {         case 'hex':         case 'rgb':   lab = d55(          col ); break;          case 'lin':   lab = d55(lin2rgb  (col)); break;                  col  ; break;         case 'p3':    lab = d55(z62   (col)); break;         case 'a98':   lab = d55(a982rgb  (col)); break;         case 'pro':   lab = d55(pro2rgb  (col)); break;         case 'r2020': lab = d55(r20202rgb(col)); break;         case 'hsv':   lab = d55(d54  (col)); break;          case 'hsl':   lab = d55(x50  (col)); break;          case 'hclok': lab = d55(z34(col)); break;         case 'hclab': lab =         d39(col);  break;         case 'hcluv': lab = d55(o44(col)); break;          case 'oklab': lab = d55(q4080(col)); break;         case 'lab':   lab =                   col;   break;         case 'luv':   lab = d55(a4073  (col)); break;          case 'xyz':   lab = k57          (col, q36.W);     break;         case 'xyz50': lab = k57          (col, sRGB_D50.W); break;         case 'xyz65': lab = k57          (col, sRGB_D65.W); break;     }      return [        'lab',         lab[0],         lab[1],         lab[2] ]; }    function q4294(j4298) {     const col = r4286(j4298);      let luv;      switch (j4298[0])     {         case 'hex':         case 'rgb':   luv = t4072(          col ); break;          case 'lin':   luv = t4072(lin2rgb  (col)); break;                  col  ; break;         case 'p3':    luv = t4072(z62   (col)); break;         case 'a98':   luv = t4072(a982rgb  (col)); break;         case 'pro':   luv = t4072(pro2rgb  (col)); break;         case 'r2020': luv = t4072(r20202rgb(col)); break;          case 'hsv':   luv = t4072(d54  (col)); break;         case 'hsl':   luv = t4072(x50  (col)); break;          case 'hclok': luv = t4072(z34(col)); break;         case 'hclab': luv = t4072(r40(col)); break;         case 'hcluv': luv =         h43(col);  break;          case 'oklab': luv = t4072(q4080(col)); break;         case 'lab':   luv = t4072(y56  (col)); break;         case 'luv':   luv =                   col;   break;          case 'xyz':   luv = o4074          (col, q36.W);     break;         case 'xyz50': luv = o4074          (col, sRGB_D50.W); break;         case 'xyz65': luv = o4074          (col, sRGB_D65.W); break;     }      return [        'luv',         luv[0],         luv[1],         luv[2] ]; }    function m4295(j4298) {     const col = r4286(j4298);      let hcl;      switch (j4298[0])     {         case 'hex':         case 'rgb':   hcl = q37(          col);  break;          case 'lin':   hcl = q37(lin2rgb  (col)); break;                  col  ; break;         case 'p3':    hcl = q37(z62   (col)); break;         case 'a98':   hcl = q37(a982rgb  (col)); break;         case 'pro':   hcl = q37(pro2rgb  (col)); break;         case 'r2020': hcl = q37(r20202rgb(col)); break;          case 'hsv':   hcl = q37(d54  (col)); break;         case 'hsl':   hcl = q37(x50  (col)); break;          case 'hclok': hcl =                     col;   break;         case 'hclab': hcl = q37(r40(col)); break;         case 'hcluv': hcl = q37(o44(col)); break;          case 'oklab': hcl = q37(q4080(col)); break;         case 'lab':   hcl = q37(y56  (col)); break;         case 'luv':   hcl = q37(a4073  (col)); break;          case 'xyz':   hcl = q37(g71  (col));           break;         case 'xyz50': hcl = q37(g71  (col, sRGB_D50)); break;         case 'xyz65': hcl = q37(g71  (col, sRGB_D65)); break;     }      return [        'hclok',         hcl[0],         hcl[1],         hcl[2] ]; }    function m4296(j4298) {     const col = r4286(j4298);      let lab;      switch (j4298[0])     {         case 'hex':         case 'rgb':   lab = p42(          col) ; break;                  case 'lin':   lab = p42(lin2rgb  (col)); break;                  col  ; break;         case 'p3':    lab = p42(z62   (col)); break;         case 'a98':   lab = p42(a982rgb  (col)); break;         case 'pro':   lab = p42(pro2rgb  (col)); break;         case 'r2020': lab = p42(r20202rgb(col)); break;          case 'hsv':   lab = p42(d54  (col)); break;         case 'hsl':   lab = p42(x50  (col)); break;                  case 'hclok': lab = p42(z34(col)); break;         case 'hclab': lab =                     col;   break;         case 'hcluv': lab = p42(o44(col)); break;                  case 'oklab': lab = p42(q4080(col)); break;         case 'lab':   lab = h41(          col ); break;         case 'luv':   lab = p42(a4073  (col)); break;          case 'xyz':   lab = p42(g71  (col));           break;         case 'xyz50': lab = p42(g71  (col, sRGB_D50)); break;         case 'xyz65': lab = p42(g71  (col, sRGB_D65)); break;     }      return [        'hclab',         lab[0],         lab[1],         lab[2] ]; }    function a4297(j4298) {     const col = r4286(j4298);      let hcl;      switch (j4298[0])     {         case 'hex':         case 'rgb':   hcl = j46(          col ); break;          case 'lin':   hcl = j46(lin2rgb  (col)); break;                  col  ; break;         case 'p3':    hcl = j46(z62   (col)); break;         case 'a98':   hcl = j46(a982rgb  (col)); break;         case 'pro':   hcl = j46(pro2rgb  (col)); break;         case 'r2020': hcl = j46(r20202rgb(col)); break;          case 'hsv':   hcl = j46(d54  (col)); break;         case 'hsl':   hcl = j46(x50  (col)); break;          case 'hclab': hcl = j46(r40(col)); break;         case 'hcluv': hcl =                     col;   break;         case 'hclok': hcl = j46(z34(col)); break;          case 'oklab': hcl = j46(q4080(col)); break;         case 'lab':   hcl = j46(y56  (col)); break;         case 'luv':   hcl = v45(          col ); break;          case 'xyz':   hcl = j46(g71  (col));           break;         case 'xyz50': hcl = j46(g71  (col, sRGB_D50)); break;         case 'xyz65': hcl = j46(g71  (col, sRGB_D65)); break;     }      return [        'hcluv',         hcl[0],         hcl[1],         hcl[2] ]; }    function convert2xyz(j4298) {     const col = r4286(j4298);      let xyz;      switch (j4298[0])     {         case 'hex':         case 'rgb':   xyz = y69(          col ); break;          case 'lin':   xyz = y69(lin2rgb  (col)); break;                  col  ; break;         case 'p3':    xyz = y69(z62   (col)); break;         case 'a98':   xyz = y69(a982rgb  (col)); break;         case 'pro':   xyz = y69(pro2rgb  (col)); break;         case 'r2020': xyz = y69(r20202rgb(col)); break;          case 'hsv':   xyz = y69(d54  (col)); break;         case 'hsl':   xyz = y69(x50  (col)); break;          case 'hclab': xyz = y69(r40(col)); break;         case 'hcluv': xyz = y69(r40(col)); break;         case 'hclok': xyz = y69(z34(col)); break;          case 'oklab': xyz = y69(q4080(col)); break;         case 'lab':   xyz = c58(          col, q36.W); break;         case 'luv':   xyz = f4075(          col, q36.W); break;          case 'xyz':   xyz =                   col;             break;         case 'xyz50': xyz = y69(g71  (col, sRGB_D50)); break;         case 'xyz65': xyz = y69(g71  (col, sRGB_D65)); break;     }      return [        'xyz',         xyz[0],         xyz[1],         xyz[2] ]; }    function convert2xyz50(j4298) {     const col = r4286(j4298);      let xyz;      switch (j4298[0])     {         case 'hex':         case 'rgb':   xyz = y69(          col,  sRGB_D50);    break;          case 'lin':   xyz = y69(lin2rgb  (col), sRGB_D50);   break;                  col  ; break;         case 'p3':    xyz = y69(z62   (col), sRGB_D50);   break;         case 'a98':   xyz = y69(a982rgb  (col), sRGB_D50);   break;         case 'pro':   xyz = y69(pro2rgb  (col), sRGB_D50);   break;         case 'r2020': xyz = y69(r20202rgb(col), sRGB_D50);   break;          case 'hsv':   xyz = y69(d54  (col), sRGB_D50);   break;         case 'hsl':   xyz = y69(x50  (col), sRGB_D50);   break;          case 'hclab': xyz = y69(r40(col), sRGB_D50);   break;         case 'hcluv': xyz = y69(r40(col), sRGB_D50);   break;         case 'hclok': xyz = y69(z34(col), sRGB_D50);   break;          case 'oklab': xyz = y69(q4080(col), sRGB_D50);   break;         case 'lab':   xyz = c58(          col,  sRGB_D50.W); break;         case 'luv':   xyz = f4075(          col,  sRGB_D50.W); break;          case 'xyz':   xyz = y69(g71  (col), sRGB_D50);   break;         case 'xyz50': xyz =                   col;               break;         case 'xyz65': xyz = y69(g71  (col), sRGB_D50);   break;     }      return [        'xyz50',         xyz[0],         xyz[1],         xyz[2] ]; }    function convert2xyz65(j4298) {     const col = r4286(j4298);      let xyz;      switch (j4298[0])     {         case 'hex':         case 'rgb':   xyz = y69(          col,  sRGB_D65);    break;          case 'lin':   xyz = y69(lin2rgb  (col), sRGB_D65);   break;                  col  ; break;         case 'p3':    xyz = y69(z62   (col), sRGB_D65);   break;         case 'a98':   xyz = y69(a982rgb  (col), sRGB_D65);   break;         case 'pro':   xyz = y69(pro2rgb  (col), sRGB_D65);   break;         case 'r2020': xyz = y69(r20202rgb(col), sRGB_D65);   break;          case 'hsv':   xyz = y69(d54  (col), sRGB_D65);   break;         case 'hsl':   xyz = y69(x50  (col), sRGB_D65);   break;          case 'hclab': xyz = y69(r40(col), sRGB_D65);   break;         case 'hcluv': xyz = y69(r40(col), sRGB_D65);   break;         case 'hclok': xyz = y69(z34(col), sRGB_D65);   break;          case 'oklab': xyz = y69(q4080(col), sRGB_D65);   break;         case 'lab':   xyz = c58(          col,  sRGB_D65.W); break;         case 'luv':   xyz = f4075(          col,  sRGB_D65.W); break;          case 'xyz':   xyz = y69(g71  (col), sRGB_D65);   break;         case 'xyz50': xyz = y69(g71  (col, sRGB_D50), sRGB_D65);   break;         case 'xyz65': xyz =                   col;               break;     }      return [        'xyz65',         xyz[0],         xyz[1],         xyz[2] ]; }


</script>