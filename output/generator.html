<script id="generatorScript" type="javascript/worker"> 'use strict';  


const generatorVersion = 440;   const p869        = 2147483647;    const NULL             = '';    const z870             = '  ';  const w871              = '    '; const e872               = '\n';    const a873   = '◦ G •'; const k874    = a873 + ' ';  const z875          = 'G_NODE'; const t876          = 'G_CONN'; const c877          = 'G_PAGE'; const q878          = 'G_TEMP';  const minWindowWidth   = 602; const minWindowHeight  =  39;   const identity = Object.freeze(     [[1, 0, 0],      [0, 1, 0],      [0, 0, 1]]);    const Epsilon = 0.0000001; const Tau     = Math.PI * 2;    var enableAsserts = false;    function a879(x, eps = 0.000000001)  {      return Math.abs(x) < eps ? 0 : x; }    function nozero(x, eps = 0.000000001)  {      return x != 0           ? x           : (x < 0 ? -eps : eps); }    function p880(v, eps = 0.000000001)  {      return point(         nozero(v.x, eps),          nozero(v.y, eps));  }    function equal(a, b, eps = 0.000000001) {     return Math.abs(b - a) < eps; }    function sqr (x) { return x*x;   }; function cube(x) { return x*x*x; };    function p881(f) { return Math.floor(f) | 0; }    function r882(x) {     x = p881(x);      x--;      x |= x >>  1;     x |= x >>  2;     x |= x >>  4;     x |= x >>  8;     x |= x >> 16;     x |= x >> 32;      return ++x; }    function gcd(a, b) {     let temp;     while (1)     {         temp = a % b;          if (temp == 0)           return b;          a = b;         b = temp;     } }    function distv(p1, p2) {     const dx = p2.x - p1.x;     const dy = p2.y - p1.y;      return Math.sqrt(dx*dx + dy*dy); }    function v883(v) {     let angle = Math.atan2(v.y, v.x);     if (angle < 0) angle += Tau;      return angle; }    function anglev2(v1, v2) {     return anglev2_(v1.x, v1.y, v2.x, v2.y); }    function anglev2_(x1, y1, x2, y2) {     const dx = x2 - x1;     const dy = y2 - y1;      let angle = Math.atan2(dy, dx);     if (angle < 0) angle += Tau;      return angle; }    function j885(v) {     return Math.sqrt(v.x*v.x + v.y*v.y); }    function lengthv_(x, y) {     return Math.sqrt(x*x + y*y); }    function a886(v) {     return point(         v.x == 0 ? 0 : v.x / j885(v),         v.y == 0 ? 0 : v.y / j885(v)); }    function dotv(v1, v2) {     return v1.x * v2.x + v1.y * v2.y; }    function x887(a1, a2) {     let diff = a2 - a1;      while (diff <= -Tau/2) diff += Tau;     while (diff >   Tau/2) diff -= Tau;      return diff;  }    function z888(v, m) {     let v3 = [v.x, v.y, 1];     let r  = i948(v3, m);      return point(r[0], r[1]); }    function e889(...mm) {     x952(mm.length > 0, 'mulm3m3() must take at least one argument');      let result = clone(mm[0]);      for (let a = 1; a < mm.length; a++)     {         const m1 = result;         const m2 = mm[a];          const m = [[0, 0, 0],                    [0, 0, 0],                    [0, 0, 0]];          for (let i = 0; i < 3; i++)         {             for (let j = 0; j < 3; j++)             {                                  for (let k = 0; k < 3; k++)                     m[i][j] += m1[i][k] * m2[k][j];             }         }          result = m;     }      return result; }    function x890(m, s) {     for (let i = 0; i < 3; i++)         for (let j = 0; j < 3; j++)             m[i][j] /= s;      return m; }    function adjugate(m) {     return cofactor(transpose(m)); }    function transpose(m) {     return [[m[0][0], m[1][0], m[2][0]],             [m[0][1], m[1][1], m[2][1]],             [m[0][2], m[1][2], m[2][2]]]; }    function cofactor(m) {     return [[  m[1][1] * m[2][2] - m[2][1] * m[1][2], -(m[1][0] * m[2][2] - m[2][0] * m[1][2]),  m[1][0] * m[2][1] - m[2][0] * m[1][1] ],             [-(m[0][1] * m[2][2] - m[2][1] * m[0][2]),  m[0][0] * m[2][2] - m[2][0] * m[0][2], -(m[0][0] * m[2][1] - m[2][0] * m[0][1])],             [  m[0][1] * m[1][2] - m[1][1] * m[0][2], -(m[0][0] * m[1][2] - m[1][0] * m[0][2]),  m[0][0] * m[1][1] - m[1][0] * m[0][1] ]];  }    function determinant(m) {     return   m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1])            - m[0][1] * (m[1][0] * m[2][2] - m[2][0] * m[1][2])            + m[0][2] * (m[1][0] * m[2][1] - m[2][0] * m[1][1]); }    function z891(m) {     return x890(adjugate(m), determinant(m)); }    function u892(angle) {     const cosA = a879(Math.cos(angle));     const sinA = a879(Math.sin(angle));      return [[ cosA, sinA, 0],             [-sinA, cosA, 0],             [ 0,    0,    1]]; }    function a893(x = 0, y = 0, scaleX = 1, scaleY = 1, angle = 0, skewX = 0, skewY = 0) {     const cosA = Math.cos(angle);     const sinA = Math.sin(angle);      return [[scaleX*cosA -  skewY*sinA, -skewX*cosA + scaleY*sinA, x],             [ skewY*cosA + scaleX*sinA, scaleY*cosA +  skewX*sinA, y],             [0,                         0,                         1]]; }    function d894(v1, v2) {                               return v1.x * v2.y - v1.y * v2.x; }	    function f895(v1, v2) {     return point(         v1.x + v2.x,         v1.y + v2.y); }	    function sqrv(v) {     return j896(v, v); }    function j896(v1, v2) {     return point(         v1.x * v2.x,         v1.y * v2.y); }	    function l897(v, s) {     return point(         v.x * s,         v.y * s); }	    function s898(v1, v2) {     return point(         v1.x / v2.x,         v1.y / v2.y); }	    function b899(v, s) {     return point(         v.x / s,         v.y / s); }	    function x900(v1, v2) {     return point(         v1.x - v2.x,         v1.y - v2.y); }	    function z901(str)  {     return decodeURI(encodeURIComponent(str)); }    function a902(str)  {     return decodeURIComponent(encodeURI(str)); }    function f903(bytes)  {     let str = '';      for (let i = 0; i < bytes.length; i++)         str += String.fromCharCode(bytes[i]);      return str; }    function h904(str) {     return Array.from(a902(str), c => c.charCodeAt(0)); }    function h905(array, size)  {     const newArray = new Uint8Array(size);     a906(array, newArray);     return newArray; }    function a906(src, dst) {     u907(         src, 0, src.length,         dst, 0, dst.length); }    function u907(src, u908, p909, dst, t910, n911) {     const size = Math.min(p909, n911);      for (let i = 0; i < size; i++)         dst[t910 + i] = src[u908 + i]; }    function a912(y913, r914) {     if (y913.length != r914.length)         return false;      for (let i = 0; i < y913.length; i++)     {         if (y913[i] != r914[i])             return false;     }      return true; }    function p915(n916, v917) {     return n916.findIndex(i => v917.includes(i)) > -1; }    function  o918(list) { return list ? '<==' : '<--'; };  function k919(list) { return list ? '==>' : '-->'; };   function b920(nodeId) { return z875 + ' ' + nodeId; } function p921(name)   { return t876 + ' ' + name;   } function d922(name)   { return c877 + ' ' + name;   }    function m923(str)  {      return str.toLowerCase() == 'true'         || str == '1'; }    function s924(a925, b926 = false) {     return i931(         a925.outputNodeId,         a925.outputId,         a925.outputOrder,         a925.inputNodeId,         a925.inputId,         a925.list,         b926); }    function e927(outputNodeId, outputId, outputOrder, inputNodeId, inputId) {     return p921(           outputNodeId + ' '         + outputId     + ' '         + outputOrder  + ' '         + inputNodeId  + ' '         + inputId); }    function x928(h243) {     return e927(         h243.outputNodeId,         h243.outputId,         h243.outputOrder,         h243.inputNodeId,         h243.inputId); }    function e929(h243) {     return e927(         h243.output.node.id,         h243.output.id,         h243.outputOrder,         h243.input.node.id,         h243.input.id); }    function p930(h243, b926 = false) {     return i931(         h243.output.node.id,         h243.output.id,         h243.outputOrder,         h243.input.node.id,         h243.input.id,         h243.list,         b926); }    function i931(outputNodeId, outputId, outputOrder, inputNodeId, inputId, list, b926 = false) {     const  sp   = b926 ? ' ' : '  ';      const jsp   = b926 ? ''  : ' ';       const arrow =            sp          + p935(typeof outputOrder == 'string' ? parseInt(outputOrder) : outputOrder)          + k919(typeof list == 'string' ? m923(list) : list)          + sp;      const join  = jsp + '.' + jsp;      return  outputNodeId + join + outputId          + arrow          + inputNodeId  + join + inputId;           }    function j932(pageId) {     return d922(pageId); }    function p933(num) {     const str = num.toString();      let sup = '';      for (const c of str)         sup += d934(c);      return sup; }    function d934(c) {     switch (c)     {         case '0': return '⁰';         case '1': return '¹';         case '2': return '²';         case '3': return '³';         case '4': return '⁴';         case '5': return '⁵';         case '6': return '⁶';         case '7': return '⁷';         case '8': return '⁸';         case '9': return '⁹';         case '.': return '·';     } }    function p935(num) {     const str = num.toString();      let sup = '';      for (const c of str)         sup += p936(c);      return sup; }    function p936(c) {     switch (c)     {         case '0': return '₀';         case '1': return '₁';         case '2': return '₂';         case '3': return '₃';         case '4': return '₄';         case '5': return '₅';         case '6': return '₆';         case '7': return '₇';         case '8': return '₈';         case '9': return '₉';         case '.': return ' ';     } }    function l937(bool) {     return bool ? 'true' : 'false'; }    function isValid(val) {     return val != undefined         && val != null; }    function isEmpty(array) {     return array.length == 0; }    function n938(array, item) {     d939(array, array.indexOf(item)); }    function d939(array, index) {     if (   index > -1          && index < array.length)         array.splice(index, 1); }    function j940(array) {     if (isEmpty(array))         return null;      let last = array.at(-1);     array.splice(array.length-1, 1);      return last; }    function g941(array) {     return array[array.length-1]; }    function d942(array, from, to)  {     const item = array[from];     array.splice(from, 1);     array.splice(to, 0, item); }    function j943(array, item) {     const index = array.indexOf(item);          if (index > -1)         array.splice(index, 1); }    function l944(w2796, array) {     for (const item of array)     {         const index = w2796.indexOf(item);                  if (index > -1)             w2796.splice(index, 1);     } }    function k945(array, where) {     const index = array.findIndex(where);          if (index > -1)         array.splice(index, 1); }    function y946(styleId) {     return styleId.split(',')[0] + ','; }    function w947(points) {     let t4032 = '';       if (points.length < 2)         return t4032;       t4032 += 'M';     t4032 += ' ' + a879(points[0].x);     t4032 += ' ' + a879(points[0].y);      for (let i = 1; i < points.length; i++)     {         t4032 +=                ' L'             + ' ' + a879(points[i].x)             + ' ' + a879(points[i].y);     }       return t4032; }    function point(x, y) { return {x: x, y: y}; }    function i948(v, m) {     let r = [0, 0, 0];      for (let i = 0; i < 3; i++)         for (let j = 0; j < 3; j++)             r[i] += v[j] * m[i][j];      return r; }    function clone(val)  {     const type = typeof val;          if (val === null)        return null;      else if (type === 'undefined'            || type === 'number'            || type === 'string'            || type === 'boolean')          return val;      else if (type === 'object')      {         if (val instanceof Array)              return val.map(x => clone(x));          else if (val instanceof Uint8Array)              return new Uint8Array(val);          else          {             let v111 = {};              for (const key in val)                  v111[key] = clone(val[key]);              return v111;         }     }      throw 'unknown'; }    function n949(array, item, equal = null) {     if (equal)     {         if (Array.isArray(item))             item.forEach(i => n949(array, i, equal));         else if (!array.find(i => equal(i, item)))             array.push(item);     }     else     {         if (Array.isArray(item))             item.forEach(i => n949(array, i));         else if (!array.includes(item))             array.push(item);     } }    function s950(array, item, equal) {     if (Array.isArray(item))         item.forEach(i => s950(array, i, equal));     else if (!array.find(equal))         array.push(item); }    function n951(array, item, except) {     if (Array.isArray(item))         item.forEach(i => n951(array, i, except));     else if (!array.find(except))         array.push(item); }    function x952(...args) {               if (enableAsserts)     {         console.assert(...args);              } }    function h953(...args) {               if (enableAsserts)         console.error(...args); }    function z954(str, trim)  {     while (str.length >= trim.length         && str.substring(0, trim.length) == trim)          str = str.substring(trim.length);      return str; }    function h955(str, trim)  {     while (str.length >= trim.length         && str.substring(str.length - trim.length) == trim)          str = str.substring(0, str.length - trim.length);      return str; }    function v956(p4092) {     const fills = [];       for (const fill of p4092)     {         switch (fill[0])         {             case 'SOLID':             {                 const color = {                     r: Math.min(Math.max(0, fill[1] / 0xff), 1),                      g: Math.min(Math.max(0, fill[2] / 0xff), 1),                      b: Math.min(Math.max(0, fill[3] / 0xff), 1) };                  const opacity = Math.min(Math.max(0, fill[4] / 100), 1);                   if (   !isNaN(color.r)                     && !isNaN(color.g)                     && !isNaN(color.b)                     && !isNaN(opacity))                     fills.push(                     {                         type:      fill[0],                          color:     color,                         opacity:   opacity,                         blendMode: fill[5]                     });                   break;             }              case 'GRADIENT_LINEAR':             case 'GRADIENT_RADIAL':             case 'GRADIENT_ANGULAR':             case 'GRADIENT_DIAMOND':             {                 const [p0, p1, p2] = fill[1];                  const m4207 =                      [[0,   1,   0],                      [0.5, 0.5, 1],                      [1,   1,   1]];                  let b4208 = [                     [p0.x, p1.x, p2.x],                     [p0.y, p1.y, p2.y],                     [1,    1,    1   ]];                  b4208 = e889(m4207, z891(b4208));                 b4208 = [b4208[0], b4208[1]];                   const stops = [];                  for (const stop of fill[2])                 {                     stops.push({                         color:                          {                             r: Math.min(Math.max(0, stop[0]), 1),                             g: Math.min(Math.max(0, stop[1]), 1),                             b: Math.min(Math.max(0, stop[2]), 1),                             a: Math.min(Math.max(0, stop[3]), 1)                         },                         position: stop[4]                     });                   }                   fills.push(                 {                     type:              fill[0],                     gradientTransform: b4208,                     gradientStops:     stops,                     blendMode:         fill[3]                 });                   break;             }         }     }       return fills; }    function n957(type) {     return w1089.includes(type); }


function n958(type, active) {     return g959(type, active, p4007); }    function g959(type, active, p4007) {     if (q1166.includes(type))         return active              ? (p4007 ? u2429 : u2419)             : (p4007 ? w2430       : n2420      );      else if (a1167.includes(type))         return active              ? (p4007 ? k2435   : d2425)             : (p4007 ? g2436         : u2426      );      else if (t1296.includes(type)          || o1214.includes(type))         return active              ? (p4007 ? j2433  : c2423)             : (p4007 ? m2434        : u2424      );      else if (u1300.includes(type))         return active              ? (p4007 ? g2431  : n2421)             : (p4007 ? d2432        : u2422      );      else if (y1090.includes(type)           || type == x1087)         return active              ? (p4007 ? v2427   : n2417)             : (p4007 ? e2428         : q2418      );      else if (type == l1216)         return active              ? (p4007 ? v2427   : n2417)             : (p4007 ? e2428         : q2418      );       switch (type)     {         case d1168:               case i1178:         case c1181:         case b1184:         case x1187:          case a1169:                    case j1175:         case w1171:         case i1173:         case p1174:         case f1176:          case v1185:         case n1188:              return p4007                   ? e2428                           : q2418;                                             }                return p4007           ? e2428                   : q2418; }    function f960(color) {     return isNaN(color[1])         || isNaN(color[2])         || isNaN(color[3]); }


function j998(x, replace) {     return !isNaN(x) ? x : replace; }    function z999(c) {     return c >= 'a' && c <= 'z'         || c >= 'A' && c <= 'Z'; }   function g1000(i) {     let l = Math.floor(Math.log10(Math.abs(i)));      return l + 1; }    function m1001(dec) {     return Math.pow(10, -dec); }    function b1002(c) {     return c >= '0'          && c <= '9'; }    function h1003(c) {     return c.length == 1         && (   c >= 'A' && c <= 'F'             || c >= 'a' && c <= 'f'); }    function n1004(num)  {     if (typeof num !== 'number')         h953('Input must be a number');          const strNum = num.toFixed(10);     const iDec   = strNum.indexOf('.');          if (iDec === -1)         return 0;          let count        = strNum.length - iDec - 1;     let nonZeroFound = false;          for (let i = strNum.length-1; i > iDec; i--)     {         if (strNum[i] === '0')             count--;         else             break;     }          return count; }    function q1005(code) {     return code == 'ArrowLeft'         || code == 'ArrowRight'         || code == 'ArrowUp'         || code == 'ArrowDown'; }    function g1006(num, dec = 0, t4001 = false, n1007 = '.', f1008 = '') {     return t4001          ? v1010(num, dec, n1007, f1008)          : d1009(num, dec, n1007, f1008); }    function d1009(num, dec, n1007 = '.', f1008 = '') {     const s4094 = Math.abs(dec);     let    str = Number(num).toFixed(s4094).toString(10);                     let i = str.length-1;          while (i >= 0         && str[i] !== '.'          && str[i] !== ',')         i--;      if (i < 0)          return b1011(str, f1008, 3);           let whole = str.slice(0, i);     let frac  = str.slice(i+1);             i = frac.length-1;      if (dec < 0)     {         while (i >= 0 && frac[i] === '0')             frac = frac.substring(0, i--);     }           return b1011(whole, f1008, 3) + (frac != '' ? n1007 : '') + frac; }    function v1010(num, dec, n1007 = '.', f1008 = '') {     const m4093 = Number(num);     const s4094 = Math.abs(dec);      let   v4091 = Number(num).toFixed(s4094).toString(10);     let    str = Math.abs(m4093).toString(16);                 let i = str.length-1;      while (i >= 0         && str[i] !== '.'          && str[i] !== ',')         i--;      if (i < 0)          return b1011(str, f1008, 2);           let whole = str.slice(0, i);     let frac  = v4091.slice(i+1);                 i = frac.length-1;      let m4095 = parseFloat(frac);     frac = '';      while (m4095 != 0)     {         m4095 *= 16;          const e4096 = Math.floor(m4095);          frac += e4096.toString(16);         m4095 -= e4096;     }           if (whole.length % 2 > 0) whole = '0' + whole;     if (frac .length % 2 > 0) frac  = frac + '0';       const neg = num < 0 ? '-' : '';      return neg + b1011(whole, f1008, 2) + n1007 + m1012(frac, f1008, 2); }    function b1011(v4091, sep, f1013) {     let str = '';      for (let i = v4091.length-1, t = 0; i >= 0; i--, t++)     {         if (t == f1013)         {             str = sep + str;             t = 0;         }          str = v4091[i] + str;     }      return str; }    function m1012(v4091, sep, f1013) {     let str = '';      for (let i = 0, t = 0; i < v4091.length; i++, t++)     {         if (t == f1013)         {             str += sep;             t = 0;         }          str += v4091[i];     }      return str; }                                 function capitalize(str) {     let cap = "";      if (str.length > 0)         cap += str[0].toUpperCase();      if (str.length > 1)         cap += str.substring(1).toLowerCase();      return cap; }    function e1014(s4097) {     const query = window.location.search.substring(1);     const vars  = query.split('&');      for (let i = 0; i < vars.length; i++)      {         let pair = vars[i].split('=');          if (pair[0] == s4097)             return pair[1];     }      return false; }


const phi = (Math.sqrt(5) - 1) / 2;  const Phi = (Math.sqrt(5) + 1) / 2;     function a1015(x, dec) {     const div = Math.round(Math.pow(10, dec));     return Math.floor((x + Number.EPSILON) * div) / div;     }    function a1016(x, dec) {     const div = Math.round(Math.pow(10, dec));     return Math.round((x + Number.EPSILON) * div) / div;     }    function n1017(x, dec) {     const div = Math.ceil(Math.pow(10, dec));     return Math.ceil((x + Number.EPSILON) * div) / div;     }    function c1018(x1, y1, x2, y2) {     const dx = x2 - x1;     const dy = y2 - y1;      return Math.sqrt(dx*dx + dy*dy); }    function vector(angle, dist) {     return point(          dist * Math.cos(angle),          dist * Math.sin(angle)); }    function x1019(v1, v2) {     return v1.x == v2.x         && v1.y == v2.y; }    function a1020(v, salt = 0.0000000001) {     return f895(v, point(         -salt + Math.random() * salt*2,          -salt + Math.random() * salt*2)); }    function c1021(v) {     return point(-v.x, -v.y); }    function w1022(v) {           return point(v.y, -v.x); }    function trimAngle(angle, min = 0, max = Tau) {     while (angle <  min) angle += max - min;     while (angle >= max) angle -= max - min;      return angle; }    function v883(v) {     let angle = Math.atan2(v.y, v.x);     if (angle < 0) angle += Tau;      return angle; }    function l884(p0, p1) {     const v = x900(p1, p0);          let angle = Math.atan2(v.y, v.x);     if (angle < 0) angle += Tau;      return angle; }    function z1023(x, y) {     let angle = Math.atan2(y, x);     if (angle < 0) angle += Tau;      return angle; }    function a4008(p, q, t0, t1) {     if (p == 0 && q < 0)     {         return null;     }     else if (p < 0)     {         let r = q/p;               if (r > t1) return null;         else if (r > t0) t0 = r;     }     else if (p > 0)     {         let r = q/p;               if (r < t0) return null;         else if (r < t1) t1 = r;     }      return [t0, t1]; }    function s4009(x1, y1, x2, y2, left, top, right, bottom) {     let t0 = 0;     let t1 = 1;      let dx = x2 - x1;     let dy = y2 - y1;      let cl = a4008(-dx, -(left - x1), t0, t1); if (cl != null) { t0 = cl[0]; t1 = cl[1]; } else return null;     let cr = a4008( dx, right - x1,   t0, t1); if (cr != null) { t0 = cr[0]; t1 = cr[1]; } else return null;     let ct = a4008(-dy, -(top - y1),  t0, t1); if (ct != null) { t0 = ct[0]; t1 = ct[1]; } else return null;     let cb = a4008( dy, bottom - y1,  t0, t1); if (cb != null) { t0 = cb[0]; t1 = cb[1]; } else return null;      if (t1 < 1)     {         x2 = x1 + t1*dx;         y2 = y1 + t1*dy;     }      if (t0 > 0)     {         x1 = x1 + t0*dx;         y1 = y1 + t0*dy;     }      return [         point(x1, y1),          point(x2, y2) ]; }    function intersect(p1, p2, q1, q2, segment) {     if (   x1019(p1, p2)          || x1019(q1, q2))          return m984;       let v1 = x900(p2, p1);     let v2 = x900(q2, q1);      if (d894(v1, v2) == 0)          return m984;       let t1 = d894(x900(q1, p1), v2) / d894(v1, v2);     let t2 = d894(x900(q1, p1), v1) / d894(v1, v2);      if ((  0 <= t1 && t1 <= 1         && 0 <= t2 && t2 <= 1)         || !segment)         return f895(p1, l897(v1, t1));              return m984; }    function p4010(l0, l1, p, segment) {     if (x1019(p, l0))         return l0;              let d = l897(         a886(w1022(x900(l1, l0))),          distv(p, l0));                  return intersect(l0, l1, p, x900(p, d), segment); }    function r4011(p0, p1, p) {     let cp = p4010(p0, p1, p, false);      let b4208 = e889(         y4012(c1021(p0)),         f4013(-anglev2(p0, p1)));              p0 = transform(p0, b4208);     p1 = transform(p1, b4208);     cp = transform(cp, b4208);      return (cp.x - p0.x) / nozero(p1.x - p0.x); }    function transform(p, b4208) {     return z888(p, b4208); }    function y4012(v) {     return [[1, 0, v.x],             [0, 1, v.y],             [0, 0, 1  ]]; }    function f4013(angle) {     return [[ Math.cos(angle), Math.sin(angle), 0],             [-Math.sin(angle), Math.cos(angle), 0],             [ 0,               0,               1]]; }                          const MaxDigits = 100000;   function g1024(x, res, resSize) {     let carry = 0n;               for (let i = 0; i < resSize; i++)      {         const prod = res[i] * x + carry;              res[i] = prod % 10n;          carry  = prod / 10n;      }                    while (carry)     {         res[resSize] = carry % 10n;         carry        = carry / 10n;         resSize++;     }      return resSize; }    function y1025(max = Number.MAX_SAFE_INTEGER/2) {     const num = Math.floor(Math.random() * max);     return d1026(num); }    function d1026(x)  {     while (!a1027(++x));     return x; }    function a1027(n, k = m1028)  {     if (n <= 1) return false;      if (n <= 3) return true;           if (n % 2 == 0)          return false;                let d = n - 1;          while (d % 2 == 0)          d /= 2;                       for (let i = 0; i < k; i++)             if (!p1029(d, n))             return false;                return true;  }        function p1029(d, n) {     return bigMillerTest(         BigInt(d),         BigInt(n)); }            function m1030(buffer, size) {     return x1031(buffer, 0, size); }    function x1031(buffer, start, size) {     let val = 0;     let mul = 1;      for (let i = start+size-1; i >= start; i--)      {         val += mul * buffer[i];         mul <<= 8;     }      return val; }    function k1032(val, buffer, c1033) {     b1034(val, buffer, 0, c1033); }    function b1034(val, buffer, start, c1033) {     let size = Math.ceil(bigBitCount(val) / 8);          size = Math.min(size, buffer.length - start);      start += c1033 - size;      for (let i = start+size-1; i >= start; i--)      {         buffer[i] = val & 0xFF;          val >>= 8;     } }    function lerpCos(a, b, t) {     return a < b          ? a + (b - a) * (-Math.cos(t*Tau/2)+1)/2          : a + (b - a) * (-Math.cos(t*Tau/2)+1)/2; }    function p1035(a, b, t) {     return a + (b - a) * t; }    function d1036(p0, p1, p2, t) {     const c0 = p1035(p0, p1, t);     const c1 = p1035(p1, p2, t);      return p1035(c0, c1, t); }    function tangent2(p0, p1, p2, t) {     return f895(l897(p0, -2*(1-t)), f895(l897(p1, 2*(1-2*t)), l897(p2, 2*t))); }    function tangent3(p0, p1, p2, p3, t) {     return f895(         l897(x900(p1, p0), 3 * Math.pow(1-t, 2)),         f895(            l897(x900(p2, p1), 6 * (1-t) * t),            l897(x900(p3, p2), 3 * Math.pow(t, 2)))); }    function n1037(p0, p1, p2, p3, t) {     const c0  = p1035(p0, p1, t);     const c1  = p1035(p1, p2, t);     const c2  = p1035(p2, p3, t);      const c01 = p1035(c0, c1, t);     const c12 = p1035(c1, c2, t);      return p1035(c01, c12, t); }    function v1038(angle) {     while (angle <  0  ) angle += Tau;     while (angle >= Tau) angle -= Tau;      return angle;  }    function w1039(m, v)  {     const result = [];      for (let i = 0; i < m.length; i++)      {         let sum = 0;          for (let j = 0; j < v.length; j++)              sum += m[i][j] * v[j];          result.push(sum);     }         return result; }    function smoothstep(x) {     if (   x < 0          || x > 1)          return x;      return 3*x*x - 2*x*x*x; }    function getMean(values) {     return values.length > 0          ? values.reduce((t807, cur) => t807 + cur, 0) / values.length          : Number.NaN; }    function getTrimmedMean(values, trimStart, trimEnd = trimStart) {     if (   trimStart <  0         || trimStart >= 0.5         || trimEnd   <  0         || trimEnd   >= 0.5)         throw new Error('trimStart = ' + trimStart + ', trimEnd = ' + trimEnd + ', trim must be between 0 and 0.5');           const sorted         = values.slice().sort((a, b) => a - b);      const trimCountStart = Math.floor(sorted.length * trimStart);     const trimCountEnd   = Math.floor(sorted.length * trimEnd  );      const trimmed   = sorted.slice(trimCountStart, sorted.length - trimCountEnd);     const sum       = trimmed.reduce((t807, val) => t807 + val, 0);      return trimmed.length > 0          ? sum / values.length          : Number.NaN; }    function getMedian(values) {     const sorted = [...values].sort((a, b) => a - b);     const middle = Math.floor(sorted.length / 2);      return sorted.length % 2 == 0          ? (sorted[middle-1] + sorted[middle]) / 2          : sorted[middle]; }


const m984 = point(Number.NaN, Number.NaN);    function c985(p) { return isNaN(p.x) || isNaN(p.y); }    function unit(v) {     return v.X != 0          || v.Y != 0         ? l897(v, 1 / j885(v))         : point(0, 0); }    function k986(p0, p1, t) {     return point(         p1035(p0.x, p1.x, t),         p1035(p0.y, p1.y, t)); }    function b987(p0, p1, p2, t) {     return point(         d1036(p0.x, p1.x, p2.x, t),         d1036(p0.y, p1.y, p2.y, t)); }    function p988(p0, p1, p2, p3, t) {     return point(         n1037(p0.x, p1.x, p2.x, p3.x, t),         n1037(p0.y, p1.y, p2.y, p3.y, t)); }    function a4008(p, q, t0, t1) {     if (p == 0 && q < 0)     {         return null;     }     else if (p < 0)     {         const r = q/p;               if (r > t1) return null;         else if (r > t0) t0 = r;     }     else if (p > 0)     {         const r = q/p;               if (r < t0) return null;         else if (r < t1) t1 = r;     }      return [t0, t1]; }    function s4009(x1, y1, x2, y2, left, top, right, bottom) {     let   t0 = 0;     let   t1 = 1;      const dx = x2 - x1;     const dy = y2 - y1;      const cl = a4008(-dx, -(left - x1), t0, t1); if (cl != null) { t0 = cl[0]; t1 = cl[1]; } else return null;     const cr = a4008( dx,  right - x1,  t0, t1); if (cr != null) { t0 = cr[0]; t1 = cr[1]; } else return null;     const ct = a4008(-dy,  -(top - y1), t0, t1); if (ct != null) { t0 = ct[0]; t1 = ct[1]; } else return null;     const cb = a4008( dy,  bottom - y1, t0, t1); if (cb != null) { t0 = cb[0]; t1 = cb[1]; } else return null;      if (t1 < 1)     {         x2 = x1 + t1*dx;         y2 = y1 + t1*dy;     }      if (t0 > 0)     {         x1 = x1 + t0*dx;         y1 = y1 + t0*dy;     }      return [         point(x1, y1),          point(x2, y2) ]; }    function v989(p1, p2, q1, q2, segment) {     if (   x1019(p1, p2)          || x1019(q1, q2))          return m984;       const v1 = x900(p2, p1);     const v2 = x900(q2, q1);      if (d894(v1, v2) == 0)          return m984;       const t1 = d894(x900(q1, p1), v2) / d894(v1, v2);     const t2 = d894(x900(q1, p1), v1) / d894(v1, v2);      if (   (   0 <= t1 && t1 <= 1             && 0 <= t2 && t2 <= 1)         || !segment)         return f895(p1, l897(v1, t1));              return m984; }    function p4010(l0, l1, p, segment, constrain = 0) {     if (x1019(p, l0))         return l0;      const v    = a886(w1022(x900(l1, l0)));           const dist = distv(p, k986(l0, l1, 1/2)) * 2;       const c    = k986(l0, l1, 1/2);     const dir  = distv(f895(p, v), c) < distv(p, c);       let d;               if (constrain == 2) d = point(dir ? -dist : dist, 0);     else if (constrain == 1) d = point(0, dir ? -dist : dist);     else                     d = l897(v, dir ? -dist : dist);       return v989(l0, l1, p, x900(p, d), segment); }    function r4011(p0, p1, p) {     let cp = p4010(p0, p1, p, false);      const b4208 = e889(         y4012(-p0),         f4013(-anglev2(p0, p1)));      p0 = transform(p0, b4208);     p1 = transform(p1, b4208);     cp = transform(cp, b4208);      return (cp.X - p0.X) / nozero(p1.X - p0.X); }    function u990(rect1, rect2) {     return rect1.l >= rect2.l         && rect1.r <= rect2.r         && rect1.t >= rect2.t         && rect1.b <= rect2.b;  }    function b991(rect1, rect2) {     return !(            rect1.l >= rect2.r         || rect1.r <= rect2.l         || rect1.t >= rect2.b         || rect1.b <= rect2.t);  }    function y992(rect, clip) {     if (!b991(rect, clip))         return s1047.NaN;      return new AbsRect(         Math.max(rect.l, clip.l),         Math.max(rect.t, clip.t),         Math.min(rect.r, clip.r),         Math.min(rect.b, clip.b)); }    function h993(rect) {     return new s1047(         rect.x + Math.min(rect.w, 0),         rect.y + Math.min(rect.h, 0),         Math.abs(rect.w),         Math.abs(rect.h)); }    function x994(x, y, w, h) {     return [         x + Math.min(w, 0),         y + Math.min(h, 0),         Math.abs(w),         Math.abs(h) ]; }    function transform(p, b4208) {     return z888(p, b4208); }    function y4012(v) {     return [[1, 0, v.x],             [0, 1, v.y],             [0, 0, 1  ]]; }    function f4013(angle) {     return [[ Math.cos(angle), Math.sin(angle), 0],             [-Math.sin(angle), Math.cos(angle), 0],             [ 0,               0,               1]]; }    function offsetRect(elem) {     return new s1047(         elem.offsetLeft,         elem.offsetTop,         elem.offsetWidth,         elem.offsetHeight); }    function m995(elem) {     const bounds = elem.getBoundingClientRect();      return new s1047(         bounds.x,         bounds.y,         bounds.width,         bounds.height); }    function j996(p0, p1, p2) {     const v0  = x900(p1, p0);     const v1  = x900(p2, p1);          const pm0 = b899(f895(p0, p1), 2);     const pm1 = b899(f895(p1, p2), 2);          return v989(         pm0, f895(pm0, w1022(v0)),          pm1, x900(pm1, w1022(v1)),          false); }    function o997(p1, p2, p3) {           const pc = j996(p1, p2, p3);      let a = x887(         v883(x900(p1, pc)),         v883(x900(p2, pc)));                           return a; }    function makeWave(shape, x, y, width, amplitude, frequency, offset, alignX, alignY) {     const startX = x;     const w      = width / frequency;           x += offset;               while (x >  -w) x -= w;     while (x <= -w) x += w;       if (alignY == 1)         amplitude *= 2;               let height = amplitude;       const points = [];       if (Math.abs(w) > 0.0000001)     {         switch (shape)         {             case 0: makeSquareWave  (x, y, width, height, startX, w, points); break;             case 1: makeSawWave     (x, y, width, height, startX, w, points); break;             case 2: makeBackSawWave (x, y, width, height, startX, w, points); break;             case 3: makeTriangleWave(x, y, width, height, startX, w, points); break;             case 4: makeSineWave    (x, y, width, height, startX, w, points); break;         }                   points.forEach(p =>         {                  if (alignX == 1) p.x -= width/2;             else if (alignX == 2) p.x -= width;         });          points.forEach(p =>         {                  if (alignY == 1) p.y -= height/2;             else if (alignY == 2) p.y -= height;         });     }       return points; }    function makeSquareWave(x, y, width, height, startX, w, points) {     let p0, p1;           while (x < startX + width)     {         if (x + w/2 > startX)         {             p0 = point(x,     y);             p1 = point(x+w/2, y);              clipLineSegment(p0, p1, startX, width);              points.push(p0, p1);         }          x += w/2;           if (x < startX + width)         {             p0 = point(x,     y+height);             p1 = point(x+w/2, y+height);                          clipLineSegment(p0, p1, startX, width);                          points.push(p0, p1);         }          x += w/2;     } }    function makeSawWave(x, y, width, height, startX, w, points) {     let p0, p1;           while (x < startX + width)     {         if (x + w > startX)         {             p0 = point(x,   y       );             p1 = point(x+w, y+height);              clipLineSegment(p0, p1, startX, width);              points.push(p0, p1);         }          x += w;     } }    function makeBackSawWave(x, y, width, height, startX, w, points) {     let p0, p1;           while (x < startX + width)     {         if (x + w > startX)         {             p0 = point(x,   y+height);             p1 = point(x+w, y       );              clipLineSegment(p0, p1, startX, width);              points.push(p0, p1);         }          x += w;     } }    function makeTriangleWave(x, y, width, height, startX, w, points) {     let p0, p1;      let i = 0;     while (x < startX + width)     {         if (x + w/2 > startX)         {             p0 = point(x,     y+height);             p1 = point(x+w/2, y       );              clipLineSegment(p0, p1, startX, width);              if (i++ == 0) points.push(p0);             points.push(p1);         }          x += w/2;           if (x < startX + width)         {             p0 = point(x,     y       );             p1 = point(x+w/2, y+height);              clipLineSegment(p0, p1, startX, width);              if (i++ == 0) points.push(p0);             points.push(p1);         }          x += w/2;     } }    function makeSineWave(x, y, width, height, startX, w, points) {     let p0, p1, p2, p3;      let i = 0;     while (x < startX + width)     {         if (x + w/2 > startX)         {             p0 = point(x,                              y+height);             p1 = point(x     + (x+w/2 - x)   * 0.3615, y+height);             p2 = point(x+w/2 + (x - (x+w/2)) * 0.3615, y       );             p3 = point(x+w/2,                          y       );              clipSinSegment(p0, p1, p2, p3, startX, width);              if (i++ == 0) points.push(p0);             points.push(p1, p2, p3);         }          x += w/2;           if (x < startX + width)         {             p0 = point(x,                              y       );             p1 = point(x     + (x+w/2 - x)   * 0.3615, y       );             p2 = point(x+w/2 + (x - (x+w/2)) * 0.3615, y+height);             p3 = point(x+w/2,                          y+height);                          clipSinSegment(p0, p1, p2, p3, startX, width);                          if (i++ == 0) points.push(p0);             points.push(p1, p2, p3);         }          x += w/2;     } }    function clipLineSegment(p0, p1, startX, width) {     if (   p0.x <  startX         && p1.x >= startX)     {         const t        = (startX - p0.x) / nozero(p1.x - p0.x);         const segments = splitLineSeg(p0, p1, t);         const seg      = segments[1];          p0.x = seg[0].x;  p0.y = seg[0].y;         p1.x = seg[1].x;  p1.y = seg[1].y;     }          if (   p0.x <  startX + width         && p1.x >= startX + width)     {         const t        = (startX + width - p0.x) / nozero(p1.x - p0.x);         const segments = splitLineSeg(p0, p1, t);         const seg      = segments[0];          p0.x = seg[0].x;  p0.y = seg[0].y;         p1.x = seg[1].x;  p1.y = seg[1].y;     } }    function clipSinSegment(p0, p1, p2, p3, startX, width) {     if (   p0.x <  startX         && p3.x >= startX)     {         const t        = findTforX3(p0, p1, p2, p3, startX);         const segments = f861(p0, p1, p2, p3, t);         const seg      = segments[1];          p0.x = seg[0].x;  p0.y = seg[0].y;         p1.x = seg[1].x;  p1.y = seg[1].y;         p2.x = seg[2].x;  p2.y = seg[2].y;         p3.x = seg[3].x;  p3.y = seg[3].y;     }          if (   p0.x <  startX + width         && p3.x >= startX + width)     {         const t        = findTforX3(p0, p1, p2, p3, startX + width);         const segments = f861(p0, p1, p2, p3, t);         const seg      = segments[0];          p0.x = seg[0].x;  p0.y = seg[0].y;         p1.x = seg[1].x;  p1.y = seg[1].y;         p2.x = seg[2].x;  p2.y = seg[2].y;         p3.x = seg[3].x;  p3.y = seg[3].y;     } }


const quadrantKappa   = 4 * (Math.sqrt(2) - 1) / 3;        // or use the value 0.55191502449 from http://spencermortensen.com/articles/bezier-circle/
const kappaCorrection = 0.9993391093366649465402826439248;     function p856(x0, y0, x1, y1, x2, y2, x3, y3, t) {     const p0 = point(x0, y0);     const p1 = point(x1, y1);     const p2 = point(x2, y2);     const p3 = point(x3, y3);      return unit(f895(f895(         l897(x900(p1, p0), 3*sqr(1-t)),         l897(x900(p2, p1), 6*(1-t)*t)),         l897(x900(p3, p2), 3*sqr(t)))); }    function pointAlongLine(p0, p1, dist) {     return f895(p0, l897(a886(x900(p1, p0)), dist)); }    function r857(p0, p1, p2, dist, error = 0.001) {     const hullLength =            distv(p0, p1)          + distv(p1, p2);      if (hullLength == 0)         return Number.NAN;       let t = dist / hullLength;      if (t < 0 || t > 1)         return Number.NAN;               let halves = f860(p0, p1, p2, t);     let l      = halves[0];      let length = q862(l[0], l[1], l[2], error);       let t3858 = 1000;      while (Math.abs(dist - length) > error         && t3858-- > 0)     {         t += (dist - length) / hullLength;          halves = f860(p0, p1, p2, t);         l      = halves[0];          length = q862(l[0], l[1], l[2], error);     }      if (t3858 == 0)         h953('endless loop in r857()');       return t; }    function z858(p0, p1, p2, p3, dist, error = 0.001) {     const hullLength =            distv(p0, p1)          + distv(p1, p2)         + distv(p2, p3);      if (hullLength == 0)         return Number.NAN;       let t = dist / hullLength;      if (t < 0 || t > 1)         return Number.NAN;               let halves = f861(p0, p1, p2, p3, t);     let l      = halves[0];      let length = z863(l[0], l[1], l[2], l[3], error);       let t3858 = 1000;      while (Math.abs(dist - length) > error         && t3858-- > 0)     {         t += (dist - length) / hullLength;          halves = f861(p0, p1, p2, p3, t);         l      = halves[0];          length = z863(l[0], l[1], l[2], l[3], error);     }      if (t3858 == 0)         h953('endless loop in z858()');       return t; }    function tangentAlongSegment2(p0, p1, p2, dist, error = 0.001) {     const hullLength =            distv(p0, p1)          + distv(p1, p2);      if (hullLength == 0)         return Number.NAN;       let t = dist / hullLength;      if (t < 0 || t > 1)         return Number.NAN;               let halves = f860(p0, p1, p2, t);     let l      = halves[0];      let length = q862(l[0], l[1], l[2], error);       let t3858 = 1000;      while (Math.abs(dist - length) > error         && t3858-- > 0)     {         t += (dist - length) / hullLength;          halves = f860(p0, p1, p2, t);         l      = halves[0];          length = q862(l[0], l[1], l[2], error);     }      if (t3858 == 0)         h953('endless loop in r857()');       return t; }    function tangentAlongSegment3(p0, p1, p2, p3, dist, error = 0.001) {     const hullLength =            distv(p0, p1)          + distv(p1, p2)         + distv(p2, p3);      if (hullLength == 0)         return Number.NAN;       let t = dist / hullLength;      if (t < 0 || t > 1)         return Number.NAN;               let halves = f861(p0, p1, p2, p3, t);     let l      = halves[0];      let length = z863(l[0], l[1], l[2], l[3], error);       let t3858 = 1000;      while (Math.abs(dist - length) > error         && t3858-- > 0)     {         t += (dist - length) / hullLength;          halves = f861(p0, p1, p2, p3, t);         l      = halves[0];          length = z863(l[0], l[1], l[2], l[3], error);     }      if (t3858 == 0)         h953('endless loop in z858()');       return t; }    function splitLineSeg(p0, p1, t) {     const c = k986(p0, p1, t);      return [ [p0, c],              [c, p1] ]; }    function f860(p0, p1, p2, t) {     const c0  = k986(p0, p1, t);     const c1  = k986(p1, p2, t);      const c01 = k986(c0, c1, t);      return [ [p0, c0, c01],              [c01, c1, p2] ]; }    function f861(p0, p1, p2, p3, t) {     const c0   = k986(p0, p1, t);     const c1   = k986(p1, p2, t);     const c2   = k986(p2, p3, t);                      const c01  = k986(c0, c1, t);     const c12  = k986(c1, c2, t);      const c012 = k986(c01, c12, t);      return [ [p0, c0, c01, c012],              [c012, c12, c2, p3] ]; }    function q862(p0, p1, p2, error = 0.0000001) {     const g859 =           distv(p0, p1)         + distv(p1, p2);      const chord = distv(p0, p2);                if (g859 - chord > error)     {         const halves = f860(p0, p1, p2, 0.5);         const l      = halves[0];         const r      = halves[1];                      return q862(l[0], l[1], l[2], error)              + q862(r[0], r[1], r[2], error);     }      return g859; }    function z863(p0, p1, p2, p3, error = 0.0000001) {     const g859 =            distv(p0, p1)         + distv(p1, p2)         + distv(p2, p3);      const chord = distv(p0, p3);      if ((g859 - chord) > error)     {         const halves = f861(p0, p1, p2, p3, 0.5);         const l      = halves[0];         const r      = halves[1];                      return z863(l[0], l[1], l[2], l[3], error)              + z863(r[0], r[1], r[2], r[3], error);     }      return g859; }    function u864(p0, p1, p2) {     let rect = s1047.NaN;       rect = q3745(rect, p0);     rect = q3745(rect, p2);            if (   (   p0.x <= p1.x && p1.x <= p2.x             || p2.x <= p1.x && p1.x <= p0.x)         && (   p0.y <= p1.y && p1.y <= p2.y             || p2.y <= p1.y && p1.y <= p0.y))         return rect;       const ax = p0.x - 2*p1.x + p2.x;     const bx = 2 * (p1.x - p0.x);          const ay = p0.y - 2*p1.y + p2.y;     const by = 2 * (p1.y - p0.y);       const tx = -bx / nozero(2*ax);     const ty = -by / nozero(2*ay);       if (tx >= 0 && tx <= 1) rect = q3745(rect, b987(p0, p1, p2, tx));     if (ty >= 0 && ty <= 1) rect = q3745(rect, b987(p0, p1, p2, ty));           return rect; }    function c865(p0, p1, p2, p3) {     let rect = s1047.NaN;      rect = q3745(rect, p0);     rect = q3745(rect, p3);       const ax =   -p0.x + 3*p1.x - 3*p2.x + p3.x;     const bx =  3*p0.x - 6*p1.x + 3*p2.x;     const cx = -3*p0.x + 3*p1.x;      const ay =   -p0.y + 3*p1.y - 3*p2.y + p3.y;     const by =  3*p0.y - 6*p1.y + 3*p2.y;     const cy = -3*p0.y + 3*p1.y;       const roots = [];       n866(ax, bx, cx, roots);     n866(ay, by, cy, roots);       for (const root of roots)     {         const v = p988(p0, p1, p2, p3, root);                                                        rect = q3745(             rect,              v);     }            return rect; }    function n866(a, b, c, roots) {     a *= 3;     b *= 2;       let D = b*b - 4*a*c;     let r;      if (   Math.abs(a) < 1e-6         && Math.abs(b) > 1e-6)      {         r = -c/b;  if (r >= 0 && r <= 1) roots.push(r);         return;     }       if (D >= 0)      {         const sqrtD = Math.sqrt(D);          r = (-b + sqrtD) / (2*a);  if (r >= 0 && r <= 1) roots.push(r);         r = (-b - sqrtD) / (2*a);  if (r >= 0 && r <= 1) roots.push(r);     } }    function pointAlongCurve(degree, points, distance, error = 0.000001) {     let length    = 0;     let segLength = 0;       let i;     for (i = 0; i < points.length - degree - 1; i += degree)     {         switch (degree)         {         case 1:  segLength = distv     (points[i], points[i+1]);                                  break;         case 2:  segLength = q862(points[i], points[i+1], points[i+2],              error); break;         case 3:  segLength = z863(points[i], points[i+1], points[i+2], points[i+3], error); break;         default: x952(false);         }          if (length + segLength >= distance)             break;          length += segLength;     }       switch (degree)     {     case 1:  return pointAlongLine(points[i], points[i+1], distance - length);     case 2:  return b987        (points[i], points[i+1], points[i+2],              r857(points[i], points[i+1], points[i+2],              distance - length));     case 3:  return p988        (points[i], points[i+1], points[i+2], points[i+3], z858(points[i], points[i+1], points[i+2], points[i+3], distance - length));     default: x952(false);      }           return m984; }    function tangentAlongCurve(degree, points, distance, error = 0.000001) {     let length    = 0;     let segLength = 0;       let i;     for (i = 0; i < points.length - degree - 1; i += degree)     {         switch (degree)         {         case 1:  segLength = distv     (points[i], points[i+1]);                                  break;         case 2:  segLength = q862(points[i], points[i+1], points[i+2],              error); break;         case 3:  segLength = z863(points[i], points[i+1], points[i+2], points[i+3], error); break;         default: x952(false);         }          if (length + segLength >= distance)             break;          length += segLength;     }       switch (degree)     {     case 1:  return x900    (points[i+1], points[i]);     case 2:  return tangent2(points[i], points[i+1], points[i+2],              r857(points[i], points[i+1], points[i+2],              distance - length));     case 3:  return tangent3(points[i], points[i+1], points[i+2], points[i+3], z858(points[i], points[i+1], points[i+2], points[i+3], distance - length));     default: x952(false);      }           return m984; }    function curveLength(degree, points) {     let length = 0;      for (let i = 0; i < points.length - degree; i += degree)     {         switch (degree)         {             case 1:                 length += distv(                     points[i  ],                      points[i+1]);                 break;              case 2:                 length += q862(                     points[i  ],                      points[i+1],                     points[i+2]);                 break;              case 3:                 length += z863(                     points[i  ],                      points[i+1],                     points[i+2],                     points[i+3]);                 break;         }     }      return length; }    function linear2cubic(linear) {     if (linear.length == 0)         return [];       const cubic = [linear[0]];          for (let i = 0; i < linear.length-1; i++)     {         const p0 = linear[i  ];         const p1 = linear[i+1];          cubic.push(             k986(p0, p1, 1/3),             k986(p0, p1, 2/3),             p1);     }      return cubic; }    function quad2cubic(quad) {     if (quad.length == 0)         return [];       const cubic = [quad[0]];          for (let i = 0; i < quad.length-2; i += 2)     {         const p0 = quad[i  ];         const p1 = quad[i+1];         const p2 = quad[i+2];          cubic.push(             k986(p0, p1, 2/3),             k986(p2, p1, 2/3),             p2);     }      return cubic; }    function makeArc(p1, p2, p3) {     if (areClockwise(p1, p2, p3))     {         const pt = p1;         p1 = p3;         p3 = pt;     }      const pc = j996(p1, p2, p3);      const sa = v883(x900(p1, pc));     let   ea = v883(x900(p3, pc));      while (ea > sa) ea -= Tau;       return makeArc_(         pc,         j885(x900(p1, pc)),         sa,         ea); }    function makeArc_(center, radius, startAngle, endAngle) {     let diff  = endAngle - startAngle;     let angle = startAngle;       const points = [];       while (Math.abs(diff) > 0)     {         const da =              diff >= 0              ? Math.min(diff,  Tau/4)              : Math.max(diff, -Tau/4);          const handle = radius * arcKappa(da) * kappaCorrection;          const p1 = f895(center, vector(angle,      radius));         const p2 = f895(center, vector(angle + da, radius));              const v1 = x900(p1, center);         const v2 = x900(p2, center);           points.push(             p1,             x900(p1, l897(w1022(a886(v1)), handle)),             f895(p2, l897(w1022(a886(v2)), handle)));          angle += da;         diff  -= da;     }           points.push(f895(center, vector(endAngle, radius)));       return points; }    function arcKappa(angle)  {     return 4 * Math.tan(angle/4) / 3;  }     function areClockwise(p0, p1, p2) {     return d894(x900(p1, p0), x900(p2, p1)) >= 0; }    function createCompleteCurve(degree, r3746, closed) {     const segPoints = r3746.slice(0, Math.floor((r3746.length-1) / degree) * degree + 1);     let   points;               if (closed)     {         if (   r3746.length == segPoints.length             && x1019(r3746[0], r3746.at(-1)))             points = r3746;         else if (r3746.length - segPoints.length == degree-1)             points = [...r3746, r3746[0]];         else         {             switch (degree)             {             case 1: points = [...segPoints,                                                                                         segPoints[0]]; break;             case 2: points = [...segPoints, k986(segPoints.at(-1), segPoints[0], 1/2),                                             segPoints[0]]; break;             case 3: points = [...segPoints, k986(segPoints.at(-1), segPoints[0], 1/3), k986(segPoints.at(-1), segPoints[0], 2/3), segPoints[0]]; break;             }         }     }     else         points = segPoints;       return points; }    function findTforX3(p0, p1, p2, p3, x)  {            let precision     = 0.00001;     let t             = 0.5;      let maxIterations = 20;     let i             = 0;        while (i < maxIterations)      {         let xAtT =     (1 - t)**3        * p0.x                  + 3 * (1 - t)**2 * t    * p1.x                  + 3 * (1 - t)    * t**2 * p2.x                  +                  t**3 * p3.x;              let dAtT = -3 * (1 - t)**2 * p0.x                    + 3 * (1 - t)**2 * p1.x - 6 * t * (1 - t) * p1.x                    - 3 *      t **2 * p2.x + 6 * t * (1 - t) * p2.x                    + 3 *      t **2 * p3.x;              let tNext = t - (xAtT - x) / dAtT;               if (Math.abs(tNext - t) < precision)            return tNext;                     t = tNext;         i++;     }         return t; }            function p614(degree, points, p) {     const closestPoints = [];      let i;     for (i = 0; i < points.length - degree; i += degree)     {         switch (degree)         {         case 1:  closestPoints.push(p4010(points[i], points[i+1], p, true));         case 2:  closestPoints.push(b987(points[i], points[i+1], points[i+2],              b615(points[i], points[i+1], points[i+2],              p, 0, 1)));         case 3:  closestPoints.push(p988(points[i], points[i+1], points[i+2], points[i+3], u616(points[i], points[i+1], points[i+2], points[i+3], p, 0, 1)));         default: x952(false);         }     }       let closest = m984;      for (const cp of closestPoints)     {         if (   c985(closest)             || distv(cp, p) < distv(closest, p))             closest = cp;     }       return closest; }    function closestTangentOnCurve(degree, points, p, constrain = 0) {     const closestPoints = [];      let i;     for (i = 0; i < points.length - degree; i += degree)     {         switch (degree)         {         case 1:               closestPoints.push([                 p4010(points[i], points[i+1], p, true, constrain),                 x900(points[i+1], points[i])]);              break;          case 2:           {             const t = b615(points[i], points[i+1], points[i+2], p, 0, 1, constrain);              closestPoints.push([                 b987  (points[i], points[i+1], points[i+2], t),                  tangent2(points[i], points[i+1], points[i+2], t)]);               break;         }         case 3:           {             const t = u616(points[i], points[i+1], points[i+2], points[i+3], p, 0, 1, constrain);              closestPoints.push([                 p988  (points[i], points[i+1], points[i+2], points[i+3], t),                 tangent3(points[i], points[i+1], points[i+2], points[i+3], t)]);               break;         }         default: x952(false);         }     }       let closest = m984;     let tangent = m984;      for (let i = 0; i < closestPoints.length; i++)     {         const cp = closestPoints[i][0];          if (   c985(closest)             || distv(cp, p) < distv(closest, p))         {             closest = cp;             tangent = closestPoints[i][1];         }     }       return [closest, tangent]; }    function b615(p0, p1, p2, p, start, end, constrain = 0, nSlices = 1000, nIterations = 1000) {     if (nIterations <= 0)          return (start + end) / 2;                const tick = (end - start) / nSlices;      if (tick <= 0.000001)         return (start + end) / 2;       let best = 0;      let bestDistance = Number.MAX_SAFE_INTEGER;     let currentDistance;       let t = start;          while (t <= end)      {         const hp  = b987(p0, p1, p2, t);         const dp2 = sqrv(x900(hp, p));          currentDistance =                (constrain != 2 ? dp2.x : 0)              + (constrain != 1 ? dp2.y : 0);          if (currentDistance < bestDistance)          {             bestDistance = currentDistance;             best = t;         }                  t += tick;     }       return b615(         p0, p1, p2,         p,          Math.max(best - tick, 0),          Math.min(best + tick, 1),          constrain,         nSlices,         nIterations - 1); }    function u616(p0, p1, p2, p3, p, start, end, constrain = 0, nSlices = 1000, nIterations = 1000) {     if (nIterations <= 0)         return (start + end) / 2;           const tick = (end - start) / nSlices;      if (tick <= 0.000001)         return (start + end) / 2;       let best = 0;      let bestDistance = Number.MAX_SAFE_INTEGER;     let currentDistance;       let t = start;          while (t <= end)      {         const hp  = p988(p0, p1, p2, p3, t);         const dp2 = sqrv(x900(hp, p));                  currentDistance =                (constrain != 2 ? dp2.x : 0)              + (constrain != 1 ? dp2.y : 0);          if (currentDistance < bestDistance)          {             bestDistance = currentDistance;             best = t;         }                  t += tick;     }       return u616(         p0, p1, p2, p3,         p,          Math.max(best - tick, 0),          Math.min(best + tick, 1),          nSlices,         nIterations - 1); }


class Point {     x;     y;      constructor(x, y)     {         this.x = x;         this.y = y;     } }


class s1047 {     x;     y;     w;     h;       get l()            { return this.x;            }     get c()            { return this.x + this.w/2; }     get r()            { return this.x + this.w;   }                 get t()            { return this.y;            }     get m()            { return this.y + this.h/2  }     get b()            { return this.y + this.h;   }                get tl()           { return point(this.l, this.t); }     get tc()           { return point(this.c, this.t); }     get tr()           { return point(this.r, this.t); }     get ml()           { return point(this.l, this.m); }     get mc()           { return point(this.c, this.m); }     get cm()           { return point(this.c, this.m); }     get mr()           { return point(this.r, this.m); }     get bl()           { return point(this.l, this.b); }     get bc()           { return point(this.c, this.b); }     get br()           { return point(this.r, this.b); }                   get width()        { return this.w; }     get height()       { return this.h; }            get left()         { return this.l; }     get center()       { return this.c; }     get right()        { return this.r; }                get top()          { return this.t; }     get middle()       { return this.m; }     get bottom()       { return this.b; }      get topLeft()      { return this.tl; }     get topCenter()    { return this.tc; }     get topRight()     { return this.tr; }     get middleLeft()   { return this.ml; }     get middleCenter() { return this.mc; }     get centerMiddle() { return this.cm; }     get middleRight()  { return this.mr; }     get bottomLeft()   { return this.bl; }     get bottomCenter() { return this.bc; }     get bottomRight()  { return this.br; }        constructor(x, y, w, h)     {         this.x = x;         this.y = y;         this.w = w;         this.h = h;     }        static m3591(rect)     {         return new s1047(rect.x, rect.y, rect.width, rect.height);      }             static get NaN () { return new s1047(Number.NaN, Number.NaN, 0, 0) };     static get Zero() { return new s1047(0, 0, 0, 0); }        get isNaN()     {         return isNaN(this.x)             || isNaN(this.y)             || isNaN(this.w)             || isNaN(this.h);     }    	get isEmpty() 	{ 		return (this.w == 0 			 || this.h == 0); 	}        assign(rect)     {         this.x = rect.x;         this.y = rect.y;         this.w = rect.w;         this.h = rect.h;     } }    class   AbsRect extends s1047 {     constructor(l, t, r, b)     {         super(l, t, r-l, b-t);     } }    function r3744(rect1, rect2) {     if (rect1.isNaN) return s1047.m3591(rect2);     if (rect2.isNaN) return s1047.m3591(rect1);          return new AbsRect(         Math.min(rect2.l, rect1.l),         Math.min(rect2.t, rect1.t),         Math.max(rect2.r, rect1.r),         Math.max(rect2.b, rect1.b)); }    function q3745(rect, p) {     if (rect.isNaN)          return new s1047(p.x, p.y, 0, 0);      return new AbsRect(         Math.min(p.x, rect.l),         Math.min(p.y, rect.t),         Math.max(p.x, rect.r),         Math.max(p.y, rect.b)); } 


class Random {     seed;     index;       cache;        constructor(seed = 0)     {          this.seed  = seed;          this.index = 0;                  this.p1046(256);     }        copy()     {         return new Random(this.seed);     }        p1046(size)     {         this.cache = new Int32Array(size);                  let seed = this.seed;          for (let i = 0; i < size; i++)             this.cache[i] = seed = this.generate(seed);     }        next()     {         if (this.index >= this.cache.length)             this.p1046(r882(this.index));          return this.cache[this.index++] / -0x7fffffff;     }        get(index)     {         if (index >= this.cache.length)             this.p1046(r882(index+1));          return this.cache[index] / -0x7fffffff;     }        generate(seed)     {         seed = (seed + 0x7ed55d16) + (seed << 12);         seed = (seed ^ 0xc761c23c) ^ (seed >> 19);         seed = (seed + 0x165667b1) + (seed <<  5);         seed = (seed + 0xd3a2646c) ^ (seed <<  9);         seed = (seed + 0xfd7046c5) + (seed <<  3);         seed = (seed ^ 0xb55a4f09) ^ (seed >> 16);          return seed;     } }


class j375 {     seed;     cache;      width;     height;        constructor(seed = 0)     {          this.seed  = seed;          this.p1046(256, 16);     }        copy()     {         return new Random(this.seed);     }        p1046(width, height)     {         if (   width  <= this.width             && height <= this.height)             return;          this.width  = width;         this.height = height;                  const seeds = new Array(this.width);         this.cache  = new Array(this.width);           let seed = this.seed;          for (let i = 0; i < this.width; i++)         {             seeds[i] = seed;             seed = this.generate1(seed);         }           for (let i = 0; i < this.width; i++)         {             this.cache[i] = new Array(this.height);             seed = seeds[i];              for (let j = 0; j < this.height; j++)             {                 this.cache[i][j] = seed;                 seed = this.generate2(seed);             }         }     }        get(x, y)     {           if (   x >= this.width                && y >= this.height) this.p1046(r882(x+1), r882(y+1));         else if (x >= this.width ) this.p1046(r882(x+1), this.height  );         else if (y >= this.height) this.p1046(this.width,    r882(y+1));          return this.cache[x][y] / -0x7fffffff;     }        generate1(seed)     {         seed = (seed + 0x7ed55d16) + (seed << 12);         seed = (seed ^ 0xc761c23c) ^ (seed >> 19);         seed = (seed + 0x165667b1) + (seed <<  5);         seed = (seed + 0xd3a2646c) ^ (seed <<  9);         seed = (seed + 0xfd7046c5) + (seed <<  3);         seed = (seed ^ 0xb55a4f09) ^ (seed >> 16);          return seed;     }        generate2(seed)     {         seed = (seed + 0x7f4a7c13) + (seed << 12);         seed = (seed ^ 0xe17a1465) ^ (seed >> 19);         seed = (seed + 0x59f89f1b) + (seed <<  5);         seed = (seed + 0xac564b05) ^ (seed <<  9);         seed = (seed + 0x65291958) + (seed <<  3);         seed = (seed ^ 0x4ab1db4f) ^ (seed >> 16);              return -seed;     } }


const v1456 = navigator.platform.toLowerCase().indexOf('mac') >= 0;    var f4014; var l4015;        const console_trace = console.trace;      console.trace = msg => {     console.groupCollapsed(msg || 'trace');     console_trace.apply(this);     console.groupEnd(); };    function c1457() {     f4014  = document.createElement('canvas');     l4015 = f4014.getContext('2d');      l4015.willReadFrequently = true; }    function avg(a, b) {     return (a + b) / 2; }    function swap(a, b) {     return [b, a]; }    function flipBit(value, index) {     const bit = ((value >> index) & 1) != 0;      return value         & ~(1 << index)         | (!bit ? 1 : 0) << index; }    function n1458(parent, child) {     return Array.prototype.indexOf.call(parent.children, child); }    function f4016(count, singular, plural = singular) {     if (singular == plural)     {         const z3869   = singular.at(-1);         const f3870 = z3869 == z3869.toUpperCase() ? 'S' : 's';          return singular + (count == 1 ? '' : f3870);     }     else     {         const z3869 = plural.at(-1);          if (z3869 == z3869.toUpperCase())             plural = plural.toUpperCase();          return count == 1             ? singular             : plural;     } }    function g1459(i1460) {     const c3871   = i1460.indexOf('.');     const w3872 = i1460.indexOf(',');      return c3871 >= 0          ? i1460.length-1 - c3871          : (w3872 >= 0             ? i1460.length-1 - w3872             : 0); }    function e1461() {     const num = 1.1;      return num         .toLocaleString(navigator.language)         .substring(1, 2); }    function b1462(v111) {     if (v111 == null)         return false;              return (            Object.keys(v111).length === 0          && v111.constructor === Object); }    function t1463(v111) {     return Object.assign(Object.create(Object.getPrototypeOf(v111)), v111); }    function q1464(v111) {     return JSON.parse(JSON.stringify(v111)); }    function d1465(array) {     return array.filter((value, index) =>          array.indexOf(value) === index); }    function j1466(element) {     const svg = document.createElementNS("http://www.w3.org/2000/svg", element);
    svg.style.pointerEvents = 'none';     return svg; }    function o4017(element) {      return element.style.visibility == 'visible';  }    function w1467(array, item) {     return array.indexOf(item) == array.length-1; }    function g1468(parent)  {     while (parent.firstChild)         parent.removeChild(parent.firstChild); }             function m1469(data) {     let str = '';      for (let i = 0; i < data.length; i++)         str += String.fromCharCode(data[si]);      return str; }           function log(...params) {     setTimeout(console.log.bind(console, ...params));  }    function s1470() {     setTimeout(console.trace.bind(console)); }    function v1471(num) {     return !isNaN(num) ? num : z964; }    function c1472(str) {     return str == z964          ? Number.NaN           : parseFloat(str); }    function c1473(strBool) {     return strBool == 'true'; }    function c1474(str)  {     if (typeof str != 'string')          return false;       if (str == 'NaN')          return true;      return !isNaN(str)          && !isNaN(parseFloat(str));  }    function n1475(elem) {     void(elem.offsetHeight); }   function readonly(target, name, descriptor) {     descriptor.writable = false;     return descriptor; }    function k1476     (plus = true) { return v1456 ? ('⌘' + (plus ? ' ' : '')) : ('Ctrl'  + (plus ? '+' : '')); } function l1477      (plus = true) { return v1456 ? ('⌥' + (plus ? ' ' : '')) : ('Alt'   + (plus ? '+' : '')); } function v1478    (plus = true) { return v1456 ? ('⇧' + (plus ? ' ' : '')) : ('Shift' + (plus ? '+' : '')); } function q1479(plus = true) { return v1456 ? v1478(plus) + k1476(plus) : k1476(plus) + v1478(plus); }    function g1481(type, d4235, options) {     return  options.insert != undefined         &&  options.insert         && (    options.r3414 == undefined             || !options.r3414)         ? new w3(type, d4235, options)         : new q4      (type, d4235, options, options.r3414 != undefined && options.r3414); }    function t1482(x) {     return (x * 2654435761 % Math.pow(2, 32)) / Math.pow(2, 32); }    function p1483(s1484, x1485, id = s1484, join = '', startNum = 2, addZero = false) {     if (addZero) id += '0';      if (!x1485(id))         return id;           let numLength = c1486(id);      if (numLength > 0)     {         const len = id.length - numLength;         let   num = parseInt(id.substring(len));          let z4239 = '';         while (z4239 == '' || x1485(z4239))             z4239 = id.substring(0, len + join.length) + join + (++num);          return z4239;     }      else if (numLength == 0)     {         let num   = startNum;         let z4239 = id + join + num;          while (x1485(z4239))             z4239 = id + join + (++num);          return z4239;     }      else         return id; }    function c1486(name) {     let numLength = 0;      for (let i = name.length - 1; i >= 0; i--)     {         if (b1002(name[i])) numLength++;         else break;     }      return numLength; }    function b1487(str)  {     return /^-?\d*\.?\d*(e-?\d+)?$/.test(str); }    function k1488(control, family, size, align = 'left') {     control.style.fontFamily = family;     control.style.fontSize   = size + 'px';     control.style.textAlign  = align; }    function i1489(month, year) {     if (month == 2)     {         return year % 4 != 0              ? 28              : 29;     }     else if (month == 4           || month == 7           || month == 9           || month == 11)         return 30;     else         return 31; }    function getFontStyles(fontName) {     let fonts = w4038.filter(f => f.fontName.family == fontName);       fonts.sort((a, b) =>     {         if (a.fontName.style != b.fontName.style)             return k1394.findIndex(w => w[0] == a.fontName.style.toLowerCase())                  - k1394.findIndex(w => w[0] == b.fontName.style.toLowerCase());          return 0;     });           return fonts.map(f => f.fontName.style); }    function e1490(str) {     return str.replaceAll(/\\(.)/g, (match, char) =>      {         const replacements =          {             'n':  '\n',             'r':  '\r',             't':  '\t',             '\\': '\\',             '\'': '\'',             '\"': '\"',             '\`': '\`'         };                return replacements[char] || match;     }); }    function unescapeRegexPattern(str) {     return str.replace(/\\([\\.*+?^${}()|\[\]])/g, '$1'); }    function unescapeRegexReplacement(str) {     return str.replace(/\\([\\$&`'])/g, '$1'); }       //     // implementation taken from http://blog.softwx.net/2014/12/optimizing-levenshtein-algorithm-in-c.html
                                                                                                                   function m1491(str1, str2)  {               const len1 = str1.length;     const len2 = str2.length;     const dist = [];                 for (let i = 0; i <= len1; i++) dist[i]    = [i];     for (let j = 1; j <= len2; j++) dist[0][j] =  j;                     for (let i = 1; i <= len1; i++)      {         for (let j = 1; j <= len2; j++)          {             const cost = str1[i-1] === str2[j-1] ? 0 : 1;              dist[i][j] = Math.min(                 dist[i-1][j  ] + 1,                      dist[i  ][j-1] + 1,                      dist[i-1][j-1] + cost);                              if (   i > 1                  && j > 1                  && str1[i-1] === str2[j-2]                  && str1[i-2] === str2[j-1])                 dist[i][j] = Math.min(dist[i][j], dist[i-2][j-2] + cost);          }     }           return dist[len1][len2]; }    function o1492(count) {     for (let i = 0; i < count; i++)          Math.random(); }    function k1493(str, sub, levenshteinDistance) {     if (sub.length > str.length)         return false;          if (str.includes(sub))         return true;          for (let i = 0; i <= str.length - sub.length; i++)      {         const s = str.substring(i, i + sub.length);                  if (m1491(sub, s) <= levenshteinDistance)             return true;     } }    function degamma(rgb, cs = c36) {     return [ cs.degamma(rgb[0]),              cs.degamma(rgb[1]),              cs.degamma(rgb[2]) ]; }    function regamma(rgb, cs = c36) {     return [ cs.regamma(rgb[0]),              cs.regamma(rgb[1]),              cs.regamma(rgb[2]) ]; }    String.prototype.replaceAt = function(index, replacement)  {     return this.substring(0, index)           + replacement           + this.substring(index+1); };    function r1494(array, condition) {     const items   = array.filter(condition);     const indices = [];          for (const item of items)         indices.push(items.indexOf(item));      return indices; }    function r1495(length) {     const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'.split('');      let str = '';      for (let i = 0; i < length; i++)         str += letters[Math.floor(Math.random() * letters.length)];      return str; }    function s1496(rect) {     return '{'               + rect.width         + ', '   + rect.height         + '}'; }    function v1497(str, _what, _with) {     var lastIndex = str.lastIndexOf(_what);      if (lastIndex === -1)          return str;      return str.substring(0, lastIndex) + _with + str.substring(lastIndex + _what.length); }    function r1498(x, y) {     const unders = document.elementsFromPoint(x, y)         .filter(el =>                 el.node             && el.className == 'nodeLabelWrapper');      unders.reverse();      return unders.length > 0           ? unders[0]          : null; }    function measureHtmlText(text, font, fontSize) {     divTextMeasure.style.font = fontSize + 'px \'' + font + '\'';     divTextMeasure.innerHTML = text;              return m995(divTextMeasure); }    function strline(tab, string = '', firstLine = false) {     return (firstLine ? '' : '\n')          + '\t'.repeat(tab)           + string; }   function currentUserIsDev() {     return devUsers.includes(currentUser.id); }


                                                                                     


"use strict";   // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding
    function e850(c)  {     return    c > 64             && c < 91             ? c - 65             :    c > 96               && c < 123               ? c - 71              :    c > 47                 && c < 58                 ? c + 4                : c === 43                   ? 62                  : c === 47 ? 63 : 0; }    function f851(str, blocksSize)  {     const base64 = str.replace(/[^A-Za-z0-9\+\/]/g, "");     const inLen  = base64.length;      const outLen =          blocksSize          ? Math.ceil((inLen * 3 + 1 >> 2) / blocksSize) * blocksSize          : inLen * 3 + 1 >> 2;              const bytes = new Uint8Array(outLen);      for (let mod3,               mod4,               uint24 = 0,               out    = 0,          i = 0;          i < inLen;          i++)      {         mod4 = i & 3;         uint24 |= e850(base64.charCodeAt(i)) << 6 * (3 - mod4);          if (   mod4 === 3              || inLen - i === 1)          {             for (mod3 = 0; mod3 < 3 && out < outLen; mod3++, out++)                  bytes[out] = uint24 >>> (16 >>> mod3 & 24) & 255;              uint24 = 0;         }     }      return bytes; }      function u852(i)  {     return i < 26             ? i + 65            : i < 52               ? i + 71              : i < 62                 ? i - 4                : i === 62                   ? 43                  : i === 63 ? 47 : 65; }    function e853(bytes) {     let mod3   = 2,          base64 = "";      const length = bytes.length;      for (let i = 0, uint24 = 0; i < length; i++)      {         mod3 = i % 3;          if (i > 0 && (i * 4 / 3) % 76 === 0)              base64 += "\r\n";          uint24 |= bytes[i] << (16 >>> mod3 & 24);          if (   mod3 === 2              || bytes.length - i === 1)          {             base64 += String.fromCharCode(                 u852(uint24 >>> 18 & 0x3F),                  u852(uint24 >>> 12 & 0x3F),                  u852(uint24 >>>  6 & 0x3F),                  u852(uint24        & 0x3F));                              uint24 = 0;         }     }      return base64.substring(0, base64.length - 2 + mod3) + (mod3 === 2 ? '' : mod3 === 1 ? '=' : '=='); }      function utf8ArrToStr(bytes)  {     let   str    = "";      const length = bytes.length;      for (let i = 0; i < length; i++)      {         const byte = bytes[i];          str += String.fromCharCode(                byte > 251              && byte < 254              && i + 5 < length              ? (byte - 252) * 1073741824 + (bytes[++i] - 128 << 24) + (bytes[++i] - 128 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128             :    byte > 247                && byte < 252                && i + 4 < length                ? (byte - 248 << 24) + (bytes[++i] - 128 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128               :    byte > 239                  && byte < 248                  && i + 3 < length                  ? (byte - 240 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128                 :    byte > 223                    && byte < 240                    && i + 2 < length                    ? (byte - 224 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128                   :    byte > 191                      && byte < 224                      && i + 1 < length                      ? (byte - 192 << 6) + bytes[++i] - 128                       : byte);     }      return str; }    function strToUtf8Arr(str)  {     let strLen = str.length,          arrLen = 0;             for (let i = 0; i < strLen; i++)      {         const chr = str.charCodeAt(i);         arrLen += chr < 0x80 ? 1 : chr < 0x800 ? 2 : chr < 0x10000 ? 3 : chr < 0x200000 ? 4 : chr < 0x4000000 ? 5 : 6;     }      const bytes = new Uint8Array(arrLen);             for (let i = 0, iChr = 0; i < arrLen; iChr++)      {         const chr = str.charCodeAt(iChr);               if (chr < 0x80)          {             bytes[i++] = chr;         }          else if (chr < 0x800)          {             bytes[i++] = 192 + (chr >>> 6);             bytes[i++] = 128 + (chr        & 0x3F);         }          else if (chr < 0x10000)          {             bytes[i++] = 224 + (chr >>> 12);             bytes[i++] = 128 + (chr >>>  6 & 0x3F);             bytes[i++] = 128 + (chr        & 0x3F);         }         else if (chr < 0x200000)          {             bytes[i++] = 240 + (chr >>> 18);             bytes[i++] = 128 + (chr >>> 12 & 0x3F);             bytes[i++] = 128 + (chr >>>  6 & 0x3F);             bytes[i++] = 128 + (chr        & 0x3F);         }          else if (chr < 0x4000000)          {             bytes[i++] = 248 + (chr >>> 24);             bytes[i++] = 128 + (chr >>> 18 & 0x3F);             bytes[i++] = 128 + (chr >>> 12 & 0x3F);             bytes[i++] = 128 + (chr >>>  6 & 0x3F);             bytes[i++] = 128 + (chr        & 0x3F);         }          else          {             bytes[i++] = 252 + (chr >>> 30);             bytes[i++] = 128 + (chr >>> 24 & 0x3F);             bytes[i++] = 128 + (chr >>> 18 & 0x3F);             bytes[i++] = 128 + (chr >>> 12 & 0x3F);             bytes[i++] = 128 + (chr >>>  6 & 0x3F);             bytes[i++] = 128 + (chr        & 0x3F);         }     }       return bytes; }


function position(e) {     return point(e.clientX, e.clientY); }    function c1500(v111, style) {     return window.getComputedStyle(v111).getPropertyValue(style); }    function a1501(e) {     return v1456 ? e.metaKey : e.ctrlKey;           }    function r1502(target, proto) {     target.dispatchEvent(new proto.constructor(proto.type, proto)); }    function l1503(className = '', id = '') {     const div = document.createElement('div');          if (className != '')         div.className = className;          if (id != '')         div.id = id;      return div; }    function l1504(div, to) {     if (!to.contains(div))         to.appendChild(div); }    function l1505(div, from) {     if (from.contains(div))         from.removeChild(div); }    function w1506(className = '') {     const textbox = document.createElement('INPUT');     textbox.setAttribute('type', 'text');       if (className.trim() != '')         textbox.className = className;          return textbox; }    function j1507(className = '') {     const textarea = document.createElement('textarea');      if (className.trim() != '')         textarea.className = className;          textarea.spellcheck = false;          return textarea; }    function createCanvas(className = '') {     const canvas = document.createElement('canvas');      if (className.trim() != '')         canvas.className = className;          return canvas; }    function u1508(elem, enable, bold = true) {     elem.style.fontStyle  = enable ? 'normal' : 'italic';       if (bold)         elem.style.fontWeight = enable ? 'normal' : 'bold'; }    function hasFocus(elem) {     return elem == document.activeElement; }    function q1509(id, properties) {     const elem = document.getElementById(id);      for (const property of properties)         elem.style[property] = properties[property]; }    function z1510(parent, child) {     return child.parentNode == parent; }    function k1511(event, element) {     const e = new event.constructor(event.type, event);     element.dispatchEvent(e); }    function offsetRect(element) {     return new s1047(         element.offsetLeft,         element.offsetTop,         element.offsetWidth,         element.offsetHeight); }    function clientRect(element) {     return new s1047(         element.clientLeft,         element.clientTop,         element.clientWidth,         element.clientHeight); }                  function h1512(elementId) {     if (document.selection)      {         var range = document.body.createTextRange();         range.moveToElementText(document.getElementById(elementId));         range.select();     }     else if (window.getSelection)      {         var range = document.createRange();         range.selectNode(document.getElementById(elementId));         window.getSelection().removeAllRanges();         window.getSelection().addRange(range);     } }    function w1513(e) {     return Math.abs(e.deltaX) < 100         && Math.abs(e.deltaY) < 100; }    function q1514(element, show = true)  {     const showStyle = 'block';     const hideStyle = 'none';      if (  !show         && element.style.display != hideStyle)         element.oldDisplay = element.style.display;      element.style.display =          show          ? (   element.style.oldDisplay             && element.style.oldDisplay != hideStyle            ? element.style.oldDsplay            : showStyle)         : hideStyle;  }   function c1515(element)               {      q1514(element, false);  }    function o4017(element) {     return element.offsetParent !== null; }    function k1516(element)  {      if (   element.tagName === 'TEXTAREA'          || (   element.tagName === 'INPUT'              && element.type === 'text'))      {         return element.value.substring(             element.selectionStart,             element.selectionEnd);     } }    function m1517(element) {     if (   element.tagName === 'TEXTAREA'          || (   element.tagName === 'INPUT'              && element.type === 'text'))      {         const str = element.value;          element.value =                str.slice(0, element.selectionStart)              + str.slice(element.selectionEnd)     } }    function scrollbarVisible(element)  {     return element.f3130 > element.clientHeight; }    function a1518(e) {     return point(e.clientX, e.clientY); }    function t1519(div) {     const selection = window.getSelection();      if (selection.rangeCount > 0)      {         const range = selection.getRangeAt(0);                  if (   range.commonAncestorContainer === div             || div.contains(range.commonAncestorContainer))         {             const selectedText = range.toString().trim();              if (selectedText.length > 0)                 return true;         }     }      return false;  }    function b1520(div) {     var range = document.createRange();     range.selectNode(div);      window.getSelection().removeAllRanges();     window.getSelection().addRange(range);     }    function h1521(callback) {     const input = document.createElement('input');      input.type   = 'file';     input.accept = '.gen';          input.onchange = e =>      {          const file = e.target.files[0];           const reader = new FileReader();         reader.readAsText(file,'UTF-8');          reader.onload = e => callback(e.target.result);     };       input.click(); }    function m1522(callback) {     const input = document.createElement('input');      input.type   = 'file';     input.accept = '*.*';          input.onchange = e =>      {          callback(e.target.files[0]);      };       input.click(); }    async function x1523(content, filename, contentType) {     const a    = document.createElement('a');     const file = new Blob([content], {type: contentType});      a.download = filename;     a.href     = URL.createObjectURL(file);      a.click();      await new Promise(resolve => setTimeout(resolve, 500));          URL.revokeObjectURL(a.href); }


const d1499 =  [     {name: 'AliceBlue',            color: 'f0f8ff'},     {name: 'AntiqueWhite',         color: 'faebd7'},     {name: 'Aqua',                 color: '00ffff'},     {name: 'Aquamarine',           color: '7fffd4'},     {name: 'Azure',                color: 'f0ffff'},     {name: 'Beige',                color: 'f5f5dc'},     {name: 'Bisque',               color: 'ffe4c4'},     {name: 'Black',                color: '000000'},     {name: 'BlanchedAlmond',       color: 'ffebcd'},     {name: 'Blue',                 color: '0000ff'},     {name: 'BlueViolet',           color: '8a2be2'},     {name: 'Brown',                color: 'a52a2a'},     {name: 'BurlyWood',            color: 'deb887'},     {name: 'CadetBlue',            color: '5f9ea0'},     {name: 'Chartreuse',           color: '7fff00'},     {name: 'Chocolate',            color: 'd2691e'},     {name: 'Coral',                color: 'ff7f50'},     {name: 'CornflowerBlue',       color: '6495ed'},     {name: 'Cornsilk',             color: 'fff8dc'},     {name: 'Crimson',              color: 'dc143c'},     {name: 'Cyan',                 color: '00ffff'},     {name: 'DarkBlue',             color: '00008b'},     {name: 'DarkCyan',             color: '008b8b'},     {name: 'DarkGoldenRod',        color: 'b8860b'},     {name: 'DarkGray',             color: 'a9a9a9'},     {name: 'DarkGrey',             color: 'a9a9a9'},     {name: 'DarkGreen',            color: '006400'},     {name: 'DarkKhaki',            color: 'bdb76b'},     {name: 'DarkMagenta',          color: '8b008b'},     {name: 'DarkOliveGreen',       color: '556b2f'},     {name: 'DarkOrange',           color: 'ff8c00'},     {name: 'DarkOrchid',           color: '9932cc'},     {name: 'DarkRed',              color: '8b0000'},     {name: 'DarkSalmon',           color: 'e9967a'},     {name: 'DarkSeaGreen',         color: '8fbc8f'},     {name: 'DarkSlateBlue',        color: '483d8b'},     {name: 'DarkSlateGray',        color: '2f4f4f'},     {name: 'DarkSlateGrey',        color: '2f4f4f'},     {name: 'DarkTurquoise',        color: '00ced1'},     {name: 'DarkViolet',           color: '9400d3'},     {name: 'DeepPink',             color: 'ff1493'},     {name: 'DeepSkyBlue',          color: '00bfff'},     {name: 'DimGray',              color: '696969'},     {name: 'DimGrey',              color: '696969'},     {name: 'DodgerBlue',           color: '1e90ff'},     {name: 'FireBrick',            color: 'b22222'},     {name: 'FloralWhite',          color: 'fffaf0'},     {name: 'ForestGreen',          color: '228b22'},     {name: 'Fuchsia',              color: 'ff00ff'},     {name: 'Gainsboro',            color: 'dcdcdc'},     {name: 'GhostWhite',           color: 'f8f8ff'},     {name: 'Gold',                 color: 'ffd700'},     {name: 'GoldenRod',            color: 'daa520'},     {name: 'Gray',                 color: '808080'},     {name: 'Grey',                 color: '808080'},     {name: 'Green',                color: '008000'},     {name: 'GreenYellow',          color: 'adff2f'},     {name: 'HoneyDew',             color: 'f0fff0'},     {name: 'HotPink',              color: 'ff69b4'},     {name: 'IndianRed',            color: 'cd5c5c'},     {name: 'Indigo',               color: '4b0082'},     {name: 'Ivory',                color: 'fffff0'},     {name: 'Khaki',                color: 'f0e68c'},     {name: 'Lavender',             color: 'e6e6fa'},     {name: 'LavenderBlush',        color: 'fff0f5'},     {name: 'LawnGreen',            color: '7cfc00'},     {name: 'LemonChiffon',         color: 'fffacd'},     {name: 'LightBlue',            color: 'add8e6'},     {name: 'LightCoral',           color: 'f08080'},     {name: 'LightCyan',            color: 'e0ffff'},     {name: 'LightGoldenRodYellow', color: 'fafad2'},     {name: 'LightGray',            color: 'd3d3d3'},     {name: 'LightGrey',            color: 'd3d3d3'},     {name: 'LightGreen',           color: '90ee90'},     {name: 'LightPink',            color: 'ffb6c1'},     {name: 'LightSalmon',          color: 'ffa07a'},     {name: 'LightSeaGreen',        color: '20b2aa'},     {name: 'LightSkyBlue',         color: '87cefa'},     {name: 'LightSlateGray',       color: '778899'},     {name: 'LightSlateGrey',       color: '778899'},     {name: 'LightSteelBlue',       color: 'b0c4de'},     {name: 'LightYellow',          color: 'ffffe0'},     {name: 'Lime',                 color: '00ff00'},     {name: 'LimeGreen',            color: '32cd32'},     {name: 'Linen',                color: 'faf0e6'},     {name: 'Magenta',              color: 'ff00ff'},     {name: 'Maroon',               color: '800000'},     {name: 'MediumAquaMarine',     color: '66cdaa'},     {name: 'MediumBlue',           color: '0000cd'},     {name: 'MediumOrchid',         color: 'ba55d3'},     {name: 'MediumPurple',         color: '9370db'},     {name: 'MediumSeaGreen',       color: '3cb371'},     {name: 'MediumSlateBlue',      color: '7b68ee'},     {name: 'MediumSpringGreen',    color: '00fa9a'},     {name: 'MediumTurquoise',      color: '48d1cc'},     {name: 'MediumVioletRed',      color: 'c71585'},     {name: 'MidnightBlue',         color: '191970'},     {name: 'MintCream',            color: 'f5fffa'},     {name: 'MistyRose',            color: 'ffe4e1'},     {name: 'Moccasin',             color: 'ffe4b5'},     {name: 'NavajoWhite',          color: 'ffdead'},     {name: 'Navy',                 color: '000080'},     {name: 'OldLace',              color: 'fdf5e6'},     {name: 'Olive',                color: '808000'},     {name: 'OliveDrab',            color: '6b8e23'},     {name: 'Orange',               color: 'ffa500'},     {name: 'OrangeRed',            color: 'ff4500'},     {name: 'Orchid',               color: 'da70d6'},     {name: 'PaleGoldenRod',        color: 'eee8aa'},     {name: 'PaleGreen',            color: '98fb98'},     {name: 'PaleTurquoise',        color: 'afeeee'},     {name: 'PaleVioletRed',        color: 'db7093'},     {name: 'PapayaWhip',           color: 'ffefd5'},     {name: 'PeachPuff',            color: 'ffdab9'},     {name: 'Peru',                 color: 'cd853f'},     {name: 'Pink',                 color: 'ffc0cb'},     {name: 'Plum',                 color: 'dda0dd'},     {name: 'PowderBlue',           color: 'b0e0e6'},     {name: 'Purple',               color: '800080'},     {name: 'RebeccaPurple',        color: '663399'},     {name: 'Red',                  color: 'ff0000'},     {name: 'RosyBrown',            color: 'bc8f8f'},     {name: 'RoyalBlue',            color: '4169e1'},     {name: 'SaddleBrown',          color: '8b4513'},     {name: 'Salmon',               color: 'fa8072'},     {name: 'SandyBrown',           color: 'f4a460'},     {name: 'SeaGreen',             color: '2e8b57'},     {name: 'SeaShell',             color: 'fff5ee'},     {name: 'Sienna',               color: 'a0522d'},     {name: 'Silver',               color: 'c0c0c0'},     {name: 'SkyBlue',              color: '87ceeb'},     {name: 'SlateBlue',            color: '6a5acd'},     {name: 'SlateGray',            color: '708090'},     {name: 'SlateGrey',            color: '708090'},     {name: 'Snow',                 color: 'fffafa'},     {name: 'SpringGreen',          color: '00ff7f'},     {name: 'SteelBlue',            color: '4682b4'},     {name: 'Tan',                  color: 'd2b48c'},     {name: 'Teal',                 color: '008080'},     {name: 'Thistle',              color: 'd8bfd8'},     {name: 'Tomato',               color: 'ff6347'},     {name: 'Turquoise',            color: '40e0d0'},     {name: 'Violet',               color: 'ee82ee'},     {name: 'Wheat',                color: 'f5deb3'},     {name: 'White',                color: 'ffffff'},     {name: 'WhiteSmoke',           color: 'f5f5f5'},     {name: 'Yellow',               color: 'ffff00'},     {name: 'YellowGreen',          color: '9acd32'} ];    const genColorNameLightness = [     {name: 'pale',   value: 0.87},     {name: 'light',  value: 0.76},     {name: 'bright', value: 0.65},     {name: 'deep',   value: 0.35},     {name: 'dim',    value: 0.22},     {name: 'dark',   value: 0.12} ];    const genColorNameSaturation = [     {name: 'calm',  value: 0.72},     {name: 'dull',  value: 0.46},     {name: 'dirty', value: 0.21} ];    const genColorNameHue = [     {name: 'violet',  value: 285},     {name: 'purple',  value: 269},     {name: 'indigo',  value: 252},     {name: 'blue',    value: 241},     {name: 'cobalt',  value: 222},     {name: 'sky',     value: 211},     {name: 'aqua',    value: 193},     {name: 'cyan',    value: 177},     {name: 'jade',    value: 154},     {name: 'green',   value: 112},     {name: 'lime',    value:  74},     {name: 'yellow',  value:  54},     {name: 'mango',   value:  42},     {name: 'orange',  value:  30},     {name: 'amber',   value:  17},     {name: 'salmon',  value:  11},     {name: 'red',     value:   0},     {name: 'rose',    value: 335},     {name: 'magenta', value: 310} ];    function parseColorNameLightness(name)  {     for (const item of genColorNameLightness)      {         if (   name.startsWith(item.name)              ||     m1491(name.slice(0, item.name.length), item.name) <= 1                && !genColorNameHue.find(h => h.name.startsWith(name)))          {             return { value:     item.value,                       remaining: name.slice(item.name.length) };         }     }      return { value:     null,               remaining: name }; }    function parseColorNameSaturation(name)  {     for (const item of genColorNameSaturation)      {         if (   name.startsWith(item.name)              ||     m1491(name.slice(0, item.name.length), item.name) <= 1                && !genColorNameHue.find(h => h.name.startsWith(name)))          {             return { value:     item.value,                       remaining: name.slice(item.name.length) };         }     }      return { value:     null,               remaining: name }; }    function parseColorNameHue(name)  {     for (const item of genColorNameHue)      {         if (   name === item.name              || m1491(name.slice(0, item.name.length), item.name) <= 1)          {             return item.value;         }     }      return null; }    function parseColorName(_colorName)  {     let colorName = _colorName.replace(/\s+/g, '');       if (   colorName === 'black'          || m1491(colorName, 'black') <= 1)         return [0, 0, 0];      if (   colorName === 'white'          || m1491(colorName, 'white') <= 1)         return [0, 0, 1];               const grayVariants = ['gray', 'grey'];      let isGray = false;     let gl     = 0.5;      for (const grayVariant of grayVariants)      {         if (   colorName.endsWith(grayVariant)              || m1491(colorName.slice(-grayVariant.length), grayVariant) <= 1)          {             isGray = true;                      const grayPrefix = colorName.slice(0, -grayVariant.length);                          if (grayPrefix)              {                 const { value } = parseColorNameLightness(grayPrefix);                                  if (value !== null)                      gl = value;             }              break;         }     }       if (isGray)         return [0, 0, gl];       let h = null;     let s = null;     let l = null;                     let result  = parseColorNameLightness(colorName);         l       = result.value;     let remName = result.remaining;          result  = parseColorNameSaturation(remName);         s       = result.value;         remName = result.remaining;          h       = parseColorNameHue(remName);                      if (   h === null          || s === null          || l === null)      {         h = null;         s = null;         l = null;          result  = parseColorNameSaturation(colorName);         s       = result.value;         remName = result.remaining;          result  = parseColorNameLightness(remName);         l       = result.value;         remName = result.remaining;          h       = parseColorNameHue(remName);     }       if (h === null) return null;      if (l === null) l = 0.5;     if (s === null) s = 1.0;           return [h / 360, s, l]; }    function createColorName(rgb) {     if (rgb.length > 3 && rgba[3] == 0)         return 'transparent';       const hsl = n48(rgb);      let   h = hsl[0] * 360;      while (h >= 360) h -= 360;     while (h <    0) h += 360;          const s = hsl[1];     const l = hsl[2];            if (l >= 0.94) return 'white';     else if (l <  0.06) return 'black';       let strH = '';     let strS = '';     let strL = '';            if (l >= 0.81 && l < 0.94) strL = 'pale ';     else if (l >= 0.69 && l < 0.81) strL = 'light ';     else if (l >= 0.56 && l < 0.69) strL = 'bright ';     else if (l >= 0.31 && l < 0.44) strL = 'deep ';     else if (l >= 0.19 && l < 0.31) strL = 'dim ';     else if (l >= 0.06 && l < 0.19) strL = 'dark ';           if (l > 0.25 && l < 0.75)      {              if (s >= 0.62 && s < 0.88) strS = 'calm ';         else if (s >= 0.31 && s < 0.62) strS = 'dull ';         else if (s >= 0.12 && s < 0.31) strS = 'dirty ';     }       if (s >= 0.12)     {              if (h < 293 && h >= 278) strH = 'violet';         else if (h < 278 && h >= 259) strH = 'purple';         else if (h < 259 && h >= 248) strH = 'indigo';         else if (h < 248 && h >= 233) strH = 'blue';         else if (h < 233 && h >= 221) strH = 'cobalt';         else if (h < 221 && h >= 201) strH = 'sky';         else if (h < 201 && h >= 185) strH = 'aqua';         else if (h < 185 && h >= 169) strH = 'cyan';         else if (h < 169 && h >= 139) strH = 'jade';         else if (h < 139 && h >=  86) strH = 'green';         else if (h <  86 && h >=  63) strH = 'lime';         else if (h <  63 && h >=  45) strH = 'yellow';         else if (h <  45 && h >=  40) strH = 'mango';         else if (h <  40 && h >=  21) strH = 'orange';         else if (h <  21 && h >=  13) strH = 'amber';         else if (h <  13 && h >=   8) strH = 'salmon';         else if (h <   8 || h >= 352) strH = 'red';         else if (h < 352 && h >= 328) strH = 'rose';         else if (h < 328 && h >= 293) strH = 'magenta';         else              console.error('error parsing hue name');     }     else          strH = 'gray';       return strL + strS + strH; } 


var _clipboard = '';    function d867(str)  {     if (subscribed())     {         if (   navigator.clipboard              && window.isSecureContext)              return navigator.clipboard.writeText(str);          else          {             const prevActive = document.activeElement;             const textArea   = document.createElement('textarea');              textArea.value = str;              textArea.style.position = 'fixed';             textArea.style.left     = '-999999px';             textArea.style.top      = '-999999px';                          document.body.appendChild(textArea);                          textArea.focus();             textArea.select();                          return new Promise((res, rej) =>              {                 document.execCommand('copy') ? res() : rej();                 textArea.remove();                  prevActive.focus();             });         }     }     else         _clipboard = str; }    function r868()  {     if (subscribed())     {         if (   navigator.clipboard              && window.isSecureContext)              return navigator.clipboard.readText();          else          {             let textArea = document.createElement('textarea');              textArea.style.position = 'fixed';             textArea.style.left     = '-999999px';             textArea.style.top      = '-999999px';                          document.body.appendChild(textArea);                          textArea.focus({preventScroll: true});             textArea.select();                          return new Promise((res, rej) =>              {                 document.execCommand('paste') ? res(textArea.value) : rej();                 textArea.remove();             });         }     }     else         return new Promise((res, rej) => res(_clipboard)); }


function c1048(key, tag)  {     return key.substring(0, tag.length+1) == tag + ' '; }    function x1049(key, tag) {     return key.substring(tag.length+1); }    function l1050(key) { return c1048(key, c877); } function v1051(key) { return c1048(key, z875); } function m1052(key) { return c1048(key, t876); }    function m1053(key) { return x1049(key, c877); } function z1054(key) { return x1049(key, z875); } function e1055(key) { return x1049(key, t876); }


const p963               = '\uFFFD'; const z964            = '?';      const l965           = '?'; const d966        = l965;  const NAME_SEPARATOR         = ' '; const l967       = ' > '; const   v968       = ' / '; const  b969       = ':';  const a970          = ' •'; const  b971          = ' ◇';       const  h972    = '<svg width="13" height="11" viewBox="0 1 13 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.3645 1.82058L10.2676 0.599976L5.1191 8.58091L2.44314 6.06144L0.800003 7.67327L5.54161 12.1958L12.3645 1.82058Z" fill="#2AD400"/></svg>';
const k973    = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="#F43D3D"/></svg>';    
 const  b974     = '<svg width="12" height="11" viewBox="0 0 12 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M11.1 0.998457L9.41674 0L4.20109 8.01592L1.50123 5.4381L0.1 6.77599L4.52397 11L11.1 0.998457Z" fill="#3FF911"/></svg>';
const v975     = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="#FF3E3E"/></svg>';
 const  l976 = '<svg width="11" height="11" viewBox="0 0 11 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.7157 0.893364L9.55198 0.139526L4.15187 8.47598L1.20316 5.59262L0.248535 6.5928L4.41886 10.5815L5.04702 9.60025L10.7157 0.893364Z" fill="black"/></svg>';
const u977 = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.13479 0.1521L0.1521 1.13479L3.51727 4.49997L0.152106 7.86514L1.1348 8.84783L4.49997 5.48266L7.86511 8.8478L8.8478 7.86511L5.48266 4.49997L8.84781 1.13482L7.86511 0.152129L4.49997 3.51727L1.13479 0.1521Z" fill="black"/></svg>';
 const  b978  = '<svg width="12" height="11" viewBox="0 0 12 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M11.1 0.998457L9.41672 0L4.20107 8.01592L1.50121 5.4381L0.0999756 6.77599L4.52395 11L11.1 0.998457Z" fill="white"/></svg>';
const h979  = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="white"/></svg>';
 const  c980     = '<svg width="12" height="11" viewBox="0 0 12 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M11.1 0.998457L9.41675 0L4.2011 8.01592L1.50124 5.4381L0.100006 6.77599L4.52398 11L11.1 0.998457Z" fill="white"/></svg>';
const f981     = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="white"/></svg>';
   function v982(color = true) {     return p4007          ? (color ? b974  : b978 )          : (color ? h972 : l976); }    function j983(color = true) {     return p4007          ? (color ? v975  : h979 )          : (color ? k973 : u977); }


var showDebugInfo = false;  var debugFlag1    = false;    function w961(nodeIds) {     let str = '';      for (let i = 0; i < nodeIds.length; i++)     {         if (i > 0) str += ', ';         str += nodeIds[i];     }      return str; }    function w962(nodes) {     let str = '';      nodes.map(n => n ? n.id : 'undefined').join(', ');                                return str; }    function updateDebugInfo() {     if (showDebugInfo)     {         debugInfoText.style.display = 'inline-block';          debugInfoText.innerHTML =                         'pan = '  + graph.currentPage.pan.x.toFixed(2) + ', ' + graph.currentPage.pan.y.toFixed(2)             + '<br/>' + 'zoom = ' + graph.currentPage.zoom.toFixed(4);     }     else         debugInfoText.style.display = 'none'; }


const w1040   = 0,       x1041 = 1,       v1042 = 2,       l1043  = 3;    class z1044 {     initial;     current;            constructor()     {         this.reset();     }            set(seed)     {         this.initial = seed;         this.current = seed;     }                rotate()     {         this.current = (this.current + 0x7ed55d16) + (this.current << 12);         this.current = (this.current ^ 0xc761c23c) ^ (this.current >> 19);         this.current = (this.current + 0x165667b1) + (this.current <<  5);         this.current = (this.current + 0xd3a2646c) ^ (this.current <<  9);         this.current = (this.current + 0xfd7046c5) + (this.current <<  3);         this.current = (this.current ^ 0xb55a4f09) ^ (this.current >> 16);     }                next()     {         const seed = this.current;         this.rotate();         return seed;     }        reset()     {         this.current = this.initial;     } };    class Noise { 	interpolation = l1043; 	clip = false;  	seed = new z1044();  	v0; 	v1; 	v2; 	v3;  	step = 0;       constructor(seed = 0)     {         this.seed.set(seed);         this.reset();     }       next(scale = 1)     {                  scale = Math.max(1, scale);          let next = this.v1;          if (this.step >= 1)         {                                   this.seed.rotate();              this.v0 = this.v1;                      this.v1 = this.v2;             this.v2 = this.v3;                      this.v3 = t1045(this.seed.current);              this.step -= 1;         }                    switch (this.interpolation)         {             case w1040:             {                 next = this.v1;                 break;             }             case x1041:             {                 next = this.v1 + this.step * (this.v2 - this.v1);                 break;             }             case v1042:             {                 const ft = this.step * Math.PI;                 const f  = (1 - Math.cos(ft)) * 0.5;                                  next = this.v1 + f * (this.v2 - this.v1);                 break;             }             case l1043:             {                 const p = (this.v3 - this.v2) - (this.v0 - this.v1);                 const q = (this.v0 - this.v1) - p;                 const r =  this.v2 - this.v0;                 const s =  this.v1;                  const val =                        p * cube(this.step)                      + q * sqr(this.step)                      + r * this.step                      + s;                  next = this.clip                      ? Math.max(0, Math.min(val, 1))                      : val;                  break;             }         }          this.step += 1 / scale;          return next;     }          reset()     {         this.seed.reset();          this.v0 = t1045(this.seed.current); this.seed.rotate();         this.v1 = t1045(this.seed.current); this.seed.rotate();         this.v2 = t1045(this.seed.current); this.seed.rotate();         this.v3 = t1045(this.seed.current); this.seed.rotate();          this.step = 0;     } }   function t1045(x) {     return x / -0x7fffffff; }


const settings = {     debugMode:                     false,              e2552:         false,     w2553:              0.35,     objectCenterSize:              18,     m4021:               500,     showPages:                     false,     showAllColorSpaces:            false,     showNodeIcons:                 true,     showBoolValues:                true,     separateThousands:             true,     invertSimpleMathParamOrder:    true,     activateDeactiatesOthers:      true,     preferHtmlColorNames:          false,     randomShiftR:                  true,     colorShiftR:                   true,      showSnapshots:                 false,     showRestartInfo:               true,     showColorLegendInMenus:        false,     showClearUndoWarning:          true,     shareUsageMetrics:             true,     showObjectCount:               true,     showDebugMenu:                 false,              showNodeId:                    false,      n2554:           false,     enableAsserts:                 false,      showTooltipLongText:           false,     showTooltipLists:              false,     showTooltipColorInterpolation: true,     showTooltipColorBlindness:     true,     showTooltipColorContrast:      true,     showTooltipColorNames:         true,     showTooltipAscii:              true,      enableBetaFeatures:            false,                  logThreadMessages:             false,     logDataMessages:               false,     logMessages:                   false,      logActions:                    false,                   logLoading:                    false,      logRequests:                   false,      logValueUpdates:               false,      logObjectUpdates:              false,     logStyleUpdates:               false,                  logRawLoadPages:               false,      logRawLoadNodes:               false,      logRawLoadConnections:         false,               logRawSavePages:               false,      logRawSaveNodes:               false,      logRawSaveConnections:         false,               logRawRequests:                false,      logRawValues:                  false,      sessionId:                     '' };    function r3593(r3661, value) {     switch (r3661)     {         case 'debugMode':                     settings.debugMode                     = value;  break;                          case 'enableZoomedOutParams':         settings.e2552         = value;  break;         case 'minZoomForParams':              settings.w2553              = value;  break;         case 'objectCenterSize':              settings.objectCenterSize              = value;  break;         case 'objectBatchSize':               settings.m4021               = value;  break;         case 'showPages':                     settings.showPages                     = value;  break;         case 'showAllColorSpaces':            settings.showAllColorSpaces            = value;  break;         case 'showNodeIcons':                 settings.showNodeIcons                 = value;  break;         case 'showBoolValues':                settings.showBoolValues                = value;  break;         case 'separateThousands':             settings.separateThousands             = value;  break;         case 'invertSimpleMathParamOrder':    settings.invertSimpleMathParamOrder    = value;  break;         case 'activateDeactiatesOthers':      settings.activateDeactiatesOthers      = value;  break;         case 'preferHtmlColorNames':          settings.preferHtmlColorNames          = value;  break;         case 'randomShiftR':                  settings.randomShiftR                  = value;  break;         case 'colorShiftR':                   settings.colorShiftR                   = value;  break;                  case 'showSnapshots':                 settings.showSnapshots                 = value;  break;         case 'showRestartInfo':               settings.showRestartInfo               = value;  break;         case 'showColorLegendInMenus':        settings.showColorLegendInMenus        = value;  break;         case 'showClearUndoWarning':          settings.showClearUndoWarning          = value;  break;         case 'shareUsageMetrics':             settings.shareUsageMetrics             = value;  break;         case 'showObjectCount':               settings.showObjectCount               = value;  break;         case 'showDebugMenu':                 settings.showDebugMenu                 = value;  break;                                  case 'showNodeId':                    settings.showNodeId                    = value;  break;         case 'showTransformPoints':           settings.n2554           = value;  break;         case 'enableAsserts':                 settings.enableAsserts                 = value;  break;          case 'showTooltipLists':              settings.showTooltipLists              = value;  break;         case 'showTooltipLongText':           settings.showTooltipLongText           = value;  break;         case 'showTooltipColorInterpolation': settings.showTooltipColorInterpolation = value;  break;         case 'showTooltipColorBlindness':     settings.showTooltipColorBlindness     = value;  break;         case 'showTooltipColorContrast':      settings.showTooltipColorContrast      = value;  break;         case 'showTooltipColorNames':         settings.showTooltipColorNames         = value;  break;         case 'showTooltipAscii':              settings.showTooltipAscii              = value;  break;          case 'enableBetaFeatures':            settings.enableBetaFeatures            = value;  break;                             case 'logThreadMessages':             settings.logThreadMessages             = value;  break;         case 'logDataMessages':               settings.logDataMessages               = value;  break;         case 'logMessages':                   settings.logMessages                   = value;  break;          case 'logActions':                    settings.logActions                    = value;  break;         case 'logLoading':                    settings.logLoading                    = value;  break;         case 'logRequests':                   settings.logRequests                   = value;  break;         case 'logValueUpdates':               settings.logValueUpdates               = value;  break;         case 'logObjectUpdates':              settings.logObjectUpdates              = value;  break;         case 'logStyleUpdates':               settings.logStyleUpdates               = value;  break;                             case 'logRawLoadPages':               settings.logRawLoadPages               = value;  break;         case 'logRawLoadNodes':               settings.logRawLoadNodes               = value;  break;         case 'logRawLoadConnections':         settings.logRawLoadConnections         = value;  break;                          case 'logRawSavePages':               settings.logRawSavePages               = value;  break;         case 'logRawSaveNodes':               settings.logRawSaveNodes               = value;  break;         case 'logRawSaveConnections':         settings.logRawSaveConnections         = value;  break;                          case 'logRawRequests':                settings.logRawRequests                = value;  break;         case 'logRawValues':                  settings.logRawValues                  = value;  break;          case 'sessionId':                     settings.sessionId                     = value;  break;     }        switch (r3661)     {         case 'objectCenterSize':             b2497(             {                 cmd:             'figUpdateObjectCenterSize',                 objectCenterSize: settings.objectCenterSize             });             break;     } }    function t3517(r3661, valid, value, save = true) {     switch (r3661)     {         case 'debugMode':                     c3660(valid, r3661, value, d722                    ); break;                        case 'enableZoomedOutParams':         c3660(valid, r3661, value, i648        ); break;         case 'showPages':                     c3660(valid, r3661, value, r652                    ); break;         case 'showAllColorSpaces':            c3660(valid, r3661, value, x654           ); break;         case 'showNodeIcons':                 c3660(valid, r3661, value, c655                ); break;         case 'showBoolValues':                c3660(valid, r3661, value, i657               ); break;         case 'separateThousands':             c3660(valid, r3661, value, s658            ); break;         case 'invertSimpleMathParamOrder':    c3660(valid, r3661, value, b659   ); break;         case 'activateDeactiatesOthers':      c3660(valid, r3661, value, menuItemActivateDeactiatesOthers     ); break;         case 'preferHtmlColorNames':          c3660(valid, r3661, value, menuItemPreferHtmlColorNames         ); break;         case 'randomShiftR':                  c3660(valid, r3661, value, menuItemRandomShiftR                 ); break;         case 'colorShiftR':                   c3660(valid, r3661, value, menuItemColorShiftR                  ); break;          case 'showSnapshots':                 c3660(valid, r3661, value, menuItemShowSnapshots                ); break;         case 'showRestartInfo':               c3660(valid, r3661, value, menuItemShowRestartInfo              ); break;         case 'showColorLegendInMenus':        c3660(valid, r3661, value, e656       ); break;         case 'showClearUndoWarning':          c3660(valid, r3661, value, o660         ); break;         case 'shareUsageMetrics':             c3660(valid, r3661, value, b661            ); break;         case 'showObjectCount':               c3660(valid, r3661, value, g663              ); break;         case 'showDebugMenu':                 c3660(valid, r3661, value, m664                ); break;                                case 'showNodeId':                    c3660(valid, r3661, value, l667                   ); break;         case 'showTransformPoints':           c3660(valid, r3661, value, w668          ); break;         case 'enableAsserts':                 c3660(valid, r3661, value, i669                ); enableAsserts = value; break;                  case 'showTooltipLists':              c3660(valid, r3661, value, l643             ); break;         case 'showTooltipLongText':           c3660(valid, r3661, value, q642          ); break;         case 'showTooltipColorInterpolation': c3660(valid, r3661, value, m644); break;         case 'showTooltipColorBlindness':     c3660(valid, r3661, value, a647    ); break;         case 'showTooltipColorContrast':      c3660(valid, r3661, value, w645     ); break;         case 'showTooltipColorNames':         c3660(valid, r3661, value, j646        ); break;         case 'showTooltipAscii':              c3660(valid, r3661, value, a647    ); break;          case 'enableBetaFeatures':            c3660(valid, r3661, value, menuItemEnableBetaFeatures           ); break;                                case 'logThreadMessages':             c3660(valid, r3661, value, j723            ); break;         case 'logDataMessages':               c3660(valid, r3661, value, g724              ); break;         case 'logMessages':                   c3660(valid, r3661, value, k725                  ); break;          case 'logActions':                    c3660(valid, r3661, value, h726                   ); break;         case 'logLoading':                    c3660(valid, r3661, value, d727                   ); break;         case 'logRequests':                   c3660(valid, r3661, value, l728                  ); break;         case 'logValueUpdates':               c3660(valid, r3661, value, u729              ); break;         case 'logObjectUpdates':              c3660(valid, r3661, value, h730             ); break;         case 'logStyleUpdates':               c3660(valid, r3661, value, m731              ); break;                                case 'logRawLoadPages':               c3660(valid, r3661, value, a732              ); break;         case 'logRawLoadNodes':               c3660(valid, r3661, value, l733              ); break;         case 'logRawLoadConnections':         c3660(valid, r3661, value, w734        ); break;                                case 'logRawSavePages':               c3660(valid, r3661, value, v735              ); break;         case 'logRawSaveNodes':               c3660(valid, r3661, value, n736              ); break;         case 'logRawSaveConnections':         c3660(valid, r3661, value, v737        ); break;                                case 'logRawRequests':                c3660(valid, r3661, value, t738               ); break;         case 'logRawValues':                  c3660(valid, r3661, value, q739                 ); break;     }        if (   save         && r3661 != 'showAllColorSpaces')         s2556(r3661, l937(value)); }    function c3660(valid, setting, value, menu) {     if (valid)          settings[setting] = value;         switch (setting)     {         case 'showNodeId':             b2497(             {                 cmd:    'figUpdateShowIds',                 r2800: settings.showNodeId             });             break;     }       if (menu)         menu.l2871(settings[setting]); }    function updateSettingsMenus() {     d722                    .u326(settings.debugMode                    );                      i648        .l2871(settings.e2552        );     r652                    .l2871(settings.showPages                    );     x654           .l2871(settings.showAllColorSpaces           );     c655                .l2871(settings.showNodeIcons                );     i657               .l2871(settings.showBoolValues               );     s658            .l2871(settings.separateThousands            );     b659   .l2871(settings.invertSimpleMathParamOrder   );     menuItemActivateDeactiatesOthers     .l2871(settings.activateDeactiatesOthers     );     menuItemPreferHtmlColorNames         .l2871(settings.preferHtmlColorNames         );     menuItemRandomShiftR                 .l2871(settings.randomShiftR                 );     menuItemColorShiftR                  .l2871(settings. colorShiftR                 );      menuItemShowSnapshots                .l2871(settings.showSnapshots                );     menuItemShowRestartInfo              .l2871(settings.showRestartInfo              );     e656       .l2871(settings.showColorLegendInMenus       );     o660         .l2871(settings.showClearUndoWarning         );     b661            .l2871(settings.shareUsageMetrics            );     g663              .l2871(settings.showObjectCount              );     m664                .l2871(settings.showDebugMenu                );                      l667                   .l2871(settings.showNodeId                   );     w668          .l2871(settings.n2554          );     i669                .l2871(settings.enableAsserts                );      l643             .l2871(settings.showTooltipLists             );     q642          .l2871(settings.showTooltipLongText          );     m644.l2871(settings.showTooltipColorInterpolation);     a647    .l2871(settings.showTooltipColorBlindness    );     w645     .l2871(settings.showTooltipColorContrast     );     j646        .l2871(settings.showTooltipColorNames        );     menuItemShowTooltipAscii             .l2871(settings.showTooltipAscii             );                            j723            .l2871(settings.logThreadMessages            );     g724              .l2871(settings.logDataMessages              );     k725                  .l2871(settings.logMessages                  );      h726                   .l2871(settings.logActions                   );                        d727                   .l2871(settings.logLoading                   );     l728                  .l2871(settings.logRequests                  );     u729              .l2871(settings.logValueUpdates              );     h730             .l2871(settings.logObjectUpdates             );     m731              .l2871(settings.logStyleUpdates              );                        l733              .l2871(settings.logRawLoadPages              );     l733              .l2871(settings.logRawLoadNodes              );     w734        .l2871(settings.logRawLoadConnections        );                          v735              .l2871(settings.logRawSaveNodes              );     n736              .l2871(settings.logRawSaveNodes              );     v737        .l2871(settings.logRawSaveConnections        );                      t738               .l2871(settings.logRawRequests               );     q739                 .l2871(settings.logRawValues                 ); }    function updateMenuItemShowPages() {     m2560('showPages', l937(settings.showPages));     graph.y2088();     z186.update(); }    function updateMenuItemShowSnapshots() {     m2560('showSnapshots', l937(settings.showSnapshots));      snapshotBar.style.display = settings.showSnapshots ? 'block' : 'none';      }    function updateMenuItemShowAllColorSpaces() {     m2560('showAllColorSpaces', l937(settings.showAllColorSpaces));      graph.nodes         .filter(n => a1177.includes(n.type))         .forEach(n => n.l3031()); }    function updateMenuItemShowNodeIcons() {     graph.nodes.forEach(n => n.l3031()); }    function updateMenuItemShowBoolValues() {     graph.nodes         .filter(n => n.params.find(p => p.type == c1091) != null)         .forEach(n => n.l3031()); }    function updateMenuItemSeparateThousands() {     graph.nodes         .filter(n => n.params.find(p => p.type == c1091) != null)         .forEach(n => n.l3031()); }    function updateMenuItemInvertSimpleMathParamOrder() {     graph.nodes         .filter(n => n.type == o1113)         .forEach(n => n.l3031()); }    function updateMenuItemShowColorLegendInMenus() {     for (const menu of w575)         menu.items.forEach(i => i.l3454()); }    function enableFeatures(sub) {     enableMenuItem(menuItemUpgrade,            true, sub, false, !sub);     enableMenuItem(menuItemSetValueNames,      true, sub);     enableMenuItem(menuItemEnableBetaFeatures, true, sub);     enableMenuItem(menuItemCopyLLMPrompt,      true, sub, true, currentUserIsDev());       enableMenuItem(menuItemShowRestartInfo,    true, sub);     enableMenuItem(menuItemValueName,          true, sub);     enableMenuItem(menuItemObjectName,         true, sub);     enableMenuItem(n689,           true, sub, true);     enableMenuItem(x692,              true, sub);     enableMenuItem(f694,            true, sub, true);     enableMenuItem(e671,         true, sub);     enableMenuItem(menuItemSaveSelected,       true, sub);     enableMenuItem(d695,              true, sub);     enableMenuItem(x701,           true, sub);     enableMenuItem(a703,              true, sub);     enableMenuItem(t3475,           true, sub);     enableMenuItem(z705,       true, sub);     enableMenuItem(x706,        true, sub);     enableMenuItem(j720,        true, sub);     enableMenuItem(menuItemVectorSep1,         true, sub, true);     enableMenuItem(menuItemVectorVertex,       true, sub, true);     enableMenuItem(menuItemVectorEdge,         true, sub, true);     enableMenuItem(menuItemVectorRegion,       true, sub, true);     enableMenuItem(menuItemVectorNetwork,      true, sub, true);     enableMenuItem(menuItemBooleanShape,       true, sub, true);     enableMenuItem(menuItemSaveTemplate,       true, sub);     enableMenuItem(i721,    true, sub);       updatePanelButton();       graph.nodes.forEach(n => n.t3495(sub)); }    function updatePanelButton() {     if (d567     ) d567     .div.style.display = !(settings.enableBetaFeatures && subscribed()) ? 'inline-block' : 'none';     if (btnDecoration) btnDecoration.div.style.display =  (settings.enableBetaFeatures && subscribed()) ? 'inline-block' : 'none'; }    function enableMenuItem(menuItem, enable, sub, beta = false, show = true) {     if (!menuItem) return;      menuItem.enabled = enable;     menuItem.sub     = sub;      menuItem.u326(            show          && (               !beta             || beta && sub && settings.enableBetaFeatures));      menuItem.update(); }    function updateMenuItemShowDebugMenu() {     updateElementDisplay(k672.div, settings.showDebugMenu);      z576.update(         m995(z576.div).x + 6,         m995(z576.div).y - 4,         true); }     function updateElementDisplay(menuItem, enable) {     menuItem.style.display = enable ? 'block' : 'none'; }    function loadLocalSettings() {     e2555('debugMode'                    );              e2555('enableZoomedOutParams'        );     e2555('minZoomForParams'             );     e2555('objectCenterSize'             );     e2555('objectBatchSize'              );     e2555('showNodeIcons'                );     e2555('showBoolValues'               );     e2555('separateThousands'            );     e2555('invertSimpleMathParamOrder'   );     e2555('activateDeactiatesOthers'     );     e2555('preferHtmlColorNames'         );     e2555('randomShiftR'                 );     e2555('colorShiftR'                  );      e2555('showSnapshots'                );     e2555('showRestartInfo'              );     e2555('showColorLegendInMenus'       );     e2555('showPages'                    );     e2555('showClearUndoWarning'         );     e2555('shareUsageMetrics'            );     e2555('showObjectCount'              );     e2555('showDebugMenu'                );              e2555('showNodeId'                   );     e2555('showTransformPoints'          );     e2555('enableAsserts'                );      e2555('showTooltipLists'             );     e2555('showTooltipLongText'          );     e2555('showTooltipColorInterpolation');     e2555('showTooltipColorBlindness'    );     e2555('showTooltipColorContrast'     );     e2555('showTooltipColorNames'        );     e2555('showTooltipAscii'             );      e2555('enableBetaFeatures'           );                  e2555('logThreadMessages'            );     e2555('logDataMessages'              );     e2555('logMessages'                  );      e2555('logActions'                   );                  e2555('logLoading'                   );     e2555('logRequests'                  );     e2555('logValueUpdates'              );     e2555('logObjectUpdates'             );     e2555('logStyleUpdates'              );                  e2555('logRawLoadPages'              );     e2555('logRawLoadNodes'              );     e2555('logRawLoadConnections'        );              e2555('logRawSavePages'              );     e2555('logRawSaveNodes'              );     e2555('logRawSaveConnections'        );              e2555('logRawRequests'               );     e2555('logRawValues'                 ); }


const q1056           = 'LIST#';  const b1057    = 'NLIST#'; const   b1058    = 'TLIST#'; const  o1059    = 'SLIST#';   const n1060            = 'NULL'; const f1061             = 'VAR'; const b1062       = 'VARGRP'; const q1063             = 'FEEDBK'; const r1064               = 'REPT'; const y1065                = 'CACHE'; const q1066               = 'FRZ'; const k1067                = 'TIMER'; const e1068           = 'VNAME'; const x1352 = 'GVNAMES'; const x1353     = 'VNAMES'; const a1354          = 'ONAME';  const p1069              = 'CMB'; const w1070         = 'LSASIT'; const n1071              = 'EXTR'; const r1072            = 'SETP'; const f1073            = 'GETP'; const b1074              = 'SUBLST'; const c1075               = 'UNIQ'; const q1349         = 'RORD'; const m1350           = 'SHFTLST'; const g1076         = 'REVLST'; const a1351          = 'BUKLST'; const k1077                 = 'SORT'; const a1078               = 'CLMN'; const n1079                 = 'CELL'; const j1080                 = 'LIST'; const k1081           = 'COUNT'; const OBJECT_COUNT         = 'OBJCOUNT'; const y1082             = 'LCONT'; const o1083               = 'SELECT'; const b1360     = 'LSTSEL'; const d1084              = 'IF'; const q1085               = 'LSTFLT';   const x1087            = 'ANY#';   const c1088 = [     q1056,     b1057,     b1058,     o1059,     p1069,     n1071,     r1072,     f1073,     b1074,     j1080,     k1081,     y1082,     r1064 ];   const w1089 = [            q1056,     b1057,       b1058,      o1059 ];   const k1086                 = 'ITER';   const k1108             = 'PROB';   const HOLD                    = 'HOLD';   const c1091            = 'NUM#';   const m1092                  = 'NUM';    const s1355        = 'NPREC';    const h1093             = 'NSIGN';    const j1094         = 'ABS';    const a1356         = 'NEG';    const q1095            = 'ROUND';    const l1357         = 'QUANT';    const w1096    = 'SMINMAX';    const e1097           = 'MINMAX';    const u1098           = 'LIM';    const a1099            = 'NCURVE';    const c1358              = 'NMAP';    const d1359             = 'NBIAS';    const c1100              = 'NANISNUM'; const f1101         = 'CONST';   const o1102         = 'DATE';   const n1103         = 'SEQ';   const a1104            = 'RANGE';   const y1105             = 'WAVE';   const e1106           = 'RAND';   const g1107            = 'NOISE';   const w1109       = 'ACCUM';   const x1110      = 'LERP';  const g1111            = 'SOLVE'; const a1112          = 'NANIM';  const o1113      = 'SMATH';   const f1114             = 'MATH';   const c1115              = 'ADD';    const h1116         = 'SUB';    const m1117         = 'MUL';    const n1118           = 'DIV';    const b1119           = 'MOD';    const n1120         = 'EXP';  const s1121          = 'NBOOL';   const h1122              = 'NOT'; const h1123              = 'AND'; const r1124               = 'OR'; const u1125              = 'XOR';  const a1126        = 'COND'; const k1127            = 'EQ'; const w1128        = 'NE'; const k1129             = 'LT'; const g1130    = 'LE'; const b1131          = 'GT'; const q1132 = 'GE';  const a1133             = 'TRIG';   const k1134              = 'SIN';    const e1135              = 'COS';    const w1136              = 'TAN'; const l1137            = 'ATAN2';  const o1138           = 'CNVANG';   const y1090 = [     n1060,     f1061,     b1062,     ...c1088,     w1070,     n1071,     r1072,     f1073,     b1074,     c1075,     q1349,     m1350,     g1076,     a1351,     a1078,     k1077,     n1079,     j1080,     o1083,     b1360,     d1084,     q1085,     q1063,     r1064,          k1086,     k1108,     HOLD,     y1065,     q1066,     k1067,     e1068,     x1352,     x1353,     a1354 ];   const e1139 = [     f1114,     o1113,     c1115,     h1116,     m1117,     n1118,     b1119,     n1120 ];   const l1140 = [     s1121,     h1122,     h1123,     r1124,     u1125 ];   const e1141 = [     a1126,     k1127,     w1128,     k1129,     g1130,     b1131,     q1132 ];   const n1142 = [     a1133,     k1134,     e1135,     w1136,     l1137 ];   const g1143     = 'TEXT#'; const y1144           = 'TEXT'; const r1145    = 'TLEN'; const b1146      = 'TTRIM'; const y1147 = 'TSUB'; const b1148  = 'TCONT'; const h1149      = 'TCASE'; const j1150   = 'TREPL'; const k1151      = 'TJOIN'; const r1152       = 'TPAD'; const s1153   = 'TCMP'; const m1154      = 'TCHAR'; const j1155   = 'TUNI'; const y1156  = 'INDEX'; const g1157 = 'N2T'; const w1158  = 'C2T'; const g1159 = 'T2N'; const x1160  = 'T2C'; const t1161     = 'TSPLT'; const v3505      = 'TJSON'; const z1163       = 'TCSV'; const p1164     = 'FETCH'; const w1165      = 'TFILE';   const q1166 = [     c1091,     b1057,     m1092,     s1355,     h1093,     j1094,     a1356,     q1095,     l1357,     w1096,     e1097,     u1098,     a1099,     c1358,     d1359,     c1100,     f1101,     o1102,     n1103,     a1104,     y1105,     e1106,     g1107,     w1109,     x1110,     g1111,     a1112,     g1157,     m1154,      ...e1139,     ...l1140,     ...e1141,     ...n1142,      o1138,     a1351 ];   const a1167 = [     g1143,     b1058,     y1144,     r1145,     b1146,     y1147,     b1148,     h1149,     k1151,     r1152,     j1150,     s1153,     j1155,     y1156,     g1159,     x1160,     t1161,     v3505,     z1163,     p1164,     w1165 ];   const d1168        = 'COL#';   const a1169              = 'COL';    const f1170        = 'CVAL';   const w1171      = 'CCOR';   const x1172   = 'COLP3'; const i1173     = 'CCNT';   const p1174         = 'BLND';   const j1175  = 'CLERP';  const f1176        = 'CBLND';   const a1177 = [     d1168,     a1169,     w1171,     x1172,     p1174,     j1175,     f1176,     w1158 ];   const i1178          = 'FILL#'; const z1179                = 'FILL'; const s1180          = [i1178, z1179];    const c1181        = 'STRK#'; const i1182              = 'STRK'; const p1183        = [c1181, i1182];    const g1190  = 'STRKSD#'; const q1191        = 'STRKSD'; const p1192  = [g1190, q1191];  const b1184    = 'CSTOP#'; const v1185          = 'CSTOP'; const k1186    = [b1184, v1185];    const x1187      = 'GRAD#'; const n1188            = 'GRAD'; const a1189      = [x1187, n1188];    const h1193 = 'RCRN#'; const h1194       = 'RCRN'; const s1195 = [h1193, h1194];  const u1196   = 'DRSH#'; const n1197         = 'DRSH'; const q1198   = [u1196, n1197];   const c1199  = 'INSH#'; const b1200        = 'INSH'; const b1201  = [c1199, b1200];   const u1202    = 'LBLR#'; const a1203          = 'LBLR'; const b1204    = [u1202, a1203];   const n1205     = 'BBLR#'; const m1206           = 'BBLR'; const j1207     = [n1205, m1206];   const d1208    = 'MASK#'; const c1209          = 'MASK'; const e1210    = [d1208, c1209];   const x1211   = 'BLEND#'; const x1212         = 'BLEND'; const w1213   = [x1211, x1212];   const o1214 = [     ...p1192,     ...s1195,     ...q1198,     ...b1201,     ...b1204,     ...j1207,     ...w1213,     ...e1210 ];   const u1215 = [            d1168,              i1178,          x1187,            c1181,     g1190,      u1196,     c1199,       u1202,        n1205,      x1211,       d1208 ];   const l1216           = 'CSTL';     const u1217           = 'SHP#';    const y1218       = 'RECT#'; const u1219             = 'RECT';   const l1220       = [y1218, u1219];   const t1221            = 'LINE#'; const m1222                  = 'LINE';  const c1223            = [t1221, m1222];     const u1224         = 'ELPS#'; const p1225               = 'ELPS';  const h1226         = [u1224, p1225];   const q1227         = 'TRPZ#'; const b1228               = 'TRPZ'; const x1229         = [q1227, b1228];   const i1236         = 'POLY#'; const h1237               = 'POLY';  const o1238         = [i1236, h1237];     const o1239            = 'STAR#'; const j1240                  = 'STAR';  const b1241            = [o1239, j1240];     const t1242      = 'TXTS#'; const k1243            = 'TXTS';  const w1244      = [t1242, k1243];    const i1245           = 'PT#'; const t1246                 = 'PT'; const s1247           = [i1245, t1246];  const t1248          = 'PCORN';  const m1249     = 'VPATH#'; const g1250           = 'VPATH';  const a1251     = [m1249, g1250];   const p1252   = 'VPT#'; const w1253         = 'VPT';  const q1254   = [p1252, w1253];  const h1255     = 'VEDGE#'; const o1256           = 'VEDGE';  const r1257     = [h1255, o1256];  const g1258   = 'VREG#'; const m1259         = 'VREG';  const g1260   = [g1258, m1259];  const w1261  = 'VNET#'; const h1262        = 'VNET';  const g1263  = [w1261, h1262];  const n1264     = 'SGRP#'; const m1265           = 'SGRP'; const o1266     = [n1264, m1265];  const r1267           = 'FRM#'; const y1268                 = 'FRM'; const w1269           = [r1267, y1268];   const r1231        = 'ARC#'; const o1230              = 'ARC'; const j1232        = [r1231, o1230];  const y1234       = 'WAVEP#'; const g1233             = 'WAVEP'; const r1235       = [y1234, g1233];  const m1270                  = 'MOVE'; const d1271                = 'ROT'; const g1272                 = 'SCALE'; const j1273                  = 'SKEW';  const SHOW_CENTER           = 'SHOWCNTR'; const k1274            = 'SCENTR'; const k1275           = 'RSTX';  const z1276                 = 'PLACE'; const c1277           = 'APPLY';    const PATH_LENGTH           = 'PTHLEN'; const JOIN_PATHS            = 'JOINPTH'; const REORIENT_PATHS        = 'REORPTH'; const q1284      = 'PTALPATH'; const o1285 = 'CPTONPATH'; const g1278        = 'MESPT'; const m1279           = 'PTANGLE'; const w1280                = 'VECLEN'; const o1281         = 'CIRCEN'; const ARC_FROM_POINTS       = 'ARCPT'; const w1282       = 'INTLIN'; const o1283     = 'PTLERP'; const REVERSE_PATH          = 'REVPTH'; const BLEND_PATH            = 'BLENDPTH';   const PATH_TYPES = [     g1250,      b1228,     o1230,     g1233 ];  const PATH_VALUES = [     m1249,      q1227,     r1231,     y1234 ];   const c1286         = 'SBOOL'; const m1287   = 'SBOOL#';  const p1288            = 'SBOOLU'; const q1289         = 'SBOOLS'; const c1290        = 'SBOOLI'; const q1291          = 'SBOOLE';   const b1292 = [     c1286,     m1287,     p1288,     q1289,     c1290,     q1291 ];   const b1293               = 'RENDER'; const EXPORT               = 'EXPORT';   const i1294 = [     u1217,     o1059,     y1218,     t1221,     u1224,     q1227,     i1236,     o1239,     t1242,     i1245,     m1249,     p1252,     h1255,     g1258,     w1261,     r1231,     y1234,     n1264,     r1267,     m1287,     u1196,     c1199,     u1202,     n1205,     x1211,     d1208 ];   const m1295 = [     d1271,     g1272,     j1273 ];   const t1296 = [     ...i1294,      ...l1220,     ...c1223,     ...h1226,     ...x1229,     ...o1238,     ...b1241,     ...w1244,     ...s1247,        t1248,     ...a1251,     ...q1254,     ...r1257,     ...g1260,     ...g1263,     ...j1232,     ...r1235,     ...o1266,     ...w1269,     ...b1292,          m1270,     ...m1295,     SHOW_CENTER,     k1274,     k1275,              z1276,     c1277,          PATH_LENGTH,     JOIN_PATHS,     REORIENT_PATHS,     q1284,     o1285,              g1278,     m1279,     w1280,     o1281,     o1230,     g1233,     ARC_FROM_POINTS,     w1282,     o1283,     REVERSE_PATH,     BLEND_PATH,      b1293,     EXPORT ];   const n1297 = [             q1056,      b1057,        b1058,       o1059,                 c1091,             g1143,            d1168,               i1178,       b1184,         x1187,           c1181,         b1184,         x1187,              u1217,        y1218,             t1221,          u1224,          q1227,          i1236,             o1239,       t1242,            i1245,      m1249,    p1252,      h1255,    g1258,   w1261,      n1264,            r1267,     h1193,      u1196,     c1199,       u1202,        n1205,       x1211,       d1208 ];   const w1298    = 'GROUP'; const k1299   = 'GPARAM';   const u1300 = [     w1298,     k1299 ];   const c1301       = 'CMNT'; const t1302 = 'CMNTARR'; const w1303         = 'PANEL';   const z1304        = 'ACT'; const d1305 = 'BFACT'; const u1306   = 'BFLST'; const f1307      = 'DIS'; const l1308       = 'NOC';   const PARAM         = 'PARAM';     const g1309           = 'LOG';   const i1310         = 'GRAPH';   const m1311 =  [        [b1119,   '%' ],     [n1118,   '/' ],      [h1116, '−' ],     [c1115,      '+' ],     [m1117, '×' ],     [n1120, 'e<sup>x']  ];   const l1312 =  [        [n1118,   '/' ],      [h1116, '−' ],     [c1115,      '+'],     [m1117, '×'] ];    const u1313 = 0; const q1314 = 1; const r1315  = 2; const a1316 = 3;   const t1317 =  [        [u1313, 'not'],     [q1314, 'xor'],      [r1315,  'or' ],     [a1316, 'and'] ];    const p1318             = 0; const z1319    = 1; const k1320        = 2; const b1321            = 3; const b1322 = 4; const i1323          = 5;   const u1324 =  [        [p1318,             '<'],     [z1319,    '≤'],     [k1320,        '≠'],     [b1321,            '='],     [b1322, '≥'],     [i1323,          '>'] ];    const v1325  = 0; const b1326  = 1; const e1327  = 2; const b1328 = 3; const y1329 = 4; const r1330 = 5;   const m1331 =  [        [v1325,  'sin' ],     [b1326,  'cos' ],     [e1327,  'tan' ],     [b1328, 'asin'],     [y1329, 'acos'],     [r1330, 'atan'] ];    const f1332               = 'EMPTY'; const v1333             = 'CONNECT'; const r1334              = 'CREATE'; const u1335       = 'CREATE_INSERT'; const u1336              = 'DELETE'; const z1337          = 'DISCONNECT'; const p1338          = 'LINK_STYLE'; const m1339       = 'LINK_VARIABLE'; const u1340 = 'LINK_VARIABLE_GROUP'; const w1341         = 'MAKE_ACTIVE'; const MAKE_NOT_CONDITION_ACTION  = 'MAKE_NOT_CONDITION'; const a1342        = 'MAKE_PASSIVE'; const j1343               = 'PASTE'; const i1344           = 'RECONNECT'; const q1345              = 'REMOVE'; const f1346              = 'RENAME'; const h1347      = 'REORDER_INPUTS'; const l1348 = 'REORDER_CONNECTIONS'; const p1361              = 'SELECT'; const e1362         = 'SELECT_MOVE'; const n1363          = 'MOVE_NODES'; const o1364     = 'SET_PARAM_VALUE'; const SET_MULTIPLE_VALUES_ACTION = 'SET_MULTIPLE_VALUES'; const w1365   = 'SET_PARAM_SETTING'; const g1366       = 'SET_NODE_RECT'; const p1367      = 'TOGGLE_DISABLE'; const c1368 = 'TOGGLE_PARAM_HEADER'; const v1369   = 'SET_CURRENT_GRAPH'; const w1370         = 'CREATE_PAGE'; const a1371         = 'DELETE_PAGE'; const d1372         = 'GROUP_NODES'; const d1373       = 'UNGROUP_NODES'; const e1374     = 'HIGHLIGHT_NODES'; const SCROLL_LIST_NODE_ACTION    = 'SCROLL_LIST_NODE'; const SET_LIST_DIVIDER_ACTION    = 'SET_LIST_DIVIDER'; const SET_NODE_PARAM_ACTION      = 'SET_NODE_PARAM';   const n1375               = 'BNORM'; const a1376               = 'BDARK'; const s1377             = 'BMULT'; const a1378          = 'BPDRK'; const d1379           = 'BBURN'; const q1380              = 'BLITE'; const u1381               = 'BSCRN'; const s1382         = 'BPLGT'; const k1383          = 'BDODG'; const l1384              = 'BOVER'; const r1385           = 'BSOFT'; const o1386           = 'BHARD'; const h1387           = 'BDIFF'; const v1388            = 'BEXCL'; const z1389                  = 'BHUE'; const t1390           = 'BSAT'; const j1391                = 'BCOL'; const w1392           = 'BLUM';   const l1393 = [     [n1375,       'normal',       'NORMAL'      ],     [a1376,       'darken',       'DARKEN'      ],     [s1377,     'multiply',     'MULTIPLY'    ],     [a1378,  'plus darker',  'LINEAR_BURN' ],     [d1379,   'color burn',   'COLOR_BURN'  ],     [q1380,      'lighten',      'LIGHTEN'     ],     [u1381,       'screen',       'SCREEN'      ],     [s1382, 'plus lighter', 'LINEAR_DODGE'],     [k1383,  'color dodge',  'COLOR_DODGE' ],     [l1384,      'overlay',      'OVERLAY'     ],     [r1385,   'soft light',   'SOFT_LIGHT'  ],     [o1386,   'hard light',   'HARD_LIGHT'  ],     [h1387,   'difference',   'DIFFERENCE'  ],     [v1388,    'exclusion',    'EXCLUSION'   ],     [z1389,          'hue',          'HUE'         ],     [t1390,   'saturation',   'SATURATION'  ],     [j1391,        'color',        'COLOR'       ],     [w1392,   'luminosity',   'LUMINOSITY'  ] ];    const k1394 = [     ['thin',        100],     ['extra light', 200],     ['light',       300],     ['regular',     400],     ['medium',      500],     ['semi bold',   600],     ['bold',        700],     ['extra bold',  800],     ['black',       900] ];    const e1395           =  0; const r1396        =  1;  const n1397      =  2;   const u1398     = 2; const l1399    =  3;   const j1400   = 3;  const q1401       =  4;   const f1402 = 4; const p1403         =  5;   const t1404            =  6; const l1405            =  7; const w1406            =  8;  const u1407          =  9;  const t1408          = 10; const m1409        = 11;   const r1410  = 12; const h1411   = 13; const l1412    = 14;                                     const z1413   = 15; const n1414     = 16; const h1415  = 17;  const x1416        = 18;  const t1417           = 19; const b1418      = 20;     const x1419        = 21; const h1420          = 22; const z1421           = 23;  const u1422              = 24;                                                                         const w1453    = 24;                                                                                              const c1423 = 24; const c1424              = 25;                                                                         const d1454   = 25; const n1425          = 26;    const d1426         = 27;                                      const s1427     = 28;   const s1428   = 28;   const z1429 = 28;   const v1430    = 28;   const n1431   = 28;   const y1432  = 28;   const o1433      = 28;   const t1434    = 28;                                 const a1435   = 29;                                        const p1436 = 29;   const c1437 = 29;   const r1438 = 29;   const z1439     = 29;   const k1455     = 29;                                 const u1441   = 30;                                        const o1442   = 30;                                 const i1443 = 30;   const h1444           = 30;   const v1440 = 30;                                                                                                                                                                   const l1445   = 31;                                                                                                                                        const x1446           = 31;                                                                                                                                                                                                       const x1447      = 32;                                                                                                                                                                                                       const y1448     = 33;                                                                                                                                                                                                                                                                                                                                                                                                                                            const d1449        = 34;                                                                                                                                                                                                       const h1450        = 35;                                                                                                                                                                                                                                                                                                                                                                                                                                            const y1451    = 36;                                                                                                                                                                                                       const l1452 = 37;


class l1843 {     type;          nodeId     = '';       objectId   = NULL;     objectName = NULL;      w3820  = -1;       retain     = 0;     feedback   = false;       showCenter = false;          b4208;      xp0   = null;      xp1   = null;      xp2   = null;       sp0   = null;      sp1   = null;      sp2   = null;       d3740;     scaleStyle;        constructor(type, nodeId, objectId, objectName)     {         this.type         = type;         this.nodeId       = nodeId;         this.objectId     = objectId;         this.objectName   = objectName;          this.b4208        = clone(identity);          this.d3740 = 1;         this.scaleStyle   = 1;     }        x3359(base)     {         this.w3820    = base.w3820;                  this.feedback     = base.feedback;         this.retain       = base.retain;          this.showCenter   = base.showCenter;          this.b4208        = clone(base.b4208);          this.xp0          = clone(base.xp0);         this.xp1          = clone(base.xp1);         this.xp2          = clone(base.xp2);          this.sp0          = clone(base.sp0);         this.sp1          = clone(base.sp1);         this.sp2          = clone(base.sp2);          this.d3740 = base.d3740;         this.scaleStyle   = base.scaleStyle;     }        copy()     {         h953('invalid use of abstract method l1843.copy()');         return null;     }        getCount()     {         return 1;     }        y3742(cx = 0, cy = 0)     {         this.sp0 = point(cx,   cy  );         this.sp1 = point(cx+1, cy  );         this.sp2 = point(cx,   cy+1);     }        resetSpace(bounds, singlePoint = false, cx = 0.5, cy = 0.5, units = 0)     {         let _cx;          let _cy;           if (units == 0)         {             _cx = bounds.x + cx * bounds.width;             _cy = bounds.y + cy * bounds.height;                     }         else if (units == 1)         {             _cx = bounds.x + cx;             _cy = bounds.y + cy;         }         else          {             _cx = cx;             _cy = cy;                     }           const ds1 = x900(this.sp1, this.sp0);         const ds2 = x900(this.sp2, this.sp0);          this.sp0  = point(_cx, _cy);          this.sp1  = f895(this.sp0, ds1);         this.sp2  = f895(this.sp0, ds2);           if (PATH_TYPES.includes(this.type))             this.y3743();     }        f4098(x, y, a = 0)     {         this.b4208 =             [[Math.cos(a), -Math.sin(a), x],              [Math.sin(a),  Math.cos(a), y],              [0,            0,           1]];     }        c3730(x, y, w, h)     {         this.xp0 = point(x,     y    );         this.xp1 = point(x + w, y    );         this.xp2 = point(x,     y + h);     }        x3732()     {         let vr = point(this.sp1.x - this.sp0.x, this.sp1.y - this.sp0.y);         let vb = point(this.sp2.x - this.sp0.x, this.sp2.y - this.sp0.y);                   let sx = vr.x;         let sy = vb.y;              let kx = vr.y;         let ky = vb.x;                  let dx = this.sp0.x;         let dy = this.sp0.y;                   let b4208 = e889(             a893(dx, dy),             [[sx, ky, 0],              [kx, sy, 0],              [0,  0,  1]]);               return b4208;     }                getBounds()     {         let bounds = s1047.NaN;          const dp = x900(this.xp1, this.xp0);          bounds = q3745(bounds, this.xp0);         bounds = q3745(bounds, this.xp1);         bounds = q3745(bounds, this.xp2);         bounds = q3745(bounds, f895(this.xp2, dp));          return bounds;     }        z4099(b4208, affectSpace)     {         const space = this.x3732();           if (this.type == t1246)         {             if (affectSpace > 0)             {                 const p = d3731(point(this.x, this.y), b4208, space);                  this.x = p.x;                 this.y = p.y;             }              if (affectSpace != 1)                 this.applySpaceTransform(b4208, space);         }         else if (PATH_TYPES.includes(this.type))         {             if (affectSpace > 0)             {                 this.applyObjectTransform(b4208, space);                  this.updatePoints(b4208, space);                 this.y3743();                              }              if (affectSpace != 1)                 this.applySpaceTransform(b4208, space);         }         else if (this.type == m1265)         {             for (const v111 of this.children)             {                 if (affectSpace > 0)                 {                     v111.applyObjectTransform(b4208, space);                      if (v111.type == g1250)                         v111.updatePoints(b4208, space);                 }                  if (affectSpace != 1)                     v111.applySpaceTransform(b4208, space);             }                         }         else         {             if (affectSpace > 0)                 this.applyObjectTransform(b4208, space);              if (affectSpace != 1)                 this.applySpaceTransform(b4208, space);         }     }        applyObjectTransform(b4208, space)     {         if (   this.xp0.x == this.xp1.x             && this.xp0.y == this.xp1.y)             this.xp1.x += 0.0001;          if (   this.xp0.x == this.xp2.x             && this.xp0.y == this.xp2.y)             this.xp2.y += 0.0001;          this.xp0 = d3731(this.xp0, b4208, space);         this.xp1 = d3731(this.xp1, b4208, space);         this.xp2 = d3731(this.xp2, b4208, space);     }        applySpaceTransform(b4208, space)     {         this.sp0 = d3731(this.sp0, b4208, space);         this.sp1 = d3731(this.sp1, b4208, space);         this.sp2 = d3731(this.sp2, b4208, space);     }        checkFlipped(flipX, flipY)     {         if (flipX)         {             const d1 = x900(this.xp1, this.xp0);              this.xp0 = f895(this.xp0, d1);             this.xp2 = f895(this.xp2, d1);             this.xp1 = x900(this.xp1, d1);         }                   if (flipY)         {             const d2 = x900(this.xp2, this.xp0);              this.xp0 = f895(this.xp0, d2);             this.xp1 = f895(this.xp1, d2);             this.xp2 = x900(this.xp2, d2);         }     }        b3756()     {         return {             type:       this.type,             nodeId:     this.nodeId,              objectId:   this.objectId,             objectName: this.objectName,                          feedback:   this.feedback,              xp0:        this.xp0 ? this.xp0 : null,             xp1:        this.xp1 ? this.xp1 : null,             xp2:        this.xp2 ? this.xp2 : null         };     }        a3741()     {         return [          this.type,          this.nodeId,           this.objectId,          this.objectName,                       this.feedback,          this.retain,                   this.xp0 ? this.xp0 : null,          this.xp1 ? this.xp1 : null,          this.xp2 ? this.xp2 : null,           0          ];     }        r3633()     {         return new u4217();     } }    function d3731(p, b4208, space) {     p = z888(p, z891(space));     p = z888(p, b4208);     p = z888(p, space);      return p; }    function f3738(v111) {     switch (v111.type)     {         case u1219:     return h1846 .prototype.copy.call(v111);         case m1222:          return p1842      .prototype.copy.call(v111);         case p1225:       return y1840   .prototype.copy.call(v111);         case b1228:       return r1851   .prototype.copy.call(v111);         case h1237:       return t1845   .prototype.copy.call(v111);         case j1240:          return n1849      .prototype.copy.call(v111);         case k1243:    return s1850      .prototype.copy.call(v111);         case t1246:         return w1844     .prototype.copy.call(v111);         case g1250:   return o1853.prototype.copy.call(v111);         case o1230:      return FigmaArcPath   .prototype.copy.call(v111);         case g1233:     return FigmaWavePath  .prototype.copy.call(v111);         case c1286: return n1838   .prototype.copy.call(v111);         case m1265:   return k1848.prototype.copy.call(v111);         case y1268:         return f1841     .prototype.copy.call(v111);     }      h953('invalid Figma object type \'' + v111.type + '\'');     return null; }    function getPointBounds(points) {     let minX = Number.MAX_SAFE_INTEGER;     let minY = Number.MAX_SAFE_INTEGER;     let maxX = Number.MIN_SAFE_INTEGER;     let maxY = Number.MIN_SAFE_INTEGER;      for (const p of points)     {         minX = Math.min(minX, p.x.value);         minY = Math.min(minY, p.y.value);         maxX = Math.max(maxX, p.x.value);         maxY = Math.max(maxY, p.y.value);     }      return new AbsRect(minX, minY, maxX, maxY); }    function getObjBounds(objects) {     let bounds = s1047.NaN;      for (const v111 of objects)         bounds = r3744(bounds, v111.getBounds());      return bounds; }    function l2586(node, v111) {     const sp0 = point(         v111.sp0.x ,          v111.sp0.y );      const sp1 = f895(sp0, l897(      x900(v111.sp1, v111.sp0),      settings.objectCenterSize));     const sp2 = f895(sp0, l897(l897(x900(v111.sp2, v111.sp0), -1), settings.objectCenterSize));          const center = createDecoPoly(         node.nodeId,         v111.objectId,         v111.objectName,          sp0,          [sp2, sp0, sp1],         false,         '',         [242, 72, 34],          a970,         true);      return center; }    function createDecoPoly(nodeId, objectId, objectName, center, points, closed, dashes, color, suffix, isCenter) {     const path = new o1853(         nodeId,         objectId   + suffix,         objectName + suffix,         points.map(p => q2023.fromPoint(objectId, p)),         closed ? 1 : 0,          0,          0,          0);       path.strokes.push([         'SOLID',          color[0],          color[1],          color[2],          100,          'NORMAL']);      path.strokeWeight =  1;     path.strokeAlign  = 'CENTER';     path.strokeJoin   = 'MITER';     path.strokeCap    = 'NONE';     path.strokeDashes =  dashes;     path.l3739       =  true;     path.isCenter     =  isCenter;       path.f4098(center.x, center.y);            return path; }    function q3628(value) {     return value         && value.objects         ? value.objects               .filter(o =>                       o.l3739  === false                   || o.isXform === true)               .map(o => o.copy())          : []; }


function r1823(v111, prop) {          if (prop.type ==         d1168)  x1824       (v111, prop);     else if (prop.type ==          i1178)  x1825        (v111, prop);     else if (prop.type ==      x1187)  o1826    (v111, prop);     else if (prop.type ==        c1181)  x1830      (v111, prop);     else if (prop.type ==  g1190)  addStrokeSidesProp (v111, prop);     else if (prop.type == h1193)  n1831(v111, prop);     else if (prop.type ==   u1196)  z1832  (v111, prop);     else if (prop.type ==  c1199)  q1833 (v111, prop);     else if (prop.type ==    u1202)  o1834   (v111, prop);     else if (prop.type ==     n1205)  v1835    (v111, prop);     else if (prop.type ==   x1211)  k1836  (v111, prop);     else if (prop.type ==    d1208)  j1837        (v111, prop); }    function x1824(v111, prop) {     const rgb = n4142(prop.p3242());      if (v111.type == m1265)     {         for (const _obj of v111.children)             r1823(_obj, prop);     }     else     {         v111.fills.push([             'SOLID',              rgb[0],              rgb[1],              rgb[2],              255 ]);     } }    function x1825(v111, prop, target = v111.fills) {     if (prop.color.type != d1168)         return;       const rgb = n4142(prop.color.p3242());      if (v111.type == m1265)     {         for (const _obj of v111.children)             r1823(_obj, prop);     }     else     {         target.push([             'SOLID',              rgb[0],              rgb[1],              rgb[2],              prop.opacity.r3633().value,             l1393[Math.min(Math.max(0, Math.round(prop.blend.value)), l1393.length-1)][2]]);     } }    function o1826(v111, prop, target = v111.fills)                 {     const gradient =      [         '',          [],          [],          '',          0                     ];       switch(prop.l3687.value)     {         case 0: gradient[0] = 'GRADIENT_LINEAR';  break;         case 1: gradient[0] = 'GRADIENT_RADIAL';  break;         case 2: gradient[0] = 'GRADIENT_ANGULAR'; break;         case 3: gradient[0] = 'GRADIENT_DIAMOND'; break;     }           let   x        =        prop.x     .value / 100;     let   y        =        prop.y     .value / 100;     let   s        = nozero(prop.size  .value / 100);     let   a        =        prop.angle .value / 360*Tau;     let   asp      = nozero(prop.aspect.value / 100);     const diag     =        prop.diagAspect;     let   sk       =        prop.skew  .value / 100;           const pos      = prop.position.value;     const isLinear = prop.l3687.value == 0;          const bounds   = v111.getBounds();       if (pos > 0)     {         if (   pos == 1             || pos == 2)          {             x = x / 100 * bounds.width;             y = y / 100 * bounds.height;         }                   x = x * 100 / nozero(bounds.width );         y = y * 100 / nozero(bounds.height);           if (pos == 4)         {             x = x - bounds.x / nozero(bounds.width );             y = y - bounds.y / nozero(bounds.height);                          s *= 100 / nozero(bounds.width);         }     }       let   p0 = point(x, y);     let   p1 = f895(p0, vector(a, diag === true ? s : s * nozero(asp)));     let   p2 = f895(p0, vector(a + Tau/4, s));      const a1 = anglev2(p0, p1);     const a2 = anglev2(p0, p2);           if (diag === true)     {         p1 = f895(p1, vector(a1 - Tau/8, (asp-1) * Math.sqrt(sqr(distv(p0, p1))/2)));         p2 = f895(p2, vector(a2 + Tau/8, (asp-1) * Math.sqrt(sqr(distv(p0, p2))/2)));          p1 = f895(p1, vector(a2 + Tau/8, s * sk * Math.sqrt(2)/2));         p2 = f895(p2, vector(a2 + Tau/8, s * sk * Math.sqrt(2)/2));     }     else     {         p2 = x900(p2, vector(a1, s * sk));     }       if (pos > 0)     {         if (   pos == 1             || pos == 3             || pos == 4)         {             const aspect = bounds.width / nozero(bounds.height);                          p1.y = p0.y + (p1.y - p0.y) * aspect;             p2.y = p0.y + (p2.y - p0.y) * aspect;         }         else if (pos == 2)         {             const aspect = bounds.height / nozero(bounds.width);                          p1.x = p0.x + (p1.x - p0.x) * aspect;             p2.x = p0.x + (p2.x - p0.x) * aspect;         }     }       if (!isLinear)     {         const dv = x900(p0, p1);          p0 = f895(p0, dv);         p2 = f895(p2, dv);     }             if (prop.stops.items.some(i =>                 i             && (   i.position.value < 0                  || i.position.value > 100)))     {         let minPos = Number.MAX_SAFE_INTEGER;         let maxPos = Number.MIN_SAFE_INTEGER;          for (const stop of prop.stops.items)         {             minPos = Math.min(minPos, stop.position.value);             maxPos = Math.max(maxPos, stop.position.value);         }          if (!isLinear)             minPos = Math.max(0, minPos);           const dpos  = Math.min(0, minPos) / 100;         const dsize = Math.max(100, maxPos - Math.min(minPos, 0)) / 100;          const dv    = x900(p0, p1);          p0 = f895(p0, l897(dv, Math.max(0, -dpos)));         p1 = f895(p1, l897(dv, Math.max(0, -dpos)));         p2 = f895(p2, l897(dv, Math.max(0, -dpos)));          if (prop.l3687.value != 2)          {             p1 = x900(p0, l897(dv, dsize));             p2 = f895(p0, l897(x900(p2, p0), dsize));         }           for (const stop of prop.stops.items)             stop.position.value = stop.position.value * 100 / maxPos;     }       gradient[1] = [p0, p1, p2];           const stops = prop.stops.items;      for (let j = 0; j < stops.length; j++)     {         const stop = stops[j];          if (stop.fill)         {             const rgba = stop.fill.d99();              gradient[2].push([                 rgba[0],                  rgba[1],                  rgba[2],                  rgba[3],                 Math.min(Math.max(0, stop.position.value / 100), 1)]);         }     }       gradient[3] = l1393[prop.blend.value][2];           target.push(gradient); }    function e1827(r1828) {     const stops = [];       for (let i = 0; i < r1828.length; i++)     {         const stop = r1828[i];          if (stop.type == d1168)         {             stops.push(new o2009(                 c2013.y3773(n4142(stop.p3242()), 100),                 y2022.NaN));         }          else if (stop.type == i1178)             stops.push(new o2009(                 stop,                 y2022.NaN));          else if (stop.type == q1056)             stops.push(...e1827(stop.items));          else             stops.push(stop);     }       return stops; }    function i1829(stops) {     if (    stops.length > 0         && !stops[0].position.isValid())          stops[0].position = new y2022(0);      if (    stops.length > 1         && (!stops.at(-1).position.isValid()))          stops.at(-1).position = new y2022(100);           if (stops.length > 2)     {         for (let i = 1; i < stops.length-1; i++)         {             const stop = stops[i];              if (   !stop                 || !stop.position                 || !stop.position.isValid())             {                 let prevValid = i-1;                 let nextValid = i+1;                  while ( prevValid > 0                     && !stops[prevValid].position.isValid())                      prevValid--;                  while ( nextValid < stops.length-1                     && !stops[nextValid].position.isValid())                      nextValid++;                                          const pv = stops[prevValid].position.value;                 const nv = stops[nextValid].position.value;                  stop.position = new y2022((pv + (nv - pv) * ((i - prevValid) / (nextValid - prevValid))));              }         }     } }    function x1830(v111, prop) {     for (const fill of prop.fills.items)     {         if (fill.type ==     i1178) x1825    (v111, fill, v111.strokes);         if (fill.type == x1187) o1826(v111, fill, v111.strokes);     }       if (v111.type == m1265)     {         for (const _obj of v111.children)             r1823(_obj, prop);     }     else     {         v111.strokeWeight = prop.weight.r3633().value;          switch (prop.fit.r3633().value)         {             case 0: v111.strokeAlign = 'INSIDE';  break;             case 1: v111.strokeAlign = 'CENTER';  break;             case 2: v111.strokeAlign = 'OUTSIDE'; break;         }          switch (prop.join.r3633().value)         {             case 0: v111.strokeJoin = 'MITER'; break;             case 1: v111.strokeJoin = 'BEVEL'; break;             case 2: v111.strokeJoin = 'ROUND'; break;         }          switch (prop.cap.r3633().value)         {             case 0: v111.strokeCap = 'NONE';   break;             case 1: v111.strokeCap = 'SQUARE'; break;             case 2: v111.strokeCap = 'ROUND';  break;         }          v111.strokeDashes     = prop.dashes.r3633().value.trim();                  v111.strokeMiterLimit = prop.miter .r3633().value;     } }    function addStrokeSidesProp(v111, prop) {     if (v111.type == m1265)     {         for (const _obj of v111.children)             r1823(_obj, prop);     }     else     {         v111.effects.push([            'STROKE_SIDES',              prop.top   .value,             prop.left  .value,             prop.right .value,             prop.bottom.value,             prop.visible ]);     } }    function n1831(v111, prop) {     if (v111.type == m1265)     {         for (const _obj of v111.children)             r1823(_obj, prop);     }     else     {         v111.effects.push([            'ROUND_CORNERS',              prop.tl.value,             prop.tr.value,             prop.bl.value,             prop.br.value,             prop.visible ]);     } }    function z1832(v111, prop) {     const rgba = prop.fill.d99();      v111.effects.push([         'DROP_SHADOW',          rgba[0],         rgba[1],         rgba[2],         rgba[3],         prop.x     .value,          prop.y     .value,          prop.blur  .value,          prop.spread.value,          l1393[prop.blend.value][2],         prop.behind.value > 0,         prop.visible ]); }    function q1833(v111, prop) {     const rgba = prop.fill.d99();      v111.effects.push([         'INNER_SHADOW',          rgba[0],         rgba[1],         rgba[2],         rgba[3],         prop.x     .value,          prop.y     .value,          prop.blur  .value,          prop.spread.value,          l1393[prop.blend.value][2],         prop.visible ]); }    function o1834(v111, prop) {     v111.effects.push([         'LAYER_BLUR',          prop.radius.value,          prop.visible ]); }    function v1835(v111, prop) {     v111.effects.push([         'BACKGROUND_BLUR',          prop.radius.value,          prop.visible ]); }    function k1836(v111, prop) {     v111.opacity = Math.min(Math.max(0, prop.opacity.value  / 100), 1);     v111.blend   = l1393[prop.blend.value][2]; }    function j1837(v111, mask) {     v111.maskType = mask.maskType.value + 1; } 


class t1847 extends l1843 {     skewX;     skewY;      fills   = [];     strokes = [];      strokeWeight;     strokeAlign;     strokeJoin;     strokeMiterLimit;     strokeCap;     strokeDashes;      effects = [];      l3739;     isCenter;     isXform;      opacity;     blend;      maskType = 0;        constructor(type, nodeId, objectId, objectName, l3739 = false, isXform = false)     {         super(type, nodeId, objectId, objectName);          this.skewX    = 0;         this.skewY    = 0;          this.l3739   = l3739;         this.isCenter = false;         this.isXform  = isXform;          this.opacity  = 1;         this.blend    = 'PASS_THROUGH';     }        x3359(base)     {         super.x3359(base);          this.skewX            = base.skewX;         this.skewY            = base.skewY;          this.fills            = clone(base.fills);         this.strokes          = clone(base.strokes);          this.strokeWeight     = base.strokeWeight;         this.strokeAlign      = base.strokeAlign;         this.strokeJoin       = base.strokeJoin;         this.strokeMiterLimit = base.strokeMiterLimit;         this.strokeCap        = base.strokeCap;         this.strokeDashes     = base.strokeDashes;          this.effects          = clone(base.effects);          this.l3739           = base.l3739;         this.isCenter         = base.isCenter;         this.isXform          = base.isXform;          this.opacity          = base.opacity;         this.blend            = base.blend;         this.maskType         = base.maskType;     }        checkFlipped(flipX, flipY)     {         super.checkFlipped(flipX, flipY);          for (const fill   of this.fills  ) flipGradient(fill,   flipX, flipY);         for (const stroke of this.strokes) flipGradient(stroke, flipX, flipY);          const foundSides = this.effects.findIndex(e => e[0] == 'STROKE_SIDES');         if (foundSides > -1) flipStrokeSides(this.effects[foundSides], flipX, flipX);          const foundCorners = this.effects.findIndex(e => e[0] == 'ROUND_CORNERS');         if (foundCorners > -1) flipRoundCorners(this.effects[foundCorners], flipX, flipY);     }        a3741()     {         const weight = this.strokeWeight * Math.abs(this.scaleStyle);          const dashes =              this.strokeDashes             ? this.strokeDashes                 .split(',')                 .map(d => parseFloat(d.trim()) * Math.abs(this.scaleStyle))                 .join(',')             : '';                   return [             ...super.a3741(),                  this.fills,              this.strokes,               weight,              this.strokeAlign,              this.strokeJoin,              this.strokeMiterLimit,              this.strokeCap,              dashes,               this.effects,               this.l3739,              this.isCenter,               this.opacity,              this.blend,              this.maskType         ];     } }    function flipGradient(fill, flipX, flipY) {     if (   fill[0] == 'GRADIENT_LINEAR'         || fill[0] == 'GRADIENT_RADIAL'         || fill[0] == 'GRADIENT_ANGULAR'         || fill[0] == 'GRADIENT_DIAMOND')     {         const p0 = fill[1][0];         const p1 = fill[1][1];         const p2 = fill[1][2];          if (flipX)         {             p0.x = 1 - p0.x;             p1.x = 1 - p1.x;             p2.x = 1 - p2.x;         }          if (flipY)         {             p0.y = 1 - p0.y;             p1.y = 1 - p1.y;             p2.y = 1 - p2.y;         }     } }    function flipStrokeSides(sides, flipX, flipY) {     if (flipX) [sides[2], sides[3]] = [sides[3], sides[2]];     if (flipY) [sides[1], sides[4]] = [sides[4], sides[1]]; }    function flipRoundCorners(corners, flipX, flipY) {     if (flipX)     {         [corners[1], corners[2]] = [corners[2], corners[1]];         [corners[3], corners[4]] = [corners[4], corners[3]];     }      if (flipY)     {         [corners[1], corners[3]] = [corners[3], corners[1]];         [corners[2], corners[4]] = [corners[4], corners[2]];     } }


class h1846 extends t1847 {     x;     y;     width;     height;      round;            constructor(nodeId, objectId, objectName, x, y, width, height, round)     {         super(u1219, nodeId, objectId, objectName);                  this.x      = x;         this.y      = y;         this.width  = width;         this.height = height;          this.round  = round;          this.y3742(             x + width /2,              y + height/2);     }        copy()     {         const copy = new h1846(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.width,             this.height,                          this.round);           copy.x3359(this);           return copy;     }        r3633()     {         return z2025.fromObject(this);     }        a3741()     {         return [             ...super.a3741(),                  this.x,              this.y,              this.width,              this.height,               this.round * Math.abs(this.d3740)         ];     } } 


class p1842 extends t1847 {     x;     y;     width;        constructor(nodeId, objectId, objectName, x, y, width)     {         super(m1222, nodeId, objectId, objectName);                  this.x     = x;         this.y     = y;         this.width = width;                   this.y3742(             x + width/2,              y);     }        copy()     {         const copy = new p1842(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.width);           copy.x3359(this);           return copy;     }        r3633()     {         return c2020.fromObject(this);     }        a3741()     {         return [             ...super.a3741(),                  this.x,              this.y,              this.width         ];     } }


class y1840 extends t1847 {     x;     y;     width;     height;     round;      start;     sweep;     inner;            constructor(nodeId, objectId, objectName, x, y, width, height, round, start, sweep, inner)     {         super(p1225, nodeId, objectId, objectName);                  this.x      = x;         this.y      = y;         this.width  = width;         this.height = height;         this.round  = round;          this.start  = start;         this.sweep  = sweep;         this.inner  = inner;                   this.y3742(             x + width /2,              y + height/2);     }        copy()     {         const copy = new y1840(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.width,             this.height,             this.round,                          this.start,             this.sweep,             this.inner);           copy.x3359(this);           return copy;     }        r3633()     {         return v2012.fromObject(this);     }        a3741()     {         return [             ...super.a3741(),                  this.x,              this.y,              this.width,              this.height,              this.round,               this.start,              this.sweep,              this.inner         ];     } }


class o1853 extends t1847 {     x;     y;     width;     height;          points;      closed;     degree;     winding;       round;          r3746;     t4032;        constructor(nodeId, objectId, objectName, points, closed, degree, winding, round)     {         super(g1250, nodeId, objectId, objectName);                           this.points  = points.map(p => p.copy());             this.closed  = closed;         this.degree  = degree;         this.winding = winding;          this.round   = round;                   this.y3743();     }        copy()     {         const copy = new o1853(             this.nodeId,             this.objectId,             this.objectName,              this.points,              this.closed,             this.degree,             this.winding,              this.round);           copy.x          = this.x;         copy.y          = this.y;         copy.width      = this.width;         copy.height     = this.height;          copy.r3746 = [...this.r3746];         copy.t4032   = this.t4032;           copy.x3359(this);           return copy;     }        x3359(base)     {         super.x3359(base);          if (base.points) this.points = base.points.map(p => p.copy());     }        getBounds()     {         let bounds = s1047.NaN;           switch (this.degree)         {             case 0:                 for (const p of this.r3746)                     bounds = q3745(bounds, p);                  break;              case 1:                 {                     let i;                     for (i = 0; i < this.r3746.length-2; i += 2)                     {                         bounds = r3744(                             bounds,                              u864(                                 this.r3746[i  ],                                  this.r3746[i+1],                                 this.r3746[i+2]));                     }                      if (   this.closed                         && i < this.r3746.length-1)                     {                         bounds = r3744(                             bounds,                              u864(                                 this.r3746.at(-2),                                  this.r3746.at(-1),                                 this.r3746.at( 0)));                     }                      break;                 }             case 2:             case 3:             case 4:             case 5:                 {                     let i;                     for (i = 0; i < this.r3746.length-3; i += 3)                     {                         const b3 = c865(                             this.r3746[i  ],                              this.r3746[i+1],                             this.r3746[i+2],                             this.r3746[i+3]);                          bounds = r3744(                             bounds,                              b3);                     }                      if (   this.closed                         && i < this.r3746.length - 2)                     {                         const b3 = c865(                             this.r3746.at(-3),                              this.r3746.at(-2),                              this.r3746.at(-1),                             this.r3746.at( 0));                          bounds = r3744(                             bounds,                              b3);                     }                      break;                 }             default:                 console.error('invalid curve degree');         }           return bounds;     }        updatePoints(b4208, space)     {         for (let i = 0; i < this.points.length; i++)         {             let p      = this.points[i].q3747();             let smooth = this.points[i].smooth;              p = d3731(p, b4208, space);              this.points[i]        = q2023.fromPoint(this.nodeId, p);             this.points[i].smooth = smooth;         }     }        y3743()     {         switch (this.degree)         {         case 0: this.r3746 = this.points.map(p => p.q3747());                           break;         case 1: this.r3746 = this.points.map(p => p.q3747());                           break;         case 2: this.r3746 = this.points.map(p => p.q3747());                           break;         case 3: this.r3746 = c3753(this.points, this.closed, q4244); break;         case 4: this.r3746 = c3753(this.points, this.closed, y4245 ); break;         case 5: this.r3746 = c3753(this.points, this.closed, k4246 ); break;         }     }        f3749()     {         if (this.type == g1250)         {             const bounds = this.getBounds();              this.x      = bounds.x;             this.y      = bounds.y;             this.width  = bounds.width;             this.height = bounds.height;              this.c3730(this.x, this.y, this.width, this.height);         }          this.t4032 = z3748(this.r3746, this.closed, this.degree);     }        checkFlipped(flipX, flipY)     {         super.checkFlipped(flipX, flipY);           const bounds = this.getBounds();           for (const point of this.points)         {             if (flipX) point.x.value = bounds.width  - point.x.value;             if (flipY) point.y.value = bounds.height - point.y.value;         }          this.y3743();                                                   }        a3741()     {                  this.f3749();           const oldType = this.type;         this.type = g1250;          const data =          [             ...super.a3741(),                  this.x,              this.y,              this.width,              this.height,               this.t4032,              this.winding,              this.round * Math.abs(this.d3740)         ];          this.type = oldType;           return data;     }        r3633()     {         return g2037.fromObject(this);     } }    function z3748(points, closed, degree) {     for (const p of points)         if (   isNaN(p.x)             || isNaN(p.y))             return '';                   let t4032 = '';       switch (degree)     {     case 0: t4032 = w947   (points);         break;      case 1: t4032 = n3750(points, closed); break;      case 2:                                                              case 3:                                                              case 4:                                                              case 5: t4032 = s3751    (points, closed); break;      }       const j3752 =            degree == 0 && points.length > 2         || degree == 1 && points.length > 2         || degree == 2 && points.length > 3         || degree == 3 && points.length > 2         || degree == 4 && points.length > 2         || degree == 5 && points.length > 2;       if (   j3752         && (   closed             || x1019(points[0], points.at(-1))))         t4032 += ' Z';       return t4032; }    function n3750(points, closed) {     let t4032 = '';       if (points.length < 3)         return t4032;       t4032 += 'M';     t4032 += ' ' + a879(points[0].x);     t4032 += ' ' + a879(points[0].y);      let i;     for (i = 1; i < points.length-1; i += 2)     {         t4032 +=                ' Q'             + ' ' + a879(points[i  ].x)             + ' ' + a879(points[i  ].y)             + ' ' + a879(points[i+1].x)             + ' ' + a879(points[i+1].y);     }       if (   points.length - i == 1         && closed)     {         t4032 +=                ' Q'             + ' ' + a879(points.at(-1).x)             + ' ' + a879(points.at(-1).y)             + ' ' + a879(points.at( 0).x)             + ' ' + a879(points.at( 0).y);     }       return t4032; }    function s3751(points, closed) {     let t4032 = '';       if (points.length < 4)         return t4032;       t4032 += 'M';     t4032 += ' ' + a879(points[0].x);     t4032 += ' ' + a879(points[0].y);      let i;     for (i = 1; i < points.length-2; i += 3)     {         t4032 +=                ' C'             + ' ' + a879(points[i  ].x)             + ' ' + a879(points[i  ].y)             + ' ' + a879(points[i+1].x)             + ' ' + a879(points[i+1].y)             + ' ' + a879(points[i+2].x)             + ' ' + a879(points[i+2].y);     }       if (   points.length - i == 2         && closed)     {         t4032 +=                ' C'             + ' ' + a879(points.at(-2).x)             + ' ' + a879(points.at(-2).y)             + ' ' + a879(points.at(-1).x)             + ' ' + a879(points.at(-1).y)             + ' ' + a879(points.at( 0).x)             + ' ' + a879(points.at( 0).y);     }       return t4032; }    function c3753(points, closed, u3754) {     if (points.length < 2)         return '';       const bp = [];            let [pp, p, pn] = u3754(         closed ? points.at(-1) : points[0],          points[0],         points[1]);      bp.push(p);       let _pp = pn;            for (let i = 1; i < points.length; i++)     {         [pp, p, pn] = u3754(             points[i-1],              points[i],             i == points.length-1              ? (closed ? points[0] : points[i])             : points[i+1]);          if (points[i].smooth)             [pp, pn] = q3755(points[i], pp, p, pn);                      bp.push(_pp, pp, p);             _pp = pn;     }       if (bp.length > 3)     {         if (closed)         {             if (   equal(bp[0].x, bp.at(-1).x, 0.01)                 && equal(bp[0].y, bp.at(-1).y, 0.01))             {                                  [pp, p, pn] = u3754(                     points.at(-2),                      points.at( 0),                     points.at( 1));                  if (points[0].smooth)                     [pp, pn] = q3755(points[0], pp, p, pn);                  bp[1]           = pn;                 bp[bp.length-2] = pp;             }             else             {                                  [pp, p, pn] = u3754(                     points.at(-1),                      points.at( 0),                     points.at( 1));                  if (points[0].smooth)                     [pp, pn] = q3755(points[0], pp, p, pn);                  bp.push(_pp, pp, p);                  bp[1]           = pn;                 bp[bp.length-2] = pp;             }         }         else          {             bp[1]           = f895(bp[0],     l897(a886(x900(bp[2],     bp[0]    )), distv(bp[3],     bp[0]    )/3));             bp[bp.length-2] = f895(bp.at(-1), l897(a886(x900(bp.at(-3), bp.at(-1))), distv(bp.at(-4), bp.at(-1))/3));         }     }       return bp; }    function q3755(point, pp, p, pn) {     if (point.smooth)     {         const smooth = point.smooth.value;                  pp = f895(p, l897(x900(pp, p), smooth));         pn = f895(p, l897(x900(pn, p), smooth));     }      return [pp, pn]; }    function q4244(_pointP, _point, _pointN) {     const _pp = point(_pointP.x.value, _pointP.y.value);     let   _p  = point(_point .x.value, _point .y.value);     const _pn = point(_pointN.x.value, _pointN.y.value);       const v = x900(_pn, _pp);               let a = x887(         v883(x900(_p, _pp)),          v883(x900(_pn, _p)));               a = Math.abs(a);     while (a >= Tau/2) a -= Tau;       const k     = 4 * (Math.sqrt(2) - 1) / 3;        // or use the value 0.55191502449 from http://spencermortensen.com/articles/bezier-circle/
	const kCorr = 0.9993391093366649465402826439248;       let f =         a > Tau/4         ? 1/3 + (k*kCorr - 1/3) * Math.sin(a)         : 1/3 + (k*kCorr - 1/3) * (1 - Math.cos(a));           let pp = f895(_p, l897(a886(v), -j885(v)/2 * f));     let pn = f895(_p, l897(a886(v),  j885(v)/2 * f));      pp = a1020(pp);      _p = a1020(_p);      pn = a1020(pn);       return [pp, _p, pn]; }    function y4245(_pointP, _point, _pointN) {     const _pp = point(_pointP.x.value, _pointP.y.value);     const _p  = point(_point .x.value, _point .y.value);     const _pn = point(_pointN.x.value, _pointN.y.value);      const  pp = point(_p.x - (_p.x - _pp.x) * 0.3615, _p.y);     const  pn = point(_p.x + (_pn.x - _p.x) * 0.3615, _p.y);      return [pp, _p, pn]; }    function k4246(_pointP, _point, _pointN) {     const _pp = point(_pointP.x.value, _pointP.y.value);     const _p  = point(_point .x.value, _point .y.value);     const _pn = point(_pointN.x.value, _pointN.y.value);      const  pp = point(_p.x, _p.y - (_p.y - _pp.y) * 0.3615);     const  pn = point(_p.x, _p.y + (_pn.y - _p.y) * 0.3615);      return [pp, _p, pn]; }


class g1852 extends t1847 {     x;     y;     width;     height;          points;     edges;     regions;      networkData;        constructor(nodeId, objectId, objectName, points, edges, regions)     {         super(h1262, nodeId, objectId, objectName);                  this.points  = points .map(p => p.copy());         this.edges   = edges  .map(e => e.copy());         this.regions = regions.map(r => r.copy());           this.updateNetworkData();           let bounds = s1047.NaN;          for (let i = 0; i < this.edges.length; i++)         {             bounds = r3744(                 bounds,                  c865(                     this.edges[i].start.q3747(),                      this.edges[i].start.q3747(),                     this.edges[i].end  .q3747(),                     this.edges[i].end  .q3747()));         }          this.y3742(             bounds.x + bounds.width /2,                         bounds.y + bounds.height/2                     );     }        copy()     {         const copy = new g1852(             this.nodeId,             this.objectId,             this.objectName,              this.points,              this.edges,              this.regions);           copy.x      = this.x;         copy.y      = this.y;         copy.width  = this.width;         copy.height = this.height;           copy.x3359(this);           return copy;     }        updateNetworkData()     {         let minX = Number.MAX_SAFE_INTEGER;         let minY = Number.MAX_SAFE_INTEGER;         let maxX = Number.MIN_SAFE_INTEGER;         let maxY = Number.MIN_SAFE_INTEGER;          for (const p of this.points)         {             minX = Math.min(minX, p.x.value);             minY = Math.min(minY, p.y.value);             maxX = Math.max(maxX, p.x.value);             maxY = Math.max(maxY, p.y.value);         }           this.x      = minX;         this.y      = minY;         this.width  = maxX - minX;         this.height = maxY - minY;          this.c3730(this.x, this.y, this.width, this.height);           this.networkData = getNetworkData(this.points, this.edges, this.regions);     }        getBounds()     {         let bounds = s1047.NaN;          for (let i = 0; i < this.edges.length; i++)         {             const edge = this.edges[i];              const s  = edge.start;             const e  = edge.end;             let   st = edge.i3665;             let   et = edge.o3666;              if (!st.isValid()) st = s.copy();             if (!et.isValid()) et = e.copy();              bounds = r3744(                 bounds,                  c865(                     s .q3747(),                      st.q3747(),                     et.q3747(),                     e .q3747()));         }          return bounds;     }        r3633()     {         return g1852.fromObject(this);     }        a3741()     {         return [             ...super.a3741(),                  this.x,              this.y,              this.width,              this.height,               this.networkData         ];     } }    function getNetworkData(points, edges, _regions) {     const vertices = [];     const segments = [];     const regions  = [];       for (const point of points)     {         let join;         let cap;          switch (point.join.value)         {             case 0: join = 'MITER'; break;             case 1: join = 'BEVEL'; break;             case 2: join = 'ROUND'; break;         }              switch (point.cap.value)         {             case 0: cap = 'NONE';   break;             case 1: cap = 'SQUARE'; break;             case 2: cap = 'ROUND';  break;         }              vertices.push(         {             x:            point.x.value,             y:            point.y.value,             strokeJoin:   join,             strokeCap:    cap,             cornerRadius: point.round.value         });     }       for (const edge of edges)     {         segments.push(         {             start: points.findIndex(p => p.w3736 == edge.start.w3736),             end:   points.findIndex(p => p.w3736 == edge.end  .w3736)         });     }       for (const region of _regions)     {         const loops = [];          for (const _loop of region.loops.items)         {             const loop = [];              for (const _edge of _loop.items)                 loop.push(edges.findIndex(e => e.w3736 == _edge.w3736));              loops.push(loop);         }           regions.push(         {             windingRule: region.winding.value == 1 ? 'NONZERO' : 'EVENODD',             loops:       loops,             fills:       v956(region.fills)         });     }       let networkData =      {         vertices: vertices,         segments: segments,         regions:  regions     };       return networkData; }


class r1851 extends o1853 {     width;     height;      round;     bias;        constructor(nodeId, objectId, objectName, x, y, width, height, round, bias)     {         const tw = width * (1 + Math.min(0,  bias/100));         const bw = width * (1 + Math.min(0, -bias/100));                  const tx = x + (width - tw) / 2;         const bx = x + (width - bw) / 2;          const points =         [             q2023.create(nodeId, tx,      y         ),             q2023.create(nodeId, bx,      y + height),             q2023.create(nodeId, bx + bw, y + height),             q2023.create(nodeId, tx + tw, y         )         ];               super(             nodeId,              objectId,             objectName,              points,             1,              0,              0,              round);          this.type   = b1228;          this.x      = x;         this.y      = y;         this.width  = width;         this.height = height;          this.round  = round;         this.bias   = bias;                   this.y3742(             x + width /2,              y + height/2);     }        copy()     {         const copy = new r1851(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.width,             this.height,                          this.round,             this.bias);           copy.x3359(this);          copy.y3743();           return copy;     }        r3633()     {         return t2034.fromObject(this);     } } 


class t1845 extends t1847 {     x;     y;     width;     height;     round;     corners;        constructor(nodeId, objectId, objectName, x, y, width, height, round, corners)     {         super(h1237, nodeId, objectId, objectName);                  this.x       = x;         this.y       = y;         this.width   = width;         this.height  = height;          this.round   = round;         this.corners = corners;                   this.y3742(             x + width /2,              y + height/2);     }        copy()     {         const copy = new t1845(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.width,             this.height,                          this.round,             this.corners);           copy.x3359(this);           return copy;     }        r3633()     {         return x2024.fromObject(this);     }        a3741()     {         return [             ...super.a3741(),                  this.x,              this.y,              this.width,              this.height,               this.round * Math.abs(this.d3740),              this.corners         ];     } } 


class n1849 extends t1847 {     x;     y;     width;     height;      round;     points;     convex;        constructor(nodeId, objectId, objectName, x, y, width, height, round, points, convex)     {         super(j1240, nodeId, objectId, objectName);                  this.x      = x;         this.y      = y;         this.width  = width;         this.height = height;          this.round  = round;         this.points = points;         this.convex = convex;                   this.y3742(             x + width /2,              y + height/2);     }        copy()     {         const copy = new n1849(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.width,             this.height,              this.round,             this.points,             this.convex);          copy.x3359(this);          return copy;     }        r3633()     {         return y2030.fromObject(this);     }        a3741()     {         return [             ...super.a3741(),                  this.x,              this.y,              this.width,              this.height,               this.round * Math.abs(this.d3740),              this.points,              this.convex         ];     } } 


class s1850 extends t1847 {     text;          x;     y;     width;     height;          x3757;     y3758;          font;     size;     style;          alignX;     alignY;          lineHeight;     letterSpacing;        constructor(nodeId, objectId, objectName, text, x, y, width, height, font, size, style, alignX, alignY, lineHeight, letterSpacing)     {         super(k1243, nodeId, objectId, objectName);                  this.text          = text;              this.x             = x;         this.y             = y;         this.width         = width;         this.height        = height;              this.x3757      = width;         this.y3758     = height;              this.font          = font;         this.size          = size;         this.style         = style;              this.alignX        = alignX;         this.alignY        = alignY;              this.lineHeight    = lineHeight;         this.letterSpacing = letterSpacing;                   this.y3742(             x + width /2,              y + height/2);     }        copy()     {         const copy = new s1850(             this.nodeId,             this.objectId,             this.objectName,                  this.text,                  this.x,             this.y,             this.width,             this.height,                  this.font,             this.size,             this.style,                  this.alignX,             this.alignY,                  this.lineHeight,             this.letterSpacing);           copy.x3757  = this.x3757;         copy.y3758 = this.y3758;           copy.x3359(this);           return copy;     }        r3633()     {         return y2032.fromObject(this);     }        b3756()     {         return {             ...super.b3756(),                 x:             this.x,             y:             this.y,             width:         this.width,             height:        this.height,              x3757:      this.x3757,             y3758:     this.y3758,              text:          this.text,              font:          this.font,             size:          this.size,             style:         this.style,              alignX:        this.alignX,             alignY:        this.alignY,                          lineHeight:    this.lineHeight,             letterSpacing: this.letterSpacing         };     }        a3741()     {         return [             ...super.a3741(),                  this.x,              this.y,              this.width,              this.height,                           this.x3757,              this.y3758,                           this.text,               this.font,              this.size,              this.style,                           this.alignX,              this.alignY,                           this.lineHeight,              this.letterSpacing         ];     } } 


class w1844 extends t1847 {     x;     y;     smooth;        constructor(nodeId, objectId, objectName, x, y, smooth = 1, l3739 = false, isCenter = false, isXform = false)     {         super(t1246, nodeId, objectId, objectName, l3739, isXform);                  this.x        = x;         this.y        = y;         this.smooth   = smooth;         this.isCenter = isCenter;                   this.y3742(x, y);          this.f4098(x, y);     }        copy()     {         const copy = new w1844(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.smooth,             this.l3739,             this.isCenter);          copy.x3359(this);          return copy;     }        getBounds()     {         return new s1047(             this.x - 0.005,              this.y - 0.005,              0.01,              0.01);     }        checkFlipped(flipX, flipY)     {      }        q3747()     {         return point(this.x, this.y);     }        r3633()     {         return q2023.fromObject(this);     }        a3741()     {         return [             ...super.a3741(),                  this.x,              this.y         ];     } } 


class n1838 extends t1847 {     operation;      children;        constructor(nodeId, objectId, objectName, operation, children = [])     {         super(c1286, nodeId, objectId, objectName);                  this.operation = operation;                  this.children  = children.map(c => c.copy());     }        copy()     {         const copy = new n1838(             this.nodeId,             this.objectId,             this.objectName,              this.operation,             this.children);          copy.x3359(this);                  return copy;     }        getBounds()     {         return getObjBounds(this.children);     }        z4099(b4208, affectSpace)     {         for (const v111 of this.children)             v111.z4099(b4208, affectSpace);     }        b3756()     {         return {             ...super.b3756(),                 operation: this.operation,             children:  this.children         };     }        a3741()     {         return [             ...super.a3741(),                  this.children.map(o => o.a3741()),              this.operation         ];     } }


class FigmaArcPath extends o1853 {     position;                          start;     sweep;            constructor(nodeId, objectId, objectName, pos, x, y, width, height, start, sweep)     {         let points = makeArc_(             point(                 x + width /2,                  y + height/2),              width/2,               start,              start + sweep);                      points = points.map(p => q2023.fromPoint(nodeId, p));           points.forEach(p =>          {             p.y.value =                  pos > 0                 ? p.y.value * height/nozero(width)                 : height/2 + (p.y.value - height/2) * height/nozero(width);              if (   pos == 0                 && width < 0)                  p.x.value += width;         });          if (width  < 0) width  *= -1;         if (height < 0) height *= -1;           super(             nodeId,              objectId,             objectName,             points,             0,               2,               0,               0);                    this.position = pos;         this.x       = x;         this.y       = y;         this.width   = width;         this.height  = height;          this.start    = start;         this.sweep    = sweep;           this.y3742(             x + width /2,             y + height/2);     }        copy()     {         const copy = new FigmaArcPath(             this.nodeId,             this.objectId,             this.objectName,              this.position,             this.x,             this.y,             this.width,             this.height,                          this.start,             this.sweep);           copy.r3746 = [...this.r3746];         copy.t4032   = this.t4032;          copy.x3359(this);           return copy;     } }


class FigmaWavePath extends o1853 {     shape;     _x;     _y;     k3073;     amplitude;     frequency;     offset;     alignX;     alignY;            constructor(nodeId, objectId, objectName, shape, x, y, width, amplitude, frequency, offset, alignX, alignY)     {         let points = makeWave(             shape,              x,             y,             width,              amplitude,              frequency,             offset,             alignX,             alignY);          points = points.map(p => q2023.fromPoint(nodeId, p));           super(             nodeId,              objectId,             objectName,             points,             0,                               shape == 4 ? 2 : 0,              0,                               0);                                    this.shape     = shape;         this._x        = x;         this._y        = y;         this.k3073    = width;         this.amplitude = amplitude;         this.frequency = frequency;         this.offset    = offset;         this.alignX    = alignX;         this.alignY    = alignY;           let height = amplitude;                  this.y3742(             x + width /2,             y + height/2);     }        copy()     {         const copy = new FigmaWavePath(             this.nodeId,             this.objectId,             this.objectName,              this.shape,             this._x,             this._y,             this.k3073,             this.amplitude,             this.frequency,             this.offset,             this.alignX,             this.alignY);           copy.r3746 = [...this.r3746];         copy.t4032   = this.t4032;          copy.x3359(this);           return copy;     } }


class k1848 extends t1847 {     children;        constructor(nodeId, objectId, objectName, children = [])     {         super(m1265, nodeId, objectId, objectName);                  this.children = children.map(c => c.copy());     }        copy()     {         const copy = new k1848(             this.nodeId,             this.objectId,             this.objectName,              this.children);          copy.x3359(this);          return copy;     }        getCount()     {         let t3334 =             this.children.length > 0             ? super.getCount()             : 0;          for (const v111 of this.children)             t3334 += v111.getCount();          return t3334;     }        y3742(cx = 0, cy = 0)     {         super.y3742(cx, cy);          for (const v111 of this.children)             v111.y3742(cx, cy);     }        resetSpace(bounds, singlePoint = false, cx = 0.5, cy = 0.5, units = 0)     {         super.resetSpace(bounds, false, cx, cy, units);          for (const v111 of this.children)             v111.resetSpace(bounds, false, cx, cy, units);     }        getBounds()     {         return getObjBounds(this.children);     }        z4099(b4208, affectSpace)     {         for (const v111 of this.children)             v111.z4099(b4208, affectSpace);     }        b3756()     {         return {             ...super.b3756(),                 children: this.children         };     }        a3741()     {         return [             ...super.a3741(),                  this.children.map(o => o.a3741())         ];     } }


class f1841 extends t1847 {     x;     y;     width;     height;      round;          clip;      children;        constructor(nodeId, objectId, objectName, x, y, width, height, round, clip, children = [])     {         super(y1268, nodeId, objectId, objectName);                  this.x        = x;         this.y        = y;         this.width    = width;         this.height   = height;              this.round    = round;          this.clip     = clip;              this.children = children.map(c => c.copy());          this.y3742(             x + width /2,              y + height/2);     }        copy()     {         const copy = new f1841(             this.nodeId,             this.objectId,             this.objectName,                  this.x,             this.y,             this.width,             this.height,                  this.round,                this.clip,                  this.children);           copy.x3359(this);           return copy;     }        getCount()     {         let t3334 = super.getCount();          for (const v111 of this.children)             t3334 += v111.getCount();          return t3334;     }            checkFlipped(flipX, flipY)     {         super.checkFlipped(flipX, flipY);          for (const v111 of this.children)         {             v111.checkFlipped(flipX, flipY);              if (flipX)             {                 v111.xp0.x = this.width - v111.xp0.x;                 v111.xp1.x = this.width - v111.xp1.x;                 v111.xp2.x = this.width - v111.xp2.x;             }              if (flipY)             {                 v111.xp0.y = this.height - v111.xp0.y;                 v111.xp1.y = this.height - v111.xp1.y;                 v111.xp2.y = this.height - v111.xp2.y;             }         }     }        b3756()     {         return {             ...super.b3756(),                 x:        this.x,             y:        this.y,             width:    this.width,             height:   this.height,                      round:    this.round,              clip:     this.clip,                      children: this.children         };     }        a3741()     {         return [             ...super.a3741(),                  this.x,              this.y,              this.width,              this.height,               this.round,               this.clip,               this.children.map(o => o.a3741())         ];     } }    


class p1839 {     type;          nodeId = '';      styleId;     styleName;      paints = [];          constructor(nodeId, styleId, styleName)     {         this.type      = l1216;         this.nodeId    = nodeId;          this.styleId   = styleId;         this.styleName = styleName;     }        copy()     {         const copy = new p1839(this.nodeId, this.styleId, this.styleName);            return copy;     }        a3741()     {         return [          this.type,          this.nodeId,           this.styleId,          this.styleName,                   this.paints         ];     } }


class s2042 {     static nextUniqueId = 0;      type;       valid;       listId           = -1;     w3736;      cached           = true;     unknown          = false;      b3821           = NULL;      currentIteration = 0;     iterated         = false;       y3096     = null;        constructor(type, options)      {         this.type    = type;          if (options && options.cached ) this.cached  = options.cached;         if (options && options.unknown) this.unknown = options.unknown;               this.w3736 = s2042.nextUniqueId++;     }        reset()     {                                                                                   this.y3096 = null;     }        copy()     {         h953('abstract type s2042 cannot be copied');         return null;     }        x3359(base)     {                  this.w3736 = base.w3736;     }        s3768()     {         if (    this.input             &&  this.input.s3768             && !this.input.notCondition)             return this.input.s3768();                  return this;     }            r3633()     {         return null;     }        toString()      {          return this.type;      }        b2119()     {         return this.toString();     }        isValid()      {         return false;     }            validate()     {         this.valid = true;     }        invalidate()     {         this.valid = false;     }        c4088(parse)     {      }        t4089(parse, from, force = false)     {         if (   this.unknown             || force)             this.valid = false;          return true;     }        o3629(parse, nodeId)     {      }        c3630(parse, nodeId)     {      }        c4087(parse)     {      }        r3632(parse, nodeId)     {      }     } 


class w2050  {     type;     valueId;      customParams = [];       objects      = null;        constructor(type)      {                   this.type    = type;          this.valueId = '';     }        reset() {}        copy()     {         h953('abstract class w2050 cannot be copied');         return null;     }        x3359(base)     {                           this.valueId  = base.valueId;         this.w3736 = base.w3736;          this.g3626(base);          if (base.objects)             this.b3627(base.objects);     }        g3626(base)     {         for (const param of base.customParams)             this.customParams.push([param[0], param[1].copy()]);     }        b3627(objects)     {         this.objects = objects.map(o => o.copy());     }                               y3712()     {         return false;     }        r3633()     {         return this.copy();     }        b2119()      {          return this.toString();      }        toString()      {          return this.type;      }        v3706()     {         return this.toString();     }        q2847(gen)     {         h953('invalid abstract method');         return '';     }        d3358()     {         h953('invalid abstract method');         return null;     }        isCached()     {         return true;     }        c4088(parse)              {}     t4089(parse, from, force) {}     c4087     (parse)              {} }    function p3837(type, value) {     switch (type)     {         case            x1087: return parseNullValue         (value)[0];          case           q1056:          case    b1057:          case      b1058:          case     o1059: return y3482         (value)[0];          case         c1091: return c2850       (value)[0];         case           g1143: return y2865         (value)[0];         case          d1168: return a2866        (value)[0];          case           i1178: return w3677         (value)[0];         case     b1184: return w2867    (value)[0];         case       x1187: return w3676     (value)[0];         case         c1181: return f3832       (value)[0];         case    u1196: return i3833   (value)[0];         case   c1199: return f3834  (value)[0];         case     u1202: return k3835    (value)[0];         case      n1205: return x3707     (value)[0];         case    x1211: return n3708   (value)[0];         case     d1208: return o3709    (value)[0];          case      y1218: return t3711    (value)[0];         case           t1221: return e3822         (value)[0];         case        u1224: return u3823      (value)[0];         case        q1227: return t3824      (value)[0];         case        i1236: return l3825      (value)[0];         case           o1239: return j3826         (value)[0];         case     t1242: return i3827    (value)[0];         case          i1245: return s3828        (value)[0];         case    m1249: return r3670   (value)[0];         case  p1252: return a3669 (value)[0];         case    h1255: return b3667   (value)[0];         case  g1258: return v3664 (value)[0];         case w1261: return q3663(value)[0];         case  m1287: return l3829 (value)[0];         case    n1264: return w3830   (value)[0];         case       r1231: return parseArcPathValue      (value)[0];         case      y1234: return parseWavePathValue     (value)[0];         case          r1267: return u3831        (value)[0];                  default:              console.error('unknown type \'' + type + '\'');             console.log('value =', value);             return null;     } }    function t4210(type, value) {     if (   type == c1091         && value.indexOf(',') < 0)         return value;       switch (type)     {         case            x1087: return parseNullValue         (value)[0].v3706();         case           q1056: return y3482         (value)[0].v3706();          case         c1091: return c2850       (value)[0].v3706();         case           g1143: const val = y2865    (value)[0]; return val == '' ? '\'\'' : val.v3706();         case          d1168: return a2866        (value)[0].v3706();         case           i1178: return w3677         (value)[0].v3706();         case     b1184: return w2867    (value)[0].v3706();         case       x1187: return w3676     (value)[0].v3706();         case         c1181: return f3832       (value)[0].v3706();         case    u1196: return i3833   (value)[0].v3706();         case   c1199: return f3834  (value)[0].v3706();         case     u1202: return k3835    (value)[0].v3706();         case      n1205: return x3707     (value)[0].v3706();         case    x1211: return n3708   (value)[0].v3706();         case     d1208: return o3709    (value)[0].v3706();          case      y1218: return t3711    (value)[0].v3706();         case           t1221: return e3822         (value)[0].v3706();         case        u1224: return u3823      (value)[0].v3706();         case        q1227: return t3824      (value)[0].v3706();         case        i1236: return l3825      (value)[0].v3706();         case           o1239: return j3826         (value)[0].v3706();         case     t1242: return i3827    (value)[0].v3706();         case          i1245: return s3828        (value)[0].v3706();         case    m1249: return r3670   (value)[0].v3706();         case  p1252: return a3669 (value)[0].v3706();         case    h1255: return b3667   (value)[0].v3706();         case  g1258: return v3664 (value)[0].v3706();         case w1261: return q3663(value)[0].v3706();         case  m1287: return l3829 (value)[0].v3706();         case    n1264: return w3830   (value)[0].v3706();         case          r1267: return u3831        (value)[0].v3706();     }       h953('cannot display value of type \'' + type + '\''); }    function nanFromType(type) {     switch (type)     {         case            q1056: return          d2021.NaN;          case          c1091: return        y2022.NaN;         case            g1143: return        new c2033();         case           d1168: return         h2010.NaN;         case            i1178: return          c2013.NaN;         case      b1184: return     o2009.NaN;         case        x1187: return      m2015.NaN;         case          c1181: return        m2031.NaN;         case     u1196: return    n2011.NaN;         case    c1199: return   k2016.NaN;         case      u1202: return     m2018.NaN;         case       n1205: return      f2008.NaN;         case     x1211: return    t2017.NaN;         case      d1208: return     k2019.NaN;          case       y1218: return     z2025.NaN;         case            t1221: return          c2020.NaN;         case         u1224: return       v2012.NaN;         case         i1236: return       x2024.NaN;         case            o1239: return          y2030.NaN;         case      t1242: return     y2032.NaN;         case           i1245: return         q2023.NaN;         case     m1249: return    g2037.NaN;         case   p1252: return  d2039.NaN;         case     h1255: return    l2035.NaN;         case   g1258: return  z2038.NaN;         case  w1261: return q2036.NaN;         case   m1287: return  w2027.NaN;         case     n1264: return    p2028.NaN;         case           r1267: return         z2014.NaN;     }      h953('cannot determine null value from type \'' + type + '\''); }


class z2043 extends s2042 {     nodeId;     nodeName;      topLevel;      value;          customParams = [];      options      = {};     y3096 = [];               constructor(type, nodeId, options)     {         super(type, options);          this.nodeId   = nodeId;         this.nodeName = options.nodeName;          this.options  = clone(options);          this.valid    = false;         this.topLevel = false;          this.value    = null;     }        reset()     {         this.customParams = [];         this.options      = {};         this.y3096 = [];     }        x3359(base)     {         super.x3359(base);                  this.nodeId   = base.nodeId;         this.nodeName = base.nodeName;          this.g3626(base);          this.options  = clone(base.options);          this.valid    = base.valid;         this.topLevel = base.topLevel;          if (base.value) this.value = base.value.copy();     }        g3626(base)     {         for (const param of base.customParams)             this.customParams.push([param[0], param[1].copy()]);     }        p4242(h2992)     {         return h2992 == 'value'             ?  this.value             :  this[h2992];     }        isCached()     {         return this.options.cached             && this.valid;     }        async eval(parse)     {                   return this;     }        async x4100(parse)     {      }        b3627(value, listId = -1)     {         const objects = q3628(value);         const copies  = [];                                  for (let i = 0; i < objects.length; i++)         {             const v111 = f3738(objects[i]);                  v111.nodeId   = this.nodeId;             v111.listId   = listId;                          v111.objectId = v111.objectId + l967 + this.nodeId;                  copies.push(v111);         }          return copies;     }                outputType()     {         return this.value             ? new c2033(                 n957(this.value.type)                 ? h3479(this.value.items)                 : this.value.type)             : new c2033(x1087);     }        outputListType()     {         return this.outputType();                                }        r3633()     {         return this.value              ? this.value.copy()              : null;     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.unknown)             this.valid = false;          this.iterated = false;     }        o3629(parse, nodeId)     {         this.b3821           = nodeId;         this.currentIteration = 0;     }        c3630(parse, nodeId)     {         this.valid = false;     }        c4087(parse)     {         const s3631 = parse.repeats.findIndex(r => r.repeatId == this.b3821);                                                                if (   (   s3631 < 0                 || s3631 == parse.repeats.length-1)             && !this.iterated)         {                          this.currentIteration++;             this.iterated = true;         }     }        iterateCache(parse, from)     {      }        r3632(parse, nodeId)     {         this.valid            = false;         this.currentIteration = 0;     }            j4101(parse, values, add = false)     {         if (    parse.repeats.length == 0             ||  this.unknown && parse.repeats[0].total == 0             || !this.unknown             ||  parse.repeats.at(-1).currentIteration == 0             ||  parse.repeats.at(-1).currentIteration == parse.repeats.at(-1).total-1)         {             if (add) this.y3096.push(...values);             else     this.y3096 = [...values];         }         else if (!add)             this.y3096 = [];     }        c4088(parse)     {                 if (!this.y3096)             return;          for (const value of this.y3096)             i2062(parse, this.nodeId, value[0], value[1]);                   this.y3096 = [];     }        t4216()     {         if (   !this.value             || !this.value.objects)             return;           for (let i = 0; i < this.value.objects.length; i++)         {             const v111     = this.value.objects[i];              v111.nodeId    = this.nodeId;             v111.objectId += l967 + this.nodeId;             v111.listId    = -1;         }     }                                                                           setConditionInput(input)     {      } }    async function evalValue(_value, parse, nan = () => new u4217()) {     let value =          _value          ? (await _value.eval(parse)).r3633()          : null;      if (    value          && !value.isValid()         && nan)          value = nan();      return value; }    async function evalNumberValue        (_value, parse) { return await evalValue(_value, parse, () => y2022        .NaN.copy()); } async function evalTextValue          (_value, parse) { return await evalValue(_value, parse, () => new c2033());                }  async function evalColorValue         (_value, parse) { return await evalValue(_value, parse, () => h2010         .NaN.copy()); } async function evalFillValue          (_value, parse) { return await evalValue(_value, parse, () => c2013          .NaN.copy()); } async function evalStrokeValue        (_value, parse) { return await evalValue(_value, parse, () => m2031        .NaN.copy()); } async function evalColorStopValue     (_value, parse) { return await evalValue(_value, parse, () => o2009     .NaN.copy()); } async function evalGradientValue      (_value, parse) { return await evalValue(_value, parse, () => m2015      .NaN.copy()); }  async function evalListValue          (_value, parse) { return await evalValue(_value, parse, () => d2021          .NaN.copy()); }  async function evalRectangleValue     (_value, parse) { return await evalValue(_value, parse, () => z2025     .NaN.copy()); } async function evalLineValue          (_value, parse) { return await evalValue(_value, parse, () => c2020          .NaN.copy()); } async function evalPolygonValue       (_value, parse) { return await evalValue(_value, parse, () => x2024       .NaN.copy()); } async function evalTextShapeValue     (_value, parse) { return await evalValue(_value, parse, () => y2032     .NaN.copy()); }  async function evalPointValue         (_value, parse) { return await evalValue(_value, parse, () => q2023         .NaN.copy()); } async function evalVectorPathValue    (_value, parse) { return await evalValue(_value, parse, () => g2037    .NaN.copy()); } async function evalArcPathValue       (_value, parse) { return await evalValue(_value, parse, () => ArcPathValue       .NaN.copy()); } async function evalWavePathValue      (_value, parse) { return await evalValue(_value, parse, () => WavePathValue      .NaN.copy()); } async function evalVectorVertexValue  (_value, parse) { return await evalValue(_value, parse, () => d2039  .NaN.copy()); } async function evalVectorEdgeValue    (_value, parse) { return await evalValue(_value, parse, () => l2035    .NaN.copy()); } async function evalVectorRegionValue  (_value, parse) { return await evalValue(_value, parse, () => z2038  .NaN.copy()); }  async function evalFrameValue         (_value, parse) { return await evalValue(_value, parse, () => z2014         .NaN.copy()); }  async function evalInnerShadowValue   (_value, parse) { return await evalValue(_value, parse, () => k2016   .NaN.copy()); } async function evalLayerBlurValue     (_value, parse) { return await evalValue(_value, parse, () => m2018     .NaN.copy()); } async function evalStrokeSidesValue   (_value, parse) { return await evalValue(_value, parse, () => y4272   .NaN.copy()); } async function evalRoundedCornersValue(_value, parse) { return await evalValue(_value, parse, () => RoundedCornersValue.NaN.copy()); } 


class r2044 extends z2043 {     input = null;        reset()     {         super.reset();          this.input = null;     }        x3359(base)     {         super.x3359(base);          if (base.input) this.input = base.input.copy();     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        isValid()     {         return this.input && this.input.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.input) this.input.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.input) this.input.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.input) this.input.c4087(parse);     }        s3768()     {         if (    this.input             &&  this.input.s3768             && !this.input.notCondition)             return this.input.s3768();                  return this;     }        setConditionInput(input)     {         this.input = input;     } }


class u2045 extends z2043 {     l4083 = null;     m4084 = null;        reset()     {         super.reset();          this.l4083 = null;         this.m4084 = null;     }        x3359(base)     {         super.x3359(base);          if (base.l4083) this.l4083 = base.l4083.copy();         if (base.m4084) this.m4084 = base.m4084.copy();     }        isCached()     {         return super.isCached()             && (!this.l4083 || this.l4083.isCached())             && (!this.m4084 || this.m4084.isCached());     }        g4090(node)     {         return this.l4083 && this.l4083.nodeId == node.nodeId             || this.m4084 && this.m4084.nodeId == node.nodeId;     }        isValid()     {         return this.l4083 && this.l4083.isValid()             && this.m4084 && this.m4084.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.l4083) this.l4083.c4088(parse);         if (this.m4084) this.m4084.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.l4083) this.l4083.t4089(parse, from, force);         if (this.m4084) this.m4084.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.l4083) this.l4083.c4087(parse);         if (this.m4084) this.m4084.c4087(parse);     }        s3768()     {         if (    this.l4083             &&  this.l4083.s3768             && !this.l4083.notCondition)             return this.l4083.s3768();                  else if (this.m4084              &&  this.m4084.s3768              && !this.m4084.notCondition)             return this.m4084.s3768();                  return this;     } }


class w2046 extends z2043 {     l4083 = null;     m4084 = null;     e4085 = null;        reset()     {         super.reset();          this.l4083 = null;         this.m4084 = null;         this.e4085 = null;     }        x3359(base)     {         super.x3359(base);          if (base.l4083) this.l4083 = base.l4083.copy();         if (base.m4084) this.m4084 = base.m4084.copy();         if (base.e4085) this.e4085 = base.e4085.copy();     }        isCached()     {         return super.isCached()             && (!this.l4083 || this.l4083.isCached())             && (!this.m4084 || this.m4084.isCached())             && (!this.e4085 || this.e4085.isCached());     }        g4090(node)     {         return this.l4083 && this.l4083.nodeId == node.nodeId             || this.m4084 && this.m4084.nodeId == node.nodeId             || this.e4085 && this.e4085.nodeId == node.nodeId;     }        isValid()     {         return this.l4083 && this.l4083.isValid()             && this.m4084 && this.m4084.isValid()             && this.e4085 && this.e4085.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.l4083) this.l4083.c4088(parse);         if (this.m4084) this.m4084.c4088(parse);         if (this.e4085) this.e4085.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.l4083) this.l4083.t4089(parse, from, force);         if (this.m4084) this.m4084.t4089(parse, from, force);         if (this.e4085) this.e4085.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.l4083) this.l4083.c4087(parse);         if (this.m4084) this.m4084.c4087(parse);         if (this.e4085) this.e4085.c4087(parse);     }        s3768()     {         if (    this.l4083             &&  this.l4083.s3768             && !this.l4083.notCondition)             return this.l4083.s3768();                  else if (this.m4084              &&  this.m4084.s3768              && !this.m4084.notCondition)             return this.m4084.s3768();                  else if (this.e4085              &&  this.e4085.s3768              && !this.e4085.notCondition)             return this.e4085.s3768();                  return this;     } }


class l2047 extends z2043 {     l4083 = null;     m4084 = null;     e4085 = null;     l4086 = null;        reset()     {         super.reset();          this.l4083 = null;         this.m4084 = null;         this.e4085 = null;         this.l4086 = null;     }        x3359(base)     {         super.x3359(base);          if (base.l4083) this.l4083 = base.l4083.copy();         if (base.m4084) this.m4084 = base.m4084.copy();         if (base.e4085) this.e4085 = base.e4085.copy();         if (base.l4086) this.l4086 = base.l4086.copy();     }        isCached()     {         return super.isCached()             && (!this.l4083 || this.l4083.isCached())             && (!this.m4084 || this.m4084.isCached())             && (!this.e4085 || this.e4085.isCached())             && (!this.l4086 || this.l4086.isCached());     }        g4090(node)     {         return this.l4083 && this.l4083.nodeId == node.nodeId             || this.m4084 && this.m4084.nodeId == node.nodeId             || this.e4085 && this.e4085.nodeId == node.nodeId             || this.l4086 && this.l4086.nodeId == node.nodeId;     }        isValid()     {         return this.l4083 && this.l4083.isValid()             && this.m4084 && this.m4084.isValid()             && this.e4085 && this.e4085.isValid()             && this.l4086 && this.l4086.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.l4083) this.l4083.c4088(parse);         if (this.m4084) this.m4084.c4088(parse);         if (this.e4085) this.e4085.c4088(parse);         if (this.l4086) this.l4086.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.l4083) this.l4083.t4089(parse, from, force);         if (this.m4084) this.m4084.t4089(parse, from, force);         if (this.e4085) this.e4085.t4089(parse, from, force);         if (this.l4086) this.l4086.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.l4083) this.l4083.c4087(parse);         if (this.m4084) this.m4084.c4087(parse);         if (this.e4085) this.e4085.c4087(parse);         if (this.l4086) this.l4086.c4087(parse);     }        s3768()     {         if (    this.l4083             &&  this.l4083.s3768             && !this.l4083.notCondition)             return this.l4083.s3768();                  else if (this.m4084              &&  this.m4084.s3768              && !this.m4084.notCondition)             return this.m4084.s3768();                  else if (this.e4085              &&  this.e4085.s3768              && !this.e4085.notCondition)             return this.e4085.s3768();                  else if (this.l4086              &&  this.l4086.s3768              && !this.l4086.notCondition)             return this.l4086.s3768();                  return this;     } }


class m2049 extends z2043 {     h2992;          node;     param;            constructor(nodeId, h2992)     {         super(PARAM, nodeId, false);          this.h2992 = h2992;     }        reset()     {         if (this.node)             this.node.reset();     }        copy()     {         const copy = new m2049(this.nodeId, this.h2992);          copy.x3359(this);          copy.node = this.node;              return copy;     }        s3768()     {         return this.node              ? this.node.s3768()              : null;     }        async eval(parse)     {         this.node = parse.g4243.find(v => v.nodeId == this.nodeId);         x952(this.node, 'can\'t find parameter node \'' + this.nodeId + '\'');           if (    this.node.type != j1080             || !this.node.h4212)             await this.node.eval(parse);           this.param = this.node.p4242(this.h2992);           if (isValid(this.param))         {             if (   this.node.type != q1063                 && this.h2992 != 'from')                 this.value = await evalValue(this.param, parse);             else                 this.value = new u4217();                               return this.value                  ? this.value.copy()                  : null;         }         else             return this.value = new u4217();     }        isCached()     {         return super.isCached();      }        r3633()     {         return this.value.copy();     }        c4088(parse)     {         super.c4088(parse);          if (this.node) this.node.c4088(parse);     }            t4089(parse, from, force)     {         super.t4089(parse, from, force);                  if (this.node) this.node.t4089(parse, from, force);     }        o3629(parse, nodeId)     {         const node = parse.g4243.find(n => n.nodeId == this.nodeId);                  node.o3629(parse, nodeId);     }        iterateCache(parse, from)     {         const node = parse.g4243.find(n => n.nodeId == this.nodeId);                   node.iterateCache(parse, from);     }        c3630(parse, nodeId)     {         const node = parse.g4243.find(n => n.nodeId == this.nodeId);                  node.c3630(parse, nodeId);     }        o3629(parse, nodeId)     {         const node = parse.g4243.find(n => n.nodeId == this.nodeId);                  node.o3629(parse, nodeId);     }        c4087(parse)     {         const node = parse.g4243.find(n => n.nodeId == this.nodeId);                  node.c4087(parse);     }        r3632(parse, nodeId)     {         const node = parse.g4243.find(n => n.nodeId == this.nodeId);                  node.r3632(parse, nodeId);     }                                                                                                                                                                                                 }


class u4217 extends w2050 {     value;        constructor()     {         super(x1087);          this.value = null;     }        copy()     {         const copy = new u4217();          copy.x3359(this);          return copy;     }        equals(_null)     {         return _null             && this.type  == _null.type             && this.value == _null.value;     }        async eval(parse)     {         return this;     }        y3712()     {         return true;     }        isValid()     {         return false;     }        r3633()     {         return this.copy();     }        b2119()      {          return this.toString();      }        toString()     {         return '';     }        u3705()     {         return 'NULL';     }        v3706()     {         return 'NULL';     }        q2847(gen)     {         return this.u3705();     }        d3358()     {         return this;     } }    function parseNullValue(str) {     const _null = new u4217();      return [_null, 1]; } 


class d2021 extends w2050 {     items;      condensed = false;        constructor(items = [])     {         super(q1056);          if (items)         {             this.items = [];              for (const item of items)             {                 this.items.push(item.copy());                  if (   this.objects                     && item.objects)                     this.objects.push(...item.objects.map(o => o.copy()));             }         }     }        copy()     {         const copy = new d2021(this.items);          copy.x3359(this);          copy.condensed = this.condensed;          return copy;     }        equals(list)     {         if (!list)                                  return false;         if (!(list instanceof d2021))           return false;         if (this.items.length != list.items.length) return false;                      for (let i = 0; i < this.items.length; i++)             if (!this.items[i].equals(list.items[i]))                 return false;          return true;     }        async eval(parse)     {         return this.copy();     }        r3633()     {         return this.copy();     }        y3712()     {         if (!this.items)             return false;                      for (const item of this.items)             if (!item.y3712())                 return false;          return true;     }        isValid()     {                  return  this.items;              }        b2119()     {         if (!this.items)             return '';           let str = '';                           str += this.items.length;          for (let i = 0; i < this.items.length; i++)         {             const item = this.items[i];              str += ' ' + item.type + ' ';             str += item.b2119();         }           return str;     }        toString()     {         if (!this.items)             return '';           let str = '';                           str += this.items.length;          for (let i = 0; i < this.items.length; i++)         {             const item = this.items[i];              str += ' ' + item.type + ' ';             str += item.toString();         }           return str;     }        u3705()     {         if (!this.items)             return '';           const nItems = Math.min(this.items.length, 10);           let str = '';          for (let i = 0; i < nItems; i++)         {             if (i > 0)                  str += '<br/>';               const item = this.items[i];              if (n957(item.type))                              {                 for (let j = 0; j < item.items.length; j++)                 {                     if (j > 0)                          str += ', ';                                          str += item.items[j].u3705();                 }             }             else                 str += item.u3705();         }          if (this.items.length > 10)              str += '<br/>. . .';                  return str;     }        v3706()     {         if (!this.items)             return '';           let str = '';                           str += this.items.length;          for (let i = 0; i < this.items.length; i++)         {             const item = this.items[i];              str += ' ' + item.type + ' ';             str += item.v3706();         }           return str;     }        d3358()     {         return d2021.NaN.copy();     }        static NaN = Object.freeze(new d2021(null)); }    function y3482(str, i = -1) {     if (i < 0)     {         str = str.split(' ');         i   = 0;     }                   const m3769  = i;     const a4209 = parseInt(str[i++]);               const list = new d2021();       for (let j = 0; j < a4209; j++)     {         const type = str[i++];          switch (type)         {             case          q1056:               case   b1057:               case     b1058:               case    o1059: { const _list   = y3482        (str, i);  i += _list  [1];  list.items.push(_list  [0]);  break; }               case        c1091: { const num     = c2850      (str[i]);  i += num    [1];  list.items.push(num    [0]);  break; }             case          g1143: { const text    = y2865        (str[i]);  i += text   [1];  list.items.push(text   [0]);  break; }             case         d1168: { const color   = a2866       (str, i);  i += color  [1];  list.items.push(color  [0]);  break; }              case          i1178: { const fill    = w3677        (str, i);  i += fill   [1];  list.items.push(fill   [0]);  break; }             case    b1184: { const stop    = w2867   (str, i);  i += stop   [1];  list.items.push(stop   [0]);  break; }             case      x1187: { const grad    = w3676    (str, i);  i += grad   [1];  list.items.push(grad   [0]);  break; }             case        c1181: { const stroke  = f3832      (str, i);  i += stroke [1];  list.items.push(stroke [0]);  break; }             case   u1196: { const shadow  = i3833  (str, i);  i += shadow [1];  list.items.push(shadow [0]);  break; }             case  c1199: { const shadow  = f3834 (str, i);  i += shadow [1];  list.items.push(shadow [0]);  break; }             case    u1202: { const blur    = k3835   (str, i);  i += blur   [1];  list.items.push(blur   [0]);  break; }             case     n1205: { const blur    = x3707    (str, i);  i += blur   [1];  list.items.push(blur   [0]);  break; }             case   x1211: { const layer   = n3708  (str, i);  i += layer  [1];  list.items.push(layer  [0]);  break; }             case    d1208: { const mask    = o3709   (str[i]);  i += mask   [1];  list.items.push(mask   [0]);  break; }              case     y1218: { const rect    = t3711   (str, i);  i += rect   [1];  list.items.push(rect   [0]);  break; }             case          t1221: { const line    = e3822        (str, i);  i += line   [1];  list.items.push(line   [0]);  break; }             case       u1224: { const ellipse = u3823     (str, i);  i += ellipse[1];  list.items.push(ellipse[0]);  break; }             case       q1227: { const trapeze = t3824     (str, i);  i += trapeze[1];  list.items.push(trapeze[0]);  break; }             case       i1236: { const poly    = l3825     (str, i);  i += poly   [1];  list.items.push(poly   [0]);  break; }             case          o1239: { const star    = j3826        (str, i);  i += star   [1];  list.items.push(star   [0]);  break; }             case    t1242: { const text    = i3827   (str, i);  i += text   [1];  list.items.push(text   [0]);  break; }             case         i1245: { const point   = s3828       (str, i);  i += point  [1];  list.items.push(point  [0]);  break; }             case   m1249: { const path    = r3670  (str, i);  i += path   [1];  list.items.push(path   [0]);  break; }             case m1287: { const bool    = l3829(str, i);  i += bool   [1];  list.items.push(bool   [0]);  break; }             case   n1264: { const group   = w3830  (str, i);  i += group  [1];  list.items.push(group  [0]);  break; }             case         r1267: { const frame   = u3831       (str, i);  i += frame  [1];  list.items.push(frame  [0]);  break; }         }     }           return [         list,          i - m3769]; }    function getItemTypes(items, debug) {     const types = [];      for (const item of items)     {         if (   item.type ==        q1056             || item.type == b1057             || item.type ==   b1058             || item.type ==  o1059)             n949(types, h3479(item.items, debug));          else             n949(types, item.type);     }      return types; }    function finalTypeFromItems(items) {     return finalTypeFromTypes(getItemTypes(items)); }    function h3479(items) {     return e3036(getItemTypes(items)); }    function finalTypeFromTypes(types) {     let _type = x1087;      for (const type of types)     {         if (_type == x1087)             _type = type;          else if (    i1294.includes(_type)                   && !i1294.includes( type))         {             _type = x1087;             break;          }         else if (   !i1294.includes(_type)                   && _type != type)         {             _type = x1087;             break;          }     }      return _type; }    function e3036(types) {     let _type = finalTypeFromTypes(types);               if (  _type == c1091)      return b1057;     else if (  _type ==   g1143)      return   b1058;     else if (i1294.includes(_type)) return  o1059;     else                                   return        q1056; }


class y2022 extends w2050 {     value;     y3789;     decimals;        constructor(val = Number.NaN, dec = -1)     {         super(c1091);          if (typeof val !== 'number')             h953('NumberValue(value) is ' + typeof val + ', must be a number');           this.value     = val;         this.y3789 = val;                  this.decimals =                !isNaN(this.value)              && dec == -1              ? n1004(this.value)              : dec;     }        static fromString(str)     {         return new y2022(             parseFloat(str),             g1459(str));     }        copy()     {         const copy = new y2022(             this.value,              this.decimals);          copy.y3789 = this.y3789;          copy.x3359(this);          return copy;     }        equals(num)     {         return num             && this.value    == num.value             && this.decimals == num.decimals;     }        async eval(parse)     {         return this.copy();     }        y3712()     {         return this.value == this.y3789;     }        isValid()     {         return !isNaN(this.value)             && !isNaN(this.decimals);     }        z3729()     {         return new y2022(Math.round(this.value));     }        o3703()     {         return a1016(this.value, this.decimals);     }        toString()     {         return v1471(this.value)               + ','               + v1471(this.decimals);     }        u3705()     {         return this.isValid()              ? g1006(this.value, this.decimals)              : z964;     }        v3706()     {         return v1471(this.value)               + (!isNaN(this.decimals)                 ? '_' + this.decimals                  : '');     }        q2847(gen)     {         return this.u3705();     }        d3358()     {         return y2022.NaN.copy();     }        static NaN = Object.freeze(new y2022(         Number.NaN,          Number.NaN)); }    function c2850(str) {     if (str.indexOf(',') < 0)     {         h953('number value \'' + str + '\' missing \',\'');         console.trace();     }           const parts = str.split(',');      const num = new y2022(         c1472(parts[0]),         c1472(parts[1]));      return [num, 1]; }    function a3836(str) {     const num =          str == z964         ? y2022.NaN.copy()         : y2022.fromString(str);      return [num, 1]; }


class c2033 extends w2050 {     value;     y3789;        constructor(val = '')     {         super(g1143);           if (   val !== null             && typeof val !== 'string')         {             console.trace();             h953('TextValue('+val+') is ' + typeof val + ', must be a string');         }                   this.value        = val;         this.y3789    = val;               }        copy()     {         const copy = new c2033(this.value);          copy.y3789 = this.y3789;                  copy.x3359(this);          return copy;     }        equals(text)     {         return text             && this.value == text.value;     }        async eval(parse)     {         return this.copy();     }        y3712()     {         this.value == this.y3789;     }        isValid()     {         return this.value !== null;     }        b2119()     {         return encodeURIComponent(this.value);     }        toString()     {         return this.value;     }        u3705()     {         const lines = this.value.split('\n');          let str = '';          for (let i = 0; i < Math.min(lines.length, 10); i++)         {             if (i > 0)                 str += '\n';              str += lines[i];         }          if (lines.length > 10)             str += '\n. . .';                  return str;     }        v3706()     {         return '\''               + this.value.replaceAll('\n', '↵')              + '\'';     }        d3358()     {         return c2033.NaN.copy();     }        static NaN = Object.freeze(new c2033()); }    function y2865(str) {     const text = new c2033(decodeURIComponent(str));      return [text, 1]; }


class h2010 extends w2050 {     space;     c1;     c2;     c3;        constructor(space = y2022.NaN,                  c1    = y2022.NaN,                  c2    = y2022.NaN,                  c3    = y2022.NaN)     {         super(d1168);          this.space  = space.copy();         this.c1     = c1   .copy();         this.c2     = c2   .copy();         this.c3     = c3   .copy();          this.valid  = true;     }        static create(space, c1, c2, c3)     {         x952(typeof space == 'number', 'ColorValue.create() space must be a number');         x952(typeof c1    == 'number', 'ColorValue.create() c1 must be a number');         x952(typeof c2    == 'number', 'ColorValue.create() c2 must be a number');         x952(typeof c3    == 'number', 'ColorValue.create() c3 must be a number');          return new h2010(             new y2022(space, 0),             new y2022(c1,    0),             new y2022(c2,    0),             new y2022(c3,    0));     }        static y3773(rgb)     {         return h2010.create(1, rgb[0], rgb[1], rgb[2]);     }        static p2806(b3199, spaceIndex = -1)     {         if (spaceIndex < 0)             spaceIndex = d4125 (b3199[0]);          const space  = j133(spaceIndex);         const factor = x4192(space);          return h2010.create(             spaceIndex,             b3199[1] * factor[0],             b3199[2] * factor[1],             b3199[3] * factor[2]);     }        copy()     {         const copy = new h2010(             this.space.copy(),              this.c1   .copy(),              this.c2   .copy(),              this.c3   .copy());          copy.x3359(this);          return copy;     }        y3712()     {         return this.space.y3712()             && this.c1   .y3712()             && this.c2   .y3712()             && this.c3   .y3712();     }        isValid()     {         return this.space.isValid()             && this.c1   .isValid()             && this.c2   .isValid()             && this.c3   .isValid();     }        equals(col)     {         return col             && this.space.equals(col.space)             && this.c1   .equals(col.c1   )             && this.c2   .equals(col.c2   )             && this.c3   .equals(col.c3   );     }        async eval(parse)     {         return this.copy();     }        w3241()     {         if (!this.isValid())             return j3814;          const space = this.space.copy();          space.value = Math.round(Math.min(Math.max(0, space.value), a131.length-1));          return a147(             space,             this.c1,             this.c2,             this.c3);     }        p3242()     {         return n4195(this.w3241());     }        d99()     {         return p100(this.p3242());     }        toRgbObject(limit = false)     {         const rgb = n4195(this.w3241());          if (limit && c73(rgb))             return {r: 0.5, g: 0.5, b: 0.5};                  return limit             ? { r: Math.min(Math.max(0, rgb[0]), 1),                 g: Math.min(Math.max(0, rgb[1]), 1),                 b: Math.min(Math.max(0, rgb[2]), 1) }             : { r: rgb[0],                 g: rgb[1],                 b: rgb[2] };     }        toString()     {         return      this.space.toString()             + ' ' + this.c1   .toString()             + ' ' + this.c2   .toString()             + ' ' + this.c3   .toString();     }        u3705()     {         return      this.space.u3705()             + ' ' + this.c1   .u3705()             + ' ' + this.c2   .u3705()             + ' ' + this.c3   .u3705();     }        v3706()     {         return      this.space.v3706()             + ' ' + this.c1   .v3706()             + ' ' + this.c2   .v3706()             + ' ' + this.c3   .v3706();     }        u3705()     {         if (!this.isValid())             return d966;          const rgb = this.p3242();          return '#' + u151(rgb);     }        toRgbString()     {         if (!this.isValid())             return d966;          const rgb = this.p3242();          return      rgb[0].toString()             + ' ' + rgb[1].toString()             + ' ' + rgb[2].toString();     }        d3358()     {         return h2010.NaN.copy();     }        static NaN = Object.freeze(new h2010(         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN)); }    function a2866(str, i = -1) {     if (i < 0)     {         str = str.split(' ');         i   = 0;     }               const m3769 = i;      const space = c2850(str[i]); i += space[1];     const c1    = c2850(str[i]); i += c1   [1];     const c2    = c2850(str[i]); i += c2   [1];     const c3    = c2850(str[i]); i += c3   [1];       return [         new h2010(space[0], c1[0], c2[0], c3[0]),          i - m3769 ]; }


class c2013 extends w2050 {     color;     opacity;     blend;        constructor(color   = h2010.NaN,                  opacity = new y2022(100),                 blend   = new y2022(0))     {         super(i1178);          this.color   = color  .copy();         this.opacity = opacity.copy();         this.blend   = blend  .copy();          this.valid   = true;     }            static create(r, g, b, opacity, blend = 0)     {         x952(             typeof opacity == 'number',             'opacity must be a number');          return new c2013(             h2010.create(1, r, g, b),             new y2022(opacity),             new y2022(blend));     }        static y3773(rgb, opacity, blend = 0)     {         x952(             typeof opacity == 'number',             'opacity must be a number');          return new c2013(             h2010.y3773(rgb),             new y2022(opacity),             new y2022(blend));     }        copy()     {         const copy = new c2013(             this.color  .copy(),             this.opacity.copy(),             this.blend  .copy());          copy.x3359(this);          return copy;     }        equals(fill)     {         return this.color  .equals(fill.color  )             && this.opacity.equals(fill.opacity)             && this.blend  .equals(fill.blend  );     }        async eval(parse)     {         return this.copy();     }        d99()     {         return [             ...this.color.p3242(),             this.opacity.value / 100 ];     }                               toString()     {         const rgb = n4142(this.color.p3242());          return        new y2022(rgb[0]).toString()               + ' ' + new y2022(rgb[1]).toString()               + ' ' + new y2022(rgb[2]).toString()               + ' ' + this.opacity           .toString()               + ' ' + this.blend             .toString();     }        u3705()     {         const rgb = n4142(this.color.p3242());          return        new y2022(rgb[0]).u3705()               + ' ' + new y2022(rgb[1]).u3705()               + ' ' + new y2022(rgb[2]).u3705()               + ' ' + this.opacity           .u3705()               + ' ' + this.blend             .u3705();     }        v3706()     {         const rgb = n4142(this.color.p3242());          return        new y2022(rgb[0]).v3706()               + ' ' + new y2022(rgb[1]).v3706()               + ' ' + new y2022(rgb[2]).v3706()               + ' ' + this.opacity           .v3706()               + ' ' + this.blend             .v3706();     }        y3712()     {         return this.color  .y3712()             && this.opacity.y3712()             && this.blend  .y3712();     }        isValid()     {         return this.color  .isValid()             && this.opacity.isValid()             && this.blend  .isValid();     }        d3358()     {         return c2013.NaN.copy();     }        static NaN = Object.freeze(new c2013(         h2010 .NaN,         y2022.NaN,         y2022.NaN));        static default = Object.freeze(c2013.create(217, 217, 217, 100)); }    function w3677(str, i = -1) {     if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const m3769 = i;      const r  = c2850(str[i]); i += r [1];     const g  = c2850(str[i]); i += g [1];     const b  = c2850(str[i]); i += b [1];     const a  = c2850(str[i]); i += a [1];     const bl = c2850(str[i]); i += bl[1];      const color = new h2010(new y2022(1), r[0], g[0], b[0]);           return [         new c2013(color, a[0], bl[0]),         i - m3769 ]; }               


class o2009 extends w2050 {     fill;     position;        constructor(fill     = c2013.NaN,                  position = new y2022(1))     {         if (fill.type != i1178)             h953('fill.type is ' + fill.type + ', must be FILL_VALUE');           super(b1184);          this.fill     = fill    .copy();         this.position = position.copy();          this.valid    = true;     }            copy()     {         const copy = new o2009(             this.fill    .copy(),             this.position.copy());          copy.x3359(this);          return copy;     }        isValid()     {         return this.fill    .isValid()             && this.position.isValid();     }        equals(stop)     {         return stop             && this.fill    .equals(stop.fill    )             && this.position.equals(stop.position);     }        async eval(parse)     {         return this;     }        r3633()     {         return this.copy();     }        toString()     {         return      this.fill    .toString()             + ' ' + this.position.toString();     }        u3705()     {         return      this.fill    .u3705()             + ' ' + this.position.u3705();     }        v3706()     {         return      this.fill    .v3706()             + ' ' + this.position.v3706();     }        d3358()     {         return o2009.NaN.copy();     }        static NaN = Object.freeze(new o2009(         c2013  .NaN,         y2022.NaN)); }    function w2867(str, i = -1) {     if (   i <  0 && str    == z964         || i >= 0 && str[i] == z964)         return [o2009.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const m3769 = i;      const fill     = w3677  (str, i); i += fill    [1];     const position = c2850(str[i]); i += position[1];       return [         new o2009(fill[0], position[0]),         i - m3769 ]; }


class m2015 extends w2050 {     stops;     l3687;     position;     x;     y;     size;     angle;     aspect;     skew;     blend;      diagAspect;        constructor(stops      = new d2021(),                 l3687   = new y2022(0),                 position   = new y2022(0),                 x          = new y2022(0),                 y          = new y2022(0),                 size       = new y2022(0),                 angle      = new y2022(0),                 aspect     = new y2022(0),                 diagAspect = false,                 skew       = new y2022(0),                 blend      = new y2022(0))     {         super(x1187);          this.stops      = stops   .copy();         this.l3687   = l3687.copy();         this.position   = position.copy();         this.x          = x       .copy();         this.y          = y       .copy();         this.size       = size    .copy();         this.angle      = angle   .copy();         this.aspect     = aspect  .copy();         this.diagAspect = diagAspect;         this.skew       = skew    .copy();         this.blend      = blend   .copy();          this.valid      = true;     }            copy()     {         const copy = new m2015(             this.stops,             this.l3687,             this.position,             this.x,             this.y,             this.size,             this.angle,             this.aspect,             this.diagAspect,             this.skew,             this.blend);          copy.x3359(this);          return copy;     }        isValid()     {         return this.stops   .isValid()             && this.l3687.isValid()             && this.position.isValid()             && this.x       .isValid()             && this.y       .isValid()             && this.size    .isValid()             && this.angle   .isValid()             && this.aspect  .isValid()             && this.skew    .isValid()             && this.blend   .isValid();     }        equals(grad)     {         return grad             && this.stops   .equals(grad.stops   )             && this.l3687.equals(grad.l3687)             && this.position.equals(grad.position)             && this.x       .equals(grad.x       )             && this.y       .equals(grad.y       )             && this.size    .equals(grad.size    )             && this.angle   .equals(grad.angle   )             && this.aspect  .equals(grad.aspect  )             && this.diagAspect == grad.diagAspect             && this.skew    .equals(grad.skew    )             && this.blend   .equals(grad.blend   );     }        async eval(parse)     {         return this;     }        r3633()     {         return this.copy();     }        toString()     {         return      this.stops   .toString()             + ' ' + this.l3687.toString()             + ' ' + this.position.toString()             + ' ' + this.x       .toString()             + ' ' + this.y       .toString()             + ' ' + this.size    .toString()             + ' ' + this.angle   .toString()             + ' ' + this.aspect  .toString()             + ' ' + (this.diagAspect ? '1' : '0')             + ' ' + this.skew    .toString()             + ' ' + this.blend   .toString();     }        d99()     {         return this.stops.length > 0              ? this.stops[0].fill.d99()              : rgba_NaN;     }            u3705()     {         return      this.stops   .u3705()             + ' ' + this.l3687.u3705()             + ' ' + this.position.u3705()             + ' ' + this.x       .u3705()             + ' ' + this.y       .u3705()             + ' ' + this.size    .u3705()             + ' ' + this.angle   .u3705()             + ' ' + this.aspect  .u3705()             + ' ' + (this.diagAspect ? '1' : '0')             + ' ' + this.skew    .u3705()             + ' ' + this.blend   .u3705();     }        v3706()     {         return      this.stops   .v3706()             + ' ' + this.l3687.v3706()             + ' ' + this.position.v3706()             + ' ' + this.x       .v3706()             + ' ' + this.y       .v3706()             + ' ' + this.size    .v3706()             + ' ' + this.angle   .v3706()             + ' ' + this.aspect  .v3706()             + ' ' + (this.diagAspect ? '1' : '0')             + ' ' + this.skew    .v3706()             + ' ' + this.blend   .v3706();     }        d3358()     {         return m2015.NaN.copy();     }        static NaN = Object.freeze(new m2015(         d2021  .NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN,         false,         y2022.NaN,         y2022.NaN)); }    function w3676(str, i = -1) {     if (   i <  0 && str    == z964         || i >= 0 && str[i] == z964)         return [m2015.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const m3769 = i;      const stops      = y3482  (str, i); i += stops   [1];     const l3687   = c2850(str[i]); i += l3687[1];     const position   = c2850(str[i]); i += position[1];     const x          = c2850(str[i]); i += x       [1];     const y          = c2850(str[i]); i += y       [1];     const size       = c2850(str[i]); i += size    [1];     const angle      = c2850(str[i]); i += angle   [1];     const aspect     = c2850(str[i]); i += aspect  [1];     const diagAspect = parseInt(str[i]) == 1;    i ++;     const skew       = c2850(str[i]); i += skew    [1];     const blend      = c2850(str[i]); i += blend   [1];       return [         new m2015(             stops   [0],              l3687[0],              position[0],             x       [0],              y       [0],              size    [0],              angle   [0],              aspect  [0],              diagAspect,             skew    [0],              blend   [0]),         i - m3769 ]; }


class m2031 extends w2050 {     fills;     weight;     fit;     join;     miter;     cap;     dashes;        constructor(fills  = new d2021(),                  weight = new y2022(1),                 fit    = new y2022(0),                 join   = new y2022(0),                 miter  = new y2022(28.96, 2),                 cap    = new y2022(0),                 dashes = new c2033())     {         if (fills.type != q1056)             h953('fill.type is ' + fills.type + ', must be LIST_VALUE');           super(c1181);          this.fills  = fills .copy();         this.weight = weight.copy();         this.fit    = fit   .copy();         this.join   = join  .copy();         this.miter  = miter .copy();         this.cap    = cap   .copy();         this.dashes = dashes.copy();          this.valid  = true;     }            copy()     {         const copy = new m2031(             this.fills .copy(),             this.weight.copy(),             this.fit   .copy(),             this.join  .copy(),             this.miter .copy(),             this.cap   .copy(),             this.dashes.copy());          copy.x3359(this);          return copy;     }        y3712()     {         return this.fills .y3712()             && this.weight.y3712()             && this.fit   .y3712()             && this.join  .y3712()             && this.miter .y3712()             && this.cap   .y3712()             && this.dashes.y3712();     }        isValid()     {         return this.fills .isValid()             && this.weight.isValid()             && this.fit   .isValid()             && this.join  .isValid()             && this.miter .isValid()             && this.cap   .isValid()             && this.dashes.isValid();     }        equals(stroke)     {         return stroke             && this.fills .equals(stroke.fill  )             && this.weight.equals(stroke.weight)             && this.fit   .equals(stroke.fit   )             && this.join  .equals(stroke.join  )             && this.miter .equals(stroke.miter )             && this.cap   .equals(stroke.cap   )             && this.dashes.equals(stroke.dashes);     }        async eval(parse)     {         return this.copy();     }        r3633()     {         return this.copy();     }        toString()     {         return      this.fills .toString()             + ' ' + this.weight.toString()             + ' ' + this.fit   .toString()             + ' ' + this.join  .toString()             + ' ' + this.miter .toString()             + ' ' + this.cap   .toString()             + ' ' + this.dashes.toString();     }        u3705()     {         return      this.fills .u3705()             + ' ' + this.weight.u3705()             + ' ' + this.fit   .u3705()             + ' ' + this.join  .u3705()             + ' ' + this.miter .u3705()             + ' ' + this.cap   .u3705()             + ' ' + this.dashes.u3705();     }        v3706()     {         return      this.fills .v3706()             + ' ' + this.weight.v3706()             + ' ' + this.fit   .v3706()             + ' ' + this.join  .v3706()             + ' ' + this.miter .v3706()             + ' ' + this.cap   .v3706()             + ' ' + this.dashes.v3706();     }        d3358()     {         return m2031.NaN.copy();     }        static NaN = Object.freeze(new m2031(         new d2021(),         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN,         new c2033()));        static default = Object.freeze(new m2031(         new d2021(),         new y2022(1),         new y2022(0),         new y2022(0),         new y2022(28.96),         new y2022(0),         new c2033())); }    function f3832(str, i = -1) {     if (   i <  0 && str    == z964         || i >= 0 && str[i] == z964)         return [m2031.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const m3769 = i;      const fills  = y3482  (str, i); i += fills [1];     const weight = c2850(str[i]); i += weight[1];     const fit    = c2850(str[i]); i += fit   [1];     const join   = c2850(str[i]); i += join  [1];     const miter  = c2850(str[i]); i += miter [1];     const cap    = c2850(str[i]); i += cap   [1];     const dashes = y2865  (str[i]); i += dashes[1];      return [          new m2031(             fills [0],              weight[0],              fit   [0],              join  [0],              miter [0],              cap   [0],              dashes[0]),                  i - m3769 ]; } 


class y4272 extends w2050 {     top;     left;     right;     bottom;     visible;        constructor(top     = new y2022(0),                  left    = new y2022(0),                  right   = new y2022(0),                  bottom  = new y2022(0),                  visible = true)     {         super(g1190);          this.top     = top;         this.left    = left;         this.right   = right;         this.bottom  = bottom;         this.visible = visible;     }            copy()     {         const copy = new y4272(             this.top   .copy(),             this.left  .copy(),             this.right .copy(),             this.bottom.copy(),             this.visible);          copy.x3359(this);          return copy;     }        equals(sides)     {         return this.top   .equals(sides.tl)             && this.left  .equals(sides.tr)             && this.right .equals(sides.bl)             && this.bottom.equals(sides.br)             && this.visible === sides.visible;     }        async eval(parse)     {         return this;     }        toString()     {         return      this.top   .toString()             + ' ' + this.left  .toString()             + ' ' + this.right .toString()             + ' ' + this.bottom.toString();     }        u3705()     {         return      this.top   .u3705()             + ' ' + this.left  .u3705()             + ' ' + this.right .u3705()             + ' ' + this.bottom.u3705();     }        v3706()     {         return      this.top   .v3706()             + ' ' + this.left  .v3706()             + ' ' + this.right .v3706()             + ' ' + this.bottom.v3706();     }        isValid()     {         return this.top   .isValid()             && this.left  .isValid()             && this.right .isValid()             && this.bottom.isValid();     }        d3358()     {         return y4272.NaN.copy();     }        static NaN = Object.freeze(new y4272(         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN,         false)); }    function parseStrokeSidesValue(str, i = -1) {     if (   i <  0 && str    == z964         || i >= 0 && str[i] == z964)         return [y4272.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const m3769 = i;      const top    = c2850(str[i]); i += top   [1];     const left   = c2850(str[i]); i += left  [1];     const right  = c2850(str[i]); i += right [1];     const bottom = c2850(str[i]); i += bottom[1];       const sides = new y4272(         top   [0],         left  [0],         right [0],         bottom[0]);       return [sides, i - m3769]; } 


class v2026 extends w2050 {     tl;     tr;     bl;     br;     visible;        constructor(tl = new y2022(0),                  tr = new y2022(0),                  bl = new y2022(0),                  br = new y2022(0),                  visible = true)     {         super(h1193);          this.tl      = tl;         this.tr      = tr;         this.bl      = bl;         this.br      = br;         this.visible = visible;     }            copy()     {         const copy = new v2026(             this.tl.copy(),             this.tr.copy(),             this.bl.copy(),             this.br.copy(),             this.visible);          copy.x3359(this);          return copy;     }        equals(corners)     {         return this.tl.equals(corners.tl)             && this.tr.equals(corners.tr)             && this.bl.equals(corners.bl)             && this.br.equals(corners.br)             && this.visible === corners.visible;     }        async eval(parse)     {         return this;     }        toString()     {         return      this.tl.toString()             + ' ' + this.tr.toString()             + ' ' + this.bl.toString()             + ' ' + this.br.toString();     }        u3705()     {         return      this.tl.u3705()             + ' ' + this.tr.u3705()             + ' ' + this.bl.u3705()             + ' ' + this.br.u3705();     }        v3706()     {         return      this.tl.v3706()             + ' ' + this.tr.v3706()             + ' ' + this.bl.v3706()             + ' ' + this.br.v3706();     }        isValid()     {         return this.tl.isValid()             && this.tr.isValid()             && this.bl.isValid()             && this.br.isValid();     }        d3358()     {         return v2026.NaN.copy();     }        static NaN = Object.freeze(new v2026(         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN,         false)); }    function j3838(str, i = -1) {     if (   i <  0 && str    == z964         || i >= 0 && str[i] == z964)         return [v2026.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const m3769 = i;      const tl = c2850(str[i]); i += tl[1];     const tr = c2850(str[i]); i += tr[1];     const bl = c2850(str[i]); i += bl[1];     const br = c2850(str[i]); i += br[1];       const corners = new v2026(         tl[0],         tr[0],         bl[0],         br[0]);       return [corners, i - m3769]; } 


class n2011 extends w2050 {     x;     y;     blur;     spread;     fill;     blend;     behind;     visible;        constructor(x       = new y2022(0),                  y       = new y2022(0),                  blur    = new y2022(0),                  spread  = new y2022(0),                  fill    = c2013.NaN,                 blend   = new y2022(0),                 behind  = new y2022(0),                 visible = true)     {         super(u1196);          this.x       = x;         this.y       = y;         this.blur    = blur;         this.spread  = spread;         this.fill    = fill;         this.blend   = blend;         this.behind  = behind;         this.visible = visible;                  x952(fill.type == i1178, 'fill.type must be FILL_VALUE');     }                                             copy()     {         const copy = new n2011(             this.x     .copy(),             this.y     .copy(),             this.blur  .copy(),             this.spread.copy(),             this.fill  .copy(),             this.blend .copy(),             this.behind.copy(),             this.visible);          copy.x3359(this);          return copy;     }        equals(shadow)     {         return this.x     .equals(shadow.x     )             && this.y     .equals(shadow.y     )             && this.blur  .equals(shadow.blur  )             && this.spread.equals(shadow.spread)             && this.fill  .equals(shadow.fill  )             && this.blend .equals(shadow.blend )             && this.behind.equals(shadow.behind)             && this.visible === shadow.visible;     }        async eval(parse)     {         return this;     }        toString()     {         return      this.x     .toString()             + ' ' + this.y     .toString()             + ' ' + this.blur  .toString()             + ' ' + this.spread.toString()             + ' ' + this.fill  .toString()             + ' ' + this.blend .toString()             + ' ' + this.behind.toString();     }        u3705()     {         return      this.x     .u3705()             + ' ' + this.y     .u3705()             + ' ' + this.blur  .u3705()             + ' ' + this.spread.u3705()             + ' ' + this.fill  .u3705()             + ' ' + this.blend .u3705()             + ' ' + this.behind.u3705();     }        v3706()     {         return      this.x     .v3706()             + ' ' + this.y     .v3706()             + ' ' + this.blur  .v3706()             + ' ' + this.spread.v3706()             + ' ' + this.fill  .v3706()             + ' ' + this.blend .v3706()             + ' ' + this.behind.v3706();     }        isValid()     {         return this.x     .isValid()             && this.y     .isValid()             && this.blur  .isValid()             && this.spread.isValid()             && this.fill  .isValid()             && this.blend .isValid()             && this.behind.isValid();     }        d3358()     {         return n2011.NaN.copy();     }        static NaN = Object.freeze(new n2011(         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN,         c2013 .NaN,         y2022.NaN,         y2022.NaN,         false));        }    function i3833(str, i = -1) {     if (   i <  0 && str    == z964         || i >= 0 && str[i] == z964)         return [n2011.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const m3769 = i;      const x      = c2850(str[i]); i += x     [1];     const y      = c2850(str[i]); i += y     [1];     const blur   = c2850(str[i]); i += blur  [1];     const spread = c2850(str[i]); i += spread[1];     const fill   = w3677  (str, i); i += fill  [1];     const blend  = c2850(str[i]); i += blend [1];     const behind = c2850(str[i]); i += behind[1];       const shadow = new n2011(         x     [0],         y     [0],         blur  [0],         spread[0],         fill  [0],         blend [0],         behind[0]);       return [shadow, i - m3769]; } 


class k2016 extends w2050 {     x;     y;     blur;     spread;     fill;     blend;     visible;        constructor(x       = new y2022(0),                  y       = new y2022(0),                  blur    = new y2022(0),                  spread  = new y2022(0),                  fill    = c2013.NaN,                 blend   = new y2022(0),                 visible = true)     {         super(c1199);          this.x       = x;         this.y       = y;         this.blur    = blur;         this.spread  = spread;         this.fill    = fill;         this.blend   = blend;         this.visible = visible;     }                                             copy()     {         const copy = new k2016(             this.x     .copy(),             this.y     .copy(),             this.blur  .copy(),             this.spread.copy(),             this.fill  .copy(),             this.blend .copy(),             this.visible);          copy.x3359(this);          return copy;     }        equals(shadow)     {         return this.x     .equals(shadow.x     )             && this.y     .equals(shadow.y     )             && this.blur  .equals(shadow.blur  )             && this.spread.equals(shadow.spread)             && this.fill  .equals(shadow.fill  )             && this.blend .equals(shadow.blend )             && this.visible === shadow.visible;     }        async eval(parse)     {         return this;     }                                                                toString()     {         return      this.x     .toString()             + ' ' + this.y     .toString()             + ' ' + this.blur  .toString()             + ' ' + this.spread.toString()             + ' ' + this.fill  .toString()             + ' ' + this.blend .toString();     }        u3705()     {         return      this.x     .u3705()             + ' ' + this.y     .u3705()             + ' ' + this.blur  .u3705()             + ' ' + this.spread.u3705()             + ' ' + this.fill  .u3705()             + ' ' + this.blend .u3705();     }        v3706()     {         return      this.x     .v3706()             + ' ' + this.y     .v3706()             + ' ' + this.blur  .v3706()             + ' ' + this.spread.v3706()             + ' ' + this.fill  .v3706()             + ' ' + this.blend .v3706();     }        isValid()     {         return this.x     .isValid()             && this.y     .isValid()             && this.blur  .isValid()             && this.spread.isValid()             && this.fill  .isValid()             && this.blend .isValid();     }        d3358()     {         return k2016.NaN.copy();     }        static NaN = Object.freeze(new k2016(         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN,         c2013 .NaN,         y2022.NaN,         false));         }    function f3834(str, i = -1) {     if (   i <  0 && str    == z964         || i >= 0 && str[i] == z964)         return [k2016.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const m3769 = i;      const x      = c2850(str[i]); i += x     [1];     const y      = c2850(str[i]); i += y     [1];     const blur   = c2850(str[i]); i += blur  [1];     const spread = c2850(str[i]); i += spread[1];     const fill   = w3677  (str, i); i += fill  [1];     const blend  = c2850(str[i]); i += blend [1];       const shadow = new k2016(         x     [0],         y     [0],         blur  [0],         spread[0],         fill  [0],         blend [0]);       return [shadow, i - m3769]; } 


class m2018 extends w2050 {     radius;     visible;        constructor(radius  = new y2022(0),                  visible = true)     {         super(u1202);          this.radius  = radius;         this.visible = visible;     }                                             copy()     {         const copy = new m2018(             this.radius.copy(),             this.visible);          copy.x3359(this);          return copy;     }        equals(blur)     {         return this.radius.equals(blur.radius)             && this.visible === blur.visible;     }        async eval(parse)     {         return this;     }                                                                toString()     {         return this.radius.toString();     }        u3705()     {         return this.radius.u3705();     }        v3706()     {         return this.radius.v3706();     }        isValid()     {         return this.radius.isValid();     }        d3358()     {         return m2018.NaN.copy();     }        static NaN = Object.freeze(new m2018(         y2022.NaN,         false));         }    function k3835(str, i = -1) {     if (   i <  0 && str    == z964         || i >= 0 && str[i] == z964)         return [m2018.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const m3769 = i;      const radius = c2850(str[i]); i += radius[1];       const shadow = new m2018(         radius[0]);       return [shadow, i - m3769]; } 


class f2008 extends w2050 {     radius;     visible;        constructor(radius  = new y2022(0),                 visible = true)     {         super(n1205);          this.radius  = radius;         this.visible = visible;     }                                             copy()     {         const copy = new f2008(             this.radius.copy(),             this.visible);          copy.x3359(this);          return copy;     }        equals(blur)     {         return this.radius.equals(blur.radius)             && this.visible === blur.visible;     }        async eval(parse)     {         return this;     }                                                                toString()     {         return this.radius.toString();     }        u3705()     {         return this.radius.u3705();     }        v3706()     {         return this.radius.v3706();     }        isValid()     {         return this.radius.isValid();     }        d3358()     {         return f2008.NaN.copy();     }        static NaN = Object.freeze(new f2008(         y2022.NaN,         false));         }    function x3707(str, i = -1) {     if (   i <  0 && str    == z964         || i >= 0 && str[i] == z964)         return [f2008.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const m3769 = i;      const radius = c2850(str[i]); i += radius[1];       const shadow = new f2008(         radius[0]);       return [shadow, i - m3769]; } 


class t2017 extends w2050 {     opacity;     blend;        constructor(opacity, blend)     {         super(x1211);          this.opacity = opacity.copy();         this.blend   = blend  .copy();     }            copy()     {         const copy = new t2017(this.opacity, this.blend);          copy.x3359(this);          return copy;     }        equals(layer)     {         return this.opacity.equals(layer.opacity)             && this.blend  .equals(layer.blend  );     }        async eval(parse)     {         return this;     }        toString()     {         return      this.opacity.toString()             + ' ' + this.blend  .toString();     }        u3705()     {         return      this.opacity.u3705()             + ' ' + this.blend  .u3705();     }        v3706()     {         return      this.opacity.v3706()             + ' ' + this.blend  .v3706();     }        y3712()     {         return this.opacity.y3712()             && this.blend  .y3712();     }        isValid()     {         return this.opacity && this.opacity.isValid()             && this.blend   && this.blend  .isValid();     }        d3358()     {         return t2017.NaN.copy();     }        static NaN = Object.freeze(new t2017(y2022.NaN, y2022.NaN)); }    function n3708(str, i = -1) {     if (   i <  0 && str    == z964         || i >= 0 && str[i] == z964)         return [t2017.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const m3769 = i;      const opacity = c2850(str[i]); i += opacity[1];     const blend   = c2850(str[i]); i += blend  [1];       const layer = new t2017(         opacity[0],         blend  [0]);               return [layer, i - m3769]; } 


class k2019 extends w2050 {     visible;     maskType;        constructor(maskType, visible = true)     {         super(d1208);          this.visible  = visible;         this.maskType = maskType.copy();     }            copy()     {         const copy = new k2019(this.maskType, this.visible);          copy.x3359(this);          return copy;     }        equals(mask)     {         return this.visible === mask.visible             && this.maskType.equals(mask.maskType);     }        async eval(parse)     {         return this;     }        toString()     {         return 'mask';     }        u3705()     {         return 'mask';     }        v3706()     {         return 'mask';     }        isValid()     {         return this.maskType.isValid();     }        d3358()     {         return k2019.NaN.copy();     }        static NaN = Object.freeze(new k2019(y2022.NaN, false)); }    function o3709(str) {     const mask =          str == z964         ? k2019.NaN         : new k2019(new y2022(parseInt(str)), true);      return [mask, 1]; } 


   class k2029 extends w2050 {     nodeId;      props = null;        constructor(type, nodeId)     {         super(type);          this.nodeId = nodeId;           this.objects = [];     }        x3359(base)     {         super.x3359(base);                  this.nodeId = base.nodeId;          if (base.objects) this.objects = base.objects.map(o => o.copy());          if (base.props  ) this.props   = base.props.copy();     }        y3712()     {         return !this.props             ||  this.props.y3712();     }        isValid()     {         return !this.props             ||  this.props.isValid();     } }    function s3710(str, i, v111) {     const props = y3482(str, i); i += props[1];      v111.props = props[0];      return i; }


class z2025 extends k2029 {     x;     y;     width;     height;     round;        constructor(nodeId,                 x      = new y2022(0),                  y      = new y2022(0),                  width  = new y2022(0),                  height = new y2022(0),                  round  = new y2022(0))     {         super(y1218, nodeId);          this.x      = x;         this.y      = y;         this.width  = width;         this.height = height;         this.round  = round;     }        static fromObject(v111)     {         return new z2025(             v111.nodeId,             new y2022(v111.x     ),              new y2022(v111.y     ),              new y2022(v111.width ),              new y2022(v111.height),              new y2022(v111.round ));     }        copy()     {         const copy = new z2025(             this.nodeId,             this.x     .copy(),              this.y     .copy(),              this.width .copy(),              this.height.copy(),              this.round .copy());          copy.x3359(this);          return copy;     }        equals(rect)     {         return rect             && this.x     .equals(rect.x     )             && this.y     .equals(rect.y     )             && this.width .equals(rect.width )             && this.height.equals(rect.height)             && this.round .equals(rect.round );     }        async eval(parse)     {         return this.copy();     }        toString()     {         return      this.x     .toString()             + ' ' + this.y     .toString()             + ' ' + this.width .toString()             + ' ' + this.height.toString()             + ' ' + this.round .toString()             + ' ' + super.toString();     }        u3705()     {         return 'rectangle';                                                                      }        v3706()     {         return      this.x     .v3706()             + ' ' + this.y     .v3706()             + ' ' + this.width .v3706()             + ' ' + this.height.v3706()             + ' ' + this.round .v3706();     }        r3633()     {         return this.copy();     }        y3712()     {         return super.y3712()             && this.x     .y3712()             && this.y     .y3712()             && this.width .y3712()             && this.height.y3712()             && this.round .y3712();     }        isValid()     {         return super.isValid()             && this.x     .isValid()             && this.y     .isValid()             && this.width .isValid()             && this.height.isValid()             && this.round .isValid();     }            static NaN = new z2025(         '',         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN); }    function t3711(str, i = -1) {     if (   i <  0 && str    == z964         || i >= 0 && str[i] == z964)         return [z2025.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const m3769 = i;      const x      = c2850(str[i]); i += x     [1];     const y      = c2850(str[i]); i += y     [1];     const width  = c2850(str[i]); i += width [1];     const height = c2850(str[i]); i += height[1];     const round  = c2850(str[i]); i += round [1];       const rect = new z2025(         '',          x     [0],         y     [0],         width [0],         height[0],         round [0]);       i = s3710(str, i, rect);           return [rect, i - m3769]; } 


class c2020 extends k2029 {     x;     y;     width;        constructor(nodeId,                 x      = new y2022(0),                  y      = new y2022(0),                  width  = new y2022(0))     {         super(t1221, nodeId);          this.x     = x;         this.y     = y;         this.width = width;     }        static fromObject(v111)     {         return new c2020(             v111.nodeId,             new y2022(v111.x    ),              new y2022(v111.y    ),              new y2022(v111.width));     }        copy()     {         const copy = new c2020(             this.nodeId,             this.x    .copy(),              this.y    .copy(),              this.width.copy());          copy.x3359(this);          return copy;     }        equals(line)     {         return line             && this.x    .equals(line.x    )             && this.y    .equals(line.y    )             && this.width.equals(line.width);     }        async eval(parse)     {         return this.copy();     }        y3712()     {         return super.y3712()             && this.x     .y3712()             && this.y     .y3712()             && this.width .y3712();     }        isValid()     {         return super.isValid()             && this.x    .isValid()             && this.y    .isValid()             && this.width.isValid();     }        r3633()     {         return this.copy();     }        toString()     {         return      this.x    .toString()             + ' ' + this.y    .toString()             + ' ' + this.width.toString()             + ' ' + super.toString();     }        u3705()     {         return      this.x    .u3705()             + ' ' + this.y    .u3705()             + ' ' + this.width.u3705();     }        v3706()     {         return      this.x    .v3706()             + ' ' + this.y    .v3706()             + ' ' + this.width.v3706();     }        static NaN = new c2020(         '',         y2022.NaN,         y2022.NaN,         y2022.NaN); }    function e3822(str, i = -1) {     if (   i <  0 && str    == z964         || i >= 0 && str[i] == z964)         return [c2020.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const m3769 = i;      const x     = c2850(str[i]); i += x    [1];     const y     = c2850(str[i]); i += y    [1];     const width = c2850(str[i]); i += width[1];       const line = new c2020(         '',          x    [0],         y    [0],         width[0]);       i = s3710(str, i, line);           return [line, i - m3769]; } 


class v2012 extends k2029 {     position;     x;     y;     width;     height;     round;     start;     sweep;     inner;        constructor(nodeId,                 position = new y2022(0),                 x        = new y2022(0),                  y        = new y2022(0),                  width    = new y2022(0),                  height   = new y2022(0),                  round    = new y2022(0),                  start    = new y2022(0),                 sweep    = new y2022(0),                 inner    = new y2022(0))     {         super(u1224, nodeId);          this.position = position;         this.x        = x;         this.y        = y;         this.width    = width;         this.height   = height;         this.round    = round;         this.start    = start;         this.sweep    = sweep;         this.inner    = inner;     }        static fromObject(v111)     {         return new v2012(             v111.nodeId,             new y2022(v111.position),              new y2022(v111.x       ),              new y2022(v111.y       ),              new y2022(v111.width   ),              new y2022(v111.height  ),              new y2022(v111.round   ),             new y2022(v111.start   ),             new y2022(v111.sweep   ),             new y2022(v111.inner   ));     }        copy()     {         const copy = new v2012(             this.nodeId,             this.position.copy(),              this.x       .copy(),              this.y       .copy(),              this.width   .copy(),              this.height  .copy(),              this.round   .copy(),              this.start   .copy(),             this.sweep   .copy(),             this.inner   .copy());          copy.x3359(this);          return copy;     }        equals(ellipse)     {         return ellipse             && this.position.equals(ellipse.position)             && this.x       .equals(ellipse.x       )             && this.y       .equals(ellipse.y       )             && this.width   .equals(ellipse.width   )             && this.height  .equals(ellipse.height  )             && this.round   .equals(ellipse.round   )             && this.start   .equals(ellipse.start   )             && this.sweep   .equals(ellipse.sweep   )             && this.inner   .equals(ellipse.inner   );     }        async eval(parse)     {         return this.copy();     }                    y3712()     {         return super.y3712()             && this.position.y3712()             && this.x       .y3712()             && this.y       .y3712()             && this.width   .y3712()             && this.height  .y3712()             && this.round   .y3712()             && this.start   .y3712()             && this.sweep   .y3712()             && this.inner   .y3712();     }        isValid()     {         return super.isValid()             && this.position.isValid()             && this.x       .isValid()             && this.y       .isValid()             && this.width   .isValid()             && this.height  .isValid()             && this.round   .isValid()             && this.start   .isValid()             && this.sweep   .isValid()             && this.inner   .isValid();     }        r3633()     {         return this.copy();     }        toString()     {         return      this.position.toString()             + ' ' + this.x       .toString()             + ' ' + this.y       .toString()             + ' ' + this.width   .toString()             + ' ' + this.height  .toString()             + ' ' + this.round   .toString()             + ' ' + this.start   .toString()             + ' ' + this.sweep   .toString()             + ' ' + this.inner   .toString()             + ' ' + super.toString();     }        u3705()     {         return 'ellipse';                                                                                                                          }        v3706()     {         return      this.position.v3706()             + ' ' + this.x       .v3706()             + ' ' + this.y       .v3706()             + ' ' + this.width   .v3706()             + ' ' + this.height  .v3706()             + ' ' + this.round   .v3706()             + ' ' + this.start   .v3706()             + ' ' + this.sweep   .v3706()             + ' ' + this.inner   .v3706();     }        static NaN = new v2012(         '',         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN); }    function u3823(str, i = -1) {     if (   i <  0 && str    == z964         || i >= 0 && str[i] == z964)         return [v2012.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const m3769 = i;      const pos    = c2850(str[i]); i += pos   [1];     const x      = c2850(str[i]); i += x     [1];     const y      = c2850(str[i]); i += y     [1];     const width  = c2850(str[i]); i += width [1];     const height = c2850(str[i]); i += height[1];     const round  = c2850(str[i]); i += round [1];     const start  = c2850(str[i]); i += start [1];     const sweep  = c2850(str[i]); i += sweep [1];     const inner  = c2850(str[i]); i += inner [1];       const ellipse = new v2012(         '',          pos   [0],         x     [0],         y     [0],         width [0],         height[0],         round [0],         start [0],         sweep [0],         inner [0]);       i = s3710(str, i, ellipse);           return [ellipse, i - m3769]; } 


class t2034 extends k2029 {     x;     y;     width;     height;     round;     bias;        constructor(nodeId,                 x      = new y2022(0),                  y      = new y2022(0),                  width  = new y2022(0),                  height = new y2022(0),                  round  = new y2022(0),                 bias   = new y2022(0))     {         super(q1227, nodeId);          this.x      = x;         this.y      = y;         this.width  = width;         this.height = height;         this.round  = round;         this.bias   = bias;     }        static fromObject(v111)     {         return new t2034(             v111.nodeId,             new y2022(v111.x     ),              new y2022(v111.y     ),              new y2022(v111.width ),              new y2022(v111.height),              new y2022(v111.round ),             new y2022(v111.bias  ));     }        copy()     {         const copy = new t2034(             this.nodeId,             this.x     .copy(),              this.y     .copy(),              this.width .copy(),              this.height.copy(),              this.round .copy(),             this.bias  .copy());          copy.x3359(this);          return copy;     }        equals(rect)     {         return rect             && this.x     .equals(rect.x     )             && this.y     .equals(rect.y     )             && this.width .equals(rect.width )             && this.height.equals(rect.height)             && this.round .equals(rect.round )             && this.bias  .equals(rect.bias  );     }        async eval(parse)     {         return this.copy();     }        toString()     {         return      this.x     .toString()             + ' ' + this.y     .toString()             + ' ' + this.width .toString()             + ' ' + this.height.toString()             + ' ' + this.round .toString()             + ' ' + this.bias  .toString()             + ' ' + super.toString();     }        u3705()     {         return 'trapeze';                                                                                   }        v3706()     {         return      this.x     .v3706()             + ' ' + this.y     .v3706()             + ' ' + this.width .v3706()             + ' ' + this.height.v3706()             + ' ' + this.round .v3706()             + ' ' + this.bias  .v3706();     }        r3633()     {         return this.copy();     }        y3712()     {         return super.y3712()             && this.x     .y3712()             && this.y     .y3712()             && this.width .y3712()             && this.height.y3712()             && this.round .y3712()             && this.bias  .y3712();     }            isValid()     {         return super.isValid()             && this.x     .isValid()             && this.y     .isValid()             && this.width .isValid()             && this.height.isValid()             && this.round .isValid()             && this.bias  .isValid();     }            static NaN = new t2034(         '',         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN); }    function t3824(str, i = -1) {     if (   i <  0 && str    == z964         || i >= 0 && str[i] == z964)         return [t2034.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const m3769 = i;      const x      = c2850(str[i]); i += x     [1];     const y      = c2850(str[i]); i += y     [1];     const width  = c2850(str[i]); i += width [1];     const height = c2850(str[i]); i += height[1];     const round  = c2850(str[i]); i += round [1];     const bias   = c2850(str[i]); i += bias  [1];       const rect = new t2034(         '',          x     [0],         y     [0],         width [0],         height[0],         round [0],         bias  [0]);       i = s3710(str, i, rect);           return [rect, i - m3769]; } 


class x2024 extends k2029 {     position;     x;     y;     width;     height;     round;     corners;        constructor(nodeId,                 position = new y2022(0),                 x        = new y2022(0),                  y        = new y2022(0),                  width    = new y2022(0),                  height   = new y2022(0),                  round    = new y2022(0),                  corners  = new y2022(0))     {         super(i1236, nodeId);          this.position = position;         this.x        = x;         this.y        = y;         this.width    = width;         this.height   = height;         this.round    = round;         this.corners  = corners;     }        static fromObject(v111)     {         return new x2024(             v111.nodeId,             new y2022(v111.position),              new y2022(v111.x       ),              new y2022(v111.y       ),              new y2022(v111.width   ),              new y2022(v111.height  ),              new y2022(v111.round   ),             new y2022(v111.corners ));     }        copy()     {         const copy = new x2024(             this.nodeId,             this.position.copy(),              this.x       .copy(),              this.y       .copy(),              this.width   .copy(),              this.height  .copy(),              this.round   .copy(),              this.corners .copy());              copy.x3359(this);          return copy;     }        equals(poly)     {         return poly             && this.position.equals(poly.position)             && this.x       .equals(poly.x       )             && this.y       .equals(poly.y       )             && this.width   .equals(poly.width   )             && this.height  .equals(poly.height  )             && this.round   .equals(poly.round   )             && this.corners .equals(poly.corners );     }        async eval(parse)     {         return this.copy();     }        y3712()     {         return super.y3712()             && this.position.y3712()             && this.x       .y3712()             && this.y       .y3712()             && this.width   .y3712()             && this.height  .y3712()             && this.round   .y3712()             && this.corners .y3712();     }        isValid()     {         return super.isValid()             && this.position.isValid()             && this.x       .isValid()             && this.y       .isValid()             && this.width   .isValid()             && this.height  .isValid()             && this.round   .isValid()             && this.corners .isValid();     }        r3633()     {         return this.copy();     }        toString()     {         return      this.position.toString()             + ' ' + this.x       .toString()             + ' ' + this.y       .toString()             + ' ' + this.width   .toString()             + ' ' + this.height  .toString()             + ' ' + this.round   .toString()             + ' ' + this.corners .toString()             + ' ' + super.toString();     }        u3705()     {         return      this.position.u3705()             + ' ' + this.x       .u3705()             + ' ' + this.y       .u3705()             + ' ' + this.width   .u3705()             + ' ' + this.height  .u3705()             + ' ' + this.round   .u3705()             + ' ' + this.corners .u3705();     }        v3706()     {         return      this.position.v3706()             + ' ' + this.x       .v3706()             + ' ' + this.y       .v3706()             + ' ' + this.width   .v3706()             + ' ' + this.height  .v3706()             + ' ' + this.round   .v3706()             + ' ' + this.corners .v3706();     }        static NaN = new x2024(         '',         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN); }    function l3825(str, i = -1) {     if (   i <  0 && str    == z964         || i >= 0 && str[i] == z964)         return [x2024.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const m3769 = i;      const pos     = c2850(str[i]); i += pos    [1];     const x       = c2850(str[i]); i += x      [1];     const y       = c2850(str[i]); i += y      [1];     const width   = c2850(str[i]); i += width  [1];     const height  = c2850(str[i]); i += height [1];     const round   = c2850(str[i]); i += round  [1];     const corners = c2850(str[i]); i += corners[1];       const poly = new x2024(         '',          pos    [0],         x      [0],         y      [0],         width  [0],         height [0],         round  [0],         corners[0]);       i = s3710(str, i, poly);           return [poly, i - m3769]; } 


class y2030 extends k2029 {     position;     x;     y;     width;     height;     round;     points;     convex;        constructor(nodeId,                 position = new y2022(0),                  x        = new y2022(0),                  y        = new y2022(0),                  width    = new y2022(0),                  height   = new y2022(0),                  round    = new y2022(0),                  points   = new y2022(0),                 convex   = new y2022(0))     {         super(o1239, nodeId);          this.position = position;         this.x        = x;         this.y        = y;         this.width    = width;         this.height   = height;         this.round    = round;         this.points   = points;         this.convex   = convex;     }        static fromObject(v111)     {         return new y2030(             v111.nodeId,             new y2022(v111.position),              new y2022(v111.x       ),              new y2022(v111.y       ),              new y2022(v111.width   ),              new y2022(v111.height  ),              new y2022(v111.round   ),             new y2022(v111.points  ),             new y2022(v111.convex  ));     }        copy()     {         const copy = new y2030(             this.nodeId,             this.position.copy(),              this.x       .copy(),              this.y       .copy(),              this.width   .copy(),              this.height  .copy(),              this.round   .copy(),              this.points  .copy(),             this.convex  .copy());          copy.x3359(this);          return copy;     }        equals(star)     {         return star             && this.position.equals(star.position)             && this.x       .equals(star.x       )             && this.y       .equals(star.y       )             && this.width   .equals(star.width   )             && this.height  .equals(star.height  )             && this.round   .equals(star.round   )             && this.points  .equals(star.points  )             && this.convex  .equals(star.convex  );     }        async eval(parse)     {         return this.copy();     }        y3712()     {         return super.y3712()             && this.position.y3712()             && this.x       .y3712()             && this.y       .y3712()             && this.width   .y3712()             && this.height  .y3712()             && this.round   .y3712()             && this.points  .y3712()             && this.convex  .y3712();     }            isValid()     {         return super.isValid()             && this.position.isValid()             && this.x       .isValid()             && this.y       .isValid()             && this.width   .isValid()             && this.height  .isValid()             && this.round   .isValid()             && this.points  .isValid()             && this.convex  .isValid();     }            r3633()     {         return this.copy();     }        toString()     {         return      this.position.toString()             + ' ' + this.x       .toString()             + ' ' + this.y       .toString()             + ' ' + this.width   .toString()             + ' ' + this.height  .toString()             + ' ' + this.round   .toString()             + ' ' + this.points  .toString()             + ' ' + this.convex  .toString()             + ' ' + super.toString();     }        u3705()     {         return      this.position.u3705()             + ' ' + this.x       .u3705()             + ' ' + this.y       .u3705()             + ' ' + this.width   .u3705()             + ' ' + this.height  .u3705()             + ' ' + this.round   .u3705()             + ' ' + this.points  .u3705()             + ' ' + this.convex  .u3705();     }        v3706()     {         return      this.position.v3706()             + ' ' + this.x       .v3706()             + ' ' + this.y       .v3706()             + ' ' + this.width   .v3706()             + ' ' + this.height  .v3706()             + ' ' + this.round   .v3706()             + ' ' + this.points  .v3706()             + ' ' + this.convex  .v3706();     }        static NaN = new y2030(         '',         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN); }    function j3826(str, i = -1) {     if (   i <  0 && str    == z964         || i >= 0 && str[i] == z964)         return [y2030.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const m3769 = i;      const pos    = c2850(str[i]); i += pos   [1];     const x      = c2850(str[i]); i += x     [1];     const y      = c2850(str[i]); i += y     [1];     const width  = c2850(str[i]); i += width [1];     const height = c2850(str[i]); i += height[1];     const round  = c2850(str[i]); i += round [1];     const points = c2850(str[i]); i += points[1];     const convex = c2850(str[i]); i += convex[1];       const star = new y2030(         '',          pos   [0],         x     [0],         y     [0],         width [0],         height[0],         round [0],         points[0],         convex[0]);       i = s3710(str, i, star);           return [star, i - m3769]; } 


class y2032 extends k2029 {     text;     x;     y;     width;     height;     font;     style;     size;     alignX;     alignY;     lineHeight;     letterSpacing;            constructor(nodeId,                 text          = new c2033(),                 x             = new y2022(0),                  y             = new y2022(0),                  width         = new y2022(0),                  height        = new y2022(0),                  font          = new y2022(0),                 style         = new y2022(0),                 size          = new y2022(0),                 alignX        = new y2022(0),                 alignY        = new y2022(0),                 lineHeight    = new y2022(0),                 letterSpacing = new y2022(0))     {         super(t1242, nodeId);          this.text          = text;         this.x             = x;         this.y             = y;         this.width         = width;         this.height        = height;         this.font          = font;         this.style         = style;         this.size          = size;         this.alignX        = alignX;         this.alignY        = alignY;         this.lineHeight    = lineHeight;         this.letterSpacing = letterSpacing;          this.objects       = [];     }        static fromObject(v111)     {         return new y2032(             v111.nodeId,             new y2022(v111.text         ),              new y2022(v111.x            ),              new y2022(v111.y            ),              new y2022(v111.width        ),              new y2022(v111.height       ),              new y2022(v111.font         ),             new y2022(v111.style        ),             new y2022(v111.size         ),             new y2022(v111.alignX       ),             new y2022(v111.alignY       ),             new y2022(v111.lineHeight   ),             new y2022(v111.letterSpacing));     }        copy()     {         const copy = new y2032(             this.nodeId,             this.text         .copy(),             this.x            .copy(),              this.y            .copy(),              this.width        .copy(),              this.height       .copy(),              this.font         .copy(),             this.style        .copy(),             this.size         .copy(),             this.alignX       .copy(),             this.alignY       .copy(),             this.lineHeight   .copy(),             this.letterSpacing.copy());           copy.x3359(this);          return copy;     }        equals(text)     {         return text             && this.text         .equals(text.text         )             && this.x            .equals(text.x            )             && this.y            .equals(text.y            )             && this.width        .equals(text.width        )             && this.height       .equals(text.height       )             && this.font         .equals(text.font         )             && this.style        .equals(text.style        )             && this.size         .equals(text.size         )             && this.alignX       .equals(text.alignX       )             && this.alignY       .equals(text.alignY       )             && this.lineHeight   .equals(text.lineHeight   )             && this.letterSpacing.equals(text.letterSpacing);     }        async eval(parse)     {         return this.copy();     }        y3712()     {         return super.y3712()             && this.text         .y3712()             && this.x            .y3712()             && this.y            .y3712()             && this.width        .y3712()             && this.height       .y3712()             && this.font         .y3712()             && this.style        .y3712()             && this.size         .y3712()             && this.alignX       .y3712()             && this.alignY       .y3712()             && this.lineHeight   .y3712()             && this.letterSpacing.y3712();     }            isValid()     {         return super.isValid()             && this.text         .isValid()             && this.x            .isValid()             && this.y            .isValid()             && this.width        .isValid()             && this.height       .isValid()             && this.font         .isValid()             && this.style        .isValid()             && this.size         .isValid()             && this.alignX       .isValid()             && this.alignY       .isValid()             && this.lineHeight   .isValid()             && this.letterSpacing.isValid();     }            r3633()     {         return this.copy();     }        toString()     {         return      this.text         .b2119()              + ' ' + this.x            .toString()             + ' ' + this.y            .toString()             + ' ' + this.width        .toString()             + ' ' + this.height       .toString()             + ' ' + this.font         .toString()             + ' ' + this.style        .toString()             + ' ' + this.size         .toString()             + ' ' + this.alignX       .toString()             + ' ' + this.alignY       .toString()             + ' ' + this.lineHeight   .toString()             + ' ' + this.letterSpacing.toString()             + ' ' + super.toString();         }        u3705()     {         return 'textShape';                                                                                                                                                                       }        v3706()     {         return      this.text         .v3706()             + ' ' + this.x            .v3706()             + ' ' + this.y            .v3706()             + ' ' + this.width        .v3706()             + ' ' + this.height       .v3706()             + ' ' + this.font         .v3706()             + ' ' + this.style        .v3706()             + ' ' + this.size         .v3706()             + ' ' + this.alignX       .v3706()             + ' ' + this.alignY       .v3706()             + ' ' + this.lineHeight   .v3706()             + ' ' + this.letterSpacing.v3706();     }        b2119()     {         return      this.text         .b2119()             + ' ' + this.x            .b2119()             + ' ' + this.y            .b2119()             + ' ' + this.width        .b2119()             + ' ' + this.height       .b2119()             + ' ' + this.font         .b2119()             + ' ' + this.style        .b2119()             + ' ' + this.size         .b2119()             + ' ' + this.alignX       .b2119()             + ' ' + this.alignY       .b2119()             + ' ' + this.lineHeight   .b2119()             + ' ' + this.letterSpacing.b2119();     }        static NaN = new y2032(         '',         c2033.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN); }    function i3827(str, i = -1) {     if (   i <  0 && str    == z964         || i >= 0 && str[i] == z964)         return [y2032.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const m3769 = i;      const text          = y2865  (str[i]); i += text         [1];     const x             = c2850(str[i]); i += x            [1];     const y             = c2850(str[i]); i += y            [1];     const width         = c2850(str[i]); i += width        [1];     const height        = c2850(str[i]); i += height       [1];     const font          = c2850(str[i]); i += font         [1];     const style         = c2850(str[i]); i += style        [1];     const size          = c2850(str[i]); i += size         [1];     const alignX        = c2850(str[i]); i += alignX       [1];     const alignY        = c2850(str[i]); i += alignY       [1];     const lineHeight    = c2850(str[i]); i += lineHeight   [1];     const letterSpacing = c2850(str[i]); i += letterSpacing[1];       const txts = new y2032(         '',          text         [0],         x            [0],         y            [0],         width        [0],         height       [0],         font         [0],         style        [0],         size         [0],         alignX       [0],         alignY       [0],         lineHeight   [0],         letterSpacing[0]);       i = s3710(str, i, txts);           return [txts, i - m3769]; } 


class q2023 extends w2050 {     nodeId;      x;     y;     smooth;       sp0 = null;      sp1 = null;      sp2 = null;         constructor(nodeId,                 x = new y2022(0),                  y = new y2022(0),                 smooth = null)     {         super(i1245);          this.nodeId  = nodeId;          this.x       = x;         this.y       = y;         this.smooth  = smooth;           this.y3742();     }        static fromObject(v111)     {         return new q2023(             v111.nodeId,             new y2022(v111.x     ),              new y2022(v111.y     ),              new y2022(v111.smooth));     }        copy()     {         const copy = new q2023(             this.nodeId,             this.x.copy(),              this.y.copy());          if (this.smooth) copy.smooth = this.smooth.copy();          copy.x3359(this);          copy.sp0 = clone(this.sp0);         copy.sp1 = clone(this.sp1);         copy.sp2 = clone(this.sp2);          return copy;     }        equals(p)     {         return p             && this.x.equals(p.x)             && this.y.equals(p.y);     }        y3742(cx = 0, cy = 0) {         this.sp0 = point(cx,   cy  );         this.sp1 = point(cx+1, cy  );         this.sp2 = point(cx,   cy+1);     }        applySpaceTransform(b4208, space)     {         this.sp0 = d3731(this.sp0, b4208, space);         this.sp1 = d3731(this.sp1, b4208, space);         this.sp2 = d3731(this.sp2, b4208, space);     }        static create(nodeId, x, y)     {         return new q2023(             nodeId,             new y2022(x),             new y2022(y));     }        static fromPoint(nodeId, p)     {         return new q2023(             nodeId,             new y2022(p.x),             new y2022(p.y));     }        async eval(parse)     {         return this.copy();     }        y3712()     {         return this.x.y3712()             && this.y.y3712()             && (  !this.smooth                 || this.smooth.y3712());     }        isValid()     {         return this.x.isValid()             && this.y.isValid()             && (  !this.smooth                 || this.smooth.isValid());     }        toString()     {         return this.x.isValid()             && this.y.isValid()             ?         this.x.toString()               + ' ' + this.y.toString()             : z964;     }        u3705()     {         return this.x.isValid()             && this.y.isValid()             ?   '(' + this.x.u3705()               + ', ' + this.y.u3705()               + ')'             : z964;     }        v3706()     {         return this.x.isValid()             && this.y.isValid()             ?         this.x.v3706()               + ' ' + this.y.v3706()             : z964;     }        r3633()     {         return this.copy();     }        q3747()     {         return point(             this.x.value,             this.y.value);     }        q2847(gen)     {         return '';     }        d3358()     {         return q2023.NaN.copy();     }        static NaN = Object.freeze(new q2023(         '',         y2022.NaN,          y2022.NaN)); }    function s3828(str, i = -1) {     if (   i <  0 && str    == z964         || i >= 0 && str[i] == z964)         return [q2023.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const m3769 = i;      const x = c2850(str[i]); i += x[1];     const y = c2850(str[i]); i += y[1];       const point = new q2023(         '',          x[0],         y[0]);       return [point, i - m3769]; } 


class g2037 extends k2029 {     points;     closed;     degree;     winding;     round;        constructor(nodeId,                 points  = new d2021(),                  closed  = new y2022(0),                  degree  = new y2022(0),                  winding = new y2022(0),                  round   = new y2022(0))     {         super(m1249, nodeId);          this.points  = points ?? new d2021();         this.closed  = closed;         this.degree  = degree;         this.winding = winding;         this.round   = round;     }        static fromObject(v111)     {         return new g2037(             v111.nodeId,             new d2021(v111.points.map(p => q2023.fromPoint(v111.nodeId, p))),              new y2022(v111.closed ),              new y2022(v111.degree ),              new y2022(v111.winding),              new y2022(v111.round  ));     }        copy()     {         const copy = new g2037(             this.nodeId,             this.points .copy(),              this.closed .copy(),              this.degree .copy(),              this.winding.copy(),              this.round  .copy());          copy.x3359(this);          return copy;     }        equals(rect)     {         return rect             && this.points .equals(rect.points )             && this.closed .equals(rect.closed )             && this.degree .equals(rect.degree )             && this.winding.equals(rect.winding)             && this.round  .equals(rect.round  );     }        async eval(parse)     {         return this.copy();     }        toString()     {         return      this.points .toString()             + ' ' + this.closed .toString()             + ' ' + this.degree .toString()             + ' ' + this.winding.toString()             + ' ' + this.round  .toString()             + ' ' + super.toString();     }        u3705()     {         return      this.points .u3705()             + ' ' + this.closed .u3705()             + ' ' + this.degree .u3705()             + ' ' + this.winding.u3705()             + ' ' + this.round  .u3705();     }        v3706()     {         return      this.points .v3706()             + ' ' + this.closed .v3706()             + ' ' + this.degree .v3706()             + ' ' + this.winding.v3706()             + ' ' + this.round  .v3706();     }        r3633()     {         return this.copy();     }        y3712()     {         return super.y3712()             && this.points .y3712()             && this.closed .y3712()             && this.degree .y3712()             && this.winding.y3712()             && this.round  .y3712();     }            isValid()     {         return super.isValid()             && this.points  && this.points .isValid()             && this.closed  && this.closed .isValid()             && this.degree  && this.degree .isValid()             && this.winding && this.winding.isValid()             && this.round   && this.round  .isValid();     }            static NaN = new g2037(         '',         d2021  .NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN); }    function r3670(str, i = -1) {     if (   i <  0 && str    == z964         || i >= 0 && str[i] == z964)         return [g2037.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const m3769 = i;      const points  = y3482  (str, i); i += points [1];     const closed  = c2850(str[i]); i += closed [1];     const degree  = c2850(str[i]); i += degree [1];     const winding = c2850(str[i]); i += winding[1];     const round   = c2850(str[i]); i += round  [1];      const path = new g2037(         '',          points [0],         closed [0],         degree [0],         winding[0],         round  [0]);       i = s3710(str, i, path);           return [path, i - m3769]; } 


class d2039 extends w2050 {     nodeId;      x;     y;     join;     cap;     round;        constructor(nodeId,                 x     = new y2022(0),                  y     = new y2022(0),                 join  = new y2022(0),                 cap   = new y2022(0),                 round = new y2022(0))     {         super(p1252);          this.nodeId = nodeId;          this.x      = x    .copy();         this.y      = y    .copy();         this.join   = join .copy();         this.cap    = cap  .copy();         this.round  = round.copy();     }        copy()     {         const copy = new d2039(             this.nodeId,             this.x    .copy(),              this.y    .copy(),              this.join .copy(),              this.cap  .copy(),              this.round.copy());          copy.x3359(this);          return copy;     }        equals(p)     {         return p             && this.x    .equals(p.x    )             && this.y    .equals(p.y    )             && this.join .equals(p.join )             && this.cap  .equals(p.cap  )             && this.round.equals(p.round);     }        static create(nodeId, x, y)     {         return new d2039(             nodeId,             new y2022(x    ),             new y2022(y    ),             new y2022(join ),             new y2022(cap  ),             new y2022(round));     }        static fromPoint(nodeId, p)     {         return new d2039(             nodeId,             new y2022(p.x),             new y2022(p.y),             new y2022(0),             new y2022(0),             new y2022(0));     }        async eval(parse)     {         return this;     }        y3712()     {         return this.x    .y3712()             && this.y    .y3712()             && this.join .y3712()             && this.cap  .y3712()             && this.round.y3712();     }        isValid()     {         return this.x    .isValid()             && this.y    .isValid()             && this.join .isValid()             && this.cap  .isValid()             && this.round.isValid();     }        toString()     {         return      this.x    .toString()             + ' ' + this.y    .toString()             + ' ' + this.join .toString()             + ' ' + this.cap  .toString()             + ' ' + this.round.toString();     }        u3705()     {         return      this.x    .u3705()             + ' ' + this.y    .u3705()             + ' ' + this.join .u3705()             + ' ' + this.cap  .u3705()             + ' ' + this.round.u3705();     }        v3706()     {         return      this.x    .v3706()             + ' ' + this.y    .v3706()             + ' ' + this.join .v3706()             + ' ' + this.cap  .v3706()             + ' ' + this.round.v3706();     }        r3633()     {         return this.copy();     }        q3747()     {         return point(             this.x.value,             this.y.value);     }        q2847(gen)     {         return '';     }        d3358()     {         return d2039.NaN.copy();     }        static NaN = Object.freeze(new d2039(         '',         y2022.NaN,          y2022.NaN,          y2022.NaN,          y2022.NaN,          y2022.NaN)); }    function a3669(str, i = -1) {     if (   i <  0 && str    == z964         || i >= 0 && str[i] == z964)         return [d2039.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const m3769 = i;      const x     = c2850(str[i]); i += x    [1];     const y     = c2850(str[i]); i += y    [1];     const join  = c2850(str[i]); i += join [1];     const cap   = c2850(str[i]); i += cap  [1];     const round = c2850(str[i]); i += round[1];       const point = new d2039(         '',          x    [0],         y    [0],         join [0],         cap  [0],         round[0]);       return [point, i - m3769]; } 


class l2035 extends w2050 {     nodeId;      start;     end;     i3665;     o3666;        constructor(nodeId,                 start,                  end,                 i3665 = q2023.create(nodeId, 0, 0),                 o3666   = q2023.create(nodeId, 0, 0))     {         super(h1255);          this.nodeId = nodeId;          this.start        = start       .copy();                this.end          = end         .copy();                  this.i3665 = i3665.copy();         this.o3666   = o3666  .copy();       }        copy()     {         const copy = new l2035(             this.nodeId,             this.start       .copy(),              this.end         .copy(),              this.i3665.copy(),              this.o3666  .copy());          copy.x3359(this);          return copy;     }        equals(edge)     {         return edge             && this.start       .equals(edge.start       )             && this.end         .equals(edge.end         )             && this.i3665.equals(edge.i3665)             && this.  o3666.equals(edge.  o3666);     }        static create(nodeId, start, end, i3665, o3666)     {         return new l2035(             nodeId,             start,             end,             q2023.create(nodeId, i3665.x, i3665.y),             q2023.create(nodeId,   o3666.x,   o3666.y));     }        async eval(parse)     {         return this;     }        y3712()     {         return this.start       .y3712()             && this.end         .y3712()             && this.i3665.y3712()             && this.o3666  .y3712();     }        isValid()     {         return this.start       .isValid()             && this.end         .isValid()             && this.i3665.isValid()             && this.o3666  .isValid();     }        toString()     {         return      this.start       .toString()             + ' ' + this.end         .toString()             + ' ' + this.i3665.toString()             + ' ' + this.o3666  .toString();     }        u3705()     {         return      this.start       .toString()             + ' ' + this.end         .toString()             + ' ' + this.i3665.toString()             + ' ' + this.o3666  .toString();     }        v3706()     {         return      this.start       .v3706()             + ' ' + this.end         .v3706()             + ' ' + this.i3665.v3706()             + ' ' + this.o3666  .v3706();     }        r3633()     {         return this.copy();     }        q2847(gen)     {         return '';     }        d3358()     {         return l2035.NaN.copy();     }        static NaN = Object.freeze(new l2035(         '',         d2039.NaN,          d2039.NaN,          q2023.NaN,          q2023.NaN)); }    function b3667(str, i = -1) {     if (   i <  0 && str    == z964         || i >= 0 && str[i] == z964)         return [l2035.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const m3769 = i;      const start        = a3669(str, i); i += start       [1];     const end          = a3669(str, i); i += end         [1];     const i3665 = s3828       (str, i); i += i3665[1];     const o3666   = s3828       (str, i); i +=   o3666[1];       const edge = new l2035(         '',          start       [0],         end         [0],         i3665[0],           o3666[0]);       return [edge, i - m3769]; } 


class z2038 extends k2029 {     loops;       winding;      fills = [];        constructor(nodeId,                 loops   = new d2021(),                  winding = new y2022(0))     {         super(g1258, nodeId);          this.loops   = loops;           this.winding = winding;     }        static fromObject(v111)     {         return new z2038(             v111.nodeId,             new d2021(),               new d2021());      }        copy()     {         const copy = new z2038(             this.nodeId,             this.loops  .copy(),              this.winding.copy());          copy.fills = clone(this.fills);                  copy.x3359(this);          return copy;     }        equals(region)     {         return region             && this.loops  .equals(region.loops  )             && this.winding.equals(region.winding);     }                                              async eval(parse)     {         return this;     }        y3712()     {         return this.loops  .y3712()             && this.winding.y3712();     }        isValid()     {         return this.loops  .isValid()             && this.winding.isValid();     }        toString()     {         return      this.loops  .toString()             + ' ' + this.winding.toString();     }        u3705()     {         return      this.loops  .u3705()             + ' ' + this.winding.u3705();     }        v3706()     {         return      this.loops  .v3706()             + ' ' + this.winding.v3706();     }        r3633()     {         return this.copy();     }        q2847(gen)     {         return '';     }        d3358()     {         return l2035.NaN.copy();     }        static NaN = Object.freeze(new z2038(         '',         d2021  .NaN,          y2022.NaN)); }    function v3664(str, i = -1) {     if (   i <  0 && str    == z964         || i >= 0 && str[i] == z964)         return [z2038.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const m3769 = i;      const loops   = y3482  (str, i); i += loops  [1];     const winding = c2850(str[i]); i += winding[1];       const region = new z2038(         '',          loops  [0],         winding[0]);       i = s3710(str, i, region);       return [region, i - m3769]; } 


class q2036 extends w2050 {     nodeId;      regions;        constructor(nodeId,                 regions = new d2021())     {         super(w1261);          this.nodeId  = nodeId;          this.regions = regions;      }        static fromObject(v111)     {         return new q2036(             v111.nodeId,             new d2021(v111.regions.map(r => z2038.fromObject(v111.nodeId, r))));     }        copy()     {         const copy = new q2036(             this.nodeId,             this.regions.copy());          copy.x3359(this);          return copy;     }        equals(other)     {         return other             && this.regions.equals(other.regions);     }        static create(nodeId, regions)     {         return new q2036(             nodeId,             regions);     }        async eval(parse)     {         return this;     }        y3712()     {         return this.regions.y3712();     }        isValid()     {         return this.regions.isValid();     }        toString()     {         return this.regions.toString();     }        u3705()     {         return this.regions.u3705();     }        v3706()     {         return this.regions.v3706();     }        r3633()     {         return this.copy();     }        q2847(gen)     {         return '';     }        d3358()     {         return q2036.NaN.copy();     }        static NaN = Object.freeze(new q2036(         '',         d2021.NaN)); }    function q3663(str, i = -1) {     if (   i <  0 && str    == z964         || i >= 0 && str[i] == z964)         return [q2036.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const m3769 = i;      const regions = y3482(str, i); i += regions[1];       const net = new q2036(         '',          regions[0]);       return [net, i - m3769]; } 


class w2027 extends k2029 {     operation;     children;        constructor(nodeId, children, operation)     {         super(m1287, nodeId);          this.children  = children;         this.operation = operation;          this.objects =              children.objects             ? children.objects.map(o => o.copy())             : null;     }        copy()     {         const copy = new w2027(             this.nodeId,             this.children .copy(),             this.operation.copy());          copy.x3359(this);          return copy;     }        equals(bool)     {         return bool             && this.children .equals(bool.children )             && this.operation.equals(bool.operation);     }        async eval(parse)     {         return this;     }        toString()     {         return      this.children .toString()             + ' ' + this.operation.toString();     }        u3705()     {         return      this.children .u3705()             + ' ' + this.operation.u3705();     }        v3706()     {         return      this.children .v3706()             + ' ' + this.operation.v3706();     }        r3633()     {         return this.copy();     }        isValid()     {         return super.isValid()             && this.children .isValid()             && this.operation.isValid();     }            static NaN = new w2027(         '',         d2021  .NaN,         y2022.NaN); }    function l3829(str, i = -1) {     if (   i <  0 && str    == z964         || i >= 0 && str[i] == z964)         return [w2027.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const m3769 = i;      const children  = y3482  (str, i); i += children [1];     const operation = c2850(str[i]); i += operation[1];      const bool = new w2027(         '',          children [0],         operation[0]);       i = s3710(str, i, bool);           return [bool, i - m3769]; } 


class WavePathValue extends k2029 {     shape;     x;     y;     width;     amplitude;     frequency;     offset;     alignX;       alignY;        degree;        constructor(nodeId,                 shape     = new y2022(0),                 x         = new y2022(0),                  y         = new y2022(0),                  width     = new y2022(0),                  amplitude = new y2022(0),                 frequency = new y2022(0),                 offset    = new y2022(0),                 alignX    = new y2022(0),                 alignY    = new y2022(0))     {         super(y1234, nodeId);          this.shape     = shape;         this.x         = x;         this.y         = y;         this.width     = width;         this.amplitude = amplitude;         this.frequency = frequency;         this.offset    = offset;         this.alignX    = alignX;         this.alignY    = alignY;          this.degree   = new y2022(2);     }        copy()     {         const copy = new WavePathValue(             this.nodeId,             this.shape    .copy(),             this.x        .copy(),              this.y        .copy(),              this.width    .copy(),              this.amplitude.copy(),             this.frequency.copy(),             this.offset   .copy(),             this.alignX   .copy(),             this.alignY   .copy());          copy.x3359(this);          return copy;     }        equals(wave)     {         return wave             && this.shape    .equals(wave.shape    )             && this.x        .equals(wave.x        )             && this.y        .equals(wave.y        )             && this.width    .equals(wave.width    )             && this.amplitude.equals(wave.amplitude)             && this.frequency.equals(wave.frequency)             && this.offset   .equals(wave.offset   )             && this.alignX   .equals(wave.alignX   )             && this.alignY   .equals(wave.alignY   );     }        async eval(parse)     {         return this.copy();     }                    y3712()     {         return super.y3712()             && this.shape    .y3712()             && this.x        .y3712()             && this.y        .y3712()             && this.width    .y3712()             && this.amplitude.y3712()             && this.frequency.y3712()             && this.offset   .y3712()             && this.alignX   .y3712()             && this.alignY   .y3712();     }        isValid()     {         return super.isValid()             && this.shape    .isValid()             && this.x        .isValid()             && this.y        .isValid()             && this.width    .isValid()             && this.amplitude.isValid()             && this.frequency.isValid()             && this.offset   .isValid()             && this.alignX   .isValid()             && this.alignY   .isValid();     }        r3633()     {         return this.copy();     }        toString()     {         return      this.shape    .toString()             + ' ' + this.x        .toString()             + ' ' + this.y        .toString()             + ' ' + this.width    .toString()             + ' ' + this.amplitude.toString()             + ' ' + this.frequency.toString()             + ' ' + this.offset   .toString()             + ' ' + this.alignX   .toString()             + ' ' + this.alignY   .toString()             + ' ' + super.toString();     }        u3705()     {         return 'wave';                                                                                                                          }        v3706()     {         return      this.shape    .v3706()             + ' ' + this.x        .v3706()             + ' ' + this.y        .v3706()             + ' ' + this.width    .v3706()             + ' ' + this.amplitude.v3706()             + ' ' + this.frequency.v3706()             + ' ' + this.offset   .v3706()             + ' ' + this.alignX   .v3706()             + ' ' + this.alignY   .v3706();     }        static NaN = new WavePathValue(         '',         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN); }    function parseWavePathValue(str, i = -1) {     if (   i <  0 && str    == z964         || i >= 0 && str[i] == z964)         return [WavePathValue.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const m3769 = i;      const shape     = c2850(str[i]); i += shape    [1];     const x         = c2850(str[i]); i += x        [1];     const y         = c2850(str[i]); i += y        [1];     const width     = c2850(str[i]); i += width    [1];     const amplitude = c2850(str[i]); i += amplitude[1];     const frequency = c2850(str[i]); i += frequency[1];     const offset    = c2850(str[i]); i += offset   [1];     const alignX    = c2850(str[i]); i += alignX   [1];     const alignY    = c2850(str[i]); i += alignY   [1];       const wave = new WavePathValue(         '',          shape    [0],         x        [0],         y        [0],         width    [0],         amplitude[0],         frequency[0],         offset   [0],         alignX   [0],         alignY   [0]);       i = s3710(str, i, wave);           return [wave, i - m3769]; } 


class ArcPathValue extends k2029 {     position;     x;     y;     width;     height;     start;     sweep;      degree;         constructor(nodeId,                 position = new y2022(0),                 x        = new y2022(0),                  y        = new y2022(0),                  width    = new y2022(0),                  height   = new y2022(0),                  start    = new y2022(0),                 sweep    = new y2022(0))     {         super(r1231, nodeId);          this.position = position;         this.x        = x;         this.y        = y;         this.width    = width;         this.height   = height;         this.start    = start;         this.sweep    = sweep;          this.degree   = new y2022(2);     }        copy()     {         const copy = new ArcPathValue(             this.nodeId,             this.position.copy(),              this.x       .copy(),              this.y       .copy(),              this.width   .copy(),              this.height  .copy(),              this.start   .copy(),             this.sweep   .copy());          copy.x3359(this);          return copy;     }        equals(arc)     {         return arc             && this.position.equals(arc.position)             && this.x       .equals(arc.x       )             && this.y       .equals(arc.y       )             && this.width   .equals(arc.width   )             && this.height  .equals(arc.height  )             && this.start   .equals(arc.start   )             && this.sweep   .equals(arc.sweep   );     }        async eval(parse)     {         return this.copy();     }                    y3712()     {         return super.y3712()             && this.position.y3712()             && this.x       .y3712()             && this.y       .y3712()             && this.width   .y3712()             && this.height  .y3712()             && this.start   .y3712()             && this.sweep   .y3712();     }        isValid()     {         return super.isValid()             && this.position.isValid()             && this.x       .isValid()             && this.y       .isValid()             && this.width   .isValid()             && this.height  .isValid()             && this.start   .isValid()             && this.sweep   .isValid();     }        r3633()     {         return this.copy();     }        toString()     {         return      this.position.toString()             + ' ' + this.x       .toString()             + ' ' + this.y       .toString()             + ' ' + this.width   .toString()             + ' ' + this.height  .toString()             + ' ' + this.start   .toString()             + ' ' + this.sweep   .toString()             + ' ' + super.toString();     }        u3705()     {         return 'arc';                                                                                                }        v3706()     {         return      this.position.v3706()             + ' ' + this.x       .v3706()             + ' ' + this.y       .v3706()             + ' ' + this.width   .v3706()             + ' ' + this.height  .v3706()             + ' ' + this.start   .v3706()             + ' ' + this.sweep   .v3706();     }        static NaN = Object.freeze(new ArcPathValue(         '',         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN)); }    function parseArcPathValue(str, i = -1) {     if (   i <  0 && str    == z964         || i >= 0 && str[i] == z964)         return [ArcPathValue.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const m3769 = i;      const pos    = c2850(str[i]); i += pos   [1];     const x      = c2850(str[i]); i += x     [1];     const y      = c2850(str[i]); i += y     [1];     const width  = c2850(str[i]); i += width [1];     const height = c2850(str[i]); i += height[1];     const start  = c2850(str[i]); i += start [1];     const sweep  = c2850(str[i]); i += sweep [1];       const arc = new ArcPathValue(         '',          pos   [0],         x     [0],         y     [0],         width [0],         height[0],         start [0],         sweep [0]);       i = s3710(str, i, arc);           return [arc, i - m3769]; } 


class p2028 extends w2050 {     items = [];        constructor(nodeId, items = [])     {         super(n1264, nodeId);          this.items = items;               }        copy()     {         const copy = new p2028(             this.nodeId,             this.items.map(i => i.copy()));          copy.x3359(this);          return copy;     }        equals(group)     {         if (!group)                                  return false;         if (!(group instanceof p2028))     return false;         if (this.items.length != group.items.length) return false;                      for (let i = 0; i < this.items.length; i++)             if (!this.items[i].equals(group.items[i]))                 return false;          return true;     }        async eval(parse)     {         return this;     }        toString()     {         if (!this.items)             return '';           let str = '';                           str += this.items.length;          for (let i = 0; i < this.items.length; i++)         {             const item = this.items[i];              str += ' ' + item.type + ' ';             str += item.toString();         }           return str;     }        u3705()     {         if (!this.items)             return '';           let str = '';                           str += this.items.length;          for (let i = 0; i < this.items.length; i++)         {             const item = this.items[i];              str += ' ' + item.type + ' ';             str += item.u3705();         }           return str;     }        v3706()     {         if (!this.items)             return '';           let str = '';                           str += this.items.length;          for (let i = 0; i < this.items.length; i++)         {             const item = this.items[i];              str += ' ' + item.type + ' ';             str += item.v3706();         }           return str;     }        r3633()     {         return this.copy();     }        isValid()     {         return  this.items             && !this.items.find(i => !i.isValid());     }            static NaN = new p2028(         '',         d2021.NaN); }    function w3830(str, i = -1) {     if (i < 0)     {         str = str.split(' ');         i   = 0;     }               const m3769 = i;      const group = new p2028();           const a4209 = parseInt(str[i++]);       for (let j = 0; j < a4209; j++)     {         const type = str[i++];                  switch (type)         {             case          q1056:               case    o1059: { const _list   = y3482        (str, i);  i += _list  [1];  group.items.push(_list  [0]);  break; }               case     y1218: { const rect    = t3711   (str, i);  i += rect   [1];  group.items.push(rect   [0]);  break; }             case          t1221: { const line    = e3822        (str, i);  i += line   [1];  group.items.push(line   [0]);  break; }             case       u1224: { const ellipse = u3823     (str, i);  i += ellipse[1];  group.items.push(ellipse[0]);  break; }             case       q1227: { const ellipse = t3824     (str, i);  i += ellipse[1];  group.items.push(ellipse[0]);  break; }             case       i1236: { const poly    = l3825     (str, i);  i += poly   [1];  group.items.push(poly   [0]);  break; }             case          o1239: { const star    = j3826        (str, i);  i += star   [1];  group.items.push(star   [0]);  break; }             case    t1242: { const text    = i3827   (str, i);  i += text   [1];  group.items.push(text   [0]);  break; }             case         i1245: { const point   = s3828       (str, i);  i += point  [1];  group.items.push(point  [0]);  break; }             case   m1249: { const path    = r3670  (str, i);  i += path   [1];  group.items.push(path   [0]);  break; }             case m1287: { const path    = l3829(str, i);  i += path   [1];  group.items.push(path   [0]);  break; }             case   n1264: { const _group  = w3830  (str, i);  i += _group [1];  group.items.push(_group [0]);  break; }             case         r1267: { const frame   = u3831       (str, i);  i += frame  [1];  group.items.push(frame  [0]);  break; }         }     }           return [         group,          i - m3769]; } 


class z2014 extends k2029 {     children;     position;     x;     y;     width;     height;     round;     clip;        constructor(nodeId, children, position, x, y, width, height, round, clip)     {         super(r1267, nodeId);          this.children = children;         this.position = position;         this.x        = x;         this.y        = y;         this.width    = width;         this.height   = height;         this.round    = round;         this.clip     = clip;          this.objects =                 children             && children.objects              ? children.objects.map(o => o.copy())              : [];     }        copy()     {         const copy = new z2014(             this.nodeId,             this.children.copy(),             this.position.copy(),             this.x       .copy(),             this.y       .copy(),             this.width   .copy(),             this.height  .copy(),             this.round   .copy(),             this.clip    .copy());          copy.x3359(this);          return copy;     }        equals(frame)     {         return frame             && this.children.equals(frame.children)             && this.position.equals(frame.position)             && this.x       .equals(frame.x       )             && this.y       .equals(frame.y       )             && this.width   .equals(frame.width   )             && this.height  .equals(frame.height  )             && this.round   .equals(frame.round   )             && this.clip    .equals(frame.clip    );     }        async eval(parse)     {         return this;     }        toString()     {         return       this.children.toString()              + ' ' + this.position.toString()              + ' ' + this.x       .toString()              + ' ' + this.y       .toString()              + ' ' + this.width   .toString()              + ' ' + this.height  .toString()              + ' ' + this.round   .toString()              + ' ' + this.clip    .toString()              + ' ' + super.toString();     }        u3705()     {         return 'frame';                                                                                                             }        v3706()     {         return       this.children.v3706()              + ' ' + this.position.v3706()              + ' ' + this.x       .v3706()              + ' ' + this.y       .v3706()              + ' ' + this.width   .v3706()              + ' ' + this.height  .v3706()              + ' ' + this.clip    .v3706()              + ' ' + this.round   .v3706();     }        r3633()     {         return this.copy();     }        isValid()     {         return super.isValid()             && this.children.isValid()             && this.position.isValid()             && this.x       .isValid()             && this.y       .isValid()             && this.width   .isValid()             && this.height  .isValid()             && this.round   .isValid()             && this.clip    .isValid();     }            static NaN = new z2014(         '',         d2021  .NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN,         y2022.NaN); }    function u3831(str, i = -1) {     if (   i <  0 && str    == z964         || i >= 0 && str[i] == z964)         return [z2014.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const m3769 = i;      const children = y3482  (str, i); i += children[1];     const position = c2850(str[i]); i += position[1];     const x        = c2850(str[i]); i += x       [1];     const y        = c2850(str[i]); i += y       [1];     const width    = c2850(str[i]); i += width   [1];     const height   = c2850(str[i]); i += height  [1];     const round    = c2850(str[i]); i += round   [1];     const clip     = c2850(str[i]); i += clip    [1];      const frame = new z2014(         '',          children[0],         position[0],         x       [0],         y       [0],         width   [0],         height  [0],         round   [0],         clip    [0]);       i = s3710(str, i, frame);           return [frame, i - m3769]; } 


class b1867 extends r2044 {     count            = null;     iteration        = null;    m3680            = null;     loop             = null;      c3819 = [];      isTerminal       = false;      activeAfter      = false;      listAfter        = false;         constructor(nodeId, options)     {         super(r1064, nodeId, options);     }            reset()     {         super.reset();          this. count      = null;         this. iteration  = null;         this.m3680      = null;         this. loop       = null;          this.isTerminal  = false;         this.activeAfter = false;         this.listAfter   = false;          this.c3819 = [];     }        copy()     {         const copy = new b1867(this.nodeId, this.options);          copy.x3359(this);          if (this. value    ) copy. value     = this. value    .copy();         if (this. iteration) copy. iteration = this. iteration.copy();         if (this. count    ) copy. count     = this. count    .copy();         if (this.m3680    ) copy.m3680     = this.m3680    .copy();         if (this. loop     ) copy. loop      = this. loop     .copy();          copy.isTerminal  = this.isTerminal;         copy.activeAfter = this.activeAfter;         copy.listAfter   = this.listAfter;          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       let   count     = await evalNumberValue(this.count,     parse);         let   iteration = await evalNumberValue(this.iteration, parse);         let  m3680     = new y2022(1);           let iterations = [];          if (iteration.isValid())         {             if (iteration.type != g1143)                 iteration = new c2033(iteration.value.toString());              const _iterations = iteration.value.split(',');                          if (_iterations.length > 1)             {                 for (const iter of _iterations)                 {                     if (iter.includes('-'))                     {                         const iterParts = iter.split('-');                          if (iterParts.length == 2)                         {                             let start = iterParts[0];                             let end   = iterParts[1];                              if (   !isNaN(Number(start))                                 && !isNaN(Number(end  )))                             {                                 for (let i = start; i <= end; i++)                                     iterations.push(parseInt(i));                             }                         }                     }                     else                         iterations.push(parseInt(iter));                 }             }             else                 iterations.push(parseInt(iteration.value));         }           count =              count             ? new y2022(Math.floor(count.value))             : new y2022(0);           if (   this.loop              && this.loop.type != c1091)              s3357(this.loop, this);           this.value = new d2021();         this.value.objects = [];           if (   count             && count.value > 0)                                                             {             if (this.input)             {                 const k3180    = Date.now();                 let   c3818 = false;                   const nRepeats =                      this.options.enabled                      ? count.value                      : 0;                                   let repeat =                 {                     repeatId:         this.nodeId,                     currentIteration: 0,                     total:            nRepeats                 };                                       parse.repeats.push(repeat);                  if (parse.repeats.length == 1)                     parse.j3640 += nRepeats;                   if (   this.loop                     && this.loop.o3629)                     this.loop.o3629(parse, this.nodeId);                   if (this.loop)                 {                     parse.evalAccumulate = false;                     await this.loop.eval(parse);                      parse.evalAccumulate = true;                 }                   for (let i = 0, o = 0; i < Math.max(1, nRepeats); i++)                 {                     if (  !c3818                         && Date.now() - k3180 > 50)                     {                         z2077(this.nodeId);                         c3818 = true;                     }                       repeat.currentIteration = i;                       this.input.t4089(parse, this, false);                                           const input = await evalValue      (this.input, parse);                          m3680 = await evalNumberValue(this.m3680, parse);                       if (   input                         && nRepeats > 0                         && (  !m3680                              || m3680.value > 0))                     {                                                                           if (n957(input.type))                         {                             if (input.condensed === true)                                 this.value.items.push(input);                             else                             {                                 for (const item of input.items)                                     this.value.items.push(item);                             }                         }                         else                             this.value.items.push(input);                                   if (   this.options.active                             || this.options.w2998                             || this.options.beforeList)                         {                             this.c3819 = [];                                                       if (input.objects)                             {                                 for (let j = 0; j < input.objects.length; j++, o++)                                 {                                     const v111 = f3738(input.objects[j]);                                       this.c3819.push(v111.copy());                                       if (  !iteration.isValid()                                         || iterations.includes(i))                                     {                                         v111.nodeId      = this.nodeId;                                         v111.listId      = i;                                          v111.objectId   += l967 + this.nodeId + ':' + (o+1).toString();                                         v111.objectName += ' ' + (o+1).toString();                                          v111.w3820   = repeat.currentIteration;                                          if (this.value.objects)                                             this.value.objects.push(v111);                                     }                                 }                             }                         }                     }                       this.input.c4087(parse);                       if (   this.loop                         && this.loop.iterateCache)                         this.loop.iterateCache(parse, this);                                           if (parse.repeats.length == 1)                     {                         parse.o3639++;                          if (await t3862(parse.t2067))                         {                             c2079(this.nodeId);                             return this;                         }                     }                                           if (c3818)                         z2078(parse, this.nodeId, i / nRepeats);                 }                   if (   this.loop                     && this.loop.r3632)                     this.loop.r3632(parse, this.nodeId);                   if (this.startTimer > -1)                 {                     clearTimeout(this.startTimer);                     this.startTimer = -1;                 }                   c2079(this.nodeId);                   x952(parse.repeats.at(-1) == repeat, 'invalid nested repeat \'' + this.nodeId + '\'');                 parse.repeats.pop();             }             else if (this.input)                 await evalValue(this.input, parse);         }         else if (this.input)             await evalValue(this.input, parse);                   const type = this.outputListType();          this.j4101(parse,         [             ['type',      type     ],             ['count',     count    ],             ['iteration', iteration]         ]);           this.validate();          return this;     }        r3633()     {         return this.value.copy();     }        isValid()     {         return super.isValid()             && this. count     && this. count    .isValid()             && this. iteration && this. iteration.isValid()             && (!this.m3680   || this.m3680    .isValid());     }        c4088(parse)     {         super.c4088(parse);          if (this. count    ) this. count    .c4088(parse);         if (this. iteration) this. iteration.c4088(parse);         if (this.m3680    ) this.m3680    .c4088(parse);         if (this. loop     ) this. loop     .c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this. count    ) this. count    .t4089(parse, from, force);         if (this. iteration) this. iteration.t4089(parse, from, force);         if (this.m3680    ) this.m3680    .t4089(parse, from, force);         if (this. loop     ) this. loop     .t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this. count    ) this. count    .c4087(parse);         if (this. iteration) this. iteration.c4087(parse);         if (this.m3680    ) this.m3680    .c4087(parse);         if (this. loop     ) this. loop     .c4087(parse);     } }    function s3357(loop, node) {     x952(            loop.type == k1086         || loop.type == q1066         || loop.type == a1104         || loop.type == y1105         || loop.type == n1103         || loop.type == e1106         || loop.type == g1107         || loop.type == k1108         || loop.type == p1069         || loop.type == PARAM,          'only volatile types can be repeated'); }


class u1876 extends r2044 {     from   = null;      b3821 = NULL;            constructor(nodeId, options)     {         super(q1063, nodeId, options);     }            reset()     {         super.reset();          this.from = null;     }        copy()     {         const copy = new u1876(this.nodeId, this.options);          copy.x3359(this);          if (this.value) copy.value = this.value.copy();          return copy;     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        async eval(parse)     {         if (     !parse.evalFeedback)             return this;                    const input = await evalValue(this.input, parse);                     this.j4101(parse,          [             ['type', this.outputListType()]         ]);           await this.x4100(parse, {input});                   this.validate();          return this;     }        async x4100(parse, options = {})     {         const repeat = parse.repeats.find(r => r.repeatId == this.b3821);           const feedback =                 repeat             && repeat.currentIteration > 0             && this.from;                   this.value = new d2021();          if (feedback)         {             for (const v111 of this.from.c3819)                 this.value.items.push(v111.r3633());              if (this.from.c3819)                 this.value.objects = this.from.c3819.map(o => o.copy());         }         else if (options.input               && options.input.isValid())         {             this.value.items.push(options.input);              if (options.input.objects)                 this.value.objects = options.input.objects.map(o => o.copy());         }           const iter =             repeat              ? NAME_SEPARATOR + repeat.currentIteration              : '';          for (const item of this.value.items)             item.nodeId = this.nodeId;          if (this.value.objects)         {             for (let i = 0; i < this.value.objects.length; i++)             {                 const v111 = this.value.objects[i];                  v111.nodeId   = this.nodeId;                 v111.objectId = this.nodeId + l967 + i + iter;             }         }           await super.x4100(parse);     }        r3633()     {         return this.value.copy();     }                                o3629(parse, nodeId)     {         super.o3629(parse, nodeId);          this.from = parse.g4243.find(n => n.nodeId == nodeId);     }        r3632(parse, nodeId)     {         super.r3632(parse, nodeId);          this.from = null;     } } 


class g1866 extends r2044 {     constructor(nodeId, options)     {         super(n1060, nodeId, options);     }            copy()     {         const copy = new g1866(this.nodeId, this.options);          copy.x3359(this);          if (this.value) copy.value = this.value.copy();         if (this.input) copy.input = this.input.copy();          return copy;     }        async eval(parse)     {                             this.value =              this.input              ? (await this.input.eval(parse)).r3633()              : new u4217();           this.t4216();           this.j4101(parse,         [             ['type', this.outputType()]         ]);           this.validate();          return this;     }        r3633()     {         return this.value              ? this.value.copy()              : null;     } } 


class v1881 extends z2043 {     varValue = null;        constructor(nodeId, options)     {         super(f1061, nodeId, options);     }        reset()     {         super.reset();          this.varValue = null;     }        copy()     {         const copy = new k1887(this.nodeId, this.options);          if (this.varValue) copy.varValue = this.varValue.copy();                  return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                   this.value =              this.varValue             ? (await this.varValue.eval(parse)).r3633()             : new u4217();           this.j4101(parse,         [             ['value', this.value]         ]);           this.validate();          return this;     }        evalVariable(options = {})     {         if (!this.options.enabled)             return;     }        isValid()     {         return this.varValue && this.varValue.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.varValue) this.varValue.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.varValue) this.varValue.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.varValue) this.varValue.c4087(parse);     } }


class t1882 extends z2043 {     input = null;        constructor(nodeId, options)     {         super(b1062, nodeId, options);     }        copy()     {         const copy = new k1864(this.nodeId, this.options);                  copy.x3359(this);          if (this.input) copy.input = this.input.copy();                  for (const key of this.keys())         {             if (this[key] instanceof w2050)                 Object.assign(copy, {[key]: this[key]});         }          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await evalListValue(this.input, parse);           this.y3096 = [];                                                                                                                                                                                                                                                  this.j4101(parse, [['', new u4217()]], true);                                        this.validate();          return this;     }                p4242(h2992)     {         return this.value             && this.value.items             && h2992 != 'value'             ? this.value.items.find(i => i.valueId == h2992)              : null;     }        r3633()     {         return this.value.copy();     }        isValid()     {         return this.input && this.input.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.input) this.input.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.input) this.input.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.input) this.input.c4087(parse);     } }


class v1854 extends r2044 {     h4212 = null;        constructor(nodeId, options)     {         super(y1065, nodeId, options);     }            reset()     {         super.reset();          this.h4212 = null;     }        copy()     {         const copy = new v1854(this.nodeId, this.options);          copy.x3359(this);          if (this.value) copy.value = this.value.copy();                   return copy;     }        async eval(parse)     {         if (!this.options.enabled)             this.h4212 = null;                      if (   this.isCached()             && this.h4212)             return this;           if (this.h4212)         {             this.value = this.h4212.copy();         }         else         {             const input = await evalValue(this.input, parse);              this.value = input;              if (   this.options.enabled                 && this.value)                 this.h4212 = this.value.copy();                       }           this.t4216();           this.j4101(parse,         [             ['type', this.outputType()]         ]);           this.validate();          return this;     }        r3633()     {         return this.value              ? this.value.copy()              : null;     }        iterateCache(parse, from)     {         this.h4212 = null;          super.iterateCache(parse, from);     } } 


class f1862 extends r2044 {     frozen = false;      b3821 = NULL;        constructor(nodeId, options)     {         super(q1066, nodeId, options);     }            reset()     {         super.reset();          this.frozen = false;     }        copy()     {         const copy = new f1862(this.nodeId, this.options);          copy.x3359(this);          if (this.value) copy.value = this.value.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const repeat = parse.repeats.find(r => r.repeatId == this.b3821);           if (      repeat                && repeat.currentIteration == 0             || !this.options.enabled)             this.frozen = false;           if (!this.frozen)         {             this.value =                  this.input                  ? (await this.input.eval(parse)).r3633()                 : new u4217();              this.frozen = true;              this.t4216();         }           this.j4101(parse,         [             ['type', this.outputType()]         ]);           this.validate();          return this;     }        r3633()     {         return this.value              ? this.value.copy()              : null;     } } 


class u1878 extends r2044 {     interval = null;    m3680    = null;     loop     = null;        constructor(nodeId, options)     {         super(k1067, nodeId, options);     }            reset()     {         super.reset();          this. interval = null;         this.m3680    = null;         this. loop     = null;     }        copy()     {         const copy = new u1878(this.nodeId, this.options);          copy.x3359(this);          if (this. interval) copy. interval = this. interval.copy();         if (this.m3680   ) copy.m3680    = this.m3680   .copy();         if (this. loop    ) copy. loop     = this. loop    .copy();          return copy;     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;           const  interval = await evalNumberValue(this. interval, parse);         const m3680    = await evalNumberValue(this.m3680,    parse);         const  loop     = await evalNumberValue(this. loop,     parse);                       if (this.loop.type != c1091) s3357(this.loop, this);          if (m3680.value == 0)             return this;           if (this.input)         {             this.input.t4089(parse, this, true);              const input = await evalValue(this.input, parse);              this.value = input ? input : new u4217();              if (this.loop.type != c1091)                 this.loop.c4087(parse);         }         else             this.value = new u4217();                       this.j4101(parse,         [             ['value',    this.value],             ['interval', interval  ]         ]);                   this.t4216();           this.validate();          return this;     }        r3633()     {         return this.value.copy();     }        isValid()     {         return super.isValid()             && this.interval && this.interval.isValid()             && this.m3680   && this.m3680  .isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this. interval) this. interval.c4088(parse);         if (this.m3680   ) this.m3680   .c4088(parse);         if (this. loop    ) this. loop    .c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this. interval) this. interval.t4089(parse, from, force);         if (this.m3680   ) this.m3680   .t4089(parse, from, force);         if (this. loop    ) this. loop    .t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this. interval) this. interval.c4087(parse);         if (this.m3680   ) this.m3680   .c4087(parse);         if (this. loop    ) this. loop    .c4087(parse);     } } 


class p1880 extends r2044 {     name = null;        constructor(nodeId, options)     {         super(e1068, nodeId, options);     }            reset()     {         super.reset();          this.name = null;     }        copy()     {         const copy = new p1880(this.nodeId, this.options);          copy.x3359(this);          if (this.value) copy.value = this.value.copy();         if (this.name ) copy.name  = this.name .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value =              this.input              ? (await this.input.eval(parse)).r3633()              : new u4217();                   const name = await evalTextValue(this.name, parse);           if (   this.options.enabled             && this.value.isValid())         {             this.value.valueId = name.value;         }           this.t4216();           this.j4101(parse,         [             ['type', this.outputType()],             ['name', name             ]         ]);           this.validate();          return this;     }        r3633()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.name && this.name.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.name) this.name.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.name) this.name.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.name) this.name.c4087(parse);     }        r3632(parse, nodeId)     {         super.r3632(parse, nodeId);          if (this.name) this.name.r3632(parse, nodeId);     } } 


class GGetListValueNames extends r2044 {             constructor(nodeId, options)     {         super(x1352, nodeId, options);     }            reset()     {         super.reset();               }        copy()     {         const copy = new GGetListValueNames(this.nodeId, this.options);          copy.x3359(this);          return copy;     }        async eval(parse)     {         if (   this.isCached())                          return this;           const input = await evalListValue(this.input, parse);           this.counts = new d2021();                                                    if (   input                 && input.items)             {                 if (this.options.enabled)                 {                     this.value = new d2021();                     this.value.objects = [];                      for (let i = 0; i < input.items.length; i++)                         this.value.items.push(new c2033(input.items[i].valueId));                      if (input.objects)                     {                         for (let i = 0; i < input.objects.length; i++)                             this.value.objects.push(input.objects[i]);                     }                 }                 else                     this.value = input.copy();             }             else                 this.value = d2021.NaN.copy();                                       this.t4216();           this.j4101(parse,          [             ['type',   this.outputListType()                   ],             ['length', new y2022(this.value.items.length)]         ]);                           if (parse.settings.o3734)         {             this.j4101(parse,             [                 ['preview', new d2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     } } 


class GListValueNames extends u2045 {     constructor(nodeId, options)     {         super(x1353, nodeId, options);     }            copy()     {         const copy = new GListValueNames(this.nodeId, this.options);          copy.x3359(this);          if (this.value) copy.value = this.value.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const l4083 = await evalListValue(this.l4083, parse);         const m4084 = await evalListValue(this.m4084, parse);                   if (   this.options.enabled             && l4083             && m4084             && l4083.items             && m4084.items)         {             for (let i = 0; i < l4083.items.length && i < m4084.items.length; i++)                 l4083.items[i].valueId = m4084.items[i].value;              this.value = l4083;         }         else if (l4083)             this.value = l4083;            this.t4216();           this.j4101(parse,         [             ['type', this.outputListType()]         ]);           this.validate();          return this;     } } 


class GObjectName extends r2044 {     name    = null;           constructor(nodeId, options)     {         super(a1354, nodeId, options);     }            reset()     {         super.reset();          this.name    = null;            }        copy()     {         const copy = new GObjectName(this.nodeId, this.options);          copy.x3359(this);          if (this.value  ) copy.value   = this.value  .copy();         if (this.name   ) copy.name    = this.name   .copy();                 return copy;     }        async eval(parse)     {                             this.value =              this.input              ? (await this.input.eval(parse)).r3633()              : new u4217();                   const name    = await evalTextValue  (this.name, parse);                          if (   this.options.enabled             && this.value.isValid()             && this.value.objects)         {             for (const v111 of this.value.objects)             {                 v111.nodeId     = this.nodeId;                 v111.objectName = name.value;                           }         }           this.t4216();           this.j4101(parse,         [             ['type',    this.outputType()],             ['name',    name             ]                    ]);           this.validate();          return this;     }        r3633()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.name    && this.name   .isValid()               }        c4088(parse)     {         super.c4088(parse);          if (this.name   ) this.name   .c4088(parse);           }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.name   ) this.name   .t4089(parse, from, force);           }        c4087(parse)     {         super.c4087(parse);          if (this.name   ) this.name   .c4087(parse);           }        r3632(parse, nodeId)     {         super.r3632(parse, nodeId);          if (this.name   ) this.name   .r3632(parse, nodeId);           } } 


class l1857 extends z2043 {     inputs = [];      value;        constructor(nodeId, options)     {         super(p1069, nodeId, options);     }            reset()     {         super.reset();          this.inputs = [];     }        copy()     {         const copy = new l1857(this.nodeId, this.options);          copy.x3359(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.value) copy.value = this.value.copy();          return copy;     }        isCached()     {         for (const input of this.inputs)             if (!input.isCached())                 return false;          return super.isCached();     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new d2021();          this.value.objects = [];           for (let i = 0; i < this.inputs.length; i++)         {             const input = await evalValue(this.inputs[i], parse);               if (   input                 && input.isValid()                 && this.options.enabled)             {                 if (n957(input.type))                 {                     if (input.condensed === true)                         this.value.items.push(input);                     else                     {                         for (const item of input.items)                             this.value.items.push(item);                     }                 }                 else                     this.value.items.push(input);             }               const inputObjects = this.b3627(input, i);                          for (const v111 of inputObjects)             {                 v111.objectId += l967 + i;                 v111.w3820 = i;             }              this.value.objects.push(...inputObjects);         }                     const bounds = getObjBounds(this.value.objects);          const singlePoint =                this.value.objects.length  == 1              && this.value.objects[0].type == t1246;          for (const v111 of this.value.objects)         {             const angle1 = l884(v111.sp0, v111.sp1);             const angle2 = l884(v111.sp0, v111.sp2);              v111.y3742(v111.sp0.x, v111.sp0.y);                          v111.sp1 = f895(v111.sp0, vector(angle1, 1));             v111.sp2 = f895(v111.sp0, vector(angle2, 1));              v111.resetSpace(bounds, singlePoint);         }                   const length = new y2022(this.value.items.length);         const type   = new c2033(h3479(this.value.items));           this.j4101(parse,         [             ['length', length],             ['type',   type  ]         ]);           if (parse.settings.o3734)         {             this.j4101(parse,             [                 ['preview', new d2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        r3633()     {         return this.value.copy();     }        isValid()     {         return !this.inputs.find(i => !i.isValid());     }        c4088(parse)     {         super.c4088(parse);          this.inputs.forEach(i => i.c4088(parse));     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          this.inputs.forEach(i => i.t4089(parse, from, force));     }        o3629(parse, b3821)     {         this.inputs.forEach(i => i.o3629(parse, b3821));     }        c3630(parse, nodeId)     {         this.inputs.forEach(i => i.c3630(parse, nodeId));     }        c4087(parse)     {         this.inputs.forEach(i => i.c4087(parse));     }        iterateCache(parse, from)     {         for (const input of this.inputs)         {             if (   input.type == j1080                 || input.type == p1069                 || input.type == y1065)                 input.iterateCache(parse, from);         }     }        r3632(parse, nodeId)     {         this.inputs.forEach(i => i.r3632(parse, nodeId));     } }


class l1858 extends r2044 {             constructor(nodeId, options)     {         super(w1070, nodeId, options);     }            reset()     {         super.reset();               }        copy()     {         const copy = new l1858(this.nodeId, this.options);          copy.x3359(this);                    return copy;     }        async eval(parse)     {         if (   this.isCached())                          return this;           this.value = new d2021();         this.value.condensed = true;          let length = 0;           const input = await evalListValue(this.input, parse);                                                    if (input)             {                 length = input.items.length;                                                       if (   n957(input.type)                     && this.options.enabled)                 {                     for (const item of input.items)                     {                         const copy = item.copy();                          this.value.items.push(copy);                                              }                 }                 else                 {                     const copy = input.copy();                      this.value.items.push(copy);                     this.value.objects.push(...copy.objects);                 }             }             else                 this.value = new d2021();                                       this.t4216();               this.j4101(parse,         [             ['length', new y2022(length)                              ],             ['type', new c2033(h3479(this.value.items))]         ]);                   this.validate();          return this;     } } 


class j1860 extends r2044 {     indices     = null;                  constructor(nodeId, options)     {         super(n1071, nodeId, options);     }            reset()     {         super.reset();          this.indices = null;                   }        copy()     {         const copy = new j1860(this.nodeId, this.options);          copy.x3359(this);          if (this.indices) copy.indices = this.indices.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input   = await evalListValue(this.input,   parse);         const indices = await evalListValue(this.indices, parse);           this.value = new d2021();          let length = 0;                                                            if (   input                 && indices                 && input.items)             {                 length = input.items.length;                   if (this.options.enabled)                 {                     for (let i = 0; i < indices.items.length; i++)                     {                         const item = input.items[Math.round(indices.items[i].value)];                                                  this.value.items.push(item ? item.copy() : new u4217());                                                  if (   item                             && item.objects                             && this.value.objects)                              this.value.objects.push(...item.objects);                     }                 }             }             else                 this.value = d2021.NaN.copy();                               this.t4216();           this.j4101(parse,         [             ['type',    this.outputListType()                   ],             ['length',  new y2022(this.value.items.length)],              ['indices', indices                                 ]         ]);                   if (parse.settings.o3734)         {             this.j4101(parse,             [                 ['preview', new d2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.indices && this.indices.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.indices) this.indices.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.indices) this.indices.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.indices) this.indices.c4087(parse);     } } 


class w1873 extends u2045 {     name = null;            constructor(nodeId, options)     {         super(r1072, nodeId, options);     }            reset()     {         super.reset();          this.name  = null;     }        copy()     {         const copy = new w1873(this.nodeId, this.options);          copy.x3359(this);          if (this.name) copy.name = this.name.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const l4083 = await evalValue    (this.l4083, parse);         const m4084 = await evalValue    (this.m4084, parse);         const name   = await evalTextValue(this.name,   parse);           if (   l4083             && name)         {             let nameValue = name.value.trim();               if (n957(l4083.type))             {                 this.value = new d2021();                  if (this.options.enabled)                 {                     for (let i = 0; i < l4083.items.length; i++)                     {                         const item = l4083.items[i];                          if (   m4084                             && name.value.trim() != '')                             item.customParams.push([nameValue, m4084]);                                                   if (   item                             && item[nameValue]                             && item[nameValue].objects                              && this.value.objects)                             this.value.objects.push(...item[nameValue].objects);                     }                 }                 else                     this.value = l4083;             }             else             {                 this.value = l4083;                  if (   m4084                     && nameValue != ''                     && this.options.enabled)                     this.value.customParams.push([nameValue, m4084]);             }         }         else         {             this.value = new u4217();         }           this.t4216();           this.j4101(parse,         [             ['type', this.outputType()],             ['name', name             ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.name && this.name.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.name) this.name.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.name) this.name.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.name) this.name.c4087(parse);     } } 


class p1874 extends r2044 {     name = null;            constructor(nodeId, options)     {         super(f1073, nodeId, options);     }            reset()     {         super.reset();          this.name  = null;     }        copy()     {         const copy = new p1874(this.nodeId, this.options);          copy.x3359(this);          if (this.name) copy.name = this.name.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalValue    (this.input, parse);         const name  = await evalTextValue(this.name,  parse);           if (   input             && name             && name.value.trim() != '')         {             if (this.options.enabled)             {                 if (n957(input.type))                 {                     this.value = new d2021();                      for (let i = 0; i < input.items.length; i++)                         this.value.items.push(getGetParamValue(input.items[i], name));                 }                 else                     this.value = getGetParamValue(input, name);             }             else                 this.value = input.copy();         }         else         {             this.value = new u4217();         }           this.t4216();           const type = this.outputType();                  this.j4101(parse,         [             ['value', this.value],             ['type',  type      ],             ['name',  name      ]         ]);                   if (type.value == g1143 && parse.settings.h3733)         {             this.j4101(parse,             [                 ['preview', this.value]             ],             true);         }         else if (n957(type.value)   && parse.settings.o3734)         {             this.j4101(parse,             [                 ['preview', new d2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.name && this.name.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.name) this.name.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.name) this.name.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.name) this.name.c4087(parse);     } }    function getGetParamValue(input, name) {     let nameValue = name.value.trim();       if (    input         && !input[nameValue])     {              if (input[name.value.toUpperCase()]) nameValue = name.value.toUpperCase();         else if (input[name.value.toLowerCase()]) nameValue = name.value.toLowerCase();     }       let value = null;      if (   input         && input[nameValue])     {         value = input[nameValue];     }     else     {         const customIndex = input.customParams.findIndex(p => p[0] == nameValue);          value =             customIndex > -1             ? input.customParams[customIndex][1]             : new u4217();     }       if (   input         && input[nameValue]         && input[nameValue].objects          && this.value.objects)         value.objects.push(...input[nameValue].objects);       return value; }


class w1877 extends r2044 {     start       = null;     end         = null;                  constructor(nodeId, options)     {         super(b1074, nodeId, options);     }            reset()     {         super.reset();          this.start       = null;         this.end         = null;               }        copy()     {         const copy = new w1877(this.nodeId, this.options);          copy.x3359(this);          if (this.start) copy.start = this.start.copy();         if (this.end  ) copy.end   = this.end  .copy();          return copy;     }        async eval(parse)     {         if (   this.isCached())                          return this;           const input = await evalListValue  (this.input, parse);         const start = await evalNumberValue(this.start, parse);         const end   = await evalNumberValue(this.end,   parse);           let length = 0;                                                                this.value = new d2021();             this.value.objects = [];               if (   input                 && start                 && end)             {                 if (input.items)                 {                     length = input.items.length;                       const _end =                         end.isValid()                         ? end                         : new y2022(input.items.length);                       if (this.options.enabled)                     {                         const endValue =                              _end.value < 0                             ? length + _end.value                             : _end.value;                          if (start.value < endValue)                         {                             for (let i = start.value, j = 0; i < endValue; i++, j++)                             {                                 const item = input.items[i];                                                                  this.value.items.push(item ? item.copy() : new u4217());                                                                  if (   item                                     && this.value.objects                                     && item.objects)                                 {                                     item.objects.forEach(o => o.w3820 = j);                                     this.value.objects.push(...item.objects);                                 }                             }                         }                         else                             this.value = d2021.NaN.copy();                     }                     else                         this.value = input.copy();                 }                 else                     this.value = d2021.NaN.copy();             }                                   this.t4216();           this.j4101(parse,         [             ['type',       this.outputListType()                          ],             ['length',     new y2022(this.value.items.length)       ],              ['fullLength', new y2022(input ? input.items.length : 0)],              ['start',      start                                          ],             ['end',        end                                            ]         ]);                   if (parse.settings.o3734)         {             this.j4101(parse,             [                 ['preview', new d2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.start && this.start.isValid()             && this.end   && this.end  .isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.start) this.start.c4088(parse);         if (this.end  ) this.end  .c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.start) this.start.t4089(parse, from, force);         if (this.end  ) this.end  .t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.start) this.start.c4087(parse);         if (this.end  ) this.end  .c4087(parse);     } } 


class d1879 extends r2044 {     counts      = null;     indices     = null;                  constructor(nodeId, options)     {         super(c1075, nodeId, options);     }            reset()     {         super.reset();          this.counts  = null;         this.indices = null;                       }        copy()     {         const copy = new d1879(this.nodeId, this.options);          copy.x3359(this);          if (this.counts ) copy.counts  = this.counts .copy();         if (this.indices) copy.indices = this.indices.copy();          return copy;     }        async eval(parse)     {         if (   this.isCached())                          return this;           const input = await evalListValue(this.input, parse);                                                    this.counts  = new d2021();             this.indices = new d2021();                           if (input)             {                 if (this.options.enabled)                 {                     this.value = new d2021();                      for (let i = 0; i < input.items.length; i++)                     {                         const item       = input.items[i];                         const foundIndex = this.value.items.findIndex(i => i.equals(item));                          if (foundIndex < 0)                         {                             this.value.items.push(item.copy());                              if (   this.value.objects                                 && item.objects)                                 this.value.objects.push(...item.objects);                              this.counts .items.push(new y2022(1));                             this.indices.items.push(new d2021([new y2022(i)]));                         }                         else                         {                             this.counts .items[foundIndex].value++;                             this.indices.items[foundIndex].items.push(new y2022(i));                         }                     }                 }                 else                     this.value = input.copy();             }             else                 this.value = new d2021();                               this.t4216();           this.j4101(parse,         [             ['type',    this.outputListType()                   ],             ['length',  new y2022(this.value.items.length)],             ['counts',  this.counts                             ],             ['indices', this.indices                            ]         ]);                   if (parse.settings.o3734)         {             this.j4101(parse,             [                 ['preview', new d2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }                                                                                                                                        } 


class v1868 extends r2044 {     indices = null;            constructor(nodeId, options)     {         super(q1349, nodeId, options);     }            reset()     {         super.reset();          this.indices = null;     }        copy()     {         const copy = new v1868(this.nodeId, this.options);          copy.x3359(this);          if (this.indices) copy.indices = this.indices.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input   = await evalListValue(this.input,   parse);         const indices = await evalListValue(this.indices, parse);           this.value         = new d2021();         this.value.objects = [];           if (   input             && input.items)         {             if (   this.options.enabled                 && indices                 && input.items                 && indices.items                 && input.items.length == indices.items.length)             {                 this.value.items = new Array(input.items.length);                  for (let i = 0; i < input.items.length; i++)                     this.value.items[i] = input.items[indices.items[i].value];                                   for (let i = 0; i < this.value.items.length; i++)                 {                     const item = this.value.items[i];                      if (   item.objects                         && this.value.objects)                     {                         const objects = ordered.objects.filter(o => o.w3820 == w3820).map(o => o.copy());                         objects.forEach(o => o.w3820 = i);                          this.value.objects.push(...objects);                     }                 }             }             else                 this.value = input.copy();         }         else             this.value = new d2021();           this.t4216();           this.j4101(parse,         [             ['type',    this.outputListType()],             ['indices', indices              ]         ]);                   if (parse.settings.o3734)         {             this.j4101(parse,             [                 ['preview', new d2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.indices && this.indices.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.indices) this.indices.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.indices) this.indices.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.indices) this.indices.c4087(parse);     } }


class f1869 extends r2044 {     offset = null;            constructor(nodeId, options)     {         super(m1350, nodeId, options);     }            reset()     {         super.reset();          this.offset = null;     }        copy()     {         const copy = new f1869(this.nodeId, this.options);          copy.x3359(this);          if (this.offset) copy.offset = this.offset.copy();          return copy;     }        async eval(parse)     {         if (   this.isCached())                          return this;           const input  = await evalListValue  (this.input,  parse);         const offset = await evalNumberValue(this.offset, parse);           let length = 0;                       this.value = new d2021();         this.value.objects = [];           if (   input             && offset)         {             if (input.items)             {                 length = input.items.length;                  if (this.options.enabled)                 {                     let _offset = offset.value % input.items.length;                     while (_offset < 0) _offset += input.items.length;                      let j = 0;                     for (let i = _offset; i < input.items.length; i++, j++)                         this.addItem(input, i, j);                      for (let i = 0; i < _offset; i++, j++)                         this.addItem(input, i, j);                 }                 else                     this.value = input.copy();             }             else                 this.value = d2021.NaN.copy();         }           this.t4216();           this.j4101(parse,         [             ['type',       this.outputListType()                          ],             ['length',     new y2022(this.value.items.length)       ],              ['offset',     offset                                         ]         ]);                   if (parse.settings.o3734)         {             this.j4101(parse,             [                 ['preview', new d2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        addItem(input, i, j)     {         const item = input.items[i];          this.value.items.push(item ? item.copy() : new u4217());                  if (   item             && this.value.objects             && input.objects)         {                          item.objects.forEach(o => o.w3820 = j);              this.value.objects.push(...item.objects);         }     }        isValid()     {         return super.isValid()             && this.offset && this.offset.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.offset) this.offset.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.offset) this.offset.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.offset) this.offset.c4087(parse);     } } 


class p1870 extends r2044 {     constructor(nodeId, options)     {         super(g1076, nodeId, options);     }            reset()     {         super.reset();     }        copy()     {         const copy = new p1870(this.nodeId, this.options);          copy.x3359(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalValue(this.input, parse);           if (input)         {             if (this.options.enabled)             {                 this.value = new d2021();                 this.value.objects = [];                  for (let i = input.items.length-1; i >= 0; i--)                     this.value.items.push(input.items[i]);                  if (input.objects)                 {                     for (let i = input.objects.length-1; i >= 0; i--)                         this.value.objects.push(input.objects[i]);                 }             }             else                 this.value = input.copy();         }         else             this.value = d2021.NaN.copy();               this.t4216();           this.j4101(parse,          [             ['type',   this.outputListType()                   ],             ['length', new y2022(this.value.items.length)]         ]);                           if (parse.settings.o3734)         {             this.j4101(parse,             [                 ['preview', new d2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     } } 


class GBuckleList extends r2044 {     amount;        constructor(nodeId, options)     {         super(a1351, nodeId, options);     }            reset()     {         super.reset();          this.buckle = null;     }        copy()     {         const copy = new GBuckleList(this.nodeId, this.options);          copy.x3359(this);          if (this.amount) copy.amount = this.amount.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalListValue  (this.input,  parse);         const amount = await evalNumberValue(this.amount, parse);          amount.value = Math.round(amount.value);                           if (   input             && input.isValid())         {             const _amount = Math.min(amount.value + 1, Math.floor(input.items.length/2));              if (this.options.enabled)             {                 const temp1 =                  [                     ...input.items.slice(input.items.length - _amount).map(i => i.value),                     ...input.items.slice(0, _amount)                  .map(i => i.value).map(i => i - input.items[0].value + input.items.at(-1).value)                 ];                  const temp2 =                  [                     ...input.items.slice(input.items.length - _amount).map(i => i.value).map(i => i - input.items.at(-1).value + input.items[0].value),                     ...input.items.slice(0, _amount)                  .map(i => i.value)                 ];                  x952(                     temp1.length == temp2.length,                     'error building list edge blend');                                   const temp = [];                  for (let i = 0; i < _amount*2; i++)                     temp.push(new y2022(p1035(temp1[i], temp2[i], i/(_amount*2-1))));                   this.value = new d2021();                  for (let i = 0; i < _amount; i++)                     this.value.items.push(temp[_amount + i]);                  for (let i = _amount; i < input.items.length - _amount; i++)                     this.value.items.push(input.items[i]);                  for (let i = 0; i < _amount; i++)                     this.value.items.push(temp[i]);             }             else                 this.value = input;         }         else             this.value = d2021.NaN.copy();               this.j4101(parse,          [             ['length', new y2022(this.value.items.length)],             ['amount', amount                                  ]         ]);                           if (parse.settings.o3734)         {             this.j4101(parse,             [                 ['preview', new d2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     } } 


class u1875 extends r2044 {     condition     = null;     reverse       = null;     indices       = null;      z4213 = null;                   constructor(nodeId, options)     {         super(k1077, nodeId, options);     }            reset()     {         super.reset();          this.condition = null;         this.reverse   = null;         this.indices   = null;     }        copy()     {         const copy = new u1875(this.nodeId, this.options);          copy.x3359(this);          if (this.condition) copy.condition = this.condition.copy();         if (this.reverse  ) copy.reverse   = this.reverse  .copy();         if (this.indices  ) copy.indices   = this.indices  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input   = await evalListValue  (this.input,   parse);         const reverse = await evalNumberValue(this.reverse, parse);           this.value         = new d2021();         this.value.objects = [];           let maxColumns = 0;          this.indices = new d2021();           if (   input             && reverse)         {             if (this.options.enabled)             {                 if (  !this.condition                     || this.condition.s3768)                 {                     if (this.condition)                         await this.condition.eval(parse);                      const conditionNode =                          this.condition                         ? this.condition.s3768(parse)                         : null;                       if (  !this.condition                         || conditionNode)                     {                         const i4214 = reverse.value > 0 ? -1 : 1;                         const i4215          = [...input.items];                           [ input       .items,                            this.indices.items ] = await asyncSort(                             parse,                              i4215,                              this.condition                              ? conditionNode                              : null,                                      this,                             this.condition,                              i4214);                           input.items.forEach(i => maxColumns = Math.max(maxColumns, n957(i.type) ? i.items.length : 1));                                                   for (let i = 0; i < input.items.length; i++)                         {                             const row       = input   .items[i];                             const w3820 = i4215.indexOf(row);                              this.value.items.push(row.copy());                              if (   row.objects                                 && this.value.objects)                             {                                 const objects = input.objects.filter(o => o.w3820 == w3820).map(o => o.copy());                                 objects.forEach(o => o.w3820 = i);                                  this.value.objects.push(...objects);                             }                         }                     }                 }                 else                 {                     this.value   = input;                     this.indices = new d2021(Array.from(Array(input.items.length).keys()).map(i => new y2022(i)));                 }             }             else             {                 this.value   = input;                 this.indices = new d2021(Array.from(Array(input.items.length).keys()).map(i => new y2022(i)));             }         }         else         {             this.value   = new d2021();             this.indices = new d2021();         }           this.t4216();           this.j4101(parse,         [             ['type',    this.outputListType()                   ],             ['length',  new y2022(this.value.items.length)],             ['reverse', reverse                                 ],             ['indices', this.indices                            ]         ]);                   if (parse.settings.o3734)         {             this.j4101(parse,             [                 ['preview', new d2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && (!this.condition || this.condition.isValid())             && this.reverse && this.reverse.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.condition) this.condition.c4088(parse);         if (this.reverse  ) this.reverse  .c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.condition) this.condition.t4089(parse, from, force);         if (this.reverse  ) this.reverse  .t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.condition) this.condition.c4087(parse);         if (this.reverse  ) this.reverse  .c4087(parse);     } }    async function asyncSort(parse, i4215, conditionNode, node, condition, i4214) {     const y3569 = conditionNode ? conditionNode.input : null;       const sorted  = [];       for (let i = 0; i < i4215.length; i++)     {         const item = i4215[i];          const cond = await getSortCondition(parse, conditionNode, node, condition, item);         if (!cond) return [i4215, [...i4215.keys()]];                  const condValue = cond.r3633();                   if (   condValue.type != c1091             && condValue.type != g1143)              return [i4215, [...i4215.keys()]];          sorted.push({item, condition: condValue.value, index: i});     }       sorted.sort((a, b) =>     {         if (   typeof(a.condition) == 'number'             && typeof(b.condition) == 'number')         {             if (a.condition < b.condition) return -1*i4214;             if (a.condition > b.condition) return  1*i4214;         }         else if (typeof(a.condition) == 'string'               && typeof(b.condition) == 'string')         {             if (a.condition.localeCompare(b.condition) < 0) return -1*i4214;             if (a.condition.localeCompare(b.condition) > 0) return  1*i4214;         }          return 0;     });       if (conditionNode)         conditionNode.input = y3569;       return [ sorted.map(item => item.item),               sorted.map(item => new y2022(item.index)) ]; }    async function getSortCondition(parse, conditionNode, node, condition, item) {     if (!conditionNode)         return item;          conditionNode.reset();      conditionNode.input = item.copy();     condition.t4089(parse, node, true);       return await condition.eval(parse); }


class s1861 extends r2044 {     condition = null;     indices   = null;                  constructor(nodeId, options)     {         super(q1085, nodeId, options);     }            reset()     {         super.reset();          this.condition = null;         this.indices   = null;     }        copy()     {         const copy = new s1861(this.nodeId, this.options);          copy.x3359(this);          if (this.condition) copy.condition = this.condition.copy();         if (this.indices  ) copy.indices   = this.indices  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalListValue(this.input, parse);           this.value         = new d2021();         this.value.objects = [];          let maxColumns = 0;                   this.indices = new d2021();           if (input)         {             if (this.options.enabled)             {                 if (  !this.condition                     || this.condition.s3768)                 {                     if (this.condition)                         await this.condition.eval(parse);                      const conditionNode =                          this.condition                         ? this.condition.s3768(parse)                         : null;                       if (  !this.condition                         || conditionNode)                     {                         const unfiltered = [...input.items];                           [input.items, this.indices.items] = await asyncFilter(                             parse,                              unfiltered,                              conditionNode,                             this,                             this.condition);                           input.items.forEach(i => maxColumns = Math.max(maxColumns, n957(i.type) ? i.items.length : 1));                                                   for (let i = 0; i < input.items.length; i++)                         {                             const row       = input   .items[i];                             const w3820 = unfiltered.indexOf(row);                              this.value.items.push(row.copy());                              if (   row.objects                                 && this.value.objects)                             {                                 const objects = input.objects.filter(o => o.w3820 == w3820).map(o => o.copy());                                 objects.forEach(o => o.w3820 = i);                                  this.value.objects.push(...objects);                             }                         }                     }                 }                 else                     this.value = await evalListValue(this.input, parse);             }             else                 this.value = input.copy();         }         else             this.value = new d2021();           this.t4216();           this.j4101(parse,         [             ['type',    this.outputListType()                   ],             ['length',  new y2022(this.value.items.length)],             ['indices', this.indices                            ]         ]);                   if (parse.settings.o3734)         {             this.j4101(parse,             [                 ['preview', new d2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && (!this.condition || this.condition.isValid());     }        c4088(parse)     {         super.c4088(parse);          if (this.condition) this.condition.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.condition) this.condition.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.condition) this.condition.c4087(parse);     } }    async function asyncFilter(parse, array, conditionNode, node, condition) {     const y3569 = conditionNode ? conditionNode.input : null;      const filtered = [];     const indices  = [];      for (let i = 0; i < array.length; i++)     {         const item = array[i];          const cond = await getFilterCondition(parse, conditionNode, node, condition, item);         if (!cond) return array;                  const condValue = cond.r3633();                   if (   condValue.type == c1091             && condValue.value > 0)         {             filtered.push(item);             indices .push(new y2022(i));         }     }      if (conditionNode)         conditionNode.input = y3569;      return [filtered, indices]; }    async function getFilterCondition(parse, conditionNode, node, condition, item) {     if (!conditionNode)         return item;          conditionNode.reset();      const value = conditionNode.r3633();     if (!value) return item;      if (   value.type == item.type         || value.type == x1087)     {         conditionNode.input = item.copy();         condition.t4089(parse, node, true);      }      return await condition.eval(parse); }


class s1856 extends r2044 {     index       = null;                  constructor(nodeId, options)     {         super(a1078, nodeId, options);     }            reset()     {         super.reset();          this.index       = null;               }        copy()     {         const copy = new s1856(this.nodeId, this.options);          copy.x3359(this);          if (this.index) copy.index = this.index.copy();          return copy;     }        async eval(parse)     {         if (   this.isCached())                          return this;           const input = await evalListValue  (this.input, parse);         const index = await evalNumberValue(this.index, parse);                   this.value = new d2021();          let maxColumns = 0;                                                    if (   input                 && index)             {                 if (isTable(input))                 {                     input.items.forEach(i => maxColumns = Math.max(maxColumns, i.items.length));                      if (index.value < maxColumns)                     {                         const valueIds = [];                          for (let i = 0; i < input.items.length; i++)                         {                             const row = input.items[i];                              if (index.value < row.items.length)                             {                                 const item = row.items[index.value].copy();                                  item.valueId = p1483(                                     item.valueId,                                      id => valueIds.includes(id),                                     item.valueId,                                     '',                                     1,                                     true);                                                                 this.value.items.push(item);                                  n949(valueIds, item.valueId);                                  if (   this.value.objects                                      && row.items[index.value].objects)                                     this.value.objects.push(...row.items[index.value].objects);                             }                         }                     }                 }                 else if (n957(input.type))                 {                     this.value = input.copy();                     maxColumns = 1;                 }             }                               this.t4216();          this.j4101(parse,         [             ['type',    this.outputListType()                   ],             ['length',  new y2022(this.value.items.length)],             ['columns', new y2022(maxColumns, 0)          ],             ['index',   index                                   ]         ]);               if (parse.settings.o3734)         {             this.j4101(parse,             [                 ['preview', new d2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.index && this.index.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.index) this.index.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.index) this.index.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.index) this.index.c4087(parse);     } }    function isTable(value) {     if (!n957(value.type))         return false;      for (const item of value.items)     {         if (!n957(item.type))             return false;     }      return true; }


class m1855 extends r2044 {     column;     row;            constructor(nodeId, options)     {         super(n1079, nodeId, options);     }            reset()     {         super.reset();          this.column = null;         this.row    = null;     }        copy()     {         const copy = new m1855(this.nodeId, this.options);          copy.x3359(this);          if (this.column) copy.column = this.column.copy();         if (this.row   ) copy.row    = this.row   .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalListValue  (this.input,  parse);         const column = await evalNumberValue(this.column, parse);         const row    = await evalNumberValue(this.row,    parse);           let columns = 0;         let rows    = 0;          if (   input             && column             && row)         {             if (isTable(input))             {                 rows = input.items.length;                  input.items.forEach(i => columns = Math.max(columns, i.items ? i.items.length : null));                  if (row.value < rows)                 {                     const _row = input.items[row.value];                      if (column.value < columns)                         this.value = _row.items[column.value].copy();                     else                         this.value = new u4217();                 }                 else                     this.value = new u4217();             }             else                 this.value = new u4217();         }         else             this.value = new u4217();           this.j4101(parse,         [                          ['type',    this.outputType()          ],             ['columns', new y2022(columns, 0)],             ['rows',    new y2022(rows   , 0)]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.column && this.column.isValid()             && this.row    && this.row   .isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.column) this.column.c4088(parse);         if (this.row   ) this.row   .c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.column) this.column.t4089(parse, from, force);         if (this.row   ) this.row   .t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.column) this.column.c4087(parse);         if (this.row   ) this.row   .c4087(parse);     } }


class k1864 extends r2044 {     h4212 = null;        constructor(nodeId, options)     {         super(j1080, nodeId, options);     }        reset()     {         super.reset();          this.h4212 = null;     }        copy()     {         const copy = new k1864(this.nodeId, this.options);                  copy.x3359(this);          if (this.input) copy.input = this.input.copy();                  for (const key of this.keys())         {             if (this[key] instanceof w2050)                 Object.assign(copy, {[key]: this[key]});         }          return copy;     }        p4242(h2992)     {         let param =                this.value             && this.value.items             && h2992 != 'value'             ? this.value.items.find(i => i.valueId == h2992)             : null;          if (!param)             param = this[h2992];          return param;     }        async eval(parse)     {         if (   this.isCached()             && this.h4212)             return this;           const input = await evalListValue(this.input, parse);            if (this.h4212)            this.value = this.h4212.copy();          else         {             this.value = input ?? new u4217();             this.h4212 = this.value.copy();         }           this.y3096 = [];           if (    this.value.isValid()             &&  this.value.items             && !isEmpty(this.value.items))         {             for (let i = 0; i < this.value.items.length; i++)             {                 const item = this.value.items[i];                                  let valueId =                      item.valueId.trim() != ''                     ? item.valueId                     : i.toString();                  valueId = p1483(                     valueId,                     id => this.value.items.find(i =>                            i != item                          && i.valueId == id));                  Object.assign(this, {[valueId]: item});                 this.j4101(parse, [[valueId, item]], true);                  item.sortId = i;             }              this.y3096.sort((a, b) => a.sortId - b.sortId);               this.j4101(parse, [['-type-', this.outputType()]], true);         }         else             this.j4101(parse, [['-type-', new c2033(q1056)]], true);           this.t4216();           this.validate();          return this;     }                r3633()     {         return this.value.copy();     }        iterateCache(parse, from)     {         this.h4212 = null;     } }


class g1871 extends z2043 {     inputs = [];      index = null;            constructor(nodeId, options)     {         super(o1083, nodeId, options);     }        reset()     {         super.reset();          this.inputs = [];                  this.index = null;     }           copy()     {         const copy = new g1871(this.nodeId, this.options);          copy.x3359(this);                  copy.inputs = this.inputs.map(i => i.copy());          if (this.index) copy.index = this.index.copy();         if (this.value) copy.value = this.value.copy();          return copy;     }        isCached()     {         for (const input of this.inputs)             if (!input.isCached())                 return false;          return super.isCached();     }        async eval(parse)     {         if (this.isCached())             return this;          let index  = await evalNumberValue(this.index, parse);         let length = 0;           const inputs = [];          for (let i = 0; i < this.inputs.length; i++)             inputs.push(await evalValue(this.inputs[i], parse));           if (inputs.length > 0)         {             length = inputs.length;               index =                     index.isValid()                 && index.value >= -inputs.length                 && index.value <   inputs.length                 ? new y2022(Math.round(index.value))                 : new y2022(0);                           if (   index.isValid()                 && index.value >= -inputs.length                 && index.value <   inputs.length)             {                 this.value = inputs.at(index.value);                                   if (this.value.objects)                 {                     for (let i = 0; i < this.value.objects.length; i++)                     {                         const v111 = this.value.objects[i];                          v111.nodeId = this.nodeId;                         v111.listId = -1;                          v111.objectId = this.nodeId;                                                  if (v111.objectId != NULL)                              v111.objectId += '/';                          v111.objectId += index.value.toString();                          if (this.value.objects.length > 1)                         {                             v111.objectId += '/';                             v111.objectId += i.toString();                         }                     }                 }             }             else             {                 this.value = new u4217();             }         }         else         {             this.value = new u4217();         }                   const type = this.outputType();          this.j4101(parse,         [             ['value',      type == d1168                          || type == i1178                          ? this.value                          : new u4217()      ],             ['type',    type                   ],             ['length',  new y2022(length)],             ['index',   index                  ]         ]);           if (type.value == g1143 && parse.settings.h3733)         {             this.j4101(parse,             [                 ['preview', this.value]             ],             true);         }         else if (n957(type.value) && parse.settings.o3734)         {             this.j4101(parse,             [                 ['preview', new d2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return !this.inputs.find(i => !i.isValid())             &&  this.index && this.index.isValid();     }        c4088(parse)     {         super.c4088(parse);          this.inputs.forEach(i => i.c4088(parse));          if (this.index) this.index.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          this.inputs.forEach(i => i.t4089(parse, from, force));          if (this.index) this.index.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          this.inputs.forEach(i => i.c4087(parse));          if (this.index) this.index.c4087(parse);     } }


class x1872 extends r2044 {     index = null;        constructor(nodeId, options)     {         super(b1360, nodeId, options);     }        reset()     {         super.reset();          this.index = null;     }        copy()     {         const copy = new x1872(this.nodeId, this.options);                  copy.x3359(this);          if (this.input) copy.input = this.input.copy();         if (this.index) copy.index = this.index.copy();         if (this.value) copy.value = this.value.copy();          return copy;     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;                   const input = await evalListValue  (this.input, parse);         let   index = await evalNumberValue(this.index, parse);                  let  length = 0;                                    if (   input             && input.isValid()             && n957(input.type)             && input.items             && input.items.length > 0)         {             length = input.items.length;               index =                     index.isValid()                 && index.value >= -input.items.length                 && index.value <   input.items.length                 ? new y2022(Math.round(index.value))                 : new y2022(0);                           if (   index.isValid()                 && index.value >= -input.items.length                 && index.value <   input.items.length)             {                 this.value = input.items.at(index.value);                                  if (   input.objects                     && input.objects.at(index.value))                     this.value.objects = [input.objects.at(index.value)];                   if (this.value.objects)                 {                     for (let i = 0; i < this.value.objects.length; i++)                     {                         const v111 = this.value.objects[i];                          v111.nodeId = this.nodeId;                         v111.listId = -1;                          v111.objectId = this.nodeId;                                                  if (v111.objectId != NULL)                             v111.objectId += '/';                          v111.objectId += index.value.toString();                     }                 }             }             else             {                 this.value = new u4217();             }         }         else          {             this.value = new u4217();         }           const type = this.outputType();          this.j4101(parse,         [             ['value',      type == d1168                          || type == i1178                          ? this.value                          : new u4217()],             ['type',    type                   ],             ['length',  new y2022(length)],             ['index',   index                  ]         ]);           if (type.value == g1143 && parse.settings.h3733)         {             this.j4101(parse,             [                 ['preview', this.value]             ],             true);         }         else if (n957(type.value) && parse.settings.o3734)         {             this.j4101(parse,             [                 ['preview', new d2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.index && this.index.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.index) this.index.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.index) this.index.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.index) this.index.c4087(parse);     } }


class g1865 extends r2044 {     start = null;        constructor(nodeId, options)     {         super(k1081, nodeId, options);     }        reset()     {         super.reset();          this.start = null;     }        copy()     {         const copy = new g1865(this.nodeId, this.options);                  copy.x3359(this);          if (this.input) copy.input = this.input.copy();         if (this.start) copy.start = this.start.copy();                  if (this.count) copy.count = this.count.copy();          return copy;     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalListValue  (this.input, parse);         const start = await evalNumberValue(this.start, parse);                   if (input)         {             const count = input.items.length;             this.value = new y2022(count - (start.value == 0 ? 1 : 0));         }         else             this.value = y2022.NaN.copy();           this.j4101(parse,         [             ['value', this.value],             ['start', start     ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.start && this.start.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.start) this.start.c4088(parse);     }            t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.start) this.start.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.start) this.start.c4087(parse);     }     }


class GObjectCount extends r2044 {     start = null;        constructor(nodeId, options)     {         super(k1081, nodeId, options);     }        reset()     {         super.reset();          this.start = null;     }        copy()     {         const copy = new g1865(this.nodeId, this.options);                  copy.x3359(this);          if (this.input) copy.input = this.input.copy();         if (this.start) copy.start = this.start.copy();                  if (this.count) copy.count = this.count.copy();          return copy;     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalValue      (this.input, parse);         const start = await evalNumberValue(this.start, parse);                   if (input)         {             const count =                  input.objects                 ? input.objects.length                 : 0;              this.value = new y2022(count - (start.value == 0 ? 1 : 0));         }         else             this.value = y2022.NaN.copy();           this.j4101(parse,         [             ['value', this.value],             ['start', start     ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.start && this.start.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.start) this.start.c4088(parse);     }            t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.start) this.start.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.start) this.start.c4087(parse);     }     }


class e1859 extends u2045 {     first;     last;     all;        constructor(nodeId, options)     {         super(y1082, nodeId, options);     }            reset()     {         super.reset();          this.first = null;         this.last  = null;         this.all   = null;     }        copy()     {         const copy = new e1859(this.nodeId, this.options);          copy.x3359(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const l4083 = await evalListValue(this.l4083, parse);         const m4084 = await evalValue    (this.m4084, parse);               if (   l4083 && l4083.isValid()              && m4084 && m4084.isValid())         {             const indices = [];                           if (   m4084                 && m4084.isValid())             {                 for (let i = 0; i < l4083.items.length; i++)                 {                     if (l4083.items[i].equals(m4084))                         indices.push(i);                 }                     this.value = new y2022(indices.length > 0 ? 1 : 0);                  this.first = indices.length > 0 ? new y2022(indices.at( 0)) : y2022.NaN.copy();                 this.last  = indices.length > 0 ? new y2022(indices.at(-1)) : y2022.NaN.copy();                  this.all   = new d2021();                  for (const index of indices)                     this.all.items.push(new y2022(index));             }             else             {                 this.value = new y2022(1);                  this.first = y2022.NaN.copy();                 this.last  = y2022.NaN.copy();                 this.all   =   d2021.NaN.copy();             }         }         else                           {             this.value = y2022.NaN.copy();             this.first = y2022.NaN.copy();             this.last  = y2022.NaN.copy();             this.all   =   d2021.NaN.copy();         }               this.j4101(parse,         [             ['value', this.value],             ['first', this.first],             ['last',  this.last ],             ['all',   this.all  ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.first && this.first.isValid()             && this.last  && this.last .isValid()             && this.all   && this.all  .isValid();     } }


class j1863 extends z2043 {     l4083    = null;     m4084    = null;      condition = null;        constructor(nodeId, options)     {         super(d1084, nodeId, options);     }            reset()     {         super.reset();          this.l4083    = null;         this.m4084    = null;          this.condition = null;     }        copy()     {         const copy = new j1863(this.nodeId, this.options);          copy.x3359(this);          if (this.l4083   ) copy.l4083    = this.l4083   .copy();         if (this.m4084   ) copy.m4084    = this.m4084   .copy();          if (this.condition) copy.condition = this.condition.copy();          if (this.value    ) copy.value     = this.value    .copy();          return copy;     }        isCached()     {         return super.isCached()             && (!this.l4083 || this.l4083.isCached())             && (!this.m4084 || this.m4084.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;                   const l4083 = await evalValue(this.l4083, parse);         const m4084 = await evalValue(this.m4084, parse);                  const cond   = await evalNumberValue(this.condition, parse);             if (   l4083                && m4084) this.value = cond.value != 0 ? l4083 : m4084;         else if (l4083) this.value = cond.value != 0 ? l4083 : new u4217();         else if (m4084) this.value = cond.value == 0 ? m4084 : new u4217();         else             this.value = new u4217();           this.t4216();           this.j4101(parse,         [             ['type',      this.outputType()],             ['condition', cond             ]         ]);                           this.validate();          return this;     }        r3633()     {         return this.value              ? this.value.copy()               : null;     }        isValid()     {         return this.l4083    && this.l4083   .isValid()             && this.m4084    && this.m4084   .isValid()             && this.condition && this.condition.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.l4083   ) this.l4083   .c4088(parse);         if (this.m4084   ) this.m4084   .c4088(parse);         if (this.condition) this.condition.c4088(parse);     }            t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.l4083   ) this.l4083   .t4089(parse, from, force);         if (this.m4084   ) this.m4084   .t4089(parse, from, force);         if (this.condition) this.condition.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.l4083   ) this.l4083   .c4087(parse);         if (this.m4084   ) this.m4084   .c4087(parse);         if (this.condition) this.condition.c4087(parse);     }     } 


class q1899 extends z2043 {     inputs = [];        reset()     {         super.reset();          this.inputs = [];     }        s3768()     {         const conditionNodes = [];          for (const input of this.inputs)         {             const conditionNode = input.s3768();             if (conditionNode) conditionNodes.push(conditionNode);                     }          console.assert(conditionNodes.length < 2, 'Error: sort order requires not more than one order node');          return conditionNodes.length == 1              ? conditionNodes[0]              : null;     }        isCached()     {         for (const input of this.inputs)             if (!input.isCached())                 return false;          return super.isCached();     }        isValid()     {         return  this.inputs.length > 0             && !this.inputs.find(i => !i.isValid());     }        c4088(parse)     {         super.c4088(parse);          this.inputs.forEach(i => i.c4088(parse));     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          this.inputs.forEach(i => i.t4089(parse, from, force));     }        c4087(parse)     {         super.c4087(parse);          this.inputs.forEach(i => i.c4087(parse));     } } 


class x1936 extends r2044 {     constructor(nodeId, options)     {         super(m1092, nodeId, options);     }        copy()     {         const copy = new x1936(this.nodeId, this.options);                  copy.x3359(this);          copy.value = this.value;          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalNumberValue(this.input, parse);           if (input)             this.value = input;         else if (this.value)             await this.value.eval(parse);         else             this.value = y2022.NaN.copy();           this.j4101(parse,          [             ['value', this.value]         ]);           this.validate();          return this;     }        isValid()     {         return !this.input               || this.input.isValid();     } }


class GSetPrecision extends r2044 {     decimals;        constructor(nodeId, options)     {         super(s1355, nodeId, options);     }            reset()     {         super.reset();          this.decimals = null;     }        copy()     {         const copy = new GSetPrecision(this.nodeId, this.options);          copy.x3359(this);          if (this.decimals) copy.decimals = this.decimals.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new y2022(0);                   const input    = await evalNumberValue(this.input,    parse);         const decimals = await evalNumberValue(this.decimals, parse);           if (input)         {             if (this.options.enabled)             {                 if (n957(input.type))                 {                     this.value = new d2021();                      for (let i = 0; i < input.items.length; i++)                     {                         const item = input.items[i];                          this.value.items.push(                             item.type == c1091                             ? getSetPrecisionValue(item, decimals)                             : y2022.NaN.copy());                        }                 }                 else                     this.value = getSetPrecisionValue(input, decimals);             }             else                 this.value = input;         }         else             this.value = y2022.NaN.copy();           this.j4101(parse,         [             ['type',     this.outputType()],             ['value',    this.value       ],             ['decimals', decimals         ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.decimals && this.decimals.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.decimals) this.decimals.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.decimals) this.decimals.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.decimals) this.decimals.c4087(parse);     } }    function getSetPrecisionValue(input, decimals) {     x952(          input == c1091,          'input must be NUMBER_VALUE');      return new y2022(input.value, decimals.value); }


class t1943 extends r2044 {     constructor(nodeId, options)     {         super(h1093, nodeId, options);     }            copy()     {         const copy = new t1943(this.nodeId, this.options);          copy.x3359(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalNumberValue(this.input, parse);           if (input)         {             if (n957(input.type))             {                 this.value = new d2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == c1091                         ? getSignValue(item)                         : y2022.NaN.copy());                    }             }             else                 this.value = getSignValue(input); }         else             this.value = y2022.NaN.copy();           this.j4101(parse,          [             ['type', this.outputType()]         ]);           this.validate();          return this;     } }    function getSignValue(input) {     x952(          input.type == c1091,          'input.type must be NUMBER_VALUE');      return new y2022(Math.sign(input.value)); }


class d1924 extends r2044 {     constructor(nodeId, options)     {         super(j1094, nodeId, options);     }            copy()     {         const copy = new d1924(this.nodeId, this.options);          copy.x3359(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalNumberValue(this.input, parse);           if (input)         {             if (n957(input.type))             {                 this.value = new d2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == c1091                         ? getAbsoluteValue(item, this.options.enabled)                         : y2022.NaN.copy());                    }             }             else                 this.value = getAbsoluteValue(input, this.options.enabled);         }         else             this.value = y2022.NaN.copy();           this.j4101(parse,          [             ['type', this.outputType()]         ]);           this.validate();          return this;     } }    function getAbsoluteValue(input, enabled) {     x952(          input.type == c1091,          'input.type must be NUMBER_VALUE');      return enabled         ? new y2022(Math.abs(input.value), input.decimals)         : input; }


class GNegative extends r2044 {     constructor(nodeId, options)     {         super(a1356, nodeId, options);     }            copy()     {         const copy = new GNegative(this.nodeId, this.options);          copy.x3359(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalNumberValue(this.input, parse);                       if (input)         {             if (n957(input.type))             {                 this.value = new d2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == c1091                         ? getNegativeValue(item, this.options.enabled)                         : y2022.NaN.copy());                    }             }             else                 this.value = getNegativeValue(input, this.options.enabled);         }         else             this.value = y2022.NaN.copy();           this.j4101(parse,          [             ['type', this.outputType()]         ]);           this.validate();          return this;     } }    function getNegativeValue(input, enabled) {     x952(          input == c1091,          'input must be NUMBER_VALUE');      return new y2022(         (enabled ? -1 : 1) * input.value,         input.decimals); }


class w1941 extends r2044 {     type;     decimals;        constructor(nodeId, options)     {         super(q1095, nodeId, options);     }            reset()     {         super.reset();          this.type     = null;         this.decimals = null;     }        copy()     {         const copy = new w1941(this.nodeId, this.options);          copy.x3359(this);          if (this.type    ) copy.type     = this.type    .copy();         if (this.decimals) copy.decimals = this.decimals.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new y2022(0);                   const input = await evalNumberValue(this.input,    parse);         const type  = await evalNumberValue(this.type,     parse);         const dec   = await evalNumberValue(this.decimals, parse);           if (   input             && type             && dec)         {             if (n957(input.type))             {                 this.value = new d2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == c1091                         ? getRoundValue(item, type, dec, this.options.enabled)                         : y2022.NaN.copy());                    }             }             else                 this.value = getRoundValue(input, type, dec, this.options.enabled); }         else             this.value = y2022.NaN.copy();           this.j4101(parse,         [             ['_type',    this.outputType()],             ['type',     type             ],             ['decimals', dec              ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.type     && this.type    .isValid()             && this.decimals && this.decimals.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.type    ) this.type    .c4088(parse);         if (this.decimals) this.decimals.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.type    ) this.type    .t4089(parse, from, force);         if (this.decimals) this.decimals.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.type    ) this.type    .c4087(parse);         if (this.decimals) this.decimals.c4087(parse);     } }    function getRoundValue(input, type, dec, enabled) {     x952(         input.type == c1091,         'input.type must be NUMBER_VALUE');       if (!enabled)         return input;      switch (type.value)     {         case 0: return new y2022(a1015(input.value, dec.value), dec.value);         case 1: return new y2022(a1016(input.value, dec.value), dec.value);         case 2: return new y2022( n1017(input.value, dec.value), dec.value);     } }


class GQuantize extends r2044 {     type;     base;     step;     amount;        constructor(nodeId, options)     {         super(l1357, nodeId, options);     }            reset()     {         super.reset();          this.type   = null;         this.base   = null;         this.step   = null;         this.amount = null;     }        copy()     {         const copy = new GQuantize(this.nodeId, this.options);          copy.x3359(this);          if (this.type  ) copy.type   = this.type  .copy();         if (this.base  ) copy.base   = this.base  .copy();         if (this.step  ) copy.step   = this.step  .copy();         if (this.amount) copy.amount = this.amount.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new y2022(0);                   const input  = await evalNumberValue(this.input,  parse);         const type   = await evalNumberValue(this.type,   parse);         const base   = await evalNumberValue(this.base,   parse);         const step   = await evalNumberValue(this.step,   parse);         const amount = await evalNumberValue(this.amount, parse);           if (input)         {             if (n957(input.type))             {                 this.value = new d2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == c1091                         ? getQuantizeValue(item, type, base, step, amount, this.options.enabled)                         : y2022.NaN.copy());                    }             }             else                 this.value = getQuantizeValue(input, type, base, step, amount, this.options.enabled); }         else             this.value = y2022.NaN.copy();           this.j4101(parse,         [             ['_type',  this.outputType()],             ['type',   type             ],             ['base',   base             ],             ['step',   step             ],             ['amount', amount           ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.type   && this.type  .isValid()             && this.base   && this.base  .isValid()             && this.step   && this.step  .isValid()             && this.amount && this.amount.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.type  ) this.type  .c4088(parse);         if (this.base  ) this.base  .c4088(parse);         if (this.step  ) this.step  .c4088(parse);         if (this.amount) this.amount.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.type  ) this.type  .t4089(parse, from, force);         if (this.base  ) this.base  .t4089(parse, from, force);         if (this.step  ) this.step  .t4089(parse, from, force);         if (this.amount) this.amount.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.type  ) this.type  .c4087(parse);         if (this.base  ) this.base  .c4087(parse);         if (this.step  ) this.step  .c4087(parse);         if (this.amount) this.amount.c4087(parse);     } }    function getQuantizeValue(input, type, base, step, amount, enabled) {     x952(          input.type == c1091,          'input.type must be NUMBER_VALUE');           if (!enabled)         return input;       let qval;      switch (type.value)     {         case 0: qval = base.value + step.value * Math.floor((input.value - base.value) / step.value); break;         case 1: qval = base.value + step.value * Math.round((input.value - base.value) / step.value); break;         case 2: qval = base.value + step.value * Math. ceil((input.value - base.value) / step.value); break;     }      return new y2022(         input.value + (qval - input.value) * amount.value/100,         Math.max(base.decimals, step.decimals)); }


class k1944 extends r2044 {     operand;     operation;        constructor(nodeId, options)     {         super(w1096, nodeId, options);     }            reset()     {         super.reset();          this.operand   = null;         this.operation = null;     }        copy()     {         const copy = new w1941(this.nodeId, this.options);          copy.x3359(this);          if (this.operand  ) copy.operand   = this.operand  .copy();         if (this.operation) copy.operation = this.operation.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new y2022(0);                   const input   = await evalNumberValue(this.input,     parse);         const operand = await evalNumberValue(this.operand,   parse);         const op      = await evalNumberValue(this.operation, parse);           if (input)         {             if (this.options.enabled)             {                 if (n957(input.type))                 {                     this.value = new d2021();                      for (let i = 0; i < input.items.length; i++)                     {                         const item = input.items[i];                          this.value.items.push(                             item.type == c1091                             ? getSimpleMinMaxValue(item, operand, op, this.options.enabled)                             : y2022.NaN.copy());                        }                 }                 else                 {                     this.value = getSimpleMinMaxValue(input, operand, op, this.options.enabled);                 }             }             else                 this.value = input.copy();         }         else             this.value = y2022.NaN.copy();           this.j4101(parse,         [                          ['type',      this.outputType()],             ['operand',   operand          ],             ['operation', op               ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.operand   && this.operation.isValid()             && this.operation && this.operand  .isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.operand  ) this.operand  .c4088(parse);         if (this.operation) this.operation.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.operand  ) this.operand  .t4089(parse, from, force);         if (this.operation) this.operation.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.operand  ) this.operand  .c4087(parse);         if (this.operation) this.operation.c4087(parse);     } }    function getSimpleMinMaxValue(input, operand, op, enabled) {     x952(         input.type == c1091,          'input.type is ' + input.type + ', must be NUMBER_VALUE');       if (enabled)     {         op.value = Math.min(Math.max(0, Math.floor(op.value)), 1);          return new y2022(op.value == 0             ? Math.min(input.value, operand.o3703())             : Math.max(input.value, operand.o3703()));     }     else         return input; }


class e1933 extends q1899 {     operation;        constructor(nodeId, options)     {         super(e1097, nodeId, options);     }            reset()     {         super.reset();          this.operation = null;     }        copy()     {         const copy = new e1933(this.nodeId, this.options);          copy.x3359(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.operation) copy.operation = this.operation.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           let op = await evalNumberValue(this.operation, parse);          if (op) op = op.z3729();           if (this.options.enabled)             op.value = Math.min(Math.max(0, op.value), m1311.length-1);                   this.value = await evalMinMaxInputs(this.inputs, op.value, parse);                   this.j4101(parse,         [             ['operation', op        ]                      ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.operation && this.operation.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.operation) this.operation.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.operation) this.operation.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.operation) this.operation.c4087(parse);     } }    async function evalMinMaxInputs(inputs, op, parse) {     if (isEmpty(inputs))         return y2022.NaN.copy();       let value = new y2022(0);       const k3690 = await evalNumberValue(inputs[0], parse);       if (   inputs.length == 1         && k3690.type == c1091)     {         value = new y2022(-k3690.value);     }     else if (n957(k3690.type)             && !isEmpty(k3690.items))     {         value = k3690.items[0].copy();                  for (let i = 1; i < k3690.items.length; i++)         {             const item = k3690.items[i];              if (item.type == c1091)             {                 value = new y2022(                      op == 0                     ? Math.min(value.value, item.value)                     : Math.max(value.value, item.value));             }                             }     }     else     {         if (k3690.type != c1091)             return y2022.NaN.copy();          value = k3690;     }       for (let i = 1; i < inputs.length; i++)     {         const val = await evalNumberValue(inputs[i], parse);           if (n957(val.type))         {             for (const item of val.items)             {                 if (item.type == c1091)                 {                     value = new y2022(                         op == 0                         ? Math.min(value.value, item.value)                         : Math.max(value.value, item.value));                                       }                                 }         }         else         {             x952(                 val.type == c1091,                  'val.type must be NUMBER_VALUE');                              value = new y2022(                 op == 0                 ? Math.min(value.value, val.value)                 : Math.max(value.value, val.value));                       }     }       return value; }


class v1932 extends r2044 {     min = null;     max = null;            constructor(nodeId, options)     {         super(u1098, nodeId, options);     }            reset()     {         super.reset();          this.min = null;         this.max = null;     }        copy()     {         const copy = new v1932(this.nodeId, this.options);          copy.x3359(this);          if (this.min) copy.min = this.min.copy();         if (this.max) copy.max = this.max.copy();          return copy;     }        isCached()     {         return super.isCached()             && (!this.min || this.min.isCached())             && (!this.max || this.max.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;                       const input = await evalNumberValue(this.input, parse);         const min   = await evalNumberValue(this.min,   parse);         const max   = await evalNumberValue(this.max,   parse);           if (input)         {             if (n957(input.type))             {                 this.value = new d2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == c1091                         ? getLimitsValue(item, min, max, this.options.enabled)                         : y2022.NaN.copy());                    }             }             else                 this.value = getLimitsValue(input, min, max, this.options.enabled);         }         else             this.value = y2022.NaN.copy();           this.j4101(parse,         [             ['type', this.outputType()],             ['min',   min             ],             ['max',   max             ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.min && this.min.isValid()             && this.max && this.max.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.input) this.input.c4088(parse);         if (this.min  ) this.min  .c4088(parse);         if (this.max  ) this.max  .c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.input) this.input.t4089(parse, from, force);         if (this.min  ) this.min  .t4089(parse, from, force);         if (this.max  ) this.max  .t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.input) this.input.c4087(parse);         if (this.min  ) this.min  .c4087(parse);         if (this.max  ) this.max  .c4087(parse);     } }    function getLimitsValue(input, min, max, enabled) {     x952(          input.type == c1091,          'input.type must be NUMBER_VALUE');      if (!enabled)         return input;      return new y2022(         Math.min(Math.max(             min.value,             input.value),             max.value),         input.decimals); }


class o1937 extends r2044 {     min   = null;     max   = null;     power = null;            constructor(nodeId, options)     {         super(a1099, nodeId, options);     }            reset()     {         super.reset();          this.min   = null;         this.max   = null;         this.power = null;     }        copy()     {         const copy = new o1937(this.nodeId, this.options);          copy.x3359(this);          if (this.min  ) copy.min   = this.min  .copy();         if (this.max  ) copy.max   = this.max  .copy();         if (this.power) copy.power = this.power.copy();          return copy;     }        isCached()     {         return super.isCached()             && (!this.min   || this.min  .isCached())             && (!this.max   || this.max  .isCached())             && (!this.power || this.power.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;                       const input = await evalNumberValue(this.input, parse);         const min   = await evalNumberValue(this.min,   parse);         const max   = await evalNumberValue(this.max,   parse);         const power = await evalNumberValue(this.power, parse);           if (input)         {             if (n957(input.type))             {                 this.value = new d2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == c1091                         ? getNumberCurveValue(item, min, max, power, this.options.enabled)                         : y2022.NaN.copy());                    }             }             else                 this.value = getNumberCurveValue(input, min, max, power, this.options.enabled);         }         else             this.value = y2022.NaN.copy();           this.j4101(parse,         [             ['type',  this.outputType()],             ['min',   min              ],             ['max',   max              ],             ['power', power            ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.min   && this.min  .isValid()             && this.max   && this.max  .isValid()             && this.power && this.power.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.min  ) this.min  .c4088(parse);         if (this.max  ) this.max  .c4088(parse);         if (this.power) this.power.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.min  ) this.min  .t4089(parse, from, force);         if (this.max  ) this.max  .t4089(parse, from, force);         if (this.power) this.power.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.min  ) this.min  .c4087(parse);         if (this.max  ) this.max  .c4087(parse);         if (this.power) this.power.c4087(parse);     } }    function getNumberCurveValue(input, min, max, power, enabled) {     x952(         input.type == c1091,         'input.type must be NUMBER_VALUE');       if (!enabled)         return input;       let f = (input.value - min.value) / (max.value - min.value);      f = Math.pow(f, power.value);     f = min.value + f * (max.value - min.value);          return new y2022(f); }


class GNumberMap extends r2044 {     from = null;     to   = null;            constructor(nodeId, options)     {         super(c1358, nodeId, options);     }            reset()     {         super.reset();          this.from = null;         this.to   = null;     }        copy()     {         const copy = new GNumberMap(this.nodeId, this.options);          copy.x3359(this);          if (from) copy.from = this.from.copy();         if (to  ) copy.to   = this.to  .copy();          return copy;     }        isCached()     {         return super.isCached()             && (!this.from  || this.from.isCached())             && (!this.to    || this.to  .isCached());     }        async eval(parse)     {         if (this.isCached())             return this;                       const input = await evalValue    (this.input, parse);         const from  = await evalListValue(this.from,  parse);         const to    = await evalListValue(this.to,    parse);           if (   input              && input.isValid())         {             if (this.options.enabled)             {                 if (   from && from.isValid() && from.items.length > 0                     && to   && to  .isValid() && to  .items.length > 0)                 {                     if (n957(input.type))                     {                         this.value = new d2021();                                  for (let i = 0; i < input.items.length; i++)                         {                             const item = input.items[i];                                      this.value.items.push(                                 item.type == c1091                                 ? getNumberMapValue(item, from, to)                                 : y2022.NaN.copy());                            }                     }                     else                         this.value = getNumberMapValue(input, from, to);                 }                 else                     this.value = y2022.NaN.copy();             }             else                 this.value = input;         }         else             this.value = y2022.NaN.copy();           this.j4101(parse,         [             ['type', this.outputType()],             ['from', from             ],             ['to',   to               ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.from && this.from.isValid()             && this.to   && this.to  .isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.from) this.from.c4088(parse);         if (this.to  ) this.to  .c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.from) this.from.t4089(parse, from, force);         if (this.to  ) this.to  .t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.from) this.from.c4087(parse);         if (this.to  ) this.to  .c4087(parse);     } }    function getNumberMapValue(input, from, to) {     x952(         input.type == c1091,         'input.type must be NUMBER_VALUE');       const maxDec = Math.max(         from.items.reduce((max, val) => Math.max(max, val.decimals), 0),         to  .items.reduce((max, val) => Math.max(max, val.decimals), 0));       if (from.items.length == 1)         return input;             const nFromSegments = Math.floor(from.items.length-1);     let   fromIndex     = 0;      while (fromIndex < nFromSegments-1)     {         if (   input.value >= from.items[fromIndex  ]             && input.value <  from.items[fromIndex+1])             break;          fromIndex++;     }               const fromLocal =              (input.value - from.items[fromIndex].value)          / (from.items[fromIndex+1].value - from.items[fromIndex].value);      const f = fromIndex/nFromSegments + fromLocal * ((fromIndex+1)/nFromSegments - fromIndex/nFromSegments);                 const nToSegments = Math.floor(to.items.length-1);     const toIndex     = Math.min(Math.max(0, Math.floor((to.items.length-1) * f)), nToSegments-1);       if (to.items.length == 1)         return to.items[0];      else if (to.items.length > 0             && toIndex < to.items.length-1)     {         const toLocal =              nToSegments > 1             ? (f - toIndex/nToSegments) * nToSegments             : f;           const k3690 = to.items[toIndex  ];         const val1 = to.items[toIndex+1];          return new y2022(             p1035(k3690.value, val1.value, toLocal),             maxDec);     } }


class GNumberBias extends r2044 {     min    = null;     max    = null;     bias   = null;     spread = null;            constructor(nodeId, options)     {         super(d1359, nodeId, options);     }            reset()     {         super.reset();          this.min    = null;         this.max    = null;         this.bias   = null;         this.spread = null;     }        copy()     {         const copy = new GNumberBias(this.nodeId, this.options);          copy.x3359(this);          if (this.min   ) copy.min    = this.min   .copy();         if (this.max   ) copy.max    = this.max   .copy();         if (this.bias  ) copy.bias   = this.bias  .copy();         if (this.spread) copy.spread = this.spread.copy();          return copy;     }        isCached()     {         return super.isCached()             && (!this.min    || this.min   .isCached())             && (!this.max    || this.max   .isCached())             && (!this.bias   || this.bias  .isCached())             && (!this.spread || this.spread.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;                       const input  = await evalNumberValue(this.input,  parse);         const min    = await evalNumberValue(this.min,    parse);         const max    = await evalNumberValue(this.max,    parse);         const bias   = await evalNumberValue(this.bias,   parse);         const spread = await evalNumberValue(this.spread, parse);           if (input)         {             if (n957(input.type))             {                 this.value = new d2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == c1091                         ? getNumberBiasValue(item, min, max, bias, spread, this.options.enabled)                         : y2022.NaN.copy());                    }             }             else                 this.value = getNumberBiasValue(input, min, max, bias, spread, this.options.enabled);         }         else             this.value = y2022.NaN.copy();           this.j4101(parse,         [             ['type',   this.outputType()],             ['min',    min              ],             ['max',    max              ],             ['bias',   bias             ],             ['spread', spread           ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.min    && this.min   .isValid()             && this.max    && this.max   .isValid()             && this.bias   && this.bias  .isValid()             && this.spread && this.spread.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.min   ) this.min   .c4088(parse);         if (this.max   ) this.max   .c4088(parse);         if (this.bias  ) this.bias  .c4088(parse);         if (this.spread) this.spread.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.min   ) this.min   .t4089(parse, from, force);         if (this.max   ) this.max   .t4089(parse, from, force);         if (this.bias  ) this.bias  .t4089(parse, from, force);         if (this.spread) this.spread.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.min   ) this.min   .c4087(parse);         if (this.max   ) this.max   .c4087(parse);         if (this.bias  ) this.bias  .c4087(parse);         if (this.spread) this.spread.c4087(parse);     } }    function u3735(f, bias, spread) {     const b = bias   / 50;     const s = spread / 50;       f =          b >= 0         ? 1 - Math.pow(1-f, 1+b)         :     Math.pow(  f, 1-b);            if (s >= 0 && f >= 0.5) f = 1 - Math.pow((1-f)*2, 1+s) / 2;     else if (s >= 0 && f <  0.5) f = Math.pow(f*2, 1+s) / 2;     else if (s < 0)              f = n1037(0, (1-s)/3, (2+s)/3, 1, f);       return f; }    function getNumberBiasValue(input, min, max, bias, spread, enabled) {     x952(         input.type == c1091,         'input.type must be NUMBER_VALUE');       if (!enabled)         return input;       let f = (input.value - min.value) / (max.value - min.value);      f = u3735(f, bias.value, spread.value);     f = min.value + f * (max.value - min.value);      return new y2022(f); }


class q1934 extends r2044 {     _value = null;        constructor(nodeId, options)     {         super(c1100, nodeId, options);     }            reset()     {         super.reset();          this._value = null;     }        copy()     {         const copy = new q1934(this.nodeId, this.options);          copy.x3359(this);          if (this._value) copy._value = this._value.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const  input = await evalNumberValue(this. input, parse);         const _value = await evalNumberValue(this._value, parse);           if (input)         {             if (n957(input.type))             {                 this.value = new d2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == c1091                         ? getNaNisNumberValue(item, _value, this.options.enabled)                         : c2033.NaN.copy());                    }             }             else             {                 this.value = getNaNisNumberValue(input, _value, this.options.enabled);             }         }          else             this.value = y2022.NaN.copy();           this.j4101(parse,         [             ['type',   this.outputType()]                      ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.value && this.value.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.value) this.value.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.value) this.value.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.value) this.value.c4087(parse);     } }    function getNaNisNumberValue(input, value, enabled) {     if (    enabled         && !input.isValid())         return value;     else         return input; }


class o1927 extends z2043 {     constant;        constructor(nodeId, options)     {         super(f1101, nodeId, options);     }            reset()     {         super.reset();          this.constant = null;     }        copy()     {         const copy = new o1927(this.nodeId, this.options);          copy.x3359(this);          if (this.constant) copy.constant = this.constant.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                                  const constant = await evalNumberValue(this.constant, parse);                   let value;          switch (Math.min(Math.max(0, constant.o3703()), 5))         {             case 0: value = 1.4142135623; break;              case 1: value = 2.7182818284; break;              case 2: value = 0.6180339887; break;              case 3: value = 1.6180339887; break;              case 4: value = 3.1415926536; break;              case 5: value = 6.2831853072; break;          }           this.value = new y2022(value);                   this.j4101(parse,         [             ['value',   this.value],             ['constant', constant ]         ]);           this.validate();          return this;     }        isValid()     {         return this.constant && this.constant.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.constant) this.constant.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.constant) this.constant.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.constant) this.constant.c4087(parse);     } } 


class j1929 extends z2043 {     seconds   = null;     minutes   = null;     hours     = null;     dayOfWeek = null;     date      = null;     month     = null;     year      = null;                    constructor(nodeId, options)     {         super(u1098, nodeId, options);     }            reset()     {         super.reset();                  this.seconds   = null;         this.minutes   = null;         this.hours     = null;         this.dayOfWeek = null;         this.date      = null;         this.month     = null;         this.year      = null;     }        copy()     {         const copy = new v1932(this.nodeId, this.options);                  copy.x3359(this);                  if (this.seconds  ) copy.seconds   = this.seconds  .copy();         if (this.minutes  ) copy.minutes   = this.minutes  .copy();         if (this.hours    ) copy.hours     = this.hours    .copy();         if (this.dayOfWeek) copy.dayOfWeek = this.dayOfWeek.copy();         if (this.date     ) copy.date      = this.date     .copy();         if (this.month    ) copy.month     = this.month    .copy();         if (this.year     ) copy.year      = this.year     .copy();          return copy;     }                        isCached()     {         return super.isCached()             && (!this.year      || this.year     .isCached())             && (!this.month     || this.month    .isCached())             && (!this.date      || this.date     .isCached())             && (!this.dayOfWeek || this.dayOfWeek.isCached())             && (!this.hours     || this.hours    .isCached())             && (!this.minutes   || this.minutes  .isCached())             && (!this.seconds   || this.seconds  .isCached())     }        async eval(parse)     {         if (this.isCached())             return this;           this.y3096 = [];                   if (this.options.enabled)         {             const dateTime = new Date();              const seconds   = new y2022(dateTime.getSeconds() );             const minutes   = new y2022(dateTime.getMinutes() );             const hours     = new y2022(dateTime.getHours()   );             const dayOfWeek = new y2022(dateTime.getDay()     );             const date      = new y2022(dateTime.getDate()    );             const month     = new y2022(dateTime.getMonth()   );             const year      = new y2022(dateTime.getFullYear());               this.j4101(parse,             [                 ['seconds',   seconds  ],                 ['minutes',   minutes  ],                 ['hours',     hours    ],                 ['dayOfWeek', dayOfWeek],                 ['date',      date     ],                 ['month',     month    ],                 ['year',      year     ]             ]);             }                       this.validate();          return this;     }            isValid()     {         return this.year      && this.year     .isValid()             && this.month     && this.month    .isValid()             && this.date      && this.date     .isValid()             && this.dayOfWeek && this.dayOfWeek.isValid()             && this.hours     && this.hours    .isValid()             && this.minutes   && this.minutes  .isValid()             && this.seconds   && this.seconds  .isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.year     ) this.year     .c4088(parse);         if (this.month    ) this.month    .c4088(parse);         if (this.date     ) this.date     .c4088(parse);         if (this.dayOfWeek) this.dayOfWeek.c4088(parse);         if (this.hours    ) this.hours    .c4088(parse);         if (this.minutes  ) this.minutes  .c4088(parse);         if (this.seconds  ) this.seconds  .c4088(parse);     }            t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.year     ) this.year     .t4089(parse, from, force);         if (this.month    ) this.month    .t4089(parse, from, force);         if (this.date     ) this.date     .t4089(parse, from, force);         if (this.dayOfWeek) this.dayOfWeek.t4089(parse, from, force);         if (this.hours    ) this.hours    .t4089(parse, from, force);         if (this.minutes  ) this.minutes  .t4089(parse, from, force);         if (this.seconds  ) this.seconds  .t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.year     ) this.year     .c4087(parse);         if (this.month    ) this.month    .c4087(parse);         if (this.date     ) this.date     .c4087(parse);         if (this.dayOfWeek) this.dayOfWeek.c4087(parse);         if (this.hours    ) this.hours    .c4087(parse);         if (this.minutes  ) this.minutes  .c4087(parse);         if (this.seconds  ) this.seconds  .c4087(parse);     }     } 


class u1930 extends z2043 {     inputs = [];        constructor(nodeId, options)     {         super(k1086, nodeId, options);     }            reset()     {         super.reset();          this.input = [];     }        copy()     {         const copy = new u1930(this.nodeId, this.options);          copy.x3359(this);          copy.inputs = this.inputs.map(i => i.copy());          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const _values = [];          for (let i = 0; i < this.inputs.length; i++)         {             const input = await evalValue(this.inputs[i], parse);              if (   input                 && this.options.enabled)                         {                 if (n957(input.type))                 {                     for (const item of input.items)                         _values.push(item.copy());                    }                 else                     _values.push(input.copy());             }         }                       this.value =              _values.length > 0             ? _values[this.currentIteration % _values.length]             : new u4217();           if (   this.value              && this.value.objects)         {             for (let i = 0; i < this.value.objects.length; i++)             {                 const v111 = this.value.objects[i];                      v111.nodeId = this.nodeId;                 v111.listId = -1;                      v111.objectId = this.nodeId;                                  if (v111.objectId != NULL)                      v111.objectId += '/';                      v111.objectId += i.toString();             }         }           this.x4100(parse);                   this.j4101(parse,         [             ['type', this.outputType()]         ]);                   this.validate();          return this;     }        r3633()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return !this.inputs.find(i => !i.isValid());     }        c4088(parse)     {         super.c4088(parse);          this.inputs.forEach(i => i.c4088(parse));     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          this.inputs.forEach(i => i.t4089(parse, from, force));     }        c4087(parse)     {         super.c4087(parse);          this.inputs.forEach(i => i.c4087(parse));     } } 


class m1942 extends z2043 {     start    = null;     multiply = null;     add      = null;     end      = null;      current  = null;                    constructor(nodeId, options)     {         super(n1103, nodeId, options);     }        reset()     {         super.reset();                  this.start    = null;         this.multiply = null;         this.add      = null;         this.end      = null;              this.current  = null;     }           copy()     {         const copy = new m1942(this.nodeId, this.options);          copy.x3359(this);          if (this.start   ) copy.start    = this.start   .copy();         if (this.multiply) copy.multiply = this.multiply.copy();         if (this.add     ) copy.add      = this.add     .copy();         if (this.end     ) copy.end      = this.end     .copy();          if (this.current) copy.current = this.current.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const start = await evalNumberValue(this.start,    parse);         const mult  = await evalNumberValue(this.multiply, parse);         const add   = await evalNumberValue(this.add,      parse);         const end   = await evalNumberValue(this.end,      parse);               if (   start             && mult             && add             && end)         {             const value = start.value + (this.options.enabled ? add.value * this.currentIteration : 0);              if (!end.isValid())                 this.value = getSequenceValue(start, mult, add, this.currentIteration, this.options.enabled);              else if (   end.isValid()                         && (   add.value == 0                          || add.value >  0 && start.value < end.value                                            &&       value < end.value                          || add.value <  0 && start.value > end.value                                            &&       value > end.value))                 this.value = getSequenceValue(start, mult, add, this.currentIteration, this.options.enabled);              else                 this.value = y2022.NaN.copy();         }         else             this.value = y2022.NaN.copy();           this.j4101(parse,         [             ['start',    start],             ['multiply', mult ],             ['add',      add  ],             ['end',      end  ]         ]);                   this.validate();          return this;     }        r3633()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return this.start    && this.start   .isValid()             && this.multiply && this.multiply.isValid()             && this.add      && this.add     .isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.start   ) this.start   .c4088(parse);         if (this.multiply) this.multiply.c4088(parse);         if (this.add     ) this.add     .c4088(parse);         if (this.end     ) this.end     .c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.start   ) this.start   .t4089(parse, from, force);         if (this.multiply) this.multiply.t4089(parse, from, force);         if (this.add     ) this.add     .t4089(parse, from, force);         if (this.end     ) this.end     .t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.start   ) this.start   .c4087(parse);         if (this.multiply) this.multiply.c4087(parse);         if (this.add     ) this.add     .c4087(parse);         if (this.end     ) this.end     .c4087(parse);     } }    function getSequenceValue(start, mult, add, iteration, enabled) {     let value = start.value;      if (enabled)     {         for (let i = 0; i < iteration; i++)         {             value *= mult.value;             value += add .value;         }     }      return new y2022(value); }


class m1940 extends z2043 {     from  = null;     start = null;     end   = null;                constructor(nodeId, options)     {         super(a1104, nodeId, options);     }            reset()     {         super.reset();          this.from  = null;         this.start = null;         this.end   = null;     }        copy()     {         const copy = new m1940(this.nodeId, this.options);          copy.x3359(this);          if (this.from   ) copy.from    = this.from   .copy();         if (this.start  ) copy.start   = this.start  .copy();         if (this.end    ) copy.end     = this.end    .copy();          if (this.current) copy.current = this.current.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const from  = await evalNumberValue(this.from,  parse);         const start = await evalNumberValue(this.start, parse);         const end   = await evalNumberValue(this.end,   parse);               const repeat    = parse.repeats.find(r => r.repeatId == this.b3821);         const iteration = repeat ? repeat.currentIteration : 0;           if (   from             && start             && end)         {             let delta = end.value - start.value;              let step =                  repeat                 && this.options.enabled                 ? delta / Math.max(1, repeat.total - (from.value == 1 ? 1 : 0))                 : 0;                               let startOffset;                   if (from  .value == 2) startOffset = step;             else if (from  .value == 1                 && repeat                 && repeat.total == 1) startOffset = delta/2;             else                        startOffset = 0;               let f;                          if (repeat)             {                      if (from.value == 2) f = iteration/repeat.total;                 else if (from.value == 1) f = (repeat.total > 1 ? iteration/(repeat.total-1) : 0);                 else if (from.value == 0) f = iteration/repeat.total;             }             else                 f = 0;               this.value = new y2022(                 start.value + startOffset + f * delta,                 Math.max(start.decimals, end.decimals));         }         else             this.value = y2022.NaN.copy();           this.j4101(parse,         [             ['from',  from ],             ['start', start],             ['end',   end  ]         ]);           this.validate();          return this;     }        r3633()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return this.from  && this.from .isValid()             && this.start && this.start.isValid()             && this.end   && this.end  .isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.from ) this.from .c4088(parse);         if (this.start) this.start.c4088(parse);         if (this.end  ) this.end  .c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.from ) this.from .t4089(parse, from, force);         if (this.start) this.start.t4089(parse, from, force);         if (this.end  ) this.end  .t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.from ) this.from .c4087(parse);         if (this.start) this.start.c4087(parse);         if (this.end  ) this.end  .c4087(parse);     } } 


class i1946 extends z2043 {     shape     = null;     base      = null;     amplitude = null;     frequency = null;     offset    = null;     bias      = null;          useWavelength;     offsetAbsolute;        constructor(nodeId, options)     {         super(y1105, nodeId, options);     }            reset()     {         super.reset();          this.shape     = null;         this.base      = null;         this.amplitude = null;         this.frequency = null;         this.offset    = null;         this.bias      = null;     }        copy()     {         const copy = new i1946(this.nodeId, this.options);          copy.x3359(this);          if (this.shape    ) copy.shape     = this.shape    .copy();         if (this.base     ) copy.base      = this.base     .copy();         if (this.amplitude) copy.amplitude = this.amplitude.copy();         if (this.frequency) copy.frequency = this.frequency.copy();         if (this.offset   ) copy.offset    = this.offset   .copy();         if (this.bias     ) copy.bias      = this.bias     .copy();          if (this.current) copy.current = this.current.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const shape  = await evalNumberValue(this.shape,     parse);         const base   = await evalNumberValue(this.base,      parse);         const amp    = await evalNumberValue(this.amplitude, parse);         let   freq   = await evalNumberValue(this.frequency, parse);         const offset = await evalNumberValue(this.offset,    parse);         const bias   = await evalNumberValue(this.bias,      parse);               const repeat    = parse.repeats.find(r => r.repeatId == this.b3821);         const iteration = repeat ? repeat.currentIteration : 0;            if (this.options.enabled)         {             let t;                                       if (   repeat                 && shape                 && freq                 && offset)             {                 const _freq =                     this.useWavelength                     ? repeat.total / nozero(freq.value)                     : freq.value;                  let _offset =                     this.offsetAbsolute                     ? offset.value/repeat.total                     : (offset.value/100)/_freq;                  if (shape.value == 3)                     _offset -= 0.25;                  t = (iteration/repeat.total - _offset) * _freq;                  while (t < 0) t++;                 while (t > 1) t--;                  switch (shape.value)                 {                     case 0: t = (t%1) < 0.5 ? 1 : -1;      break;                      case 1: t = (1 - (t%1)*2);             break;                      case 2: t = ((t%1)*2 - 1);             break;                      case 3: t = 1 - 2*Math.abs(2*(t%1)-1); break;                      case 4: t = Math.sin(t * Tau);         break;                  }             }             else                  t = 0;                           if (bias)             {                 const b = bias.value / 100;                  if (b >= 0) t = t / (1+b) + b/2;                 else        t = t / (1-b) + b/2;             }               if (amp ) t = t * amp .value;             if (base) t = t + base.value;               this.value = new y2022(t);         }         else             this.value = base;                   this.j4101(parse,         [             ['shape',     shape ],             ['base',      base  ],             ['amplitude', amp   ],             ['frequency', freq  ],             ['offset',    offset],             ['bias',      bias  ]         ]);           this.validate();          return this;     }        r3633()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return this.shape     && this.shape    .isValid()             && this.base      && this.base     .isValid()             && this.amplitude && this.amplitude.isValid()             && this.frequency && this.frequency.isValid()             && this.offset    && this.offset   .isValid()             && this.bias      && this.bias     .isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.shape    ) this.shape    .c4088(parse);         if (this.base     ) this.base     .c4088(parse);         if (this.amplitude) this.amplitude.c4088(parse);         if (this.frequency) this.frequency.c4088(parse);         if (this.offset   ) this.offset   .c4088(parse);         if (this.bias     ) this.bias     .c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.shape    ) this.shape    .t4089(parse, from, force);         if (this.base     ) this.base     .t4089(parse, from, force);         if (this.amplitude) this.amplitude.t4089(parse, from, force);         if (this.frequency) this.frequency.t4089(parse, from, force);         if (this.offset   ) this.offset   .t4089(parse, from, force);         if (this.bias     ) this.bias     .t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.shape    ) this.shape    .c4087(parse);         if (this.base     ) this.base     .c4087(parse);         if (this.amplitude) this.amplitude.c4087(parse);         if (this.frequency) this.frequency.c4087(parse);         if (this.offset   ) this.offset   .c4087(parse);         if (this.bias     ) this.bias     .c4087(parse);     } } 


class d1939 extends z2043 {     seed         = null;     iteration    = null;     min          = null;     max          = null;     bias         = null;     spread       = null;     unique       = null;      random       = null;     randomUnique = null;      lastValue1   = -1;     lastValue2   = -1;     uniqueOffset =  0;        constructor(nodeId, options)     {         super(e1106, nodeId, options);     }            reset()     {         super.reset();          this.seed      = null;         this.iteration = null;         this.min       = null;         this.max       = null;         this.bias      = null;         this.spread    = null;         this.unique    = null;     }        copy()     {         const copy = new d1939(this.nodeId, this.options);          copy.x3359(this);          if (this.seed     ) copy.seed      = this.seed     .copy();         if (this.iteration) copy.iteration = this.iteration.copy();         if (this.min      ) copy.min       = this.min      .copy();         if (this.max      ) copy.max       = this.max      .copy();         if (this.bias     ) copy.bias      = this.bias     .copy();         if (this.spread   ) copy.spread    = this.spread   .copy();         if (this.unique   ) copy.unique    = this.unique   .copy();          if (this.random   ) copy.random    = this.random   .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const seed      = await evalNumberValue(this.seed,      parse);         const iteration = await evalNumberValue(this.iteration, parse);         const min       = await evalNumberValue(this.min,       parse);         const max       = await evalNumberValue(this.max,       parse);         const bias      = await evalNumberValue(this.bias,      parse);         const spread    = await evalNumberValue(this.spread,    parse);         const unique    = await evalNumberValue(this.unique,    parse);               if (   this.options.enabled             && iteration             && seed             && min             && max             && bias             && spread             && unique)         {             if (  !this.random                 || this.random.seed != seed.value)             {                 this.random       = new Random(seed.value);                 this.randomUnique = new Random(seed.value+1);             }               if (iteration.isValid())                 this.currentIteration = Math.round(iteration.value);               if (this.currentIteration >= 0)             {                 let f  = this.random.get(this.currentIteration + this.uniqueOffset);                  f = u3735(f, bias.value, spread.value);                 f = min.value + f * (max.value - min.value);                                  this.value = new y2022(f, Math.max(min.decimals, max.decimals));                                       const _unique = unique.value/100;                                   if (max.value - min.value >= 1)                 {                     while (this.value.o3703() == this.lastValue1                         && this.randomUnique.get(this.currentIteration) < _unique)                         this.value = new y2022(                             min.value + this.random.get(this.currentIteration + ++this.uniqueOffset) * (max.value - min.value),                             Math.max(min.decimals, max.decimals));                 }                  if (max.value - min.value >= 2)                 {                     while ((   this.value.o3703() == this.lastValue1                             || this.value.o3703() == this.lastValue2)                         && this.randomUnique.get(this.currentIteration) < Math.max(_unique - 1))                         this.value = new y2022(                             min.value + this.random.get(this.currentIteration + ++this.uniqueOffset) * (max.value - min.value),                             Math.max(min.decimals, max.decimals));                 }                     }             else                 this.value = new y2022((min.value + max.value) / 2);         }         else             this.value = y2022.NaN.copy();           if (this.value.isValid())             this.value.value = this.value.o3703();          this.lastValue2 = this.lastValue1;         this.lastValue1 = this.value.value;           this.j4101(parse,         [             ['iteration', iteration],             ['seed',      seed     ],             ['min',       min      ],             ['max',       max      ],             ['bias',      bias     ],             ['spread',    spread   ],             ['unique',    unique   ]         ]);                   this.validate();          return this;     }        r3633()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return this.seed      && this.seed     .isValid()             && this.iteration && this.iteration.isValid()             && this.min       && this.min      .isValid()             && this.max       && this.max      .isValid()             && this.bias      && this.bias     .isValid()             && this.spread    && this.spread   .isValid()             && this.unique    && this.unique   .isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.seed     ) this.seed     .c4088(parse);         if (this.iteration) this.iteration.c4088(parse);         if (this.min      ) this.min      .c4088(parse);         if (this.max      ) this.max      .c4088(parse);         if (this.bias     ) this.bias     .c4088(parse);         if (this.spread   ) this.spread   .c4088(parse);         if (this.unique   ) this.unique   .c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.seed     ) this.seed     .t4089(parse, from, force);         if (this.iteration) this.iteration.t4089(parse, from, force);         if (this.min      ) this.min      .t4089(parse, from, force);         if (this.max      ) this.max      .t4089(parse, from, force);         if (this.bias     ) this.bias     .t4089(parse, from, force);         if (this.spread   ) this.spread   .t4089(parse, from, force);         if (this.unique   ) this.unique   .t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.seed     ) this.seed     .c4087(parse);         if (this.iteration) this.iteration.c4087(parse);         if (this.min      ) this.min      .c4087(parse);         if (this.max      ) this.max      .c4087(parse);         if (this.bias     ) this.bias     .c4087(parse);         if (this.spread   ) this.spread   .c4087(parse);         if (this.unique   ) this.unique   .c4087(parse);     }        o3629(parse, nodeId)     {         super.o3629(parse, nodeId);          this.uniqueOffset = 0;     }        r3632(parse, nodeId)     {         super.r3632(parse, nodeId);          this.uniqueOffset = 0;     } } 


class i1935 extends z2043 {     seed        = null;     iteration   = null;     min         = null;     max         = null;     scale       = null;     interpolate = null;     offset      = null;     evolve      = null;     detail      = null;          randoms     = [];     offsets     = [];                    constructor(nodeId, options)     {         super(g1107, nodeId, options);     }                    reset()     {         super.reset();                  this.seed          = null;         this.iteration     = null;         this.min           = null;         this.max           = null;         this.scale         = null;         this.interpolate   = null;         this.offset        = null;         this.evolve        = null;         this.detail        = null;     }        copy()     {         const copy = new i1935(this.nodeId, this.options);          copy.x3359(this);          if (this.seed       ) copy.seed        = this.seed       .copy();         if (this.iteration  ) copy.iteration   = this.iteration  .copy();         if (this.min        ) copy.min         = this.min        .copy();         if (this.max        ) copy.max         = this.max        .copy();         if (this.scale      ) copy.scale       = this.scale      .copy();         if (this.offset     ) copy.offset      = this.offset     .copy();         if (this.evolve     ) copy.evolve      = this.evolve     .copy();         if (this.interpolate) copy.interpolate = this.interpolate.copy();         if (this.detail     ) copy.detail      = this.detail     .copy();          if (this.randoms    ) copy.randoms     = this.randoms.map(r => r.copy());         if (this.offsets    ) copy.offsets     = this.offsets.slice();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const seed        = await evalNumberValue(this.seed,        parse);         const iteration   = await evalNumberValue(this.iteration,   parse);         const min         = await evalNumberValue(this.min,         parse);         const max         = await evalNumberValue(this.max,         parse);         const scale       = await evalNumberValue(this.scale,       parse);         const offset      = await evalNumberValue(this.offset,      parse);         const evolve      = await evalNumberValue(this.evolve,      parse);         const interpolate = await evalNumberValue(this.interpolate, parse);         const detail      = await evalNumberValue(this.detail,      parse);               if (   this.options.enabled             && seed             && iteration             && min             && max             && scale             && offset             && evolve             && interpolate             && detail)         {             const _detail = Math.max(1, Math.ceil(detail.value));               if (  !this.randoms                 || this.randoms.length < _detail)             {                 const randoms = new Array(_detail);                  for (let c = 0; c < this.randoms.length; c++)                     randoms[c] = this.randoms[c];                                   let _seed = seed.value;                  for (let c = this.randoms.length; c < _detail; c++)                 {                     randoms[c] = new j375(_seed);                     _seed = seed.value;                 }                   this.randoms = randoms;                   this.updateOffsets(this.randoms[0].width * _detail);             }               let   size  = 1;             let   power = 1;                          const avg   = (min.value + max.value) / 2;             let   r;                           if (iteration.isValid())                 this.currentIteration = Math.round(iteration.value);                               if (   this.options.enabled                 && scale  && scale .isValid()                 && offset && offset.isValid()                 && evolve && evolve.isValid())             {                 r = avg;                                  if (this.currentIteration >= 0)                 {                     for (let c = 0; c < _detail; c++)                     {                         const i  = Math.max(0, this.currentIteration / (Math.max(0.000001, scale.value) * size) + offset.value);                         const i0 = Math.floor(i);                         const i1 = Math.ceil (i);                                                   this.updateOffsets((i1 + 1) * _detail);                          const o0 = this.offsets[i0];                         const o1 = this.offsets[i1];                         let   _o;                          switch (interpolate.value)                         {                             case 0: _o = o0;                                                 break;                             case 1: _o = p1035(o0, o1, i-i0);                                 break;                             case 2: _o = (o0 + (o1 - o0) * (-Math.cos((i-i0)*Tau/2) + 1)/2); break;                         }                                                   const j   = evolve.value + _o;                         const j0  = Math.floor(j);                         const j1  = Math.ceil (j);                           const r00 = this.randoms[c].get(i0, j0);                         const r10 = this.randoms[c].get(i1, j0);                         const r01 = this.randoms[c].get(i0, j1);                         const r11 = this.randoms[c].get(i1, j1);                                       let _r, _r0, _r1;                                                  switch (interpolate.value)                         {                             case 0:                                  _r = r00;                                 break;                              case 1:                                  _r0 = p1035(r00, r10, i-i0);                                 _r1 = p1035(r01, r11, i-i0);                                 _r  = p1035(_r0, _r1, j-j0);                                 break;                              case 2:                                  _r0 = (r00 + (r10 - r00) * (-Math.cos((i-i0)*Tau/2) + 1)/2);                                  _r1 = (r01 + (r11 - r01) * (-Math.cos((i-i0)*Tau/2) + 1)/2);                                  _r  = (_r0 + (_r1 - _r0) * (-Math.cos((j-j0)*Tau/2) + 1)/2);                                  break;                         }                           const clamp =                              detail.value - c < 1                              ? detail.value - c                              : 1;                          r +=                              - power *      (avg       - min.value) * clamp                             + power * _r * (max.value - min.value) * clamp;                                                   size  /= 2;                         power /= 2;                                                   this.updateOffsets(this.randoms[0].width * _detail);                     }                 }             }             else             {                 r = min.value;             }               this.value = new y2022(r, Math.max(min.decimals, max.decimals));         }         else         {             this.value = y2022.NaN.copy();         }           this.j4101(parse,         [             ['seed',        seed       ],             ['iteration',   iteration  ],             ['min',         min        ],             ['max',         max        ],             ['scale',       scale      ],             ['offset',      offset     ],             ['evolve',      evolve     ],             ['interpolate', interpolate],             ['detail',      detail     ]         ]);                   this.validate();          return this;     }        updateOffsets(newSize)     {         if (newSize < this.offsets.length)              return;          this.offsets = new Array(newSize);         const offsetRandom = new Random(0);          for (let o = 0; o < newSize; o++)             this.offsets[o] = offsetRandom.get(o);     }        r3633()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return this.seed        && this.seed       .isValid()             && this.iteration   && this.iteration  .isValid()             && this.min         && this.min        .isValid()             && this.max         && this.max        .isValid()             && this.scale       && this.scale      .isValid()             && this.offset      && this.offset     .isValid()             && this.evolve      && this.evolve     .isValid()             && this.interpolate && this.interpolate.isValid()             && this.detail      && this.detail     .isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.seed       ) this.seed       .c4088(parse);         if (this.iteration  ) this.iteration  .c4088(parse);         if (this.min        ) this.min        .c4088(parse);         if (this.max        ) this.max        .c4088(parse);         if (this.scale      ) this.scale      .c4088(parse);         if (this.offset     ) this.offset     .c4088(parse);         if (this.evolve     ) this.evolve     .c4088(parse);         if (this.interpolate) this.interpolate.c4088(parse);         if (this.detail     ) this.detail     .c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.seed       ) this.seed       .t4089(parse, from, force);         if (this.iteration  ) this.iteration  .t4089(parse, from, force);         if (this.min        ) this.min        .t4089(parse, from, force);         if (this.max        ) this.max        .t4089(parse, from, force);         if (this.scale      ) this.scale      .t4089(parse, from, force);         if (this.offset     ) this.offset     .t4089(parse, from, force);         if (this.evolve     ) this.evolve     .t4089(parse, from, force);         if (this.interpolate) this.interpolate.t4089(parse, from, force);         if (this.detail     ) this.detail     .t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.seed       ) this.seed       .c4087(parse);         if (this.iteration  ) this.iteration  .c4087(parse);         if (this.min        ) this.min        .c4087(parse);         if (this.max        ) this.max        .c4087(parse);         if (this.scale      ) this.scale      .c4087(parse);         if (this.offset     ) this.offset     .c4087(parse);         if (this.evolve     ) this.evolve     .c4087(parse);         if (this.interpolate) this.interpolate.c4087(parse);         if (this.detail     ) this.detail     .c4087(parse);     } } 


class g1938 extends u2045 {     seed      = null;     iteration = null;     chance    = null;     alternate = null;      random    = null;        constructor(nodeId, options)     {         super(k1108, nodeId, options);     }            reset()     {         super.reset();          this.seed      = null;         this.iteration = null;         this.chance    = null;         this.alternate = null;     }        copy()     {         const copy = new d1939(this.nodeId, this.options);          copy.x3359(this);          if (this.seed     ) copy.seed      = this.seed     .copy();         if (this.iteration) copy.iteration = this.iteration.copy();         if (this.chance   ) copy.chance    = this.chance   .copy();         if (this.alternate) copy.alternate = this.alternate.copy();          if (this.random) copy.random = this.random.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const l4083    = await evalValue      (this.l4083,    parse);         const m4084    = await evalValue      (this.m4084,    parse);         const seed      = await evalNumberValue(this.seed,      parse);         const iteration = await evalNumberValue(this.iteration, parse);         const chance    = await evalNumberValue(this.chance,    parse);         const alternate = await evalNumberValue(this.alternate, parse);               if (   seed             && iteration             && chance             && alternate)         {             if (  !this.random                 || this.random.seed != seed.value)                 this.random = new Random(seed.value);               if (iteration.isValid())                 this.currentIteration = Math.round(iteration.value);               if (this.currentIteration >= 0)             {                 const calt  = this.currentIteration % 2 == 0 ? 0 : 1;                  let   cval  = chance.value/100;                       cval += alternate.value/100 * (calt - cval);                  const ch    = this.random.get(this.currentIteration) > cval ? 0 : 1;                                   if (   l4083                      && m4084)                 {                     if (   l4083.isValid()                         && m4084.isValid())                         this.value = ch < 0.5 ? l4083 : m4084;                     else                         this.value = new u4217();                 }                  else if (l4083)                     this.value = l4083;                                  else if (m4084)                     this.value = m4084;                                  else                     this.value = new y2022(ch < 0.5 ? 0 : 1);             }             else                 this.value = new u4217();         }         else             this.value = new u4217();           this.j4101(parse,         [             ['type',      this.outputType()],             ['seed',      seed             ],             ['iteration', iteration        ],             ['chance',    chance           ],             ['alternate', alternate        ]         ]);                   this.validate();          return this;     }        r3633()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return this.seed      && this.seed     .isValid()             && this.iteration && this.iteration.isValid()             && this.chance    && this.chance   .isValid()             && this.alternate && this.alternate.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.seed     ) this.seed     .c4088(parse);         if (this.iteration) this.iteration.c4088(parse);         if (this.chance   ) this.chance   .c4088(parse);         if (this.alternate) this.alternate.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.seed     ) this.seed     .t4089(parse, from, force);         if (this.iteration) this.iteration.t4089(parse, from, force);         if (this.chance   ) this.chance   .t4089(parse, from, force);         if (this.alternate) this.alternate.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.seed     ) this.seed     .c4087(parse);         if (this.iteration) this.iteration.c4087(parse);         if (this.chance   ) this.chance   .c4087(parse);         if (this.alternate) this.alternate.c4087(parse);     } } 


class q1925 extends r2044 {     current;     when;        constructor(nodeId, options)     {         super(w1109, nodeId, options);          this.current = new y2022(0);     }            reset()     {         super.reset();          this.current = null;         this.when    = null;     }        copy()     {         const copy = new q1925(this.nodeId, this.options);          copy.x3359(this);          if (this.when   ) copy.when    = this.when   .copy();         if (this.current) copy.current = this.current.copy();          return copy;     }        async eval(parse)     {         if (    this.isCached()             || !parse.evalAccumulate)             return this;           const input = await evalNumberValue(this.input, parse);         const when  = await evalNumberValue(this.when,  parse);                       if (   input             && when)         {             if (this.options.enabled)             {                 if (when.value > 0)                     this.value = this.current.copy();                  if (input)                 {                     this.current.value   += input.value;                     this.current.decimals = Math.max(this.current.decimals, input.decimals);                 }                  if (when.value == 0)                     this.value = this.current.copy();             }             else                 this.value = input.copy();         }         else             this.value = y2022.NaN.copy();           this.j4101(parse,          [             ['when', when]         ]);                   this.validate();          return this;     }        r3633()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.when && this.when.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.when) this.when.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.when) this.when.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.when) this.when.c4087(parse);     }        r3632(parse, nodeId)     {         super.r3632(parse, nodeId);          this.current = new y2022(0);     } } 


class GHold extends r2044 {     current;     first;        constructor(nodeId, options)     {         super(HOLD, nodeId, options);          this.current = null;     }            reset()     {         super.reset();          this.current = null;         this.first   = null;     }        copy()     {         const copy = new GHold(this.nodeId, this.options);          copy.x3359(this);          if (this.first  ) copy.first   = this.first  .copy();         if (this.current) copy.current = this.current.copy();          return copy;     }        async eval(parse)     {         if (    this.isCached()             || !parse.evalAccumulate)             return this;           const input = await evalValue(this.input, parse);         const first = await evalValue(this.first, parse);                       if (   input             && first)         {             if (this.options.enabled)             {                 this.value   = this.current ? this.current : first;                 this.current = input;             }             else                 this.value = input;         }         else             this.value = y2022.NaN.copy();           this.j4101(parse,          [             ['type', this.outputType()]         ]);                   this.validate();          return this;     }        r3633()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.first && this.first.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.first) this.first.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.first) this.first.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.first) this.first.c4087(parse);     }        r3632(parse, nodeId)     {         super.r3632(parse, nodeId);          this.current = null;     } } 


class o1931 extends u2045 {     inputs = [];      amount;     degree;        constructor(nodeId, options)     {         super(x1110, nodeId, options);     }            reset()     {         super.reset();          this.inputs = [];          this.amount = null;         this.degree = null;     }        copy()     {         const copy = new o1931(this.nodeId, this.options);          copy.x3359(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.amount) copy.amount = this.amount.copy();         if (this.degree) copy.degree = this.degree.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const amount = await evalNumberValue(this.amount, parse);         const degree = await evalNumberValue(this.degree, parse);           const values = [];                  for (const n3812 of this.inputs)         {             const input = await evalNumberValue(n3812, parse);              if (n957(input.type))             {                 for (const item of input.items)                 {                                                                    const value = await evalNumberValue(item, parse);                     values.push(value);                 }             }             else             {                 const value = await evalNumberValue(input, parse);                 values.push(value);             }         }                           const maxDec = values.reduce((max, v) => Math.max(max, v.decimals), 0);           const deg =             degree.value < 3             ? Math.min(degree.value, 2) + 1             : 1;          const nSegments = Math.floor((values.length-1)/deg);         const index     = Math.min(Math.floor((values.length-1)/deg * amount.value/100), nSegments-1);           if (values.length == 1)             this.value = values[0];          else if (values.length > 0               && index < values.length - deg)         {             const localAmount =                  nSegments > 1                 ? (amount.value/100 - index/nSegments) * nSegments                 : amount.value/100;               if (degree.value == 0)              {                 const k3690 = values[index*deg  ];                 const val1 = values[index*deg+1];                  this.value = new y2022(                     p1035(k3690.value, val1.value, localAmount),                     maxDec);             }             else if (degree.value == 1)              {                 const k3690 = values[index*deg  ];                 const val1 = values[index*deg+1];                 const val2 = values[index*deg+2];                  this.value = new y2022(                     d1036(k3690.value, val1.value, val2.value, localAmount),                     maxDec);             }             else if (degree.value == 2)              {                 const k3690 = values[index*deg  ];                 const val1 = values[index*deg+1];                 const val2 = values[index*deg+2];                 const val3 = values[index*deg+3];                  this.value = new y2022(                     n1037(k3690.value, val1.value, val2.value, val3.value, localAmount),                     maxDec);             }             else if (degree.value == 3)              {                 const k3690 = values[index*deg  ];                 const val1 = values[index*deg+1];                  this.value = new y2022(                     lerpCos(k3690.value, val1.value, localAmount),                     maxDec);             }             else                 this.value = y2022.NaN.copy();         }          else                               this.value = y2022.NaN.copy();           this.j4101(parse,         [             ['value',  this.value],             ['amount', amount    ],             ['degree', degree    ]         ]);                   this.validate();          return this;     }        isValid()     {         return  super.isValid()             &&  this.inputs.length > 0             && !this.inputs.find(i => !i.isValid())             &&  this.amount && this.amount.isValid()             &&  this.degree && this.degree.isValid();     }        c4088(parse)     {         super.c4088(parse);          this.inputs.forEach(i => i.c4088(parse));          if (this.amount) this.amount.c4088(parse);         if (this.degree) this.degree.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          this.inputs.forEach(i => i.t4089(parse, from, force));          if (this.amount) this.amount.t4089(parse, from, force);         if (this.degree) this.degree.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          this.inputs.forEach(i => i.c4087(parse));          if (this.amount) this.amount.c4087(parse);         if (this.degree) this.degree.c4087(parse);     } } 


class f1945 extends r2044 {     current = null;     target  = null;      temp    = null;            constructor(nodeId, options)     {         super(u1098, nodeId, options);     }            reset()     {         super.reset();          this.current = null;         this.target  = null;         this.temp    = null;     }        copy()     {         const copy = new f1945(this.nodeId, this.options);          copy.x3359(this);          if (this.current) copy.current = this.current.copy();         if (this.target ) copy.target  = this.target .copy();          return copy;     }        isCached()     {         return super.isCached()             && this.current.isCached()             && this.target .isCached();     }        async eval(parse)     {         if (this.isCached())             return this;           let   input   = await evalNumberValue(this.input,   parse);         let   current = await evalNumberValue(this.current, parse);         const target  = await evalNumberValue(this.target,  parse);           if (   input             && current.isValid()             && target .isValid())         {             x952(                 input.type == c1091,                  'input.type must be NUMBER_VALUE');               if (this.options.enabled)             {                 let   diff      = target.value - current.value;                 let   prevDiff  = 0;                   let   temp      = 0;                 let   step      = Number.MAX_SAFE_INTEGER/65536;                   let   iter      = 0;                 const maxIter   = 1000;                                   z2077(this.nodeId);                   parse.j3640 += maxIter;                   while (iter++ < maxIter)                 {                     temp += step;                       if (this.input.type == PARAM)                     {                         this.input.node[this.input.h2992].value    = temp;                         this.input.node[this.input.h2992].decimals = n1004(temp);                     }                                               this.current.t4089(parse, this);                     current = await evalNumberValue(this.current, parse);                                                                                      if (current.isValid())                     {                         diff = target.value - current.value;                                                   if (Math.abs(diff) < 0.0000001)                             break;                                                       if (   Math.abs (diff) >  Math.abs (prevDiff)                             || Math.sign(diff) != Math.sign(prevDiff))                             step /= -2;                                                                             prevDiff = diff;                     }                                               parse.o3639++;                     z2078(parse, this.nodeId, iter / maxIter);                 }                   if (iter < maxIter)                 {                     parse.o3639 += maxIter - iter;                      input = await evalNumberValue(this.input, parse);                     this.value = input.copy();                 }                 else                 {                     this.value = y2022.NaN.copy();                     console.warn('max solve iterations');                 }             }             else                 this.value = input.copy();         }         else         {             if (this.input)                  await this.input.eval(parse);              this.value = y2022.NaN.copy();         }                             this.j4101(parse,         [                          ['current', current   ],             ['target',  target    ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.current && this.current.isValid()             && this.target  && this.target .isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.current) this.current.c4088(parse);         if (this.target ) this.target .c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.current) this.current.t4089(parse, from, force);         if (this.target ) this.target .t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.current) this.current.c4087(parse);         if (this.target ) this.target .c4087(parse);     } } 


class i1926 extends z2043 {     from   = null;     to     = null;     curve  = null;     repeat = null;     length = null;     time   = null;                    constructor(nodeId, options)     {         super(a1112, nodeId, options);     }                    reset()     {         super.reset();                  this.from   = null;         this.to     = null;         this.curve  = null;         this.repeat = null;         this.length = null;         this.time   = null;     }        copy()     {         const copy = new i1926(this.nodeId, this.options);          copy.x3359(this);          if (this.from  ) copy.from   = this.from  .copy();         if (this.to    ) copy.to     = this.to    .copy();         if (this.curve ) copy.curve  = this.curve .copy();         if (this.repeat) copy.repeat = this.repeat.copy();         if (this.length) copy.length = this.length.copy();         if (this.time  ) copy.time   = this.time  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const from   = await evalNumberValue(this.from,   parse);         const to     = await evalNumberValue(this.to,     parse);         const curve  = await evalNumberValue(this.curve,  parse);         const repeat = await evalNumberValue(this.repeat, parse);         const length = await evalNumberValue(this.length, parse);         const time   = await evalNumberValue(this.time,   parse);               const maxDec = Math.max(from.decimals, to.decimals);          switch (curve.value)         {             case 0:              {                 this.value = new y2022(                     time.value < length.value ? from.value : to.value,                      maxDec);                      break;             }             case 1:              {                 this.value = new y2022(                     from.value + (to.value - from.value) * time.value / length.value,                     maxDec);                  break;             }             case 2:              {                 let f = time.value / length.value;                  f = 1 - sqr(1 - f);                  this.value = new y2022(                     from.value + (to.value - from.value) * f,                     maxDec);                      break;             }             case 3:              {                 let f = time.value / length.value;                  f = sqr(f);                  this.value = new y2022(                     from.value + (to.value - from.value) * f,                     maxDec);                      break;             }             case 4:              {                 let f = time.value / length.value;                  f = 6*Math.pow(f, 5) - 15*Math.pow(f, 4) + 10*Math.pow(f, 3);                  this.value = new y2022(                     from.value + (to.value - from.value) * f,                     maxDec);                      break;             }         }                   this.j4101(parse,         [             ['from',   from  ],             ['to',     to    ],             ['curve',  curve ],             ['repeat', repeat],             ['length', length],             ['time',   time  ]         ]);                   this.validate();          return this;     }        isValid()     {         return this.from   && this.from  .isValid()             && this.to     && this.to    .isValid()             && this.curve  && this.curve .isValid()             && this.repeat && this.repeat.isValid()             && this.length && this.length.isValid()             && this.time   && this.time  .isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.from  ) this.from  .c4088(parse);         if (this.to    ) this.to    .c4088(parse);         if (this.curve ) this.curve .c4088(parse);         if (this.repeat) this.repeat.c4088(parse);         if (this.length) this.length.c4088(parse);         if (this.time  ) this.time  .c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.from  ) this.from  .t4089(parse, from, force);         if (this.to    ) this.to    .t4089(parse, from, force);         if (this.curve ) this.curve .t4089(parse, from, force);         if (this.repeat) this.repeat.t4089(parse, from, force);         if (this.length) this.length.t4089(parse, from, force);         if (this.time  ) this.time  .t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.from  ) this.from  .c4087(parse);         if (this.to    ) this.to    .c4087(parse);         if (this.curve ) this.curve .c4087(parse);         if (this.repeat) this.repeat.c4087(parse);         if (this.length) this.length.c4087(parse);         if (this.time  ) this.time  .c4087(parse);     } } 


class y1902 extends q1899 {     operation;        constructor(nodeId, options)     {         super(f1114, nodeId, options);     }       reset()     {         super.reset();          this.operation = null;     }            copy()     {         const copy = new y1902(this.nodeId, this.options);          copy.x3359(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.operation) copy.operation = this.operation.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           let op = await evalNumberValue(this.operation, parse);          if (op) op = op.z3729();                   if (op.isValid())         {             op.value    = Math.min(Math.max(0, Math.round(op.value)), m1311.length-1);             op.decimals = 0;         }           if (this.options.enabled)         {             switch (op.value)             {                 case 0: this.value = await r3701  (this, this.inputs, parse); break;                 case 1: this.value = await s3700  (this, this.inputs, parse); break;                 case 2: this.value = await z3698(this, this.inputs, parse); break;                 case 3: this.value = await t3697     (this, this.inputs, parse); break;                 case 4: this.value = await f3699(this, this.inputs, parse); break;                 case 5: this.value = await z3702(this, this.inputs, parse); break;             }         }          else if (this.inputs.length > 0)             this.value =                     this.inputs.length > 0                  && this.inputs[0]                  ? (await this.inputs[0].eval(parse)).r3633()                  : null;          else             this.value = y2022.NaN.copy();           this.j4101(parse,         [                          ['operation', op        ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.operation && this.operation.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.operation) this.operation.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.operation) this.operation.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.operation) this.operation.c4087(parse);     } }    async function t3697(node, inputs, parse) {     if (isEmpty(inputs))         return y2022.NaN.copy();       const value = new y2022(0);       for (let i = 0; i < inputs.length; i++)     {         const val = await evalValue(inputs[i], parse);                   if (   !val             || !val.isValid())         {             for (let j = i+1; j < inputs.length; j++)                 await evalValue(inputs[j], parse);                          return y2022.NaN.copy();         }           if (n957(val.type))         {             if (   isEmpty(val.items)                 || val.items[0].type != c1091)                 return y2022.NaN.copy();              for (const item of val.items)             {                 if (item.type == c1091)                 {                     value.value   += item.value;                     value.decimals = Math.max(value.decimals, item.decimals);                 }             }         }         else         {             x952(                  val.type == c1091,                  'val.type must be NUMBER_VALUE');              value.value   += val.value;             value.decimals = Math.max(value.decimals, val.decimals);         }     }       return value; }    async function z3698(node, inputs, parse) {     if (isEmpty(inputs))         return y2022.NaN.copy();       let value = new y2022(0);       if (!isEmpty(inputs))     {         const k3690 = await evalValue(inputs[0], parse);          if (   !k3690             || !k3690.isValid())         {             for (let j = 1; j < inputs.length; j++)                 await evalValue(inputs[j], parse);                          return y2022.NaN.copy();         }                                                                 if (     n957(k3690.type)              && !isEmpty(k3690.items))         {             const k3689 = k3690.items[0];              if (   !k3689                 || !k3689.isValid())                 return y2022.NaN.copy();               value.value    = k3689.value;             value.decimals = k3689.decimals;              for (let i = 1; i < k3690.items.length; i++)             {                 const item = k3690.items[i];                  if (   !item                     || !item.isValid())                     return y2022.NaN.copy();                  if (item.type == c1091)                 {                     value.value   -= item.value;                     value.decimals = Math.max(value.decimals, item.decimals);                 }                                 }         }         else         {             if (k3690.type != c1091)                 return y2022.NaN.copy();              value.value    = k3690.value;             value.decimals = k3690.decimals;         }           for (let i = 1; i < inputs.length; i++)         {             const val = await evalNumberValue(inputs[i], parse);              if (   !val                 || !val.isValid())             {                 for (let j = i+1; j < inputs.length; j++)                     await evalValue(inputs[j], parse);                                  return y2022.NaN.copy();             }               if (n957(val.type))             {                 for (const item of val.items)                 {                     if (item.type == c1091)                     {                         value.value   -= item.value;                         value.decimals = Math.max(value.decimals, item.decimals);                     }                                     }             }             else             {                 x952(                      val.type == c1091,                      'val.type must be NUMBER_VALUE');                                      value.value   -= val.value;                 value.decimals = Math.max(value.decimals, val.decimals);             }         }     }       return value; }    async function f3699(node, inputs, parse) {     if (isEmpty(inputs))         return y2022.NaN.copy();       const value = new y2022(0);       if (!isEmpty(inputs))     {         value.value = 1;          for (let i = 0; i < inputs.length; i++)         {             const val = await evalValue(inputs[i], parse);              if (   !val                 || !val.isValid())             {                 for (let j = i+1; j < inputs.length; j++)                     await evalValue(inputs[j], parse);                                  return y2022.NaN.copy();             }               if (n957(val.type))             {                 if (   isEmpty(val.items)                     || val.items[0].type != c1091)                     return y2022.NaN.copy();                  for (const item of val.items)                 {                     value.value   *= item.value;                     value.decimals = Math.max(value.decimals, item.decimals);                 }             }             else             {                 x952(                      val.type == c1091,                      'val.type must be NUMBER_VALUE');                  value.value   *= val.value;                 value.decimals = Math.max(value.decimals, val.decimals);             }         }     }       return value; }    async function s3700(node, inputs, parse) {     if (isEmpty(inputs))         return y2022.NaN.copy();               let value = new y2022(0);               if (!isEmpty(inputs))     {         const k3690 = await evalValue(inputs[0], parse);          if (   !k3690             || !k3690.isValid())         {             for (let j = 1; j < inputs.length; j++)                 await evalValue(inputs[j], parse);                          return y2022.NaN.copy();         }           if (    n957(k3690.type)             && !isEmpty(k3690.items))         {             const k3689 = k3690.items[0];              if (   !k3689                 || !k3689.isValid())                 return y2022.NaN.copy();               value.value    = k3689.value;             value.decimals = k3689.decimals;              for (let i = 1; i < k3690.items.length; i++)             {                 const item = k3690.items[i];                  if (   !item                     || !item.isValid())                     return y2022.NaN.copy();                                       if (item.type == c1091)                 {                     if (item.value == 0)                      {                          value.value    = Number.NaN;                          value.decimals = 0;                         break;                      }                      value.value    = value.value / item.value;                     value.decimals = Math.max(value.decimals, item.decimals);                 }                                 }         }         else         {             if (k3690.type != c1091)                 return y2022.NaN.copy();              value.value    = k3690.value;             value.decimals = k3690.decimals;         }                   for (let i = 1; i < inputs.length; i++)         {             const val = await evalNumberValue(inputs[i], parse);              if (   !val                 || !val.isValid())             {                 for (let j = i+1; j < inputs.length; j++)                     await evalValue(inputs[j], parse);                                  return y2022.NaN.copy();             }               if (n957(val.type))             {                 for (const item of val.items)                 {                     if (   !item                         || !item.isValid())                         return y2022.NaN.copy();                       if (item.type == c1091)                     {                         if (item.value == 0)                          {                              value.value    = Number.NaN;                              value.decimals = 0;                             break;                          }                                                   value.value    = value.value / item.value;                         value.decimals = Math.max(value.decimals, item.decimals);                     }                                     }             }             else             {                 x952(                      val.type == c1091,                      'val.type must be NUMBER_VALUE');                  if (val.value == 0)                  {                      value.value    = Number.NaN;                      value.decimals = 0;                     break;                  }                                                        value.value    = value.value / val.value;                 value.decimals = Math.max(value.decimals, val.decimals);             }         }     }       return value; }    async function r3701(node, inputs, parse) {     if (isEmpty(inputs))         return y2022.NaN.copy();               const value = new y2022(0);               if (!isEmpty(inputs))     {         const k3690 = await evalValue(inputs[0], parse);          if (   !k3690             || !k3690.isValid())         {             for (let j = 1; j < inputs.length; j++)                 await evalValue(inputs[j], parse);                          return y2022.NaN.copy();         }           if (    n957(k3690.type)             && !isEmpty(k3690.items))         {             const k3689 = k3690.items[0];              if (   !k3689                 || !k3689.isValid())                 return y2022.NaN.copy();               value.value    = k3689.value;             value.decimals = k3689.decimals;              for (let i = 1; i < k3690.items.length; i++)             {                 const item = k3690.items[i];                                  if (   !item                     || !item.isValid())                     return y2022.NaN.copy();                   if (item.type == c1091)                 {                     if (item.value == 0)                      {                          value.value    = Number.NaN;                          value.decimals = 0;                         break;                      }                      value.decimals = Math.max(value.decimals, item.decimals);                     value.value    = value.value % item.value;                 }                                 }         }         else         {             if (k3690.type != c1091)                 return y2022.NaN.copy();              value.value    = k3690.value;             value.decimals = k3690.decimals;         }           for (let i = 1; i < inputs.length; i++)         {             const val = await evalNumberValue(inputs[i], parse);              if (   !val                 || !val.isValid())             {                 for (let j = i+1; j < inputs.length; j++)                     await evalValue(inputs[j], parse);                                  return y2022.NaN.copy();             }               if (n957(val.type))             {                 for (const item of val.items)                 {                     if (   !item                         || !item.isValid())                         return y2022.NaN.copy();                       if (item.type == c1091)                     {                         if (item.value == 0)                          {                              value.value    = Number.NaN;                              value.decimals = 0;                             break;                          }                          value.decimals = Math.max(value.decimals, item.decimals);                         value.value    = a1015(value.value % item.value, value.decimals);                     }                                     }             }             else             {                 x952(                      val.type == c1091,                      'val.type must be NUMBER_VALUE');                  if (val.value == 0)                  {                      value.value    = Number.NaN;                      value.decimals = 0;                     break;                  }                  value.decimals = Math.max(value.decimals, val.decimals);                 value.value    = a1015(value.value % val.value, value.decimals);             }         }     }       return value; }    async function z3702(node, inputs, parse) {     if (isEmpty(inputs))         return y2022.NaN.copy();       const value = new y2022(0);       if (!isEmpty(inputs))     {         const k3690 = await evalValue(inputs[0], parse);          if (   !k3690             || !k3690.isValid())         {             for (let j = 1; j < inputs.length; j++)                 await evalValue(inputs[j], parse);                          return y2022.NaN.copy();         }           if (    n957(k3690.type)             && !isEmpty(k3690.items))         {             const k3689 = k3690.items[0];              if (   !k3689                 || !k3689.isValid())                 return y2022.NaN.copy();               value.value    = k3689.value;             value.decimals = k3689.decimals;              for (let i = 1; i < k3690.items.length; i++)             {                 const item = k3690.items[i];                                  if (   !item                     || !item.isValid())                     return y2022.NaN.copy();                   if (item.type == c1091)                 {                     value.value    = Math.pow(value.value,    item.value);                     value.decimals = Math.max(value.decimals, item.decimals);                 }                                 }         }         else         {             if (k3690.type != c1091)                 return y2022.NaN.copy();              value.value    = k3690.value;             value.decimals = k3690.decimals;         }           for (let i = 1; i < inputs.length; i++)         {             const val = await evalNumberValue(inputs[i], parse);              if (   !val                 || !val.isValid())             {                 for (let j = i+1; j < inputs.length; j++)                     await evalValue(inputs[j], parse);                                  return y2022.NaN.copy();             }               if (n957(val.type))             {                 for (const item of val.items)                 {                     if (   !item                         || !item.isValid())                         return y2022.NaN.copy();                      if (item.type == c1091)                     {                         value.value    = Math.pow(value.value,    item.value);                         value.decimals = Math.max(value.decimals, item.decimals);                     }                                     }             }             else             {                 x952(                     val.type == c1091,                      'val.type must be NUMBER_VALUE');                  value.value    = Math.pow(value.value,    val.value);                 value.decimals = Math.max(value.decimals, val.decimals);             }         }     }       return value; }


class m1905 extends r2044 {     operation;     operand;     invert;        constructor(nodeId, options)     {         super(o1113, nodeId, options);     }            reset()     {         super.reset();          this.operation = null;         this.operand   = null;         this.invert    = null;     }        copy()     {         const copy = new w1941(this.nodeId, this.options);          copy.x3359(this);          if (this.operation) copy.operation = this.operation.copy();         if (this.operand  ) copy.operand   = this.operand  .copy();         if (this.invert   ) copy.invert    = this.invert   .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new y2022(0);           const input   = await evalNumberValue(this.input,     parse);         const op      = await evalNumberValue(this.operation, parse);         const operand = await evalNumberValue(this.operand,   parse);         const invert  = await evalNumberValue(this.invert,    parse);           if (op)         {             op.value    = Math.min(Math.max(0, Math.round(op.value)), m1311.length-1);             op.decimals = 0;         }           if (   input             && op)         {             if (this.options.enabled)             {                 if (n957(input.type))                 {                     this.value = new d2021();                      for (let i = 0; i < input.items.length; i++)                     {                         const item = input.items[i];                          this.value.items.push(                             item.type == c1091                             ? p3696(item, operand, op, invert, this.options.enabled)                             : y2022.NaN.copy());                        }                 }                 else                 {                     this.value = p3696(input, operand, op, invert, this.options.enabled);                 }             }             else                 this.value = input.copy();         }         else             this.value = y2022.NaN.copy();           this.j4101(parse,         [                          ['type',      this.outputType()],             ['operation', op               ],             ['operand',   operand          ],             ['invert',    invert           ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.operation && this.operation.isValid()             && this.operand   && this.operand  .isValid()             && this.invert    && this.invert   .isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.operation) this.operation.c4088(parse);         if (this.operand  ) this.operand  .c4088(parse);         if (this.invert   ) this.invert   .c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.operation) this.operation.t4089(parse, from, force);         if (this.operand  ) this.operand  .t4089(parse, from, force);         if (this.invert   ) this.invert   .t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.operation) this.operation.c4087(parse);         if (this.operand  ) this.operand  .c4087(parse);         if (this.invert   ) this.invert   .c4087(parse);     } }    function p3696(input, operand, op, invert, enabled) {     x952(         input.type == c1091,          'input.type is ' + input.type + ', must be NUMBER_VALUE');       if (enabled)     {         op.value = Math.min(Math.max(0, Math.floor(op.value)), m1311.length-1);          const s3695 = Math.max(input.decimals, operand.decimals);          switch (op.value)         {             case 0:                  return invert.value == 0                     ? new y2022(input.value % operand.value, s3695)                     : new y2022(operand.value % input.value, s3695);              case 1:                  if (      operand.value == 0                        && invert .value == 0                     ||    input  .value == 0                        && invert .value == 1)                     return y2022.NaN.copy();                 else                     return invert.value == 0                         ? new y2022(input.value / operand.value, s3695)                         : new y2022(operand.value / input.value, s3695);              case 2:                  return invert.value == 0                     ? new y2022(input.value - operand.value, s3695)                     : new y2022(operand.value - input.value, s3695);              case 3:                  return invert.value == 0                     ? new y2022(input.value + operand.value, s3695)                     : new y2022(operand.value + input.value, s3695);              case 4:                  return invert.value == 0                     ? new y2022(input.value * operand.value, s3695)                     : new y2022(operand.value * input.value, s3695);              case 5:                  return invert.value == 0                     ? new y2022(Math.pow(input.value, operand.value), s3695)                     : new y2022(Math.pow(operand.value, input.value), s3695);         }           h953('invalid math operation');         return input;     }     else         return input; }


class y1908 extends q1899 {     operation;        constructor(nodeId, options)     {         super(s1121, nodeId, options);     }        reset()     {         super.reset();          this.operation = null;     }           copy()     {         const copy = new y1908(this.nodeId, this.options);          copy.x3359(this);          copy.inputs    = this.inputs.map(i => i.copy());          if (this.operation) copy.operation = this.operation.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           let op = await evalNumberValue(this.operation, parse);          if (op) op = op.z3729();           op.value     =          op.y3789 = Math.min(Math.max(0, op.value), t1317.length-1);                   switch (op.value)         {             case u1313: this.value = await m3694(this.inputs, parse); break;             case q1314: this.value = await p3691 (this.inputs, parse); break;             case r1315:  this.value = await x3692  (this.inputs, parse); break;             case a1316: this.value = await g3693 (this.inputs, parse); break;         }                   this.j4101(parse,         [                          ['operation', op        ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.operation && this.operation.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.operation) this.operation.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.operation) this.operation.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.operation) this.operation.c4087(parse);     } }


class a1909 extends q1899 {     constructor(nodeId, options)     {         super(h1122, nodeId, options);     }            copy()     {         const copy = new a1909(this.nodeId, this.options);         copy.x3359(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await m3694(this.inputs, parse);                   this.j4101(parse,          [             ['', new u4217()]                      ]);           this.validate();          return this;     } }    async function m3694(inputs, parse) {     if (isEmpty(inputs))         return y2022.NaN.copy();       const value = new y2022();       if (!isEmpty(inputs))     {         const k3690 = await evalNumberValue(inputs[0], parse);         if (!k3690.isValid()) return y2022.NaN.copy();          if (    n957(k3690.type)             && !isEmpty(k3690.items))         {             const k3689 = k3690.items[0];              value.value = k3689.o3703() != 0 ? 0 : 1;              for (let i = 1; i < k3690.items.length; i++)             {                 const item = k3690.items[i];                                  if (   item.type == c1091                     && item.o3703() == 0)                     value.value = 1;             }         }         else         {             if (k3690.type != c1091)                 return y2022.NaN.copy();              value.value = k3690.o3703() != 0 ? 0 : 1;         }           for (let i = 1; i < inputs.length; i++)         {             const val = await evalNumberValue(inputs[i], parse);             if (!val.isValid()) return y2022.NaN.copy();              if (n957(val.type))             {                 for (const item of val.items)                 {                     if (   item.type == c1091                         && item.o3703() == 0)                         value.value = 1;                 }             }             else             {                 x952(                     val.type == c1091,                      'val.type must be NUMBER_VALUE');                  if (val.o3703() == 0)                     value.value = 1;             }         }     }       return value; } 


class k1907 extends q1899 {     constructor(nodeId, options)     {         super(h1123, nodeId, options);     }            copy()     {         const copy = new k1907(this.nodeId, this.options);         copy.x3359(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await g3693(this.inputs, parse);                   this.j4101(parse,          [             ['', new u4217()]                      ]);                   this.validate();          return this;     } }    async function g3693(inputs, parse) {     if (isEmpty(inputs))         return y2022.NaN.copy();       const value = new y2022();       if (!isEmpty(inputs))     {         const k3690 = await evalNumberValue(inputs[0], parse);         if (!k3690.isValid()) return y2022.NaN.copy();           if (    n957(k3690.type)             && !isEmpty(k3690.items))         {             const k3689 = k3690.items[0];              value.value = k3689.o3703();              for (let i = 1; i < k3690.items.length; i++)             {                 const item = k3690.items[i];                                  if (item.type == c1091)                     value.value = Math.min(value.value, item.o3703());             }         }         else         {             if (k3690.type != c1091)                 return y2022.NaN.copy();              value.value = k3690.o3703();         }           for (let i = 1; i < inputs.length; i++)         {             const val = await evalNumberValue(inputs[i], parse);             if (!val.isValid()) return y2022.NaN.copy();               if (n957(val.type))             {                 for (const item of val.items)                 {                     if (item.type == c1091)                         value.value = Math.min(value.value, item.o3703());                 }             }             else             {                 x952(                     val.type == c1091,                      'val.type must be NUMBER_VALUE');                  value.value = Math.min(value.value, val.o3703());             }         }                   if (value.value != 0)             value.value = 1;     }       return value; }


class s1910 extends q1899 {     constructor(nodeId, options)     {         super(r1124, nodeId, options);     }            copy()     {         const copy = new s1910(this.nodeId, this.options);          copy.x3359(this);          copy.inputs = this.inputs.map(i => i.copy());          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await x3692(this.inputs, parse);                   this.j4101(parse,          [             ['', new u4217()]                      ]);           this.validate();          return this;     } }    async function x3692(inputs, parse) {     if (isEmpty(inputs))         return y2022.NaN.copy();       const value = new y2022();       if (!isEmpty(inputs))     {         const k3690 = await evalNumberValue(inputs[0], parse);         if (!k3690.isValid()) return y2022.NaN.copy();          if (    n957(k3690.type)             && !isEmpty(k3690.items))         {             const k3689 = k3690.items[0];              value.value = k3689.o3703();              for (let i = 1; i < k3690.items.length; i++)             {                 const item = k3690.items[i];                                  if (item.type == c1091)                     value.value = Math.max(value.value, item.o3703());             }         }         else         {             if (k3690.type != c1091)                 return y2022.NaN.copy();              value.value = k3690.o3703();         }           for (let i = 1; i < inputs.length; i++)         {             const val = await evalNumberValue(inputs[i], parse);             if (!val.isValid()) return y2022.NaN.copy();              if (n957(val.type))             {                 for (const item of val.items)                 {                     if (item.type == c1091)                         value.value = Math.max(value.value, item.o3703());                 }             }             else             {                 x952(                     val.type == c1091,                      'val.type must be NUMBER_VALUE');                                      value.value = Math.max(value.value, val.o3703());             }         }           if (value.value != 0)             value.value = 1;     }       return value; }


class w1911 extends q1899 {     constructor(nodeId, options)     {         super(u1125, nodeId, options);     }            copy()     {         const copy = new w1911(this.nodeId, this.options);         copy.x3359(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await p3691(this.inputs, parse);                   this.j4101(parse,          [             ['', new u4217()]                      ]);           this.validate();          return this;     } }    async function p3691(inputs, parse) {     if (isEmpty(inputs))         return y2022.NaN.copy();       const value = new y2022(0);       let flipped;      if (!isEmpty(inputs))     {         const k3690 = await evalNumberValue(inputs[0], parse);         if (!k3690.isValid()) return y2022.NaN.copy();          if (    n957(k3690.type)             && !isEmpty(k3690.items))         {             const k3689 = k3690.items[0];              flipped = k3689.o3703() != 0;              for (let i = 1; i < k3690.items.length; i++)             {                 const item = k3690.items[i];                                  if (   item.type == c1091                     && item.o3703() != 0)                     flipped++;             }         }         else         {             if (k3690.type != c1091)                 return y2022.NaN.copy();              flipped = k3690.o3703() != 0;         }           for (let i = 1; i < inputs.length; i++)         {             const val = await evalNumberValue(inputs[i], parse);             if (!val.isValid()) return y2022.NaN.copy();              if (n957(val.type))             {                 for (const item of val.items)                 {                     if (   item.type == c1091                         && item.o3703() != 0)                         flipped++;                     }             }             else             {                 x952(                     val.type == c1091,                      'val.type must be NUMBER_VALUE');                                      if (val.o3703() != 0)                     flipped++;             }         }           value.value = flipped == 1 ? 1 : 0;     }       return value; }


class q1912 extends r2044 {     operation;     operand;        constructor(nodeId, options)     {         super(a1126, nodeId, options);     }            reset()     {         super.reset();          this.operation = null;         this.operand   = null;     }        copy()     {         const copy = new q1912(this.nodeId, this.options);          copy.x3359(this);          if (this.operation) copy.operation = this.operation.copy();         if (this.operand  ) copy.operand   = this.operand  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const op      = await evalNumberValue(this.operation, parse);         const operand = await evalNumberValue(this.operand,   parse);          op.value = Math.min(Math.max(0, op.value), u1324.length-1);                   switch (op.value)         {             case p1318:              this.value = await m3688(this.input, operand, ((a, b) => a <  b), parse);  break;             case z1319:     this.value = await m3688(this.input, operand, ((a, b) => a <= b), parse);  break;             case k1320:         this.value = await m3688(this.input, operand, ((a, b) => a != b), parse);  break;             case b1321:             this.value = await m3688(this.input, operand, ((a, b) => a == b), parse);  break;             case b1322:  this.value = await m3688(this.input, operand, ((a, b) => a >= b), parse);  break;             case i1323:           this.value = await m3688(this.input, operand, ((a, b) => a >  b), parse);  break;         }           this.j4101(parse,         [                          ['operation', op        ],             ['operand',   operand   ]         ]);           this.validate();      return this;     }        isValid()     {         return super.isValid()             && this.operation && this.operation.isValid()             && this.operand   && this.operand  .isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.operation) this.operation.c4088(parse);         if (this.operand  ) this.operand  .c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.operation) this.operation.t4089(parse, from, force);         if (this.operand  ) this.operand  .t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.operation) this.operation.c4087(parse);         if (this.operand  ) this.operand  .c4087(parse);     } }    async function m3688(l4083, m4084, op, parse)  {     const k3690 = await evalNumberValue(l4083, parse);     const val1 = await evalNumberValue(m4084, parse);      if (   k3690 && k3690.isValid()          && val1 && val1.isValid())         return new y2022(op(k3690.o3703(), val1.o3703()) ? 1 : 0);     else                           return y2022.NaN.copy(); }


class h1913 extends u2045 {     constructor(nodeId, options)     {         super(k1127, nodeId, options);     }            copy()     {         const copy = new h1913(this.nodeId, this.options);         copy.x3359(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await m3688(             this.l4083,              this.m4084,              (a, b) => a == b,              parse);                       this.j4101(parse,          [             ['', new u4217()]                      ]);           this.validate();          return this;     } } 


class t1918 extends u2045 {     constructor(nodeId, options)     {         super(w1128, nodeId, options);     }            copy()     {         const copy = new t1918(this.nodeId, this.options);         copy.x3359(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await m3688(             this.l4083,              this.m4084,              (a, b) => a != b,              parse);                   this.j4101(parse,          [             ['', new u4217()]                      ]);           this.validate();          return this;     } }


class y1916 extends u2045 {     constructor(nodeId, options)     {         super(k1129, nodeId, options);     }            copy()     {         const copy = new y1916(this.nodeId, this.options);         copy.x3359(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await m3688(             this.l4083,              this.m4084,              (a, b) => a < b,              parse);                       this.j4101(parse,          [             ['', new u4217()]                      ]);           this.validate();          return this;     } }


class b1917 extends u2045 {     constructor(nodeId, options)     {         super(g1130, nodeId, options);     }            copy()     {         const copy = new b1917(this.nodeId, this.options);         copy.x3359(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await m3688(             this.l4083,              this.m4084,              (a, b) => a <= b,              parse);                       this.j4101(parse,          [             ['', new u4217()]                      ]);           this.validate();          return this;     } } 


class o1914 extends u2045 {     constructor(nodeId, options)     {         super(b1131, nodeId, options);     }            copy()     {         const copy = new o1914(this.nodeId, this.options);         copy.x3359(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await m3688(             this.l4083,              this.m4084,              (a, b) => a > b,              parse);                   this.j4101(parse,          [             ['', new u4217()]                      ]);           this.validate();          return this;     } }


class o1915 extends u2045 {     constructor(nodeId, options)     {         super(q1132, nodeId, options);     }            copy()     {         const copy = new o1915(this.nodeId, this.options);          copy.x3359(this);          copy.inputs = this.inputs.map(i => i.copy());          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await m3688(             this.l4083,              this.m4084,              (a, b) => a >= b,              parse);                       this.j4101(parse,          [             ['', new u4217()]                      ]);           this.validate();          return this;     } } 


class t1923 extends r2044 {     function;        constructor(nodeId, options)     {         super(a1133, nodeId, options);     }            reset()     {         super.reset();          this.function = null;     }        copy()     {         const copy = new t1923(this.nodeId, this.options);          copy.x3359(this);          if (this.function) copy.function = this.function.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalNumberValue(this.input,    parse);         const func  = await evalNumberValue(this.function, parse);          func.value = Math.min(Math.max(0, func.value), m1331.length-1);                   if (input)         {             if (n957(input.type))             {                 this.value = new d2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == c1091                         ? await getTrigValue(item, func, this.options.enabled)                         : y2022.NaN.copy());                    }             }             else                 this.value = await getTrigValue(input, func, this.options.enabled); }         else             this.value = y2022.NaN.copy();           this.j4101(parse,         [             ['type',     this.outputType()],             ['function', func             ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.function && this.function.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.function) this.function.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.function) this.function.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.function) this.function.c4087(parse);     } }    async function getTrigValue(input, func, enabled) {     x952(         input.type == c1091,         'input.type must be NUMBER_VALUE');       if (!enabled)         return input;       switch (func.value)     {         case v1325:  return await w4236   (input, false);         case b1326:  return await k4237 (input, false);         case e1327:  return await v4238(input, false);         case b1328: return await w4236   (input, true );         case y1329: return await k4237 (input, true );         case r1330: return await v4238(input, true );     } }


class v1921 extends r2044 {     constructor(nodeId, options)     {         super(k1134, nodeId, options);     }            copy()     {         const copy = new v1921(this.nodeId, this.options);                  copy.x3359(this);          if (this.input) copy.input = this.input.copy();                  return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await w4236(this.input, parse);           this.j4101(parse,          [             ['', new u4217()]                      ]);           this.validate();          return this;     }        r3633()     {         return this.value.copy();     } }    async function w4236(input, arc) {     if (!input)         return y2022.NaN.copy();      const val =          !arc          ? Math.sin (input.value)          : Math.asin(input.value);      return new y2022(val, n1004(val)); }


class z1920 extends r2044 {     constructor(nodeId, options)     {         super(e1135, nodeId, options);     }            copy()     {         const copy = new z1920(this.nodeId, this.options);                  copy.x3359(this);          if (this.input) copy.input = this.input.copy();                  return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await k4237(this.input, parse);           this.j4101(parse,          [             ['', new u4217()]                      ]);           this.validate();          return this;     } }    async function k4237(input, arc) {     if (!input)         return y2022.NaN.copy();      const val =          !arc          ? Math.cos (input.value)          : Math.acos(input.value);     return new y2022(val, n1004(val)); }


class g1922 extends r2044 {     constructor(nodeId, options)     {         super(w1136, nodeId, options);     }            copy()     {         const copy = new g1922(this.nodeId, this.options);                  copy.x3359(this);          if (this.input) copy.input = this.input.copy();                  return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await v4238(this.input, parse);           this.j4101(parse,          [             ['', new u4217()]                      ]);           this.validate();          return this;     } }    async function v4238(input, arc) {     if (!input)         return y2022.NaN.copy();      const val =          !arc          ? Math.tan (input.value)          : Math.atan(input.value);          return new y2022(val, n1004(val)); }


class e1919 extends z2043 {     x;     y;            constructor(nodeId, options)     {         super(l1137, nodeId, options);     }            reset()     {         super.reset();          this.x = null;         this.y = null;     }        copy()     {         const copy = new e1919(this.nodeId, this.options);          copy.x3359(this);          if (this.x) copy.x = this.x.copy();         if (this.y) copy.y = this.y.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const x = await evalNumberValue(this.x, parse);         const y = await evalNumberValue(this.y, parse);           this.value = new y2022(Math.atan2(y.value, x.value));           this.j4101(parse,         [                          ['x',     x         ],             ['y',     y         ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.x && this.x.isValid()             && this.y && this.y.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.x) this.x.c4088(parse);         if (this.y) this.y.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.x) this.x.t4089(parse, from, force);         if (this.y) this.y.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.x) this.x.c4087(parse);         if (this.y) this.y.c4087(parse);     } } 


class q1928 extends r2044 {     from;        constructor(nodeId, options)     {         super(o1138, nodeId, options);     }            reset()     {         super.reset();          this.from = null;     }        copy()     {         const copy = new q1928(this.nodeId, this.options);          copy.x3359(this);          if (this.from) copy.from = this.from.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new y2022(0);                   const input = await evalNumberValue(this.input, parse);         const from  = await evalNumberValue(this.from,  parse);           if (input)         {             if (n957(input.type))             {                 this.value = new d2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == c1091                         ? getConvertAngleValue(item, from, this.options.enabled)                         : y2022.NaN.copy());                    }             }             else                 this.value = getConvertAngleValue(input, from, this.options.enabled);         }         else             this.value = y2022.NaN.copy();           this.j4101(parse,         [             ['type',  this.outputType()],                          ['from',  from             ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.from && this.from.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.from) this.from.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.from) this.from.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.from) this.from.c4087(parse);     } }    function getConvertAngleValue(input, from, enabled) {     x952(          input == c1091,          'input must be NUMBER_VALUE');               const value = input;          if (enabled)     {         switch (from.value)         {             case 0: value.value = value.value/360 * Tau; break;             case 1: value.value = value.value/Tau * 360; break;         }          value.decimals = n1004(value.value);     }       return value; }


class n1992 extends r2044 {     constructor(nodeId, options)     {         super(y1144, nodeId, options);     }        copy()     {         const copy = new n1992(this.nodeId, this.options);                  copy.x3359(this);          copy.value = this.value;                  return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           if (this.input)             this.value = await evalTextValue(this.input, parse);         else if (this.value)             await this.value.eval(parse);         else             this.value = new c2033();           this.j4101(parse,         [             ['value', this.value]         ]);                   this.validate();          return this;     }        isValid()     {         return   !this.input                && this.value != p963              || this.input.isValid();     } }


class e2000 extends r2044 {     length;        constructor(nodeId, options)     {         super(r1145, nodeId, options);     }            reset()     {         super.reset();          this.length = null;     }        copy()     {         const copy = new e2000(this.nodeId, this.options);          copy.x3359(this);          if (this.length) copy.length = this.length.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalTextValue(this.input, parse);          if (   input             && input.value)         {             x952(input.type == g1143, 'input must be TEXT_VALUE');              this.length = new y2022(input.value.length);         }         else             this.length = y2022.NaN.copy();               this.j4101(parse,         [             ['length', this.length]         ]);           this.validate();          return this;     } } 


class x2007 extends r2044 {     start = null;     end   = null;            constructor(nodeId, options)     {         super(b1146, nodeId, options);     }            reset()     {         super.reset();          this.start = null;         this.end   = null;     }        copy()     {         const copy = new x2007(this.nodeId, this.options);          copy.x3359(this);          if (this.start) copy.start = this.start.copy();         if (this.end  ) copy.end   = this.end  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const start = await evalNumberValue(this.start, parse);         const end   = await evalNumberValue(this.end,   parse);           if (this.input)         {             const input = await evalTextValue(this.input, parse);                          if (n957(input.type))             {                 this.value = new d2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == g1143                         ? w3430(item, start, end, this.options.enabled)                         : new c2033());                    }             }             else             {                 this.value = w3430(input, start, end, this.options.enabled);             }         }         else             this.value = new c2033();           this.j4101(parse,         [                          ['type',  this.outputType()],             ['start', start            ],             ['end',   end              ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.start && this.start.isValid()             && this.end   && this.end  .isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.start) this.start.c4088(parse);         if (this.end  ) this.end  .c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.start) this.start.t4089(parse, from, force);         if (this.end  ) this.end  .t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.start) this.start.c4087(parse);         if (this.end  ) this.end  .c4087(parse);     } }    function w3430(input, start, end, enabled) {     x952(input.type == g1143, 'input.type must be TEXT_VALUE');                     const value = input.copy();      if (enabled)     {         if (start.value.length > 0) value.value = z954(value.value, e1490(start.value));         if (end  .value.length > 0) value.value = h955  (value.value, e1490(end  .value));     }      return value; }


class z2004 extends r2044 {     start = null;     end   = null;            constructor(nodeId, options)     {         super(y1147, nodeId, options);     }            reset()     {         super.reset();          this.start = null;         this.end   = null;     }        copy()     {         const copy = new z2004(this.nodeId, this.options);          copy.x3359(this);          if (this.start) copy.start = this.start.copy();         if (this.end  ) copy.end   = this.end  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalTextValue  (this.input, parse);         const start = await evalNumberValue(this.start, parse);         const end   = await evalNumberValue(this.end,   parse);           let length = 0;           if (   input             && start             && end)         {             length = input.value.length;                          this.value = input.copy();                          x952(this.value.type == g1143, 'this.value.type must be TEXT_VALUE');                                               const _end =                 end.isValid()                 ? end                 : new y2022(input.value.length);               if (this.options.enabled)             {                 const endValue =                      _end.value < 0                     ? length + _end.value                     : _end.value;                  if (start.value <= endValue)                     this.value.value = this.value.value.substring(start.value, endValue);                 else                     this.value = new c2033();             }             else                 this.value = input.copy();         }         else             this.value = new c2033();           this.j4101(parse,         [             ['length',     new y2022(length)                        ],              ['fullLength', new y2022(input ? input.value.length : 0)],              ['start',      start                                          ],             ['end',        end                                            ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.start && this.start.isValid()             && this.end   && this.end  .isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.start) this.start.c4088(parse);         if (this.end  ) this.end  .c4088(parse);     }        c4088(parse)     {         super.c4088(parse);          if (this.start) this.start.c4088(parse);         if (this.end  ) this.end  .c4088(parse);     }        c4087(parse, from)     {         super.c4087(parse, from);          if (this.start) this.start.c4087(parse, from);         if (this.end  ) this.end  .c4087(parse, from);     } } 


class h1995 extends u2045 {     first;     last;     all;        constructor(nodeId, options)     {         super(b1148, nodeId, options);     }            reset()     {         super.reset();          this.first = null;         this.last  = null;         this.all   = null;     }        copy()     {         const copy = new h1995(this.nodeId, this.options);          copy.x3359(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const l4083 = await evalTextValue(this.l4083, parse);         const m4084 = await evalTextValue(this.m4084, parse);               if (   l4083 && l4083.isValid()              && m4084 && m4084.isValid())         {             const indices = [];             let   index   = 0;              if (m4084.value != '')             {                 while (index != -1)                  {                     index = l4083.value.indexOf(m4084.value, index);                      if (index != -1)                      {                         indices.push(index);                         index += 1;                     }                 }                                   this.value = new y2022(indices.length > 0 ? 1 : 0);                  this.first = indices.length > 0 ? new y2022(indices.at( 0)) : y2022.NaN.copy();                 this.last  = indices.length > 0 ? new y2022(indices.at(-1)) : y2022.NaN.copy();                  this.all   = new d2021();                  for (const index of indices)                     this.all.items.push(new y2022(index));             }             else             {                 this.value = new y2022(1);                  this.first = y2022.NaN.copy();                 this.last  = y2022.NaN.copy();                 this.all   =   d2021.NaN.copy();             }         }         else                           {             this.value = y2022.NaN.copy();             this.first = y2022.NaN.copy();             this.last  = y2022.NaN.copy();             this.all   =   d2021.NaN.copy();         }               this.j4101(parse,         [             ['value', this.value],             ['first', this.first],             ['last',  this.last ],             ['all',   this.all  ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.first && this.first.isValid()             && this.last  && this.last .isValid()             && this.all   && this.all  .isValid();     } }


class y1993 extends r2044 {     case;            constructor(nodeId, options)     {         super(h1149, nodeId, options);     }            reset()     {         super.reset();          this.case = null;     }        copy()     {         const copy = new y1993(this.nodeId, this.options);          copy.x3359(this);          if (this.case) copy.case = this.case.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalTextValue  (this.input, parse);         const t3659 = await evalNumberValue(this.case,  parse);           if (input)         {             if (this.options.enabled)             {                 if (n957(input.type))                 {                     this.value = new d2021();                      for (let i = 0; i < input.items.length; i++)                     {                         const item = input.items[i];                          this.value.items.push(                             item.type == g1143                             ? getTextCaseValue(item, t3659)                             : new c2033());                        }                 }                 else                 {                     this.value = getTextCaseValue(input, t3659);                 }             }             else                 this.value = input.copy();         }         else             this.value = new c2033();           this.j4101(parse,         [                          ['type',   this.outputType()],             ['case',  t3659             ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.case && this.case.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.case) this.case.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.case) this.case.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.case) this.case.c4087(parse);     } }    function getTextCaseValue(input, t3659) {     x952(input.type == g1143, 'input.type must be TEXT_VALUE');      const val   = input.value;     const value = new c2033();           if (t3659.value == 0)           value.value = val.toLowerCase();      else if (t3659.value == 1)     {         if (val.length > 0) value.value += val.substring(0, 1).toUpperCase();         if (val.length > 1) value.value += val.substring(1)   .toLowerCase();     }      else if (t3659.value == 2)     {         let i = 0;         while (i < val.length)         {             while (i < val.length                 && /\s/.test(val.charAt(i)))                 value.value += val.charAt(i++);              if (i < val.length)                 value.value += val.charAt(i++).toUpperCase();              while (i < val.length                 && !/\s/.test(val.charAt(i)))                 value.value += val.charAt(i++).toLowerCase();         }     }      else if (t3659.value == 3)          value.value = val.toUpperCase();       return value; }


class s1991 extends r2044 {     base;     decimals;     thousands;            constructor(nodeId, options)     {         super(g1157, nodeId, options);     }            reset()     {         super.reset();          this.base      = null;         this.decimals  = null;         this.thousands = null;     }        copy()     {         const copy = new s1991(this.nodeId, this.options);          copy.x3359(this);          if (this.base     ) copy.base      = this.base     .copy();         if (this.decimals ) copy.decimals  = this.decimals .copy();         if (this.thousands) copy.thousands = this.thousands.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input     = await evalNumberValue(this.input,     parse);         const base      = await evalNumberValue(this.base,      parse);         const decimals  = await evalNumberValue(this.decimals,  parse);         const thousands = await evalNumberValue(this.thousands, parse);           if (input)         {             if (n957(input.type))             {                 this.value = new d2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == c1091                         ? e3431(item, base, decimals, thousands)                         : c2033.NaN.copy());                    }             }             else             {                 this.value = e3431(input, base, decimals, thousands);             }         }         else             this.value = c2033.NaN.copy();           this.j4101(parse,         [                          ['type',      this.outputType()],             ['base',      base             ],             ['decimals',  decimals         ],             ['thousands', thousands        ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.base      && this.base     .isValid()             && this.decimals  && this.decimals .isValid()             && this.thousands && this.thousands.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.base     ) this.base     .c4088(parse);         if (this.decimals ) this.decimals .c4088(parse);         if (this.thousands) this.thousands.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.base     ) this.base     .t4089(parse, from, force);         if (this.decimals ) this.decimals .t4089(parse, from, force);         if (this.thousands) this.thousands.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.base     ) this.base     .c4087(parse);         if (this.decimals ) this.decimals .c4087(parse);         if (this.thousands) this.thousands.c4087(parse);     } }    function e3431(input, base, decimals, thousands) {     return input.isValid()          ? new c2033(g1006(                input.value,                -input.decimals,                 base.value == 1,                 decimals.value,                 thousands.value))          : new c2033('?'); }


class z1989 extends r2044 {     format;            constructor(nodeId, options)     {         super(w1158, nodeId, options);     }       reset()     {         super.reset();          this.format = null;     }            copy()     {         const copy = new z1989(this.nodeId, this.options);          copy.x3359(this);          if (this.format) copy.format = this.format.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalColorValue (this.input,  parse);         const format = await evalNumberValue(this.format, parse);           if (input)         {             if (n957(input.type))             {                 this.value = new d2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == c1091                         ? getColorToTextValue(item, format)                         : c2033.NaN.copy());                    }             }             else             {                 this.value = getColorToTextValue(input, format);             }         }          else             this.value = c2033.NaN.copy();           this.j4101(parse,         [             ['type',   this.outputType()],             ['format', format           ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.format && this.format.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.format) this.format.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.format) this.format.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.format) this.format.c4087(parse);     } }    function getColorToTextValue(input, format) {     let str = p963;      const rgb = input.p3242();      switch (format.value)     {         case 0:              str = u151(rgb);             break;          case 1:              str =                    g1006(rgb[0], -3) + ', '                 + g1006(rgb[1], -3) + ', '                 + g1006(rgb[2], -3);             break;          case 2:              str =                    Math.round(rgb[0] * 255) + ', '                 + Math.round(rgb[1] * 255) + ', '                 + Math.round(rgb[2] * 255);             break;          case 3:              str = createColorName(rgb);             break;     }      return new c2033(str); }


class d2006 extends r2044 {     base      = null;     decimals  = null;     thousands = null;            constructor(nodeId, options)     {         super(g1159, nodeId, options);     }            reset()     {         super.reset();          this.base      = null;         this.decimals  = null;         this.thousands = null;     }        copy()     {         const copy = new d2006(this.nodeId, this.options);          copy.x3359(this);          if (this.base     ) copy.base      = this.base     .copy();         if (this.decimals ) copy.decimals  = this.decimals .copy();         if (this.thousands) copy.thousands = this.thousands.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input     = await evalTextValue  (this.input,     parse);         const base      = await evalNumberValue(this.base,      parse);         const decimals  = await evalNumberValue(this.decimals,  parse);         const thousands = await evalTextValue  (this.thousands, parse);           if (   input             && input.isValid())         {             if (n957(input.type))             {                 this.value = new d2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == g1143                         ? getTextToNumberValue(item, base, decimals, thousands)                         : y2022.NaN.copy());                    }             }             else                 this.value = getTextToNumberValue(input, base, decimals, thousands);         }          else             this.value = y2022.NaN.copy();           this.j4101(parse,         [             ['type',      this.outputType()],             ['base',      base             ],             ['decimals',  decimals         ],             ['thousands', thousands        ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.base      && this.base     .isValid()             && this.decimals  && this.decimals .isValid()             && this.thousands && this.thousands.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.base     ) this.base     .c4088(parse);         if (this.decimals ) this.decimals .c4088(parse);         if (this.thousands) this.thousands.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.base     ) this.base     .t4089(parse, from, force);         if (this.decimals ) this.decimals .t4089(parse, from, force);         if (this.thousands) this.thousands.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.base     ) this.base     .c4087(parse);         if (this.decimals ) this.decimals .c4087(parse);         if (this.thousands) this.thousands.c4087(parse);     } }    function getTextToNumberValue(input, base, decimals, thousands) {     let num   = Number.NaN;     let value = input.value;      if (thousands)         value = value.replaceAll(thousands.value, '');           if (base)     {         switch (base.value)         {             case 0:              {                 if (value.lastIndexOf(decimals.value) < 0)                     num = parseInt(value.replace(/\D/g, ''), 10);                 else                 {                     value = v1497(value, decimals.value, '.');                     num   = parseFloat(value);                 }                          break;             }             case 1:              {                 const decIndex = value.lastIndexOf(decimals.value);                  if (decIndex < -1)                     num = parseInt(value, 16);                 else                 {                     const whole = value.slice(0, decIndex);                     const frac  = value.slice(decIndex + decimals.value.length);                      num =                          parseInt(whole, 16)                         + frac.split('')                             .reduce((sum, digit, index) => sum + parseInt(digit, 16) / Math.pow(16, index + 1), 0);                 }                  break;             }         }     }       return new y2022(num, n1004(num)); }


class x2005 extends r2044 {     constructor(nodeId, options)     {         super(x1160, nodeId, options);     }            copy()     {         const copy = new x2005(this.nodeId, this.options);          copy.x3359(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           if (this.input)         {             const input = await evalTextValue(this.input, parse);              if (n957(input.type))             {                 this.value = new d2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == g1143                         ? getTextToColorValue(item)                         : y2022.NaN.copy());                    }             }             else             {                 this.value = getTextToColorValue(input);             }         }         else             this.value = h2010.NaN.copy();           this.j4101(parse,         [             ['value', this.value       ],             ['type',  this.outputType()]         ]);           this.validate();          return this;     } }    function getTextToColorValue(input) {     const str = input.value.trim();       let rgb;        if (settings.preferHtmlColorNames)     {                    let webColor = d1499.find(wc => wc.name.toLowerCase() == str);         if (!webColor) webColor = d1499.find(wc => m1491(wc.name.toLowerCase(), str) <= 1);                  if (webColor)              rgb = i153(webColor.color);     }     else     {         const hsl = parseColorName(str);          rgb =              hsl              ? v50(hsl)              : i153(str);     }           return h2010.y3773(n4142(rgb)); }


class n1988 extends r2044 {     constructor(nodeId, options)     {         super(m1154, nodeId, options);     }            copy()     {         const copy = new n1988(this.nodeId, this.options);          copy.x3359(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalNumberValue(this.input, parse);           if (input)         {             if (n957(input.type))             {                 this.value = new d2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == c1091                         ? getCodeToCharacterValue(item)                         : c2033.NaN.copy());                    }             }             else             {                 this.value = getCodeToCharacterValue(input);             }         }         else             this.value = c2033.NaN.copy();           this.j4101(parse,         [                          ['type',  this.outputType()]         ]);           this.validate();          return this;     } }    function getCodeToCharacterValue(input) {     return new c2033(String.fromCharCode(Math.min(Math.max(0, input.value), 0xffff))); }


class x1987 extends r2044 {     constructor(nodeId, options)     {         super(j1155, nodeId, options);     }            copy()     {         const copy = new x1987(this.nodeId, this.options);          copy.x3359(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalTextValue(this.input, parse);           if (input)         {             if (n957(input.type))             {                 this.value = new d2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == g1143                         ? getCharacterToCodeValue(item)                         : y2022.NaN.copy());                    }             }             else             {                 this.value = getCharacterToCodeValue(input);             }         }         else             this.value = y2022.NaN.copy();           this.j4101(parse,         [                          ['type',  this.outputType()]         ]);           this.validate();          return this;     } }    function getCharacterToCodeValue(input) {     return input.value.length > 0          ? new y2022(input.value.charCodeAt(0))          : y2022.NaN.copy(); }


class i1990 extends z2043 {     name;     index;            constructor(nodeId, options)     {         super(y1156, nodeId, options);     }            reset()     {         super.reset();          this.index = null;     }        copy()     {         const copy = new i1990(this.nodeId, this.options);          copy.x3359(this);          if (this.name ) copy.name  = this.name .copy();         if (this.index) copy.index = this.index.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const name  = await evalTextValue  (this.name,  parse);         const index = await evalNumberValue(this.index, parse);           switch (name.value)         {             case 0: this.value = new c2033(                 [                     'monday',                      'tuesday',                      'wednesday',                      'thursday',                      'friday',                      'saturday',                      'sunday'                 ]                  [index.value-1]);                  break;              case 1: this.value = new c2033(                 [                     'january',                      'february',                      'march',                      'april',                      'may',                      'june',                      'july',                     'august',                     'september',                     'october',                     'november',                     'december'                 ]                  [index.value-1]);                  break;              case 2:                 this.value = new c2033(j4039[index.value]);                 break;          }           this.j4101(parse,         [                          ['name',  name      ],             ['index', index     ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.index && this.index.isValid()             && this.name  && this.name .isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.index) this.index.c4088(parse);         if (this.name ) this.name .c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.index) this.index.t4089(parse, from, force);         if (this.name ) this.name .t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.index) this.index.c4087(parse);         if (this.name ) this.name .c4087(parse);     } } 


class a2002 extends r2044 {     what  = null;     with  = null;     regex = null;        constructor(nodeId, options)     {         super(j1150, nodeId, options);     }            reset()     {         super.reset();          this.what  = null;         this.with  = null;         this.regex = null;     }        copy()     {         const copy = new a2002(this.nodeId, this.options);          copy.x3359(this);          if (this.what ) copy.what  = this.what .copy();         if (this.with ) copy.with  = this.with .copy();         if (this.regex) copy.regex = this.regex.copy();          if (this.value) copy.value = this.value.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const  input = await evalTextValue  (this.input, parse);         const _what  = await evalTextValue  (this.what,  parse);         const _with  = await evalTextValue  (this.with,  parse);         const _regex = await evalNumberValue(this.regex, parse);           if (input)         {             if (this.options.enabled)             {                 if (n957(input.type))                 {                     this.value = new d2021();                      for (let i = 0; i < input.items.length; i++)                     {                         const item = input.items[i];                          this.value.items.push(                             item.type == g1143                             ? getReplaceValue(item, _what, _with, _regex)                             : new c2033());                        }                 }                 else                 {                     this.value = getReplaceValue(input, _what, _with, _regex);                 }             }             else                 this.value = input.copy();         }         else             this.value = new c2033();           this.j4101(parse,         [                          ['type',   this.outputType()],             ['what',  _what             ],             ['with',  _with             ],             ['regex', _regex            ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.what  && this.what .isValid()             && this.with  && this.with .isValid()             && this.regex && this.regex.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.what ) this.what .c4088(parse);         if (this.with ) this.with .c4088(parse);         if (this.regex) this.regex.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.what ) this.what .t4089(parse, from, force);         if (this.with ) this.with .t4089(parse, from, force);         if (this.regex) this.regex.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.what ) this.what .c4087(parse);         if (this.with ) this.with .c4087(parse);         if (this.regex) this.regex.c4087(parse);     } }    function getReplaceValue(input, _what, _with, _regex) {     x952(input.type == g1143, 'input.type must be TEXT_VALUE');      const value = new c2033();           if (_regex.value > 0)     {         try         {             value.value = input.value.replace(                 new RegExp(unescapeRegexPattern(_what.value), 'gu'),                 unescapeRegexReplacement(_with.value));         }         catch (e)         {             t4042(e.message, {error: true});         }     }     else if (input.value)     {         value.value = input.value.replaceAll(             e1490(_what.value),             e1490(_with.value));     }       return value; }


class g1999 extends z2043 {     inputs = [];      with = null;            constructor(nodeId, options)     {         super(k1151, nodeId, options);     }        reset()     {         super.reset();          this.inputs = [];                  this.with = null;     }           copy()     {         const copy = new g1999(this.nodeId, this.options);         copy.x3359(this);                  copy.inputs = this.inputs.map(i => i.copy());         copy.with   = this.with;          return copy;     }        isCached()     {         for (const input of this.inputs)             if (!input.isCached())                 return false;          return super.isCached();     }        async eval(parse)     {         if (this.isCached())             return this;           const _with = await evalTextValue(this.with, parse);          this.value = await evalJoinInputs(this.inputs, _with, parse);                   this.j4101(parse,         [                          ['with',  _with     ]         ]);           this.validate();          return this;     }        isValid()     {         return !this.inputs.find(i => !i.isValid())             && this.with && this.with.isValid();     }        c4088(parse)     {         super.c4088(parse);          this.inputs.forEach(i => i.c4088(parse));          if (this.with) this.with.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          this.inputs.forEach(i => i.t4089(parse, from, force));          if (this.with) this.with.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          this.inputs.forEach(i => i.c4087(parse));          if (this.with) this.with.c4087(parse);     } }    async function evalJoinInputs(inputs, _with, parse) {     if (isEmpty(inputs))         return new c2033();       const value = new c2033();     const w     = e1490(_with.value);      for (let i = 0; i < inputs.length; i++)     {         const val = await evalTextValue(inputs[i], parse);         if (!val) continue;           if (i > 0)             value.value += w;           if (n957(val.type))         {             for (let j = 0; j < val.items.length; j++)             {                 if (j > 0)                     value.value += w;                   const item = val.items[j];                  if (item.type == g1143)                     value.value += item.value;             }         }         else         {             x952(val.type == g1143, 'val.type must be TEXT_VALUE');              value.value += val.value;         }     }       return value; }


class w2001 extends r2044 {     p3655   = null;     q3656 = null;     l3657     = null;     n3658   = null;                    constructor(nodeId, options)     {         super(r1152, nodeId, options);     }            reset()     {         super.reset();                  this.p3655   = null;         this.q3656 = null;         this.l3657     = null;         this.n3658   = null;     }        copy()     {         const copy = new w2001(this.nodeId, this.options);          copy.x3359(this);          if (this.p3655  ) copy.p3655   = this.p3655  .copy();         if (this.q3656) copy.q3656 = this.q3656.copy();         if (this.l3657    ) copy.l3657     = this.l3657    .copy();         if (this.n3658  ) copy.n3658   = this.n3658  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const p3655   = await evalTextValue  (this.p3655,   parse);         const q3656 = await evalNumberValue(this.q3656, parse);         const l3657     = await evalTextValue  (this.l3657,     parse);         const n3658   = await evalNumberValue(this.n3658,   parse);           if (this.input)         {             const input = await evalTextValue(this.input, parse);                          if (n957(input.type))             {                 this.value = new d2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == g1143                         ? getPadValue(                             item,                              p3655,                              q3656,                              l3657,                              n3658,                              this.options.enabled)                         : new c2033());                    }             }             else             {                 this.value = getPadValue(                     input,                      p3655,                      q3656,                      l3657,                      n3658,                      this.options.enabled);             }         }         else             this.value = new c2033();           this.j4101(parse,         [                          ['type',       this.outputType()],             ['startPad',   p3655         ],             ['startCount', q3656       ],             ['endPad',     l3657           ],             ['endCount',   n3658         ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.p3655   && this.p3655  .isValid()             && this.q3656 && this.q3656.isValid()             && this.l3657     && this.l3657    .isValid()             && this.n3658   && this.n3658  .isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.p3655  ) this.p3655  .c4088(parse);         if (this.q3656) this.q3656.c4088(parse);         if (this.l3657    ) this.l3657    .c4088(parse);         if (this.n3658  ) this.n3658  .c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.p3655  ) this.p3655  .t4089(parse, from, force);         if (this.q3656) this.q3656.t4089(parse, from, force);         if (this.l3657    ) this.l3657    .t4089(parse, from, force);         if (this.n3658  ) this.n3658  .t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.p3655  ) this.p3655  .c4087(parse);         if (this.q3656) this.q3656.c4087(parse);         if (this.l3657    ) this.l3657    .c4087(parse);         if (this.n3658  ) this.n3658  .c4087(parse);     } }    function getPadValue(input, p3655, q3656, l3657, n3658, enabled) {     x952(input.type == g1143, 'input.type must be TEXT_VALUE');      const value = input.copy();          if (enabled)         value.value = input.value             .padStart(q3656.value, e1490(p3655.value))             .padEnd  (  n3658.value, l3657.value != '' ? e1490(l3657.value) : e1490(p3655.value));      return value; }


class o2003 extends r2044 {     separator;        constructor(nodeId, options)     {         super(t1161, nodeId, options);     }        reset()     {         super.reset();          this.separator = null;     }           copy()     {         const copy = new o2003(this.nodeId, this.options);          copy.x3359(this);          if (this.separator) copy.separator = this.separator.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const separator = await evalTextValue(this.separator, parse);           this.value = new d2021();           if (   this.input             && separator)         {             const input = await evalTextValue(this.input, parse);                          if (   input                 && input.value)             {                 x952(input.type == g1143, 'input must be TEXT_VALUE');                 const items = input.value.split(e1490(separator.value));                  for (const item of items)                     this.value.items.push(new c2033(item));             }         }               this.j4101(parse,         [             ['length',    new y2022(this.value.items.length)],             ['separator', separator                               ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.separator && this.separator.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.separator) this.separator.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.separator) this.separator.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.separator) this.separator.c4087(parse);     } } 


class z1994 extends u2045 {     operation;        constructor(nodeId, options)     {         super(s1153, nodeId, options);     }            reset()     {         super.reset();          this.operation = null;     }        copy()     {         const copy = new z1994(this.nodeId, this.options);          copy.x3359(this);          if (this.operation) copy.operation = this.operation.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = y2022.NaN.copy();                           const op = await evalNumberValue(this.operation, parse);                   if (op)         {             op.value = Math.min(Math.max(0, op.value), u1324.length-1);              switch (op.value)             {                 case p1318:              this.value = await evalCompareInputs(this.l4083, this.m4084, ((a, b) => a <  b), parse);  break;                 case z1319:     this.value = await evalCompareInputs(this.l4083, this.m4084, ((a, b) => a <= b), parse);  break;                 case k1320:         this.value = await evalCompareInputs(this.l4083, this.m4084, ((a, b) => a != b), parse);  break;                 case b1321:             this.value = await evalCompareInputs(this.l4083, this.m4084, ((a, b) => a == b), parse);  break;                 case b1322:  this.value = await evalCompareInputs(this.l4083, this.m4084, ((a, b) => a >= b), parse);  break;                 case i1323:           this.value = await evalCompareInputs(this.l4083, this.m4084, ((a, b) => a >  b), parse);  break;             }         }           this.j4101(parse,         [             ['value',     this.value],             ['operation', op        ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.operation && this.operation.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.operation) this.operation.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.operation) this.operation.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.operation) this.operation.c4087(parse);     } }    async function evalCompareInputs(l4083, m4084, op, parse)  {     const k3690 = await evalTextValue(l4083, parse);     const val1 = await evalTextValue(m4084, parse);      if (   k3690 && k3690.isValid()          && val1 && val1.isValid())         return new y2022(op(k3690.value, val1.value) ? 1 : 0);     else                           return new u4217(); }


class d1996 extends r2044 {     p3648;     o3649;        constructor(nodeId, options)     {         super(z1163, nodeId, options);     }            reset()     {         super.reset();          this.p3648    = null;         this.o3649 = null;     }        copy()     {         const copy = new d1996(this.nodeId, this.options);          copy.x3359(this);          if (this.p3648   ) copy.p3648    = this.p3648   .copy();         if (this.o3649) copy.o3649 = this.o3649.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const p3648    = await evalTextValue(this.p3648,    parse);         const o3649 = await evalTextValue(this.o3649, parse);           this.value = new d2021();           let maxColumns = 0;                   let nRows    = 0;         let nColumns = 0;           if (   this.input             && p3648             && o3649             && p3648.value != '')         {             const input = await evalTextValue(this.input, parse);                           const rows =                     input                 && input.value                             ? input.value.split(e1490(p3648.value))                 : [];               for (const _row of rows)             {                 const cells =                      _row                     ? _row.split(e1490(o3649.value))                     : [];                   const row = new d2021();                  for (const cell of cells)                     row.items.push(new c2033(cell));                  maxColumns = Math.max(maxColumns, row.items.length);                   this.value.items.push(row);             }               nRows    = this.value.items.length;             nColumns = maxColumns;         }               this.j4101(parse,         [             ['rowSeparator',    p3648             ],             ['columnSeparator', o3649          ],             ['rows',            new y2022(nRows   )],             ['columns',         new y2022(nColumns)]         ]);                   if (parse.settings.o3734)         {             this.j4101(parse,             [                 ['preview', new d2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.p3648    && this.p3648   .isValid()             && this.o3649 && this.o3649.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.p3648   ) this.p3648   .c4088(parse);         if (this.o3649) this.o3649.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.p3648   ) this.p3648   .t4089(parse, from, force);         if (this.o3649) this.o3649.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.p3648   ) this.p3648   .c4087(parse);         if (this.o3649) this.o3649.c4087(parse);     } } 


class GTextJson extends r2044 {     constructor(nodeId, options)     {         super(v3505, nodeId, options);     }            copy()     {         const copy = new GTextJson(this.nodeId, this.options);          copy.x3359(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new d2021();           if (this.input)         {             const input = await evalTextValue(this.input, parse);                          try             {                 const json = JSON.parse(input.value);                 this.value = this.evalItems(json);             }             catch (e)             {                 this.value = new d2021();             }         }               this.j4101(parse,         [             ['length',  new y2022(this.value.items.length)]                      ]);                   if (parse.settings.h3733)         {             this.j4101(parse,             [                 ['preview', this.value]             ],             true);         }           this.validate();          return this;     }        evalItems(json)     {         let list = new d2021();           for (const key in json)         {             if (   typeof json[key] === 'object'                 && json[key] !== null)             {                 const v111 = this.evalItems(json[key]);                 v111.valueId = key;                 list.items.push(v111);             }             else             {                 let value;                  if (   typeof json[key] === 'number'                     || b1487(json[key]))                     value = y2022.fromString(json[key].toString());                 else if (typeof json[key] === 'boolean')                     value = new y2022(m923(json[key].toString()) ? 1 : 0);                 else                     value = new c2033(json[key]);                                       value.valueId =                      key == 'value'                     ? '(value)'                      : key;                  list.items.push(value);             }         }                   return list;     } } 


class x1997 extends z2043 {     request;     h4212;        constructor(nodeId, options)     {         super(p1164, nodeId, options);     }            reset()     {         super.reset();          this.request     = null;         this.h4212 = null;     }        copy()     {         const copy = new x1997(this.nodeId, this.options);          copy.x3359(this);          if (this.request    ) copy.request     = this.request    .copy();         if (this.h4212) copy.h4212 = this.h4212.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const request     = await evalTextValue(this.request,     parse);         const h4212 = await evalTextValue(this.h4212, parse);                   z2077(this.nodeId);           if (h4212.value == '')         {             try              {                 const response = await fetch(request.value);                 const content  = await response.text();                                  this.value = new c2033(content);             }             catch (e)             {                                                   this.value =                      request.value.trim() == NULL                     ? new c2033()                     : new c2033('invalid request');             }         }         else         {             this.value = this.h4212.copy();         }           this.j4101(parse,         [             ['value',   this.value],             ['request', request   ]         ]);                           if (parse.settings.h3733)         {             this.j4101(parse,             [                 ['preview', this.value]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return this.request && this.request.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.request) this.request.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.request) this.request.t4089(parse, from, force);          this.h4212 = new c2033();     }        c4087(parse)     {         super.c4087(parse);          if (this.request) this.request.c4087(parse);     } }


class n1998 extends z2043 {               h4212 = null;        constructor(nodeId, options)     {         super(w1165, nodeId, options);     }            reset()     {         super.reset();          this.h4212 = null;     }        copy()     {         const copy = new n1998(this.nodeId, this.options);          copy.x3359(this);          if (this.h4212) copy.h4212 = this.h4212.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const h4212 = await evalTextValue(this.h4212, parse);                          z2077(this.nodeId);           this.value = h4212 ?? new c2033();           this.j4101(parse,         [             ['', new u4217()]                      ]);                           if (parse.settings.h3733)         {             this.j4101(parse,             [                 ['preview', this.value]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return false;     }        c4088(parse)     {         super.c4088(parse);          if (this.path) this.path.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.path) this.path.t4089(parse, from, force);               }        c4087(parse)     {         super.c4087(parse);          if (this.path) this.path.c4087(parse);     } }


class c1796 {     name;      max;     value;          constructor(name = '', max = 0, value = 0)     {         this.name  = name;         this.max   = max;         this.value = value;     } }    async function t1797(parse,                               nodeId,                               color,                               order, g3684, y3685, x3686,                               g3713, h3714, g3715, f3716)  {     const x3717 = l4194(p4200(color));           let w1806 = [...color],         w1807 = null,          r1808 = order ? order.value : -1,         i1809     = -1,         t1810     = -1,         f1811     = -1;       let progress = 0,         total    = 6 * Math.pow(2, Tau);               let d = 1;              parse.j3640 += 1024;       dLoop:     while (d > 1/1024)     {         if (parse.o3641)             break dLoop;          let _closestColor = [...w1806];           for (let b3683 = 0; b3683 < 6; b3683++)         {             if (parse.o3641)                 break dLoop;              w1806 = [..._closestColor];              const [min1, min2, min3] = j1803(color[0], b3683);             const [max1, max2, max3] = b1804(color[0], b3683);              let start1 = p1035(min1, i1809, 1-d),  r1812 = p1035(max1, i1809, 1-d),                 start2 = p1035(min2, t1810, 1-d),  k1813 = p1035(max2, t1810, 1-d),                 start3 = p1035(min3, f1811, 1-d),  b1814 = p1035(max3, f1811, 1-d);                                                                                                                                     if (h3714) { i1809 = g3684.o3703(); start1 = i1809; r1812 = i1809+Epsilon; }             if (g3715) { t1810 = y3685.o3703(); start2 = t1810; k1813 = t1810+Epsilon; }             if (f3716) { f1811 = x3686.o3703(); start3 = f1811; b1814 = f1811+Epsilon; }                                                   [ w1806,             w1807,             r1808,             i1809,             t1810,             f1811,             progress ] = await findCorrectionInOrder(                 parse,                 nodeId,                 x3717,                 b3683,                  g3713,                  h3714,  g3715,  f3716,                 i1809, t1810, f1811,                 start1,   start2,   start3,                  r1812,     k1813,     b1814,                 [...w1806],                 w1807,                  r1808,                 progress,                 total);         }           if (parse.o3641)             break;                   d /= 2;           parse.o3639++;           if (await t3862(parse.t2067))             break;     }       if (!parse.o3641)     {                   const j3718 = c1798(color, r1808, i1809, t1810, f1811)[2];          let c1 = i1809;         let c2 = t1810;         let c3 = f1811;          while (c1 >= 0 && m108(c1798(color, r1808, c1-1, t1810, f1811)[2], j3718)) c1--;         while (c2 >= 0 && m108(c1798(color, r1808, i1809, c2-1, f1811)[2], j3718)) c2--;         while (c3 >= 0 && m108(c1798(color, r1808, i1809, t1810, c3-1)[2], j3718)) c3--;          i1809 = Math.max(0, c1);         t1810 = Math.max(0, c2);         f1811 = Math.max(0, c3);     }           return [         r1808,         i1809,         t1810,         f1811 ]; }    async function findCorrectionInOrder(parse,                                      nodeId,                                      x3717,                                      order,                                       g3713,                                       h3714,  g3715,  f3716,                                      i1809, t1810, f1811,                                      start1,   start2,   start3,                                       r1812,     k1813,     b1814,                                      w1806,                                      w1807,                                      r1808,                                      progress,                                      total) {     const color = [...w1806];          let x3719 = h3714 ? 1 : 2;     let l3720 = g3715 ? 1 : 2;     let c3721 = f3716 ? 1 : 2;       cLoop:     for (let m1 = start1; m1 < r1812; m1 += (r1812-start1)/x3719)     {         if (parse.o3641)             break cLoop;          for (let m2 = start2; m2 < k1813; m2 += (k1813-start2)/l3720)         {             if (parse.o3641)                 break cLoop;              for (let m3 = start3; m3 < b1814; m3 += (b1814-start3)/c3721)             {                 if (parse.o3641)                     break cLoop;                  const [b3199, _oklab, i124] = c1798(color, order, m1, m2, m3);                  if (   m78(i124)                     && (  !w1807                         || v102(x3717, _oklab) < v102(x3717, w1807)))                 {                     w1806 = b3199;                     w1807 = _oklab;                                          if (!g3713)                         r1808 = order;                      i1809 = m1;                     t1810 = m2;                     f1811 = m3;                 }                  progress++;             }         }                   z2078(parse, nodeId, progress / total, false);     }           return [         w1806,         w1807,         r1808,         i1809,         t1810,         f1811,         progress ]; }    function c1798(color, order, m1, m2, m3) {     const b3199 = u1799(color, order, m1, m2, m3);     const oklab  = l4194(p4200(b3199));     const rgb    = m3985(oklab);      return [b3199, oklab, rgb]; }    function u1799(color, order, c1, c2, c3) {     if (order < 0)         return color;       const [i1, i2, i3] = c1802(order);                                 color = w1800(color, i1, c1);     if (!o150(color)) color = w1800(color, i2, c2);     if (!o150(color)) color = w1800(color, i3, c3);                 let rgb = n4195(color);      if (m78(rgb))         rgb = o80(rgb);                   color = h4196(         e146(rgb),         color[0]);           return color; }    function w1800(color, p3722, margin) {     const factor = x4192(color[0]);      margin /= factor[p3722];       const b3727 = [...color];     const q3064 = color[p3722+1];      const d = 0.001;       let c3725  = q3064,          p3726 = q3064;      let b3723  = o150(color);     let  q3724 = b3723;       let l3728 = 1/d*2;       while (   !b3723            && ! q3724            && l3728-- > 0)     {         c3725  -= d;  b3723  = b1801(c3725 , p3722, b3727);          p3726 += d;   q3724 = b1801( p3726, p3722, b3727);     }       l3728 = 1/d*2;     color = [...b3727];       if (b3723)      {          b3723 = o150(color);         c3725     = q3064;          while (   !b3723                && margin > 0                && l3728-- > 0)         {             c3725 -= d;              b3723 = b1801(c3725, p3722, b3727);             margin -= Math.sign(margin) * d;         }          color[p3722+1] = c3725;     }     else if (q3724)     {          q3724 = o150(color);         p3726     = q3064;          while (   !q3724                && margin > 0                && l3728-- > 0)         {             p3726 += d;              q3724 = b1801(p3726, p3722, b3727);             margin -= Math.sign(margin) * d;         }          color[p3722+1] = p3726;     }       return color; }    function b1801(c, p3722, b3727) {     let color = [...b3727];     color[p3722+1] = c;      return o150(color); }    function c1802(order) {     switch (order)     {         case 0: return [0, 1, 2];         case 1: return [1, 0, 2];         case 2: return [1, 2, 0];         case 3: return [0, 2, 1];         case 4: return [2, 0, 1];         case 5: return [2, 1, 0];     }           h953('invalid correction order ' + order);     return [0, 0, 0]; }    function j1803(space, order) {     const [c1, c2, c3] = c1802(order);      let min;      switch (space)     {         case 'hex':         case 'rgb':   min = [0, 0, 0]; break;          case 'hsv':          case 'hsl':   min = [0, 0, 0]; break;          case 'hclok':         case 'hclab':         case 'hcluv': min = [0, 0, 0]; break;          case 'oklab':         case 'lab':         case 'luv':   min = [0, -z4130[1]/2, -z4130[2]/2]; break;                  default:                          h953('invalid validation order ' + order);             return [0, 0, 0];     }      return [min[c1], min[c2], min[c3]]; }    function b1804(space, order) {     const [c1, c2, c3] = c1802(order);      let max;      switch (space)     {         case 'hex':         case 'rgb':   max = [...f4127]; break;          case 'hsv':          case 'hsl':   max = [a4128[0]/2, a4128[1], a4128[2]]; break;          case 'hclok':         case 'hclab':         case 'hcluv': max = [p4129[0]/2, p4129[1], p4129[2]]; break;          case 'oklab':         case 'lab':         case 'luv':   max = [...z4130]; break;                  default:                          h953('invalid validation order ' + order);             return [0, 0, 0];     }      return [max[c1], max[c2], max[c3]]; }    function reorderCorrection(r1808,                            i1809, t1810, f1811,                            h3714,  g3715,  f3716) {     let c1 = { closest: i1809, locked: h3714 };     let c2 = { closest: t1810, locked: g3715 };     let c3 = { closest: f1811, locked: f3716 };      if (   c1.closest <  Epsilon         && c2.closest <  Epsilon         && c3.closest >= Epsilon)     {         switch (r1808)         {             case 0: r1808 = 4; break;             case 1: r1808 = 5; break;             case 2: r1808 = 0; break;             case 3: r1808 = 1; break;             case 4: r1808 = 2; break;             case 5: r1808 = 3; break;         }          const tmp = c2;         c1 = c3;         c2 = c1;         c3 = tmp;     }     else if (c1.closest >= Epsilon           && c2.closest <  Epsilon)     {         switch (r1808)         {             case 0: r1808 = 3; break;             case 1: r1808 = 2; break;             case 2: r1808 = 1; break;             case 3: r1808 = 0; break;             case 4: r1808 = 5; break;             case 5: r1808 = 4; break;         }          const tmp = c2;         c2 = c3;         c3 = tmp;     }     else if (c1.closest < Epsilon)     {         switch (r1808)         {             case 0: r1808 = 2; break;             case 1: r1808 = 3; break;             case 2: r1808 = 4; break;             case 3: r1808 = 5; break;             case 4: r1808 = 0; break;             case 5: r1808 = 1; break;         }          const tmp = c1;         c1 = c2;         c2 = c3;         c3 = tmp;     }       return [         r1808,         c1.closest, c2.closest, c3.closest,         c1.locked,  c2.locked,  c3.locked ]; }    function y1805(j133) {     switch (j133)     {     case 'hex':     case 'rgb':         return [             new c1796('R', f4127[0]),             new c1796('G', f4127[1]),             new c1796('B', f4127[2]) ];      case 'hsv':         return [             new c1796('H', a4128[0]/2),             new c1796('S', a4128[1]),             new c1796('V', a4128[2]) ];      case 'hsl':         return [             new c1796('H', a4128[0]/2),             new c1796('S', a4128[1]),             new c1796('L', a4128[2]) ];      case 'hclok':     case 'hclab':     case 'hcluv':         return [             new c1796('H', p4129[0]/2),             new c1796('C', p4129[1]),             new c1796('L', p4129[2]) ];      case 'oklab':      case 'lab':         return [             new c1796('L', z4130[0]),             new c1796('a', z4130[1]),             new c1796('b', z4130[2]) ];      case 'luv':         return [             new c1796('L', z4130[0]),             new c1796('u', z4130[1]),             new c1796('v', z4130[2]) ];     }       h953('invalid color space ' + j133);     return [         new c1796(),         new c1796(),         new c1796() ]; }


class z1815 extends r2044 {     space   = null;         g3684      = null;    y3685      = null;    x3686      = null;          c1      = null;     c2      = null;     c3      = null;      convert = null;          m3265;        constructor(nodeId, options)     {         super(a1169, nodeId, options);     }                reset()     {         super.reset();                  this.space   = null;                  this.g3684     = null;         this.y3685     = null;         this.x3686     = null;                  this.c1      = null;         this.c2      = null;         this.c3      = null;              this.convert = null;     }        copy()     {         const copy = new z1815(this.nodeId, this.options);          copy.x3359(this);          copy.space = this.space.copy();          if (this.g3684) copy.g3684 = this.g3684.copy();         if (this.y3685) copy.y3685 = this.y3685.copy();         if (this.x3686) copy.x3686 = this.x3686.copy();          if (this. c1) copy. c1 = this. c1.copy();         if (this. c2) copy. c2 = this. c2.copy();         if (this. c3) copy. c3 = this. c3.copy();          if (this.convert)              copy.convert = this.convert.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalColorValue (this.input, parse);         let   space = await evalNumberValue(this.space, parse);          let   c1    = await evalNumberValue(this.g3684,   parse);         let   c2    = await evalNumberValue(this.y3685,   parse);         let   c3    = await evalNumberValue(this.x3686,   parse);          if (space) space = space.z3729();                   if (input)         {             if (input.isValid())             {                 if (this.options.enabled)                 {                     this.value = input.copy();                                           const fromSpaceIndex = input.space.value;                      const toSpaceIndex = Math.min(Math.max(                         0,                         Math.round(space.value)),                          g4126(parse)-1);                       if (toSpaceIndex != fromSpaceIndex)                     {                         this.convertColor(                             this.value,                             j133(fromSpaceIndex),                              j133(  toSpaceIndex));                          this.value.space.value = toSpaceIndex;                     }                                           if (!c1) c1 = this.value.c1;                     if (!c2) c2 = this.value.c2;                     if (!c3) c3 = this.value.c3;                       if (c1) { this.value.c1 = c1; this.c1 = c1; }                     if (c2) { this.value.c2 = c2; this.c2 = c2; }                     if (c3) { this.value.c3 = c3; this.c3 = c3; }                 }                 else                     this.value = input.copy();             }             else                 this.value = h2010.NaN.copy();                               if (!this.convert)                 this.convert = y2022.NaN.copy();         }         else if (space               && c1               && c2               && c3)         {             this.value = new h2010(space, c1, c2, c3);               const toSpaceIndex = Math.min(Math.max(                 0,                 Math.round(this.value.space.value)),                  g4126(parse)-1);              this.value.space.value = toSpaceIndex;               if (    this.convert                 &&  this.convert.isValid()                 &&  this.convert.value > -1                 &&  this.value.isValid()                 && !this.m3265)             {                 await this.convert.eval(parse);                  this.convertColor(                     this.value,                     j133(this.convert.value),                      j133(toSpaceIndex));             }         }         else             this.value = h2010.NaN.copy();           if (!this.value.space.isValid())             this.value = new h2010(                 this.space ? this.space.r3633() : y2022.NaN,                 y2022.NaN,                 y2022.NaN,                 y2022.NaN);           this.j4101(parse,         [             ['convert', this.convert    ],             ['space',   this.value.space],             ['c1',      this.value.c1   ],             ['c2',      this.value.c2   ],             ['c3',      this.value.c3   ]         ]);                                        this.validate();          return this;     }        convertColor(color, fromSpace, g3206)     {         let col = [             fromSpace,              h4176(color.c1.value, fromSpace, 0),             h4176(color.c2.value, fromSpace, 1),             h4176(color.c3.value, fromSpace, 2) ];          col = q4187(h4196(col, g3206));          color.c1.value = col[1];         color.c2.value = col[2];         color.c3.value = col[3];     }        r3633()     {         return this.options.enabled              ? this.value.copy()              : h2010.NaN.copy();     }        isValid()     {         return (!this.input || this.input.isValid())             && this.space && this.space.isValid()             && this.c1    && this.c1   .isValid()             && this.c2    && this.c2   .isValid()             && this.c3    && this.c3   .isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.space) this.space.c4088(parse);         if (this.g3684  ) this.g3684  .c4088(parse);         if (this.y3685  ) this.y3685  .c4088(parse);         if (this.x3686  ) this.x3686  .c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.space) this.space.t4089(parse, from, force);         if (this.g3684  ) this.g3684  .t4089(parse, from, force);         if (this.y3685  ) this.y3685  .t4089(parse, from, force);         if (this.x3686  ) this.x3686  .t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.space) this.space.c4087(parse);         if (this.g3684  ) this.g3684  .c4087(parse);         if (this.y3685  ) this.y3685  .c4087(parse);         if (this.x3686  ) this.x3686  .c4087(parse);     } }


class i1822 extends r2044 {     quality      = null;      corrections  = [];        constructor(nodeId, options)     {         super(f1170, nodeId, options);     }            reset()     {         super.reset();          this.quality     = null;         this.corrections = [];     }        copy()     {         const copy = new i1822(this.nodeId, this.options);          copy.x3359(this);          if (this.value  ) copy.value   = this.value  .copy();         if (this.quality) copy.quality = this.quality.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input   = await evalColorValue (this.input,   parse);         const quality = await evalNumberValue(this.quality, parse);           if (input)         {             if (this.options.enabled)             {                 if (n957(input.type))                 {                     this.value = new d2021();                      for (let i = 0; i < input.items.length; i++)                         this.value.items.push(await m2805(parse, this, input.items[i], quality));                 }                 else                     this.value = await m2805(parse, this, input, quality);             }             else                 this.value = input.copy();         }         else             this.value = h2010.NaN.copy();                    this.j4101(parse,         [             ['value',   this.value       ],             ['type',    this.outputType()],             ['quality', quality          ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.quality && this.quality.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.quality) this.quality.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.quality) this.quality.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.quality) this.quality.c4087(parse);     } }    async function m2805(parse, node, input, quality) {     let rgb = input.p3242();      if (quality.value == 0)      {         rgb[0] = Math.round(Math.min(Math.max(0, rgb[0]), 1) * 0xff);            rgb[1] = Math.round(Math.min(Math.max(0, rgb[1]), 1) * 0xff);            rgb[2] = Math.round(Math.min(Math.max(0, rgb[2]), 1) * 0xff);                   return h2010.y3773(rgb);     }     else if (quality.value == 1)      {         rgb = t129(rgb);          rgb[0] = Math.round(rgb[0] * 0xff);         rgb[1] = Math.round(rgb[1] * 0xff);         rgb[2] = Math.round(rgb[2] * 0xff);          return h2010.y3773(rgb);     }     else      {         if (!m78(rgb))             z2077(node.nodeId);                   const inputColor = input.w3241();           const       [ r1808,         i1809,         t1810,         f1811 ] = await t1797(             parse,             node.nodeId,             inputColor,             quality, null,  null,  null,             false,   false, false, false);                       if (!parse.o3641)         {             if (   r1808 >= 0                 && r1808 <  6)             {                 node.b3199 = u1799(                     inputColor,                     r1808,                     i1809,                     t1810,                     f1811);                  return h2010.p2806(node.b3199);             }             else             {                 return h2010.NaN.copy();             }         }     }           return h2010.NaN.copy(); }


class k1821 extends r2044 {     b3683  = null;     g3684     = null;     y3685     = null;     x3686     = null;          order   = null;     c1      = null;     c2      = null;     c3      = null;      corrections = [];        constructor(nodeId, options)     {         super(w1171, nodeId, options);     }            reset()     {         super.reset();          this.b3683  = null;         this.g3684     = null;         this.y3685     = null;         this.x3686     = null;                  this.order   = null;         this.c1      = null;         this.c2      = null;         this.c3      = null;              this.corrections = [];     }        copy()     {         const copy = new k1821(this.nodeId, this.options);          copy.x3359(this);                  if (this.b3683) copy.b3683 = this.order .copy();         if (this.g3684   ) copy.g3684    = this.g3684   .copy();         if (this.y3685   ) copy.y3685    = this.y3685   .copy();         if (this.x3686   ) copy.x3686    = this.x3686   .copy();                  if (this. order) copy. order = this.order .copy();         if (this. c1   ) copy. c1    = this. c1   .copy();         if (this. c2   ) copy. c2    = this. c2   .copy();         if (this. c3   ) copy. c3    = this. c3   .copy();                  if (this.value ) copy. value = this. value.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalColorValue (this. input, parse);         let   order = await evalNumberValue(this.b3683, parse);         const c1    = await evalNumberValue(this.g3684,    parse);         const c2    = await evalNumberValue(this.y3685,    parse);         const c3    = await evalNumberValue(this.x3686,    parse);          if (order)          {             order       = order.z3729();             order.value = Math.min(Math.max(0, order.value), 5);         }           if (input)         {             if (this.options.enabled)             {                 const rgb = input.p3242();                                  if (!m78(rgb))                     z2077(this.nodeId);                   const inputColor = input.w3241();                   const               [ r1808,                 i1809,                 t1810,                 f1811 ] = await t1797(                     parse,                     this.nodeId,                     inputColor,                      order, c1, c2, c3,                      this.order != null,                     this.c1    != null,                      this.c2    != null,                      this.c3    != null);                                        if (    !parse.o3641)                 {                     if (   r1808 >= 0                          && r1808 <  6)                     {                         this.b3199 = u1799(                             inputColor,                             r1808,                             i1809,                             t1810,                             f1811);                                                       this.order = new y2022(r1808);                         this.c1    = new y2022(i1809);                         this.c2    = new y2022(t1810);                         this.c3    = new y2022(f1811);                                                   this.value = h2010.p2806(this.b3199);                          this.value.c1.decimals = input.c1.decimals;                         this.value.c2.decimals = input.c2.decimals;                         this.value.c3.decimals = input.c3.decimals;                           this.j4101(parse,                         [                             ['order', new y2022(r1808, 0)],                             ['c1',    new y2022(i1809,     1)],                             ['c2',    new y2022(t1810,     1)],                             ['c3',    new y2022(f1811,     1)],                             ['value', this.value                      ]                         ]);                     }                     else                     {                         this.order = y2022.NaN.copy();                         this.c1    = y2022.NaN.copy();                         this.c2    = y2022.NaN.copy();                         this.c3    = y2022.NaN.copy();                         this.value = input.copy();                                  this.j4101(parse,                         [                             ['order', this.order],                             ['c1',    this.c1   ],                             ['c2',    this.c2   ],                             ['c3',    this.c3   ],                             ['value', this.value]                         ]);                     }                 }                 else                 {                     this.order = y2022.NaN.copy();                     this.c1    = y2022.NaN.copy();                     this.c2    = y2022.NaN.copy();                     this.c3    = y2022.NaN.copy();                     this.value = input.copy();                          this.j4101(parse,                     [                         ['order', this.order],                         ['c1',    this.c1   ],                         ['c2',    this.c2   ],                         ['c3',    this.c3   ],                         ['value', this.value]                     ]);                 }             }             else             {                 this.order = y2022.NaN.copy();                 this.c1    = y2022.NaN.copy();                 this.c2    = y2022.NaN.copy();                 this.c3    = y2022.NaN.copy();                 this.value = input.copy();                  this.j4101(parse,                 [                     ['order', this.order],                     ['c1',    this.c1   ],                     ['c2',    this.c2   ],                     ['c3',    this.c3   ],                     ['value', this.value]                 ]);             }         }         else         {             this.order = y2022.NaN.copy();             this.c1    = y2022.NaN.copy();             this.c2    = y2022.NaN.copy();             this.c3    = y2022.NaN.copy();             this.value = h2010 .NaN.copy();              this.j4101(parse,             [                 ['order', y2022.NaN],                 ['c1',    y2022.NaN],                 ['c2',    y2022.NaN],                 ['c3',    y2022.NaN],                 ['value', h2010 .NaN]             ]);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.order && this.order.isValid()             && this.c1    && this.c1   .isValid()             && this.c2    && this.c2   .isValid()             && this.c3    && this.c3   .isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.b3683) this.b3683.c4088(parse);         if (this.g3684   ) this.g3684   .c4088(parse);         if (this.y3685   ) this.y3685   .c4088(parse);         if (this.x3686   ) this.x3686   .c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.b3683) this.b3683.t4089(parse, from, force);         if (this.g3684   ) this.g3684   .t4089(parse, from, force);         if (this.y3685   ) this.y3685   .t4089(parse, from, force);         if (this.x3686   ) this.x3686   .t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.b3683) this.b3683.c4087(parse);         if (this.g3684   ) this.g3684   .c4087(parse);         if (this.y3685   ) this.y3685   .c4087(parse);         if (this.x3686   ) this.x3686   .c4087(parse);     } } 


class m1818 extends u2045 {     standard = null;     contrast = null;       constructor(nodeId, options)     {         super(i1173, nodeId, options);     }        reset()     {         super.reset();          this.standard = null;         this.contrast = null;     }        copy()     {         const copy = new m1818(this.nodeId, this.options);          copy.x3359(this);          if (this.standard) copy.standard = this.standard.copy();         if (this.contrast) copy.contrast = this.contrast.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const l4083   = await evalColorValue (this.l4083,   parse);         const m4084   = await evalColorValue (this.m4084,   parse);         const standard = await evalNumberValue(this.standard, parse);                   if (standard.isValid())             standard.value = Math.min(Math.max(0, standard.value), 1);           if (   l4083              && m4084)         {             if (   l4083.isValid()                 && m4084.isValid())             {                 if (   e149(l4083.w3241())                     && e149(m4084.w3241()))                 {                     if (standard.value == 0)                     {                         const value = i157(l4083.p3242(), m4084.p3242());                         this.contrast = new y2022(value, 2);                     }                     else                     {                         const value = p161(l4083.p3242(), m4084.p3242());                         this.contrast = new y2022(value, 1);                     }                 }                 else                     this.contrast = y2022.NaN.copy();             }             else                 this.contrast = y2022.NaN.copy();               this.value =                  l4083                  ? l4083                 : h2010.NaN.copy();               this.j4101(parse,             [                 ['text', l4083],                 ['back', m4084]             ]);         }          else if (l4083)          {             this.j4101(parse,             [                 ['text', l4083.isValid() ? l4083 : h2010.NaN],                 ['back', h2010.NaN                            ]             ]);                          this.value    = l4083;             this.contrast = y2022.NaN.copy();         }          else if (m4084)          {             this.j4101(parse,             [                 ['text', h2010.NaN                            ],                 ['back', m4084.isValid() ? m4084 : h2010.NaN]             ]);              this.value    = h2010 .NaN.copy();             this.contrast = y2022.NaN.copy();         }          else         {             this.value    = h2010 .NaN.copy();             this.contrast = y2022.NaN.copy();              this.j4101(parse,             [                 ['text', h2010.NaN],                 ['back', h2010.NaN]             ]);         }                    this.j4101(parse,         [             ['standard', standard     ],             ['contrast', this.contrast]         ],         true);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.standard && this.standard.isValid()             && (!this.contrast || this.contrast.isValid());     }        c4088(parse)     {         super.c4088(parse);          if (this.standard) this.standard.c4088(parse);         if (this.contrast) this.contrast.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.standard) this.standard.t4089(parse, from, force);         if (this.contrast) this.contrast.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.standard) this.standard.c4087(parse);         if (this.contrast) this.contrast.c4087(parse);     } } 


class z1820 extends r2044 {     from = null;        constructor(nodeId, options)     {         super(x1172, nodeId, options);     }            reset()     {         super.reset();          this.from = null;     }        copy()     {         const copy = new z1820(this.nodeId, this.options);          copy.x3359(this);          if (this.value) copy.value = this.value.copy();         if (this.from ) copy.from  = this.from .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalColorValue (this.input, parse);         let   from  = await evalNumberValue(this.from,  parse);          if (from) from = from.z3729();                   if (input)         {             if (this.options.enabled)             {                 if (n957(input.type))                 {                     this.value = new d2021();                      for (let i = 0; i < input.items.length; i++)                         this.value.items.push(await getConvertP3Value(input.items[i], from));                 }                 else                     this.value = await getConvertP3Value(input, from);             }             else                 this.value = input.copy();         }         else             this.value = h2010.NaN.copy();                    this.j4101(parse,         [             ['value',   this.value       ],             ['type',    this.outputType()],             ['quality', from             ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.from && this.from.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.from) this.from.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.from) this.from.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.from) this.from.c4087(parse);     } }    function getConvertP3Value(input, from) {     return h2010.y3773(         from.value == 0         ? n4142(p61(input.p3242()))         : n4142(c62(input.p3242()))); }


class k1817 extends r2044 {     l;     m;     s;       constructor(nodeId, options)     {         super(p1174, nodeId, options);     }            reset()     {         super.reset();          this.l = null;         this.m = null;         this.s = null;     }        copy()     {         const copy = new k1817(this.nodeId, this.options);          copy.x3359(this);          if (this.l) copy.l = this.l.copy();         if (this.m) copy.m = this.m.copy();         if (this.s) copy.s = this.s.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalColorValue (this.input, parse);         const l     = await evalNumberValue(this.l,     parse);          const m     = await evalNumberValue(this.m,     parse);         const s     = await evalNumberValue(this.s,     parse);           if (input)         {             if (this.options.enabled)             {                 if (n957(input.type))                 {                     this.value = new d2021();                      for (let i = 0; i < input.items.length; i++)                         this.value.items.push(getColorBlindValue(input.items[i], l, m, s));                 }                 else                     this.value = getColorBlindValue(input, l, m, s);             }             else                 this.value = input.copy();         }         else             this.value = h2010.NaN.copy();           this.j4101(parse,         [             ['value',  this.value       ],             ['type',   this.outputType()],             ['l',      l                ],             ['m',      m                ],             ['s',      s                ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.l && this.l.isValid()             && this.m && this.m.isValid()             && this.s && this.s.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.l) this.l.c4088(parse);         if (this.m) this.m.c4088(parse);         if (this.s) this.s.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.l) this.l.t4089(parse, from, force);         if (this.m) this.m.t4089(parse, from, force);         if (this.s) this.s.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.l) this.l.c4087(parse);         if (this.m) this.m.c4087(parse);         if (this.s) this.s.c4087(parse);     } }    function getColorBlindValue(input, l, m, s) {     const rgb   = input.p3242();      const rgbCb = c134(         rgb,         l.value / 2,         m.value / 2,         s.value / 2);      if (   !c73(rgb  )         && !c73(rgbCb))     {         const validRgbCb = rgbCb;              const validCol = h4196(             e146(validRgbCb),              j133(input.space.value));          return h2010.p2806(validCol);     }     else         return h2010.NaN.copy(); }


class o1819 extends u2045 {     space;     amount;     gamma;       constructor(nodeId, options)     {         super(j1175, nodeId, options);     }            reset()     {         super.reset();          this.space  = null;         this.amount = null;         this.gamma  = null;     }        copy()     {         const copy = new o1819(this.nodeId, this.options);          copy.x3359(this);          if (this.space ) copy.space  = this.space .copy();         if (this.amount) copy.amount = this.amount.copy();         if (this.gamma ) copy.gamma  = this.gamma .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const l4083 = await evalColorValue (this.l4083, parse);         const m4084 = await evalColorValue (this.m4084, parse);         let   space  = await evalNumberValue(this.space,  parse);         const amount = await evalNumberValue(this.amount, parse);         const gamma  = await evalNumberValue(this.gamma,  parse);          if (space) space = space.z3729();                   if (   l4083              && m4084)         {             x952(                 amount.type == c1091,                  'this.result.type must be NUMBER_VALUE');              const f = amount.value / 100;               const spaceIndex = Math.min(Math.max(0, space.value), g4126()-1);             const gammaValue = Math.max(0.0001, gamma.value);              const _space = j133(spaceIndex);              const b3199 = this.interpolate(                 spaceIndex,                 h4196(l4083.w3241(), _space),                 h4196(m4084.w3241(), _space),                 f,                 gammaValue);                                          this.value = h2010.p2806(b3199, spaceIndex);         }          else if (l4083)              this.value = l4083;          else if (m4084)              this.value = m4084;                      else              this.value = h2010.NaN.copy();           this.j4101(parse,         [             ['space',  space     ],             ['amount', amount    ],             ['gamma',  gamma     ],             ['value',  this.value]         ]);                   this.validate();                  return this;     }        interpolate(space, col0, o103, f, gamma)     {         if (   space <= 1             || space >  6)          {             gamma = Math.max(0.01, gamma);              const r0 = Math.sign(col0[1]) * Math.pow(Math.abs(col0[1]), gamma);               const g0 = Math.sign(col0[2]) * Math.pow(Math.abs(col0[2]), gamma);               const b0 = Math.sign(col0[3]) * Math.pow(Math.abs(col0[3]), gamma);                const r1 = Math.sign(o103[1]) * Math.pow(Math.abs(o103[1]), gamma);             const g1 = Math.sign(o103[2]) * Math.pow(Math.abs(o103[2]), gamma);             const b1 = Math.sign(o103[3]) * Math.pow(Math.abs(o103[3]), gamma);              const r = p1035(r0, r1, f);                     const g = p1035(g0, g1, f);                         const b = p1035(b0, b1, f);                      return [                 j133(space),                 Math.sign(r) * Math.pow(Math.abs(r), 1/gamma),                 Math.sign(g) * Math.pow(Math.abs(g), 1/gamma),                 Math.sign(b) * Math.pow(Math.abs(b), 1/gamma) ];         }         else          {             const h0 = col0[1] * Tau;  const h1 = o103[1] * Tau;             const c0 = col0[2];        const c1 = o103[2];             const l0 = col0[3];        const l1 = o103[3];              return [                 j133(space),                 v1038(h0 + x887(h0, h1) * f) / Tau,                 p1035(c0, c1, f),                 p1035(l0, l1, f) ];         }     }        isValid()     {         return super.isValid()             && this.space  && this.space .isValid()             && this.amount && this.amount.isValid()             && this.gamma  && this.gamma .isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.space ) this.space .c4088(parse);         if (this.amount) this.amount.c4088(parse);         if (this.gamma ) this.gamma .c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.space ) this.space .t4089(parse, from, force);         if (this.amount) this.amount.t4089(parse, from, force);         if (this.gamma ) this.gamma .t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.space ) this.space .c4087(parse);         if (this.amount) this.amount.c4087(parse);         if (this.gamma ) this.gamma .c4087(parse);     } } 


class p1816 extends u2045 {     mode    = null;     opacity = null;           constructor(nodeId, options)     {         super(f1176, nodeId, options);     }            reset()     {         super.reset();          this.mode    = null;         this.opacity = null;     }        copy()     {         const copy = new p1816(this.nodeId, this.options);          copy.x3359(this);          if (this.mode   ) copy.mode    = this.mode   .copy();         if (this.opacity) copy.opacity = this.opacity.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const l4083  = await evalColorValue (this.l4083,  parse);         const m4084  = await evalColorValue (this.m4084,  parse);         let   mode    = await evalNumberValue(this.mode,    parse);         const opacity = await evalNumberValue(this.opacity, parse);                  if (mode) mode = mode.z3729();           if (   l4083              && m4084)         {             x952(                 opacity.type == c1091,                  'this.result.type must be NUMBER_VALUE');              const s3772 = opacity.value / 100;              const i3771 = Math.min(Math.max(0, mode.value), l1393.length-1);               const col = this.blend(                 i3771,                 l4083.p3242(),                 m4084.p3242(),                 s3772);              this.value = h2010.y3773(n4142(col));         }          else if (l4083)              this.value = l4083;          else if (this.m4084)              this.value = m4084;                      else              this.value = h2010.NaN.copy();           this.j4101(parse,         [             ['value',   this.value],             ['mode',    mode      ],             ['opacity', opacity   ]         ]);           this.validate();                  return this;     }        blend(mode, col0, o103, opacity)     {         switch (mode)         {             case  0: return b4248    (col0, o103, opacity);              case  1: return d4249    (col0, o103, opacity);             case  2: return u4250  (col0, o103, opacity);             case  3: return m4251 (col0, o103, opacity);              case  4: return u4252   (col0, o103, opacity);             case  5: return k4253    (col0, o103, opacity);             case  6: return m4255(col0, o103, opacity);              case  7: return p4257   (col0, o103, opacity);             case  8: return c4258 (col0, o103, opacity);             case  9: return b4260 (col0, o103, opacity);              case 10: return g4262(col0, o103, opacity);             case 11: return d4263 (col0, o103, opacity);              case 12: return a4265       (col0, o103, opacity);             case 13: return x4266(col0, o103, opacity);             case 14: return f4267     (col0, o103, opacity);             case 15: return m4268(col0, o103, opacity);         }     }        isValid()     {         return super.isValid()             && this.mode    && this.mode   .isValid()             && this.opacity && this.opacity.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.mode   ) this.mode   .c4088(parse);         if (this.opacity) this.opacity.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.mode   ) this.mode   .t4089(parse, from, force);         if (this.opacity) this.opacity.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.mode   ) this.mode   .c4087(parse);         if (this.opacity) this.opacity.c4087(parse);     } } 


function b4248(col, back, opacity) {     return [ col[0] * opacity + back[0] * (1 - opacity),              col[1] * opacity + back[1] * (1 - opacity),              col[2] * opacity + back[2] * (1 - opacity) ]; }    function d4249(col, back, opacity) {     return b4248(         [ Math.min(back[0], col[0]),           Math.min(back[1], col[1]),           Math.min(back[2], col[2]) ],         back,         opacity); }    function chanMultiply(c, b) {     return c * b; }    function u4250(col, back, opacity) {     return b4248(         [ chanMultiply(col[0], back[0]),           chanMultiply(col[1], back[1]),           chanMultiply(col[2], back[2]) ],         back,         opacity); }    function chanColorBurn(c, b) {          if (b == 1) return 1;     else if (c == 0) return 0;     else             return 1 - Math.min((1 - b) / c, 1); }    function m4251(col, back, opacity) {     return b4248(          [ chanColorBurn(col[0], back[0]),            chanColorBurn(col[1], back[1]),            chanColorBurn(col[2], back[2]) ],         back,         opacity); }    function u4252(col, back, opacity) {     return b4248(         [ Math.max(back[0], col[0]),           Math.max(back[1], col[1]),           Math.max(back[2], col[2]) ],         back,         opacity); }    function r4254(c, b) {     return b + c - b*c; }    function k4253(col, back, opacity) {     return b4248(         [ r4254(col[0], back[0]),           r4254(col[1], back[1]),           r4254(col[2], back[2]) ],         back,         opacity); }    function i4256(c, b) {          if (b == 0) return 0;     else if (c == 1) return 1;     else             return Math.min(b / (1 - c), 1); }    function m4255(col, back, opacity) {     return b4248(         [ i4256(col[0], back[0]),           i4256(col[1], back[1]),           i4256(col[2], back[2]) ],         back,         opacity); }    function p4257(col, back, opacity) {     return b4248(         [ o4261(back[0], col[0]),           o4261(back[1], col[1]),           o4261(back[2], col[2]) ],         back,         opacity); }    function s2807(b) {     return b <= 0.25          ? ((16 * b - 12) * b + 4) * b          : Math.sqrt(b); }    function j4259(c, b) {     return c <= 0.5          ? b - (1 - 2*c) * b * (1 - b)          : b + (2*c - 1) * (s2807(b) - b); }    function c4258(col, back, opacity) {     return b4248(         [ j4259(col[0], back[0]),           j4259(col[1], back[1]),           j4259(col[2], back[2]) ],         back,         opacity); }    function o4261(c, b) {     if (c <= 0.5) return chanMultiply(b, 2 * c);     else          return r4254(b, 2 * c - 1); }    function b4260(col, back, opacity) {     return b4248(         [ o4261(col[0], back[0]),           o4261(col[1], back[1]),           o4261(col[2], back[2]) ],         back,         opacity); }    function g4262(col, back, opacity) {     return [ Math.abs(back[0] - col[0]),              Math.abs(back[1] - col[1]),              Math.abs(back[2] - col[2]) ]; }    function t4264(c, b) {     return b + c - 2*b*c; }    function d4263(col, back, opacity) {     return b4248(         [ t4264(col[0], back[0]),           t4264(col[1], back[1]),           t4264(col[2], back[2]) ],         back,         opacity); }    function v2808(col) {     return col[0] * 0.30          + col[1] * 0.59          + col[2] * 0.11; }    function v2809(i127, l) {     const col = [...i127];      const d = l - v2808(col);      col[0] += d;     col[1] += d;     col[2] += d;      return w2817(col); }    function d2810(col) {     return Math.max(col[0], col[1], col[2])           - Math.min(col[0], col[1], col[2]); }    function x2811(col) {          if (col[0] <= col[1]            && col[0] <= col[2]) return 0;     else if (col[1] <= col[1]            && col[1] <= col[2]) return 1;     else                       return 2; }    function j2812(col) {          if (   col[0] >= col[1]               && col[0] <= col[2]           ||    col[0] <= col[1]               && col[0] >= col[2]) return 0;     else if (   col[1] >= col[0]               && col[1] <= col[2]           ||    col[1] <= col[0]               && col[1] >= col[2]) return 1;     else                          return 2; }    function o2813(col) {          if (col[0] >= col[1]            && col[0] >= col[2]) return 0;     else if (col[1] >= col[1]            && col[1] >= col[2]) return 1;     else                       return 2; }    function s2814(col)  {     if (   col[0] == col[1]          && col[0] == col[2])         return [0, 1, 2];      else          return [             x2811(col),              j2812(col),              o2813(col)]; }    function z2815(i127, s) {     const col       = [...i127];     const [n, d, x] = s2814(col);      if (col[x] > col[n])     {         col[d] = (((col[d] - col[n]) * s) / (col[x] - col[n]));         col[x] = s;     }     else         col[d] = col[x] = 0;      col[n] = 0;      return col; }    function o2816(c, l, n, x) {          if (n < 0) return l + (((c - l) * l) / (l - n));     else if (x > 1) return l + (((c - l) * (1 - l)) / (x - l));     else            return c; }    function w2817(col) {     const l   = v2808(col);      const n = Math.min(col[0], col[1], col[2]);     const x = Math.max(col[0], col[1], col[2]);      return [ o2816(col[0], l, n, x),              o2816(col[1], l, n, x),              o2816(col[2], l, n, x) ]; }    function a4265(col, back, opacity) {     return b4248(         v2809(z2815(col, d2810(back)), v2808(back)),         back,         opacity); }    function x4266(col, back, opacity) {     return b4248(         v2809(z2815(back, d2810(col)), v2808(back)),         back,         opacity); }    function f4267(col, back, opacity) {     return b4248(         v2809(col, v2808(back)),         back,         opacity); }    function m4268(col, back, opacity) {     return b4248(         v2809(back, v2808(col)),         back,         opacity); }


class k1887 extends z2043 {     id;      colorStyle;     r2818;           linked;        constructor(nodeId, options, styleId)     {         super(l1216, nodeId, options);          this.id == styleId;     }        copy()     {         const copy = new k1887(this.nodeId, this.options);          copy.id = this.id;          if (this.colorStyle) copy.colorStyle = this.colorStyle.copy();         if (this.r2818  ) copy.r2818   = this.r2818  .copy();                         copy.linked   = this.linked;          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                   this.value = await evalColorValue(this.r2818, parse);           if (   this.value.isValid()             && this.linked)                                   {             if (this.value.type == d1168)                 this.value = c2013.y3773(n4142(this.value.p3242()), 0xff);              const rgba       = this.value.d99();             const k3261 = p100(d120(rgba), rgba[3]);              this.evalStyle({rgba: k3261});         }         else             this.value = c2013.NaN.copy();           this.j4101(parse,         [             ['value', this.value]         ]);           this.validate();          return this;     }        evalStyle(options = {})     {         if (!this.options.enabled)             return;                       const colorStyle = new p1839(this.nodeId, this.id, this.name);                     colorStyle.paints =          [             [ 'SOLID',                        Math.round(options.rgba[0] * 0xff)               + ' ' + Math.round(options.rgba[1] * 0xff)               + ' ' + Math.round(options.rgba[2] * 0xff)               + ' ' + Math.round(options.rgba[3] * 100 ) ]         ];           this.colorStyle = colorStyle;     }        isValid()     {         return this.r2818 && this.r2818.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.r2818) this.r2818.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.r2818) this.r2818.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.r2818) this.r2818.c4087(parse);     } }


class c1889 extends r2044 {     color   = null;     opacity = null;     blend   = null;        constructor(nodeId, options)     {         super(z1179, nodeId, options);     }        reset()     {         super.reset();          this.color   = null;         this.opacity = null;         this.blend   = null;     }        copy()     {         const copy = new c1889(this.nodeId, this.options);          copy.x3359(this);          if (this.color  ) copy.color   = this.color  .copy();         if (this.opacity) copy.opacity = this.opacity.copy();         if (this.blend  ) copy.blend   = this.blend  .copy();          return copy;     }        p4242(h2992)     {         switch (h2992)         {             case 'color':   return this.input ? this.value.color   : this.color;             case 'opacity': return this.input ? this.value.opacity : this.opacity;             case 'blend':   return this.input ? this.value.blend   : this.blend;         }          return null;     }        async eval(parse)     {         if (this.isCached())             return this;           const input   = await evalFillValue  (this.input,   parse);         let   color   = await evalColorValue (this.color,   parse);         let   opacity = await evalNumberValue(this.opacity, parse);         let   blend   = await evalNumberValue(this.blend,   parse);           if (input)         {             this.value = new c2013(                 color   ?? input.color,                 opacity ?? input.opacity,                 blend   ?? input.blend);         }         else if ((!color   || color  .type == d1168 )               && (!opacity || opacity.type == c1091)               && (!blend   || blend  .type == c1091))         {             this.value = new c2013(                 color,                  opacity,                 blend);         }         else             this.value = c2013.NaN.copy();           this.j4101(parse,         [             ['value',   this.value],             ['color',   color     ],             ['opacity', opacity   ],             ['blend',   blend     ]         ]);                                                this.validate();          return this;     }        r3633()     {         return this.options.enabled             ? new c2013(                 this.color   ? this.color  .r3633() : this.input.value.color  .r3633(),                 this.opacity ? this.opacity.r3633() : this.input.value.opacity.r3633(),                 this.blend   ? this.blend  .r3633() : this.input.value.blend  .r3633())             : c2013.NaN.copy();     }        isValid()     {         return (!this.input || this.input.isValid())             && this.color   && this.color  .isValid()             && this.opacity && this.opacity.isValid()             && this.blend   && this.blend  .isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.color  ) this.color  .c4088(parse);         if (this.opacity) this.opacity.c4088(parse);         if (this.blend  ) this.blend  .c4088(parse);     }                    t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.color  ) this.color  .t4089(parse, from, force);         if (this.opacity) this.opacity.t4089(parse, from, force);         if (this.blend  ) this.blend  .t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.color  ) this.color  .c4087(parse);         if (this.opacity) this.opacity.c4087(parse);         if (this.blend  ) this.blend  .c4087(parse);     } }


class g1886 extends r2044 {     fill     = null;     position = null;        constructor(nodeId, options)     {         super(v1185, nodeId, options);     }        reset()     {         super.reset();          this.fill     = null;         this.position = null;     }        copy()     {         const copy = new g1886(this.nodeId, this.options);          copy.x3359(this);          if (this.fill    ) copy.fill     = this.fill    .copy();         if (this.position) copy.position = this.position.copy();          return copy;     }        p4242(h2992)     {         switch (h2992)         {             case 'fill':      return this.input ? this.value.fill     : this.fill;             case 'position':  return this.input ? this.value.position : this.position;         }          return null;     }        async eval(parse)     {         if (this.isCached())             return this;                                     const input    = await evalColorStopValue(this.input,    parse);         let   fill     = await evalFillValue     (this.fill,     parse);         const position = await evalNumberValue   (this.position, parse);                  fill = this.validateFill(fill);           if (input)         {             this.value = new o2009(                    fill                  && fill.type != i1178                      ? fill                      : input.fill,                 position ?? input.position);         }         else         {             this.value = new o2009(                 fill,                  position);         }           this.j4101(parse,          [             ['value', this.value]         ]);                   if (!this.fill    ) this.fill     = this.value.fill    .copy();         if (!this.position) this.position = this.value.position.copy();           this.validate();          return this;     }        validateFill(fill)     {         if (!fill)             return null;           if (fill.type == d1168)             return c2013.y3773(n4142(fill.p3242()), 100);         else             return fill;     }        r3633()     {         return new o2009(             this.options.enabled             ? this.validateFill(this.fill ? this.fill.r3633() : this.input.fill.r3633())             : c2013.NaN,             this.position ? this.position.r3633() : this.input.position.r3633());     }                         isValid()     {         return (!this.input || this.input.isValid())             && this.fill     && this.fill    .isValid()             && this.position && this.position.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.fill    ) this.fill    .c4088(parse);         if (this.position) this.position.c4088(parse);     }                    t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.fill    ) this.fill    .t4089(parse, from, force);         if (this.position) this.position.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.fill    ) this.fill    .c4087(parse);         if (this.position) this.position.c4087(parse);     } }


class c1890 extends z2043 {     inputs = [];      l3687 = null;     position = null;     x        = null;     y        = null;     size     = null;     angle    = null;     aspect   = null;     skew     = null;     blend    = null;          diagAspect;                constructor(nodeId, options)     {         super(n1188, nodeId, options);     }                    reset()     {         super.reset();                  this.inputs = [];              this.l3687 = null;         this.position = null;         this.x        = null;         this.y        = null;         this.size     = null;         this.angle    = null;         this.aspect   = null;         this.skew     = null;         this.blend    = null;     }        copy()     {         const copy = new c1890(this.nodeId, this.options);          copy.x3359(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.l3687) copy.l3687 = this.x       .copy();         if (this.position) copy.position = this.position.copy();         if (this.x       ) copy.x        = this.x       .copy();         if (this.y       ) copy.y        = this.y       .copy();         if (this.size    ) copy.size     = this.size    .copy();         if (this.angle   ) copy.angle    = this.angle   .copy();         if (this.aspect  ) copy.aspect   = this.aspect  .copy();         if (this.skew    ) copy.skew     = this.skew    .copy();         if (this.blend   ) copy.blend    = this.blend   .copy();          return copy;     }        p4242(h2992)     {         switch (h2992)         {             case 'gradType':  return this.input ? this.value.l3687 : this.l3687;             case 'position':  return this.input ? this.value.position : this.position;             case 'x':         return this.input ? this.value.x        : this.x;             case 'y':         return this.input ? this.value.y        : this.y;             case 'size':      return this.input ? this.value.size     : this.size;             case 'angle':     return this.input ? this.value.angle    : this.angle;             case 'aspect':    return this.input ? this.value.aspect   : this.aspect;             case 'skew':      return this.input ? this.value.skew     : this.skew;             case 'blend':     return this.input ? this.value.blend    : this.blend;         }          return null;     }        async eval(parse)     {         if (this.isCached())             return this;                       let l3687 = await evalNumberValue(this.l3687, parse);         let position = await evalNumberValue(this.position, parse);         let x        = await evalNumberValue(this.x,        parse);         let y        = await evalNumberValue(this.y,        parse);         let size     = await evalNumberValue(this.size,     parse);         let angle    = await evalNumberValue(this.angle,    parse);         let aspect   = await evalNumberValue(this.aspect,   parse);         let skew     = await evalNumberValue(this.skew,     parse);         let blend    = await evalNumberValue(this.blend,    parse);           if (position) position.value = Math.min(Math.max(0, Math.floor(position.value)), 4);         if (blend   ) blend   .value = Math.min(Math.max(0, Math.floor(blend   .value)), l1393.length-1);           let stops = new d2021();           const inputs = [];                  for (const input of this.inputs)             inputs.push(await evalValue(input, parse));           if (   inputs.length == 1             && inputs[0].type == x1187)         {             this.value        = inputs[0].r3633();             this.value.nodeId = this.nodeId;             this.value.g3626(inputs[0]);              if (l3687)  this.value.l3687 = l3687;  else  l3687 = this.value.l3687;                   if (position)  this.value.position = position;  else  position = this.value.position;                   if (x       )  this.value.x        = x;         else  x        = this.value.x;                   if (y       )  this.value.y        = y;         else  y        = this.value.y;                   if (size    )  this.value.size     = size;      else  size     = this.value.size;                   if (angle   )  this.value.angle    = angle;     else  angle    = this.value.angle;                   if (aspect  )  this.value.aspect   = aspect;    else  aspect   = this.value.aspect;                   if (skew    )  this.value.skew     = skew;      else  skew     = this.value.skew;                   if (blend   )  this.value.blend    = blend;     else  blend    = this.value.blend;               }         else         {             for (let i = 0, o = 0; i < inputs.length; i++)             {                 const input = inputs[i];                  if (   input                     && this.options.enabled)                 {                     if (n957(input.type))                     {                         for (const item of input.items)                             if (item.isValid())                                 stops.items.push(item);                     }                     else if (input.type == x1187)                     {                         for (const item of input.stops.items)                             stops.items.push(item);                     }                     else                         if (input.isValid())                             stops.items.push(input);                 }             }               stops.items = e1827(stops.items);              i1829(stops.items);               this.value = new m2015(                 stops,                 l3687,                 position,                 x,                  y,                  size,                  angle,                  aspect,                 this.diagAspect,                 skew,                 blend);         }                   this.j4101(parse,         [             ['value',    this.value],             ['gradType', l3687  ],             ['position', position  ],             ['x',        x         ],             ['y',        y         ],             ['size',     size      ],             ['angle',    angle     ],             ['aspect',   aspect    ],             ['skew',     skew      ],             ['blend',    blend     ]         ]);                   if (   inputs.length == 1             && inputs[0].type == x1187)         {             if (!this.l3687) this.l3687 = this.value.l3687.copy();             if (!this.position) this.position = this.value.position.copy();             if (!this.x       ) this.x        = this.value.x       .copy();             if (!this.y       ) this.y        = this.value.y       .copy();             if (!this.size    ) this.size     = this.value.size    .copy();             if (!this.angle   ) this.angle    = this.value.angle   .copy();             if (!this.aspect  ) this.aspect   = this.value.aspect  .copy();             if (!this.skew    ) this.skew     = this.value.skew    .copy();             if (!this.blend   ) this.blend    = this.value.blend   .copy();         }           this.validate();          return this;     }                r3633()     {         return this.value.copy();     }                         isValid()     {         return !this.inputs.find(i => !i.isValid())             && this.l3687 && this.l3687.isValid()             && this.position && this.position.isValid()             && this.x        && this.x       .isValid()             && this.y        && this.y       .isValid()             && this.size     && this.size    .isValid()             && this.angle    && this.angle   .isValid()             && this.aspect   && this.aspect  .isValid()             && this.skew     && this.skew    .isValid()             && this.blend    && this.blend   .isValid();     }        c4088(parse)     {         super.c4088(parse);          this.inputs.forEach(i => i.c4088(parse));          if (this.l3687) this.l3687.c4088(parse);         if (this.position) this.position.c4088(parse);         if (this.x       ) this.x       .c4088(parse);         if (this.y       ) this.y       .c4088(parse);         if (this.size    ) this.size    .c4088(parse);         if (this.angle   ) this.angle   .c4088(parse);         if (this.aspect  ) this.aspect  .c4088(parse);         if (this.skew    ) this.skew    .c4088(parse);         if (this.blend   ) this.blend   .c4088(parse);     }            t4089(parse, from, force)     {         super.t4089(parse, from, force);          this.inputs.forEach(i => i.t4089(parse, from, force));                  if (this.l3687) this.l3687.t4089(parse, from, force);         if (this.position) this.position.t4089(parse, from, force);         if (this.x       ) this.x       .t4089(parse, from, force);         if (this.y       ) this.y       .t4089(parse, from, force);         if (this.size    ) this.size    .t4089(parse, from, force);         if (this.angle   ) this.angle   .t4089(parse, from, force);         if (this.aspect  ) this.aspect  .t4089(parse, from, force);         if (this.skew    ) this.skew    .t4089(parse, from, force);         if (this.blend   ) this.blend   .t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          this.inputs.forEach(i => i.c4087(parse));          if (this.l3687) this.l3687.c4087(parse);         if (this.position) this.position.c4087(parse);         if (this.x       ) this.x       .c4087(parse);         if (this.y       ) this.y       .c4087(parse);         if (this.size    ) this.size    .c4087(parse);         if (this.angle   ) this.angle   .c4087(parse);         if (this.aspect  ) this.aspect  .c4087(parse);         if (this.skew    ) this.skew    .c4087(parse);         if (this.blend   ) this.blend   .c4087(parse);     }     }


class z1896 extends r2044 {     fills  = null;    r3675  = null;      weight = null;     fit    = null;     join   = null;     miter  = null;     cap    = null;     dashes = null;                constructor(nodeId, options)     {         super(i1182, nodeId, options);     }                reset()     {         super.reset();                  this. fills  = null;         this.r3675  = null;          this. weight = null;         this. fit    = null;         this. join   = null;         this. miter  = null;         this. cap    = null;         this. dashes = null;     }        copy()     {         const copy = new z1896(this.nodeId, this.options);          copy.x3359(this);          if (this.fills ) copy. fills  = this.fills .copy();         if (this.r3675) copy.r3675  = this.r3675.copy();         if (this.weight) copy. weight = this.weight.copy();         if (this.fit   ) copy. fit    = this.fit   .copy();         if (this.join  ) copy. join   = this.join  .copy();         if (this.miter ) copy. miter  = this.miter .copy();         if (this.cap   ) copy. cap    = this.cap   .copy();         if (this.dashes) copy. dashes = this.dashes.copy();          return copy;     }        p4242(h2992)     {         switch (h2992)         {             case 'fills ':  return this.input ? this.value.fills  : this.fills;             case 'weight':  return this.input ? this.value.weight : this.weight;             case 'fit':     return this.input ? this.value.fit    : this.fit;             case 'join':    return this.input ? this.value.join   : this.join;             case 'miter':   return this.input ? this.value.miter  : this.miter;             case 'cap':     return this.input ? this.value.cap    : this.cap;             case 'dashes':  return this.input ? this.value.dashes : this.dashes;         }          return null;     }        async eval(parse)     {         if (this.isCached())             return this;          const input = await evalStrokeValue(this. input, parse);         let   fills = await evalListValue  (this.r3675, parse);          fills = this.validateFills(fills);          if (!n957(this.r3675.type))             this.fills = fills;           const weight = await evalNumberValue(this.weight, parse);         const fit    = await evalNumberValue(this.fit,    parse);         const join   = await evalNumberValue(this.join,   parse);         const miter  = await evalNumberValue(this.miter,  parse);         const cap    = await evalNumberValue(this.cap,    parse);         const dashes = await evalTextValue  (this.dashes, parse);           if (input)         {             this.value = new m2031(                 fills  ?? input.fills,                 weight ?? input.weight,                 fit    ?? input.fit,                 join   ?? input.join,                 miter  ?? input.miter,                 cap    ?? input.cap,                 dashes ?? input.dashes);         }         else         {             this.value = new m2031(                 fills,                  weight,                  fit,                  join,                 miter,                 cap,                 dashes);         }           this.j4101(parse,         [             ['value',  this.value],             ['fills',  fills     ],             ['weight', weight    ],             ['fit',    fit       ],             ['join',   join      ],             ['miter',  miter     ],             ['cap',    cap       ],             ['dashes', dashes    ]         ]);           this.validate();          return this;     }        validateFills(fills)     {                     if (!fills)             return null;          if (fills.type == d1168)             return new d2021([c2013.y3773(n4142(fills.p3242()), 100)]);          else if (fills.type ==     i1178               || fills.type == x1187)             return new d2021([fills]);         else         {             x952(fills.type == q1056, 'stroke.fills must be a LIST_VALUE');             return fills;         }     }        r3633()     {         return new m2031(             this.options.enabled             ? this.validateFills(this.fills ? this.fills.r3633() : this.input.fills.r3633())             : new d2021(),             this.weight ? this.weight.r3633() : this.input.weight.r3633(),             this.fit    ? this.fit   .r3633() : this.input.fit   .r3633(),             this.join   ? this.join  .r3633() : this.input.join  .r3633(),             this.miter  ? this.miter .r3633() : this.input.miter .r3633(),             this.cap    ? this.cap   .r3633() : this.input.cap   .r3633(),             this.dashes ? this.dashes.r3633() : this.input.dashes.r3633());     }                         isValid()     {         return (!this.input || this.input.isValid())             && this.fills  && this.fills .isValid()             && this.weight && this.weight.isValid()             && this.fit    && this.fit   .isValid()             && this.join   && this.join  .isValid()             && this.miter  && this.miter .isValid()             && this.cap    && this.cap   .isValid()             && this.dashes && this.dashes.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.r3675) this.r3675.c4088(parse);         if (this.weight) this.weight.c4088(parse);         if (this.fit   ) this.fit   .c4088(parse);         if (this.join  ) this.join  .c4088(parse);         if (this.miter ) this.miter .c4088(parse);         if (this.cap   ) this.cap   .c4088(parse);         if (this.dashes) this.dashes.c4088(parse);     }                    t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.r3675) this.r3675.t4089(parse, from, force);         if (this.weight) this.weight.t4089(parse, from, force);         if (this.fit   ) this.fit   .t4089(parse, from, force);         if (this.join  ) this.join  .t4089(parse, from, force);         if (this.miter ) this.miter .t4089(parse, from, force);         if (this.cap   ) this.cap   .t4089(parse, from, force);         if (this.dashes) this.dashes.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.r3675) this.r3675.c4087(parse);         if (this.weight) this.weight.c4087(parse);         if (this.fit   ) this.fit   .c4087(parse);         if (this.join  ) this.join  .c4087(parse);         if (this.miter ) this.miter .c4087(parse);         if (this.cap   ) this.cap   .c4087(parse);         if (this.dashes) this.dashes.c4087(parse);     }     }


class GStrokeSides extends r2044 {     top    = null;     left   = null;     right  = null;     bottom = null;                constructor(nodeId, options)     {         super(q1191, nodeId, options);     }                reset()     {         super.reset();                  this.top    = null;         this.left   = null;         this.right  = null;         this.bottom = null;     }        copy()     {         const copy = new GStrokeSides(this.nodeId, this.options);          copy.x3359(this);          if (this.top   ) copy.top    = this.top   .copy();         if (this.left  ) copy.left   = this.left  .copy();         if (this.right ) copy.right  = this.right .copy();         if (this.bottom) copy.bottom = this.bottom.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalStrokeSidesValue(this.input,  parse);         const top    = await evalNumberValue     (this.top,    parse);         const left   = await evalNumberValue     (this.left,   parse);         const right  = await evalNumberValue     (this.right,  parse);         const bottom = await evalNumberValue     (this.bottom, parse);           if (input)         {             this.value = new y4272(                 top    ?? input.top,                 left   ?? input.left,                 right  ?? input.right,                 bottom ?? input.bottom,                 this.options.enabled);         }         else         {             this.value = new y4272(                 top,                  left,                  right,                  bottom,                 this.options.enabled);         }           this.j4101(parse,         [             ['top',    this.value.top   ],             ['left',   this.value.left  ],             ['right',  this.value.right ],             ['bottom', this.value.bottom]         ]);                   if (!this.top   ) this.top    = this.value.top   .copy();         if (!this.left  ) this.left   = this.value.left  .copy();         if (!this.right ) this.right  = this.value.right .copy();         if (!this.bottom) this.bottom = this.value.bottom.copy();           this.validate();          return this;     }        r3633()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.top    && this.top   .isValid()             && this.left   && this.left  .isValid()             && this.right  && this.right .isValid()             && this.bottom && this.bottom.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.top   ) this.top   .c4088(parse);         if (this.left  ) this.left  .c4088(parse);         if (this.right ) this.right .c4088(parse);         if (this.bottom) this.bottom.c4088(parse);     }                   t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.top   ) this.top   .t4089(parse, from, force);         if (this.left  ) this.left  .t4089(parse, from, force);         if (this.right ) this.right .t4089(parse, from, force);         if (this.bottom) this.bottom.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.top   ) this.top   .c4087(parse);         if (this.left  ) this.left  .c4087(parse);         if (this.right ) this.right .c4087(parse);         if (this.bottom) this.bottom.c4087(parse);     } }


class g1895 extends r2044 {     tl = null;     tr = null;     bl = null;     br = null;                constructor(nodeId, options)     {         super(h1194, nodeId, options);     }                reset()     {         super.reset();                  this.tl = null;         this.tr = null;         this.bl = null;         this.br = null;     }        copy()     {         const copy = new g1895(this.nodeId, this.options);          copy.x3359(this);          if (this.tl) copy.tl = this.tl.copy();         if (this.tr) copy.tr = this.tr.copy();         if (this.bl) copy.bl = this.bl.copy();         if (this.br) copy.br = this.br.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalRoundedCornersValue(this.input, parse);         const tl    = await evalNumberValue        (this.tl,    parse);         const tr    = await evalNumberValue        (this.tr,    parse);         const bl    = await evalNumberValue        (this.bl,    parse);         const br    = await evalNumberValue        (this.br,    parse);           if (input)         {             this.value = new v2026(                 tl ?? input.tl,                 tr ?? input.tr,                 bl ?? input.bl,                 br ?? input.br,                 this.options.enabled);         }         else         {             this.value = new v2026(                 tl,                  tr,                  bl,                  br,                 this.options.enabled);         }           this.j4101(parse,         [             ['tl', this.value.tl],             ['tr', this.value.tr],             ['bl', this.value.bl],             ['br', this.value.br]         ]);                   if (!this.tl) this.tl = this.value.tl.copy();         if (!this.tr) this.tr = this.value.tr.copy();         if (!this.bl) this.bl = this.value.bl.copy();         if (!this.br) this.br = this.value.br.copy();           this.validate();          return this;     }        r3633()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.tl && this.tl.isValid()             && this.tr && this.tr.isValid()             && this.bl && this.bl.isValid()             && this.br && this.br.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.tl) this.tl.c4088(parse);         if (this.tr) this.tr.c4088(parse);         if (this.bl) this.bl.c4088(parse);         if (this.br) this.br.c4088(parse);     }                   t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.tl) this.tl.t4089(parse, from, force);         if (this.tr) this.tr.t4089(parse, from, force);         if (this.bl) this.bl.t4089(parse, from, force);         if (this.br) this.br.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.tl) this.tl.c4087(parse);         if (this.tr) this.tr.c4087(parse);         if (this.bl) this.bl.c4087(parse);         if (this.br) this.br.c4087(parse);     } }


class u1888 extends r2044 {     x      = null;     y      = null;     blur   = null;     spread = null;     fill   = null;     blend  = null;     behind = null;                constructor(nodeId, options)     {         super(n1197, nodeId, options);     }                reset()     {         super.reset();                  this.x      = null;         this.y      = null;         this.blur   = null;         this.spread = null;         this.fill   = null;         this.blend  = null;         this.behind = null;     }        copy()     {         const copy = new u1888(this.nodeId, this.options);          copy.x3359(this);          if (this.x     ) copy.x      = this.x     .copy();         if (this.y     ) copy.y      = this.y     .copy();         if (this.blur  ) copy.blur   = this.blur  .copy();         if (this.spread) copy.spread = this.spread.copy();         if (this.fill  ) copy.fill   = this.fill  .copy();         if (this.blend ) copy.blend  = this.blend .copy();         if (this.behind) copy.behind = this.behind.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalValue      (this.input,  parse);         const x      = await evalNumberValue(this.x,      parse);         const y      = await evalNumberValue(this.y,      parse);         const blur   = await evalNumberValue(this.blur,   parse);         const spread = await evalNumberValue(this.spread, parse);         let   fill   = await evalFillValue  (this.fill,   parse);         const blend  = await evalNumberValue(this.blend,  parse);         const behind = await evalNumberValue(this.behind, parse);           if (   fill             && fill.type == d1168)             fill = new c2013(fill);                   if (input)         {             this.value = new n2011(                 x      ?? input.x,                 y      ?? input.y,                 blur   ?? input.blur,                 spread ?? input.spread,                 fill   ?? input.fill,                 blend  ?? input.blend,                 behind ?? input.behind,                 this.options.enabled);         }         else         {             this.value = new n2011(                 x,                  y,                  blur,                  spread,                  fill,                  blend,                  behind,                 this.options.enabled);         }           this.j4101(parse,         [             ['x',      this.value.x     ],             ['y',      this.value.y     ],             ['blur',   this.value.blur  ],             ['spread', this.value.spread],             ['fill',   this.value.fill  ],             ['blend',  this.value.blend ],             ['behind', this.value.behind]         ]);                   if (!this.x     ) this.x      = this.value.x     .copy();         if (!this.y     ) this.y      = this.value.y     .copy();         if (!this.blur  ) this.blur   = this.value.blur  .copy();         if (!this.spread) this.spread = this.value.spread.copy();         if (!this.fill  ) this.fill   = this.value.fill  .copy();         if (!this.blend ) this.blend  = this.value.blend .copy();         if (!this.behind) this.behind = this.value.behind.copy();           this.validate();          return this;     }        r3633()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.x      && this.x     .isValid()             && this.y      && this.y     .isValid()             && this.blur   && this.blur  .isValid()             && this.spread && this.spread.isValid()             && this.fill   && this.fill  .isValid()             && this.blend  && this.blend .isValid()             && this.behind && this.behind.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.x     ) this.x     .c4088(parse);         if (this.y     ) this.y     .c4088(parse);         if (this.blur  ) this.blur  .c4088(parse);         if (this.spread) this.spread.c4088(parse);         if (this.fill  ) this.fill  .c4088(parse);         if (this.blend ) this.blend .c4088(parse);         if (this.behind) this.behind.c4088(parse);     }                   t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.x     ) this.x     .t4089(parse, from, force);         if (this.y     ) this.y     .t4089(parse, from, force);         if (this.blur  ) this.blur  .t4089(parse, from, force);         if (this.spread) this.spread.t4089(parse, from, force);         if (this.fill  ) this.fill  .t4089(parse, from, force);         if (this.blend ) this.blend .t4089(parse, from, force);         if (this.behind) this.behind.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.x     ) this.x     .c4087(parse);         if (this.y     ) this.y     .c4087(parse);         if (this.blur  ) this.blur  .c4087(parse);         if (this.spread) this.spread.c4087(parse);         if (this.fill  ) this.fill  .c4087(parse);         if (this.blend ) this.blend .c4087(parse);         if (this.behind) this.behind.c4087(parse);     } }


class z1891 extends r2044 {     x      = null;     y      = null;     blur   = null;     spread = null;     fill   = null;     blend  = null;                constructor(nodeId, options)     {         super(b1200, nodeId, options);     }        reset()     {         super.reset();          this.x      = null;         this.y      = null;         this.blur   = null;         this.spread = null;         this.fill   = null;         this.blend  = null;     }        copy()     {         const copy = new z1891(this.nodeId, this.options);          copy.x3359(this);          if (this.x     ) copy.x      = this.x     .copy();         if (this.y     ) copy.y      = this.y     .copy();         if (this.blur  ) copy.blur   = this.blur  .copy();         if (this.spread) copy.spread = this.spread.copy();         if (this.fill  ) copy.fill   = this.fill  .copy();         if (this.blend ) copy.blend  = this.blend .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalInnerShadowValue(this.input,  parse);         const x      = await evalNumberValue     (this.x,      parse);         const y      = await evalNumberValue     (this.y,      parse);         const blur   = await evalNumberValue     (this.blur,   parse);         const spread = await evalNumberValue     (this.spread, parse);         let   fill   = await evalFillValue       (this.fill,   parse);         const blend  = await evalNumberValue     (this.blend,  parse);                   if (   fill             && fill.type == d1168)             fill = new c2013(fill);           if (input)         {             this.value = new k2016(                 x      ?? input.x,                 y      ?? input.y,                 blur   ?? input.blur,                 spread ?? input.spread,                 fill   ?? input.fill,                 blend  ?? input.blend,                 this.options.enabled);         }         else         {             this.value = new k2016(                 x,                  y,                  blur,                  spread,                  fill,                  blend,                 this.options.enabled);         }           this.j4101(parse,         [             ['x',      this.value.x     ],             ['y',      this.value.y     ],             ['blur',   this.value.blur  ],             ['spread', this.value.spread],             ['fill',   this.value.fill  ],             ['blend',  this.value.blend ],         ]);                   if (!this.x     ) this.x      = this.value.x     .copy();         if (!this.y     ) this.y      = this.value.y     .copy();         if (!this.blur  ) this.blur   = this.value.blur  .copy();         if (!this.spread) this.spread = this.value.spread.copy();         if (!this.fill  ) this.fill   = this.value.fill  .copy();         if (!this.blend ) this.blend  = this.value.blend .copy();           this.validate();          return this;     }        r3633()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.x      && this.x     .isValid()             && this.y      && this.y     .isValid()             && this.blur   && this.blur  .isValid()             && this.spread && this.spread.isValid()             && this.fill   && this.fill  .isValid()             && this.blend  && this.blend .isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.x     ) this.x     .c4088(parse);         if (this.y     ) this.y     .c4088(parse);         if (this.blur  ) this.blur  .c4088(parse);         if (this.spread) this.spread.c4088(parse);         if (this.fill  ) this.fill  .c4088(parse);         if (this.blend ) this.blend .c4088(parse);     }                    t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.x     ) this.x     .t4089(parse, from, force);         if (this.y     ) this.y     .t4089(parse, from, force);         if (this.blur  ) this.blur  .t4089(parse, from, force);         if (this.spread) this.spread.t4089(parse, from, force);         if (this.fill  ) this.fill  .t4089(parse, from, force);         if (this.blend ) this.blend .t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.x     ) this.x     .c4087(parse);         if (this.y     ) this.y     .c4087(parse);         if (this.blur  ) this.blur  .c4087(parse);         if (this.spread) this.spread.c4087(parse);         if (this.fill  ) this.fill  .c4087(parse);         if (this.blend ) this.blend .c4087(parse);     } }


class j1893 extends r2044 {     radius = null;        constructor(nodeId, options)     {         super(a1203, nodeId, options);     }        reset()     {         super.reset();          this.radius = null;     }        copy()     {         const copy = new j1893(this.nodeId, this.options);          copy.x3359(this);          if (this.radius) copy.radius = this.radius.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalLayerBlurValue(this.input,  parse);         const radius = await evalNumberValue   (this.radius, parse);                   if (input)         {             this.value = new m2018(                 radius ?? input.radius,                 this.options.enabled);         }         else         {             this.value = new m2018(                 radius,                 this.options.enabled);         }           this.j4101(parse,         [             ['radius', this.value.radius]         ]);                   if (!this.radius) this.radius = this.value.radius.copy();           this.validate();          return this;     }        r3633()     {         return new m2018(             this.radius ? this.radius.r3633() : this.input.radius.r3633(),             this.options.enabled);     }        isValid()     {         return super.isValid()             && this.radius && this.radius.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.radius) this.radius.c4088(parse);     }                    t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.radius) this.radius.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.radius) this.radius.c4087(parse);     } }


class g1885 extends r2044 {     radius = null;        constructor(nodeId, options)     {         super(m1206, nodeId, options);     }        reset()     {         super.reset();          this.radius = null;     }        copy()     {         const copy = new g1885(this.nodeId, this.options);          copy.x3359(this);          if (this.radius) copy.radius = this.radius.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalValue      (this.input,  parse);         const radius = await evalNumberValue(this.radius, parse);                   if (input)         {             this.value = new f2008(                 radius ?? input.radius,                 this.options.enabled);         }         else         {             this.value = new f2008(                 radius,                 this.options.enabled);         }           this.j4101(parse,         [             ['radius', this.value.radius]         ]);                   if (!this.radius) this.radius = this.value.radius.copy();           this.validate();          return this;     }        r3633()     {         return new f2008(             this.radius ? this.radius.r3633() : this.input.radius.r3633(),             this.options.enabled);     }        isValid()     {         return super.isValid()             && this.radius && this.radius.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.radius) this.radius.c4088(parse);     }                    t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.radius) this.radius.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.radius) this.radius.c4087(parse);     } }


class y1892 extends z2043 {     opacity;     blend;        constructor(nodeId, options)     {         super(x1212, nodeId, options);     }        reset()     {         super.reset();          this.opacity = null;         this.blend   = null;     }        copy()     {         const copy = new y1892(this.nodeId, this.options);          copy.x3359(this);          if (this.opacity) copy.opacity = this.opacity.copy();         if (this.blend  ) copy.blend   = this.blend  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const opacity = await evalNumberValue(this.opacity, parse);         const blend   = await evalNumberValue(this.blend,   parse);           this.value =              this.options.enabled             ? new t2017(opacity, blend)             : new t2017(new y2022(100), new y2022(0));           this.j4101(parse,          [             ['opacity', opacity],             ['blend',   blend  ]         ]);           this.validate();          return this;     }        r3633()     {         return this.value.copy();     }        isValid()     {         return this.opacity && this.opacity.isValid()             && this.blend   && this.blend  .isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.opacity) this.opacity.c4088(parse);         if (this.blend  ) this.blend  .c4088(parse);     }                    t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.opacity) this.opacity.t4089(parse, from, force);         if (this.blend  ) this.blend  .t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.opacity) this.opacity.c4087(parse);         if (this.blend  ) this.blend  .c4087(parse);     } }


class f1894 extends z2043 {     maskType;        constructor(nodeId, options)     {         super(c1209, nodeId, options);     }        reset()     {         super.reset();          this.maskType = null;     }        copy()     {         const copy = new f1894(this.nodeId, this.options);          copy.x3359(this);          if (this.maskType) copy.maskType = this.maskType.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const maskType = await evalNumberValue(this.maskType, parse);           this.value = new k2019(maskType, this.options.enabled);           this.j4101(parse,          [             ['maskType', maskType]         ]);           this.validate();          return this;     }        r3633()     {         return this.value.copy();     }        isValid()     {         return this.maskType && this.maskType.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.maskType) this.maskType.c4088(parse);     }                    t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.maskType) this.maskType.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.maskType) this.maskType.c4087(parse);     } }


class c1975 extends z2043 {     x      = null;     y      = null;     width  = null;     height = null;        constructor(type, nodeId, options)     {         super(type, nodeId, options);     }        reset()     {         super.reset();                  this.x      = null;         this.y      = null;         this.width  = null;         this.height = null;     }        x3359(base)     {         super.x3359(base);          if (base.x     ) this.x      = base.x     .copy();         if (base.y     ) this.y      = base.y     .copy();         if (base.width ) this.width  = base.width .copy();         if (base.height) this.height = base.height.copy();     }        async evalBaseParams(parse, evalHeight = true)     {         let x      =              await evalNumberValue(this.x,      parse);         let y      =              await evalNumberValue(this.y,      parse);         let width  =              await evalNumberValue(this.width,  parse);         let height = evalHeight ? await evalNumberValue(this.height, parse) : null;          return [x, y, width, height];     }        evalStyle(options = {})     {                       }        isValid()     {         return this.x      && this.x     .isValid()             && this.y      && this.y     .isValid()             && this.width  && this.width .isValid()             && this.height && this.height.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.x     ) this.x     .c4088(parse);         if (this.y     ) this.y     .c4088(parse);         if (this.width ) this.width .c4088(parse);         if (this.height) this.height.c4088(parse);     }            t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.x     ) this.x     .t4089(parse, from, force);         if (this.y     ) this.y     .t4089(parse, from, force);         if (this.width ) this.width .t4089(parse, from, force);         if (this.height) this.height.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.x     ) this.x     .c4087(parse);         if (this.y     ) this.y     .c4087(parse);         if (this.width ) this.width .c4087(parse);         if (this.height) this.height.c4087(parse);     } }    function validateObjectRect(x, y, w, h, a = 0, _a = 0) {     if (w < 0)     {         x += w * Math.cos(_a);         y += w * Math.sin(_a);     }      if (h < 0)     {         y += h * Math.cos(_a);         x -= h * Math.sin(_a);     }             w = Math.abs(w);     h = Math.abs(h);       return [x, y, w, h, a, _a]; }


class r1974 extends c1975 {     input = null;      props = null;           constructor(type, nodeId, options)     {         super(type, nodeId, options);     }        reset()     {         super.reset();          this.input = null;         this.props = null;     }        x3359(base)     {         super.x3359(base);                  if (base.input) this.input = base.input.copy();         if (base.props) this.props = base.props.copy();     }        p4242(h2992)     {         switch (h2992)         {             case 'props':  return this.input ? this.value.props : this.props;         }          return null;     }        y2897()     {         return this.value             && this.value.props             && this.value.props.isValid();     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        async s2896(parse)     {         let props = await evalListValue(this.props, parse);          if (   props             && u1215.includes(props.type))             props = new d2021([props]);                   if (this.value)         {             if (this.input)             {                 this.value.props = props ?? this.input.r3633().props;                                  if (props)  this.value.props = props;  else  props = this.value.props;               }             else                 this.value.props = props;                                   if (   this.value                 && this.value.isValid()                 && this.value.props != undefined)              {                 this.j4101(parse,                  [                                      ],                  true);                                   if (!this.props) this.props = this.value.props.copy();             }         }     }        async x4100(parse)     {         if (!this.value)             return;           for (const v111 of this.value.objects)         {             x952(v111.fills,   'obj.fills   must not be null');             x952(v111.strokes, 'obj.strokes must not be null');             x952(v111.effects, 'obj.effects must not be null');               if (this.value.props)                 addProps(v111, this.value.props);         }     }        evalStyle(options = {})     {      }        isValid()     {         return super.isValid()             && (!this.input || this.input.isValid())             && this.props && this.props.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.input) this.input.c4088(parse);         if (this.props) this.props.c4088(parse);     }            t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.input) this.input.t4089(parse, from, force);         if (this.props) this.props.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.input) this.input.c4087(parse);         if (this.props) this.props.c4087(parse);     } }    function addProps(v111, props) {     if (n957(props.type))     {                        for (let i = 0; i < props.items.length; i++)             r1823(v111, props.items[i]);     }     else         r1823(v111, props); }


class f1969 extends r1974 {     round = null;        constructor(nodeId, options)     {         super(u1219, nodeId, options);     }        reset()     {         super.reset();          this.round = null;     }        copy()     {         const copy = new f1969(this.nodeId, this.options);          copy.x3359(this);          if (this.round) copy.round = this.round.copy();          return copy;     }        p4242(h2992)     {         switch (h2992)         {             case 'x':      return this.input ? this.value.x      : this.x;             case 'y':      return this.input ? this.value.y      : this.y;             case 'width':  return this.input ? this.value.width  : this.width;             case 'height': return this.input ? this.value.height : this.height;             case 'round':  return this.input ? this.value.round  : this.round;         }          return super.p4242(h2992);     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalRectangleValue(this.input, parse);         let   round = await evalNumberValue   (this.round, parse);          if (round && !round.isValid()) round = y2022.NaN.copy();                   let [x, y, width, height] = await this.evalBaseParams(parse);           if (input)         {             this.value        = input.r3633();             this.value.nodeId = this.nodeId;             this.value.g3626(input);                          if (x     )  this.value.x      = x;       else  x      = this.value.x;                   if (y     )  this.value.y      = y;       else  y      = this.value.y;                   if (width )  this.value.width  = width;   else  width  = this.value.width;               if (height)  this.value.height = height;  else  height = this.value.height;              if (round )  this.value.round  = round;   else  round  = this.value.round;           }         else         {             this.value = new z2025(                 this.nodeId,                  x,                  y,                  width,                  height,                  round);         }                  this.j4101(parse,          [             ['x',      x     ],             ['y',      y     ],             ['width',  width ],             ['height', height],             ['round',  round ]         ]);           await this.s2896(parse);           await this.x4100(parse);           if (!this.x     ) this.x      = this.value.x     .copy();         if (!this.y     ) this.y      = this.value.y     .copy();         if (!this.width ) this.width  = this.value.width .copy();         if (!this.height) this.height = this.value.height.copy();         if (!this.round ) this.round  = this.value.round .copy();           this.validate();          return this;     }        async x4100(parse, options = {})     {         if (!this.options.enabled)             return;                        this.value.objects = [];           if (   super.y2897()                && this.value.x     .isValid()             && this.value.y     .isValid()             && this.value.width .isValid()             && this.value.height.isValid()             && this.value.round .isValid())         {             let   x = this.value.x     .value;             let   y = this.value.y     .value;             let   w = this.value.width .value;             let   h = this.value.height.value;             const r = Math.max(0, this.value.round.value);               [x, y, w, h, , ] = validateObjectRect(x, y, w, h);               if (   w != 0                  && h != 0)             {                 const rect = new h1846(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     x, y, w, h, r);                  rect.f4098(x, y);                 rect.c3730(x, y, w, h);                  this.value.objects.push(rect);             }         }                   await super.x4100(parse);     }                                                                                    isValid()     {         return super.isValid()             && this.round && this.round.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.round) this.round.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.round) this.round.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.round) this.round.c4087(parse);     } }


class e1960 extends r1974 {     constructor(nodeId, options)     {         super(m1222, nodeId, options);     }        copy()     {         const copy = new e1960(this.nodeId, this.options);          copy.x3359(this);          return copy;     }        p4242(h2992)     {         switch (h2992)         {             case 'x':     return this.input ? this.value.x     : this.x;             case 'y':     return this.input ? this.value.y     : this.y;             case 'width': return this.input ? this.value.width : this.width;         }          return super.p4242(h2992);     }        async eval(parse)     {         if (this.isCached())             return this;           let input = await evalLineValue(this.input, parse);          let [x, y, width, ] = await this.evalBaseParams(parse, false);                       if (input)         {             this.value        = input.r3633();             this.value.nodeId = this.nodeId;             this.value.g3626(input);              if (x    )  this.value.x     = x;      else  x     = this.value.x;                   if (y    )  this.value.y     = y;      else  y     = this.value.y;                   if (width)  this.value.width = width;  else  width = this.value.width;           }         else         {             this.value = new c2020(                 this.nodeId,                  x,                  y,                  width);         }           this.j4101(parse,          [             ['x',      x     ],             ['y',      y     ],             ['width',  width ]         ]);           await this.s2896(parse);           await this.x4100(parse);           if (!this.x    ) this.x     = this.value.x    .copy();         if (!this.y    ) this.y     = this.value.y    .copy();         if (!this.width) this.width = this.value.width.copy();           this.validate();          return this;     }        async x4100(parse, options = {})     {         if (!this.options.enabled)             return;                       this.value.objects = [];           if (   super.y2897()                && this.value.x    .isValid()             && this.value.y    .isValid()             && this.value.width.isValid())          {             let x = this.value.x    .value;             let y = this.value.y    .value;             let w = this.value.width.value;               [x, y, w, , , ] = validateObjectRect(x, y, w, 0);               if (w != 0)             {                 const line = new p1842(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     x, y, w);                  line.f4098(x, y);                 line.c3730(x, y, w, 0.01);                                  this.value.objects.push(line);             }         }                   await super.x4100(parse);     }        isValid()     {         return super.isValid()             && this.x     && this.x    .isValid()             && this.y     && this.y    .isValid()             && this.width && this.width.isValid();     }        c4088(parse)     {         super.c4088(parse);           if (this.x    ) this.x    .c4088(parse);         if (this.y    ) this.y    .c4088(parse);         if (this.width) this.width.c4088(parse);     }                   t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.x    ) this.x    .t4089(parse, from, force);         if (this.y    ) this.y    .t4089(parse, from, force);         if (this.width) this.width.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);           if (this.x    ) this.x    .c4087(parse);         if (this.y    ) this.y    .c4087(parse);         if (this.width) this.width.c4087(parse);     } }


class a1956 extends r1974 {     position = null;     round    = null;     start    = null;     sweep    = null;     inner    = null;      innerAbsolute;     sweepInDegrees;        constructor(nodeId, options)     {         super(p1225, nodeId, options);     }        reset()     {         super.reset();          this.position = null;         this.round    = null;         this.start    = null;         this.sweep    = null;         this.inner    = null;     }        copy()     {         const copy = new a1956(this.nodeId, this.options);          copy.x3359(this);          if (this.position) copy.position = this.position.copy();         if (this.round   ) copy.round    = this.round   .copy();         if (this.start   ) copy.start    = this.start   .copy();         if (this.sweep   ) copy.sweep    = this.sweep   .copy();         if (this.inner   ) copy.inner    = this.inner   .copy();                  return copy;     }        p4242(h2992)     {         switch (h2992)         {             case 'position': return this.input ? this.value.position : this.position;             case 'x':        return this.input ? this.value.x        : this.x;             case 'y':        return this.input ? this.value.y        : this.y;             case 'width':    return this.input ? this.value.width    : this.width;             case 'height':   return this.input ? this.value.height   : this.height;             case 'round':    return this.input ? this.value.round    : this.round;             case 'start':    return this.input ? this.value.start    : this.start;             case 'sweep':    return this.input ? this.value.sweep    : this.sweep;             case 'inner':    return this.input ? this.value.inner    : this.inner         }          return super.p4242(h2992);     }        async eval(parse)     {         if (this.isCached())             return this;           let [x, y, width, height] = await this.evalBaseParams(parse);          let input = await evalValue      (this.input,    parse);         let pos   = await evalNumberValue(this.position, parse);         let round = await evalNumberValue(this.round,    parse);         let start = await evalNumberValue(this.start,    parse);         let sweep = await evalNumberValue(this.sweep,    parse);         let inner = await evalNumberValue(this.inner,    parse);          if (pos   && !pos  .isValid()) pos   = y2022.NaN.copy();         if (round && !round.isValid()) round = y2022.NaN.copy();         if (start && !start.isValid()) start = y2022.NaN.copy();         if (sweep && !sweep.isValid()) sweep = y2022.NaN.copy();         if (inner && !inner.isValid()) inner = y2022.NaN.copy();           if (input)         {             this.value        = input.copy();             this.value.nodeId = this.nodeId;             this.value.g3626(input);              if (pos   )  this.value.position = pos;     else  pos    = this.value.position;             if (x     )  this.value.x        = x;       else  x      = this.value.x;                   if (y     )  this.value.y        = y;       else  y      = this.value.y;                   if (width )  this.value.width    = width;   else  width  = this.value.width;               if (height)  this.value.height   = height;  else  height = this.value.height;              if (round )  this.value.round    = round;   else  round  = this.value.round;               if (start )  this.value.start    = start;   else  start  = this.value.start;             if (sweep )  this.value.sweep    = sweep;   else  sweep  = this.value.sweep;             if (inner )  this.value.inner    = inner;   else  inner  = this.value.inner;           }         else         {             this.value = new v2012(                 this.nodeId,                 pos,                 x,                  y,                  width,                  height,                 round,                 start,                 sweep,                 inner);         }           this.j4101(parse,          [             ['position', pos   ],             ['x',        x     ],             ['y',        y     ],             ['width',    width ],             ['height',   height],             ['round',    round ],             ['start',    start ],             ['sweep',    sweep ],             ['inner',    inner ]         ]);           await this.s2896(parse);           await this.x4100(parse);           this.validate();          return this;     }        async x4100(parse, options = {})     {        if (!this.options.enabled)            return;                                 this.value.objects = [];           if (   super.y2897()             && this.value.x     .isValid()             && this.value.y     .isValid()             && this.value.width .isValid()             && this.value.height.isValid())          {             const vpos = this.value.position;             const vx   = this.value.x;             const vy   = this.value.y;             const vw   = this.value.width;             const vh   = this.value.height;              const _x = vpos.value <= 0 ? vx : new y2022(vx.value - vw.value, Math.max(vx.decimals, vw.decimals));             const _y = vpos.value <= 0 ? vy : new y2022(vy.value - vh.value, Math.max(vy.decimals, vh.decimals));             const _w = vpos.value <= 0 ? vw : new y2022(vw.value*2, Math.max(vx.decimals, vw.decimals));             const _h = vpos.value <= 0 ? vh : new y2022(vh.value*2, Math.max(vy.decimals, vh.decimals));                          let   x  = _x.value;             let   y  = _y.value;             let   w  = _w.value;             let   h  = _h.value;             let   r  = this.value.round .value;             const st = this.value.start .value;             let   sw = this.value.sweep .value;             let   i  = this.value.inner .value;               [x, y, w, h, , ] = validateObjectRect(x, y, w, h);               if (   w != 0                  && h != 0)             {                 if (this.innerAbsolute ) i  /= Math.max(w, h) / 200;                 if (this.sweepInDegrees) sw /= 3.6;                  const ellipse = new y1840(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     x, y, w, h, r, st, sw, i);                  ellipse.f4098(x, y);                 ellipse.c3730(x, y, w, h);                  this.value.objects.push(ellipse);             }         }           await super.x4100(parse);     }                       isValid()     {         return super.isValid()             && this.position && this.position.isValid()             && this.round    && this.round   .isValid()             && this.start    && this.start   .isValid()             && this.sweep    && this.sweep   .isValid()             && this.inner    && this.inner   .isValid();     }        c4088(parse)     {         super.c4088(parse);           if (this.position) this.position.c4088(parse);         if (this.round   ) this.round   .c4088(parse);         if (this.start   ) this.start   .c4088(parse);         if (this.sweep   ) this.sweep   .c4088(parse);         if (this.inner   ) this.inner   .c4088(parse);     }                   t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.position) this.position.t4089(parse, from, force);         if (this.round   ) this.round   .t4089(parse, from, force);         if (this.start   ) this.start   .t4089(parse, from, force);         if (this.sweep   ) this.sweep   .t4089(parse, from, force);         if (this.inner   ) this.inner   .t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);           if (this.position) this.position.c4087(parse);         if (this.round   ) this.round   .c4087(parse);         if (this.start   ) this.start   .c4087(parse);         if (this.sweep   ) this.sweep   .c4087(parse);         if (this.inner   ) this.inner   .c4087(parse);     } }


class h1980 extends r1974 {     round = null;     bias  = null;        constructor(nodeId, options)     {         super(b1228, nodeId, options);     }        reset()     {         super.reset();          this.round = null;         this.bias  = null;     }        copy()     {         const copy = new h1980(this.nodeId, this.options);          copy.x3359(this);          if (this.round) copy.round = this.round.copy();         if (this.bias ) copy.bias  = this.bias .copy();          return copy;     }        p4242(h2992)     {         switch (h2992)         {             case 'x':      return this.input ? this.value.x      : this.x;             case 'y':      return this.input ? this.value.y      : this.y;             case 'width':  return this.input ? this.value.width  : this.width;             case 'height': return this.input ? this.value.height : this.height;             case 'round':  return this.input ? this.value.round  : this.round;             case 'bias':   return this.input ? this.value.bias   : this.bias;         }          return super.p4242(h2992);     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalValue      (this.input, parse);         let   round = await evalNumberValue(this.round, parse);         let   bias  = await evalNumberValue(this.bias,  parse);                  let [x, y, width, height] = await this.evalBaseParams(parse);           if (input)         {             this.value        = input.r3633();             this.value.nodeId = this.nodeId;             this.value.g3626(input);              if (x     )  this.value.x      = x;       else  x      = this.value.x;                   if (y     )  this.value.y      = y;       else  y      = this.value.y;                   if (width )  this.value.width  = width;   else  width  = this.value.width;               if (height)  this.value.height = height;  else  height = this.value.height;              if (round )  this.value.round  = round;   else  round  = this.value.round;               if (bias  )  this.value.bias   = bias;    else  bias   = this.value.bias;           }         else         {             this.value = new t2034(                 this.nodeId,                  x,                  y,                  width,                  height,                  round,                 bias);         }                  this.j4101(parse,          [             ['x',      x     ],             ['y',      y     ],             ['width',  width ],             ['height', height],             ['round',  round ],             ['bias',   bias  ]         ]);           await this.s2896(parse);           await this.x4100(parse);           if (!this.x     ) this.x      = this.value.x     .copy();         if (!this.y     ) this.y      = this.value.y     .copy();         if (!this.width ) this.width  = this.value.width .copy();         if (!this.height) this.height = this.value.height.copy();         if (!this.round ) this.round  = this.value.round .copy();         if (!this.bias  ) this.bias   = this.value.bias  .copy();           this.validate();          return this;     }        async x4100(parse, options = {})     {         if (!this.options.enabled)             return;                        this.value.objects = [];           if (   super.y2897()                && this.value.x     .isValid()                 && this.value.y     .isValid()                 && this.value.width .isValid()             && this.value.height.isValid()             && this.value.round .isValid()             && this.value.bias  .isValid())         {             let   x = this.value.x     .value;             let   y = this.value.y     .value;             let   w = this.value.width .value;             let   h = this.value.height.value;             const r = Math.max(0, this.value.round.value);             let   b = this.value.bias  .value;               [x, y, w, h, , ] = validateObjectRect(x, y, w, h);               if (   w != 0                  && h != 0)             {                 const trapeze = new r1851(                     this.nodeId,                      this.nodeId,                      this.nodeName,                      x, y, w, h, r, b);                  trapeze.f4098(x, y);                 trapeze.c3730(x, y, w, h);                  this.value.objects.push(trapeze);             }         }           await super.x4100(parse);     }        isValid()     {         return super.isValid()             && this.round && this.round.isValid()             && this.bias  && this.bias .isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.round) this.round.c4088(parse);         if (this.bias ) this.bias .c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.round) this.round.t4089(parse, from, force);         if (this.bias ) this.bias .t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.round) this.round.c4087(parse);         if (this.bias ) this.bias .c4087(parse);     } }


class q1968 extends r1974 {     position = null;     round    = null;     corners  = null;        constructor(nodeId, options)     {         super(h1237, nodeId, options);     }        reset()     {         super.reset();          this.position = null;         this.round    = null;         this.corners  = null;     }        copy()     {         const copy = new q1968(this.nodeId, this.options);          copy.x3359(this);          if (this.position) copy.position = this.position.copy();         if (this.round   ) copy.round    = this.round   .copy();         if (this.corners ) copy.corners  = this.corners .copy();          return copy;     }        p4242(h2992)     {         switch (h2992)         {             case 'position': return this.input ? this.value.position : this.position;             case 'x':        return this.input ? this.value.x        : this.x;             case 'y':        return this.input ? this.value.y        : this.y;             case 'width':    return this.input ? this.value.width    : this.width;             case 'height':   return this.input ? this.value.height   : this.height;             case 'round':    return this.input ? this.value.round    : this.round;             case 'corners':  return this.input ? this.value.corners  : this.corners;         }          return super.p4242(h2992);     }        async eval(parse)     {         if (this.isCached())             return this;                       let [x, y, width, height] = await this.evalBaseParams(parse);          let input   = await evalPolygonValue(this.input,    parse);         let pos     = await evalNumberValue (this.position, parse);         let round   = await evalNumberValue (this.round,    parse);         let corners = await evalNumberValue (this.corners,  parse);           if (input)         {             this.value        = input.r3633();             this.value.nodeId = this.nodeId;             this.value.g3626(input);              if (pos    )  this.value.position = pos;      else  pos     = this.value.position;             if (x      )  this.value.x        = x;        else  x       = this.value.x;                   if (y      )  this.value.y        = y;        else  y       = this.value.y;                   if (width  )  this.value.width    = width;    else  width   = this.value.width;               if (height )  this.value.height   = height;   else  height  = this.value.height;              if (round  )  this.value.round    = round;    else  round   = this.value.round;               if (corners)  this.value.corners  = corners;  else  corners = this.value.corners;           }         else         {             this.value = new x2024(                 this.nodeId,                 pos,                 x,                  y,                  width,                  height,                 round,                 corners);         }           this.j4101(parse,          [             ['position', pos    ],             ['x',        x      ],             ['y',        y      ],             ['width',    width  ],             ['height',   height ],             ['round',    round  ],             ['corners',  corners]         ]);           await this.s2896(parse);           await this.x4100(parse);           if (!this.position) this.position = this.value.position.copy();         if (!this.x       ) this.x        = this.value.x       .copy();         if (!this.y       ) this.y        = this.value.y       .copy();         if (!this.width   ) this.width    = this.value.width   .copy();         if (!this.height  ) this.height   = this.value.height  .copy();         if (!this.round   ) this.round    = this.value.round   .copy();         if (!this.corners ) this.corners  = this.value.corners .copy();           this.validate();          return this;     }        async x4100(parse, options = {})     {         if (!this.options.enabled)             return;                                   this.value.objects = [];           if (   super.y2897()                && this.value.x      .isValid()             && this.value.y      .isValid()             && this.value.width  .isValid()             && this.value.height .isValid()             && this.value.round  .isValid()             && this.value.corners.isValid())         {             const vpos = this.value.position;             const vx   = this.value.x;             const vy   = this.value.y;             const vw   = this.value.width;             const vh   = this.value.height;              const _x = vpos.value <= 0 ? vx : new y2022(vx.value - vw.value, Math.max(vx.decimals, vw.decimals));             const _y = vpos.value <= 0 ? vy : new y2022(vy.value - vh.value, Math.max(vy.decimals, vh.decimals));             const _w = vpos.value <= 0 ? vw : new y2022(vw.value*2, Math.max(vx.decimals, vw.decimals));             const _h = vpos.value <= 0 ? vh : new y2022(vh.value*2, Math.max(vy.decimals, vh.decimals));                          let   x = _x.value;             let   y = _y.value;             let   w = _w.value;             let   h = _h.value;             const r = Math.max(0, this.value.round.value);             const c = Math.max(3, Math.floor(this.value.corners.value));               [x, y, w, h, , ] = validateObjectRect(x, y, w, h);               if (   w != 0                  && h != 0)             {                 const poly = new t1845(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     x, y, w, h, r, c);                  poly.f4098(x, y);                 poly.c3730(x, y, w, h);                  this.value.objects.push(poly);             }         }                   await super.x4100(parse);     }                                                                                              isValid()     {         return super.isValid()             && this.position && this.position.isValid()             && this.round    && this.round   .isValid()             && this.corners  && this.corners .isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.position) this.position.c4088(parse);         if (this.round   ) this.round   .c4088(parse);         if (this.corners ) this.corners .c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.position) this.position.t4089(parse, from, force);         if (this.round   ) this.round   .t4089(parse, from, force);         if (this.corners ) this.corners .t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.position) this.position.c4087(parse);         if (this.round   ) this.round   .c4087(parse);         if (this.corners ) this.corners .c4087(parse);     } }


 class j1978 extends r1974 {     position = null;     round    = null;     points   = null;     convex   = null;        constructor(nodeId, options)     {         super(j1240, nodeId, options);     }        reset()     {         super.reset();          this.position = null;         this.round    = null;         this.points   = null;         this.convex   = null;     }        copy()     {         const copy = new j1978(this.nodeId, this.options);          copy.x3359(this);          if (this.position) copy.position = this.position.copy();         if (this.round   ) copy.round    = this.round   .copy();         if (this.points  ) copy.points   = this.points  .copy();         if (this.convex  ) copy.convex   = this.convex  .copy();          return copy;     }        p4242(h2992)     {         switch (h2992)         {             case 'position': return this.input ? this.value.position : this.position;             case 'x':        return this.input ? this.value.x        : this.x;             case 'y':        return this.input ? this.value.y        : this.y;             case 'width':    return this.input ? this.value.width    : this.width;             case 'height':   return this.input ? this.value.height   : this.height;             case 'round':    return this.input ? this.value.round    : this.round;             case 'points':   return this.input ? this.value.points   : this.points;             case 'convex':   return this.input ? this.value.convex   : this.convex;         }          return super.p4242(h2992);     }        async eval(parse)     {         if (this.isCached())             return this;                       let [x, y, width, height] = await this.evalBaseParams(parse);          let input  = await evalValue      (this.input,    parse);         let pos    = await evalNumberValue(this.position, parse);         let round  = await evalNumberValue(this.round,    parse);         let points = await evalNumberValue(this.points,   parse);         let convex = await evalNumberValue(this.convex,   parse);           if (input)         {             this.value        = input.r3633();             this.value.nodeId = this.nodeId;             this.value.g3626(input);              if (pos   )  this.value.position = pos;     else  pos    = this.value.position;             if (x     )  this.value.x        = x;       else  x      = this.value.x;                   if (y     )  this.value.y        = y;       else  y      = this.value.y;                   if (width )  this.value.width    = width;   else  width  = this.value.width;               if (height)  this.value.height   = height;  else  height = this.value.height;              if (round )  this.value.round    = round;   else  round  = this.value.round;               if (points)  this.value.points   = points;  else  points = this.value.points;               if (convex)  this.value.convex   = convex;  else  convex = this.value.convex;          }         else         {             this.value = new y2030(                 this.nodeId,                 pos,                 x,                  y,                  width,                  height,                 round,                 points,                 convex);         }           this.j4101(parse,          [             ['position', pos   ],             ['x',        x     ],             ['y',        y     ],             ['width',    width ],             ['height',   height],             ['round',    round ],             ['points',   points],             ['convex',   convex]         ]);           await this.s2896(parse);           await this.x4100(parse);           if (!this.position) this.position = this.value.position.copy();         if (!this.x       ) this.x        = this.value.x       .copy();         if (!this.y       ) this.y        = this.value.y       .copy();         if (!this.width   ) this.width    = this.value.width   .copy();         if (!this.height  ) this.height   = this.value.height  .copy();         if (!this.round   ) this.round    = this.value.round   .copy();         if (!this.points  ) this.points   = this.value.points  .copy();         if (!this.convex  ) this.convex   = this.value.convex  .copy();            this.validate();          return this;    }       async x4100(parse, options = {})    {         if (!this.options.enabled)            return;                                 this.value.objects = [];           if (   super.y2897()                && this.value.x     .isValid()             && this.value.y     .isValid()             && this.value.width .isValid()             && this.value.height.isValid()              && this.value.round .isValid()             && this.value.points.isValid()             && this.value.convex.isValid())         {             const vpos = this.value.position;             const vx   = this.value.x;             const vy   = this.value.y;             const vw   = this.value.width;             const vh   = this.value.height;              const _x = vpos.value <= 0 ? vx : new y2022(vx.value - vw.value, Math.max(vx.decimals, vw.decimals));             const _y = vpos.value <= 0 ? vy : new y2022(vy.value - vh.value, Math.max(vy.decimals, vh.decimals));             const _w = vpos.value <= 0 ? vw : new y2022(vw.value*2, Math.max(vx.decimals, vw.decimals));             const _h = vpos.value <= 0 ? vh : new y2022(vh.value*2, Math.max(vy.decimals, vh.decimals));                          let   x = _x.value;             let   y = _y.value;             let   w = _w.value;             let   h = _h.value;             const r = Math.max(0, this.value.round.value);             const p = Math.max(3, Math.floor(this.value.points.value));             const c = this.value.convex.value;               if (   w != 0                 && h != 0)             {                 const star = new n1849(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     x, y, w, h, r, p, c);                  star.f4098(x, y);                 star.c3730(x, y, w, h);                  this.value.objects.push(star);             }         }                  await super.x4100(parse);     }                                                                                                    isValid()     {         return super.isValid()             && this.position && this.position.isValid()             && this.round    && this.round   .isValid()             && this.points   && this.points  .isValid()             && this.convex   && this.convex  .isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.position) this.position.c4088(parse);         if (this.round   ) this.round   .c4088(parse);         if (this.points  ) this.points  .c4088(parse);         if (this.convex  ) this.convex  .c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.position) this.position.t4089(parse, from, force);         if (this.round   ) this.round   .t4089(parse, from, force);         if (this.points  ) this.points  .t4089(parse, from, force);         if (this.convex  ) this.convex  .t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.position) this.position.c4087(parse);         if (this.round   ) this.round   .c4087(parse);         if (this.points  ) this.points  .c4087(parse);         if (this.convex  ) this.convex  .c4087(parse);     } }


class y1979 extends r1974 {     text          = null;     x             = null;     y             = null;     width         = null;     height        = null;     font          = null;     size          = null;     style         = null;     alignX        = null;     alignY        = null;     lineHeight    = null;     letterSpacing = null;                constructor(nodeId, options)     {         super(k1243, nodeId, options);     }            reset()     {         super.reset();                  this.text          = null;         this.x             = null;         this.y             = null;         this.width         = null;         this.height        = null;         this.font          = null;         this.size          = null;         this.style         = null;         this.alignX        = null;         this.alignY        = null;         this.lineHeight    = null;         this.letterSpacing = null;     }        copy()     {         const copy = new y1979(this.nodeId, this.options);          copy.x3359(this);          if (this.text         ) copy.text          = this.text         .copy();         if (this.x            ) copy.x             = this.x            .copy();         if (this.y            ) copy.y             = this.y            .copy();         if (this.width        ) copy.width         = this.width        .copy();         if (this.height       ) copy.height        = this.height       .copy();         if (this.font         ) copy.font          = this.font         .copy();         if (this.style        ) copy.style         = this.style        .copy();         if (this.size         ) copy.size          = this.size         .copy();         if (this.alignX       ) copy.alignX        = this.alignX       .copy();         if (this.alignY       ) copy.alignY        = this.alignY       .copy();         if (this.lineHeight   ) copy.lineHeight    = this.lineHeight   .copy();         if (this.letterSpacing) copy.letterSpacing = this.letterSpacing.copy();          return copy;     }        p4242(h2992)     {         switch (h2992)         {             case 'text':          return this.input ? this.value.text          : this.text;             case 'x':             return this.input ? this.value.x             : this.x;             case 'y':             return this.input ? this.value.y             : this.y;             case 'width':         return this.input ? this.value.width         : this.width;             case 'height':        return this.input ? this.value.height        : this.height;             case 'font':          return this.input ? this.value.font          : this.font;             case 'style':         return this.input ? this.value.style         : this.style;             case 'size':          return this.input ? this.value.size          : this.size;             case 'alignX':        return this.input ? this.value.alignX        : this.alignX;             case 'alignY':        return this.input ? this.value.alignY        : this.alignY;             case 'lineHeight':    return this.input ? this.value.lineHeight    : this.lineHeight;             case 'letterSpacing': return this.input ? this.value.letterSpacing : this.letterSpacing;         }          return super.p4242(h2992);     }        async eval(parse)     {         if (this.isCached())             return this;           const input         = await evalTextShapeValue(this.input,         parse);         let   text          = await evalNumberValue   (this.text,          parse);         let   x             = await evalNumberValue   (this.x,             parse);         let   y             = await evalNumberValue   (this.y,             parse);         let   width         = await evalNumberValue   (this.width,         parse);         let   height        = await evalNumberValue   (this.height,        parse);         let   font          = await evalNumberValue   (this.font,          parse);         let   style         = await evalNumberValue   (this.style,         parse);         let   size          = await evalNumberValue   (this.size,          parse);         let   alignX        = await evalNumberValue   (this.alignX,        parse);         let   alignY        = await evalNumberValue   (this.alignY,        parse);         let   lineHeight    = await evalNumberValue   (this.lineHeight,    parse);         let   letterSpacing = await evalNumberValue   (this.letterSpacing, parse);           if (text          && !text         .isValid()) text          = new c2033();         if (x             && !x            .isValid()) x             = y2022.NaN.copy();         if (y             && !y            .isValid()) y             = y2022.NaN.copy();         if (width         && !width        .isValid()) width         = y2022.NaN.copy();         if (height        && !height       .isValid()) height        = y2022.NaN.copy();         if (font          && !font         .isValid()) font          = y2022.NaN.copy();         if (style         && !style        .isValid()) style         = y2022.NaN.copy();         if (size          && !size         .isValid()) size          = y2022.NaN.copy();         if (alignX        && !alignX       .isValid()) alignX        = y2022.NaN.copy();         if (alignY        && !alignY       .isValid()) alignY        = y2022.NaN.copy();         if (lineHeight    && !lineHeight   .isValid()) lineHeight    = y2022.NaN.copy();         if (letterSpacing && !letterSpacing.isValid()) letterSpacing = y2022.NaN.copy();                    if (text          && text         .type !=   g1143) text          = new c2033();         if (x             && x            .type != c1091) x             = y2022.NaN.copy();         if (y             && y            .type != c1091) y             = y2022.NaN.copy();         if (width         && width        .type != c1091) width         = y2022.NaN.copy();         if (height        && height       .type != c1091) height        = y2022.NaN.copy();         if (font          && font         .type != c1091) font          = y2022.NaN.copy();         if (style         && style        .type != c1091) style         = y2022.NaN.copy();         if (size          && size         .type != c1091) size          = y2022.NaN.copy();         if (alignX        && alignX       .type != c1091) alignX        = y2022.NaN.copy();         if (alignY        && alignY       .type != c1091) alignY        = y2022.NaN.copy();         if (lineHeight    && lineHeight   .type != c1091) lineHeight    = y2022.NaN.copy();         if (letterSpacing && letterSpacing.type != c1091) letterSpacing = y2022.NaN.copy();                   if (input)         {             this.value        = input.r3633();             this.value.nodeId = this.nodeId;             this.value.g3626(input);                          if (text         )  this.value.text          = text;           else  text          = this.value.text;             if (x            )  this.value.x             = x;              else  x             = this.value.x;             if (y            )  this.value.y             = y;              else  y             = this.value.y;             if (width        )  this.value.width         = width;          else  width         = this.value.width;             if (height       )  this.value.height        = height;         else  height        = this.value.height;             if (font         )  this.value.font          = font;           else  font          = this.value.font;             if (style        )  this.value.style         = style;          else  style         = this.value.style;             if (size         )  this.value.size          = size;           else  size          = this.value.size;             if (alignX       )  this.value.alignX        = alignX;         else  alignX        = this.value.alignX;             if (alignY       )  this.value.alignY        = alignY;         else  alignY        = this.value.alignY;             if (lineHeight   )  this.value.lineHeight    = lineHeight;     else  lineHeight    = this.value.lineHeight;             if (letterSpacing)  this.value.letterSpacing = letterSpacing;  else  letterSpacing = this.value.letterSpacing;          }         else         {             this.value = new y2032(                 this.nodeId,                  text,                  x,                  y,                  width,                  height,                  font,                  style,                 size,                 alignX,                 alignY,                 lineHeight,                 letterSpacing);         }                  this.j4101(parse,          [             ['text',          text         ],             ['x',             x            ],             ['y',             y            ],             ['width',         width        ],             ['height',        height       ],             ['font',          font         ],             ['style',         style        ],             ['size',          size         ],             ['alignX',        alignX       ],             ['alignY',        alignY       ],             ['lineHeight',    lineHeight   ],             ['letterSpacing', letterSpacing]         ]);           await this.s2896(parse);           await this.x4100(parse);           if (!this.text         ) this.text          = this.value.text         .copy();         if (!this.x            ) this.x             = this.value.x            .copy();         if (!this.y            ) this.y             = this.value.y            .copy();         if (!this.width        ) this.width         = this.value.width        .copy();         if (!this.height       ) this.height        = this.value.height       .copy();         if (!this.font         ) this.font          = this.value.font         .copy();         if (!this.style        ) this.style         = this.value.style        .copy();         if (!this.size         ) this.size          = this.value.size         .copy();         if (!this.alignX       ) this.alignX        = this.value.alignX       .copy();         if (!this.alignY       ) this.alignY        = this.value.alignY       .copy();         if (!this.lineHeight   ) this.lineHeight    = this.value.lineHeight   .copy();         if (!this.letterSpacing) this.letterSpacing = this.value.letterSpacing.copy();                   this.validate();          return this;     }        async x4100(parse, options = {})     {         if (!this.options.enabled)             return;                   this.value.objects = [];           if (   super.y2897()                && this.value.text         .isValid()             && this.value.x            .isValid()             && this.value.y            .isValid()             && this.value.width        .isValid()             && this.value.height       .isValid()             && this.value.font         .isValid()             && this.value.style        .isValid()             && this.value.size         .isValid()             && this.value.alignX       .isValid()             && this.value.alignY       .isValid()             && this.value.lineHeight   .isValid()             && this.value.letterSpacing.isValid())         {             let x = this.value.x     .value;             let y = this.value.y     .value;             let w = this.value.width .value;             let h = this.value.height.value;              const fontName   = j4039[this.value.font.value];             const fontStyles = getFontStyles(fontName);              const text = new s1850(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 this.value.text.value,                 x, y, w, h,                 fontName,                 this.value.size         .value,                 fontStyles[Math.min(this.value.style.value, fontStyles.length-1)],                 this.value.alignX       .value,                 this.value.alignY       .value,                 this.value.lineHeight   .value,                 this.value.letterSpacing.value);                               text.f4098(x, y);                                                                                                                                                                                                text.c3730(x, y, w, h);                  this.value.objects.push(text);                      }                   await super.x4100(parse);     }        isValid()     {         return super.isValid()             && this.text          && this.text         .isValid()             && this.x             && this.x            .isValid()             && this.y             && this.y            .isValid()             && this.width         && this.width        .isValid()             && this.height        && this.height       .isValid()             && this.font          && this.font         .isValid()             && this.style         && this.style        .isValid()             && this.size          && this.size         .isValid()             && this.alignX        && this.alignX       .isValid()             && this.alignY        && this.alignY       .isValid()             && this.lineHeight    && this.lineHeight   .isValid()             && this.letterSpacing && this.letterSpacing.isValid();     }        c4088(parse)     {         super.c4088(parse);                  if (this.text         ) this.text         .c4088(parse);         if (this.x            ) this.x            .c4088(parse);         if (this.y            ) this.y            .c4088(parse);         if (this.width        ) this.width        .c4088(parse);         if (this.height       ) this.height       .c4088(parse);         if (this.font         ) this.font         .c4088(parse);         if (this.style        ) this.style        .c4088(parse);         if (this.size         ) this.size         .c4088(parse);         if (this.alignX       ) this.alignX       .c4088(parse);         if (this.alignY       ) this.alignY       .c4088(parse);         if (this.lineHeight   ) this.lineHeight   .c4088(parse);         if (this.letterSpacing) this.letterSpacing.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);                  if (this.text         ) this.text         .t4089(parse, from, force);         if (this.x            ) this.x            .t4089(parse, from, force);         if (this.y            ) this.y            .t4089(parse, from, force);         if (this.width        ) this.width        .t4089(parse, from, force);         if (this.height       ) this.height       .t4089(parse, from, force);         if (this.font         ) this.font         .t4089(parse, from, force);         if (this.style        ) this.style        .t4089(parse, from, force);         if (this.size         ) this.size         .t4089(parse, from, force);         if (this.alignX       ) this.alignX       .t4089(parse, from, force);         if (this.alignY       ) this.alignY       .t4089(parse, from, force);         if (this.lineHeight   ) this.lineHeight   .t4089(parse, from, force);         if (this.letterSpacing) this.letterSpacing.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);                  if (this.text         ) this.text         .c4087(parse);         if (this.x            ) this.x            .c4087(parse);         if (this.y            ) this.y            .c4087(parse);         if (this.width        ) this.width        .c4087(parse);         if (this.height       ) this.height       .c4087(parse);         if (this.font         ) this.font         .c4087(parse);         if (this.style        ) this.style        .c4087(parse);         if (this.size         ) this.size         .c4087(parse);         if (this.alignX       ) this.alignX       .c4087(parse);         if (this.alignY       ) this.alignY       .c4087(parse);         if (this.lineHeight   ) this.lineHeight   .c4087(parse);         if (this.letterSpacing) this.letterSpacing.c4087(parse);     } }


class g1964 extends r2044 {     x = null;     y = null;        constructor(nodeId, options)     {         super(t1246, nodeId, options);     }        reset()     {         super.reset();          this.x = null;         this.y = null;     }        copy()     {         const copy = new g1964(this.nodeId, this.options);          copy.x3359(this);          if (this.value) copy.value = this.value.copy();         if (this.x    ) copy.x     = this.x    .copy();         if (this.y    ) copy.y     = this.y    .copy();          return copy;     }        p4242(h2992)     {         switch (h2992)         {             case 'x': return this.input ? this.value.x : this.x;             case 'y': return this.input ? this.value.y : this.y;         }          return null;     }        async eval(parse)     {         if (this.isCached())             return this;                   let input = await evalPointValue (this.input, parse);         let x     = await evalNumberValue(this.x,     parse);         let y     = await evalNumberValue(this.y,     parse);           if (   input             && input.isValid())         {             const n3812 = input;              if (input.type == p1252)             {                 input = new q2023(input.nodeId, input.x, input.y);                 input.g3626(n3812);             }                          this.value        = input;             this.value.nodeId = this.nodeId;             this.value.g3626(input);               if (   this.value.objects                 && this.value.objects.length > 0)             {                 this.value.x = new y2022(this.value.objects[0].x);                 this.value.y = new y2022(this.value.objects[0].y);             }                          if (x)  this.value.x = x;  else  x = this.value.x;             if (y)  this.value.y = y;  else  y = this.value.y;         }         else if (x                && y)         {             this.value = new q2023(                 this.nodeId,                  x,                  y);         }         else             this.value = q2023.NaN.copy();           this.value.w3736 = this.w3736;           await this.x4100(parse);           this.j4101(parse,          [             ['x', x],             ['y', y]         ]);               this.validate();          return this;     }        async x4100(parse, options = {})     {         if (!this.options.enabled)             return;                                   if (!this.value.objects)             this.value.objects = [];           if (   this.value.x             && this.value.y                && this.value.x.isValid()             && this.value.y.isValid())         {             const x = this.value.x.value;             const y = this.value.y.value;              const point = new w1844(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 x,                 y,                 this.smooth ? this.smooth.value/100 : 1);              point.f4098(x, y);              this.value.objects = [point];         }           await super.x4100(parse);     }        isValid()     {         return super.isValid()             && this.x && this.x.isValid()             && this.y && this.y.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.x) this.x.c4088(parse);         if (this.y) this.y.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.x) this.x.t4089(parse, from, force);         if (this.y) this.y.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.x) this.x.c4087(parse);         if (this.y) this.y.c4087(parse);     } }


class d1965 extends r2044 {     smooth = null;        constructor(nodeId, options)     {         super(t1248, nodeId, options);     }        reset()     {         super.reset();          this.smooth = null;     }        copy()     {         const copy = new d1965(this.nodeId, this.options);          copy.x3359(this);          if (this.value ) copy.value  = this.value .copy();         if (this.smooth) copy.smooth = this.smooth.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                   const input  = await evalPointValue (this.input,  parse);         const smooth = await evalNumberValue(this.smooth, parse);                  if (input)         {             this.value        = input;             this.value.nodeId = this.nodeId;             this.value.g3626(input);              this.value.smooth = smooth;               if (   this.value.objects                 && this.value.objects.length > 0)             {                 this.value.x = new y2022(this.value.objects[0].x);                 this.value.y = new y2022(this.value.objects[0].y);             }         }         else             this.value = q2023.NaN.copy();           await this.x4100(parse);           this.j4101(parse,          [             ['smooth', smooth]         ]);           this.validate();          return this;     }        async x4100(parse, options = {})     {         if (!this.options.enabled)             return;                                   this.value.objects = [];           if (   this.value.x.isValid()             && this.value.y.isValid())         {             const x      = this.value.x.value;             const y      = this.value.y.value;             const smooth = this.value.smooth ? this.value.smooth.value/100 : 1;              const point = new w1844(                 this.nodeId,                  this.nodeId,                  this.nodeName,                  x,                  y,                  smooth);              point.f4098(x, y);              this.value.objects = [point];         }           await super.x4100(parse);     }        r3633()     {         return this.value.copy();                                                    }        isValid()     {         return super.isValid()             && this.smooth && this.smooth.isValid();     }        c4088(parse)     {         super.c4088(parse);          if (this.smooth) this.smooth.c4088(parse);     }        t4089(parse, from, force)     {         super.t4089(parse, from, force);          if (this.smooth) this.smooth.t4089(parse, from, force);     }        c4087(parse)     {         super.c4087(parse);          if (this.smooth) this.smooth.c4087(parse);     } }


class b1984 extends r1974 {     points  = null;     closed  = null;     degree  = null;     winding = null;     round   = null;        constructor(nodeId, options)     {         super(g1250, nodeId, options);     }        reset()     {         super.reset();          this.points  = null;         this.closed  = null;         this.degree  = null;         this.winding = null;         this.round   = null;     }        copy()     {         const copy = new b1984(this.nodeId, this.options);          copy.x3359(this);          if (this.points ) copy.points  = this.points .copy();         if (this.closed ) copy.closed  = this.closed .copy();         if (this.degree ) copy.degree  = this.degree .copy();         if (this.winding) copy.winding = this.winding.copy();         if (this.round  ) copy.round   = this.round  .copy();          return copy;     }        p4242(h2992)     {         switch (h2992)         {             case 'points':  return this.input ? this.value.points  : this.points;             case 'closed':  return this.input ? this.value.closed  : this.closed;             case 'degree':  return this.input ? this.value.degree  : this.degree;             case 'winding': return this.input ? this.value.winding : this.winding;             case 'round':   return this.input ? this.value.round   : this.round;         }          return super.p4242(h2992);     }        async eval(parse)     {         if (this.isCached())             return this;           const input   = await evalVectorPathValue(this.input,   parse);         let   points  = await evalNumberValue    (this.points,  parse);         let   closed  = await evalNumberValue    (this.closed,  parse);         let   degree  = await evalNumberValue    (this.degree,  parse);         let   winding = await evalNumberValue    (this.winding, parse);         let   round   = await evalNumberValue    (this.round,   parse);           await this.evalBaseParams(parse);           if (input)         {                                                    if (   input.points                 && input.points.items                 && input.points.objects)             {                 x952(                      input.points.items.length == input.points.objects.length,                     'Vector path points input item count must match object count');                  for (let i = 0; i < input.points.items.length; i++)                 {                     const item = input.points.items  [i].copy();                     const v111  = input.points.objects[i].copy();                      if (item && v111)                     {                         item.x = new y2022(v111.x);                         item.y = new y2022(v111.y);                     }                 }             }               this.value = new g2037(                 this.nodeId,                    points                  && points.items.length > 0                  ? points                 : input.points,                 closed  ?? input.closed,                 degree  ?? input.degree,                 winding ?? input.winding,                 round   ?? input.round);              this.value.g3626(input);                           if (points )  this.value.points   = points;   else  points  = this.value.points;                 if (closed )  this.value.closed   = closed;   else  closed  = this.value.closed;                 if (degree )  this.value.degree   = degree;   else  degree  = this.value.degree;               if (winding)  this.value.windingt = winding;  else  winding = this.value.winding;              if (round  )  this.value.round    = round;    else  round   = this.value.round;           }         else         {             this.value = new g2037(                 this.nodeId,          