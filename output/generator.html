<script id='generatorScript' type='javascript/worker'>
'use strict';




const generatorVersion = 293;


const MAX_INT32        = 2147483647;
  
const NULL             = '';
  
const HTAB             = '  '; // half-tab
const TAB              = '    ';
const NL               = '\n';
  
const GENERATOR_LOGO   = '◦ G •';
const OBJECT_PREFIX    = GENERATOR_LOGO + ' ';

const nodeTag          = 'G_NODE';
const connTag          = 'G_CONN';
const pageTag          = 'G_PAGE';
const tempTag          = 'G_TEMP';



const identity = Object.freeze(
    [[1, 0, 0],
     [0, 1, 0],
     [0, 0, 1]]);



const Epsilon = 0.0000001;
const Tau     = Math.PI * 2;



var enableAsserts = false;



function hardZero(x, eps = 0.000000001) 
{ 
    return Math.abs(x) < eps ? 0 : x;
}



function nozero(x, eps = 0.000000001) 
{ 
    return x != 0 
         ? x 
         : (x < 0 ? -eps : eps);
}



function nozerov(v, eps = 0.000000001) 
{ 
    return point(
        nozero(v.x, eps), 
        nozero(v.y, eps)); 
}



function equal(a, b, eps = 0.000000001)
{
    return Math.abs(b - a) < eps;
}



function sqr (x) { return x*x;   };
function cube(x) { return x*x*x; };
 

function toInt(f) { return Math.floor(f) | 0; }



function nextPow2(x)
{
    x = toInt(x);

    x--;

    x |= x >>  1;
    x |= x >>  2;
    x |= x >>  4;
    x |= x >>  8;
    x |= x >> 16;
    x |= x >> 32;

    return ++x;
}



function gcd(a, b)
{
    let temp;
    while (1)
    {
        temp = a % b;

        if (temp == 0)
          return b;

        a = b;
        b = temp;
    }
}



function distance(p1, p2)
{
    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;

    return Math.sqrt(dx*dx + dy*dy);
}



function angle(v)
{
    let angle = Math.atan2(v.y, v.x);
    if (angle < 0) angle += Tau;

    return angle;
}



function anglev(v1, v2)
{
    return anglev_(v1.x, v1.y, v2.x, v2.y);
}



function anglev_(x1, y1, x2, y2)
{
    const dx = x2 - x1;
    const dy = y2 - y1;

    let angle = Math.atan2(dy, dx);
    if (angle < 0) angle += Tau;

    return angle;
}



function lengthv(v)
{
    return Math.sqrt(v.x*v.x + v.y*v.y);
}



function unitv(v)
{
    return point(
        v.x == 0 ? 0 : v.x / lengthv(v),
        v.y == 0 ? 0 : v.y / lengthv(v));
}



function dot(v1, v2)
{
    return v1.x * v2.x + v1.y * v2.y;
}



function angleDiff(a1, a2)
{
    let diff = a2 - a1;

    while (diff <= -Tau/2) diff += Tau;
    while (diff >   Tau/2) diff -= Tau;

    return diff; // |-Tau/2, Tau/2]
}



function mulv2m3(v, m)
{
    let v3 = [v.x, v.y, 1];
    let r  = mulv3m3(v3, m);

    return point(r[0], r[1]);
}



function mulm3m3(...mm)
{
    consoleAssert(mm.length > 0, 'mulm3m3() must take at least one argument');

    let result = clone(mm[0]);

    for (let a = 1; a < mm.length; a++)
    {
        const m1 = result;
        const m2 = mm[a];

        const m = [[0, 0, 0],
                   [0, 0, 0],
                   [0, 0, 0]];

        for (let i = 0; i < 3; i++)
        {
            for (let j = 0; j < 3; j++)
            {
                /*	calculate the dot product of ith row 
                    of this and jth column of m  */
                for (let k = 0; k < 3; k++)
                    m[i][j] += m1[i][k] * m2[k][j];
            }
        }

        result = m;
    }

    return result;
}



function divm3s(m, s)
{
    for (let i = 0; i < 3; i++)
        for (let j = 0; j < 3; j++)
            m[i][j] /= s;

    return m;
}



function adjugate(m)
{
    return cofactor(transpose(m));
}



function transpose(m)
{
    return [[m[0][0], m[1][0], m[2][0]],
            [m[0][1], m[1][1], m[2][1]],
            [m[0][2], m[1][2], m[2][2]]];
}



function cofactor(m)
{
    return [[  m[1][1] * m[2][2] - m[2][1] * m[1][2], -(m[1][0] * m[2][2] - m[2][0] * m[1][2]),  m[1][0] * m[2][1] - m[2][0] * m[1][1] ],
            [-(m[0][1] * m[2][2] - m[2][1] * m[0][2]),  m[0][0] * m[2][2] - m[2][0] * m[0][2], -(m[0][0] * m[2][1] - m[2][0] * m[0][1])],
            [  m[0][1] * m[1][2] - m[1][1] * m[0][2], -(m[0][0] * m[1][2] - m[1][0] * m[0][2]),  m[0][0] * m[1][1] - m[1][0] * m[0][1] ]]; 
}



function determinant(m)
{
    return   m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1])
           - m[0][1] * (m[1][0] * m[2][2] - m[2][0] * m[1][2])
           + m[0][2] * (m[1][0] * m[2][1] - m[2][0] * m[1][1]);
}



function inversem3(m)
{
    return divm3s(adjugate(m), determinant(m));
}



function createRotateTransform(angle)
{
    const cosA = hardZero(Math.cos(angle));
    const sinA = hardZero(Math.sin(angle));

    return [[ cosA, sinA, 0],
            [-sinA, cosA, 0],
            [ 0,    0,    1]];
}



function createTransform(x = 0, y = 0, scaleX = 1, scaleY = 1, angle = 0, skewX = 0, skewY = 0)
{
    const cosA = Math.cos(angle);
    const sinA = Math.sin(angle);

    return [[scaleX*cosA -  skewY*sinA, -skewX*cosA + scaleY*sinA, x],
            [ skewY*cosA + scaleX*sinA, scaleY*cosA +  skewX*sinA, y],
            [0,                         0,                         1]];
}



function crossv2(v1, v2)
{
    // returns the magnitude of v1×v2 = ‖v1‖‖v2‖sinθ "perpendicular dot product",
    // equivalent to dot(v1, cross(v2)) (same as in 3D with a Z component of 0)
    // also the area of the parallelogram between the two vectors
    // also determinant of 2×2 matrix built from the two vectors
    // positive if turn from v1 to v2 is clockwise

    return v1.x * v2.y - v1.y * v2.x;
}	



function addv(v1, v2)
{
    return point(
        v1.x + v2.x,
        v1.y + v2.y);
}	



function mulv(v1, v2)
{
    return point(
        v1.x * v2.x,
        v1.y * v2.y);
}	



function mulvs(v, s)
{
    return point(
        v.x * s,
        v.y * s);
}	



function divv(v1, v2)
{
    return point(
        v1.x / v2.x,
        v1.y / v2.y);
}	



function divvs(v, s)
{
    return point(
        v.x / s,
        v.y / s);
}	



function subv(v1, v2)
{
    return point(
        v1.x - v2.x,
        v1.y - v2.y);
}	



function toUtf8(str) 
{
    return decodeURI(encodeURIComponent(str));
}



function fromUtf8(str) 
{
    return decodeURIComponent(encodeURI(str));
}



function charCodeArrayToString(bytes) 
{
    let str = '';

    for (let i = 0; i < bytes.length; i++)
        str += String.fromCharCode(bytes[i]);

    return str;
}



function stringToCharCodeArray(str)
{
    return Array.from(fromUtf8(str), c => c.charCodeAt(0));
}



function newSizeArrayFrom(array, size) // resizes an array and returns a new array
{
    const newArray = new Uint8Array(size);
    copyArray(array, newArray);
    return newArray;
}



function copyArray(src, dst)
{
    copyArrayAt(
        src, 0, src.length,
        dst, 0, dst.length);
}



function copyArrayAt(src, srcStart, srcSize, dst, dstStart, dstSize)
{
    const size = Math.min(srcSize, dstSize);

    for (let i = 0; i < size; i++)
        dst[dstStart + i] = src[srcStart + i];
}



function arraysAreEqual(arr1, arr2)
{
    if (arr1.length != arr2.length)
        return false;

    for (let i = 0; i < arr1.length; i++)
    {
        if (arr1[i] != arr2[i])
            return false;
    }

    return true;
}



function arraysIntersect(array1, array2)
{
    return array1.findIndex(i => array2.includes(i)) > -1;
}



function  leftArrowChar(list) { return list ? '<==' : '<--'; }; 
function rightArrowChar(list) { return list ? '==>' : '-->'; }; 

function nodeNameForStorage(nodeId) { return nodeTag + ' ' + nodeId; }
function connNameForStorage(name)   { return connTag + ' ' + name;   }
function pageNameForStorage(name)   { return pageTag + ' ' + name;   }



function parseBool(str) 
{ 
    return str.toLowerCase() == 'true'
        || str == '1';
}



function connToString(_conn, logSpace = false)
{
    return getConnectionString(
        _conn.outputNodeId,
        _conn.outputId,
        _conn.outputOrder,
        _conn.inputNodeId,
        _conn.inputId,
        _conn.list,
        logSpace);
}



function getConnectionKey(outputNodeId, outputId, outputOrder, inputNodeId, inputId)
{
    return connNameForStorage(
          outputNodeId + ' '
        + outputId     + ' '
        + outputOrder  + ' '
        + inputNodeId  + ' '
        + inputId);
}



function getStorageConnKey(conn)
{
    return getConnectionKey(
        conn.outputNodeId,
        conn.outputId,
        conn.outputOrder,
        conn.inputNodeId,
        conn.inputId);
}



function getConnKey(conn)
{
    return getConnectionKey(
        conn.output.node.id,
        conn.output.id,
        conn.outputOrder,
        conn.input.node.id,
        conn.input.id);
}



function getConnString(conn, logSpace = false)
{
    return getConnectionString(
        conn.output.node.id,
        conn.output.id,
        conn.outputOrder,
        conn.input.node.id,
        conn.input.id,
        conn.list,
        logSpace);
}



function getConnectionString(outputNodeId, outputId, outputOrder, inputNodeId, inputId, list, logSpace = false)
{
    const  sp   = logSpace ? ' ' : '  '; 
    const jsp   = logSpace ? ''  : ' '; 

    const arrow = 
          sp 
        + subscriptNumber(typeof outputOrder == 'string' ? parseInt(outputOrder) : outputOrder) 
        + rightArrowChar(typeof list == 'string' ? parseBool(list) : list) 
        + sp;

    const join  = jsp + '.' + jsp;

    return '( '
         + outputNodeId + join + outputId
         + arrow
         + inputNodeId  + join + inputId
         + ' )';
}



function getPageKey(pageId)
{
    return pageNameForStorage(pageId);
}



function superscriptNumber(num)
{
    const str = num.toString();

    let sup = '';

    for (const c of str)
        sup += superscriptChar(c);

    return sup;
}



function superscriptChar(c)
{
    switch (c)
    {
        case '0': return '⁰';
        case '1': return '¹';
        case '2': return '²';
        case '3': return '³';
        case '4': return '⁴';
        case '5': return '⁵';
        case '6': return '⁶';
        case '7': return '⁷';
        case '8': return '⁸';
        case '9': return '⁹';
        case '.': return '·';
    }
}



function subscriptNumber(num)
{
    const str = num.toString();

    let sup = '';

    for (const c of str)
        sup += subscriptChar(c);

    return sup;
}



function subscriptChar(c)
{
    switch (c)
    {
        case '0': return '₀';
        case '1': return '₁';
        case '2': return '₂';
        case '3': return '₃';
        case '4': return '₄';
        case '5': return '₅';
        case '6': return '₆';
        case '7': return '₇';
        case '8': return '₈';
        case '9': return '₉';
        case '.': return ' ';
    }
}



function boolToString(bool)
{
    return bool ? 'true' : 'false';
}



function isValid(val)
{
    return val != undefined
        && val != null;
}



function isEmpty(array)
{
    return array.length == 0;
}



function removeFrom(array, item)
{
    removeAt(array, array.indexOf(item));
}



function removeAt(array, index)
{
    if (   index > -1 
        && index < array.length)
        array.splice(index, 1)
}



function removeLast(array)
{
    if (isEmpty(array))
        return null;

    let last = array.at(-1);
    array.splice(array.length-1, 1)

    return last;
}



function lastOf(array)
{
    return array[array.length-1];
}



function moveInArray(array, from, to) 
{
    const item = array[from];
    array.splice(from, 1);
    array.splice(to, 0, item);
}



function removeFromArray(array, item)
{
    const index = array.indexOf(item);
    
    if (index > -1)
        array.splice(index, 1);
}



function removeArrayFromArray(fromArray, array)
{
    for (const item of array)
    {
        const index = fromArray.indexOf(item);
        
        if (index > -1)
            fromArray.splice(index, 1);
    }
}



function removeFromArrayWhere(array, where)
{
    const index = array.findIndex(where);
    
    if (index > -1)
        array.splice(index, 1);
}



function cleanStyleId(styleId)
{
    return styleId.split(',')[0] + ',';
}



function getLinearPathData(points)
{
    let pathData = '';


    if (points.length < 2)
        return pathData;


    pathData += 'M';
    pathData += ' ' + hardZero(points[0].x);
    pathData += ' ' + hardZero(points[0].y);

    for (let i = 1; i < points.length; i++)
    {
        pathData += 
              ' L'
            + ' ' + hardZero(points[i].x)
            + ' ' + hardZero(points[i].y);
    }


    return pathData;
}



function point(x, y) { return {x: x, y: y}; }



function mulv3m3(v, m)
{
    let r = [0, 0, 0];

    for (let i = 0; i < 3; i++)
        for (let j = 0; j < 3; j++)
            r[i] += v[j] * m[i][j];

    return r;
}



function clone(val) 
{
    const type = typeof val;
    
    if (val === null) 
      return null;

    else if (type === 'undefined' 
          || type === 'number' 
          || type === 'string' 
          || type === 'boolean') 
        return val;

    else if (type === 'object') 
    {
        if (val instanceof Array) 
            return val.map(x => clone(x));

        else if (val instanceof Uint8Array) 
            return new Uint8Array(val);

        else 
        {
            let obj = {};

            for (const key in val) 
                obj[key] = clone(val[key]);

            return obj;
        }
    }

    throw 'unknown';
}



function pushUnique(array, item)
{
    if (Array.isArray(item))
        item.forEach(i => pushUnique(array, i));
    else if (!array.includes(item))
        array.push(item);
}



function pushUniqueBy(array, item, equal)
{
    if (Array.isArray(item))
        item.forEach(i => pushUniqueBy(array, i, equal));
    else if (!array.find(equal))
        array.push(item);
}



function pushUniqueExcept(array, item, except)
{
    if (Array.isArray(item))
        item.forEach(i => pushUniqueExcept(array, i, except));
    else if (!array.find(except))
        array.push(item);
}



function consoleAssert(...args)
{
    // if (  !settings 
    //     || settings.enableAsserts)
    if (enableAsserts)
        console.assert(...args);
}



function consoleError(...args)
{
    // if (  !settings
    //     || settings.enableAsserts)
    if (enableAsserts)
        console.error(...args);
}



function trimCharFromStart(str, trim) 
{
    while (str.length >= trim.length
        && str.substring(0, trim.length) == trim) 
        str = str.substring(trim.length);

    return str;
}



function trimCharFromEnd(str, trim) 
{
    while (str.length >= trim.length
        && str.substring(str.length - trim.length) == trim) 
        str = str.substring(0, str.length - trim.length);

    return str;
}



function getObjectFills(genObjFills)
{
    const fills = [];


    for (const fill of genObjFills)
    {
        switch (fill[0])
        {
            case 'SOLID':
            {
                const color = {
                    r: Math.min(Math.max(0, fill[1] / 0xff), 1), 
                    g: Math.min(Math.max(0, fill[2] / 0xff), 1), 
                    b: Math.min(Math.max(0, fill[3] / 0xff), 1) };

                const opacity = Math.min(Math.max(0, fill[4] / 100), 1);


                if (   !isNaN(color.r)
                    && !isNaN(color.g)
                    && !isNaN(color.b)
                    && !isNaN(opacity))
                    fills.push(
                    {
                        type:      fill[0], 
                        color:     color,
                        opacity:   opacity,
                        blendMode: fill[5]
                    });


                break;
            }

            case 'GRADIENT_LINEAR':
            case 'GRADIENT_RADIAL':
            case 'GRADIENT_ANGULAR':
            case 'GRADIENT_DIAMOND':
            {
                const xform = fill[1];


                const stops = [];

                for (const stop of fill[2])
                {
                    stops.push({
                        color: 
                        {
                            r: Math.min(Math.max(0, stop[0]), 1),
                            g: Math.min(Math.max(0, stop[1]), 1),
                            b: Math.min(Math.max(0, stop[2]), 1),
                            a: Math.min(Math.max(0, stop[3]), 1)
                        },
                        position: stop[4]
                    })    
                }


                fills.push(
                {
                    type:              fill[0],
                    gradientTransform: xform,
                    gradientStops:     stops,
                    blendMode:         fill[3]
                });


                break;
            }
        }
    }


    return fills;
}



function isListType(type)
{
    return LIST_VALUES.includes(type);
}


function rgbFromType(type, active)
{
    return rgbFromTypeMode(type, active, darkMode);
}



function rgbFromTypeMode(type, active, mode)
{
    if (NUMBER_TYPES.includes(type))
        return active 
            ? (mode ? rgbActiveNumberDark : rgbActiveNumberLight)
            : (mode ? rgbNumberDark       : rgbNumberLight      );

    else if (TEXT_TYPES.includes(type))
        return active 
            ? (mode ? rgbActiveTextDark   : rgbActiveTextLight)
            : (mode ? rgbTextDark         : rgbTextLight      );

    else if (SHAPE_TYPES.includes(type)
         || EFFECT_TYPES.includes(type))
        return active 
            ? (mode ? rgbActiveShapeDark  : rgbActiveShapeLight)
            : (mode ? rgbShapeDark        : rgbShapeLight      );

    else if (GROUP_TYPES.includes(type))
        return active 
            ? (mode ? rgbActiveGroupDark  : rgbActiveGroupLight)
            : (mode ? rgbGroupDark        : rgbGroupLight      );

    else if (FLOW_TYPES.includes(type)
          || type == ANY_VALUE)
        return active 
            ? (mode ? rgbActiveFlowDark   : rgbActiveFlowLight)
            : (mode ? rgbFlowDark         : rgbFlowLight      );

    else if (type == COLOR_STYLE)
        return active 
            ? (mode ? rgbActiveFlowDark   : rgbActiveFlowLight)
            : (mode ? rgbFlowDark         : rgbFlowLight      );


    switch (type)
    {
        case COLOR_VALUE:      
        case FILL_VALUE:
        case STROKE_VALUE:
        case COLOR_STOP_VALUE:
        case GRADIENT_VALUE:

        case COLOR:           
        case COLOR_INTERPOLATE:
        case CORRECT_COLOR:
        case COLOR_CONTRAST:
        case COLORBLIND:
        case COLOR_BLEND:

        case COLOR_STOP:
        case GRADIENT:

            return mode 
                 ? rgbFlowDark         
                 : rgbFlowLight;

            // return active 
            //     ? (mode ? rgbActiveFlowDark   : rgbActiveFlowLight)
            //     : (mode ? rgbFlowDark         : rgbFlowLight      );
    }

    
    // return [0xff, 0, 0xff];
    return mode 
         ? rgbFlowDark         
         : rgbFlowLight;
}



function isDataColorNaN(color)
{
    return isNaN(color[1])
        || isNaN(color[2])
        || isNaN(color[3]);
}


function noNaN(x, replace)
{
    return !isNaN(x) ? x : replace;
}



function isSimpleLatinLetter(c)
{
    return c >= 'a' && c <= 'z'
        || c >= 'A' && c <= 'Z';
}


function getDigitCount(i)
{
    let l = Math.floor(Math.log10(Math.abs(i))); // the minus sign doesn't count as a digit;
    return l + 1;
}



function getDecimalFactor(dec)
{
    return Math.pow(10, -dec);
}



function isDigit(c)
{
    return c >= '0' 
        && c <= '9';
}



function isHexDigit(c)
{
    return c.length == 1
        && (   c >= 'A' && c <= 'F'
            || c >= 'a' && c <= 'f');
}



function decDigits(num) 
{
    if (typeof num !== 'number')
        consoleError('Input must be a number');
    
    const strNum = num.toFixed(10);
    const iDec   = strNum.indexOf('.');
    
    if (iDec === -1)
        return 0;
    
    let count        = strNum.length - iDec - 1;
    let nonZeroFound = false;
    
    for (let i = strNum.length-1; i > iDec; i--)
    {
        if (strNum[i] === '0')
            count--;
        else
            break;
    }
    
    return count;
}



function isArrowKey(code)
{
    return code == 'ArrowLeft'
        || code == 'ArrowRight'
        || code == 'ArrowUp'
        || code == 'ArrowDown';
}



function numToString(num, dec, showHex = false)
{
    if (showHex)
    {
        const _num = Number(num);
        let str = Math.round(Math.abs(_num)).toString(16);

        if (str.length % 2 > 0) str = '0' + str;
        if (_num < 0)           str = '-' + str;

        return str;
    }

    
    const _dec = Math.abs(dec);
    let    str = Number(num).toFixed(_dec).toString(showHex ? 16 : 10);
    

    let i = 0;

    // find decimal place

    while (i < str.length 
        && str[i] !== '.' 
        && str[i] !== ',')
        i++;

    if (i >= str.length) // if no decimal place
        return str;

        
    i = str.length-1;

    if (dec < 0)
    {
        while (i >= 0 && str[i] === '0')
            str = str.substring(0, i--);
        
         if (   str[i] === '.' 
             || str[i] === ',') // hack because JavaScript has shit support for locales
            str = str.substring(0, i--);
    }    

    return str;
}



// function numToString(num, dec)
// {
//     lst str = Number(num).toFixed(dec).toString();

//     let i = 0;

//     // find decimal place

//     while (   i < str.length 
//            && str[i] !== '.' 
//            && str[i] !== ',')
//         i++;

//     if (i >= str.length) // if no decimal place
//         return str;

//     i = str.length-1;

//     while (i >= 0 && str[i] === '0')
//         str = str.substring(0, i--);

//     if (str[i] === '.' || str[i] === ',') // hack because JavaScript has shit support for locales
//         str = str.substring(0, i--);

//     return str;
// }



function capitalize(str)
{
    let cap = "";

    if (str.length > 0)
        cap += str[0].toUpperCase();

    if (str.length > 1)
        cap += str.substring(1).toLowerCase();

    return cap;
}



function getQueryVariable(strVar)
{
    const query = window.location.search.substring(1);
    const vars  = query.split('&');

    for (let i = 0; i < vars.length; i++) 
    {
        let pair = vars[i].split('=');

        if (pair[0] == strVar)
            return pair[1];
    }

    return false;
}


const phi = (Math.sqrt(5) - 1) / 2; // 0.618
const Phi = (Math.sqrt(5) + 1) / 2; // 1.618



function floorTo(x, dec)
{
    const div = Math.round(Math.pow(10, dec));
    return Math.floor((x + Number.EPSILON) * div) / div;    
}



function roundTo(x, dec)
{
    const div = Math.round(Math.pow(10, dec));
    return Math.round((x + Number.EPSILON) * div) / div;    
}



function ceilTo(x, dec)
{
    const div = Math.ceil(Math.pow(10, dec));
    return Math.ceil((x + Number.EPSILON) * div) / div;    
}



function distance_(x1, y1, x2, y2)
{
    const dx = x2 - x1;
    const dy = y2 - y1;

    return Math.sqrt(dx*dx + dy*dy);
}



function vector(angle, dist)
{
    return point( 
        dist * Math.cos(angle), 
        dist * Math.sin(angle));
}



function equalv(v1, v2)
{
    return v1.x == v2.x
        && v1.y == v2.y;
}



function saltv(v, salt = 0.0000000001)
{
    return addv(v, point(
        -salt + Math.random() * salt*2, 
        -salt + Math.random() * salt*2));
}



function negv(v)
{
    return point(-v.x, -v.y);
}



function crossv(v)
{
    // returns a cross product of v and the unit vector pointing up the Z axis

    return point(v.y, -v.x);
}



function angle(v)
{
    let angle = Math.atan2(v.y, v.x);
    if (angle < 0) angle += Tau;

    return angle;
}



function angle_(x, y)
{
    let angle = Math.atan2(y, x);
    if (angle < 0) angle += Tau;

    return angle;
}



function clipEdge(p, q, t0, t1)
{
    if (p == 0 && q < 0)
    {
        return null;
    }
    else if (p < 0)
    {
        let r = q/p;

             if (r > t1) return null;
        else if (r > t0) t0 = r;
    }
    else if (p > 0)
    {
        let r = q/p;

             if (r < t0) return null;
        else if (r < t1) t1 = r;
    }

    return [t0, t1];
}



function clipLine(x1, y1, x2, y2, left, top, right, bottom)
{
    let t0 = 0;
    let t1 = 1;

    let dx = x2 - x1;
    let dy = y2 - y1;

    let cl = clipEdge(-dx, -(left - x1), t0, t1); if (cl != null) { t0 = cl[0]; t1 = cl[1]; } else return null;
    let cr = clipEdge( dx, right - x1,   t0, t1); if (cr != null) { t0 = cr[0]; t1 = cr[1]; } else return null;
    let ct = clipEdge(-dy, -(top - y1),  t0, t1); if (ct != null) { t0 = ct[0]; t1 = ct[1]; } else return null;
    let cb = clipEdge( dy, bottom - y1,  t0, t1); if (cb != null) { t0 = cb[0]; t1 = cb[1]; } else return null;

    if (t1 < 1)
    {
        x2 = x1 + t1*dx;
        y2 = y1 + t1*dy;
    }

    if (t0 > 0)
    {
        x1 = x1 + t0*dx;
        y1 = y1 + t0*dy;
    }

    return [
        point(x1, y1), 
        point(x2, y2) ];
}



function intersect(p1, p2, q1, q2, segment)
{
    if (   equalv(p1, p2) 
        || equalv(q1, q2)) 
        return point_NaN; // undefined line

    let v1 = subv(p2, p1);
    let v2 = subv(q2, q1);

    if (crossv2(v1, v2) == 0) 
        return point_NaN; // parallel lines

    let t1 = crossv2(subv(q1, p1), v2) / crossv2(v1, v2);
    let t2 = crossv2(subv(q1, p1), v1) / crossv2(v1, v2);

    if ((  0 <= t1 && t1 <= 1
        && 0 <= t2 && t2 <= 1)
        || !segment)
        return addv(p1, mulvs(v1, t1));
        
    return point_NaN;
}



function closestPointOnLine(l0, l1, p, segment)
{
    if (equalv(p, l0))
        return l0;
        
    let d = mulvs(
        unitv(crossv(subv(l1, l0))), // perpendicular unit vector from p towards the line
        distance(p, l0));            // the distance to any of the two points guarantees intersection with the line

    return intersect(l0, l1, p, subv(p, d), segment);
}



function signedPosOnLine(p0, p1, p)
{
    let cp = closestPointOnLine(p0, p1, p, false);

    let xform = mulm3m3(
        xmove(negv(p0)),
        xrotate(-anglev(p0, p1)));
        
    p0 = transform(p0, xform);
    p1 = transform(p1, xform);
    cp = transform(cp, xform);

    return (cp.x - p0.x) / nozero(p1.x - p0.x);
}



function transform(p, xform)
{
    return mulv2m3(p, xform);
}



function xmove(v)
{
    return [[1, 0, v.x],
            [0, 1, v.y],
            [0, 0, 1  ]];
}



function xrotate(angle)
{
    return [[ Math.cos(angle), Math.sin(angle), 0],
            [-Math.sin(angle), Math.cos(angle), 0],
            [ 0,               0,               1]];
}



// function ipow(n, e)
// {
//     let res = 1;

//     for (;;)
//     {
//         if (e & 1 != 0)
//             res *= n;

//         e >>= 1;

//         if (e == 0)
//             break;

//         n *= n;
//     }

//     return res;
// }



const MaxDigits = 100000;
 
function multRes(x, res, resSize)
{
    let carry = 0n;
    
    // multiply individual digits of res[] by n
    for (let i = 0; i < resSize; i++) 
    {
        const prod = res[i] * x + carry;
    
        res[i] = prod % 10n; // store last digit of prod in res[]
        carry  = prod / 10n; // put rest in carry
    }
    
    // put carry in res and
    // increase result size
    while (carry)
    {
        res[resSize] = carry % 10n;
        carry        = carry / 10n;
        resSize++;
    }

    return resSize;
}



function randomPrime(max = Number.MAX_SAFE_INTEGER/2)
{
    const num = Math.floor(Math.random() * max);
    return nextPrime(num);
}



function nextPrime(x) 
{
    while (!isPrime(++x));
    return x;
}



function isPrime(n, k = millerRabinIterations) // Miller-Rabin
{
    if (n <= 1) return false; 
    if (n <= 3) return true; // prime
    
    if (n % 2 == 0) 
        return false; // composite
    
    
    let d = n - 1;     // find d      
    while (d % 2 == 0) // so that x = 2^d * r + 1 
        d /= 2;        // for r >= 1
    
    
    for (let i = 0; i < k; i++)    
        if (!millerTest(d, n))
            return false; // composite
    
    
    return true; // maybe prime        
}    



function millerTest(d, n)
{
    return bigMillerTest(
        BigInt(d),
        BigInt(n));
}        



function uintFromBuffer(buffer, size)
{
    return uintFromBufferAt(buffer, 0, size);
}



function uintFromBufferAt(buffer, start, size)
{
    let val = 0;
    let mul = 1;

    for (let i = start+size-1; i >= start; i--) // little-endian
    {
        val += mul * buffer[i];
        mul <<= 8;
    }

    return val;
}



function uintToBuffer(val, buffer, bufferSize)
{
    uintToBufferAt(val, buffer, 0, bufferSize);
}



function uintToBufferAt(val, buffer, start, bufferSize)
{
    let size = Math.ceil(bigBitCount(val) / 8);
    
    size = Math.min(size, buffer.length - start);

    start += bufferSize - size;

    for (let i = start+size-1; i >= start; i--) // little-endian
    {
        buffer[i] = val & 0xFF; 
        val >>= 8;
    }
}



function lerp(a, b, t)
{
    return a + (b - a) * t;
}



function lerp2(f0, f1, f2, t)
{
    const c0 = lerp(f0, f1, t);
    const c1 = lerp(f1, f2, t);

    return lerp(c0, c1, t);
}



function lerp3(f0, f1, f2, f3, t)
{
    const c0  = lerp(f0, f1, t);
    const c1  = lerp(f1, f2, t);
    const c2  = lerp(f2, f3, t);

    const c01 = lerp(c0, c1, t);
    const c12 = lerp(c1, c2, t);

    return lerp(c01, c12, t);
}



function normalAngle(angle)
{
    while (angle <  0  ) angle += Tau;
    while (angle >= Tau) angle -= Tau;

    return angle; // [0, Tau|
}



function dot3(m, v) 
{
    const result = [];

    for (let i = 0; i < m.length; i++) 
    {
        let sum = 0;

        for (let j = 0; j < v.length; j++) 
            sum += m[i][j] * v[j];

        result.push(sum);
    }
   
    return result;
}


const point_NaN = point(Number.NaN, Number.NaN);



function pointIsNaN(p) { return isNaN(p.x) || isNaN(p.y); }



function unit(v)
{
    return v.X != 0 
        || v.Y != 0
        ? mulvs(v, 1 / lengthv(v))
        : point(0, 0);
}



function lerpv(p0, p1, t)
{
    return point(
        lerp(p0.x, p1.x, t),
        lerp(p0.y, p1.y, t));
}



function lerpv2(p0, p1, p2, t)
{
    return point(
        lerp2(p0.x, p1.x, p2.x, t),
        lerp2(p0.y, p1.y, p2.y, t));
}



function lerpv3(p0, p1, p2, p3, t)
{
    return point(
        lerp3(p0.x, p1.x, p2.x, p3.x, t),
        lerp3(p0.y, p1.y, p2.y, p3.y, t));
}



function clipEdge(p, q, t0, t1)
{
    if (p == 0 && q < 0)
    {
        return null;
    }
    else if (p < 0)
    {
        const r = q/p;

             if (r > t1) return null;
        else if (r > t0) t0 = r;
    }
    else if (p > 0)
    {
        const r = q/p;

             if (r < t0) return null;
        else if (r < t1) t1 = r;
    }

    return [t0, t1];
}



function clipLine(x1, y1, x2, y2, left, top, right, bottom)
{
    const t0 = 0;
    const t1 = 1;

    const dx = x2 - x1;
    const dy = y2 - y1;

    const cl = clipEdge(-dx, -(left - x1), t0, t1); if (cl != null) { t0 = cl[0]; t1 = cl[1]; } else return null;
    const cr = clipEdge( dx,  right - x1,  t0, t1); if (cr != null) { t0 = cr[0]; t1 = cr[1]; } else return null;
    const ct = clipEdge(-dy,  -(top - y1), t0, t1); if (ct != null) { t0 = ct[0]; t1 = ct[1]; } else return null;
    const cb = clipEdge( dy,  bottom - y1, t0, t1); if (cb != null) { t0 = cb[0]; t1 = cb[1]; } else return null;

    if (t1 < 1)
    {
        x2 = x1 + t1*dx;
        y2 = y1 + t1*dy;
    }

    if (t0 > 0)
    {
        x1 = x1 + t0*dx;
        y1 = y1 + t0*dy;
    }

    return [
        point(x1, y1), 
        point(x2, y2) ];
}



function intersectLines(p1, p2, q1, q2, segment)
{
    if (   equalv(p1, p2) 
        || equalv(q1, q2)) 
        return point_NaN; // undefined line

    const v1 = subv(p2, p1);
    const v2 = subv(q2, q1);

    if (crossv2(v1, v2) == 0) 
        return point_NaN; // parallel lines

    const t1 = crossv2(subv(q1, p1), v2) / crossv2(v1, v2);
    const t2 = crossv2(subv(q1, p1), v1) / crossv2(v1, v2);

    if (   (   0 <= t1 && t1 <= 1
            && 0 <= t2 && t2 <= 1)
        || !segment)
        return addv(p1, mulvs(v1, t1));
        
    return point_NaN;
}



function closestPointOnLine(l0, l1, p, segment)
{
    if (equalv(p, l0))
        return l0;
        
    const d = mulvs(
        unitv(crossv(subv(l1, l0))), // perpendicular unit vector from p towards the line
        distance(p, l0));            // the distance to any of the two points guarantees intersection with the line

    return intersectLines(l0, l1, p, subv(p, d), segment);
}



function signedPosOnLine(p0, p1, p)
{
    let cp = closestPointOnLine(p0, p1, p, false);

    const xform = mulm3m3(
        xmove(-p0),
        xrotate(-anglev(p0, p1)));

    p0 = transform(p0, xform);
    p1 = transform(p1, xform);
    cp = transform(cp, xform);

    return (cp.X - p0.X) / nozero(p1.X - p0.X);
}



function rectInside(rect1, rect2)
{
    return rect1.l >= rect2.l
        && rect1.r <= rect2.r
        && rect1.t >= rect2.t
        && rect1.b <= rect2.b; 
}



function rectsIntersect(rect1, rect2)
{
    return !(
           rect1.l >= rect2.r
        || rect1.r <= rect2.l
        || rect1.t >= rect2.b
        || rect1.b <= rect2.t); 
}



function clipRect(rect, clip)
{
    if (!rectsIntersect(rect, clip))
        return Rect.NaN;

    return new AbsRect(
        Math.max(rect.l, clip.l),
        Math.max(rect.t, clip.t),
        Math.min(rect.r, clip.r),
        Math.min(rect.b, clip.b));
}



function validateRect(rect)
{
    return new Rect(
        rect.x + Math.min(rect.w, 0),
        rect.y + Math.min(rect.h, 0),
        Math.abs(rect.w),
        Math.abs(rect.h));
}



function validateRect_(x, y, w, h)
{
    return [
        x + Math.min(w, 0),
        y + Math.min(h, 0),
        Math.abs(w),
        Math.abs(h) ];
}



function transform(p, xform)
{
    return mulv2m3(p, xform);
}



function xmove(v)
{
    return [[1, 0, v.x],
            [0, 1, v.y],
            [0, 0, 1  ]];
}



function xrotate(angle)
{
    return [[ Math.cos(angle), Math.sin(angle), 0],
            [-Math.sin(angle), Math.cos(angle), 0],
            [ 0,               0,               1]];
}



function offsetRect(elem)
{
    return new Rect(
        elem.offsetLeft,
        elem.offsetTop,
        elem.offsetWidth,
        elem.offsetHeight);
}



function boundingRect(elem)
{
    const bounds = elem.getBoundingClientRect();

    return new Rect(
        bounds.x,
        bounds.y,
        bounds.width,
        bounds.height);
}



function circleCenter(p0, p1, p2)
{
    const v0  = subv(p1, p0);
    const v1  = subv(p2, p1);
    
    const pm0 = divvs(addv(p0, p1), 2);
    const pm1 = divvs(addv(p1, p2), 2);
    
    return intersectLines(
        pm0, addv(pm0, crossv(v0)), 
        pm1, subv(pm1, crossv(v1)), 
        false);
}



function halfArcAngle(p1, p2, p3)
{
    // returns the angle of the first half of the arc p1-p2

    const pc = circleCenter(p1, p2, p3);

    let a = angleDiff(
        angle(subv(p1, pc)),
        angle(subv(p2, pc)));

    // console.log('angle(subv(p1, pc) =', angle(subv(p1, pc)));    
    // console.log('angle(subv(p2, pc) =', angle(subv(p2, pc)));        
    // while (a < 0)
    //     a += Tau;

    return a;
}


function bezierTangent(x0, y0, x1, y1, x2, y2, x3, y3, t)
{
    const p0 = point(x0, y0);
    const p1 = point(x1, y1);
    const p2 = point(x2, y2);
    const p3 = point(x3, y3);

    return unit(addv(addv(
        mulvs(subv(p1, p0), 3*sqr(1-t)),
        mulvs(subv(p2, p1), 6*(1-t)*t)),
        mulvs(subv(p3, p2), 3*sqr(t))));
}



function positionOnSegment(p0, p1, p2, p3, arcLen, error = 0.001)
{
    const hullLength = 
          distance(p0, p1) 
        + distance(p1, p2)
        + distance(p2, p3);

    if (hullLength == 0)
        return Number.NAN;


    let t = arcLen / hullLength;

    if (t < 0 || t > 1)
        return Number.NAN;

        
    let halves = splitSeg(p0, p1, p2, p3, t);
    let l      = halves[0];

    let length = arcLength(l[0], l[1], l[2], l[3], error);


    let loopProtect = 1000;

    while (Math.abs(arcLen - length) > error
        && loopProtect-- > 0)
    {
        t += (arcLen - length) / hullLength;

        halves = splitSeg(p0, p1, p2, p3, t);
        l      = halves[0];

        length = arcLength(l[0], l[1], l[2], l[3], error);
    }

    if (loopProtect == 0)
        console.log('endless loop in positionOnSegment()');


    return t;
}



function splitSeg(p0, p1, p2, p3, t)
{
    const c0   = lerpv(p0, p1, t);
    const c1   = lerpv(p1, p2, t);
    const c2   = lerpv(p2, p3, t);
                
    const c01  = lerpv(c0, c1, t);
    const c12  = lerpv(c1, c2, t);

    const c012 = lerpv(c01, c12, t);

    return [
        [p0, c0, c01, c012],
        [c012, c12, c2, p3] ];
}



// function splitSegments(_p0, _p1, _p2, _p3, ts)
// {
//     const segments = [];


//     let p0 = _p0, 
//         p1 = _p1,
//         p2 = _p2,
//         p3 = _p3;

//     for (let i = 0; i < ts.length; i++)
//     {
//         const parts = split(p0, p1, p2, p3, ts[i]);
//         const l     = parts[0];
//         const r     = parts[1];


//         segments.push(l);


//         if (i < ts.length-1)
//         {
//             p0 = r[0];
//             p1 = r[1];
//             p2 = r[2];
//             p3 = r[3];

//             for (let j = i+1; j < ts.length; j++)
//                 ts[j] = 1 - (1 - ts[j]) / (1 - ts[i]);
//         }
//         else segments.push(r);
//     }


//     return segments;
// }



function arcLength(p0, p1, p2, p3, error = 0.0000001)
{
    const arcLen = 
          distance(p0, p1)
        + distance(p1, p2)
        + distance(p2, p3);

    const chord = distance(p0, p3);

    if ((arcLen - chord) > error)
    {
        const halves = splitSeg(p0, p1, p2, p3, 0.5);
        const l      = halves[0];
        const r      = halves[1];
            
        return arcLength(l[0], l[1], l[2], l[3], error)
             + arcLength(r[0], r[1], r[2], r[3], error);
    }

    return arcLen;
}



function bounds2(p0, p1, p2)
{
    let rect = Rect.NaN;


    rect = expandRect_(rect, p0);
    rect = expandRect_(rect, p2);

    /*	if p1 is between p0 and p2 then 
        p0 and p2 are opposite corners of the bounds  */

    if (   (   p0.x <= p1.x && p1.x <= p2.x
            || p2.x <= p1.x && p1.x <= p0.x)
        && (   p0.y <= p1.y && p1.y <= p2.y
            || p2.y <= p1.y && p1.y <= p0.y))
        return rect;


    const ax = p0.x - 2*p1.x + p2.x;
    const bx = 2 * (p1.x - p0.x);
    
    const ay = p0.y - 2*p1.y + p2.y;
    const by = 2 * (p1.y - p0.y);


    const tx = -bx / nozero(2*ax);
    const ty = -by / nozero(2*ay);


    if (tx >= 0 && tx <= 1) rect = expandRect_(rect, lerpv2(p0, p1, p2, tx));
    if (ty >= 0 && ty <= 1) rect = expandRect_(rect, lerpv2(p0, p1, p2, ty));
    

    return rect;
}



function bounds3(p0, p1, p2, p3)
{
    let rect = Rect.NaN;


    rect = expandRect_(rect, p0);
    rect = expandRect_(rect, p3);


    const ax =   -p0.x + 3*p1.x - 3*p2.x + p3.x;
    const bx =  3*p0.x - 6*p1.x + 3*p2.x;
    const cx = -3*p0.x + 3*p1.x;

    const ay =   -p0.y + 3*p1.y - 3*p2.y + p3.y;
    const by =  3*p0.y - 6*p1.y + 3*p2.y;
    const cy = -3*p0.y + 3*p1.y;


    const roots = []; // there will be ≤4 solutions

    bounds3t(ax, bx, cx, roots);
    bounds3t(ay, by, cy, roots);


    for (const root of roots)
    {
        rect = expandRect_(
            rect, 
            lerpv3(p0, p1, p2, p3, root));
    }


    return rect;
}



function bounds3t(a, b, c, roots)
{
    let a_ = a * 3;
    let b_ = b * 2;


    let D = b_*b_ - 4*a_*c;
    let r;

    if (a_ == 0)
    {
        r = -c/b_;  if (r >= 0 && r <= 1) roots.push(r);
    }
    else
    {
        const _2a = 1/(2*a_);
        b_ *= _2a;
    
        if (D == 0)
        {
            if (b_ >= 0 && b_ <= 1) roots.push(-b_);
        }
        else if (D > 0)
        {
            D = Math.sqrt(D) * _2a;

            r = -b_ + D;  if (r >= 0 && r <= 1) roots.push(r);
            r = -b_ - D;  if (r >= 0 && r <= 1) roots.push(r);
        }
    }
}


var bigBuffer = new Uint8Array(2048);



function bigRandom(max = 0)
{
    const size = 
        max > 0
        ? Math.max(1, Math.floor(bigBitCount(max)/8))
        : bigBuffer.length;
    
    if (size > bigBuffer.length)
        bigBuffer = new Uint8Array(nextPow2(size));
        
    for (let i = 0; i < size; i++)
        bigBuffer[i] = toInt(Math.random() * 0x100);

    let rnd = bigFromBufferAt(bigBuffer, 0, size);

    if (max > 0)
        rnd = rnd % max;
        
    return rnd;
}



function bigPowMod(n, e, m) // n^e % mod
{
    let c = 1n;

    while (e > 0n)
    {
        if ((e & 1n) != 0n)
        {
            c *= n;
            c %= m;
        }

        e  >>= 1n;
        
        n *= n;
        n %= m;
    }
    
    return c;
}



function bigNextPrime(n) 
{
    while (!bigIsPrime(++n));
    return n;
}



function bigIsPrime(x, k = millerRabinIterations) // Miller-Rabin
{
    if (x <= 1n) return false; 
    if (x <= 3n) return true;
    
    if (x % 2n == 0n) 
        return false;
        
        
    let d = x - 1n;
    let s = 0n; 
                
    while (d % 2n == 0n) 
    {
        d /= 2n;         
        s++;
    }
        

    for (let i = 0; i < k; i++)    
    {
        const a = 2n + bigRandom(x - 1n);//bigMult(n - 3n, Math.random()); // -3 = -4 + 1 because random() doesn't include 1.0

        if (!bigIsWitness(a, s, d, x))
            return false;        
    }
        

    return true; 
}    

    

function bigIsWitness(a, s, d, n)
{
    let x = bigPowMod(a, d, n);
        
    if (x == 1n)
        return true;

    for (let j = 0n; j < s-1n; j++)
    {
        if (x == n-1n)
            return true;
        
        x = bigPowMod(x, 2n, n);
    }

    return x == n-1n;
}



function bigFromBuffer(buffer)
{
    return bigFromBufferAt(buffer, 0, buffer.length);
}



function bigFromBufferAt(buffer, start, size)
{
    size = Math.min(size, buffer.length - start);
    
    let val = 0n;
    let mul = 1n;

    for (let i = start+size-1; i >= start; i--) // little-endian
    {
        val += mul * BigInt(buffer[i]);
        mul <<= 8n;
    }

    return val;
}



function bigToBuffer(n, buffer, bufferSize)
{
    bigToBufferAt(n, buffer, 0, bufferSize);
}



function bigToBufferAt(n, buffer, start, bufferSize)
{
    let size = Math.ceil(bigBitCount(n) / 8);
    
    size = Math.min(size, buffer.length - start);

    start += bufferSize - size;

    for (let i = start+size-1; i >= start; i--) // little-endian
    {
        buffer[i] = Number(n & 0xFFn); 
        n >>= 8n;
    }
}



function bigBitCount(n)
{
    return n.toString(2).length;
}



function bigModInvert(n, m)
{
    const gcd = bigGcdExtended(n, m);

    if (gcd[0] != 1n) return undefined; // inverse doesn't exist
    else              return (gcd[1] % m + m) % m;
}



function bigGcdExtended(n, m)
{
    if (n == 0n)
        return [m, 0n, 1n];

    const gcd = bigGcdExtended(m % n, n);

    const x   = gcd[1];
    const y   = gcd[2];

    return [
        gcd[0], 
        y - (m/n)*x,
        x ];
}


class Point
{
    x;
    y;

    constructor(x, y)
    {
        this.x = x;
        this.y = y;
    }
}


class Rect
{
    x;
    y;
    w;
    h;


    get l()            { return this.x;            }
    get c()            { return this.x + this.w/2; }
    get r()            { return this.x + this.w;   }
           
    get t()            { return this.y;            }
    get m()            { return this.y + this.h/2  }
    get b()            { return this.y + this.h;   }
          
    get tl()           { return point(this.l, this.t); }
    get tc()           { return point(this.c, this.t); }
    get tr()           { return point(this.r, this.t); }
    get ml()           { return point(this.l, this.m); }
    get mc()           { return point(this.c, this.m); }
    get cm()           { return point(this.c, this.m); }
    get mr()           { return point(this.r, this.m); }
    get bl()           { return point(this.l, this.b); }
    get bc()           { return point(this.c, this.b); }
    get br()           { return point(this.r, this.b); }
      
      
    get width()        { return this.w; }
    get height()       { return this.h; }
      
    get left()         { return this.l; }
    get center()       { return this.c; }
    get right()        { return this.r; }
          
    get top()          { return this.t; }
    get middle()       { return this.m; }
    get bottom()       { return this.b; }

    get topLeft()      { return this.tl; }
    get topCenter()    { return this.tc; }
    get topRight()     { return this.tr; }
    get middleLeft()   { return this.ml; }
    get middleCenter() { return this.mc; }
    get centerMiddle() { return this.cm; }
    get middleRight()  { return this.mr; }
    get bottomLeft()   { return this.bl; }
    get bottomCenter() { return this.bc; }
    get bottomRight()  { return this.br; }



    constructor(x, y, w, h)
    {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
    }



    static fromRect(rect)
    {
        return new Rect(rect.x, rect.y, rect.width, rect.height); 
    }



    // w & h are kept 0 so that isEmpty() works logically on NaN rects
    static get NaN() { return new Rect(Number.NaN, Number.NaN, 0, 0) };
    static get Zero() { return new Rect(0, 0, 0, 0); }



    get isNaN()
    {
        return isNaN(this.x)
            || isNaN(this.y)
            || isNaN(this.w)
            || isNaN(this.h);
    }



	get isEmpty()
	{
		return (this.w == 0
			 || this.h == 0);
	}



    assign(rect)
    {
        this.x = rect.x;
        this.y = rect.y;
        this.w = rect.w;
        this.h = rect.h;
    }
}


class   AbsRect
extends Rect
{
    constructor(l, t, r, b)
    {
        super(l, t, r-l, b-t);
    }
}



function expandRect(rect1, rect2)
{
    if (rect1.isNaN  ) return rect2;
    if (rect1.isEmpty) return rect2;

    if (rect2.isNaN  ) return rect1;
    if (rect2.isEmpty) return rect1;
    
    return new AbsRect(
        Math.min(rect2.l, rect1.l),
        Math.min(rect2.t, rect1.t),
        Math.max(rect2.r, rect1.r),
        Math.max(rect2.b, rect1.b));
}



function expandRect_(rect, p)
{
    if (rect.isNaN) return new Rect(p.x, p.y, 0, 0);

    return new AbsRect(
        Math.min(p.x, rect.l),
        Math.min(p.y, rect.t),
        Math.max(p.x, rect.r),
        Math.max(p.y, rect.b));
}



class Random
{
    seed;
    index; // for next()

    cache;



    constructor(seed = 0)
    { 
        this.seed  = seed; 
        this.index = 0;
        
        this.updateCache(256);
    }



    copy()
    {
        return new Random(this.seed, this.last);
    }



    updateCache(size)
    {
        this.cache = new Int32Array(size);

        let seed = this.seed;
        let last = seed;

        for (let i = 0; i < size; i++)
            this.cache[i] = seed = this.generate(seed, last);
    }



    next()
    {
        if (this.index >= this.cache.length)
            this.updateCache(nextPow2(this.index));

        return this.cache[this.index++] / -0x7fffffff;
    }



    get(index)
    {
        if (index >= this.cache.length)
            this.updateCache(nextPow2(index+1));

        return this.cache[index] / -0x7fffffff;
    }



    generate(seed, last)
    {
        last = seed;
        
        seed = (seed + 0x7ed55d16) + (seed << 12);
        seed = (seed ^ 0xc761c23c) ^ (seed >> 19);
        seed = (seed + 0x165667b1) + (seed <<  5);
        seed = (seed + 0xd3a2646c) ^ (seed <<  9);
        seed = (seed + 0xfd7046c5) + (seed <<  3);
        seed = (seed ^ 0xb55a4f09) ^ (seed >> 16);

        return seed;
    }
}


const isMac = navigator.platform.toLowerCase().indexOf('mac') >= 0;



var utilCanvas;
var utilContext;
    


function initUtilContext()
{
    utilCanvas  = document.createElement('canvas');
    utilContext = utilCanvas.getContext('2d');

    utilContext.willReadFrequently = true;
}



function indexOfChild(parent, child)
{
    return Array.prototype.indexOf.call(parent.children, child);
}



function countString(count, singular, plural = singular)
{
    if (singular == plural)
    {
        const lastChar   = singular.at(-1);
        const pluralChar = lastChar == lastChar.toUpperCase() ? 'S' : 's';

        return singular + (count == 1 ? '' : pluralChar);
    }
    else
    {
        const lastChar = plural.at(-1);

        if (lastChar == lastChar.toUpperCase())
            plural = plural.toUpperCase();

        return count == 1
            ? singular
            : plural;
    }
}



function decCount(strValue)
{
    const dotIndex   = strValue.indexOf('.');
    const commaIndex = strValue.indexOf(',');

    return dotIndex >= 0
         ? strValue.length-1 - dotIndex
         : (commaIndex >= 0
            ? strValue.length-1 - commaIndex
            : 0);
}



function getUserDecimalSeparator()
{
    const num = 1.1;

    return num
        .toLocaleString(navigator.language)
        .substring(1, 2);
}



function isEmptyObject(obj)
{
    if (obj == null)
        return false;
        
    return (
           Object.keys(obj).length === 0 
        && obj.constructor === Object);
}



function shallowCopy(obj)
{
    return Object.assign(Object.create(Object.getPrototypeOf(obj)), obj);
}



function deepCopy(obj)
{
    return JSON.parse(JSON.stringify(obj));
}



function filterUnique(array)
{
    return array.filter((value, index) => 
        array.indexOf(value) === index);
}



function createSvg(element)
{
    const svg = document.createElementNS('http://www.w3.org/2000/svg', element);
    svg.style.pointerEvents = 'none';
    return svg;
}



function isVisible(element)
{ 
    return element.style.visibility == 'visible'; 
}



function isLastInArray(array, item)
{
    return array.indexOf(item) == array.length-1;
}



function clearChildren(parent) 
{
    while (parent.firstChild)
        parent.removeChild(parent.firstChild);
}



// function replaceInStringAt(str, index, replace)
// {
//     return str.substring(0, index) 
//          + replace 
//          + str.substring(index + replace.length);
// }



function strFromData(data)
{
    let str = '';

    for (let i = 0; i < data.length; i++)
        str += String.fromCharCode(data[si]);

    return str;
}



// function clearConsole()
// {
//     setTimeout(console.clear.bind(console));
// }



function log(...params)
{
    setTimeout(console.log.bind(console, ...params)); // doesn't show log source, which makes logs cleaner
}



function logTrace()
{
    setTimeout(console.trace.bind(console));
}



function printNum(num)
{
    return !isNaN(num) ? num : NAN_DISPLAY;
}



function parseNum(str)
{
    return str == NAN_DISPLAY
         ? Number.NaN 
         : parseFloat(str);
}



function isTrue(strBool)
{
    return strBool == 'true';
}



function strIsNum(str) 
{
    if (typeof str != 'string') 
        return false; // only process strings

    if (str == 'NaN') // explicitly support NaN
        return true;

    return !isNaN(str) // use type coercion to parse the whole string
        && !isNaN(parseFloat(str)); // ensure strings of whitespace fail
}



function reflow(elem)
{
    void(elem.offsetHeight);
}


function readonly(target, name, descriptor)
{
    descriptor.writable = false;
    return descriptor;
}



function osCtrl     (plus = true) { return isMac ? ('⌘' + (plus ? ' ' : '')) : ('Ctrl'  + (plus ? '+' : '')); }
function osAlt      (plus = true) { return isMac ? ('⌥' + (plus ? ' ' : '')) : ('Alt'   + (plus ? '+' : '')); }
function osShift    (plus = true) { return isMac ? ('⇧' + (plus ? ' ' : '')) : ('Shift' + (plus ? '+' : '')); }
function osCtrlShift(plus = true) { return isMac ? osShift(plus) + osCtrl(plus) : osCtrl(plus) + osShift(plus); }



function getCreateNodeAction(type, creatingButton, options)
{
    return  options.insert != undefined
        &&  options.insert
        && (    options.autoConnect == undefined
            || !options.autoConnect)
        ? new CreateInsertNodeAction(type, creatingButton, options)
        : new CreateNodeAction      (type, creatingButton, options, options.autoConnect != undefined && options.autoConnect);
}



function simpleIntHash(x)
{
    return (x * 2654435761 % Math.pow(2, 32)) / Math.pow(2, 32);
}



function getNewNumberId(curId, checkExists, id = curId, join = '')
{
    if (!checkExists(id))
        return id;
    

    let numLength = getNumLength(id);

    if (numLength > 0)
    {
        const len = id.length - numLength;
        let   num = parseInt(id.substring(len));

        let newId = '';
        while (newId == '' || checkExists(newId))
            newId = id.substring(0, len + join.length) + join + (++num);

        return newId;
    }

    else if (numLength == 0)
    {
        let num   = 2;
        let newId = id + join + num;

        while (checkExists(newId))
            newId = id + join + (++num);

        return newId;
    }

    else
        return id;
}



function getNumLength(name)
{
    let numLength = 0;

    for (let i = name.length - 1; i >= 0; i--)
    {
        if (isDigit(name[i])) numLength++;
        else break;
    }

    return numLength;
}



function isValidFloatString(str) 
{
    return /^-?\d*\.?\d*(e-?\d+)?$/.test(str);
}



function setControlFont(control, family, size, align = 'left')
{
    control.style.fontFamily = family;
    control.style.fontSize   = size + 'px';
    control.style.textAlign  = align;
}



function daysInMonth(month, year)
{
    if (month == 2)
    {
        return year % 4 != 0
             ? 28
             : 29;
    }
    else if (month == 4
          || month == 7
          || month == 9
          || month == 11)
        return 30;
    else
        return 31;
}



function getFontStyles(fontName)
{
    let fonts = figFonts.filter(f => f.fontName.family == fontName)


    fonts.sort((a, b) =>
    {
        if (a.fontName.style != b.fontName.style)
            return FONT_WEIGHTS.findIndex(w => w[0] == a.fontName.style.toLowerCase())
                 - FONT_WEIGHTS.findIndex(w => w[0] == b.fontName.style.toLowerCase());

        return 0;
    });

    
    return fonts.map(f => f.fontName.style);
}



function unescapeString(str)
{
    return str.replace(/\\(.)/g, (match, char) => 
    {
        const replacements = 
        {
            'n':  '\n',
            'r':  '\r',
            't':  '\t',
            '\\': '\\',
            '\'': '\'',
            '\"': '\"',
            '\`': '\`'
        };
      
        return replacements[char] || match;
    });
}



function getEditDistance(str1, str2)
{
    // calculate the Levenshtein distance between two strings
    // implementation taken from http://blog.softwx.net/2014/12/optimizing-levenshtein-algorithm-in-c.html

    // TODO replace with Damerau-Levenshtein

    if (str1.length == 0) return str2.length;
    if (str2.length == 0) return str1.length;

    // make sure str1 is the shorter string

    if (str1.length > str2.length)
    {
        const _str = str1;
        str1 = str2;
        str2 = _str;
    } 

    let len1 = str1.length; // min length of the two strings
    let len2 = str2.length;

    // suffix common to both strings can be ignored

    while (len1 > 0 
        && str1[len1 - 1] == str2[len2 - 1])
    {
        len1--; 
        len2--; 
    }

    let start = 0;

    // if there's a shared prefix or str1 == str2's suffix

    if (str1[0] == str2[0])
    {
        while (start < len1 
            && str1[start] == str2[start]) 
            start++;

        len1 -= start; // length of the part excluding common prefix and suffix
        len2 -= start;

        // if str1 == prefix and/or suffix of str2, 
        // edit distance is just the number of additional characters in str2

        if (len1 == 0) return len2;

        str2 = str2.substring(start, len2); // faster than str2[start + j] in inner loop below
    }

    //

    let v0 = [];
    
    for (let j = 0; j < len2; j++) 
        v0.push(j + 1);

    //

    let current = 0;

    for (let i = 0; i < len1; i++)
    {
        const c = str1[start + i];

        let left = current = i;

        for (let j = 0; j < len2; j++)
        {
            const above = current;
           
            current = left; // cost on diagonal (substitution)
            left = v0[j];

            if (c != str2[j])
            {
                current++; // substitution

                let insDel = above + 1; // deletion

                if (insDel < current) 
                    current = insDel;

                insDel = left + 1; // insertion

                if (insDel < current) 
                    current = insDel;
            }

            v0[j] = current;
        }
    }
    
    return current;
}



function skipRandom(count)
{
    for (let i = 0; i < count; i++) 
        Math.random();
}



function includesSimilar(str, sub, levenshteinDistance)
{
    if (sub.length > str.length)
        return false;
    
    if (str.includes(sub))
        return true;
    
    for (let i = 0; i <= str.length - sub.length; i++) 
    {
        const s = str.substring(i, i + sub.length);
        
        if (getEditDistance(sub, s) <= levenshteinDistance)
            return true;
    }
}



function degamma(rgb, cs = sRGB)
{
    return [ cs.degamma(rgb[0]),
             cs.degamma(rgb[1]),
             cs.degamma(rgb[2]) ];
}



function regamma(rgb, cs = sRGB)
{
    return [ cs.regamma(rgb[0]),
             cs.regamma(rgb[1]),
             cs.regamma(rgb[2]) ];
}



String.prototype.replaceAt = function(index, replacement) 
{
    return this.substring(0, index) 
         + replacement 
         + this.substring(index+1);// + replacement.length);
}



function findAllIndices(array, condition)
{
    const items   = array.filter(condition);
    const indices = [];
    
    for (const item of items)
        indices.push(items.indexOf(item));

    return indices;
}



function createRandomString(length)
{
    const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'.split('');

    let str = '';

    for (let i = 0; i < length; i++)
        str += letters[Math.floor(Math.random() * letters.length)];

    return str;
}



function rectToString(rect)
{
    return '{'
             /*+ rect.x
        + ', ' + rect.y
        + ', '*/ + rect.width
        + ', '   + rect.height
        + '}';
}


"use strict";

// Base64 / binary data / UTF-8 strings utilities
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding


// byte array to Base64 string decoding

function base64toUint6(c) 
{
    return    c > 64 
           && c < 91 
           ? c - 65 
           :    c > 96 
             && c < 123 
             ? c - 71
             :    c > 47 
               && c < 58 
               ? c + 4
               : c === 43 
                 ? 62
                 : c === 47 ? 63 : 0;
}



function base64toArray(str, blocksSize) 
{
    const base64 = str.replace(/[^A-Za-z0-9\+\/]/g, "");
    const inLen  = base64.length;

    const outLen = 
        blocksSize 
        ? Math.ceil((inLen * 3 + 1 >> 2) / blocksSize) * blocksSize 
        : inLen * 3 + 1 >> 2;
        
    const bytes = new Uint8Array(outLen);

    for (let mod3, 
             mod4, 
             uint24 = 0, 
             out    = 0, 
        i = 0; 
        i < inLen; 
        i++) 
    {
        mod4 = i & 3;
        uint24 |= base64toUint6(base64.charCodeAt(i)) << 6 * (3 - mod4);

        if (   mod4 === 3 
            || inLen - i === 1) 
        {
            for (mod3 = 0; mod3 < 3 && out < outLen; mod3++, out++) 
                bytes[out] = uint24 >>> (16 >>> mod3 & 24) & 255;

            uint24 = 0;
        }
    }

    return bytes;
}



// Base64 string to array encoding

function uint6toBase64(i) 
{
    return i < 26 
           ? i + 65
           : i < 52 
             ? i + 71
             : i < 62 
               ? i - 4
               : i === 62 
                 ? 43
                 : i === 63 ? 47 : 65;
}



function arrayToBase64(bytes)
{
    let mod3   = 2, 
        base64 = "";

    const length = bytes.length;

    for (let i = 0, uint24 = 0; i < length; i++) 
    {
        mod3 = i % 3;

        if (i > 0 && (i * 4 / 3) % 76 === 0) 
            base64 += "\r\n";

        uint24 |= bytes[i] << (16 >>> mod3 & 24);

        if (   mod3 === 2 
            || bytes.length - i === 1) 
        {
            base64 += String.fromCharCode(
                uint6toBase64(uint24 >>> 18 & 0x3F), 
                uint6toBase64(uint24 >>> 12 & 0x3F), 
                uint6toBase64(uint24 >>>  6 & 0x3F), 
                uint6toBase64(uint24        & 0x3F));
                
            uint24 = 0;
        }
    }

    return base64.substr(0, base64.length - 2 + mod3) + (mod3 === 2 ? '' : mod3 === 1 ? '=' : '==');
}



// UTF-8 array to DOMString and vice versa

function UTF8ArrToStr(bytes) 
{
    let   str    = "";

    const length = bytes.length;

    for (let i = 0; i < length; i++) 
    {
        const byte = bytes[i];

        str += String.fromCharCode(
               byte > 251 
            && byte < 254 
            && i + 5 < length // six bytes
            ? (byte - 252) * 1073741824 + (bytes[++i] - 128 << 24) + (bytes[++i] - 128 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
            :    byte > 247 
              && byte < 252 
              && i + 4 < length // five bytes
              ? (byte - 248 << 24) + (bytes[++i] - 128 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
              :    byte > 239 
                && byte < 248 
                && i + 3 < length // four bytes
                ? (byte - 240 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
                :    byte > 223 
                  && byte < 240 
                  && i + 2 < length // three bytes
                  ? (byte - 224 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
                  :    byte > 191 
                    && byte < 224 
                    && i + 1 < length // two bytes
                    ? (byte - 192 << 6) + bytes[++i] - 128 /* nPart < 127 ? */ // one byte
                    : byte);
    }

    return str;
}



function strToUTF8Arr(str) 
{
    let strLen = str.length, 
        arrLen = 0;


    // mapping

    for (let i = 0; i < strLen; i++) 
    {
        chr = str.charCodeAt(i);
        arrLen += chr < 0x80 ? 1 : chr < 0x800 ? 2 : chr < 0x10000 ? 3 : chr < 0x200000 ? 4 : chr < 0x4000000 ? 5 : 6;
    }

    const bytes = new Uint8Array(arrLen);


    // transcription

    for (let i = 0, iChr = 0; i < arrLen; iChr++) 
    {
        const chr = str.charCodeAt(iChr);
     
        if (chr < 0x80) // one byte
        {
            bytes[i++] = chr;
        } 
        else if (chr < 0x800) // two bytes
        {
            bytes[i++] = 192 + (chr >>> 6);
            bytes[i++] = 128 + (chr        & 0x3F);
        } 
        else if (chr < 0x10000) // three bytes
        {
            bytes[i++] = 224 + (chr >>> 12);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        }
        else if (chr < 0x200000) // four bytes
        {
            bytes[i++] = 240 + (chr >>> 18);
            bytes[i++] = 128 + (chr >>> 12 & 0x3F);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        } 
        else if (chr < 0x4000000) // five bytes
        {
            bytes[i++] = 248 + (chr >>> 24);
            bytes[i++] = 128 + (chr >>> 18 & 0x3F);
            bytes[i++] = 128 + (chr >>> 12 & 0x3F);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        } 
        else //if (nChr <= 0x7fffffff) // six bytes
        {
            bytes[i++] = 252 + (chr >>> 30);
            bytes[i++] = 128 + (chr >>> 24 & 0x3F);
            bytes[i++] = 128 + (chr >>> 18 & 0x3F);
            bytes[i++] = 128 + (chr >>> 12 & 0x3F);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        }
    }


    return bytes;
}


function position(e)
{
    return point(e.clientX, e.clientY);
}



function getStyleValue(obj, style)
{
    return window.getComputedStyle(obj).getPropertyValue(style);
}



function getCtrlKey(e)
{
    return isMac ? e.metaKey : e.ctrlKey;
    // return  isMac && e.metaKey
    //     || !isMac && e.ctrlKey;
}



function dispatchNewEvent(target, proto)
{
    target.dispatchEvent(new proto.constructor(proto.type, proto));
}



function createDiv(className = '', id = '')
{
    const div = document.createElement('div');
    
    if (className != '')
        div.className = className;
    
    if (id != '')
        div.id = id;

    return div;
}



function appendDivTo(div, to)
{
    if (!to.contains(div))
        to.appendChild(div);
}



function removeDivFrom(div, from)
{
    if (from.contains(div))
        from.removeChild(div);
}



function createTextbox(className = '')
{
    const textbox = document.createElement('INPUT');
    textbox.setAttribute('type', 'text'); 

    if (className.trim() != '')
        textbox.className = className;
    
    return textbox;
}



function createTextarea(className = '')
{
    const textarea = document.createElement('textarea');

    if (className.trim() != '')
        textarea.className = className;
    
    textarea.spellcheck = false;
    
    return textarea;
}



function enableElementText(elem, enable, bold = true)
{
    elem.style.fontStyle  = enable ? 'normal' : 'italic'; 

    if (bold)
        elem.style.fontWeight = enable ? 'normal' : 'bold';
}



function hasFocus(elem)
{
    return elem == document.activeElement;
}



function setStyle(id, properties)
{
    const elem = document.getElementById(id);

    for (const property of properties)
        elem.style[property] = properties[property];
}



function containsChild(parent, child)
{
    return child.parentNode == parent;
}



function forwardEvent(event, element)
{
    const e = new event.constructor(event.type, event);
    element.dispatchEvent(e);
}



function offsetRect(element)
{
    return new Rect(
        element.offsetLeft,
        element.offsetTop,
        element.offsetWidth,
        element.offsetHeight);
}



function clientRect(element)
{
    return new Rect(
        element.clientLeft,
        element.clientTop,
        element.clientWidth,
        element.clientHeight);
}



// function triggerMouseEvent(element, event, px, py, button = 0)
// {
//     const e = new MouseEvent(event, 
//     {
//         clientX: px,
//         clientY: py,
//         button:  button
//     });
//
//     element.dispatchEvent(e);
// }



function selectElementText(elementId)
{
    if (document.selection) // IE
    {
        var range = document.body.createTextRange();
        range.moveToElementText(document.getElementById(elementId));
        range.select();
    }
    else if (window.getSelection) 
    {
        var range = document.createRange();
        range.selectNode(document.getElementById(elementId));
        window.getSelection().removeAllRanges();
        window.getSelection().addRange(range);
    }
}



function isTouchpad(e)
{
    return Math.abs(e.deltaX) < 100
        && Math.abs(e.deltaY) < 100;
}



function showElement(element, show = true) 
{
    const showStyle = 'block';
    const hideStyle = 'none';

    if (  !show
        && element.style.display != hideStyle)
        element.oldDisplay = element.style.display;

    element.style.display = 
        show 
        ? (   element.style.oldDisplay 
           && element.style.oldDisplay != hideStyle
           ? element.style.oldDsplay
           : showStyle)
        : hideStyle; 
}


function hideElement(element)              
{ 
    showElement(element, false); 
}



function isVisible(element)
{
    return element.offsetParent !== null;
}



function getSelectedText(element) // only allow input[type=text] & textarea
{ 
    if (   element.tagName === 'TEXTAREA' 
        || (   element.tagName === 'INPUT' 
            && element.type === 'text')) 
    {
        return element.value.substring(
            element.selectionStart,
            element.selectionEnd);
    }
}



function clearSelectedText(element)
{
    if (   element.tagName === 'TEXTAREA' 
        || (   element.tagName === 'INPUT' 
            && element.type === 'text')) 
    {
        const str = element.value;

        element.value = 
              str.slice(0, element.selectionStart) 
            + str.slice(element.selectionEnd)
    }
}



function scrollbarVisible(element) 
{
    return element.scrollHeight > element.clientHeight;
}



function clientPos(e)
{
    return point(e.clientX, e.clientY);
}



function elementHasSelectedText(div)
{
    const selection = window.getSelection();

    if (selection.rangeCount > 0) 
    {
        const range = selection.getRangeAt(0);
        
        if (   range.commonAncestorContainer === div
            || div.contains(range.commonAncestorContainer))
        {
            const selectedText = range.toString().trim();

            if (selectedText.length > 0)
                return true;
        }
    }

    return false; 
}



function selectDivText(div)
{
    var range = document.createRange();
    range.selectNode(div);

    window.getSelection().removeAllRanges();
    window.getSelection().addRange(range);    
}



function loadFromLocalFile(callback)
{
    const input = document.createElement('input');

    input.type   = 'file';
    input.accept = '.gen';
    
    input.onchange = e => 
    { 
        const file = e.target.files[0]; 

        const reader = new FileReader();
        reader.readAsText(file,'UTF-8');

        reader.onload = e => callback(e.target.result);
    }; 

    input.click();
}



function getLocalFile(callback)
{
    const input = document.createElement('input');

    input.type   = 'file';
    input.accept = '*.*';
    
    input.onchange = e => 
    { 
        callback(e.target.files[0]); 
    }; 

    input.click();
}



function saveToLocalFile(content, filename, contentType)
{
    const a    = document.createElement('a');
    const file = new Blob([content], {type: contentType});

    a.download = filename;
    a.href     = URL.createObjectURL(file);

    a.click();

    URL.revokeObjectURL(a.href);
}


const webColors = [
    {name: 'AliceBlue',            color: 'f0f8ff'},
    {name: 'AntiqueWhite',         color: 'faebd7'},
    {name: 'Aqua',                 color: '00ffff'},
    {name: 'Aquamarine',           color: '7fffd4'},
    {name: 'Azure',                color: 'f0ffff'},
    {name: 'Beige',                color: 'f5f5dc'},
    {name: 'Bisque',               color: 'ffe4c4'},
    {name: 'Black',                color: '000000'},
    {name: 'BlanchedAlmond',       color: 'ffebcd'},
    {name: 'Blue',                 color: '0000ff'},
    {name: 'BlueViolet',           color: '8a2be2'},
    {name: 'Brown',                color: 'a52a2a'},
    {name: 'BurlyWood',            color: 'deb887'},
    {name: 'CadetBlue',            color: '5f9ea0'},
    {name: 'Chartreuse',           color: '7fff00'},
    {name: 'Chocolate',            color: 'd2691e'},
    {name: 'Coral',                color: 'ff7f50'},
    {name: 'CornflowerBlue',       color: '6495ed'},
    {name: 'Cornsilk',             color: 'fff8dc'},
    {name: 'Crimson',              color: 'dc143c'},
    {name: 'Cyan',                 color: '00ffff'},
    {name: 'DarkBlue',             color: '00008b'},
    {name: 'DarkCyan',             color: '008b8b'},
    {name: 'DarkGoldenRod',        color: 'b8860b'},
    {name: 'DarkGray',             color: 'a9a9a9'},
    {name: 'DarkGrey',             color: 'a9a9a9'},
    {name: 'DarkGreen',            color: '006400'},
    {name: 'DarkKhaki',            color: 'bdb76b'},
    {name: 'DarkMagenta',          color: '8b008b'},
    {name: 'DarkOliveGreen',       color: '556b2f'},
    {name: 'DarkOrange',           color: 'ff8c00'},
    {name: 'DarkOrchid',           color: '9932cc'},
    {name: 'DarkRed',              color: '8b0000'},
    {name: 'DarkSalmon',           color: 'e9967a'},
    {name: 'DarkSeaGreen',         color: '8fbc8f'},
    {name: 'DarkSlateBlue',        color: '483d8b'},
    {name: 'DarkSlateGray',        color: '2f4f4f'},
    {name: 'DarkSlateGrey',        color: '2f4f4f'},
    {name: 'DarkTurquoise',        color: '00ced1'},
    {name: 'DarkViolet',           color: '9400d3'},
    {name: 'DeepPink',             color: 'ff1493'},
    {name: 'DeepSkyBlue',          color: '00bfff'},
    {name: 'DimGray',              color: '696969'},
    {name: 'DimGrey',              color: '696969'},
    {name: 'DodgerBlue',           color: '1e90ff'},
    {name: 'FireBrick',            color: 'b22222'},
    {name: 'FloralWhite',          color: 'fffaf0'},
    {name: 'ForestGreen',          color: '228b22'},
    {name: 'Fuchsia',              color: 'ff00ff'},
    {name: 'Gainsboro',            color: 'dcdcdc'},
    {name: 'GhostWhite',           color: 'f8f8ff'},
    {name: 'Gold',                 color: 'ffd700'},
    {name: 'GoldenRod',            color: 'daa520'},
    {name: 'Gray',                 color: '808080'},
    {name: 'Grey',                 color: '808080'},
    {name: 'Green',                color: '008000'},
    {name: 'GreenYellow',          color: 'adff2f'},
    {name: 'HoneyDew',             color: 'f0fff0'},
    {name: 'HotPink',              color: 'ff69b4'},
    {name: 'IndianRed',            color: 'cd5c5c'},
    {name: 'Indigo',               color: '4b0082'},
    {name: 'Ivory',                color: 'fffff0'},
    {name: 'Khaki',                color: 'f0e68c'},
    {name: 'Lavender',             color: 'e6e6fa'},
    {name: 'LavenderBlush',        color: 'fff0f5'},
    {name: 'LawnGreen',            color: '7cfc00'},
    {name: 'LemonChiffon',         color: 'fffacd'},
    {name: 'LightBlue',            color: 'add8e6'},
    {name: 'LightCoral',           color: 'f08080'},
    {name: 'LightCyan',            color: 'e0ffff'},
    {name: 'LightGoldenRodYellow', color: 'fafad2'},
    {name: 'LightGray',            color: 'd3d3d3'},
    {name: 'LightGrey',            color: 'd3d3d3'},
    {name: 'LightGreen',           color: '90ee90'},
    {name: 'LightPink',            color: 'ffb6c1'},
    {name: 'LightSalmon',          color: 'ffa07a'},
    {name: 'LightSeaGreen',        color: '20b2aa'},
    {name: 'LightSkyBlue',         color: '87cefa'},
    {name: 'LightSlateGray',       color: '778899'},
    {name: 'LightSlateGrey',       color: '778899'},
    {name: 'LightSteelBlue',       color: 'b0c4de'},
    {name: 'LightYellow',          color: 'ffffe0'},
    {name: 'Lime',                 color: '00ff00'},
    {name: 'LimeGreen',            color: '32cd32'},
    {name: 'Linen',                color: 'faf0e6'},
    {name: 'Magenta',              color: 'ff00ff'},
    {name: 'Maroon',               color: '800000'},
    {name: 'MediumAquaMarine',     color: '66cdaa'},
    {name: 'MediumBlue',           color: '0000cd'},
    {name: 'MediumOrchid',         color: 'ba55d3'},
    {name: 'MediumPurple',         color: '9370db'},
    {name: 'MediumSeaGreen',       color: '3cb371'},
    {name: 'MediumSlateBlue',      color: '7b68ee'},
    {name: 'MediumSpringGreen',    color: '00fa9a'},
    {name: 'MediumTurquoise',      color: '48d1cc'},
    {name: 'MediumVioletRed',      color: 'c71585'},
    {name: 'MidnightBlue',         color: '191970'},
    {name: 'MintCream',            color: 'f5fffa'},
    {name: 'MistyRose',            color: 'ffe4e1'},
    {name: 'Moccasin',             color: 'ffe4b5'},
    {name: 'NavajoWhite',          color: 'ffdead'},
    {name: 'Navy',                 color: '000080'},
    {name: 'OldLace',              color: 'fdf5e6'},
    {name: 'Olive',                color: '808000'},
    {name: 'OliveDrab',            color: '6b8e23'},
    {name: 'Orange',               color: 'ffa500'},
    {name: 'OrangeRed',            color: 'ff4500'},
    {name: 'Orchid',               color: 'da70d6'},
    {name: 'PaleGoldenRod',        color: 'eee8aa'},
    {name: 'PaleGreen',            color: '98fb98'},
    {name: 'PaleTurquoise',        color: 'afeeee'},
    {name: 'PaleVioletRed',        color: 'db7093'},
    {name: 'PapayaWhip',           color: 'ffefd5'},
    {name: 'PeachPuff',            color: 'ffdab9'},
    {name: 'Peru',                 color: 'cd853f'},
    {name: 'Pink',                 color: 'ffc0cb'},
    {name: 'Plum',                 color: 'dda0dd'},
    {name: 'PowderBlue',           color: 'b0e0e6'},
    {name: 'Purple',               color: '800080'},
    {name: 'RebeccaPurple',        color: '663399'},
    {name: 'Red',                  color: 'ff0000'},
    {name: 'RosyBrown',            color: 'bc8f8f'},
    {name: 'RoyalBlue',            color: '4169e1'},
    {name: 'SaddleBrown',          color: '8b4513'},
    {name: 'Salmon',               color: 'fa8072'},
    {name: 'SandyBrown',           color: 'f4a460'},
    {name: 'SeaGreen',             color: '2e8b57'},
    {name: 'SeaShell',             color: 'fff5ee'},
    {name: 'Sienna',               color: 'a0522d'},
    {name: 'Silver',               color: 'c0c0c0'},
    {name: 'SkyBlue',              color: '87ceeb'},
    {name: 'SlateBlue',            color: '6a5acd'},
    {name: 'SlateGray',            color: '708090'},
    {name: 'SlateGrey',            color: '708090'},
    {name: 'Snow',                 color: 'fffafa'},
    {name: 'SpringGreen',          color: '00ff7f'},
    {name: 'SteelBlue',            color: '4682b4'},
    {name: 'Tan',                  color: 'd2b48c'},
    {name: 'Teal',                 color: '008080'},
    {name: 'Thistle',              color: 'd8bfd8'},
    {name: 'Tomato',               color: 'ff6347'},
    {name: 'Turquoise',            color: '40e0d0'},
    {name: 'Violet',               color: 'ee82ee'},
    {name: 'Wheat',                color: 'f5deb3'},
    {name: 'White',                color: 'ffffff'},
    {name: 'WhiteSmoke',           color: 'f5f5f5'},
    {name: 'Yellow',               color: 'ffff00'},
    {name: 'YellowGreen',          color: '9acd32'}
];


var _clipboard = '';



function writeTextToClipboard(str) 
{
    if (subscribed())
    {
        if (   navigator.clipboard 
            && window.isSecureContext) 
            return navigator.clipboard.writeText(str);

        else 
        {
            const prevActive = document.activeElement;
            const textArea   = document.createElement('textarea');

            textArea.value = str;

            textArea.style.position = 'fixed';
            textArea.style.left     = '-999999px';
            textArea.style.top      = '-999999px';
            
            document.body.appendChild(textArea);
            
            textArea.focus();
            textArea.select();
            
            return new Promise((res, rej) => 
            {
                document.execCommand('copy') ? res() : rej();
                textArea.remove();

                prevActive.focus();
            });
        }
    }
    else
        _clipboard = str;
}



function readTextFromClipboard() 
{
    if (subscribed())
    {
        if (   navigator.clipboard 
            && window.isSecureContext) 
            return navigator.clipboard.readText();

        else 
        {
            let textArea = document.createElement('textarea');

            textArea.style.position = 'fixed';
            textArea.style.left     = '-999999px';
            textArea.style.top      = '-999999px';
            
            document.body.appendChild(textArea);
            
            textArea.focus({preventScroll: true});
            textArea.select();
            
            return new Promise((res, rej) => 
            {
                document.execCommand('paste') ? res(textArea.value) : rej();
                textArea.remove();
            });
        }
    }
    else
        return new Promise((res, rej) => res(_clipboard));
}


function isTagKey(key, tag) 
{
    return key.substring(0, tag.length+1) == tag + ' ';
}



function noTag(key, tag)
{
    return key.substring(tag.length+1);
}



function isPageKey(key) { return isTagKey(key, pageTag); }
function isNodeKey(key) { return isTagKey(key, nodeTag); }
function isConnKey(key) { return isTagKey(key, connTag); }



function noPageTag(key) { return noTag(key, pageTag); }
function noNodeTag(key) { return noTag(key, nodeTag); }
function noConnTag(key) { return noTag(key, connTag); }


const NAN_CHAR               = '\uFFFD';
const NAN_DISPLAY            = '?';
    
const UNKNOWN_CHAR           = '?';
const UNKNOWN_DISPLAY        = UNKNOWN_CHAR;//'🤷‍♂️';

const OBJECT_SEPARATOR       = ' > ';
const   PROP_SEPARATOR       = ' / ';
const  INPUT_SEPARATOR       = ':';

const CENTER_SUFFIX          = ' •';
const  XFORM_SUFFIX          = ' ◇';
    

const  TRUE_DISPLAY_LIGHT    = '<svg width="13" height="11" viewBox="0 1 13 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.3645 1.82058L10.2676 0.599976L5.1191 8.58091L2.44314 6.06144L0.800003 7.67327L5.54161 12.1958L12.3645 1.82058Z" fill="#2AD400"/></svg>';
const FALSE_DISPLAY_LIGHT    = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="#F43D3D"/></svg>';    

const  TRUE_DISPLAY_DARK     = '<svg width="12" height="11" viewBox="0 0 12 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M11.1 0.998457L9.41674 0L4.20109 8.01592L1.50123 5.4381L0.1 6.77599L4.52397 11L11.1 0.998457Z" fill="#3FF911"/></svg>';
const FALSE_DISPLAY_DARK     = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="#FF3E3E"/></svg>';

const  TRUE_DISPLAY_LIGHT_BW = '<svg width="11" height="11" viewBox="0 0 11 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.7157 0.893364L9.55198 0.139526L4.15187 8.47598L1.20316 5.59262L0.248535 6.5928L4.41886 10.5815L5.04702 9.60025L10.7157 0.893364Z" fill="black"/></svg>';
const FALSE_DISPLAY_LIGHT_BW = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.13479 0.1521L0.1521 1.13479L3.51727 4.49997L0.152106 7.86514L1.1348 8.84783L4.49997 5.48266L7.86511 8.8478L8.8478 7.86511L5.48266 4.49997L8.84781 1.13482L7.86511 0.152129L4.49997 3.51727L1.13479 0.1521Z" fill="black"/></svg>';

const  TRUE_DISPLAY_DARK_BW  = '<svg width="12" height="11" viewBox="0 0 12 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M11.1 0.998457L9.41672 0L4.20107 8.01592L1.50121 5.4381L0.0999756 6.77599L4.52395 11L11.1 0.998457Z" fill="white"/></svg>';
const FALSE_DISPLAY_DARK_BW  = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="white"/></svg>';

const  TRUE_DISPLAY_MENU     = '<svg width="12" height="11" viewBox="0 0 12 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M11.1 0.998457L9.41675 0L4.2011 8.01592L1.50124 5.4381L0.100006 6.77599L4.52398 11L11.1 0.998457Z" fill="white"/></svg>';
const FALSE_DISPLAY_MENU     = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="white"/></svg>';



function getTrueDisplay(color = true)
{
    return darkMode
         ? (color ? TRUE_DISPLAY_DARK  : TRUE_DISPLAY_DARK_BW )
         : (color ? TRUE_DISPLAY_LIGHT : TRUE_DISPLAY_LIGHT_BW);
}



function getFalseDisplay(color = true)
{
    return darkMode
         ? (color ? FALSE_DISPLAY_DARK  : FALSE_DISPLAY_DARK_BW )
         : (color ? FALSE_DISPLAY_LIGHT : FALSE_DISPLAY_LIGHT_BW);
}


function nodeIdArrayToString(nodeIds)
{
    let str = '';

    for (let i = 0; i < nodeIds.length; i++)
    {
        if (i > 0) str += ', ';
        str += nodeIds[i];
    }

    return str;
}



function nodeArrayToString(nodes)
{
    let str = '';

    nodes.map(n => n ? n.id : 'undefined').join(', ');

    // for (let i = 0; i < nodes.length; i++)
    // {
    //     if (i > 0) str += ', ';
    //     str += nodes[i] ? nodes[i].id : 'undefined';
    // }

    return str;
}


const INTER_STEP   = 0,
      INTER_LINEAR = 1,
      INTER_COSINE = 2,
      INTER_CUBIC  = 3;



class NoiseSeed
{
    initial;
    current;

    

    constructor()
    {
        this.reset();
    }
    


    set(seed)
    {
        this.initial = seed;
        this.current = seed;
    }    
    


    rotate()
    {
        this.current = (this.current + 0x7ed55d16) + (this.current << 12);
        this.current = (this.current ^ 0xc761c23c) ^ (this.current >> 19);
        this.current = (this.current + 0x165667b1) + (this.current <<  5);
        this.current = (this.current + 0xd3a2646c) ^ (this.current <<  9);
        this.current = (this.current + 0xfd7046c5) + (this.current <<  3);
        this.current = (this.current ^ 0xb55a4f09) ^ (this.current >> 16);
    }    
    


    next()
    {
        const seed = this.current;
        this.rotate();
        return seed;
    }



    reset()
    {
        this.current = this.initial;
    }
};



class Noise
{
	interpolation = INTER_CUBIC;
	clip = false;

	seed = new NoiseSeed();

	v0;
	v1;
	v2;
	v3;

	step = 0;


    constructor(seed = 0)
    {
        this.seed.set(seed);
        this.reset();
    }


    next(scale = 1)
    {
        //scale = Math.pow(Phi, scale) / Phi;
        scale = Math.max(1, scale);

        let next = this.v1;

        if (this.step >= 1)
        {
            // get the next random value
        
            this.seed.rotate();

            this.v0 = this.v1;
        //------------------------
            this.v1 = this.v2;
            this.v2 = this.v3;
        //------------------------
            this.v3 = normalizeSeed(this.seed.current);

            this.step -= 1;
        }

        // get the next 'noise' value

        switch (this.interpolation)
        {
            case INTER_STEP:
            {
                next = this.v1;
                break;
            }
            case INTER_LINEAR:
            {
                next = this.v1 + this.step * (this.v2 - this.v1);
                break;
            }
            case INTER_COSINE:
            {
                const ft = this.step * Math.PI;
                const f  = (1 - Math.cos(ft)) * 0.5;
                
                next = this.v1 + f * (this.v2 - this.v1);
                break;
            }
            case INTER_CUBIC:
            {
                const p = (this.v3 - this.v2) - (this.v0 - this.v1);
                const q = (this.v0 - this.v1) - p;
                const r =  this.v2 - this.v0;
                const s =  this.v1;

                const val = 
                      p * cube(this.step) 
                    + q * sqr(this.step) 
                    + r * this.step 
                    + s;

                next = this.clip 
                    ? Math.max(0, Math.min(val, 1)) 
                    : val;

                break;
            }
        }

        this.step += 1 / scale;

        return next;
    }

   
    reset()
    {
        this.seed.reset();

        this.v0 = normalizeSeed(this.seed.current); this.seed.rotate();
        this.v1 = normalizeSeed(this.seed.current); this.seed.rotate();
        this.v2 = normalizeSeed(this.seed.current); this.seed.rotate();
        this.v3 = normalizeSeed(this.seed.current); this.seed.rotate();

        this.step = 0;
    }
}


function normalizeSeed(x)
{
    return x / -0x7fffffff;
}


const settings =
{
    dataMode:                      false,
    debugMode:                     false,
        
    enableZoomedOutParams:         false,
    minZoomForParams:              0.35,
    showPages:                     false,
    showAllColorSpaces:            false,
    showNodeIcons:                 true,
    showBoolValues:                true,
    showColorLegendInMenus:        false,
    showOperationResults:          false,
    showClearUndoWarning:          true,
    shareUsageMetrics:             true,
    showDebugMenu:                 false,
        
    showNodeId:                    false, // instead of name
    showTransformPoints:           false,
    enableAsserts:                 false,

    showTooltipLongText:           true,
    showTooltipColorInterpolation: true,
    showTooltipColorBlindness:     true,
    showTooltipColorContrast:      true,

    //enableBetaFeatures:            false,
            
    logThreadMessages:             false,
    logDataMessages:               false,
    logMessages:                   false,

    logActions:                    false, 
            
    logLoading:                    false, 
    logRequests:                   false, 
    logValueUpdates:               false, 
    logObjectUpdates:              false,
    logStyleUpdates:               false,
            
    logRawLoadPages:               false, 
    logRawLoadNodes:               false, 
    logRawLoadConnections:         false, 
        
    logRawSavePages:               false, 
    logRawSaveNodes:               false, 
    logRawSaveConnections:         false, 
        
    logRawRequests:                false, 
    logRawValues:                  false,

    sessionId:                     ''
};



function updateSetting(settingName, value)
{
    switch (settingName)
    {
        case 'dataMode':                      settings.dataMode                      = value;  break;
        case 'debugMode':                     settings.debugMode                     = value;  break;
                
        case 'enableZoomedOutParams':         settings.enableZoomedOutParams         = value;  break;
        case 'minZoomForParams':              settings.minZoomForParams              = value;  break;
        case 'showPages':                     settings.showPages                     = value;  break;
        case 'showAllColorSpaces':            settings.showAllColorSpaces            = value;  break;
        case 'showNodeIcons':                 settings.showNodeIcons                 = value;  break;
        case 'showBoolValues':                settings.showBoolValues                = value;  break;
        case 'showColorLegendInMenus':        settings.showColorLegendInMenus        = value;  break;
        case 'showOperationResults':          settings.showOperationResults          = value;  break;
        case 'showClearUndoWarning':          settings.showClearUndoWarning          = value;  break;
        case 'shareUsageMetrics':             settings.shareUsageMetrics             = value;  break;
        case 'showDebugMenu':                 settings.showDebugMenu                 = value;  break;
                        
        case 'showNodeId':                    settings.showNodeId                    = value;  break;
        case 'showTransformPoints':           settings.showTransformPoints           = value;  break;
        case 'enableAsserts':                 settings.enableAsserts                 = value;  break;

        case 'showTooltipLongText':           settings.showTooltipLongText           = value;  break;
        case 'showTooltipColorInterpolation': settings.showTooltipColorInterpolation = value;  break;
        case 'showTooltipColorBlindness':     settings.showTooltipColorBlindness     = value;  break;
        case 'showTooltipColorContrast':      settings.showTooltipColorContrast      = value;  break;

        //case 'enableBetaFeatures':            settings.enableBetaFeatures            = value;  break;
                   
        case 'logThreadMessages':             settings.logThreadMessages             = value;  break;
        case 'logDataMessages':               settings.logDataMessages               = value;  break;
        case 'logMessages':                   settings.logMessages                   = value;  break;

        case 'logActions':                    settings.logActions                    = value;  break;
        case 'logLoading':                    settings.logLoading                    = value;  break;
        case 'logRequests':                   settings.logRequests                   = value;  break;
        case 'logValueUpdates':               settings.logValueUpdates               = value;  break;
        case 'logObjectUpdates':              settings.logObjectUpdates              = value;  break;
        case 'logStyleUpdates':               settings.logStyleUpdates               = value;  break;
                   
        case 'logRawLoadPages':               settings.logRawLoadPages               = value;  break;
        case 'logRawLoadNodes':               settings.logRawLoadNodes               = value;  break;
        case 'logRawLoadConnections':         settings.logRawLoadConnections         = value;  break;
                
        case 'logRawSavePages':               settings.logRawSavePages               = value;  break;
        case 'logRawSaveNodes':               settings.logRawSaveNodes               = value;  break;
        case 'logRawSaveConnections':         settings.logRawSaveConnections         = value;  break;
                
        case 'logRawRequests':                settings.logRawRequests                = value;  break;
        case 'logRawValues':                  settings.logRawValues                  = value;  break;

        case 'sessionId':                     settings.sessionId                     = value;  break;
    } 
}



function updateSettingAndMenu(settingName, valid, value, save = true)
{
    switch (settingName)
    {
        case 'dataMode':                      updateSettingAndMenu_(valid, settingName, value, menuItemDataMode                     ); break;
        case 'debugMode':                     updateSettingAndMenu_(valid, settingName, value                                       ); break;
              
        case 'enableZoomedOutParams':         updateSettingAndMenu_(valid, settingName, value, menuItemEnableZoomedOutParams        ); break;
        case 'showPages':                     updateSettingAndMenu_(valid, settingName, value, menuItemShowPages                    ); break;
        case 'showAllColorSpaces':            updateSettingAndMenu_(valid, settingName, value, menuItemShowAllColorSpaces           ); break;
        case 'showNodeIcons':                 updateSettingAndMenu_(valid, settingName, value, menuItemShowNodeIcons                ); break;
        case 'showBoolValues':                updateSettingAndMenu_(valid, settingName, value, menuItemShowBoolValues               ); break;
        case 'showColorLegendInMenus':        updateSettingAndMenu_(valid, settingName, value, menuItemShowColorLegendInMenus       ); break;
        case 'showOperationResults':          updateSettingAndMenu_(valid, settingName, value, menuItemShowOperationResults         ); break;
        case 'showClearUndoWarning':          updateSettingAndMenu_(valid, settingName, value, menuItemShowClearUndoWarning         ); break;
        case 'shareUsageMetrics':             updateSettingAndMenu_(valid, settingName, value, menuItemShareUsageMetrics            ); break;
        case 'showDebugMenu':                 updateSettingAndMenu_(valid, settingName, value, menuItemShowDebugMenu                ); break;
                      
        case 'showNodeId':                    updateSettingAndMenu_(valid, settingName, value, menuItemShowNodeId                   ); break;
        case 'showTransformPoints':           updateSettingAndMenu_(valid, settingName, value, menuItemShowTransformPoints          ); break;
        case 'enableAsserts':                 updateSettingAndMenu_(valid, settingName, value, menuItemEnableAsserts                ); enableAsserts = value; break;
        
        case 'showTooltipLongText':           updateSettingAndMenu_(valid, settingName, value, menuItemShowTooltipLongText          ); break;
        case 'showTooltipColorContrast':      updateSettingAndMenu_(valid, settingName, value, menuItemShowTooltipColorContrast     ); break;
        case 'showTooltipColorInterpolation': updateSettingAndMenu_(valid, settingName, value, menuItemShowTooltipColorInterpolation); break;
        case 'showTooltipColorBlindness':     updateSettingAndMenu_(valid, settingName, value, menuItemShowTooltipColorBlindness    ); break;

        //case 'enableBetaFeatures':            //updateSettingAndMenu_(valid, settingName, value, menuItemEnableBetaFeatures           ); break;
                      
        case 'logThreadMessages':             updateSettingAndMenu_(valid, settingName, value, menuItemLogThreadMessages            ); break;
        case 'logDataMessages':               updateSettingAndMenu_(valid, settingName, value, menuItemLogDataMessages              ); break;
        case 'logMessages':                   updateSettingAndMenu_(valid, settingName, value, menuItemLogMessages                  ); break;

        case 'logActions':                    updateSettingAndMenu_(valid, settingName, value, menuItemLogActions                   ); break;
        case 'logLoading':                    updateSettingAndMenu_(valid, settingName, value, menuItemLogLoading                   ); break;
        case 'logRequests':                   updateSettingAndMenu_(valid, settingName, value, menuItemLogRequests                  ); break;
        case 'logValueUpdates':               updateSettingAndMenu_(valid, settingName, value, menuItemLogValueUpdates              ); break;
        case 'logObjectUpdates':              updateSettingAndMenu_(valid, settingName, value, menuItemLogObjectUpdates             ); break;
        case 'logStyleUpdates':               updateSettingAndMenu_(valid, settingName, value, menuItemLogStyleUpdates              ); break;
                      
        case 'logRawLoadPages':               updateSettingAndMenu_(valid, settingName, value, menuItemLogRawLoadPages              ); break;
        case 'logRawLoadNodes':               updateSettingAndMenu_(valid, settingName, value, menuItemLogRawLoadNodes              ); break;
        case 'logRawLoadConnections':         updateSettingAndMenu_(valid, settingName, value, menuItemLogRawLoadConnections        ); break;
                      
        case 'logRawSavePages':               updateSettingAndMenu_(valid, settingName, value, menuItemLogRawSavePages              ); break;
        case 'logRawSaveNodes':               updateSettingAndMenu_(valid, settingName, value, menuItemLogRawSaveNodes              ); break;
        case 'logRawSaveConnections':         updateSettingAndMenu_(valid, settingName, value, menuItemLogRawSaveConnections        ); break;
                      
        case 'logRawRequests':                updateSettingAndMenu_(valid, settingName, value, menuItemLogRawRequests               ); break;
        case 'logRawValues':                  updateSettingAndMenu_(valid, settingName, value, menuItemLogRawValues                 ); break;
    } 


    if (   save
        && settingName != 'showAllColorSpaces')
        uiSetLocalData(settingName, boolToString(value));
}



function updateSettingAndMenu_(valid, setting, value, menu)
{
    if (valid) 
        settings[setting] = value;  


    if (setting == 'showNodeId')
    {
        uiPostMessageToFigma(
        {
            cmd:    'figUpdateShowIds',
            showIds: settings.showNodeId
        });
    }


    if (menu)
        menu.setChecked(settings[setting]);
}



function updateSettingsMenus()
{
    menuItemDataMode                     .setVisible(settings.dataMode                     );
    menuItemDebug                        .setVisible(settings.debugMode                    );
                
    menuItemEnableZoomedOutParams        .setChecked(settings.enableZoomedOutParams        );
    menuItemShowPages                    .setChecked(settings.showPages                    );
    menuItemShowAllColorSpaces           .setChecked(settings.showAllColorSpaces           );
    menuItemShowNodeIcons                .setChecked(settings.showNodeIcons                );
    menuItemShowBoolValues               .setChecked(settings.showBoolValues               );
    menuItemShowColorLegendInMenus       .setChecked(settings.showColorLegendInMenus       );
    menuItemShowOperationResults         .setChecked(settings.showOperationResults         );
    menuItemShowClearUndoWarning         .setChecked(settings.showClearUndoWarning         );
    menuItemShareUsageMetrics            .setChecked(settings.shareUsageMetrics            );
    menuItemShowDebugMenu                .setChecked(settings.showDebugMenu                );
                
    menuItemShowNodeId                   .setChecked(settings.showNodeId                   );
    menuItemShowTransformPoints          .setChecked(settings.showTransformPoints          );
    menuItemEnableAsserts                .setChecked(settings.enableAsserts                );

    menuItemShowTooltipLongText          .setChecked(settings.showTooltipLongText          );
    menuItemShowTooltipColorInterpolation.setChecked(settings.showTooltipColorInterpolation);
    menuItemShowTooltipColorBlindness    .setChecked(settings.showTooltipColorBlindness    );
    menuItemShowTooltipColorContrast     .setChecked(settings.showTooltipColorContrast     );

  //menuItemEnableBetaFeatures           .setChecked(settings.enableBetaFeatures           );
                  
    menuItemLogThreadMessages            .setChecked(settings.logThreadMessages            );
    menuItemLogDataMessages              .setChecked(settings.logDataMessages              );
    menuItemLogMessages                  .setChecked(settings.logMessages                  );

    menuItemLogActions                   .setChecked(settings.logActions                   );
                  
    menuItemLogLoading                   .setChecked(settings.logLoading                   );
    menuItemLogRequests                  .setChecked(settings.logRequests                  );
    menuItemLogValueUpdates              .setChecked(settings.logValueUpdates              );
    menuItemLogObjectUpdates             .setChecked(settings.logObjectUpdates             );
    menuItemLogStyleUpdates              .setChecked(settings.logStyleUpdates              );
                  
    menuItemLogRawLoadNodes              .setChecked(settings.logRawLoadPages              );
    menuItemLogRawLoadNodes              .setChecked(settings.logRawLoadNodes              );
    menuItemLogRawLoadConnections        .setChecked(settings.logRawLoadConnections        );
                    
    menuItemLogRawSavePages              .setChecked(settings.logRawSaveNodes              );
    menuItemLogRawSaveNodes              .setChecked(settings.logRawSaveNodes              );
    menuItemLogRawSaveConnections        .setChecked(settings.logRawSaveConnections        );
                
    menuItemLogRawRequests               .setChecked(settings.logRawRequests               );
    menuItemLogRawValues                 .setChecked(settings.logRawValues                 );
}



function updateMenuItemShowPages()
{
    uiSetPageData('showPages', boolToString(settings.showPages));
    graph.updatePages();
    graphView.update();
}



function updateMenuItemShowAllColorSpaces()
{
    uiSetPageData('showAllColorSpaces', boolToString(settings.showAllColorSpaces));

    graph.nodes
        .filter(n => COLOR_TYPES.includes(n.type))
        .forEach(n => n.updateNode());
}



function updateMenuItemShowNodeIcons()
{
    graph.nodes.forEach(n => n.updateNode());
}



function updateMenuItemShowBoolValues()
{
    graph.nodes
        .filter(n => 
               NUMBER_BOOLEAN_TYPES.includes(n.type)
            ||      CONDITION_TYPES.includes(n.type)
            ||         AFFINE_TYPES.includes(n.type)
            || n.type == IF_ELSE)
        .forEach(n => n.updateNode());
}



function updateMenuItemShowColorLegendInMenus()
{
    for (const menu of menuBarMenus)
        menu.items.forEach(i => i.updateLegend());
}



function updateMenuItemShowOperationResults()
{
    const nodes = graph.nodes
        .filter(n => n.params.find(p => p.isResult));

    nodes.forEach(n => 
    {
        const rectd = n.measureData.divOffset;
        const recth = n.measureData.headerOffset;

        n.setRect(rectd.x, rectd.y, recth.w, recth.h, false);
        n.updateNode();
    });

    graphView.updateNodeTransforms(nodes);
}



function enableFeatures(sub, beta = false)
{
    //enableMenuItem(menuItemVarGroup,    sub,  sub);
    enableMenuItem(menuItemTimer,        sub, sub);
    enableMenuItem(menuItemAnimate,      sub, sub);
    enableMenuItem(menuItemSaveToFile,   sub, sub);
    enableMenuItem(menuItemFetch,        sub, sub);
    enableMenuItem(menuItemTextFile,     sub, sub);
    enableMenuItem(menuItemDateTime,     sub, sub);
    enableMenuItem(menuItemSolve,        sub, sub);
    enableMenuItem(menuItemTextJson,     sub, sub);
    enableMenuItem(menuItemCorrectColor, sub, sub);
    enableMenuItem(menuItemConvertToP3,  sub, sub);
    enableMenuItem(menuItemShapeRender,  sub, sub);

    graph.nodes.forEach(n => n.updateSubscribeStatus(sub));
}



function enableMenuItem(menuItem, enable, sub)
{
    //if (!menuItem) return;

    menuItem.enabled = enable;
    menuItem.sub     = sub;

    menuItem.update();
}



function updateMenuItemShowDebugMenu()
{
    updateElementDisplay(menuItemDebug.div, settings.showDebugMenu);

    menuMain.update(
        boundingRect(menuMain.div).x + 6,
        boundingRect(menuMain.div).y - 4,
        true);
}

 

function updateElementDisplay(menuItem, enable)
{
    menuItem.style.display = enable ? 'block' : 'none';
}



function loadLocalSettings()
{
    uiGetLocalData('dataMode'                     );
    uiGetLocalData('debugMode'                    );
        
    uiGetLocalData('enableZoomedOutParams'        );
    uiGetLocalData('minZoomForParams'             );
    uiGetLocalData('showNodeIcons'                );
    uiGetLocalData('showBoolValues'               );
    uiGetLocalData('showColorLegendInMenus'       );
    uiGetLocalData('showPages'                    );
    uiGetLocalData('showOperationResults'         );
    uiGetLocalData('showClearUndoWarning'         );
    uiGetLocalData('shareUsageMetrics'            );
    uiGetLocalData('showDebugMenu'                );
        
    uiGetLocalData('showNodeId'                   );
    uiGetLocalData('showTransformPoints'          );
    uiGetLocalData('enableAsserts'                );

    uiGetLocalData('showTooltipLongText'          );
    uiGetLocalData('showTooltipColorInterpolation');
    uiGetLocalData('showTooltipColorBlindness'    );
    uiGetLocalData('showTooltipColorContrast'     );

  //uiGetLocalData('enableBetaFeatures'           );
            
    uiGetLocalData('logThreadMessages'            );
    uiGetLocalData('logDataMessages'              );
    uiGetLocalData('logMessages'                  );

    uiGetLocalData('logActions'                   );
            
    uiGetLocalData('logLoading'                   );
    uiGetLocalData('logRequests'                  );
    uiGetLocalData('logValueUpdates'              );
    uiGetLocalData('logObjectUpdates'             );
    uiGetLocalData('logStyleUpdates'              );
            
    uiGetLocalData('logRawLoadPages'              );
    uiGetLocalData('logRawLoadNodes'              );
    uiGetLocalData('logRawLoadConnections'        );
        
    uiGetLocalData('logRawSavePages'              );
    uiGetLocalData('logRawSaveNodes'              );
    uiGetLocalData('logRawSaveConnections'        );
        
    uiGetLocalData('logRawRequests'               );
    uiGetLocalData('logRawValues'                 );

    uiGetLocalData('sessionId'                    );
}


const LIST_VALUE              = 'LIST#';

const NUMBER_LIST_VALUE       = 'NLIST#';
const   TEXT_LIST_VALUE       = 'TLIST#';
const  SHAPE_LIST_VALUE       = 'SLIST#';


const NULL_NODE               = 'NULL';
const VARIABLE                = 'VAR';
const VARIABLE_GROUP          = 'VARGRP';
const START                   = 'START';
const REPEAT                  = 'REPT';
const CACHE                   = 'CACHE';
const FREEZE                  = 'FRZ';
const TIMER                   = 'TIMER';
const VALUE_NAME              = 'VNAME';

const COMBINE                 = 'CMB';
const CONDENSE                = 'CDENSE';
const EXTRACT                 = 'EXTR';
const SET_PARAM               = 'SETP';
const EXTRACT_PARAM           = 'EXTRP';
const SUBLIST                 = 'SUBLST';
const UNIQUE                  = 'UNIQ';
const REVERSE_LIST            = 'REVLST';
const SORT                    = 'SORT';
const COLUMN                  = 'CLMN';
const CELL                    = 'CELL';
const LIST                    = 'LIST';
const LIST_COUNT              = 'COUNT';
const CONTAINS                = 'LCONT';
const SELECT                  = 'SEL';
const IF_ELSE                 = 'IF';
const FILTER                  = 'LSTFLT';
const DEFINE                  = 'DEFINE';  


const ANY_VALUE               = 'ANY#';


const LIST_TYPES =
[
    LIST_VALUE,
    NUMBER_LIST_VALUE,
    TEXT_LIST_VALUE,
    SHAPE_LIST_VALUE,
    COMBINE,
    EXTRACT,
    SET_PARAM,
    EXTRACT_PARAM,
    SUBLIST,
    LIST,
    LIST_COUNT,
    CONTAINS,
    REPEAT
];


const LIST_VALUES =
[
           LIST_VALUE,
    NUMBER_LIST_VALUE,
      TEXT_LIST_VALUE,
     SHAPE_LIST_VALUE
];


const FLOW_TYPES =
[
    NULL_NODE,
    VARIABLE,
    VARIABLE_GROUP,
    ...LIST_TYPES,
    CONDENSE,
    EXTRACT,
    SET_PARAM,
    EXTRACT_PARAM,
    SUBLIST,
    UNIQUE,
    REVERSE_LIST,
    COLUMN,
    SORT,
    CELL,
    LIST,
    SELECT,
    IF_ELSE,
    FILTER,
    START,
    REPEAT,
    //FOREACH,
    DEFINE,
    CACHE,
    FREEZE,
    TIMER,
    VALUE_NAME
];


const NUMBER_VALUE            = 'NUM#';  
const NUMBER                  = 'NUM';   
const NUMBER_SIGN             = 'NSIGN';   
const NUMBER_ABSOLUTE         = 'ABS';   
const NUMBER_ROUND            = 'ROUND';   
const NUMBER_SIMPLE_MINMAX    = 'SMINMAX';   
const NUMBER_MINMAX           = 'MINMAX';   
const NUMBER_LIMITS           = 'LIM';   
const NUMBER_CURVE            = 'NCURVE';   
const NUMBER_NAN              = 'NANISNUM';
const NUMBER_CONSTANT         = 'CONST';  
const NUMBER_DATETIME         = 'DATE';  
const NUMBER_SEQUENCE         = 'SEQ';  
const NUMBER_RANGE            = 'RANGE';  
const NUMBER_WAVE             = 'WAVE';  
const NUMBER_RANDOM           = 'RAND';  
const NUMBER_NOISE            = 'NOISE';  
const NUMBER_PROBABILITY      = 'PROB';  
const NUMBER_ACCUMULATE       = 'ACCUM';  
const NUMBER_INTERPOLATE      = 'LERP'; 
const NUMBER_SOLVE            = 'SOLVE';
const NUMBER_ANIMATE          = 'NANIM';

const NUMBER_SIMPLE_MATH      = 'SMATH';  
const NUMBER_MATH             = 'MATH';  
const NUMBER_ADD              = 'ADD';   
const NUMBER_SUBTRACT         = 'SUB';   
const NUMBER_MULTIPLY         = 'MUL';   
const NUMBER_DIVIDE           = 'DIV';   
const NUMBER_MODULO           = 'MOD';   
const NUMBER_EXPONENT         = 'EXP';

const NUMBER_BOOLEAN          = 'NBOOL';  
const NUMBER_NOT              = 'NOT';
const NUMBER_AND              = 'AND';
const NUMBER_OR               = 'OR';
const NUMBER_XOR              = 'XOR';

const NUMBER_CONDITION        = 'COND';
const NUMBER_EQUAL            = 'EQ';
const NUMBER_NOT_EQUAL        = 'NE';
const NUMBER_LESS             = 'LT';
const NUMBER_LESS_OR_EQUAL    = 'LE';
const NUMBER_GREATER          = 'GT';
const NUMBER_GREATER_OR_EQUAL = 'GE';

const NUMBER_TRIG             = 'TRIG';  
const NUMBER_SIN              = 'SIN';   
const NUMBER_COS              = 'COS';   
const NUMBER_TAN              = 'TAN';   

const CONVERT_ANGLE           = 'CNVANG';

const MATH_TYPES =
[
    NUMBER_MATH,
    NUMBER_SIMPLE_MATH,
    NUMBER_ADD,
    NUMBER_SUBTRACT,
    NUMBER_MULTIPLY,
    NUMBER_DIVIDE,
    NUMBER_MODULO,
    NUMBER_EXPONENT
];


const NUMBER_BOOLEAN_TYPES =
[
    NUMBER_BOOLEAN,
    NUMBER_NOT,
    NUMBER_AND,
    NUMBER_OR,
    NUMBER_XOR
];


const CONDITION_TYPES =
[
    NUMBER_CONDITION,
    NUMBER_EQUAL,
    NUMBER_NOT_EQUAL,
    NUMBER_LESS,
    NUMBER_LESS_OR_EQUAL,
    NUMBER_GREATER,
    NUMBER_GREATER_OR_EQUAL
];


const TRIG_TYPES =
[
    NUMBER_TRIG,
    NUMBER_SIN,
    NUMBER_COS,
    NUMBER_TAN
];


const TEXT_VALUE     = 'TEXT#';
const TEXT           = 'TEXT';
const TEXT_LENGTH    = 'TLEN';
const TEXT_TRIM      = 'TTRIM';
const TEXT_SUBSTRING = 'TSUB';
const TEXT_CONTAINS  = 'TCONT';
const TEXT_CASE      = 'TCASE';
const TEXT_REPLACE   = 'TREPL';
const TEXT_JOIN      = 'TJOIN';
const TEXT_PAD       = 'TPAD';
const TEXT_COMPARE   = 'TCMP';
const TEXT_CHAR      = 'TCHAR';
const INDEX_TO_NAME  = 'INDEX';
const NUMBER_TO_TEXT = 'N2T';
const COLOR_TO_TEXT  = 'C2T';
const TEXT_TO_NUMBER = 'T2N';
const TEXT_TO_COLOR  = 'T2C';
const TEXT_SPLIT     = 'TSPLT';
const TEXT_JSON      = 'TJSON';
const TEXT_CSV       = 'TCSV';
const TEXT_FETCH     = 'FETCH';
const TEXT_FILE      = 'TFILE';


const NUMBER_TYPES =
[
    NUMBER_VALUE,
    NUMBER_LIST_VALUE,
    NUMBER,
    NUMBER_SIGN,
    NUMBER_ABSOLUTE,
    NUMBER_ROUND,
    NUMBER_SIMPLE_MINMAX,
    NUMBER_MINMAX,
    NUMBER_LIMITS,
    NUMBER_CURVE,
    NUMBER_NAN,
    NUMBER_CONSTANT,
    NUMBER_DATETIME,
    NUMBER_SEQUENCE,
    NUMBER_RANGE,
    NUMBER_WAVE,
    NUMBER_RANDOM,
    NUMBER_NOISE,
    NUMBER_PROBABILITY,
    NUMBER_ACCUMULATE,
    NUMBER_INTERPOLATE,
    NUMBER_SOLVE,
    NUMBER_ANIMATE,
    NUMBER_TO_TEXT,
    COLOR_TO_TEXT,

    ...MATH_TYPES,
    ...NUMBER_BOOLEAN_TYPES,
    ...CONDITION_TYPES,
    ...TRIG_TYPES,

    CONVERT_ANGLE
];


const TEXT_TYPES =
[
    TEXT_VALUE,
    TEXT_LIST_VALUE,
    TEXT,
    TEXT_LENGTH,
    TEXT_TRIM,
    TEXT_SUBSTRING,
    TEXT_CONTAINS,
    TEXT_CASE,
    TEXT_JOIN,
    TEXT_PAD,
    TEXT_REPLACE,
    TEXT_COMPARE,
    TEXT_CHAR,
    INDEX_TO_NAME,
    TEXT_TO_NUMBER,
    TEXT_TO_COLOR,
    TEXT_SPLIT,
    TEXT_JSON,
    TEXT_CSV,
    TEXT_FETCH,
    TEXT_FILE
];


const COLOR_VALUE        = 'COL#';  
const COLOR              = 'COL';   
const VALID_COLOR        = 'CVAL';  
const CORRECT_COLOR      = 'CCOR';  
const COLOR_CONVERT_P3   = 'COLP3';
const COLOR_CONTRAST     = 'CCNT';  
const COLORBLIND         = 'BLND';  
const COLOR_INTERPOLATE  = 'CLERP'; 
const COLOR_BLEND        = 'CBLND';


const COLOR_TYPES =
[
    COLOR_VALUE,
    COLOR,
    CORRECT_COLOR,
    COLOR_CONVERT_P3,
    COLORBLIND,
    COLOR_INTERPOLATE,
    COLOR_BLEND
];


const FILL_VALUE          = 'FILL#';
const FILL                = 'FILL';
const FILL_TYPES          = [FILL_VALUE, FILL];
  
const STROKE_VALUE        = 'STRK#';
const STROKE              = 'STRK';
const STROKE_TYPES        = [STROKE_VALUE, STROKE];
  
const COLOR_STOP_VALUE    = 'CSTOP#';
const COLOR_STOP          = 'CSTOP';
const COLOR_STOP_TYPES    = [COLOR_STOP_VALUE, COLOR_STOP];
  
const GRADIENT_VALUE      = 'GRAD#';
const GRADIENT            = 'GRAD';
const GRADIENT_TYPES      = [GRADIENT_VALUE, GRADIENT];
 

const ROUND_CORNERS_VALUE = 'RCRN#';
const ROUND_CORNERS       = 'RCRN';
const ROUND_CORNERS_TYPES = [ROUND_CORNERS_VALUE, ROUND_CORNERS];

const DROP_SHADOW_VALUE   = 'DRSH#';
const DROP_SHADOW         = 'DRSH';
const DROP_SHADOW_TYPES   = [DROP_SHADOW_VALUE, DROP_SHADOW];
 
const INNER_SHADOW_VALUE  = 'INSH#';
const INNER_SHADOW        = 'INSH';
const INNER_SHADOW_TYPES  = [INNER_SHADOW_VALUE, INNER_SHADOW];
 
const LAYER_BLUR_VALUE    = 'LBLR#';
const LAYER_BLUR          = 'LBLR';
const LAYER_BLUR_TYPES    = [LAYER_BLUR_VALUE, LAYER_BLUR];
 
const BACK_BLUR_VALUE     = 'BBLR#';
const BACK_BLUR           = 'BBLR';
const BACK_BLUR_TYPES     = [BACK_BLUR_VALUE, BACK_BLUR];
 
const LAYER_MASK_VALUE    = 'MASK#';
const LAYER_MASK          = 'MASK';
const LAYER_MASK_TYPES    = [LAYER_MASK_VALUE, LAYER_MASK];
 
const LAYER_BLEND_VALUE   = 'BLEND#';
const LAYER_BLEND         = 'BLEND';
const LAYER_BLEND_TYPES   = [LAYER_BLEND_VALUE, LAYER_BLEND];


const EFFECT_TYPES =
[
    ...ROUND_CORNERS_TYPES,
    ...DROP_SHADOW_TYPES,
    ...INNER_SHADOW_TYPES,
    ...LAYER_BLUR_TYPES,
    ...BACK_BLUR_TYPES,
    ...LAYER_BLEND_TYPES,
    ...LAYER_MASK_TYPES
];


const STYLE_VALUES =
[
           COLOR_VALUE, 
            FILL_VALUE, 
        GRADIENT_VALUE, 
          STROKE_VALUE,
     DROP_SHADOW_VALUE,
    INNER_SHADOW_VALUE,
      LAYER_BLUR_VALUE,
       BACK_BLUR_VALUE,
     LAYER_BLEND_VALUE,
      LAYER_MASK_VALUE
];


const COLOR_STYLE          = 'CSTL';
 
 
const SHAPE_VALUE          = 'SHP#'; // abstract placeholder
 
const RECTANGLE_VALUE      = 'RECT#';
const RECTANGLE            = 'RECT'; 
const RECTANGLE_TYPES      = [RECTANGLE_VALUE, RECTANGLE];
 
const LINE_VALUE           = 'LINE#';
const LINE                 = 'LINE'; 
const LINE_TYPES           = [LINE_VALUE, LINE];
   
const ELLIPSE_VALUE        = 'ELPS#';
const ELLIPSE              = 'ELPS'; 
const ELLIPSE_TYPES        = [ELLIPSE_VALUE, ELLIPSE];
 
const TRAPEZE_VALUE        = 'TRPZ#';
const TRAPEZE              = 'TRPZ';
const TRAPEZE_TYPES        = [TRAPEZE_VALUE, TRAPEZE];
 
const POLYGON_VALUE        = 'POLY#';
const POLYGON              = 'POLY'; 
const POLYGON_TYPES        = [POLYGON_VALUE, POLYGON];
   
const STAR_VALUE           = 'STAR#';
const STAR                 = 'STAR'; 
const STAR_TYPES           = [STAR_VALUE, STAR];
   
const TEXT_SHAPE_VALUE     = 'TXTS#';
const TEXT_SHAPE           = 'TXTS'; 
const TEXT_SHAPE_TYPES     = [TEXT_SHAPE_VALUE, TEXT_SHAPE];
  
const POINT                = 'PT';
const POINT_VALUE          = 'PT#';
const POINT_TYPES          = [POINT_VALUE, POINT];

const POINT_CORNER         = 'PCORN';

const VECTOR_PATH_VALUE    = 'VPATH#';
const VECTOR_PATH          = 'VPATH'; 
const VECTOR_PATH_TYPES    = [VECTOR_PATH_VALUE, VECTOR_PATH];
 
const VECTOR_VERTEX_VALUE  = 'VPT#';
const VECTOR_VERTEX        = 'VPT'; 
const VECTOR_VERTEX_TYPES  = [VECTOR_VERTEX_VALUE, VECTOR_VERTEX];
 
const VECTOR_EDGE_VALUE    = 'VEDGE#';
const VECTOR_EDGE          = 'VEDGE'; 
const VECTOR_EDGE_TYPES    = [VECTOR_EDGE_VALUE, VECTOR_EDGE];
 
const VECTOR_REGION_VALUE  = 'VREG#';
const VECTOR_REGION        = 'VREG'; 
const VECTOR_REGION_TYPES  = [VECTOR_REGION_VALUE, VECTOR_REGION];
 
const VECTOR_NETWORK_VALUE = 'VNET#';
const VECTOR_NETWORK       = 'VNET'; 
const VECTOR_NETWORK_TYPES = [VECTOR_NETWORK_VALUE, VECTOR_NETWORK];
 
const SHAPE_GROUP_VALUE    = 'SGRP#';
const SHAPE_GROUP          = 'SGRP';
const SHAPE_GROUP_TYPES    = [SHAPE_GROUP_VALUE, SHAPE_GROUP];
 
const FRAME_VALUE          = 'FRM#';
const FRAME                = 'FRM';
const FRAME_TYPES          = [FRAME_VALUE, FRAME];
 

const MOVE                 = 'MOVE';
const ROTATE               = 'ROT';
const SCALE                = 'SCALE';
const SKEW                 = 'SKEW';

const CENTER               = 'CENTR';
const RESET_XFORM          = 'RSTX';

const PLACE                = 'PLACE';
const SHAPE_APPLY          = 'APPLY';
  
const MEASURE_POINTS       = 'MESPT';
const CIRCLE_CENTER        = 'CIRCEN';
const INTERSECT_LINES      = 'INTLIN';
const INTERPOLATE_POINT    = 'PTLERP';
const POINT_ON_PATH        = 'PONPT';


const BOOLEAN              = 'BOOL';
const BOOLEAN_VALUE        = 'BOOL#';

const BOOL_UNION           = 'BOOLU';
const BOOL_SUBTRACT        = 'BOOLS';
const BOOL_INTERSECT       = 'BOOLI';
const BOOL_EXCLUDE         = 'BOOLE';


const BOOLEAN_TYPES =
[
    BOOLEAN,
    BOOLEAN_VALUE,
    BOOL_UNION,
    BOOL_SUBTRACT,
    BOOL_INTERSECT,
    BOOL_EXCLUDE
]


const RENDER             = 'RENDER';


const SHAPE_VALUES =
[
    SHAPE_VALUE,
    SHAPE_LIST_VALUE,
    RECTANGLE_VALUE,
    LINE_VALUE,
    ELLIPSE_VALUE,
    TRAPEZE_VALUE,
    POLYGON_VALUE,
    STAR_VALUE,
    TEXT_SHAPE_VALUE,
    POINT_VALUE,
    VECTOR_PATH_VALUE,
    VECTOR_VERTEX_VALUE,
    VECTOR_EDGE_VALUE,
    VECTOR_REGION_VALUE,
    VECTOR_NETWORK_VALUE,
    SHAPE_GROUP_VALUE,
    FRAME_VALUE,
    BOOLEAN_VALUE,
    DROP_SHADOW_VALUE,
    INNER_SHADOW_VALUE,
    LAYER_BLUR_VALUE,
    BACK_BLUR_VALUE,
    LAYER_BLEND_VALUE,
    LAYER_MASK_VALUE
];


const AFFINE_TYPES =
[
    ROTATE,
    SCALE,
    SKEW
];


const SHAPE_TYPES =
[
    ...SHAPE_VALUES,

    ...RECTANGLE_TYPES,
    ...LINE_TYPES,
    ...ELLIPSE_TYPES,
    ...TRAPEZE_TYPES,
    ...POLYGON_TYPES,
    ...STAR_TYPES,
    ...TEXT_SHAPE_TYPES,
    ...POINT_TYPES,
       POINT_CORNER,
    ...VECTOR_PATH_TYPES,
    ...VECTOR_VERTEX_TYPES,
    ...VECTOR_EDGE_TYPES,
    ...VECTOR_REGION_TYPES,
    ...VECTOR_NETWORK_TYPES,
    ...SHAPE_GROUP_TYPES,
    ...FRAME_TYPES,
    ...BOOLEAN_TYPES,

    MOVE,
    ...AFFINE_TYPES,
    CENTER,
    RESET_XFORM,

    PLACE,
    SHAPE_APPLY,

    MEASURE_POINTS,
    CIRCLE_CENTER,
    INTERSECT_LINES,
    INTERPOLATE_POINT,
    POINT_ON_PATH,

    RENDER
];


const ALL_VALUES =
[
            LIST_VALUE,
     NUMBER_LIST_VALUE,
       TEXT_LIST_VALUE,
      SHAPE_LIST_VALUE,
     
          NUMBER_VALUE,
            TEXT_VALUE,
           COLOR_VALUE,
 
            FILL_VALUE,
      COLOR_STOP_VALUE,
        GRADIENT_VALUE,
          STROKE_VALUE,
 
      COLOR_STOP_VALUE,
        GRADIENT_VALUE,
 
           SHAPE_VALUE,
       RECTANGLE_VALUE,
            LINE_VALUE,
         ELLIPSE_VALUE,
         TRAPEZE_VALUE,
         POLYGON_VALUE,
            STAR_VALUE,
      TEXT_SHAPE_VALUE,
           POINT_VALUE,
     VECTOR_PATH_VALUE,
   VECTOR_VERTEX_VALUE,
     VECTOR_EDGE_VALUE,
   VECTOR_REGION_VALUE,
  VECTOR_NETWORK_VALUE,
     SHAPE_GROUP_VALUE,
           FRAME_VALUE,

   ROUND_CORNERS_VALUE,
     DROP_SHADOW_VALUE,
    INNER_SHADOW_VALUE,
      LAYER_BLUR_VALUE,
       BACK_BLUR_VALUE,

     LAYER_BLEND_VALUE,
      LAYER_MASK_VALUE
];


const GROUP_NODE    = 'GROUP';
const GROUP_PARAM   = 'GPARAM';


const GROUP_TYPES =
[
    GROUP_NODE,
    GROUP_PARAM
];


const COMMENT       = 'CMNT';
const COMMENT_ARROW = 'CMNTARR';
const PANEL         = 'PANEL';


const ACTIVE        = 'ACT';
const BEFORE_ACTIVE = 'BEF';
const DISABLED      = 'DIS';
const NOCACHE       = 'NOC';
 
const PARAM         = 'PARAM'; // nodeId paramId
 

const LOG           = 'LOG';


const GRAPH         = 'GRAPH';


const MATH_OPS = 
[   // the order is important for logical keyboard value changes
    [NUMBER_SUBTRACT, '−' ],
    [NUMBER_ADD,      '+' ],
    [NUMBER_MODULO,   '%' ],
    [NUMBER_DIVIDE,   '/' ], //'÷' ],
    [NUMBER_MULTIPLY, '×' ],
    [NUMBER_EXPONENT, 'e<sup>x'] 
];


const MATH_OPS_SHORT = 
[   // the order is important for logical keyboard value changes
    [NUMBER_SUBTRACT, '−' ],
    [NUMBER_ADD,      '+'],
    [NUMBER_DIVIDE,   '/' ], //'÷' ],
    [NUMBER_MULTIPLY, '×']
];



const BOOLEAN_NOT = 0;
const BOOLEAN_XOR = 1;
const BOOLEAN_OR  = 2;
const BOOLEAN_AND = 3;


const BOOLEAN_OPS = 
[   
    [BOOLEAN_NOT, 'not'],
    [BOOLEAN_XOR, 'xor'], 
    [BOOLEAN_OR,  'or' ],
    [BOOLEAN_AND, 'and']
];



const CONDITION_LESS             = 0;
const CONDITION_LESS_OR_EQUAL    = 1;
const CONDITION_NOT_EQUAL        = 2;
const CONDITION_EQUAL            = 3;
const CONDITION_GREATER_OR_EQUAL = 4;
const CONDITION_GREATER          = 5;


const CONDITION_OPS = 
[   
    [CONDITION_LESS,             '<'],
    [CONDITION_LESS_OR_EQUAL,    '≤'],
    [CONDITION_NOT_EQUAL,        '≠'],
    [CONDITION_EQUAL,            '='],
    [CONDITION_GREATER_OR_EQUAL, '≥'],
    [CONDITION_GREATER,          '>']
];



const TRIG_SIN = 0;
const TRIG_COS = 1;
const TRIG_TAN = 2;


const TRIG_OPS = 
[   
    [TRIG_SIN, 'sin'],
    [TRIG_COS, 'cos'],
    [TRIG_TAN, 'tan']
];



const EMPTY_ACTION               = 'EMPTY';
const CONNECT_ACTION             = 'CONNECT';
const CREATE_ACTION              = 'CREATE';
const CREATE_INSERT_ACTION       = 'CREATE_INSERT';
const DELETE_ACTION              = 'DELETE';
const DISCONNECT_ACTION          = 'DISCONNECT';
const LINK_STYLE_ACTION          = 'LINK_STYLE';
const LINK_VARIABLE_ACTION       = 'LINK_VARIABLE';
const LINK_VARIABLE_GROUP_ACTION = 'LINK_VARIABLE_GROUP';
const MAKE_ACTIVE_ACTION         = 'MAKE_ACTIVE';
const MAKE_PASSIVE_ACTION        = 'MAKE_PASSIVE';
const PASTE_ACTION               = 'PASTE';
const RECONNECT_ACTION           = 'RECONNECT';
const REMOVE_ACTION              = 'REMOVE';
const RENAME_ACTION              = 'RENAME';
const REORDER_INPUTS_ACTION      = 'REORDER_INPUTS';
const REORDER_CONNECTIONS_ACTION = 'REORDER_CONNECTIONS';
const SELECT_ACTION              = 'SELECT';
const SELECT_MOVE_ACTION         = 'SELECT_MOVE';
const MOVE_NODES_ACTION          = 'MOVE_NODES';
const SET_PARAM_VALUE_ACTION     = 'SET_PARAM_VALUE';
const SET_PARAM_SETTING_ACTION   = 'SET_PARAM_SETTING';
const SET_NODE_RECT_ACTION       = 'SET_NODE_RECT';
const TOGGLE_DISABLE_ACTION      = 'TOGGLE_DISABLE';
const TOGGLE_PARAM_HEADER_ACTION = 'TOGGLE_PARAM_HEADER';
const SET_CURRENT_GRAPH_ACTION   = 'SET_CURRENT_GRAPH';
const CREATE_PAGE_ACTION         = 'CREATE_PAGE';
const DELETE_PAGE_ACTION         = 'DELETE_PAGE';
const GROUP_NODES_ACTION         = 'GROUP_NODES';
const UNGROUP_NODES_ACTION       = 'UNGROUP_NODES';
const HIGHLIGHT_NODES_ACTION     = 'HIGHLIGHT_NODES';


const BLEND_NORMAL               = 'BNORM';
const BLEND_DARKEN               = 'BDARK';
const BLEND_MULTIPLY             = 'BMULT';
const BLEND_PLUS_DARKER          = 'BPDRK';
const BLEND_COLOR_BURN           = 'BBURN';
const BLEND_LIGNTEN              = 'BLITE';
const BLEND_SCREEN               = 'BSCRN';
const BLEND_PLUS_LIGHTER         = 'BPLGT';
const BLEND_COLOR_DODGE          = 'BDODG';
const BLEND_OVERLAY              = 'BOVER';
const BLEND_SOFT_LIGHT           = 'BSOFT';
const BLEND_HARD_LIGHT           = 'BHARD';
const BLEND_DIFFERENCE           = 'BDIFF';
const BLEND_EXCLUSION            = 'BEXCL';
const BLEND_HUE                  = 'BHUE';
const BLEND_SATURATION           = 'BSAT';
const BLEND_COLOR                = 'BCOL';
const BLEND_LUMINOSITY           = 'BLUM';


const BlendModes =
[
    [BLEND_NORMAL,       'normal',       'NORMAL'      ],
    [BLEND_DARKEN,       'darken',       'DARKEN'      ],
    [BLEND_MULTIPLY,     'multiply',     'MULTIPLY'    ],
    [BLEND_PLUS_DARKER,  'plus darker',  'LINEAR_BURN' ],
    [BLEND_COLOR_BURN,   'color burn',   'COLOR_BURN'  ],
    [BLEND_LIGNTEN,      'lighten',      'LIGHTEN'     ],
    [BLEND_SCREEN,       'screen',       'SCREEN'      ],
    [BLEND_PLUS_LIGHTER, 'plus lighter', 'LINEAR_DODGE'],
    [BLEND_COLOR_DODGE,  'color dodge',  'COLOR_DODGE' ],
    [BLEND_OVERLAY,      'overlay',      'OVERLAY'     ],
    [BLEND_SOFT_LIGHT,   'soft light',   'SOFT_LIGHT'  ],
    [BLEND_HARD_LIGHT,   'hard light',   'HARD_LIGHT'  ],
    [BLEND_DIFFERENCE,   'difference',   'DIFFERENCE'  ],
    [BLEND_EXCLUSION,    'exclusion',    'EXCLUSION'   ],
    [BLEND_HUE,          'hue',          'HUE'         ],
    [BLEND_SATURATION,   'saturation',   'SATURATION'  ],
    [BLEND_COLOR,        'color',        'COLOR'       ],
    [BLEND_LUMINOSITY,   'luminosity',   'LUMINOSITY'  ]
];



const FONT_WEIGHTS =
[
    ['thin',        100],
    ['extra light', 200],
    ['light',       300],
    ['regular',     400],
    ['medium',      500],
    ['semi bold',   600],
    ['bold',        700],
    ['extra bold',  800],
    ['black',       900]
];



const FO_TYPE           =  0;
const FO_NODE_ID        =  1;

const FO_OBJECT_ID      =  2;   const FO_STYLE_ID     = 2;
const FO_OBJECT_NAME    =  3;   const FO_STYLE_NAME   = 3;

const FO_FEEDBACK       =  4;   const FO_STYLE_PAINTS = 4;
const FO_RETAIN         =  5;


const FO_XP0            =  6;
const FO_XP1            =  7;
const FO_XP2            =  8;

const FO_SCALE          =  9;

const FO_FILLS          = 10;
const FO_STROKES        = 11;


const FO_STROKE_WEIGHT  = 12;
const FO_STROKE_ALIGN   = 13;
const FO_STROKE_JOIN    = 14;                                    
const FO_STROKE_MITER   = 15;
const FO_STROKE_CAP     = 16;
const FO_STROKE_DASHES  = 17;

const FO_EFFECTS        = 18;

const FO_DECO           = 19;

const FO_OPACITY        = 20;
const FO_BLEND          = 21;
const FO_MASK           = 22;

const FO_X              = 23;                                                                                                                                                                                                         const FO_GROUP_CHILDREN = 23;
const FO_Y              = 24;                                    
const FO_WIDTH          = 25;   const FO_POINT_IS_CENTER = 25;   
const FO_HEIGHT         = 26;                                    

const FO_RECT_ROUND     = 27;   const FO_ELLIPSE_ROUND   = 27;   const FO_VECTOR_NETWORK_DATA = 27;   const FO_VECTOR_PATH_DATA    = 27;   const FO_POLY_ROUND   = 27;   const FO_STAR_ROUND  = 27;   const FO_FIG_WIDTH      = 27;   const FO_FRAME_ROUND    = 27;
                                const FO_ELLIPSE_FROM    = 28;                                        const FO_VECTOR_PATH_WINDING = 28;   const FO_POLY_CORNERS = 28;   const FO_STAR_POINTS = 28;   const FO_FIG_HEIGHT     = 28;   const FO_FRAME_CHILDREN = 28;
                                const FO_ELLIPSE_TO      = 29;                                        const FO_VECTOR_PATH_ROUND   = 29;                                 const FO_STAR_CONVEX = 29;   const FO_TEXT           = 29; 
                                const FO_ELLIPSE_INNER   = 30;                                                                                                 
                                                                                                                                                                                                      const FO_FONT           = 30;
                                                                                                                                                                                                      const FO_FONT_SIZE      = 31;
                                                                                                                                                                                                      const FO_FONT_STYLE     = 32;
                                                                                                                                                                                                                                    
                                                                                                                                                                                                      const FO_ALIGN_H        = 33;
                                                                                                                                                                                                      const FO_ALIGN_V        = 34;
                                                                                                                                                                                                                                    
                                                                                                                                                                                                      const FO_LINE_HEIGHT    = 35;
                                                                                                                                                                                                      const FO_LETTER_SPACING = 36;                                


class FigmaObject
{
    type;
    
    nodeId     = '';


    objectId   = NULL;
    objectName = NULL;

    itemIndex  = -1; // for linking objects to list items

    retain     = 0;
    feedback   = false;


    xform;

    xp0 = null; //  xp0 ------- xp1 
    xp1 = null; //   |     
    xp2 = null; //  xp2

    sp0 = null; //  sp0 ------- sp1 
    sp1 = null; //   |
    sp2 = null; //  sp2


    scaleCorners;
    scaleStyle;



    constructor(type, nodeId, objectId, objectName)
    {
        this.type         = type;
        this.nodeId       = nodeId;
        this.objectId     = objectId;
        this.objectName   = objectName;

        this.xform        = clone(identity);

        this.scaleCorners = 1;
        this.scaleStyle   = 1;
    }



    copyBase(base)
    {
        this.itemIndex    = base.itemIndex;
        
        this.feedback     = base.feedback;
        this.retain       = base.retain;
        
        this.xform        = clone(base.xform);

        this.xp0          = clone(base.xp0);
        this.xp1          = clone(base.xp1);
        this.xp2          = clone(base.xp2);

        this.sp0          = clone(base.sp0);
        this.sp1          = clone(base.sp1);
        this.sp2          = clone(base.sp2);

        this.scaleCorners = base.scaleCorners;
        this.scaleStyle   = base.scaleStyle;
    }



    copy()
    {
        consoleError('invalid use of abstract method FigmaObject.copy()');
        return null;
    }



    createDefaultSpace(cx = 0, cy = 0)
    {
        this.sp0 = point(cx,   cy  );
        this.sp1 = point(cx+1, cy  );
        this.sp2 = point(cx,   cy+1);
    }



    resetSpace(bounds, singlePoint = false, cx = 0.5, cy = 0.5)
    {
        if (singlePoint)
        {
            cx *= 100;
            cy *= 100;
        }


        const _cx = singlePoint ? this.x + cx : bounds.x + cx * bounds.width;
        const _cy = singlePoint ? this.y + cy : bounds.y + cy * bounds.height;            


        const ds1 = subv(this.sp1, this.sp0);
        const ds2 = subv(this.sp2, this.sp0);

        this.sp0  = point(_cx, _cy);

        this.sp1  = addv(this.sp0, ds1);
        this.sp2  = addv(this.sp0, ds2);
    }



    createDefaultTransform(x, y, a = 0)
    {
        this.xform =
            [[Math.cos(a), -Math.sin(a), x],
             [Math.sin(a),  Math.cos(a), y],
             [0,            0,           1]];
    }



    createDefaultTransformPoints(x, y, w, h)
    {
        this.xp0 = point(x,     y    );
        this.xp1 = point(x + w, y    );
        this.xp2 = point(x,     y + h);
    }



    createSpaceTransform()
    {
        let vr = point(this.sp1.x - this.sp0.x, this.sp1.y - this.sp0.y);
        let vb = point(this.sp2.x - this.sp0.x, this.sp2.y - this.sp0.y);
    
    
        let sx = vr.x;
        let sy = vb.y;
    
        let kx = vr.y;
        let ky = vb.x;
        
        let dx = this.sp0.x;
        let dy = this.sp0.y;
    
    
        let xform = mulm3m3(
            createTransform(dx, dy),
            [[sx, ky, 0],
             [kx, sy, 0],
             [0,  0,  1]]);
    

        return xform;
    }
    
    

    getBounds()
    {
        let bounds = Rect.NaN;

        const dp = subv(this.xp1, this.xp0);

        bounds = expandRect_(bounds, this.xp0);
        bounds = expandRect_(bounds, this.xp1);
        bounds = expandRect_(bounds, this.xp2);
        bounds = expandRect_(bounds, addv(this.xp2, dp));

        return bounds;
    }



    applyTransform(xform, affectSpace)
    {
        const space = this.createSpaceTransform();


        if (this.type == POINT)
        {
            const p = transformPoint(point(this.x, this.y), xform, space);

            this.x = p.x;
            this.y = p.y;

            if (affectSpace)
                this.applySpaceTransform(xform, space);
        }
        else if (this.type == VECTOR_PATH
              || this.type == TRAPEZE)
        {
            this.applyObjectTransform(xform, space);

            this.updatePoints(xform, space);
            this.updatePathPoints();
            this.updatePathData();

            if (affectSpace)
                this.applySpaceTransform(xform, space);
        }
        else if (this.type == SHAPE_GROUP)
        {
            for (const obj of this.children)
            {
                obj.applyObjectTransform(xform, space);

                if (obj.type == VECTOR_PATH)
                    obj.updatePoints(xform, space);

                if (affectSpace)
                    obj.applySpaceTransform(xform, space);
            }                
        }
        else
        {
            this.applyObjectTransform(xform, space);

            if (affectSpace)
                this.applySpaceTransform(xform, space);
        }
    }



    applyObjectTransform(xform, space)
    {
        if (   this.xp0.x == this.xp1.x
            && this.xp0.y == this.xp1.y)
            this.xp1.x += 0.000000001;

        if (   this.xp0.x == this.xp2.x
            && this.xp0.y == this.xp2.y)
            this.xp2.y += 0.000000001;

        this.xp0 = transformPoint(this.xp0, xform, space);
        this.xp1 = transformPoint(this.xp1, xform, space);
        this.xp2 = transformPoint(this.xp2, xform, space);
    }



    applySpaceTransform(xform, space)
    {
        this.sp0 = transformPoint(this.sp0, xform, space);
        this.sp1 = transformPoint(this.sp1, xform, space);
        this.sp2 = transformPoint(this.sp2, xform, space);
    }



    toJsonObject()
    {
        return {
            type:       this.type,
            nodeId:     this.nodeId,

            objectId:   this.objectId,
            objectName: this.objectName,
            
            feedback:   this.feedback,

            xp0:        this.xp0 ? this.xp0/*.toPoint()*/ : null,
            xp1:        this.xp1 ? this.xp1/*.toPoint()*/ : null,
            xp2:        this.xp2 ? this.xp2/*.toPoint()*/ : null
        };
    }



    toData()
    {
        return [
        /* 0 */ this.type,
        /* 1 */ this.nodeId,

        /* 2 */ this.objectId,
        /* 3 */ this.objectName,
            
        /* 4 */ this.feedback,
        /* 5 */ this.retain,
        
        /* 6 */ this.xp0 ? this.xp0/*.toPoint()*/ : null,
        /* 7 */ this.xp1 ? this.xp1/*.toPoint()*/ : null,
        /* 8 */ this.xp2 ? this.xp2/*.toPoint()*/ : null,

        /* 9 */ 0 // for future use
        ];
    }
}



function transformPoint(p, xform, space)
{
    p = mulv2m3(p, inversem3(space));
    p = mulv2m3(p, xform);
    p = mulv2m3(p, space);

    return p;
}



function copyFigmaObject(obj)
{
    switch (obj.type)
    {
        case RECTANGLE:   return FigmaRectangle .prototype.copy.call(obj);
        case LINE:        return FigmaLine      .prototype.copy.call(obj);
        case ELLIPSE:     return FigmaEllipse   .prototype.copy.call(obj);
        case TRAPEZE:     return FigmaTrapeze   .prototype.copy.call(obj);
        case POLYGON:     return FigmaPolygon   .prototype.copy.call(obj);
        case STAR:        return FigmaStar      .prototype.copy.call(obj);
        case TEXT_SHAPE:  return FigmaText      .prototype.copy.call(obj);
        case POINT:       return FigmaPoint     .prototype.copy.call(obj);
        case VECTOR_PATH: return FigmaVectorPath.prototype.copy.call(obj);
        case BOOLEAN:     return FigmaBoolean   .prototype.copy.call(obj);
        case SHAPE_GROUP: return FigmaShapeGroup.prototype.copy.call(obj);
        case FRAME:       return FigmaFrame     .prototype.copy.call(obj);
    }

    consoleError('invalid Figma object type \'' + obj.type + '\'');
    return null;
}



function getPointBounds(points)
{
    let minX = Number.MAX_SAFE_INTEGER;
    let minY = Number.MAX_SAFE_INTEGER;
    let maxX = Number.MIN_SAFE_INTEGER;
    let maxY = Number.MIN_SAFE_INTEGER;

    for (const p of points)
    {
        minX = Math.min(minX, p.x.value);
        minY = Math.min(minY, p.y.value);
        maxX = Math.max(maxX, p.x.value);
        maxY = Math.max(maxY, p.y.value);
    }

    return new AbsRect(minX, minY, maxX, maxY);
}



function getObjBounds(objects)
{
    let bounds = Rect.NaN;

    for (const obj of objects)
        bounds = expandRect(bounds, obj.getBounds());

    return bounds;
}



function addObjectCenter(node, obj, zoom)
{
    const length = 10;
    
    const sp0 = point(
        obj.sp0.x /*+ 0.5*/, 
        obj.sp0.y /*+ 0.5*/);

    const sp1 = addv(sp0, mulvs(      subv(obj.sp1, obj.sp0),      length));
    const sp2 = addv(sp0, mulvs(mulvs(subv(obj.sp2, obj.sp0), -1), length));    

    node.value.objects.push(
        createDecoPoly(
            node, 
            sp0, 
            [sp2, sp0, sp1],
            false,
            '',
            [242, 72, 34], 
            CENTER_SUFFIX));
}



function createDecoPoly(node, center, points, closed, dashes, color, suffix)
{
    const line = new FigmaVectorPath(
        node.nodeId,
        node.nodeId   + suffix,
        node.nodeName + suffix,
        points.map(p => PointValue.fromPoint(node.nodeId, p)),
        closed ? 1 : 0, 
        0, 
        0, 
        0);


    line.strokes.push([
        'SOLID', 
        color[0], 
        color[1], 
        color[2], 
        100, 
        'NORMAL']);

    line.strokeWeight = 1;
    line.strokeAlign  = 'CENTER';
    line.strokeJoin   = 'MITER';
    line.strokeCap    = 'NONE';
    line.strokeDashes = dashes;
    line.isDeco       = true;


    line.createDefaultTransform(center.x, center.y);


    return line;
}



function getValidObjects(value)
{
    return value
        && value.objects
        ? value.objects
              .filter(o => 
                     o.isDeco  === false
                  || o.isXform === true)
              .map(o => o.copy()) 
        : [];
}


function addColorProp(obj, prop)
{
    const rgb = scaleRgb(prop.toRgb());

    obj.fills.push([
        'SOLID', 
        rgb[0], 
        rgb[1], 
        rgb[2], 
        255   ]);
}



function addFillProp(obj, prop, target = obj.fills)
{
    const rgb = scaleRgb(prop.color.toRgb());

    target.push([
        'SOLID', 
        rgb[0], 
        rgb[1], 
        rgb[2], 
        prop.opacity.toValue().toNumber(),
        BlendModes[Math.min(Math.max(0, Math.round(prop.blend.value)), BlendModes.length-1)][2]]);
}



function addGradientProp(obj, prop, target = obj.fills)                
{
    const gradient = 
    [
        '', // type
        [], // transform
        []  // stops
    ];


    switch(prop.gradType.value)
    {
        case 0: gradient[0] = 'GRADIENT_LINEAR';  break;
        case 1: gradient[0] = 'GRADIENT_RADIAL';  break;
        case 2: gradient[0] = 'GRADIENT_ANGULAR'; break;
        case 3: gradient[0] = 'GRADIENT_DIAMOND'; break;
    }


    const isLinear   = prop.gradType.value == 0;

    let   x   =        prop.x     .toNumber() / 100;
    let   y   =        prop.y     .toNumber() / 100;
    const a   =        prop.angle .toNumber()/360*Tau;
    let   s   = nozero(prop.size  .toNumber() / 100);
    let   asp = nozero(prop.aspect.toNumber() / 100);
    let   sk  =        prop.skew  .toNumber() / 100;


    if (!isLinear)
    {
        x -= s/2 * Math.cos(a);
        y -= s/2 * Math.sin(a);

        asp /= 2;
    }

    
    const p0 = point(x, y);
    const p1 = addv(p0, vector(a, s));
    
    const p2 = addv(
        addv(p0, vector(a + Tau/4, s * asp)),
        mulvs(unitv(subv(p1, p0)), distance(p0, p1) * sk));


    const identityHandles = 
        [[0,   1,   0],
         [0.5, 0.5, 1],
         [1,   1,   1]];


    let xform = [
        [p0.x, p1.x, p2.x],
        [p0.y, p1.y, p2.y],
        [1,    1,    1   ]];


    xform = mulm3m3(identityHandles, inversem3(xform));


    gradient[1] = [
        xform[0],
        xform[1] ];
        

    const stops = validateColorStops(prop.stops.items);
    
    setColorStopPositions(stops);


    for (let j = 0; j < stops.length; j++)
    {
        const stop = stops[j];
        const rgba = stop.fill.toRgba();

        gradient[2].push([
            rgba[0], 
            rgba[1], 
            rgba[2], 
            rgba[3],
            stop.position.toNumber() / 100]);
    }


    gradient[3] = BlendModes[prop.blend.value][2];    


    target.push(gradient);
}



function validateColorStops(_stops)
{
    const stops = [];


    for (let i = 0; i < _stops.length; i++)
    {
        const stop = _stops[i];

        if (stop.type == COLOR_VALUE)
        {
            // if (isNaN(stop.toRgb()[0]))
            //     console.log('stop =', stop);
            stops.push(new ColorStopValue(
                FillValue.fromRgb(scaleRgb(stop.toRgb()), 100),
                NumberValue.NaN));
        }

        else if (stop.type == FILL_VALUE)
            stops.push(new ColorStopValue(
                stop,
                NumberValue.NaN));

        else if (stop.type == LIST_VALUE)
            stops.push(...validateColorStops(stop.items));

        else
            stops.push(stop);
    }


    return stops;
}



function setColorStopPositions(stops)
{
    if (    stops.length > 0
        && !stops[0].position.isValid()) 
        stops[0].position = new NumberValue(0);

    if (    stops.length > 1
        && !stops.at(-1).position.isValid()) 
        stops.at(-1).position = new NumberValue(100);
    

    if (stops.length > 2)
    {
        for (let i = 1; i < stops.length-1; i++)
        {
            const stop = stops[i];

            if (!stop.position.isValid())
            {
                let prevValid = i-1;
                let nextValid = i+1;

                while ( prevValid > 0
                    && !stops[prevValid].position.isValid()) 
                    prevValid--;

                while ( nextValid < stops.length-1
                    && !stops[nextValid].position.isValid()) 
                    nextValid++;
                        
                const pv = stops[prevValid].position.toNumber();
                const nv = stops[nextValid].position.toNumber();

               stop.position = new NumberValue((pv + (nv - pv) * ((i - prevValid) / (nextValid - prevValid)))); 
            }
        }
    }
}



function addStrokeProp(obj, prop)
{
    for (const fill of prop.fills.items)
    {
        if (fill.type ==     FILL_VALUE) addFillProp    (obj, fill, obj.strokes);
        if (fill.type == GRADIENT_VALUE) addGradientProp(obj, fill, obj.strokes);
    }


    obj.strokeWeight = prop.weight.toValue().toNumber();

    switch (prop.fit.toValue().value)
    {
        case 0: obj.strokeAlign = 'INSIDE';  break;
        case 1: obj.strokeAlign = 'CENTER';  break;
        case 2: obj.strokeAlign = 'OUTSIDE'; break;
    }

    switch (prop.join.toValue().value)
    {
        case 0: obj.strokeJoin = 'MITER'; break;
        case 1: obj.strokeJoin = 'BEVEL'; break;
        case 2: obj.strokeJoin = 'ROUND'; break;
    }

    switch (prop.cap.toValue().value)
    {
        case 0: obj.strokeCap = 'NONE';   break;
        case 1: obj.strokeCap = 'SQUARE'; break;
        case 2: obj.strokeCap = 'ROUND';  break;
    }

    obj.strokeDashes     = prop.dashes.toValue().value;
    
    obj.strokeMiterLimit = prop.miter .toValue().value;
}



function addRoundCornersProp(obj, prop)
{
    obj.effects.push([
        'ROUND_CORNERS', 
        prop.tl.toNumber(),
        prop.tr.toNumber(),
        prop.bl.toNumber(),
        prop.br.toNumber(),
        prop.visible ]);
}



function addDropShadowProp(obj, prop)
{
    const rgba = prop.fill.toRgba();

    obj.effects.push([
        'DROP_SHADOW', 
        rgba[0],
        rgba[1],
        rgba[2],
        rgba[3],
        prop.x     .toNumber(),
        prop.y     .toNumber(),
        prop.blur  .toNumber(),
        prop.spread.toNumber(),
        BlendModes[prop.blend.value][2],
        prop.behind.value > 0,
        prop.visible ]);
}



function addInnerShadowProp(obj, prop)
{
    const rgba = prop.fill.toRgba();

    obj.effects.push([
        'INNER_SHADOW', 
        rgba[0],
        rgba[1],
        rgba[2],
        rgba[3],
        prop.x     .toNumber(),
        prop.y     .toNumber(),
        prop.blur  .toNumber(),
        prop.spread.toNumber(),
        BlendModes[prop.blend.value][2],
        prop.visible ]);
}



function addLayerBlurProp(obj, prop)
{
    obj.effects.push([
        'LAYER_BLUR', 
        prop.radius.toNumber(),
        prop.visible ]);
}



function addBackBlurProp(obj, prop)
{
    obj.effects.push([
        'BACKGROUND_BLUR', 
        prop.radius.toNumber(),
        prop.visible ]);
}



function addLayerBlendProp(obj, prop)
{
    obj.opacity = Math.min(Math.max(0, prop.opacity.toNumber() / 100), 1);
    obj.blend   = BlendModes[prop.blend.value][2];
}



function addMaskProp(obj, mask)
{
    obj.maskType = mask.maskType.value + 1;
}



class FigmaShape
extends FigmaObject
{
    skewX;
    skewY;

    fills   = [];
    strokes = [];

    strokeWeight;
    strokeAlign;
    strokeJoin;
    strokeMiterLimit;
    strokeCap;
    strokeDashes;

    effects = [];

    isDeco;
    isXform;

    opacity;
    blend;

    maskType = 0;



    constructor(type, nodeId, objectId, objectName, isDeco = false, isXform = false)
    {
        super(type, nodeId, objectId, objectName);

        this.skewX   = 0;
        this.skewY   = 0;

        this.isDeco  = isDeco;
        this.isXform = isXform;

        this.opacity = 1;
        this.blend   = 'PASS_THROUGH';
    }



    copyBase(base)
    {
        super.copyBase(base);

        this.skewX            = base.skewX;
        this.skewY            = base.skewY;

        this.fills            = clone(base.fills);
        this.strokes          = clone(base.strokes);

        this.strokeWeight     = base.strokeWeight;
        this.strokeAlign      = base.strokeAlign;
        this.strokeJoin       = base.strokeJoin;
        this.strokeMiterLimit = base.strokeMiterLimit;
        this.strokeCap        = base.strokeCap;
        this.strokeDashes     = base.strokeDashes;

        this.effects          = clone(base.effects);

        this.isDeco           = base.isDeco;
        this.isXform          = base.isXform;

        this.opacity          = base.opacity;
        this.blend            = base.blend;
        this.maskType         = base.maskType;
    }



    toData()
    {
        const weight = this.strokeWeight * Math.abs(this.scaleStyle);

        const dashes = 
            this.strokeDashes
            ? this.strokeDashes
                .split(',')
                .map(d => parseFloat(d.trim()) * Math.abs(this.scaleStyle))
                .join(',')
            : '';

        
        return [
            ...super.toData(),
   
            /* 10 */ this.fills,
            /* 11 */ this.strokes,

            /* 12 */ weight,
            /* 13 */ this.strokeAlign,
            /* 14 */ this.strokeJoin,
            /* 15 */ this.strokeMiterLimit,
            /* 16 */ this.strokeCap,
            /* 17 */ dashes,

            /* 18 */ this.effects,

            /* 19 */ this.isDeco,

            /* 20 */ this.opacity,
            /* 21 */ this.blend,
            /* 22 */ this.maskType
        ];
    }
}



class FigmaRectangle
extends FigmaShape
{
    x;
    y;
    width;
    height;

    round;

    

    constructor(nodeId, objectId, objectName, x, y, width, height, round)
    {
        super(RECTANGLE, nodeId, objectId, objectName);
        
        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;

        this.round  = round;

        this.createDefaultSpace(
            x + width /2, 
            y + height/2);
    }



    copy()
    {
        const copy = new FigmaRectangle(
            this.nodeId,
            this.objectId,
            this.objectName,

            this.x,
            this.y,
            this.width,
            this.height,
            
            this.round);


        copy.copyBase(this);

        
        return copy;
    }



    toData()
    {
        return [
            ...super.toData(),
   
            /* 23 */ this.x,
            /* 24 */ this.y,
            /* 25 */ this.width,
            /* 26 */ this.height,

            /* 27 */ this.round * Math.abs(this.scaleCorners)
        ];
    }
}



class FigmaLine
extends FigmaShape
{
    x;
    y;
    width;



    constructor(nodeId, objectId, objectName, x, y, width)
    {
        super(LINE, nodeId, objectId, objectName);
        
        this.x     = x;
        this.y     = y;
        this.width = width;

        
        this.createDefaultSpace(
            x + width/2, 
            y);
    }



    copy()
    {
        const copy = new FigmaLine(
            this.nodeId,
            this.objectId,
            this.objectName,

            this.x,
            this.y,
            this.width);


        copy.copyBase(this);


        return copy;
    }



    toData()
    {
        return [
            ...super.toData(),
   
            /* 23 */ this.x,
            /* 24 */ this.y,
            /* 25 */ this.width
        ];
    }
}


class FigmaEllipse
extends FigmaShape
{
    x;
    y;
    width;
    height;
    round;

    from;
    to;
    inner;

    

    constructor(nodeId, objectId, objectName, x, y, width, height, round, from, to, inner)
    {
        super(ELLIPSE, nodeId, objectId, objectName);
        
        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;
        this.round  = round;

        this.from   = from;
        this.to     = to;
        this.inner  = inner;

        
        this.createDefaultSpace(
            x + width /2, 
            y + height/2);
    }



    copy()
    {
        const copy = new FigmaEllipse(
            this.nodeId,
            this.objectId,
            this.objectName,

            this.x,
            this.y,
            this.width,
            this.height,
            this.round,
            
            this.from,
            this.to,
            this.inner);


        copy.copyBase(this);


        return copy;
    }



    toData()
    {
        return [
            ...super.toData(),
   
            /* 23 */ this.x,
            /* 24 */ this.y,
            /* 25 */ this.width,
            /* 26 */ this.height,
            /* 27 */ this.round,

            /* 28 */ this.from,
            /* 29 */ this.to,
            /* 30 */ this.inner
        ];
    }
}


class FigmaVectorPath
extends FigmaShape
{
    x;
    y;
    width;
    height;
    
    points;
    closed;
    degree;

    pathPoints;

    pathData;
    winding;
    round;



    constructor(nodeId, objectId, objectName, points, closed, degree, winding, round)
    {
        super(VECTOR_PATH, nodeId, objectId, objectName);
        
        this.points  = points.map(p => p.copy());

        this.closed  = closed;
        this.degree  = degree;
        this.winding = winding;

        this.round   = round;
        

        this.updatePathPoints();


        let bounds = this.getBounds();

        this.createDefaultSpace(
            bounds.x + bounds.width /2,            
            bounds.y + bounds.height/2            
        );
    }



    copy()
    {
        const copy = new FigmaVectorPath(
            this.nodeId,
            this.objectId,
            this.objectName,

            this.points, 

            this.closed, 
            this.degree,
            this.winding,

            this.round);


        copy.x        = this.x;
        copy.y        = this.y;
        copy.width    = this.width;
        copy.height   = this.height;


        copy.copyBase(this);


        return copy;
    }



    copyBase(base)
    {
        super.copyBase(base);

        if (base.points) this.points = base.points.map(p => p.copy());
    }



    getBounds()
    {
        let bounds = Rect.NaN;

        
        switch (this.degree)
        {
            case 0:
                for (const p of this.pathPoints)
                    bounds = expandRect_(bounds, p);

                break;

            case 1:
                for (let i = 0; i < this.pathPoints.length-2; i += 2)
                {
                    bounds = expandRect(
                        bounds, 
                        bounds2(
                            this.pathPoints[i  ], 
                            this.pathPoints[i+1],
                            this.pathPoints[i+2]));
                }
                break;

            case 2:
            case 3:
            case 4:
            case 5:
                for (let i = 0; i < this.pathPoints.length-3; i += 3)
                {
                    bounds = expandRect(
                        bounds, 
                        bounds3(
                            this.pathPoints[i  ], 
                            this.pathPoints[i+1],
                            this.pathPoints[i+2],
                            this.pathPoints[i+3]));
                }
                break;

            default:
                console.error('invalid curve degree');
        }


        return bounds;
    }



    updatePoints(xform, space)
    {
        for (let i = 0; i < this.points.length; i++)
        {
            let p      = this.points[i].toPoint();
            let smooth = this.points[i].smooth;

            p = transformPoint(p, xform, space);

            this.points[i]        = PointValue.fromPoint(this.nodeId, p);
            this.points[i].smooth = smooth;
        }
    }



    updatePathPoints()
    {
        switch (this.degree)
        {
        case 0: this.pathPoints = this.points.map(p => p.toPoint());                           break;
        case 1: this.pathPoints = this.points.map(p => p.toPoint());                           break;
        case 2: this.pathPoints = this.points.map(p => p.toPoint());                           break;
        case 3: this.pathPoints = getSmoothPoints(this.points, this.closed, getSmoothSegment); break;
        case 4: this.pathPoints = getSmoothPoints(this.points, this.closed, getSineXSegment ); break;
        case 5: this.pathPoints = getSmoothPoints(this.points, this.closed, getSineYSegment ); break;
        }
    }



    updatePathData()
    {
        const bounds = this.getBounds();

        this.x      = bounds.x;
        this.y      = bounds.y;
        this.width  = bounds.width;
        this.height = bounds.height;

        this.createDefaultTransformPoints(this.x, this.y, this.width, this.height);

        this.pathData = getPathDataFromPoints(this.pathPoints, this.closed, this.degree);
    }



    toData()
    {
        this.updatePathPoints();
        this.updatePathData();


        return [
            ...super.toData(),
   
            /* 21 */ this.x,
            /* 22 */ this.y,
            /* 23 */ this.width,
            /* 24 */ this.height,

            /* 25 */ this.pathData,
            /* 26 */ this.winding,
            /* 27 */ this.round * Math.abs(this.scaleCorners)
        ];
    }
}



function getPathDataFromPoints(points, closed, degree)
{
    for (const p of points)
        if (   isNaN(p.x)
            || isNaN(p.y))
            return '';

            
    let pathData = '';


    switch (degree)
    {
    case 0: pathData = getLinearPathData   (points);         break; // linear
    case 1: pathData = getQuadraticPathData(points, closed); break; // quadratic
    case 2:                                                         // cubic
    case 3:                                                         // smooth
    case 4:                                                         // sine X
    case 5: pathData = getCubicPathData    (points, closed); break; // sine Y
    }


    const pointsAreValid =
           degree == 0 && points.length > 2
        || degree == 1 && points.length > 2
        || degree == 2 && points.length > 3
        || degree == 3 && points.length > 2
        || degree == 4 && points.length > 2
        || degree == 5 && points.length > 2;


    if (   pointsAreValid
        && (   closed
            || equalv(points[0], points.at(-1))))
        pathData += ' Z';


    return pathData;
}



function getQuadraticPathData(points, closed)
{
    let pathData = '';


    if (points.length < 3)
        return pathData;


    pathData += 'M';
    pathData += ' ' + hardZero(points[0].x);
    pathData += ' ' + hardZero(points[0].y);

    let i;
    for (i = 1; i < points.length-1; i += 2)
    {
        pathData += 
              ' Q'
            + ' ' + hardZero(points[i  ].x)
            + ' ' + hardZero(points[i  ].y)
            + ' ' + hardZero(points[i+1].x)
            + ' ' + hardZero(points[i+1].y);
    }


    if (   points.length - i == 1
        && closed)
    {
        pathData += 
              ' Q'
            + ' ' + hardZero(points.at(-1).x)
            + ' ' + hardZero(points.at(-1).y)
            + ' ' + hardZero(points.at( 0).x)
            + ' ' + hardZero(points.at( 0).y);
    }


    return pathData;
}



function getCubicPathData(points, closed)
{
    let pathData = '';


    if (points.length < 4)
        return pathData;


    pathData += 'M';
    pathData += ' ' + hardZero(points[0].x);
    pathData += ' ' + hardZero(points[0].y);

    let i;
    for (i = 1; i < points.length-2; i += 3)
    {
        pathData += 
              ' C'
            + ' ' + hardZero(points[i  ].x)
            + ' ' + hardZero(points[i  ].y)
            + ' ' + hardZero(points[i+1].x)
            + ' ' + hardZero(points[i+1].y)
            + ' ' + hardZero(points[i+2].x)
            + ' ' + hardZero(points[i+2].y);
    }


    if (points.length - i == 2)
    {
        pathData += 
              ' C'
            + ' ' + hardZero(points.at(-2).x)
            + ' ' + hardZero(points.at(-2).y)
            + ' ' + hardZero(points.at(-1).x)
            + ' ' + hardZero(points.at(-1).y)
            + ' ' + hardZero(points.at( 0).x)
            + ' ' + hardZero(points.at( 0).y);
    }


    return pathData;
}



function getSmoothPoints(points, closed, getSegment)
{
    if (points.length < 2)
        return '';


    const bp = [];


    // first point
    let [pp, p, pn] = getSegment(
        closed ? points.at(-1) : points[0], 
        points[0],
        points[1]);

    bp.push(p);


    let _pp = pn;


    // middle segments
    for (let i = 1; i < points.length; i++)
    {
        [pp, p, pn] = getSegment(
            points[i-1], 
            points[i],
            i == points.length-1 
            ? (closed ? points[0] : points[i])
            : points[i+1]);

        if (points[i].smooth)
            [pp, pn] = getSmoothPoint(points[i], pp, p, pn);
            
        bp.push(_pp, pp, p);
   
        _pp = pn;
    }


    if (bp.length > 3)
    {
        if (closed)
        {
            if (   equal(bp[0].x, bp.at(-1).x, 0.01)
                && equal(bp[0].y, bp.at(-1).y, 0.01))
            {
                // last segment
                [pp, p, pn] = getSegment(
                    points.at(-2), 
                    points.at( 0),
                    points.at( 1));

                if (points[0].smooth)
                    [pp, pn] = getSmoothPoint(points[0], pp, p, pn);

                bp[1]           = pn;
                bp[bp.length-2] = pp;
            }
            else
            {
                // last segment
                [pp, p, pn] = getSegment(
                    points.at(-1), 
                    points.at( 0),
                    points.at( 1));

                if (points[0].smooth)
                    [pp, pn] = getSmoothPoint(points[0], pp, p, pn);

                bp.push(_pp, pp, p);

                bp[1]           = pn;
                bp[bp.length-2] = pp;
            }
        }
        else // open
        {
            bp[1]           = addv(bp[0],     mulvs(unitv(subv(bp[2],     bp[0]    )), distance(bp[3],     bp[0]    )/3));
            bp[bp.length-2] = addv(bp.at(-1), mulvs(unitv(subv(bp.at(-3), bp.at(-1))), distance(bp.at(-4), bp.at(-1))/3));
        }
    }


    return bp;
}



function getSmoothPoint(point, pp, p, pn)
{
    if (point.smooth)
    {
        const smooth = point.smooth.value;
        
        pp = addv(p, mulvs(subv(pp, p), smooth));
        pn = addv(p, mulvs(subv(pn, p), smooth));
    }

    return [pp, pn];
}



function getSmoothSegment(_pointP, _point, _pointN)
{
    const _pp = point(_pointP.x.value, _pointP.y.value);
    let   _p  = point(_point .x.value, _point .y.value);
    const _pn = point(_pointN.x.value, _pointN.y.value);


    const v = subv(_pn, _pp);
    
    
    let a = angleDiff(
        angle(subv(_p, _pp)), 
        angle(subv(_pn, _p)));

    a = Math.abs(a);
    while (a >= Tau/2) a -= Tau;


    const k     = 4 * (Math.sqrt(2) - 1) / 3;        // or use the value 0.55191502449 from http://spencermortensen.com/articles/bezier-circle/
	const kCorr = 0.9993391093366649465402826439248; // slight improvement (see Bézier Curves p. 13, Gernot Hoffmann);

    let f =
        a > Tau/4
        ? 1/3 + (k*kCorr - 1/3) * Math.sin(a)
        : 1/3 + (k*kCorr - 1/3) * (1 - Math.cos(a));
    

    let pp = addv(_p, mulvs(unitv(v), -lengthv(v)/2 * f));
    let pn = addv(_p, mulvs(unitv(v),  lengthv(v)/2 * f));

    pp = saltv(pp); // add salt to get around Figma's issue 
    _p = saltv(_p); // with straight otrhogonal bezier lines
    pn = saltv(pn);


    return [pp, _p, pn];
}



function getSineXSegment(_pointP, _point, _pointN)
{
    const _pp = point(_pointP.x.value, _pointP.y.value);
    const _p  = point(_point .x.value, _point .y.value);
    const _pn = point(_pointN.x.value, _pointN.y.value);

    const  pp = point(_p.x - (_p.x - _pp.x) * 0.3615, _p.y);
    const  pn = point(_p.x + (_pn.x - _p.x) * 0.3615, _p.y);

    return [pp, _p, pn];
}



function getSineYSegment(_pointP, _point, _pointN)
{
    const _pp = point(_pointP.x.value, _pointP.y.value);
    const _p  = point(_point .x.value, _point .y.value);
    const _pn = point(_pointN.x.value, _pointN.y.value);

    const  pp = point(_p.x, _p.y - (_p.y - _pp.y) * 0.3615);
    const  pn = point(_p.x, _p.y + (_pn.y - _p.y) * 0.3615);

    return [pp, _p, pn];
}


class FigmaVectorNetwork
extends FigmaShape
{
    x;
    y;
    width;
    height;
    
    points;
    edges;
    regions;

    networkData;



    constructor(nodeId, objectId, objectName, points, edges, regions)
    {
        super(VECTOR_NETWORK, nodeId, objectId, objectName);
        
        this.points  = points .map(p => p.copy());
        this.edges   = edges  .map(e => e.copy());
        this.regions = regions.map(r => r.copy());


        this.updateNetworkData();


        let bounds = Rect.NaN;

        for (let i = 0; i < this.edges.length; i++)
        {
            bounds = expandRect(
                bounds, 
                bounds3(
                    this.edges[i].start.toPoint(), 
                    this.edges[i].start.toPoint(),
                    this.edges[i].end  .toPoint(),
                    this.edges[i].end  .toPoint()));
        }

        this.createDefaultSpace(
            bounds.x + bounds.width /2,            
            bounds.y + bounds.height/2            
        );
    }



    copy()
    {
        const copy = new FigmaVectorNetwork(
            this.nodeId,
            this.objectId,
            this.objectName,

            this.points, 
            this.edges, 
            this.regions);


        copy.x      = this.x;
        copy.y      = this.y;
        copy.width  = this.width;
        copy.height = this.height;


        copy.copyBase(this);


        return copy;
    }



    updateNetworkData()
    {
        let minX = Number.MAX_SAFE_INTEGER;
        let minY = Number.MAX_SAFE_INTEGER;
        let maxX = Number.MIN_SAFE_INTEGER;
        let maxY = Number.MIN_SAFE_INTEGER;

        for (const p of this.points)
        {
            minX = Math.min(minX, p.x.value);
            minY = Math.min(minY, p.y.value);
            maxX = Math.max(maxX, p.x.value);
            maxY = Math.max(maxY, p.y.value);
        }


        this.x      = minX;
        this.y      = minY;
        this.width  = maxX - minX;
        this.height = maxY - minY;

        this.createDefaultTransformPoints(this.x, this.y, this.width, this.height);


        this.networkData = getNetworkData(this.points, this.edges, this.regions);
    }



    getBounds()
    {
        let bounds = Rect.NaN;

        for (let i = 0; i < this.edges.length; i++)
        {
            bounds = expandRect(
                bounds, 
                bounds3(
                    this.edges[i].start.toPoint(), 
                    this.edges[i].start.toPoint(),
                    this.edges[i].end  .toPoint(),
                    this.edges[i].end  .toPoint()));
        }

        return bounds;
    }



    toData()
    {
        return [
            ...super.toData(),
   
            /* 21 */ this.x,
            /* 22 */ this.y,
            /* 23 */ this.width,
            /* 24 */ this.height,

            /* 25 */ this.networkData
        ];
    }
}



function getNetworkData(points, edges, _regions)
{
    const vertices = [];
    const segments = [];
    const regions  = [];


    for (const point of points)
    {
        let join;
        let cap;

        switch (point.join.value)
        {
            case 0: join = 'MITER'; break;
            case 1: join = 'BEVEL'; break;
            case 2: join = 'ROUND'; break;
        }
    
        switch (point.cap.value)
        {
            case 0: cap = 'NONE';   break;
            case 1: cap = 'SQUARE'; break;
            case 2: cap = 'ROUND';  break;
        }
    
        vertices.push(
        {
            x:            point.x.value,
            y:            point.y.value,
            strokeJoin:   join,
            strokeCap:    cap,
            cornerRadius: point.round.value
        });
    }


    for (const edge of edges)
    {
        segments.push(
        {
            start: points.findIndex(p => p.uniqueId == edge.start.uniqueId),
            end:   points.findIndex(p => p.uniqueId == edge.end  .uniqueId)
        });
    }


    for (const region of _regions)
    {
        const loops = [];

        for (const _loop of region.loops.items)
        {
            const loop = [];

            for (const _edge of _loop.items)
                loop.push(edges.findIndex(e => e.uniqueId == _edge.uniqueId));

            loops.push(loop);
        }


        regions.push(
        {
            windingRule: region.winding.value == 1 ? 'NONZERO' : 'EVENODD',
            loops:       loops,
            fills:       getObjectFills(region.fills)
        });
    }


    let networkData = 
    {
        vertices: vertices,
        segments: segments,
        regions:  regions
    };


    return networkData;
}


class FigmaTrapeze
extends FigmaVectorPath
{
    width;
    height;

    round;
    bias;



    constructor(nodeId, objectId, objectName, x, y, width, height, round, bias)
    {
        const tw = width * (1 + Math.min(0,  bias/100));
        const bw = width * (1 + Math.min(0, -bias/100));
        
        const tx = x + (width - tw) / 2;
        const bx = x + (width - bw) / 2;

        const points =
        [
            PointValue.create(nodeId, tx,      y         ),
            PointValue.create(nodeId, bx,      y + height),
            PointValue.create(nodeId, bx + bw, y + height),
            PointValue.create(nodeId, tx + tw, y         )
        ];

    
        super(
            nodeId, 
            objectId,
            objectName, 
            points,
            1, // closed
            0, // linear
            0, // even-odd winding
            round);

        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;

        this.round  = round;
        this.bias   = bias;

        
        this.createDefaultSpace(
            x + width /2, 
            y + height/2);

        // let bounds = this.getBounds();

        // this.createDefaultSpace(
        //     bounds.x + bounds.width /2,            
        //     bounds.y + bounds.height/2            
        // );
    }



    copy()
    {
        const copy = new FigmaTrapeze(
            this.nodeId,
            this.objectId,
            this.objectName,

            this.x,
            this.y,
            this.width,
            this.height,
            
            this.round,
            this.bias);


        copy.x      = this.x;
        copy.y      = this.y;
        copy.width  = this.width;
        copy.height = this.height;


        copy.copyBase(this);

        
        return copy;
    }
}



class FigmaPolygon
extends FigmaShape
{
    x;
    y;
    width;
    height;
    round;
    corners;



    constructor(nodeId, objectId, objectName, x, y, width, height, round, corners)
    {
        super(POLYGON, nodeId, objectId, objectName);
        
        this.x       = x;
        this.y       = y;
        this.width   = width;
        this.height  = height;

        this.round   = round;
        this.corners = corners;

        
        this.createDefaultSpace(
            x + width /2, 
            y + height/2);
    }



    copy()
    {
        const copy = new FigmaPolygon(
            this.nodeId,
            this.objectId,
            this.objectName,

            this.x,
            this.y,
            this.width,
            this.height,
            
            this.round,
            this.corners);


        copy.copyBase(this);


        return copy;
    }



    toData()
    {
        return [
            ...super.toData(),
   
            /* 23 */ this.x,
            /* 24 */ this.y,
            /* 25 */ this.width,
            /* 26 */ this.height,

            /* 27 */ this.round * Math.abs(this.scaleCorners),
            /* 28 */ this.corners
        ];
    }
}



class FigmaStar
extends FigmaShape
{
    x;
    y;
    width;
    height;

    round;
    points;
    convex;



    constructor(nodeId, objectId, objectName, x, y, width, height, round, points, convex)
    {
        super(STAR, nodeId, objectId, objectName);
        
        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;

        this.round  = round;
        this.points = points;
        this.convex = convex;

        
        this.createDefaultSpace(
            x + width /2, 
            y + height/2);
    }



    copy()
    {
        const copy = new FigmaStar(
            this.nodeId,
            this.objectId,
            this.objectName,

            this.x,
            this.y,
            this.width,
            this.height,

            this.round,
            this.points,
            this.convex);

        copy.copyBase(this);

        return copy;
    }


    toData()
    {
        return [
            ...super.toData(),
   
            /* 23 */ this.x,
            /* 24 */ this.y,
            /* 25 */ this.width,
            /* 26 */ this.height,

            /* 27 */ this.round * Math.abs(this.scaleCorners),
            /* 28 */ this.points,
            /* 29 */ this.convex
        ];
    }
}



class FigmaText
extends FigmaShape
{
    text;
    
    x;
    y;
    width;
    height;
    
    figWidth;
    figHeight;
    
    font;
    size;
    style;
    
    alignH;
    alignV;
    
    lineHeight;
    letterSpacing;



    constructor(nodeId, objectId, objectName, text, x, y, width, height, font, size, style, alignH, alignV, lineHeight, letterSpacing)
    {
        super(TEXT_SHAPE, nodeId, objectId, objectName);
        
        this.text          = text;
    
        this.x             = x;
        this.y             = y;
        this.width         = width;
        this.height        = height;
    
        this.figWidth      = width;
        this.figHeight     = height;
    
        this.font          = font;
        this.size          = size;
        this.style         = style;
    
        this.alignH        = alignH;
        this.alignV        = alignV;
    
        this.lineHeight    = lineHeight;
        this.letterSpacing = letterSpacing;

        
        this.createDefaultSpace(
            x + width /2, 
            y + height/2);
    }



    copy()
    {
        const copy = new FigmaText(
            this.nodeId,
            this.objectId,
            this.objectName,
    
            this.text,
    
            this.x,
            this.y,
            this.width,
            this.height,
    
            this.font,
            this.size,
            this.style,
    
            this.alignH,
            this.alignV,
    
            this.lineHeight,
            this.letterSpacing);


        copy.figWidth  = this.figWidth;
        copy.figHeight = this.figHeight;


        copy.copyBase(this);


        return copy;
    }



    toJsonObject()
    {
        return {
            ...super.toJsonObject(),
   
            x:             this.x,
            y:             this.y,
            width:         this.width,
            height:        this.height,

            figWidth:      this.figWidth,
            figHeight:     this.figHeight,

            text:          this.text,

            font:          this.font,
            size:          this.size,
            style:         this.style,

            alignH:        this.alignH,
            alignV:        this.alignV,
            
            lineHeight:    this.lineHeight,
            letterSpacing: this.letterSpacing
        };
    }



    toData()
    {
        return [
            ...super.toData(),
   
            /* 23 */ this.x,
            /* 24 */ this.y,
            /* 25 */ this.width,
            /* 26 */ this.height,
            
            /* 27 */ this.figWidth,
            /* 28 */ this.figHeight,
            
            /* 29 */ this.text,

            /* 30 */ this.font,
            /* 31 */ this.size,
            /* 32 */ this.style,
            
            /* 33 */ this.alignH,
            /* 34 */ this.alignV,
            
            /* 35 */ this.lineHeight,
            /* 36 */ this.letterSpacing
        ];
    }
}



class FigmaPoint
extends FigmaShape
{
    x;
    y;
    smooth;
    isCenter;



    constructor(nodeId, objectId, objectName, x, y, smooth = 1, isDeco = false, isCenter = false, isXform = false)
    {
        super(POINT, nodeId, objectId, objectName, isDeco, isXform);
        
        this.x        = x;
        this.y        = y;
        this.smooth   = smooth;
        this.isCenter = isCenter;

        
        this.createDefaultSpace(x, y);

        this.createDefaultTransform(x, y);
    }



    copy()
    {
        const copy = new FigmaPoint(
            this.nodeId,
            this.objectId,
            this.objectName, 
            this.x,
            this.y,
            this.smooth,
            this.isDeco,
            this.isCenter);

        copy.copyBase(this);

        return copy;
    }



    getBounds()
    {
        return new Rect(
            this.x - 0.005, 
            this.y - 0.005, 
            0.01, 
            0.01);
    }



    toPoint()
    {
        return point(this.x, this.y);
    }



    toData()
    {
        return [
            ...super.toData(),
   
            /* 23 */ this.x,
            /* 24 */ this.y,
            /* 25 */ this.isCenter
        ];
    }
}



class FigmaBoolean
extends FigmaShape
{
    operation;
    children;



    constructor(nodeId, objectId, objectName, operation, children = [])
    {
        super(BOOLEAN, nodeId, objectId, objectName);
        
        this.operation = operation;
        this.children  = children.map(c => c.copy());
    }



    copy()
    {
        const copy = new FigmaBoolean(
            this.nodeId,
            this.objectId,
            this.objectName,
            this.operation,
            this.children);

        copy.copyBase(this);

        return copy;
    }



    toJsonObject()
    {
        return {
            ...super.toJsonObject(),
   
            operation: this.operation,
            children:  this.children
        };
    }
}


class FigmaShapeGroup
extends FigmaShape
{
    children;



    constructor(nodeId, objectId, objectName, children = [])
    {
        super(SHAPE_GROUP, nodeId, objectId, objectName);
        
        this.children = children.map(c => c.copy());
    }



    copy()
    {
        const copy = new FigmaShapeGroup(
            this.nodeId,
            this.objectId,
            this.objectName,

            this.children);

        copy.copyBase(this);

        return copy;
    }



    toJsonObject()
    {
        return {
            ...super.toJsonObject(),
   
            children: this.children
        };
    }



    toData()
    {
        return [
            ...super.toData(),
   
            /* 23 */ this.children.map(o => o.toData())
        ];
    }
}


class FigmaFrame
extends FigmaShape
{
    x;
    y;
    width;
    height;

    round;
    
    children;



    constructor(nodeId, objectId, objectName, x, y, width, height, round, children = [])
    {
        super(FRAME, nodeId, objectId, objectName);
        
        this.x        = x;
        this.y        = y;
        this.width    = width;
        this.height   = height;
    
        this.round    = round;
    
        this.children = children.map(c => c.copy());

        this.createDefaultSpace(
            x + width /2, 
            y + height/2);
    }



    copy()
    {
        const copy = new FigmaFrame(
            this.nodeId,
            this.objectId,
            this.objectName,
    
            this.x,
            this.y,
            this.width,
            this.height,
    
            this.round,
    
            this.children);


        copy.copyBase(this);


        return copy;
    }



    toJsonObject()
    {
        return {
            ...super.toJsonObject(),
   
            x:        this.x,
            y:        this.y,
            width:    this.width,
            height:   this.height,
        
            round:    this.round,
        
            children: this.children
        };
    }



    toData()
    {
        return [
            ...super.toData(),
   
            /* 23 */ this.x,
            /* 24 */ this.y,
            /* 25 */ this.width,
            /* 26 */ this.height,

            /* 27 */ this.round,

            /* 28 */ this.children.map(o => o.toData())
        ];
    }
}






class FigmaColorStyle
{
    type;
    
    nodeId = '';

    styleId;
    styleName;

    paints = [];

//    existing;



    constructor(nodeId, styleId, styleName)
    {
        this.type      = COLOR_STYLE;
        this.nodeId    = nodeId;

        this.styleId   = styleId;
        this.styleName = styleName;
    }



    copy()
    {
        const copy = new FigmaColorStyle(this.nodeId, this.styleId, this.styleName);

//        copy.existing = this.existing;

        return copy;
    }



    toData()
    {
        return [
        /* 0 */ this.type,
        /* 1 */ this.nodeId,

        /* 2 */ this.styleId,
        /* 3 */ this.styleName,
        
        /* 4 */ this.paints
        ];
    }
}


class GNode
{
    static nextUniqueId = 0;

    type;


    valid; // has been evaluated

    listId        = -1;
    uniqueId;

    cached        = true;
    unknown       = false;

    loopId        = NULL;

    iteration     = 0;
    iterated      = false;


    updateValues  = null;



    constructor(type, options) 
    {
        this.type    = type;

        if (options && options.cached ) this.cached  = options.cached;
        if (options && options.unknown) this.unknown = options.unknown;
     
        this.uniqueId = GNode.nextUniqueId++;
    }



    reset()
    {
        //this.listId       = -1;
    
        //this.cached       = true;
        //this.unknown      = false;
    
        //this.loopId       = NULL;
    
        //this.iteration    = 0;
        //this.iterated     = false;
    
        this.updateValues = null;
    }



    copy()
    {
        consoleError('abstract type GNode cannot be copied');
        return null;
    }



    copyBase(base)
    {
        //this.data     = clone(base.data);
        this.uniqueId = base.uniqueId;
    }



    getOrderNode()
    {
        if (   this.input
            && this.input.getOrderNode)
            return this.input.getOrderNode();
        
        return this;
    }

    

    toValue()
    {
        return null;
    }



    toString() 
    { 
        return this.type; 
    }



    toJson()
    {
        return this.toString();
    }



    isValid() // is a valid value
    {
        return false;
    }


    
    validate()
    {
        this.valid = true;
    }



    pushValueUpdates(parse)
    {

    }



    invalidateInputs(parse, from, force = false)
    {
        if (   this.unknown
            || force)
            this.valid = false;

        return true;
    }



    initLoop(parse, nodeId)
    {

    }



    invalidateLoop(parse, nodeId)
    {

    }



    iterateLoop(parse)
    {

    }



    resetLoop(parse, nodeId)
    {

    }    
}



class GValue
//extends GNode
{
    type;
    valueId;

    customParams = []; // [[name, GValue]]

    objects = null;



    constructor(type) 
    {
        //super(type, options);

        this.type = type;


        this.valueId = '';
    }



    reset() {}



    copy()
    {
        consoleError('abstract class GValue cannot be copied');
        return null;
    }



    copyBase(base)
    {
        //super.copyBase(base);
        
        this.valueId = base.valueId;

        this.copyCustomParams(base);

        if (base.objects)
            this.copyObjects(base.objects);
    }



    copyCustomParams(base)
    {
        for (const param of base.customParams)
            this.customParams.push([param[0], param[1].copy()]);
    }



    copyObjects(objects)
    {
        this.objects = objects.map(o => o.copy());
    }



    // eval()
    // {
    //     return this;
    // }



    hasInitValue()
    {
        return false;
    }



    toValue()
    {
        return this.copy();
    }



    toJson() 
    { 
        return this.toString(); 
    }



    toString() 
    { 
        return this.type; 
    }



    toDisplayString()
    {
        return this.toString();
    }



    toJsCode(gen)
    {
        consoleError('invalid abstract method');
        return '';
    }



    getNaN()
    {
        consoleError('invalid abstract method');
        return null;
    }



    isCached()
    {
        return true;
    }



    pushValueUpdates(parse)              {}
    invalidateInputs(parse, from, force) {}
    iterateLoop     (parse)              {}
}



function parseValueFromType(type, value)
{
    switch (type)
    {
        case           LIST_VALUE: 
        case    NUMBER_LIST_VALUE: 
        case      TEXT_LIST_VALUE: 
        case     SHAPE_LIST_VALUE: return parseListValue         (value)[0];

        case         NUMBER_VALUE: return parseNumberValue       (value)[0];
        case           TEXT_VALUE: return parseTextValue         (value)[0];
        case          COLOR_VALUE: return parseColorValue        (value)[0];

        case           FILL_VALUE: return parseFillValue         (value)[0];
        case     COLOR_STOP_VALUE: return parseColorStopValue    (value)[0];
        case       GRADIENT_VALUE: return parseGradientValue     (value)[0];
        case         STROKE_VALUE: return parseStrokeValue       (value)[0];
        case    DROP_SHADOW_VALUE: return parseDropShadowValue   (value)[0];
        case   INNER_SHADOW_VALUE: return parseInnerShadowValue  (value)[0];
        case     LAYER_BLUR_VALUE: return parseLayerBlurValue    (value)[0];
        case      BACK_BLUR_VALUE: return parseBackBlurValue     (value)[0];
        case    LAYER_BLEND_VALUE: return parseLayerBlendValue   (value)[0];
        case     LAYER_MASK_VALUE: return parseLayerMaskValue    (value)[0];

        case      RECTANGLE_VALUE: return parseRectangleValue    (value)[0];
        case           LINE_VALUE: return parseLineValue         (value)[0];
        case        ELLIPSE_VALUE: return parseEllipseValue      (value)[0];
        case        TRAPEZE_VALUE: return parseTrapezeValue      (value)[0];
        case        POLYGON_VALUE: return parsePolygonValue      (value)[0];
        case           STAR_VALUE: return parseStarValue         (value)[0];
        case     TEXT_SHAPE_VALUE: return parseTextShapeValue    (value)[0];
        case          POINT_VALUE: return parsePointValue        (value)[0];
        case    VECTOR_PATH_VALUE: return parseVectorPathValue   (value)[0];
        case  VECTOR_VERTEX_VALUE: return parseVectorVertexValue (value)[0];
        case    VECTOR_EDGE_VALUE: return parseVectorEdgeValue   (value)[0];
        case  VECTOR_REGION_VALUE: return parseVectorRegionValue (value)[0];
        case VECTOR_NETWORK_VALUE: return parseVectorNetworkValue(value)[0];
        case        BOOLEAN_VALUE: return parseShapeBooleanValue (value)[0];
        case    SHAPE_GROUP_VALUE: return parseShapeGroupValue   (value)[0];
        case          FRAME_VALUE: return parseFrameValue        (value)[0];
        
        default: 
            console.error('unknown type \'' + type + '\'');
            return null;
    }
}



function displayValue(type, value)
{
    if (   type == NUMBER_VALUE
        && value.indexOf(',') < 0)
        return value;


    switch (type)
    {
        case           LIST_VALUE: return parseListValue         (value)[0].toDisplayString();

        case         NUMBER_VALUE: return parseNumberValue       (value)[0].toDisplayString();
        case           TEXT_VALUE: const val = parseTextValue    (value)[0]; return val == '' ? '\'\'' : val.toDisplayString();
        case          COLOR_VALUE: return parseColorValue        (value)[0].toDisplayString();
        case           FILL_VALUE: return parseFillValue         (value)[0].toDisplayString();
        case     COLOR_STOP_VALUE: return parseColorStopValue    (value)[0].toDisplayString();
        case       GRADIENT_VALUE: return parseGradientValue     (value)[0].toDisplayString();
        case         STROKE_VALUE: return parseStrokeValue       (value)[0].toDisplayString();
        case    DROP_SHADOW_VALUE: return parseDropShadowValue   (value)[0].toDisplayString();
        case   INNER_SHADOW_VALUE: return parseInnerShadowValue  (value)[0].toDisplayString();
        case     LAYER_BLUR_VALUE: return parseLayerBlurValue    (value)[0].toDisplayString();
        case      BACK_BLUR_VALUE: return parseBackBlurValue     (value)[0].toDisplayString();
        case    LAYER_BLEND_VALUE: return parseLayerBlendValue   (value)[0].toDisplayString();
        case     LAYER_MASK_VALUE: return parseLayerMaskValue    (value)[0].toDisplayString();

        case      RECTANGLE_VALUE: return parseRectangleValue    (value)[0].toDisplayString();
        case           LINE_VALUE: return parseLineValue         (value)[0].toDisplayString();
        case        ELLIPSE_VALUE: return parseEllipseValue      (value)[0].toDisplayString();
        case        TRAPEZE_VALUE: return parseTrapezeValue      (value)[0].toDisplayString();
        case        POLYGON_VALUE: return parsePolygonValue      (value)[0].toDisplayString();
        case           STAR_VALUE: return parseStarValue         (value)[0].toDisplayString();
        case     TEXT_SHAPE_VALUE: return parseTextShapeValue    (value)[0].toDisplayString();
        case          POINT_VALUE: return parsePointValue        (value)[0].toDisplayString();
        case    VECTOR_PATH_VALUE: return parseVectorPathValue   (value)[0].toDisplayString();
        case  VECTOR_VERTEX_VALUE: return parseVectorVertexValue (value)[0].toDisplayString();
        case    VECTOR_EDGE_VALUE: return parseVectorEdgeValue   (value)[0].toDisplayString();
        case  VECTOR_REGION_VALUE: return parseVectorRegionValue (value)[0].toDisplayString();
        case VECTOR_NETWORK_VALUE: return parseVectorNetworkValue(value)[0].toDisplayString();
        case        BOOLEAN_VALUE: return parseShapeBooleanValue (value)[0].toDisplayString();
        case    SHAPE_GROUP_VALUE: return parseShapeGroupValue   (value)[0].toDisplayString();
        case          FRAME_VALUE: return parseFrameValue        (value)[0].toDisplayString();
    }


    consoleError('cannot display value of type \'' + type + '\'');
}



function nanFromType(type)
{
    switch (type)
    {
        case            LIST_VALUE: return          ListValue.NaN;

        case          NUMBER_VALUE: return        NumberValue.NaN;
        case            TEXT_VALUE: return        new TextValue();
        case           COLOR_VALUE: return         ColorValue.NaN;
        case            FILL_VALUE: return          FillValue.NaN;
        case      COLOR_STOP_VALUE: return     ColorStopValue.NaN;
        case        GRADIENT_VALUE: return      GradientValue.NaN;
        case          STROKE_VALUE: return        StrokeValue.NaN;
        case     DROP_SHADOW_VALUE: return    DropShadowValue.NaN;
        case    INNER_SHADOW_VALUE: return   InnerShadowValue.NaN;
        case      LAYER_BLUR_VALUE: return     LayerBlurValue.NaN;
        case       BACK_BLUR_VALUE: return      BackBlurValue.NaN;
        case     LAYER_BLEND_VALUE: return    LayerBlendValue.NaN;
        case      LAYER_MASK_VALUE: return     LayerMaskValue.NaN;

        case       RECTANGLE_VALUE: return     RectangleValue.NaN;
        case            LINE_VALUE: return          LineValue.NaN;
        case         ELLIPSE_VALUE: return       EllipseValue.NaN;
        case         POLYGON_VALUE: return       PolygonValue.NaN;
        case            STAR_VALUE: return          StarValue.NaN;
        case      TEXT_SHAPE_VALUE: return     TextShapeValue.NaN;
        case           POINT_VALUE: return         PointValue.NaN;
        case     VECTOR_PATH_VALUE: return    VectorPathValue.NaN;
        case   VECTOR_VERTEX_VALUE: return  VectorVertexValue.NaN;
        case     VECTOR_EDGE_VALUE: return    VectorEdgeValue.NaN;
        case   VECTOR_REGION_VALUE: return  VectorRegionValue.NaN;
        case  VECTOR_NETWORK_VALUE: return VectorNetworkValue.NaN;
        case         BOOLEAN_VALUE: return  ShapeBooleanValue.NaN;
        case     SHAPE_GROUP_VALUE: return    ShapeGroupValue.NaN;
        case           FRAME_VALUE: return         FrameValue.NaN;
    }

    consoleError('cannot determine null value from type \'' + type + '\'');
}


class GOperator
extends GNode
{
    nodeId;
    nodeName;

    topLevel;

    value;
    
    customParams = []; // [[name, GValue]]
    options      = {};
    updateValues = [];

   
    
    constructor(type, nodeId, options)
    {
        super(type, options);

        this.nodeId   = nodeId;
        this.nodeName = options.nodeName;

        this.options  = clone(options);

        this.valid    = false;
        this.topLevel = false;

        this.value    = null;
    }



    reset()
    {
        super.reset();
        
        this.customParams = [];
        this.options      = {};
        this.updateValues = [];
    }



    copyBase(base)
    {
        super.copyBase(base);
        
        this.nodeId       = base.nodeId;
        this.nodeName     = base.nodeName;

        this.copyCustomParams(base);

        this.options      = clone(base.options);

        this.valid        = base.valid;
        this.topLevel     = base.topLevel;

        if (base.value) 
            this.value = base.value.copy();
    }



    copyCustomParams(base)
    {
        for (const param of base.customParams)
            this.customParams.push([param[0], param[1].copy()]);
    }



    paramFromId(paramId)
    {
        return paramId == 'value'
            ?  this.value
            :  this[paramId];
    }



    isCached()
    {
        return this.options.cached
            && this.valid;
    }



    async eval(parse)
    {
        // calculate and add value update here

        return this;
    }



    async evalObjects(parse)
    {

    }



    copyObjects(value, listId = -1)
    {
        const objects = getValidObjects(value);
        const copies  = [];
                        
        for (let i = 0; i < objects.length; i++)//, o++)
        {
            const obj = copyFigmaObject(objects[i]);
    
            obj.nodeId   = this.nodeId;
            obj.listId   = listId;
            
            obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;
    
            copies.push(obj);
        }

        return copies;
    }
    
    

    outputType()
    {
        return this.value
            ? new TextValue(
                isListType(this.value.type)
                ? finalListTypeFromItems(this.value.items)
                : this.value.type)
            : TextValue.NaN;
    }



    outputListType()
    {
        return this.outputType();
        //return this.value
        //     ? new TextValue(finalListTypeFromItems(this.value.items))
        //     : TextValue.NaN.copy();
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        //if (this.unknown)
            this.valid = false;

        this.iterated = false;
    }



    initLoop(parse, nodeId)
    {
        this.loopId    = nodeId;
        this.iteration = 0;
    }



    invalidateLoop(parse, nodeId)
    {
        this.valid = false;
    }



    iterateLoop(parse)
    {
        const repeatIndex = parse.repeats.findIndex(r => r.repeatId == this.loopId);
        
        // if (this.nodeId == 'sequence')
        // {
        //     console.log('repeatIndex = ', repeatIndex);
        //     console.log('this.iterated = ', this.iterated);
        // }

        if (   (   repeatIndex < 0
                || repeatIndex == parse.repeats.length-1)
            && !this.iterated)
        {
            //console.log('iterating');
            this.iteration++;
            this.iterated = true;
        }
    }



    resetLoop(parse, nodeId)
    {
        this.valid     = false;
        this.iteration = 0;
    }    



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    setUpdateValues(parse, values, add = false)
    {
        if (    parse.repeats.length == 0
            ||  this.unknown && parse.repeats[0].total == 0
            || !this.unknown
            ||  parse.repeats.at(-1).iteration == 0
            ||  parse.repeats.at(-1).iteration == parse.repeats.at(-1).total-1)
        {
            if (add) this.updateValues.push(...values);
            else     this.updateValues = [...values];
        }
        else if (!add)
            this.updateValues = [];
    }



    pushValueUpdates(parse)
    {
        if (!this.updateValues)
            return;

        for (const value of this.updateValues)
            genPushUpdateValue(parse, this.nodeId, value[0], value[1]);

        if (this.isValid())
            this.updateValues = [];
    }



    updateValueObjects()
    {
        if (   !this.value
            || !this.value.objects)
            return;


        for (let i = 0; i < this.value.objects.length; i++)
        {
            const obj    = this.value.objects[i];

            obj.nodeId   = this.nodeId;
            obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;
            obj.listId   = -1;
        }
    }



    // resetNode()
    // {
    //     for (const prop in this)
    //     {
    //         if (this.hasOwnProperty(prop))
    //         {
    //             if (   this[prop]
    //                 && this[prop].resetNode)
    //                 this[prop].resetNode();

    //             this[prop] = null;
    //         }
    //     }
    // }
}


class GOperator1
extends GOperator
{
    input = null;



    reset()
    {
        super.reset();

        this.input = null;
    }



    copyBase(base)
    {
        super.copyBase(base);

        if (base.input) this.input = base.input.copy();
    }



    isCached()
    {
        return super.isCached()
            && (  !this.input 
                || this.input.isCached());
    }



    isValid()
    {
        return this.input && this.input.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input) this.input.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.input) this.input.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input) this.input.iterateLoop(parse);
    }
}


class GOperator2
extends GOperator
{
    input0 = null;
    input1 = null;



    reset()
    {
        super.reset();

        this.input0 = null;
        this.input1 = null;
    }



    copyBase(base)
    {
        super.copyBase(base);

        if (base.input0) this.input0 = base.input0.copy();
        if (base.input1) this.input1 = base.input1.copy();
    }



    isCached()
    {
        return super.isCached()
            && (!this.input0 || this.input0.isCached())
            && (!this.input1 || this.input1.isCached());
    }



    inputNameFromNode(node)
    {
        return this.input0 && this.input0.nodeId == node.nodeId
            || this.input1 && this.input1.nodeId == node.nodeId;
    }



    isValid()
    {
        return this.input0 && this.input0.isValid()
            && this.input1 && this.input1.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input0) this.input0.pushValueUpdates(parse);
        if (this.input1) this.input1.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.input0) this.input0.invalidateInputs(parse, from, force);
        if (this.input1) this.input1.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input0) this.input0.iterateLoop(parse);
        if (this.input1) this.input1.iterateLoop(parse);
    }
}


class GOperator3
extends GOperator
{
    input0 = null;
    input1 = null;
    input2 = null;



    reset()
    {
        super.reset();

        this.input0 = null;
        this.input1 = null;
        this.input2 = null;
    }



    copyBase(base)
    {
        super.copyBase(base);

        if (base.input0) this.input0 = base.input0.copy();
        if (base.input1) this.input1 = base.input1.copy();
        if (base.input2) this.input2 = base.input2.copy();
    }



    isCached()
    {
        return super.isCached()
            && (!this.input0 || this.input0.isCached())
            && (!this.input1 || this.input1.isCached())
            && (!this.input2 || this.input2.isCached());
    }



    inputNameFromNode(node)
    {
        return this.input0 && this.input0.nodeId == node.nodeId
            || this.input1 && this.input1.nodeId == node.nodeId
            || this.input2 && this.input2.nodeId == node.nodeId;
    }



    isValid()
    {
        return this.input0 && this.input0.isValid()
            && this.input1 && this.input1.isValid()
            && this.input2 && this.input2.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input0) this.input0.pushValueUpdates(parse);
        if (this.input1) this.input1.pushValueUpdates(parse);
        if (this.input2) this.input2.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.input0) this.input0.invalidateInputs(parse, from, force);
        if (this.input1) this.input1.invalidateInputs(parse, from, force);
        if (this.input2) this.input2.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input0) this.input0.iterateLoop(parse);
        if (this.input1) this.input1.iterateLoop(parse);
        if (this.input2) this.input2.iterateLoop(parse);
    }
}


class GOperator4
extends GOperator
{
    input0 = null;
    input1 = null;
    input2 = null;
    input3 = null;



    reset()
    {
        super.reset();

        this.input0 = null;
        this.input1 = null;
        this.input2 = null;
        this.input3 = null;
    }



    copyBase(base)
    {
        super.copyBase(base);

        if (base.input0) this.input0 = base.input0.copy();
        if (base.input1) this.input1 = base.input1.copy();
        if (base.input2) this.input2 = base.input2.copy();
        if (base.input3) this.input3 = base.input3.copy();
    }



    isCached()
    {
        return super.isCached()
            && (!this.input0 || this.input0.isCached())
            && (!this.input1 || this.input1.isCached())
            && (!this.input2 || this.input2.isCached())
            && (!this.input3 || this.input3.isCached());
    }



    inputNameFromNode(node)
    {
        return this.input0 && this.input0.nodeId == node.nodeId
            || this.input1 && this.input1.nodeId == node.nodeId
            || this.input2 && this.input2.nodeId == node.nodeId
            || this.input3 && this.input3.nodeId == node.nodeId;
    }



    isValid()
    {
        return this.input0 && this.input0.isValid()
            && this.input1 && this.input1.isValid()
            && this.input2 && this.input2.isValid()
            && this.input3 && this.input3.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input0) this.input0.pushValueUpdates(parse);
        if (this.input1) this.input1.pushValueUpdates(parse);
        if (this.input2) this.input2.pushValueUpdates(parse);
        if (this.input3) this.input3.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.input0) this.input0.invalidateInputs(parse, from, force);
        if (this.input1) this.input1.invalidateInputs(parse, from, force);
        if (this.input2) this.input2.invalidateInputs(parse, from, force);
        if (this.input3) this.input3.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input0) this.input0.iterateLoop(parse);
        if (this.input1) this.input1.iterateLoop(parse);
        if (this.input2) this.input2.iterateLoop(parse);
        if (this.input3) this.input3.iterateLoop(parse);
    }
}


class GParam
extends GOperator
{
    paramId;
    
    node;
    param;
    


    constructor(nodeId, paramId)
    {
        super(PARAM, nodeId, false);

        this.paramId = paramId;
    }



    reset()
    {
        if (this.node)
            this.node.reset();
    }



    copy()
    {
        const copy = new GParam(this.nodeId, this.paramId);

        copy.copyBase(this);

        copy.node = this.node;
    
        return copy;
    }



    getOrderNode()
    {
        return this.node
             ? this.node.getOrderNode()
             : null;
    }



    async eval(parse)
    {
        this.node = parse.parsedNodes.find(v => v.nodeId == this.nodeId);
        consoleAssert(this.node, 'can\'t find parameter node \'' + this.nodeId + '\'');


        await this.node.eval(parse);


        this.param = this.node.paramFromId(this.paramId);

        if (this.node.type == LIST)
            this.param = this.node[this.paramId];//.copy();

        
        if (isValid(this.param))
        {
            const value = (await this.param.eval(parse)).toValue();
            this.value = value;
            
            return this.value;
        }
        else
            return this.value = NullValue.copy();
    }



    isCached()
    {
        return super.isCached();
//            && this.node.isCached();
    }



    toValue()
    {
        return this.value.copy();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.node) this.node.pushValueUpdates(parse);
    }


    
    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.node) this.node.invalidateInputs(parse, from, force);
    }



    initLoop(parse, nodeId)
    {
        const node = parse.parsedNodes.find(n => n.nodeId == this.nodeId);
        node.initLoop(parse, nodeId);
    }



    invalidateLoop(parse, nodeId)
    {
        const node = parse.parsedNodes.find(n => n.nodeId == this.nodeId);
        node.invalidateLoop(parse, nodeId);
    }



    iterateLoop(parse)
    {
        const node = parse.parsedNodes.find(n => n.nodeId == this.nodeId);
        node.iterateLoop(parse);
    }



    resetLoop(parse, nodeId)
    {
        const node = parse.parsedNodes.find(n => n.nodeId == this.nodeId);
        node.resetLoop(parse, nodeId);
    }
}


class ListValue
extends GValue
{
    items;

    condensed = false;



    constructor(items = [])
    {
        super(LIST_VALUE);

        if (items)
        {
            this.items = [];

            for (const item of items)
            {
                this.items.push(item.copy());

                if (   this.objects
                    && item.objects)
                    this.objects.push(...item.objects.map(o => o.copy()));
            }
        }
    }



    copy()
    {
        const copy = new ListValue(this.items);

        copy.copyBase(this);

        copy.condensed = this.condensed;

        return copy;
    }



    equals(list)
    {
        if (!list)                                  return false;
        if (!(list instanceof ListValue))           return false;
        if (this.items.length != list.items.length) return false;
            
        for (let i = 0; i < this.items.length; i++)
            if (!this.items[i].equals(list.items[i]))
                return false;

        return true;
    }



    async eval(parse)
    {
        return this;
    }



    toValue()
    {
        return this.copy();
    }



    hasInitValue()
    {
        if (!this.items)
            return false;
            
        for (const item of this.items)
            if (!item.hasInitValue())
                return false;

        return true;
    }



    isValid()
    {
        //console.log('invalid =', this.items.find(i => !i.isValid()));
        return  this.items;
        //    && !this.items.find(i => !i.isValid());
    }



    toJson()
    {
        if (!this.items)
            return '';


        let str = '';
        
        
        str += this.items.length;

        for (let i = 0; i < this.items.length; i++)
        {
            const item = this.items[i];

            str += ' ' + item.type + ' ';
            str += item.toJson();
        }


        return str;
    }



    toString()
    {
        if (!this.items)
            return '';


        let str = '';
        
        
        str += this.items.length;

        for (let i = 0; i < this.items.length; i++)
        {
            const item = this.items[i];

            str += ' ' + item.type + ' ';
            str += item.toString();
        }


        return str;
    }



    toPreviewString()
    {
        if (!this.items)
            return '';


        const nItems = Math.min(this.items.length, 10);


        let str = '';

        for (let i = 0; i < nItems; i++)
        {
            if (i > 0) 
                str += '<br/>';


            const item = this.items[i];

            if (isListType(item.type))
                // str += 'list [' + item.items.length + ']';
            {
                for (let j = 0; j < item.items.length; j++)
                {
                    if (j > 0) 
                        str += ', ';
                    
                    str += item.items[j].toPreviewString();
                }
            }
            else
                str += item.toPreviewString();
        }

        if (this.items.length > 10) 
            str += '<br/>. . .';
        
        return str;
    }



    toDisplayString()
    {
        if (!this.items)
            return '';


        let str = '';
        
        
        str += this.items.length;

        for (let i = 0; i < this.items.length; i++)
        {
            const item = this.items[i];

            str += ' ' + item.type + ' ';
            str += item.toDisplayString();
        }


        return str;
    }



    getNaN()
    {
        return ListValue.NaN;
    }



    static NaN = Object.freeze(new ListValue(null));
}



function parseListValue(str, i = -1)
{
    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }
        
    
    const iStart  = i;
    const nInputs = parseInt(str[i++]);
    
    
    const list = new ListValue();


    for (let j = 0; j < nInputs; j++)
    {
        const type = str[i++];

        switch (type)
        {
            case         LIST_VALUE:  
            case  NUMBER_LIST_VALUE:  
            case    TEXT_LIST_VALUE:  
            case   SHAPE_LIST_VALUE: { const _list   = parseListValue        (str, i);  i += _list  [1];  list.items.push(_list  [0]);  break; }
 
            case       NUMBER_VALUE: { const num     = parseNumberValue      (str[i]);  i += num    [1];  list.items.push(num    [0]);  break; }
            case         TEXT_VALUE: { const text    = parseTextValue        (str[i]);  i += text   [1];  list.items.push(text   [0]);  break; }
            case        COLOR_VALUE: { const color   = parseColorValue       (str, i);  i += color  [1];  list.items.push(color  [0]);  break; }

            case         FILL_VALUE: { const fill    = parseFillValue        (str, i);  i += fill   [1];  list.items.push(fill   [0]);  break; }
            case   COLOR_STOP_VALUE: { const stop    = parseColorStopValue   (str, i);  i += stop   [1];  list.items.push(stop   [0]);  break; }
            case     GRADIENT_VALUE: { const grad    = parseGradientValue    (str, i);  i += grad   [1];  list.items.push(grad   [0]);  break; }
            case       STROKE_VALUE: { const stroke  = parseStrokeValue      (str, i);  i += stroke [1];  list.items.push(stroke [0]);  break; }
            case  DROP_SHADOW_VALUE: { const shadow  = parseDropShadowValue  (str, i);  i += shadow [1];  list.items.push(shadow [0]);  break; }
            case INNER_SHADOW_VALUE: { const shadow  = parseInnerShadowValue (str, i);  i += shadow [1];  list.items.push(shadow [0]);  break; }
            case   LAYER_BLUR_VALUE: { const blur    = parseLayerBlurValue   (str, i);  i += blur   [1];  list.items.push(blur   [0]);  break; }
            case    BACK_BLUR_VALUE: { const blur    = parseBackBlurValue    (str, i);  i += blur   [1];  list.items.push(blur   [0]);  break; }
            case  LAYER_BLEND_VALUE: { const layer   = parseLayerBlendValue  (str, i);  i += layer  [1];  list.items.push(layer  [0]);  break; }
            case   LAYER_MASK_VALUE: { const mask    = parseLayerMaskValue   (str[i]);  i += mask   [1];  list.items.push(mask   [0]);  break; }

            case    RECTANGLE_VALUE: { const rect    = parseRectangleValue   (str, i);  i += rect   [1];  list.items.push(rect   [0]);  break; }
            case         LINE_VALUE: { const line    = parseLineValue        (str, i);  i += line   [1];  list.items.push(line   [0]);  break; }
            case      ELLIPSE_VALUE: { const ellipse = parseEllipseValue     (str, i);  i += ellipse[1];  list.items.push(ellipse[0]);  break; }
            case      TRAPEZE_VALUE: { const trapeze = parseTrapezeValue     (str, i);  i += trapeze[1];  list.items.push(trapeze[0]);  break; }
            case      POLYGON_VALUE: { const poly    = parsePolygonValue     (str, i);  i += poly   [1];  list.items.push(poly   [0]);  break; }
            case         STAR_VALUE: { const star    = parseStarValue        (str, i);  i += star   [1];  list.items.push(star   [0]);  break; }
            case   TEXT_SHAPE_VALUE: { const text    = parseTextShapeValue   (str, i);  i += text   [1];  list.items.push(text   [0]);  break; }
            case        POINT_VALUE: { const point   = parsePointValue       (str, i);  i += point  [1];  list.items.push(point  [0]);  break; }
            case  VECTOR_PATH_VALUE: { const path    = parseVectorPathValue  (str, i);  i += path   [1];  list.items.push(path   [0]);  break; }
            case      BOOLEAN_VALUE: { const bool    = parseShapeBooleanValue(str, i);  i += bool   [1];  list.items.push(bool   [0]);  break; }
            case  SHAPE_GROUP_VALUE: { const group   = parseShapeGroupValue  (str, i);  i += group  [1];  list.items.push(group  [0]);  break; }
            case        FRAME_VALUE: { const frame   = parseFrameValue       (str, i);  i += frame  [1];  list.items.push(frame  [0]);  break; }
        }
    }

    
    return [
        list, 
        i - iStart];
}



function getItemTypes(items, debug)
{
    const types = [];

    for (const item of items)
    {
        if (   item.type ==        LIST_VALUE
            || item.type == NUMBER_LIST_VALUE
            || item.type ==   TEXT_LIST_VALUE
            || item.type ==  SHAPE_LIST_VALUE)
            pushUnique(types, finalListTypeFromItems(item.items, debug));

        else
            pushUnique(types, item.type);
    }

    return types;
}



function finalTypeFromItems(items)
{
    return finalTypeFromTypes(getItemTypes(items));
}



function finalListTypeFromItems(items)
{
    return finalListTypeFromTypes(getItemTypes(items));
}



function finalTypeFromTypes(types)
{
    let _type = NULL;


    for (const type of types)
    {
        if (_type == NULL)
            _type = type;

        else if (_type != type
                 &&  SHAPE_VALUES.includes(_type) 
                 && !SHAPE_VALUES.includes( type))
        { 
            _type = ANY_VALUE;
            break; 
        }
    }


    return _type;
}



function finalListTypeFromTypes(types)
{
    //console.log('types =', types);
    let _type = finalTypeFromTypes(types);
    
         if (  _type == NUMBER_VALUE || _type == NUMBER_LIST_VALUE)  return NUMBER_LIST_VALUE;
    else if (  _type ==   TEXT_VALUE || _type ==   TEXT_LIST_VALUE)  return   TEXT_LIST_VALUE;
    else if (SHAPE_VALUES.includes(_type))                           return  SHAPE_LIST_VALUE;
    else                                                             return        LIST_VALUE;
}


class NumberValue
extends GValue
{
    value;
    initValue;
    decimals;



    constructor(val = Number.NaN, dec = -1)
    {
        super(NUMBER_VALUE);

        if (typeof val !== 'number')
            consoleError('NumberValue(value) is ' + typeof val + ', must be a number');


        this.value     = val;
        this.initValue = val;
        
        this.decimals = 
              !isNaN(this.value) 
            && dec == -1 
            ? decDigits(this.value) 
            : dec;
    }



    static fromString(str)
    {
        return new NumberValue(
            parseFloat(str),
            decCount(str));
    }



    copy()
    {
        const copy = new NumberValue(
            this.value, 
            this.decimals);

        copy.initValue = this.initValue;

        copy.copyBase(this);

        return copy;
    }



    equals(num)
    {
        return num
            && this.value    == num.value
            && this.decimals == num.decimals;
    }



    async eval(parse)
    {
        return this;
    }



    hasInitValue()
    {
        return this.value == this.initValue;
    }



    isValid()
    {
        return !isNaN(this.value)
            && !isNaN(this.decimals);
    }



    toInteger()
    {
        return new NumberValue(Math.round(this.value));
    }



    toNumber()
    {
        return roundTo(this.value, this.decimals);
    }



    toString()
    {
        return printNum(this.value) + ',' + printNum(this.decimals);
    }



    toPreviewString()
    {
        return this.isValid()
             ? numToString(this.value, this.decimals)
             : NAN_DISPLAY;
    }



    toDisplayString()
    {
        return printNum(this.value) 
             + (!isNaN(this.decimals)
                ? '_' + this.decimals //subscriptNumber(this.decimals)
                : '');
    }



    toJsCode(gen)
    {
        return this.toPreviewString();
    }



    getNaN()
    {
        return NumberValue.NaN;
    }



    static NaN = Object.freeze(new NumberValue(
        Number.NaN, 
        Number.NaN));
}



const NullValue = Object.freeze(NumberValue.NaN);



function parseNumberValue(str)
{
    if (str.indexOf(',') < 0)
    {
        console.trace();
        consoleError('number value \'' + str + '\' missing \',\'');
    }

    
    const parts = str.split(',');

    const num = new NumberValue(
        parseNum(parts[0]),
        parseNum(parts[1]));

    return [num, 1];
}



function parseSimpleNumberValue(str)
{
    const num = 
        str == NAN_DISPLAY
        ? NumberValue.NaN
        : NumberValue.fromString(str);

    return [num, 1];
}


class TextValue
extends GValue
{
    value;
    initValue;



    constructor(val = '')
    {
        super(TEXT_VALUE);


        if (   val !== null
            && typeof val !== 'string')
        {
            console.trace();
            consoleError('TextValue('+val+') is ' + typeof val + ', must be a string');
        }

        
        this.value        = val;
        this.initValue    = val;

        // this.updateValues = [];
    }



    copy()
    {
        const copy = new TextValue(this.value);

        copy.initValue = this.initValue;
        
        copy.copyBase(this);

        return copy;
    }



    equals(text)
    {
        return text
            && this.value == text.value;
    }



    async eval(parse)
    {
        return this;
    }



    hasInitValue()
    {
        this.value == this.initValue;
    }



    isValid()
    {
        return this.value !== null;
    }



    toJson()
    {
        return encodeURIComponent(this.value);
    }



    toString()
    {
        return this.value;
    }



    toPreviewString()
    {
        const lines = this.value.split('\n');

        let str = '';

        for (let i = 0; i < Math.min(lines.length, 10); i++)
        {
            if (i > 0)
                str += '\n';

            str += lines[i];
        }

        if (lines.length > 10)
            str += '\n. . .';
        
        return str;
    }



    toDisplayString()
    {
        return '\'' 
             + this.value.replaceAll('\n', '↵')
             + '\'';
    }



    getNaN()
    {
        return TextValue.NaN;
    }



    static NaN = Object.freeze(new TextValue());
}



function parseTextValue(str)
{
    const text = new TextValue(decodeURIComponent(str));

    return [text, 1];
}


class ColorValue
extends GValue
{
    space;
    c1;
    c2;
    c3;



    constructor(space = NumberValue.NaN, 
                c1    = NumberValue.NaN, 
                c2    = NumberValue.NaN, 
                c3    = NumberValue.NaN)
    {
        super(COLOR_VALUE);

        this.space  = space.copy();
        this.c1     = c1   .copy();
        this.c2     = c2   .copy();
        this.c3     = c3   .copy();

        this.valid  = true;
    }



    static create(space, c1, c2, c3)
    {
        consoleAssert(typeof space == 'number', 'ColorValue.create() space must be a number');
        consoleAssert(typeof c1    == 'number', 'ColorValue.create() c1 must be a number');
        consoleAssert(typeof c2    == 'number', 'ColorValue.create() c2 must be a number');
        consoleAssert(typeof c3    == 'number', 'ColorValue.create() c3 must be a number');

        return new ColorValue(
            new NumberValue(space),
            new NumberValue(c1   ),
            new NumberValue(c2   ),
            new NumberValue(c3   ));
    }



    static fromRgb(rgb)
    {
        return ColorValue.create(1, rgb[0], rgb[1], rgb[2]);
    }



    static fromDataColor(_color, spaceIndex = -1)
    {
        if (spaceIndex < 0)
            spaceIndex = colorSpaceIndex (_color[0]);

        const space  = colorSpace(spaceIndex);
        const factor = colorSpaceFactor(space);

        return ColorValue.create(
            spaceIndex,
            _color[1] * factor[0],
            _color[2] * factor[1],
            _color[3] * factor[2]);
    }



    copy()
    {
        const copy = new ColorValue(
            this.space.copy(), 
            this.c1   .copy(), 
            this.c2   .copy(), 
            this.c3   .copy());

        copy.copyBase(this);

        return copy;
    }



    hasInitValue()
    {
        return this.space.hasInitValue()
            && this.c1   .hasInitValue()
            && this.c2   .hasInitValue()
            && this.c3   .hasInitValue();
    }



    isValid()
    {
        return this.space.isValid()
            && this.c1   .isValid()
            && this.c2   .isValid()
            && this.c3   .isValid();
    }



    equals(col)
    {
        return col
            && this.space.equals(col.space)
            && this.c1   .equals(col.c1   )
            && this.c2   .equals(col.c2   )
            && this.c3   .equals(col.c3   );
    }



    async eval(parse)
    {
        return this;
    }



    toDataColor()
    {
        if (!this.isValid())
            return dataColor_NaN;

        const space = this.space.copy();

        space.value = Math.round(Math.min(Math.max(0, space.value), ColorSpaces.length-1));

        return makeDataColor(
            space,
            this.c1,
            this.c2,
            this.c3);
    }



    toRgb()
    {
        return dataColor2rgb(this.toDataColor());
    }



    toRgbObject(limit = false)
    {
        const rgb = dataColor2rgb(this.toDataColor());

        if (limit && rgbIsNaN(rgb))
            return {r: 0.5, g: 0.5, b: 0.5};
        
        return limit
            ? { r: Math.min(Math.max(0, rgb[0]), 1),
                g: Math.min(Math.max(0, rgb[1]), 1),
                b: Math.min(Math.max(0, rgb[2]), 1) }
            : { r: rgb[0],
                g: rgb[1],
                b: rgb[2] };
    }



    toString()
    {
        return      this.space.toString()
            + ' ' + this.c1   .toString()
            + ' ' + this.c2   .toString()
            + ' ' + this.c3   .toString();
    }



    toPreviewString()
    {
        return      this.space.toPreviewString()
            + ' ' + this.c1   .toPreviewString()
            + ' ' + this.c2   .toPreviewString()
            + ' ' + this.c3   .toPreviewString();
    }



    toDisplayString()
    {
        return      this.space.toDisplayString()
            + ' ' + this.c1   .toDisplayString()
            + ' ' + this.c2   .toDisplayString()
            + ' ' + this.c3   .toDisplayString();
    }



    toPreviewString()
    {
        if (!this.isValid())
            return UNKNOWN_DISPLAY;

        const rgb = this.toRgb();

        return '#' + rgb2hex(rgb);
    }



    toRgbString()
    {
        if (!this.isValid())
            return UNKNOWN_DISPLAY;

        const rgb = this.toRgb();

        return      rgb[0].toString()
            + ' ' + rgb[1].toString()
            + ' ' + rgb[2].toString();
    }



    getNaN()
    {
        return ColorValue.NaN;
    }



    static NaN = Object.freeze(new ColorValue(
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN));
}



function parseColorValue(str, i = -1)
{
    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }
        

    const iStart = i;

    const space = parseNumberValue(str[i]); i += space[1];
    const c1    = parseNumberValue(str[i]); i += c1   [1];
    const c2    = parseNumberValue(str[i]); i += c2   [1];
    const c3    = parseNumberValue(str[i]); i += c3   [1];


    return [
        new ColorValue(space[0], c1[0], c2[0], c3[0]), 
        i - iStart ];
}


class FillValue
extends GValue
{
    color;
    opacity;
    blend;



    constructor(color   = ColorValue.NaN, 
                opacity = new NumberValue(100),
                blend   = new NumberValue(0))
    {
        super(FILL_VALUE);

        this.color   = color  .copy();
        this.opacity = opacity.copy();
        this.blend   = blend  .copy();

        this.valid   = true;
    }


    
    static create(r, g, b, opacity, blend = 0)
    {
        consoleAssert(
            typeof opacity == 'number',
            'opacity must be a number');

        return new FillValue(
            ColorValue.create(1, r, g, b),
            new NumberValue(opacity),
            new NumberValue(blend));
    }



    static fromRgb(rgb, opacity, blend = 0)
    {
        consoleAssert(
            typeof opacity == 'number',
            'opacity must be a number');

        return new FillValue(
            ColorValue.fromRgb(rgb),
            new NumberValue(opacity),
            new NumberValue(blend));
    }



    copy()
    {
        const copy = new FillValue(
            this.color  .copy(),
            this.opacity.copy(),
            this.blend  .copy());

        copy.copyBase(this);

        return copy;
    }



    equals(fill)
    {
        return this.color  .equals(fill.color  )
            && this.opacity.equals(fill.opacity)
            && this.blend  .equals(fill.blend  );
    }



    async eval(parse)
    {
        return this;
    }



    toRgba()
    {
        return [
            ...this.color.toRgb(),
            this.opacity.value / 100 ];
    }



    // toFigma()
    // {
    //     return [['SOLID', this.toString()]];
    // }



    toString()
    {
        const rgb = scaleRgb(this.color.toRgb());

        return        new NumberValue(rgb[0]).toString()
              + ' ' + new NumberValue(rgb[1]).toString()
              + ' ' + new NumberValue(rgb[2]).toString()
              + ' ' + this.opacity           .toString()
              + ' ' + this.blend             .toString();
    }



    toPreviewString()
    {
        const rgb = scaleRgb(this.color.toRgb());

        return        new NumberValue(rgb[0]).toPreviewString()
              + ' ' + new NumberValue(rgb[1]).toPreviewString()
              + ' ' + new NumberValue(rgb[2]).toPreviewString()
              + ' ' + this.opacity           .toPreviewString()
              + ' ' + this.blend             .toPreviewString();
    }



    toDisplayString()
    {
        const rgb = scaleRgb(this.color.toRgb());

        return        new NumberValue(rgb[0]).toDisplayString()
              + ' ' + new NumberValue(rgb[1]).toDisplayString()
              + ' ' + new NumberValue(rgb[2]).toDisplayString()
              + ' ' + this.opacity           .toDisplayString()
              + ' ' + this.blend             .toDisplayString();
    }



    hasInitValue()
    {
        return this.color  .hasInitValue()
            && this.opacity.hasInitValue()
            && this.blend  .hasInitValue();
    }



    isValid()
    {
        return this.color  .isValid()
            && this.opacity.isValid()
            && this.blend  .isValid();
    }



    getNaN()
    {
        return FillValue.NaN;
    }



    static NaN = Object.freeze(new FillValue(
        ColorValue .NaN,
        NumberValue.NaN,
        NumberValue.NaN));



    static default = Object.freeze(FillValue.create(217, 217, 217, 100));
}



function parseFillValue(str, i = -1)
{
    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const r  = parseNumberValue(str[i]); i += r [1];
    const g  = parseNumberValue(str[i]); i += g [1];
    const b  = parseNumberValue(str[i]); i += b [1];
    const a  = parseNumberValue(str[i]); i += a [1];
    const bl = parseNumberValue(str[i]); i += bl[1];

    const color = new ColorValue(new NumberValue(1), r[0], g[0], b[0]);

    
    return [
        new FillValue(color, a[0], bl[0]),
        i - iStart ];
}






// async function evalFillValue(fillValue, parse)
// {
//     await fillValue.eval(parse);

//          if ( FILL_TYPES.includes(fillValue.type)) return fill;
//     else if (COLOR_TYPES.includes(fillValue.type)) return new FillValue(fill, fillValue.data.opacity);

//     else consoleError('fill must have type');
// }


class ColorStopValue
extends GValue
{
    fill;
    position;



    constructor(fill     = FillValue.NaN, 
                position = new NumberValue(1))
    {
        if (fill.type != FILL_VALUE)
            consoleError('fill.type is ' + fill.type + ', must be FILL_VALUE');


        super(COLOR_STOP_VALUE);

        this.fill     = fill    .copy();
        this.position = position.copy();

        this.valid    = true;
    }


    
    copy()
    {
        const copy = new ColorStopValue(
            this.fill    .copy(),
            this.position.copy());

        copy.copyBase(this);

        return copy;
    }



    isValid()
    {
        return this.fill    .isValid()
            && this.position.isValid();
    }



    equals(stop)
    {
        return stop
            && this.fill    .equals(stop.fill    )
            && this.position.equals(stop.position);
    }



    async eval(parse)
    {
        return this;
    }



    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.fill    .toString()
            + ' ' + this.position.toString();
    }



    toPreviewString()
    {
        return      this.fill    .toPreviewString()
            + ' ' + this.position.toPreviewString();
    }



    toDisplayString()
    {
        return      this.fill    .toDisplayString()
            + ' ' + this.position.toDisplayString();
    }



    getNaN()
    {
        return ColorStopValue.NaN;
    }



    static NaN = Object.freeze(new ColorStopValue(
        FillValue  .NaN,
        NumberValue.NaN));
}



function parseColorStopValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [ColorStopValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const fill     = parseFillValue  (str, i); i += fill    [1];
    const position = parseNumberValue(str[i]); i += position[1];


    return [
        new ColorStopValue(fill[0], position[0]),
        i - iStart ];
}


class GradientValue
extends GValue
{
    stops;
    gradType;
    x;
    y;
    size;
    angle;
    aspect;
    skew;
    blend;



    constructor(stops    = new ListValue(),
                gradType = new NumberValue(0),
                x        = new NumberValue(0),
                y        = new NumberValue(0),
                size     = new NumberValue(0),
                angle    = new NumberValue(0),
                aspect   = new NumberValue(0),
                skew     = new NumberValue(0),
                blend    = new NumberValue(0))
    {
        super(GRADIENT_VALUE);

        this.stops    = stops   .copy();
        this.gradType = gradType.copy();
        this.x        = x       .copy();
        this.y        = y       .copy();
        this.size     = size    .copy();
        this.angle    = angle   .copy();
        this.aspect   = aspect  .copy();
        this.skew     = skew    .copy();
        this.blend    = blend   .copy();

        this.valid = true;
    }


    
    copy()
    {
        const copy = new GradientValue(
            this.stops,
            this.gradType,
            this.x,
            this.y,
            this.size,
            this.angle,
            this.aspect,
            this.skew,
            this.blend);

        copy.copyBase(this);

        return copy;
    }



    isValid()
    {
        return this.stops   .isValid()
            && this.gradType.isValid()
            && this.x       .isValid()
            && this.y       .isValid()
            && this.size    .isValid()
            && this.angle   .isValid()
            && this.aspect  .isValid()
            && this.skew    .isValid()
            && this.blend   .isValid();
    }



    equals(grad)
    {
        return grad
            && this.stops   .equals(grad.stops   )
            && this.gradType.equals(grad.gradType)
            && this.x       .equals(grad.x       )
            && this.y       .equals(grad.y       )
            && this.size    .equals(grad.size    )
            && this.angle   .equals(grad.angle   )
            && this.aspect  .equals(grad.aspect  )
            && this.skew    .equals(grad.skew    )
            && this.blend   .equals(grad.blend   );
    }



    async eval(parse)
    {
        return this;
    }



    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.stops   .toString()
            + ' ' + this.gradType.toString()
            + ' ' + this.x       .toString()
            + ' ' + this.y       .toString()
            + ' ' + this.size    .toString()
            + ' ' + this.angle   .toString()
            + ' ' + this.aspect  .toString()
            + ' ' + this.skew    .toString()
            + ' ' + this.blend   .toString();
    }



    toRgba()
    {
        return this.stops.length > 0
             ? this.stops[0].fill.toRgba()
             : rgba_NaN;
    }


    
    toPreviewString()
    {
        return      this.stops   .toPreviewString()
            + ' ' + this.gradType.toPreviewString()
            + ' ' + this.x       .toPreviewString()
            + ' ' + this.y       .toPreviewString()
            + ' ' + this.size    .toPreviewString()
            + ' ' + this.angle   .toPreviewString()
            + ' ' + this.aspect  .toPreviewString()
            + ' ' + this.skew    .toPreviewString()
            + ' ' + this.blend   .toPreviewString();
    }



    toDisplayString()
    {
        return      this.stops   .toDisplayString()
            + ' ' + this.gradType.toDisplayString()
            + ' ' + this.x       .toDisplayString()
            + ' ' + this.y       .toDisplayString()
            + ' ' + this.size    .toDisplayString()
            + ' ' + this.angle   .toDisplayString()
            + ' ' + this.aspect  .toDisplayString()
            + ' ' + this.skew    .toDisplayString()
            + ' ' + this.blend   .toDisplayString();
    }



    getNaN()
    {
        return GradientValue.NaN;
    }



    static NaN = Object.freeze(new GradientValue(
        ListValue  .NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN));



    // static default = Object.freeze(new StrokeValue(
    //     FillValue.create(0, 0, 0, 100),
    //     new NumberValue(1),
    //     new NumberValue(0),
    //     new NumberValue(0),
    //     new NumberValue(28.96)));
}



function parseGradientValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [GradientValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const stops    = parseListValue  (str, i); i += stops   [1];
    const gradType = parseNumberValue(str[i]); i += gradType[1];
    const x        = parseNumberValue(str[i]); i += x       [1];
    const y        = parseNumberValue(str[i]); i += y       [1];
    const size     = parseNumberValue(str[i]); i += size    [1];
    const angle    = parseNumberValue(str[i]); i += angle   [1];
    const aspect   = parseNumberValue(str[i]); i += aspect  [1];
    const skew     = parseNumberValue(str[i]); i += skew    [1];
    const blend    = parseNumberValue(str[i]); i += blend   [1];


    return [
        new GradientValue(stops[0], gradType[0], x[0], y[0], size[0], angle[0], aspect[0], skew[0], blend[0]),
        i - iStart ];
}


class StrokeValue
extends GValue
{
    fills;
    weight;
    fit;
    join;
    miter;
    cap;
    dashes;



    constructor(fills  = new ListValue(), 
                weight = new NumberValue(1),
                fit    = new NumberValue(0),
                join   = new NumberValue(0),
                miter  = new NumberValue(28.96, 2),
                cap    = new NumberValue(0),
                dashes = new TextValue())
    {
        if (fills.type != LIST_VALUE)
            consoleError('fill.type is ' + fills.type + ', must be LIST_VALUE');


        super(STROKE_VALUE);

        this.fills  = fills .copy();
        this.weight = weight.copy();
        this.fit    = fit   .copy();
        this.join   = join  .copy();
        this.miter  = miter .copy();
        this.cap    = cap   .copy();
        this.dashes = dashes.copy();

        this.valid  = true;
    }


    
    copy()
    {
        const copy = new StrokeValue(
            this.fills .copy(),
            this.weight.copy(),
            this.fit   .copy(),
            this.join  .copy(),
            this.miter .copy(),
            this.cap   .copy(),
            this.dashes.copy());

        copy.copyBase(this);

        return copy;
    }



    hasInitValue()
    {
        return this.fills .hasInitValue()
            && this.weight.hasInitValue()
            && this.fit   .hasInitValue()
            && this.join  .hasInitValue()
            && this.miter .hasInitValue()
            && this.cap   .hasInitValue()
            && this.dashes.hasInitValue();
    }



    isValid()
    {
        return this.fills .isValid()
            && this.weight.isValid()
            && this.fit   .isValid()
            && this.join  .isValid()
            && this.miter .isValid()
            && this.cap   .isValid()
            && this.dashes.isValid();
    }



    equals(stroke)
    {
        return stroke
            && this.fills .equals(stroke.fill  )
            && this.weight.equals(stroke.weight)
            && this.fit   .equals(stroke.fit   )
            && this.join  .equals(stroke.join  )
            && this.miter .equals(stroke.miter )
            && this.cap   .equals(stroke.cap   )
            && this.dashes.equals(stroke.dashes);
    }



    async eval(parse)
    {
        return this;
    }



    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.fills .toString()
            + ' ' + this.weight.toString()
            + ' ' + this.fit   .toString()
            + ' ' + this.join  .toString()
            + ' ' + this.miter .toString()
            + ' ' + this.cap   .toString()
            + ' ' + this.dashes.toString();
    }



    toPreviewString()
    {
        return      this.fills .toPreviewString()
            + ' ' + this.weight.toPreviewString()
            + ' ' + this.fit   .toPreviewString()
            + ' ' + this.join  .toPreviewString()
            + ' ' + this.miter .toPreviewString()
            + ' ' + this.cap   .toPreviewString()
            + ' ' + this.dashes.toPreviewString();
    }



    toDisplayString()
    {
        return      this.fills .toDisplayString()
            + ' ' + this.weight.toDisplayString()
            + ' ' + this.fit   .toDisplayString()
            + ' ' + this.join  .toDisplayString()
            + ' ' + this.miter .toDisplayString()
            + ' ' + this.cap   .toDisplayString()
            + ' ' + this.dashes.toDisplayString();
    }



    getNaN()
    {
        return StrokeValue.NaN;
    }



    static NaN = Object.freeze(new StrokeValue(
        new ListValue(),
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        new TextValue()));



    static default = Object.freeze(new StrokeValue(
        new ListValue(),
        new NumberValue(1),
        new NumberValue(0),
        new NumberValue(0),
        new NumberValue(28.96),
        new NumberValue(0),
        new TextValue()));
}



function parseStrokeValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [StrokeValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const fills  = parseListValue  (str, i); i += fills [1];
    const weight = parseNumberValue(str[i]); i += weight[1];
    const fit    = parseNumberValue(str[i]); i += fit   [1];
    const join   = parseNumberValue(str[i]); i += join  [1];
    const miter  = parseNumberValue(str[i]); i += miter [1];
    const cap    = parseNumberValue(str[i]); i += cap   [1];
    const dashes = parseTextValue  (str[i]); i += dashes[1];

    return [

        new StrokeValue(
            fills [0], 
            weight[0], 
            fit   [0], 
            join  [0], 
            miter [0], 
            cap   [0], 
            dashes[0]),
        
        i - iStart ];
}



class RoundCornersValue
extends GValue
{
    tl;
    tr;
    bl;
    br;
    visible;



    constructor(tl = new NumberValue(0), 
                tr = new NumberValue(0), 
                bl = new NumberValue(0), 
                br = new NumberValue(0), 
                visible = true)
    {
        super(ROUND_CORNERS_VALUE);

        this.tl      = tl;
        this.tr      = tr;
        this.bl      = bl;
        this.br      = br;
        this.visible = visible;
    }


    
    copy()
    {
        const copy = new RoundCornersValue(
            this.tl.copy(),
            this.tr.copy(),
            this.bl.copy(),
            this.br.copy(),
            this.visible);

        copy.copyBase(this);

        return copy;
    }



    equals(corners)
    {
        return this.tl.equals(corners.tl)
            && this.tr.equals(corners.tr)
            && this.bl.equals(corners.bl)
            && this.br.equals(corners.br)
            && this.visible === corners.visible;
    }



    async eval(parse)
    {
        return this;
    }



    toString()
    {
        return      this.tl.toString()
            + ' ' + this.tr.toString()
            + ' ' + this.bl.toString()
            + ' ' + this.br.toString();
    }



    toPreviewString()
    {
        return      this.tl.toPreviewString()
            + ' ' + this.tr.toPreviewString()
            + ' ' + this.bl.toPreviewString()
            + ' ' + this.br.toPreviewString();
    }



    toDisplayString()
    {
        return      this.tl.toDisplayString()
            + ' ' + this.tr.toDisplayString()
            + ' ' + this.bl.toDisplayString()
            + ' ' + this.br.toDisplayString();
    }



    isValid()
    {
        return this.tl.isValid()
            && this.tr.isValid()
            && this.bl.isValid()
            && this.br.isValid();
    }



    getNaN()
    {
        return RoundCornersValue.NaN;
    }



    static NaN = Object.freeze(new RoundCornersValue(
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        false));
}



function parseRoundCornersValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [RoundCornersValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const tl = parseNumberValue(str[i]); i += tl[1];
    const tr = parseNumberValue(str[i]); i += tr[1];
    const bl = parseNumberValue(str[i]); i += bl[1];
    const br = parseNumberValue(str[i]); i += br[1];


    const corners = new RoundCornersValue(
        tl[0],
        tr[0],
        bl[0],
        br[0]);


    return [corners, i - iStart];
}



class DropShadowValue
extends GValue
{
    x;
    y;
    blur;
    spread;
    fill;
    blend;
    behind;
    visible;



    constructor(x       = new NumberValue(0), 
                y       = new NumberValue(0), 
                blur    = new NumberValue(0), 
                spread  = new NumberValue(0), 
                fill    = FillValue.NaN,
                blend   = new NumberValue(0),
                behind  = new NumberValue(0),
                visible = true)
    {
        super(DROP_SHADOW_VALUE);

        this.x       = x;
        this.y       = y;
        this.blur    = blur;
        this.spread  = spread;
        this.fill    = fill;
        this.blend   = blend;
        this.behind  = behind;
        this.visible = visible;
        
        consoleAssert(fill.type == FILL_VALUE, 'fill.type must be FILL_VALUE');
    }


    
    // static create(x, y, blur, spread, fill, blend, behind)
    // {
    //     return new FillValue(
    //         new Number,
    //         new NumberValue(opacity));
    // }



    copy()
    {
        const copy = new DropShadowValue(
            this.x     .copy(),
            this.y     .copy(),
            this.blur  .copy(),
            this.spread.copy(),
            this.fill  .copy(),
            this.blend .copy(),
            this.behind.copy(),
            this.visible);

        copy.copyBase(this);

        return copy;
    }



    equals(shadow)
    {
        return this.x     .equals(shadow.x     )
            && this.y     .equals(shadow.y     )
            && this.blur  .equals(shadow.blur  )
            && this.spread.equals(shadow.spread)
            && this.fill  .equals(shadow.fill  )
            && this.blend .equals(shadow.blend )
            && this.behind.equals(shadow.behind)
            && this.visible === shadow.visible;
    }



    async eval(parse)
    {
        return this;
    }



    toString()
    {
        return      this.x     .toString()
            + ' ' + this.y     .toString()
            + ' ' + this.blur  .toString()
            + ' ' + this.spread.toString()
            + ' ' + this.fill  .toString()
            + ' ' + this.blend .toString()
            + ' ' + this.behind.toString();
    }



    toPreviewString()
    {
        return      this.x     .toPreviewString()
            + ' ' + this.y     .toPreviewString()
            + ' ' + this.blur  .toPreviewString()
            + ' ' + this.spread.toPreviewString()
            + ' ' + this.fill  .toPreviewString()
            + ' ' + this.blend .toPreviewString()
            + ' ' + this.behind.toPreviewString();
    }



    toDisplayString()
    {
        return      this.x     .toDisplayString()
            + ' ' + this.y     .toDisplayString()
            + ' ' + this.blur  .toDisplayString()
            + ' ' + this.spread.toDisplayString()
            + ' ' + this.fill  .toDisplayString()
            + ' ' + this.blend .toDisplayString()
            + ' ' + this.behind.toDisplayString();
    }



    isValid()
    {
        return this.x     .isValid()
            && this.y     .isValid()
            && this.blur  .isValid()
            && this.spread.isValid()
            && this.fill  .isValid()
            && this.blend .isValid()
            && this.behind.isValid();
    }



    getNaN()
    {
        return DropShadowValue.NaN;
    }



    static NaN = Object.freeze(new DropShadowValue(
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        FillValue .NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        false));


    // static default = Object.freeze(DropShadowValue.create(217, 217, 217, 100));
}



function parseDropShadowValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [DropShadowValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x      = parseNumberValue(str[i]); i += x     [1];
    const y      = parseNumberValue(str[i]); i += y     [1];
    const blur   = parseNumberValue(str[i]); i += blur  [1];
    const spread = parseNumberValue(str[i]); i += spread[1];
    const fill   = parseFillValue  (str, i); i += fill  [1];
    const blend  = parseNumberValue(str[i]); i += blend [1];
    const behind = parseNumberValue(str[i]); i += behind[1];


    const shadow = new DropShadowValue(
        x     [0],
        y     [0],
        blur  [0],
        spread[0],
        fill  [0],
        blend [0],
        behind[0]);


    return [shadow, i - iStart];
}



class InnerShadowValue
extends GValue
{
    x;
    y;
    blur;
    spread;
    fill;
    blend;
    visible;



    constructor(x       = new NumberValue(0), 
                y       = new NumberValue(0), 
                blur    = new NumberValue(0), 
                spread  = new NumberValue(0), 
                fill    = FillValue.NaN,
                blend   = new NumberValue(0),
                visible = true)
    {
        super(INNER_SHADOW_VALUE);

        this.x       = x;
        this.y       = y;
        this.blur    = blur;
        this.spread  = spread;
        this.fill    = fill;
        this.blend   = blend;
        this.visible = visible;
    }


    
    // static create(x, y, blur, spread, fill, blend)
    // {
    //     return new FillValue(
    //         new Number,
    //         new NumberValue(opacity));
    // }



    copy()
    {
        const copy = new InnerShadowValue(
            this.x     .copy(),
            this.y     .copy(),
            this.blur  .copy(),
            this.spread.copy(),
            this.fill  .copy(),
            this.blend .copy(),
            this.visible);

        copy.copyBase(this);

        return copy;
    }



    equals(shadow)
    {
        return this.x     .equals(shadow.x     )
            && this.y     .equals(shadow.y     )
            && this.blur  .equals(shadow.blur  )
            && this.spread.equals(shadow.spread)
            && this.fill  .equals(shadow.fill  )
            && this.blend .equals(shadow.blend )
            && this.visible === shadow.visible;
    }



    async eval(parse)
    {
        return this;
    }



    // toRgba()
    // {
    //     return [
    //         ...this.color.toRgb(),
    //         this.opacity.value / 100 ];
    // }



    // toFigma()
    // {
    //     return [['SOLID', this.toString()]];
    // }



    toString()
    {
        return      this.x     .toString()
            + ' ' + this.y     .toString()
            + ' ' + this.blur  .toString()
            + ' ' + this.spread.toString()
            + ' ' + this.fill  .toString()
            + ' ' + this.blend .toString();
    }



    toPreviewString()
    {
        return      this.x     .toPreviewString()
            + ' ' + this.y     .toPreviewString()
            + ' ' + this.blur  .toPreviewString()
            + ' ' + this.spread.toPreviewString()
            + ' ' + this.fill  .toPreviewString()
            + ' ' + this.blend .toPreviewString();
    }



    toDisplayString()
    {
        return      this.x     .toDisplayString()
            + ' ' + this.y     .toDisplayString()
            + ' ' + this.blur  .toDisplayString()
            + ' ' + this.spread.toDisplayString()
            + ' ' + this.fill  .toDisplayString()
            + ' ' + this.blend .toDisplayString();
    }



    isValid()
    {
        return this.x     .isValid()
            && this.y     .isValid()
            && this.blur  .isValid()
            && this.spread.isValid()
            && this.fill  .isValid()
            && this.blend .isValid();
    }



    getNaN()
    {
        return InnerShadowValue.NaN;
    }



    static NaN = Object.freeze(new InnerShadowValue(
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        FillValue .NaN,
        NumberValue.NaN,
        false));



    // static default = Object.freeze(InnerShadowValue.create(217, 217, 217, 100));
}



function parseInnerShadowValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [InnerShadowValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x      = parseNumberValue(str[i]); i += x     [1];
    const y      = parseNumberValue(str[i]); i += y     [1];
    const blur   = parseNumberValue(str[i]); i += blur  [1];
    const spread = parseNumberValue(str[i]); i += spread[1];
    const fill   = parseFillValue  (str, i); i += fill  [1];
    const blend  = parseNumberValue(str[i]); i += blend [1];


    const shadow = new InnerShadowValue(
        x     [0],
        y     [0],
        blur  [0],
        spread[0],
        fill  [0],
        blend [0]);


    return [shadow, i - iStart];
}



class LayerBlurValue
extends GValue
{
    radius;
    visible;



    constructor(radius  = new NumberValue(0), 
                visible = true)
    {
        super(LAYER_BLUR_VALUE);

        this.radius  = radius;
        this.visible = visible;
    }


    
    // static create(x, y, blur, spread, fill, blend)
    // {
    //     return new FillValue(
    //         new Number,
    //         new NumberValue(opacity));
    // }



    copy()
    {
        const copy = new LayerBlurValue(
            this.radius.copy(),
            this.visible);

        copy.copyBase(this);

        return copy;
    }



    equals(blur)
    {
        return this.radius.equals(blur.radius)
            && this.visible === blur.visible;
    }



    async eval(parse)
    {
        return this;
    }



    // toRgba()
    // {
    //     return [
    //         ...this.color.toRgb(),
    //         this.opacity.value / 100 ];
    // }



    // toFigma()
    // {
    //     return [['SOLID', this.toString()]];
    // }



    toString()
    {
        return this.radius.toString();
    }



    toPreviewString()
    {
        return this.radius.toPreviewString();
    }



    toDisplayString()
    {
        return this.radius.toDisplayString();
    }



    isValid()
    {
        return this.radius.isValid();
    }



    getNaN()
    {
        return LayerBlurValue.NaN;
    }



    static NaN = Object.freeze(new LayerBlurValue(
        NumberValue.NaN,
        false));



    // static default = Object.freeze(LayerBlurValue.create(217, 217, 217, 100));
}



function parseLayerBlurValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [LayerBlurValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const radius = parseNumberValue(str[i]); i += radius[1];


    const shadow = new LayerBlurValue(
        radius[0]);


    return [shadow, i - iStart];
}



class BackBlurValue
extends GValue
{
    radius;
    visible;



    constructor(radius  = new NumberValue(0),
                visible = true)
    {
        super(BACK_BLUR_VALUE);

        this.radius  = radius;
        this.visible = visible;
    }


    
    // static create(x, y, blur, spread, fill, blend)
    // {
    //     return new FillValue(
    //         new Number,
    //         new NumberValue(opacity));
    // }



    copy()
    {
        const copy = new BackBlurValue(
            this.radius.copy(),
            this.visible);

        copy.copyBase(this);

        return copy;
    }



    equals(blur)
    {
        return this.radius.equals(blur.radius)
            && this.visible === blur.visible;
    }



    async eval(parse)
    {
        return this;
    }



    // toRgba()
    // {
    //     return [
    //         ...this.color.toRgb(),
    //         this.opacity.value / 100 ];
    // }



    // toFigma()
    // {
    //     return [['SOLID', this.toString()]];
    // }



    toString()
    {
        return this.radius.toString();
    }



    toPreviewString()
    {
        return this.radius.toPreviewString();
    }



    toDisplayString()
    {
        return this.radius.toDisplayString();
    }



    isValid()
    {
        return this.radius.isValid();
    }



    getNaN()
    {
        return BackBlurValue.NaN;
    }



    static NaN = Object.freeze(new BackBlurValue(
        NumberValue.NaN,
        false));



    // static default = Object.freeze(BackBlurValue.create(217, 217, 217, 100));
}



function parseBackBlurValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [BackBlurValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const radius = parseNumberValue(str[i]); i += radius[1];


    const shadow = new BackBlurValue(
        radius[0]);


    return [shadow, i - iStart];
}



class LayerBlendValue
extends GValue
{
    opacity;
    blend;



    constructor(opacity, blend)
    {
        super(LAYER_BLEND_VALUE);

        this.opacity = opacity.copy();
        this.blend   = blend  .copy();
    }


    
    copy()
    {
        const copy = new LayerBlendValue(this.opacity, this.blend);

        copy.copyBase(this);

        return copy;
    }



    equals(layer)
    {
        return this.opacity.equals(layer.opacity)
            && this.blend  .equals(layer.blend  );
    }



    async eval(parse)
    {
        return this;
    }



    toString()
    {
        return      this.opacity.toString()
            + ' ' + this.blend  .toString();
    }



    toPreviewString()
    {
        return      this.opacity.toPreviewString()
            + ' ' + this.blend  .toPreviewString();
    }



    toDisplayString()
    {
        return      this.opacity.toDisplayString()
            + ' ' + this.blend  .toDisplayString();
    }



    hasInitValue()
    {
        return this.opacity.hasInitValue()
            && this.blend  .hasInitValue();
    }



    isValid()
    {
        return this.opacity && this.opacity.isValid()
            && this.blend   && this.blend  .isValid();
    }



    getNaN()
    {
        return LayerBlendValue.NaN;
    }



    static NaN = Object.freeze(new LayerBlendValue(NumberValue.NaN, NumberValue.NaN));
}



function parseLayerBlendValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [LayerBlendValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const opacity = parseNumberValue(str[i]); i += opacity[1];
    const blend   = parseNumberValue(str[i]); i += blend  [1];


    const layer = new LayerBlendValue(
        opacity[0],
        blend  [0]);

        
    return [layer, i - iStart];
}



class LayerMaskValue
extends GValue
{
    visible;
    maskType;



    constructor(maskType, visible = true)
    {
        super(LAYER_MASK_VALUE);

        this.visible  = visible;
        this.maskType = maskType.copy();
    }


    
    copy()
    {
        const copy = new LayerMaskValue(this.maskType, this.visible);

        copy.copyBase(this);

        return copy;
    }



    equals(mask)
    {
        return this.visible === mask.visible
            && this.maskType.equals(mask.maskType);
    }



    async eval(parse)
    {
        return this;
    }



    toString()
    {
        return 'mask';
    }



    toPreviewString()
    {
        return 'mask';
    }



    toDisplayString()
    {
        return 'mask';
    }



    isValid()
    {
        return this.maskType.isValid();
    }



    getNaN()
    {
        return LayerMaskValue.NaN;
    }



    static NaN = Object.freeze(new LayerMaskValue(NumberValue.NaN, false));
}



function parseLayerMaskValue(str)
{
    const mask = 
        str == NAN_DISPLAY
        ? LayerMaskValue.NaN
        : new LayerMaskValue(new NumberValue(parseInt(str)), true);

    return [mask, 1];
}



/*
    This is getting closer to Figma now, so here the format changes,
    and objects hold stroke values directly, which incoming stroke values just set.
*/

class ShapeValue
extends GValue
{
    nodeId;

    props = null;



    constructor(type, nodeId)
    {
        super(type);

        this.nodeId = nodeId; 

        this.objects = [];
    }



    copyBase(base)
    {
        super.copyBase(base);
        
        this.nodeId  = base.nodeId;

        this.objects = base.objects.map(o => o.copy());

        if (base.props) this.props = base.props.copy();
    }



    hasInitValue()
    {
        return !this.props
            ||  this.props.hasInitValue();
    }



    isValid()
    {
        return !this.props
            ||  this.props.isValid();
    }
}



function parseShapeBaseValue(str, i, obj)
{
    const props = parseListValue(str, i); i += props[1];

    obj.props = props[0];

    return i;
}


class RectangleValue
extends ShapeValue
{
    x;
    y;
    width;
    height;
    round;



    constructor(nodeId,
                x      = new NumberValue(0), 
                y      = new NumberValue(0), 
                width  = new NumberValue(0), 
                height = new NumberValue(0), 
                round  = new NumberValue(0))
    {
        super(RECTANGLE_VALUE, nodeId);

        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;
        this.round  = round;
    }



    copy()
    {
        const copy = new RectangleValue(
            this.nodeId,
            this.x     .copy(), 
            this.y     .copy(), 
            this.width .copy(), 
            this.height.copy(), 
            this.round .copy());

        copy.copyBase(this);

        return copy;
    }



    equals(rect)
    {
        return rect
            && this.x     .equals(rect.x     )
            && this.y     .equals(rect.y     )
            && this.width .equals(rect.width )
            && this.height.equals(rect.height)
            && this.round .equals(rect.round );
    }



    async eval(parse)
    {
        return this;
    }



    toString()
    {
        return      this.x     .toString()
            + ' ' + this.y     .toString()
            + ' ' + this.width .toString()
            + ' ' + this.height.toString()
            + ' ' + this.round .toString()
            + ' ' + super.toString();
    }



    toPreviewString()
    {
        return 'rectangle';
            // + ' ' + this.x     .toPreviewString()
            // + ' ' + this.y     .toPreviewString()
            // + ' ' + this.width .toPreviewString()
            // + ' ' + this.height.toPreviewString()
            // + ' ' + this.round .toPreviewString();
    }



    toDisplayString()
    {
        return      this.x     .toDisplayString()
            + ' ' + this.y     .toDisplayString()
            + ' ' + this.width .toDisplayString()
            + ' ' + this.height.toDisplayString()
            + ' ' + this.round .toDisplayString();
    }



    toValue()
    {
        return this.copy();
    }



    hasInitValue()
    {
        return super.hasInitValue()
            && this.x     .hasInitValue()
            && this.y     .hasInitValue()
            && this.width .hasInitValue()
            && this.height.hasInitValue()
            && this.round .hasInitValue();
    }



    isValid()
    {
        return super.isValid()
            && this.x     .isValid()
            && this.y     .isValid()
            && this.width .isValid()
            && this.height.isValid()
            && this.round .isValid();
    }


    
    static NaN = new RectangleValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseRectangleValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [RectangleValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x      = parseNumberValue(str[i]); i += x     [1];
    const y      = parseNumberValue(str[i]); i += y     [1];
    const width  = parseNumberValue(str[i]); i += width [1];
    const height = parseNumberValue(str[i]); i += height[1];
    const round  = parseNumberValue(str[i]); i += round [1];


    const rect = new RectangleValue(
        '', // set node ID elsewhere
        x     [0],
        y     [0],
        width [0],
        height[0],
        round [0]);


    i = parseShapeBaseValue(str, i, rect);

    
    return [rect, i - iStart];
}



class LineValue
extends ShapeValue
{
    x;
    y;
    width;



    constructor(nodeId,
                x      = new NumberValue(0), 
                y      = new NumberValue(0), 
                width  = new NumberValue(0))
    {
        super(LINE_VALUE, nodeId);

        this.x     = x;
        this.y     = y;
        this.width = width;
    }



    copy()
    {
        const copy = new LineValue(
            this.nodeId,
            this.x    .copy(), 
            this.y    .copy(), 
            this.width.copy())

        copy.copyBase(this);

        return copy;
    }



    equals(line)
    {
        return line
            && this.x    .equals(line.x    )
            && this.y    .equals(line.y    )
            && this.width.equals(line.width);
    }



    async eval(parse)
    {
        return this;
    }



    hasInitValue()
    {
        return super.hasInitValue()
            && this.x     .hasInitValue()
            && this.y     .hasInitValue()
            && this.width .hasInitValue();
    }



    isValid()
    {
        return super.isValid()
            && this.x    .isValid()
            && this.y    .isValid()
            && this.width.isValid();
    }



    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.x    .toString()
            + ' ' + this.y    .toString()
            + ' ' + this.width.toString()
            + ' ' + super.toString();
    }



    toPreviewString()
    {
        return      this.x    .toPreviewString()
            + ' ' + this.y    .toPreviewString()
            + ' ' + this.width.toPreviewString();
    }



    toDisplayString()
    {
        return      this.x    .toDisplayString()
            + ' ' + this.y    .toDisplayString()
            + ' ' + this.width.toDisplayString();
    }



    static NaN = new LineValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseLineValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [LineValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x     = parseNumberValue(str[i]); i += x    [1];
    const y     = parseNumberValue(str[i]); i += y    [1];
    const width = parseNumberValue(str[i]); i += width[1];


    const line = new LineValue(
        '', // set node ID elsewhere
        x    [0],
        y    [0],
        width[0]);


    i = parseShapeBaseValue(str, i, line);

    
    return [line, i - iStart];
}



class EllipseValue
extends ShapeValue
{
    position;
    x;
    y;
    width;
    height;
    round;
    from;
    to;
    inner;



    constructor(nodeId,
                position = new NumberValue(0),
                x        = new NumberValue(0), 
                y        = new NumberValue(0), 
                width    = new NumberValue(0), 
                height   = new NumberValue(0), 
                round    = new NumberValue(0), 
                from     = new NumberValue(0),
                to       = new NumberValue(0),
                inner    = new NumberValue(0))
    {
        super(ELLIPSE_VALUE, nodeId);

        this.position = position;
        this.x        = x;
        this.y        = y;
        this.width    = width;
        this.height   = height;
        this.round    = round;
        this.from     = from;
        this.to       = to;
        this.inner    = inner;
    }



    copy()
    {
        const copy = new EllipseValue(
            this.nodeId,
            this.position.copy(), 
            this.x       .copy(), 
            this.y       .copy(), 
            this.width   .copy(), 
            this.height  .copy(), 
            this.round   .copy(), 
            this.from    .copy(),
            this.to      .copy(),
            this.inner   .copy());

        copy.copyBase(this);

        return copy;
    }



    equals(ellipse)
    {
        return ellipse
            && this.position.equals(ellipse.position)
            && this.x       .equals(ellipse.x       )
            && this.y       .equals(ellipse.y       )
            && this.width   .equals(ellipse.width   )
            && this.height  .equals(ellipse.height  )
            && this.round   .equals(ellipse.round   )
            && this.from    .equals(ellipse.from    )
            && this.to      .equals(ellipse.to      )
            && this.inner   .equals(ellipse.inner   );
    }



    async eval(parse)
    {
        return this;
    }
    
    
    
    hasInitValue()
    {
        return super.hasInitValue()
            && this.position.hasInitValue()
            && this.x       .hasInitValue()
            && this.y       .hasInitValue()
            && this.width   .hasInitValue()
            && this.height  .hasInitValue()
            && this.round   .hasInitValue()
            && this.from    .hasInitValue()
            && this.to      .hasInitValue()
            && this.inner   .hasInitValue();
    }



    isValid()
    {
        return super.isValid()
            && this.position.isValid()
            && this.x       .isValid()
            && this.y       .isValid()
            && this.width   .isValid()
            && this.height  .isValid()
            && this.round   .isValid()
            && this.from    .isValid()
            && this.to      .isValid()
            && this.inner   .isValid();
    }



    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.position.toString()
            + ' ' + this.x       .toString()
            + ' ' + this.y       .toString()
            + ' ' + this.width   .toString()
            + ' ' + this.height  .toString()
            + ' ' + this.round   .toString()
            + ' ' + this.from    .toString()
            + ' ' + this.to      .toString()
            + ' ' + this.inner   .toString()
            + ' ' + super.toString();
    }



    toPreviewString()
    {
        return 'ellipse';
            // + ' ' + this.position.toPreviewString()
            // + ' ' + this.x       .toPreviewString()
            // + ' ' + this.y       .toPreviewString()
            // + ' ' + this.width   .toPreviewString()
            // + ' ' + this.height  .toPreviewString()
            // + ' ' + this.round   .toPreviewString()
            // + ' ' + this.inner   .toPreviewString() + '%'
            // + ' ' + this.from    .toPreviewString() + '°'
            // + ' ' + this.to      .toPreviewString() + '°';
    }



    toDisplayString()
    {
        return      this.position.toDisplayString()
            + ' ' + this.x       .toDisplayString()
            + ' ' + this.y       .toDisplayString()
            + ' ' + this.width   .toDisplayString()
            + ' ' + this.height  .toDisplayString()
            + ' ' + this.round   .toDisplayString()
            + ' ' + this.from    .toDisplayString()
            + ' ' + this.to      .toDisplayString()
            + ' ' + this.inner   .toDisplayString();
    }



    static NaN = new EllipseValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseEllipseValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [EllipseValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const pos    = parseNumberValue(str[i]); i += pos   [1];
    const x      = parseNumberValue(str[i]); i += x     [1];
    const y      = parseNumberValue(str[i]); i += y     [1];
    const width  = parseNumberValue(str[i]); i += width [1];
    const height = parseNumberValue(str[i]); i += height[1];
    const round  = parseNumberValue(str[i]); i += round [1];
    const from   = parseNumberValue(str[i]); i += from  [1];
    const to     = parseNumberValue(str[i]); i += to    [1];
    const inner  = parseNumberValue(str[i]); i += inner [1];


    const ellipse = new EllipseValue(
        '', // set node ID elsewhere,
        pos   [0],
        x     [0],
        y     [0],
        width [0],
        height[0],
        round [0],
        from  [0],
        to    [0],
        inner [0]);


    i = parseShapeBaseValue(str, i, ellipse);

    
    return [ellipse, i - iStart];
}



class TrapezeValue
extends ShapeValue
{
    x;
    y;
    width;
    height;
    round;
    bias;



    constructor(nodeId,
                x      = new NumberValue(0), 
                y      = new NumberValue(0), 
                width  = new NumberValue(0), 
                height = new NumberValue(0), 
                round  = new NumberValue(0),
                bias   = new NumberValue(0))
    {
        super(TRAPEZE_VALUE, nodeId);

        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;
        this.round  = round;
        this.bias   = bias;
    }



    copy()
    {
        const copy = new TrapezeValue(
            this.nodeId,
            this.x     .copy(), 
            this.y     .copy(), 
            this.width .copy(), 
            this.height.copy(), 
            this.round .copy(),
            this.bias  .copy());

        copy.copyBase(this);

        return copy;
    }



    equals(rect)
    {
        return rect
            && this.x     .equals(rect.x     )
            && this.y     .equals(rect.y     )
            && this.width .equals(rect.width )
            && this.height.equals(rect.height)
            && this.round .equals(rect.round )
            && this.bias  .equals(rect.bias  );
    }



    async eval(parse)
    {
        return this;
    }



    toString()
    {
        return      this.x     .toString()
            + ' ' + this.y     .toString()
            + ' ' + this.width .toString()
            + ' ' + this.height.toString()
            + ' ' + this.round .toString()
            + ' ' + this.bias  .toString()
            + ' ' + super.toString();
    }



    toPreviewString()
    {
        return 'trapeze';
            //        this.x     .toPreviewString()
            //+ ' ' + this.y     .toPreviewString()
            //+ ' ' + this.width .toPreviewString()
            //+ ' ' + this.height.toPreviewString()
            //+ ' ' + this.round .toPreviewString()
            //+ ' ' + this.bias  .toPreviewString();
    }



    toDisplayString()
    {
        return      this.x     .toDisplayString()
            + ' ' + this.y     .toDisplayString()
            + ' ' + this.width .toDisplayString()
            + ' ' + this.height.toDisplayString()
            + ' ' + this.round .toDisplayString()
            + ' ' + this.bias  .toDisplayString();
    }



    toValue()
    {
        return this.copy();
    }



    hasInitValue()
    {
        return super.hasInitValue()
            && this.x     .hasInitValue()
            && this.y     .hasInitValue()
            && this.width .hasInitValue()
            && this.height.hasInitValue()
            && this.round .hasInitValue()
            && this.bias  .hasInitValue();
    }


    
    isValid()
    {
        return super.isValid()
            && this.x     .isValid()
            && this.y     .isValid()
            && this.width .isValid()
            && this.height.isValid()
            && this.round .isValid()
            && this.bias  .isValid();
    }


    
    static NaN = new TrapezeValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseTrapezeValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [TrapezeValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x      = parseNumberValue(str[i]); i += x     [1];
    const y      = parseNumberValue(str[i]); i += y     [1];
    const width  = parseNumberValue(str[i]); i += width [1];
    const height = parseNumberValue(str[i]); i += height[1];
    const round  = parseNumberValue(str[i]); i += round [1];
    const bias   = parseNumberValue(str[i]); i += bias  [1];


    const rect = new TrapezeValue(
        '', // set node ID elsewhere
        x     [0],
        y     [0],
        width [0],
        height[0],
        round [0],
        bias  [0]);


    i = parseShapeBaseValue(str, i, rect);

    
    return [rect, i - iStart];
}



class PolygonValue
extends ShapeValue
{
    position;
    x;
    y;
    width;
    height;
    round;
    corners;



    constructor(nodeId,
                position = new NumberValue(0),
                x        = new NumberValue(0), 
                y        = new NumberValue(0), 
                width    = new NumberValue(0), 
                height   = new NumberValue(0), 
                round    = new NumberValue(0), 
                corners  = new NumberValue(0))
    {
        super(POLYGON_VALUE, nodeId);

        this.position = position;
        this.x        = x;
        this.y        = y;
        this.width    = width;
        this.height   = height;
        this.round    = round;
        this.corners  = corners;
    }



    copy()
    {
        const copy = new PolygonValue(
            this.nodeId,
            this.position.copy(), 
            this.x       .copy(), 
            this.y       .copy(), 
            this.width   .copy(), 
            this.height  .copy(), 
            this.round   .copy(), 
            this.corners .copy());
    
        copy.copyBase(this);

        return copy;
    }



    equals(poly)
    {
        return poly
            && this.position.equals(poly.position)
            && this.x       .equals(poly.x       )
            && this.y       .equals(poly.y       )
            && this.width   .equals(poly.width   )
            && this.height  .equals(poly.height  )
            && this.round   .equals(poly.round   )
            && this.corners .equals(poly.corners );
    }



    async eval(parse)
    {
        return this;
    }



    hasInitValue()
    {
        return super.hasInitValue()
            && this.position.hasInitValue()
            && this.x       .hasInitValue()
            && this.y       .hasInitValue()
            && this.width   .hasInitValue()
            && this.height  .hasInitValue()
            && this.round   .hasInitValue()
            && this.corners .hasInitValue();
    }



    isValid()
    {
        return super.isValid()
            && this.position.isValid()
            && this.x       .isValid()
            && this.y       .isValid()
            && this.width   .isValid()
            && this.height  .isValid()
            && this.round   .isValid()
            && this.corners .isValid();
    }



    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.position.toString()
            + ' ' + this.x       .toString()
            + ' ' + this.y       .toString()
            + ' ' + this.width   .toString()
            + ' ' + this.height  .toString()
            + ' ' + this.round   .toString()
            + ' ' + this.corners .toString()
            + ' ' + super.toString();
    }



    toPreviewString()
    {
        return      this.position.toPreviewString()
            + ' ' + this.x       .toPreviewString()
            + ' ' + this.y       .toPreviewString()
            + ' ' + this.width   .toPreviewString()
            + ' ' + this.height  .toPreviewString()
            + ' ' + this.round   .toPreviewString()
            + ' ' + this.corners .toPreviewString();
    }



    toDisplayString()
    {
        return      this.position.toDisplayString()
            + ' ' + this.x       .toDisplayString()
            + ' ' + this.y       .toDisplayString()
            + ' ' + this.width   .toDisplayString()
            + ' ' + this.height  .toDisplayString()
            + ' ' + this.round   .toDisplayString()
            + ' ' + this.corners .toDisplayString();
    }



    static NaN = new PolygonValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parsePolygonValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [PolygonValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const pos     = parseNumberValue(str[i]); i += pos    [1];
    const x       = parseNumberValue(str[i]); i += x      [1];
    const y       = parseNumberValue(str[i]); i += y      [1];
    const width   = parseNumberValue(str[i]); i += width  [1];
    const height  = parseNumberValue(str[i]); i += height [1];
    const round   = parseNumberValue(str[i]); i += round  [1];
    const corners = parseNumberValue(str[i]); i += corners[1];


    const poly = new PolygonValue(
        '', // set node ID elsewhere
        pos    [0],
        x      [0],
        y      [0],
        width  [0],
        height [0],
        round  [0],
        corners[0]);


    i = parseShapeBaseValue(str, i, poly);

    
    return [poly, i - iStart];
}



class StarValue
extends ShapeValue
{
    position;
    x;
    y;
    width;
    height;
    round;
    points;
    convex;



    constructor(nodeId,
                position = new NumberValue(0), 
                x        = new NumberValue(0), 
                y        = new NumberValue(0), 
                width    = new NumberValue(0), 
                height   = new NumberValue(0), 
                round    = new NumberValue(0), 
                points   = new NumberValue(0),
                convex   = new NumberValue(0))
    {
        super(STAR_VALUE, nodeId);

        this.position = position;
        this.x        = x;
        this.y        = y;
        this.width    = width;
        this.height   = height;
        this.round    = round;
        this.points   = points;
        this.convex   = convex;
    }



    copy()
    {
        const copy = new StarValue(
            this.nodeId,
            this.position.copy(), 
            this.x       .copy(), 
            this.y       .copy(), 
            this.width   .copy(), 
            this.height  .copy(), 
            this.round   .copy(), 
            this.points  .copy(),
            this.convex  .copy());

        copy.copyBase(this);

        return copy;
    }



    equals(star)
    {
        return star
            && this.position.equals(star.position)
            && this.x       .equals(star.x       )
            && this.y       .equals(star.y       )
            && this.width   .equals(star.width   )
            && this.height  .equals(star.height  )
            && this.round   .equals(star.round   )
            && this.points  .equals(star.points  )
            && this.convex  .equals(star.convex  );
    }



    async eval(parse)
    {
        return this;
    }



    hasInitValue()
    {
        return super.hasInitValue()
            && this.position.hasInitValue()
            && this.x       .hasInitValue()
            && this.y       .hasInitValue()
            && this.width   .hasInitValue()
            && this.height  .hasInitValue()
            && this.round   .hasInitValue()
            && this.points  .hasInitValue()
            && this.convex  .hasInitValue();
    }


    
    isValid()
    {
        return super.isValid()
            && this.position.isValid()
            && this.x       .isValid()
            && this.y       .isValid()
            && this.width   .isValid()
            && this.height  .isValid()
            && this.round   .isValid()
            && this.points  .isValid()
            && this.convex  .isValid();
    }


    
    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.position.toString()
            + ' ' + this.x       .toString()
            + ' ' + this.y       .toString()
            + ' ' + this.width   .toString()
            + ' ' + this.height  .toString()
            + ' ' + this.round   .toString()
            + ' ' + this.points  .toString()
            + ' ' + this.convex  .toString()
            + ' ' + super.toString();
    }



    toPreviewString()
    {
        return      this.position.toPreviewString()
            + ' ' + this.x       .toPreviewString()
            + ' ' + this.y       .toPreviewString()
            + ' ' + this.width   .toPreviewString()
            + ' ' + this.height  .toPreviewString()
            + ' ' + this.round   .toPreviewString()
            + ' ' + this.points  .toPreviewString()
            + ' ' + this.convex  .toPreviewString();
    }



    toDisplayString()
    {
        return      this.position.toDisplayString()
            + ' ' + this.x       .toDisplayString()
            + ' ' + this.y       .toDisplayString()
            + ' ' + this.width   .toDisplayString()
            + ' ' + this.height  .toDisplayString()
            + ' ' + this.round   .toDisplayString()
            + ' ' + this.points  .toDisplayString()
            + ' ' + this.convex  .toDisplayString();
    }



    static NaN = new StarValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseStarValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [StarValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const pos    = parseNumberValue(str[i]); i += pos   [1];
    const x      = parseNumberValue(str[i]); i += x     [1];
    const y      = parseNumberValue(str[i]); i += y     [1];
    const width  = parseNumberValue(str[i]); i += width [1];
    const height = parseNumberValue(str[i]); i += height[1];
    const round  = parseNumberValue(str[i]); i += round [1];
    const points = parseNumberValue(str[i]); i += points[1];
    const convex = parseNumberValue(str[i]); i += convex[1];


    const star = new StarValue(
        '', // set node ID elsewhere
        pos   [0],
        x     [0],
        y     [0],
        width [0],
        height[0],
        round [0],
        points[0],
        convex[0]);


    i = parseShapeBaseValue(str, i, star);

    
    return [star, i - iStart];
}



class TextShapeValue
extends ShapeValue
{
    text;
    x;
    y;
    width;
    height;
    font;
    style;
    size;
    alignH;
    alignV;
    lineHeight;
    letterSpacing;

    

    constructor(nodeId,
                text          = new TextValue(),
                x             = new NumberValue(0), 
                y             = new NumberValue(0), 
                width         = new NumberValue(0), 
                height        = new NumberValue(0), 
                font          = new NumberValue(0),
                style         = new NumberValue(0),
                size          = new NumberValue(0),
                alignH        = new NumberValue(0),
                alignV        = new NumberValue(0),
                lineHeight    = new NumberValue(0),
                letterSpacing = new NumberValue(0))
    {
        super(TEXT_SHAPE_VALUE, nodeId);

        this.text          = text;
        this.x             = x;
        this.y             = y;
        this.width         = width;
        this.height        = height;
        this.font          = font;
        this.style         = style;
        this.size          = size;
        this.alignH        = alignH;
        this.alignV        = alignV;
        this.lineHeight    = lineHeight;
        this.letterSpacing = letterSpacing;

        this.objects       = [];
    }



    copy()
    {
        const copy = new TextShapeValue(
            this.nodeId,
            this.text         .copy(),
            this.x            .copy(), 
            this.y            .copy(), 
            this.width        .copy(), 
            this.height       .copy(), 
            this.font         .copy(),
            this.style        .copy(),
            this.size         .copy(),
            this.alignH       .copy(),
            this.alignV       .copy(),
            this.lineHeight   .copy(),
            this.letterSpacing.copy()); 

        copy.copyBase(this);

        return copy;
    }



    equals(text)
    {
        return text
            && this.text         .equals(text.text         )
            && this.x            .equals(text.x            )
            && this.y            .equals(text.y            )
            && this.width        .equals(text.width        )
            && this.height       .equals(text.height       )
            && this.font         .equals(text.font         )
            && this.style        .equals(text.style        )
            && this.size         .equals(text.size         )
            && this.alignH       .equals(text.alignH       )
            && this.alignV       .equals(text.alignV       )
            && this.lineHeight   .equals(text.lineHeight   )
            && this.letterSpacing.equals(text.letterSpacing);
    }



    async eval(parse)
    {
        return this;
    }



    hasInitValue()
    {
        return super.hasInitValue()
            && this.text         .hasInitValue()
            && this.x            .hasInitValue()
            && this.y            .hasInitValue()
            && this.width        .hasInitValue()
            && this.height       .hasInitValue()
            && this.font         .hasInitValue()
            && this.style        .hasInitValue()
            && this.size         .hasInitValue()
            && this.alignH       .hasInitValue()
            && this.alignV       .hasInitValue()
            && this.lineHeight   .hasInitValue()
            && this.letterSpacing.hasInitValue();
    }


    
    isValid()
    {
        return super.isValid()
            && this.text         .isValid()
            && this.x            .isValid()
            && this.y            .isValid()
            && this.width        .isValid()
            && this.height       .isValid()
            && this.font         .isValid()
            && this.style        .isValid()
            && this.size         .isValid()
            && this.alignH       .isValid()
            && this.alignV       .isValid()
            && this.lineHeight   .isValid()
            && this.letterSpacing.isValid();
    }


    
    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.text         .toJson() // otherwise the string can't contain another string
            + ' ' + this.x            .toString()
            + ' ' + this.y            .toString()
            + ' ' + this.width        .toString()
            + ' ' + this.height       .toString()
            + ' ' + this.font         .toString()
            + ' ' + this.style        .toString()
            + ' ' + this.size         .toString()
            + ' ' + this.alignH       .toString()
            + ' ' + this.alignV       .toString()
            + ' ' + this.lineHeight   .toString()
            + ' ' + this.letterSpacing.toString()
            + ' ' + super.toString();
        }



    toPreviewString()
    {
        return      this.text         .toJson() // otherwise the string can't contain another string
            + ' ' + this.x            .toPreviewString()
            + ' ' + this.y            .toPreviewString()
            + ' ' + this.width        .toPreviewString()
            + ' ' + this.height       .toPreviewString()
            + ' ' + this.font         .toPreviewString()
            + ' ' + this.style        .toPreviewString()
            + ' ' + this.size         .toPreviewString()
            + ' ' + this.alignH       .toPreviewString()
            + ' ' + this.alignV       .toPreviewString()
            + ' ' + this.lineHeight   .toPreviewString()
            + ' ' + this.letterSpacing.toPreviewString();
    }



    toDisplayString()
    {
        return      this.text         .toDisplayString()
            + ' ' + this.x            .toDisplayString()
            + ' ' + this.y            .toDisplayString()
            + ' ' + this.width        .toDisplayString()
            + ' ' + this.height       .toDisplayString()
            + ' ' + this.font         .toDisplayString()
            + ' ' + this.style        .toDisplayString()
            + ' ' + this.size         .toDisplayString()
            + ' ' + this.alignH       .toDisplayString()
            + ' ' + this.alignV       .toDisplayString()
            + ' ' + this.lineHeight   .toDisplayString()
            + ' ' + this.letterSpacing.toDisplayString();
    }



    toJson()
    {
        return      this.text         .toJson()
            + ' ' + this.x            .toJson()
            + ' ' + this.y            .toJson()
            + ' ' + this.width        .toJson()
            + ' ' + this.height       .toJson()
            + ' ' + this.font         .toJson()
            + ' ' + this.style        .toJson()
            + ' ' + this.size         .toJson()
            + ' ' + this.alignH       .toJson()
            + ' ' + this.alignV       .toJson()
            + ' ' + this.lineHeight   .toJson()
            + ' ' + this.letterSpacing.toJson();
    }



    static NaN = new TextShapeValue(
        '',
        TextValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseTextShapeValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [TextShapeValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const text          = parseTextValue  (str[i]); i += text         [1];
    const x             = parseNumberValue(str[i]); i += x            [1];
    const y             = parseNumberValue(str[i]); i += y            [1];
    const width         = parseNumberValue(str[i]); i += width        [1];
    const height        = parseNumberValue(str[i]); i += height       [1];
    const font          = parseNumberValue(str[i]); i += font         [1];
    const style         = parseNumberValue(str[i]); i += style        [1];
    const size          = parseNumberValue(str[i]); i += size         [1];
    const alignH        = parseNumberValue(str[i]); i += alignH       [1];
    const alignV        = parseNumberValue(str[i]); i += alignV       [1];
    const lineHeight    = parseNumberValue(str[i]); i += lineHeight   [1];
    const letterSpacing = parseNumberValue(str[i]); i += letterSpacing[1];


    const txts = new TextShapeValue(
        '', // set node ID elsewhere
        text         [0],
        x            [0],
        y            [0],
        width        [0],
        height       [0],
        font         [0],
        style        [0],
        size         [0],
        alignH       [0],
        alignV       [0],
        lineHeight   [0],
        letterSpacing[0]);


    i = parseShapeBaseValue(str, i, txts);

    
    return [txts, i - iStart];
}



class PointValue
extends GValue
{
    nodeId;

    x;
    y;
    smooth;


    sp0 = null; //  sp0 ------- sp1 
    sp1 = null; //   |
    sp2 = null; //  sp2



    constructor(nodeId,
                x = new NumberValue(0), 
                y = new NumberValue(0),
                smooth = null)
    {
        super(POINT_VALUE);

        this.nodeId  = nodeId;

        this.x       = x;
        this.y       = y;
        this.smooth  = smooth;


        this.createDefaultSpace();
    }



    copy()
    {
        const copy = new PointValue(
            this.nodeId,
            this.x.copy(), 
            this.y.copy());

        if (this.smooth) copy.smooth = this.smooth.copy();

        copy.copyBase(this);

        copy.sp0 = clone(this.sp0);
        copy.sp1 = clone(this.sp1);
        copy.sp2 = clone(this.sp2);

        return copy;
    }



    equals(p)
    {
        return p
            && this.x.equals(p.x)
            && this.y.equals(p.y);
    }



    createDefaultSpace(cx = 0, cy = 0)
    {
        this.sp0 = point(cx,   cy  );
        this.sp1 = point(cx+1, cy  );
        this.sp2 = point(cx,   cy+1);
    }



    applySpaceTransform(xform, space)
    {
        this.sp0 = transformPoint(this.sp0, xform, space);
        this.sp1 = transformPoint(this.sp1, xform, space);
        this.sp2 = transformPoint(this.sp2, xform, space);
    }



    static create(nodeId, x, y)
    {
        return new PointValue(
            nodeId,
            new NumberValue(x),
            new NumberValue(y));
    }



    static fromPoint(nodeId, p)
    {
        return new PointValue(
            nodeId,
            new NumberValue(p.x),
            new NumberValue(p.y));
    }



    async eval(parse)
    {
        return this;
    }



    hasInitValue()
    {
        return this.x.hasInitValue()
            && this.y.hasInitValue()
            && (  !this.smooth
                || this.smooth.hasInitValue());
    }



    isValid()
    {
        return this.x.isValid()
            && this.y.isValid()
            && (  !this.smooth
                || this.smooth.isValid());
    }



    toString()
    {
        return this.x.isValid()
            && this.y.isValid()
            ?         this.x.toString()
              + ' ' + this.y.toString()
            : NAN_DISPLAY;
    }



    toPreviewString()
    {
        return this.x.isValid()
            && this.y.isValid()
            ?   '(' + this.x.toPreviewString()
              + ', ' + this.y.toPreviewString()
              + ')'
            : NAN_DISPLAY;
    }



    toDisplayString()
    {
        return this.x.isValid()
            && this.y.isValid()
            ?         this.x.toDisplayString()
              + ' ' + this.y.toDisplayString()
            : NAN_DISPLAY;
    }



    toValue()
    {
        return this.copy();
    }



    toPoint()
    {
        return point(
            this.x.value,
            this.y.value);
    }



    toJsCode(gen)
    {
        return '';//this.toPreviewString();
    }



    getNaN()
    {
        return PointValue.NaN;
    }



    static NaN = Object.freeze(new PointValue(
        '',
        NumberValue.NaN, 
        NumberValue.NaN));
}



function parsePointValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [PointValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x = parseNumberValue(str[i]); i += x[1];
    const y = parseNumberValue(str[i]); i += y[1];


    const rect = new PointValue(
        '', // set node ID elsewhere
        x[0],
        y[0]);


    return [rect, i - iStart];
}



class VectorPathValue
extends ShapeValue
{
    points;
    closed;
    degree;
    winding;
    round;



    constructor(nodeId,
                points  = new ListValue(), 
                closed  = new NumberValue(0), 
                degree  = new NumberValue(0), 
                winding = new NumberValue(0), 
                round   = new NumberValue(0))
    {
        super(VECTOR_PATH_VALUE, nodeId);

        this.points  = points ?? new ListValue();
        this.closed  = closed;
        this.degree  = degree;
        this.winding = winding;
        this.round   = round;
    }



    copy()
    {
        const copy = new VectorPathValue(
            this.nodeId,
            this.points .copy(), 
            this.closed .copy(), 
            this.degree .copy(), 
            this.winding.copy(), 
            this.round  .copy());

        copy.copyBase(this);

        return copy;
    }



    equals(rect)
    {
        return rect
            && this.points .equals(rect.points )
            && this.closed .equals(rect.closed )
            && this.degree .equals(rect.degree )
            && this.winding.equals(rect.winding)
            && this.round  .equals(rect.round  );
    }



    async eval(parse)
    {
        return this;
    }



    toString()
    {
        return      this.points .toString()
            + ' ' + this.closed .toString()
            + ' ' + this.degree .toString()
            + ' ' + this.winding.toString()
            + ' ' + this.round  .toString()
            + ' ' + super.toString();
    }



    toPreviewString()
    {
        return      this.points .toPreviewString()
            + ' ' + this.closed .toPreviewString()
            + ' ' + this.degree .toPreviewString()
            + ' ' + this.winding.toPreviewString()
            + ' ' + this.round  .toPreviewString();
    }



    toDisplayString()
    {
        return      this.points .toDisplayString()
            + ' ' + this.closed .toDisplayString()
            + ' ' + this.degree .toDisplayString()
            + ' ' + this.winding.toDisplayString()
            + ' ' + this.round  .toDisplayString();
    }



    toValue()
    {
        return this;//.copy();
    }



    hasInitValue()
    {
        return super.hasInitValue()
            && this.points .hasInitValue()
            && this.closed .hasInitValue()
            && this.degree .hasInitValue()
            && this.winding.hasInitValue()
            && this.round  .hasInitValue();
    }


    
    isValid()
    {
        return super.isValid()
            && this.points .isValid()
            && this.closed .isValid()
            && this.degree .isValid()
            && this.winding.isValid()
            && this.round  .isValid();
    }


    
    static NaN = new VectorPathValue(
        '',
        ListValue  .NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseVectorPathValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [VectorPathValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const points  = parseListValue  (str, i); i += points [1];
    const closed  = parseNumberValue(str[i]); i += closed [1];
    const degree  = parseNumberValue(str[i]); i += degree [1];
    const winding = parseNumberValue(str[i]); i += winding[1];
    const round   = parseNumberValue(str[i]); i += round  [1];

    const path = new VectorPathValue(
        '', // set node ID elsewhere
        points [0],
        closed [0],
        degree [0],
        winding[0],
        round  [0]);


    i = parseShapeBaseValue(str, i, path);

    
    return [path, i - iStart];
}



class VectorVertexValue
extends GValue
{
    nodeId;

    x;
    y;
    join;
    cap;
    round;



    constructor(nodeId,
                x     = new NumberValue(0), 
                y     = new NumberValue(0),
                join  = new NumberValue(0),
                cap   = new NumberValue(0),
                round = new NumberValue(0))
    {
        super(VECTOR_VERTEX_VALUE);

        this.nodeId = nodeId;

        this.x      = x    .copy();
        this.y      = y    .copy();
        this.join   = join .copy();
        this.cap    = cap  .copy();
        this.round  = round.copy();
    }



    copy()
    {
        const copy = new VectorVertexValue(
            this.nodeId,
            this.x    .copy(), 
            this.y    .copy(), 
            this.join .copy(), 
            this.cap  .copy(), 
            this.round.copy());

        copy.copyBase(this);

        return copy;
    }



    equals(p)
    {
        return p
            && this.x    .equals(p.x    )
            && this.y    .equals(p.y    )
            && this.join .equals(p.join )
            && this.cap  .equals(p.cap  )
            && this.round.equals(p.round);
    }



    static create(nodeId, x, y)
    {
        return new VectorVertexValue(
            nodeId,
            new NumberValue(x    ),
            new NumberValue(y    ),
            new NumberValue(join ),
            new NumberValue(cap  ),
            new NumberValue(round));
    }



    static fromPoint(nodeId, p)
    {
        return new VectorVertexValue(
            nodeId,
            new NumberValue(p.x),
            new NumberValue(p.y),
            new NumberValue(0),
            new NumberValue(0),
            new NumberValue(0));
    }



    async eval(parse)
    {
        return this;
    }



    hasInitValue()
    {
        return this.x    .hasInitValue()
            && this.y    .hasInitValue()
            && this.join .hasInitValue()
            && this.cap  .hasInitValue()
            && this.round.hasInitValue();
    }



    isValid()
    {
        return this.x    .isValid()
            && this.y    .isValid()
            && this.join .isValid()
            && this.cap  .isValid()
            && this.round.isValid();
    }



    toString()
    {
        return      this.x    .toString()
            + ' ' + this.y    .toString()
            + ' ' + this.join .toString()
            + ' ' + this.cap  .toString()
            + ' ' + this.round.toString();
    }



    toPreviewString()
    {
        return      this.x    .toPreviewString()
            + ' ' + this.y    .toPreviewString()
            + ' ' + this.join .toPreviewString()
            + ' ' + this.cap  .toPreviewString()
            + ' ' + this.round.toPreviewString();
    }



    toDisplayString()
    {
        return      this.x    .toDisplayString()
            + ' ' + this.y    .toDisplayString()
            + ' ' + this.join .toDisplayString()
            + ' ' + this.cap  .toDisplayString()
            + ' ' + this.round.toDisplayString();
    }



    toValue()
    {
        return this.copy();
    }



    toPoint()
    {
        return point(
            this.x.value,
            this.y.value);
    }



    toJsCode(gen)
    {
        return '';//this.toPreviewString();
    }



    getNaN()
    {
        return VectorVertexValue.NaN;
    }



    static NaN = Object.freeze(new VectorVertexValue(
        '',
        NumberValue.NaN, 
        NumberValue.NaN, 
        NumberValue.NaN, 
        NumberValue.NaN, 
        NumberValue.NaN));
}



function parseVectorVertexValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [VectorVertexValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x     = parseNumberValue(str[i]); i += x    [1];
    const y     = parseNumberValue(str[i]); i += y    [1];
    const join  = parseNumberValue(str[i]); i += join [1];
    const cap   = parseNumberValue(str[i]); i += cap  [1];
    const round = parseNumberValue(str[i]); i += round[1];


    const point = new VectorVertexValue(
        '', // set node ID elsewhere
        x    [0],
        y    [0],
        join [0],
        cap  [0],
        round[0]);


    return [point, i - iStart];
}



class VectorEdgeValue
extends GValue
{
    nodeId;

    start;
    end;
    startTangent;
    endTangent;



    constructor(nodeId,
                start, 
                end,
                startTangent = PointValue.create(nodeId, 0, 0),
                endTangent   = PointValue.create(nodeId, 0, 0))
    {
        super(VECTOR_EDGE_VALUE);

        this.nodeId = nodeId;

        this.start        = start       .copy();       
        this.end          = end         .copy();         
        this.startTangent = startTangent.copy();
        this.endTangent   = endTangent  .copy();  
    }



    copy()
    {
        const copy = new VectorEdgeValue(
            this.nodeId,
            this.start       .copy(), 
            this.end         .copy(), 
            this.startTangent.copy(), 
            this.endTangent  .copy());

        copy.copyBase(this);

        return copy;
    }



    equals(edge)
    {
        return edge
            && this.start       .equals(edge.start       )
            && this.end         .equals(edge.end         )
            && this.startTangent.equals(edge.startTangent)
            && this.  endTangent.equals(edge.  endTangent);
    }



    static create(nodeId, start, end, startTangent, endTangent)
    {
        return new VectorEdgeValue(
            nodeId,
            start,
            end,
            PointValue.create(nodeId, startTangent.x, startTangent.y),
            PointValue.create(nodeId,   endTangent.x,   endTangent.y));
    }



    async eval(parse)
    {
        return this;
    }



    hasInitValue()
    {
        return this.start       .hasInitValue()
            && this.end         .hasInitValue()
            && this.startTangent.hasInitValue()
            && this.endTangent  .hasInitValue();
    }



    isValid()
    {
        return this.start       .isValid()
            && this.end         .isValid();
            // && this.startTangent.isValid()
            // && this.endTangent  .isValid();
    }



    toString()
    {
        return      this.start       .toString()
            + ' ' + this.end         .toString()
            + ' ' + this.startTangent.toString()
            + ' ' + this.endTangent  .toString();
    }



    toPreviewString()
    {
        return      this.start       .toString()
            + ' ' + this.end         .toString()
            + ' ' + this.startTangent.toString()
            + ' ' + this.endTangent  .toString();
    }



    toDisplayString()
    {
        return      this.start       .toDisplayString()
            + ' ' + this.end         .toDisplayString()
            + ' ' + this.startTangent.toDisplayString()
            + ' ' + this.endTangent  .toDisplayString();
    }



    toValue()
    {
        return this.copy();
    }



    toJsCode(gen)
    {
        return '';//this.toPreviewString();
    }



    getNaN()
    {
        return VectorEdgeValue.NaN;
    }



    static NaN = Object.freeze(new VectorEdgeValue(
        '',
        VectorVertexValue.NaN, 
        VectorVertexValue.NaN, 
        PointValue.NaN, 
        PointValue.NaN));
}



function parseVectorEdgeValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [VectorEdgeValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const start        = parseVectorVertexValue(str, i); i += start       [1];
    const end          = parseVectorVertexValue(str, i); i += end         [1];
    const startTangent = parsePointValue       (str, i); i += startTangent[1];
    const endTangent   = parsePointValue       (str, i); i +=   endTangent[1];


    const edge = new VectorEdgeValue(
        '', // set node ID elsewhere
        start       [0],
        end         [0],
        startTangent[0],
          endTangent[0]);


    return [edge, i - iStart];
}



class VectorRegionValue
extends ShapeValue
{
    loops;  
    winding;

    fills = [];



    constructor(nodeId,
                loops   = new ListValue(), 
                winding = new NumberValue(0))
    {
        super(VECTOR_REGION_VALUE, nodeId);

        this.loops   = loops;  
        this.winding = winding;
    }



    copy()
    {
        const copy = new VectorRegionValue(
            this.nodeId,
            this.loops  .copy(), 
            this.winding.copy());

        copy.fills = clone(this.fills);
        
        copy.copyBase(this);

        return copy;
    }



    equals(region)
    {
        return region
            && this.loops  .equals(region.loops  )
            && this.winding.equals(region.winding);
    }



    // static create(nodeId, loops, winding, props)
    // {
    //     return new VectorRegionValue(
    //         nodeId,
    //         loops,
    //         new NumberValue(winding));
    // }



    async eval(parse)
    {
        return this;
    }



    hasInitValue()
    {
        return this.loops  .hasInitValue()
            && this.winding.hasInitValue();
    }



    isValid()
    {
        return this.loops  .isValid()
            && this.winding.isValid();
    }



    toString()
    {
        return      this.loops  .toString()
            + ' ' + this.winding.toString();
    }



    toPreviewString()
    {
        return      this.loops  .toPreviewString()
            + ' ' + this.winding.toPreviewString();
    }



    toDisplayString()
    {
        return      this.loops  .toDisplayString()
            + ' ' + this.winding.toDisplayString();
    }



    toValue()
    {
        return this.copy();
    }



    toJsCode(gen)
    {
        return '';//this.toPreviewString();
    }



    getNaN()
    {
        return VectorEdgeValue.NaN;
    }



    static NaN = Object.freeze(new VectorRegionValue(
        '',
        ListValue  .NaN, 
        NumberValue.NaN));
}



function parseVectorRegionValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [VectorRegionValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const loops   = parseListValue  (str, i); i += loops  [1];
    const winding = parseNumberValue(str[i]); i += winding[1];


    const region = new VectorRegionValue(
        '', // set node ID elsewhere
        loops  [0],
        winding[0]);


    i = parseShapeBaseValue(str, i, region);


    return [region, i - iStart];
}



class VectorNetworkValue
extends GValue
{
    nodeId;

    regions;



    constructor(nodeId,
                regions = new ListValue())
    {
        super(VECTOR_NETWORK_VALUE);

        this.nodeId  = nodeId;

        this.regions = regions; 
    }



    copy()
    {
        const copy = new VectorNetworkValue(
            this.nodeId,
            this.regions.copy());

        copy.copyBase(this);

        return copy;
    }



    equals(region)
    {
        return region
            && this.regions.equals(region.regions);
    }



    static create(nodeId, regions)
    {
        return new VectorNetworkValue(
            nodeId,
            regions);
    }



    async eval(parse)
    {
        return this;
    }



    hasInitValue()
    {
        return this.regions.hasInitValue();
    }



    isValid()
    {
        return this.regions.isValid();
    }



    toString()
    {
        return this.regions.toString();
    }



    toPreviewString()
    {
        return this.regions.toPreviewString();
    }



    toDisplayString()
    {
        return this.regions.toDisplayString();
    }



    toValue()
    {
        return this.copy();
    }



    toJsCode(gen)
    {
        return '';//this.toPreviewString();
    }



    getNaN()
    {
        return VectorNetworkValue.NaN;
    }



    static NaN = Object.freeze(new VectorNetworkValue(
        '',
        ListValue.NaN));
}



function parseVectorNetworkValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [VectorNetworkValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const regions = parseListValue(str, i); i += regions[1];


    const net = new VectorNetworkValue(
        '', // set node ID elsewhere
        regions[0]);


    return [net, i - iStart];
}



class ShapeBooleanValue
extends ShapeValue
{
    operation;
    children;



    constructor(nodeId, operation, children)
    {
        super(BOOLEAN_VALUE, nodeId);

        this.operation = operation;
        this.children  = children;

        this.objects = 
            children.objects
            ? children.objects.map(o => o.copy())
            : null;
    }



    copy()
    {
        const copy = new ShapeGroupValue(
            this.nodeId,
            this.operation.copy(),
            this.children .copy());

        copy.copyBase(this);

        return copy;
    }



    equals(bool)
    {
        return bool
            && this.operation.equals(bool.operation)
            && this.children .equals(bool.children );
    }



    async eval(parse)
    {
        return this;
    }



    toString()
    {
        return      this.operation.toString()
            + ' ' + this.children .toString();
    }



    toPreviewString()
    {
        return      this.operation.toPreviewString()
            + ' ' + this.children .toPreviewString();
    }



    toDisplayString()
    {
        return      this.operation.toDisplayString()
            + ' ' + this.children .toDisplayString();
    }



    toValue()
    {
        return this.copy();
    }



    isValid()
    {
        return super.isValid()
            && this.operation.isValid()
            && this.children .isValid();
    }


    
    static NaN = new ShapeBooleanValue(
        '',
        NumberValue.NaN,
        ListValue  .NaN);
}



function parseShapeBooleanValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [ShapeBooleanValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const operation = parseNumberValue(str[i]); i += operation[1];
    const children  = parseListValue  (str, i); i += children [1];

    const bool = new ShapeBooleanValue(
        '', // set node ID elsewhere
        operation[0],
        children [0]);


    i = parseShapeBaseValue(str, i, bool);

    
    return [bool, i - iStart];
}



class ShapeGroupValue
extends GValue
{
    items = [];



    constructor(nodeId, items = [])
    {
        super(SHAPE_GROUP_VALUE, nodeId);

        this.items = items;

        //this.objects = children.objects.map(o => o.copy());
    }



    copy()
    {
        const copy = new ShapeGroupValue(
            this.nodeId,
            this.items.map(i => i.copy()));

        copy.copyBase(this);

        return copy;
    }



    equals(group)
    {
        if (!group)                                  return false;
        if (!(group instanceof ShapeGroupValue))     return false;
        if (this.items.length != group.items.length) return false;
            
        for (let i = 0; i < this.items.length; i++)
            if (!this.items[i].equals(group.items[i]))
                return false;

        return true;
    }



    async eval(parse)
    {
        return this;
    }



    toString()
    {
        if (!this.items)
            return '';


        let str = '';
        
        
        str += this.items.length;

        for (let i = 0; i < this.items.length; i++)
        {
            const item = this.items[i];

            str += ' ' + item.type + ' ';
            str += item.toString();
        }


        return str;
    }



    toPreviewString()
    {
        if (!this.items)
            return '';


        let str = '';
        
        
        str += this.items.length;

        for (let i = 0; i < this.items.length; i++)
        {
            const item = this.items[i];

            str += ' ' + item.type + ' ';
            str += item.toPreviewString();
        }


        return str;
    }



    toDisplayString()
    {
        if (!this.items)
            return '';


        let str = '';
        
        
        str += this.items.length;

        for (let i = 0; i < this.items.length; i++)
        {
            const item = this.items[i];

            str += ' ' + item.type + ' ';
            str += item.toDisplayString();
        }


        return str;
    }



    toValue()
    {
        return this.copy();
    }



    isValid()
    {
        return  this.items
            && !this.items.find(i => !i.isValid());
    }


    
    static NaN = new ShapeGroupValue(
        '',
        ListValue.NaN);
}



function parseShapeGroupValue(str, i = -1)
{
    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }
        

    const iStart = i;

    const group = new ShapeGroupValue();
    

    const nInputs = parseInt(str[i++]);


    for (let j = 0; j < nInputs; j++)
    {
        const type = str[i++];
        
        switch (type)
        {
            case         LIST_VALUE:  
            case   SHAPE_LIST_VALUE: { const _list   = parseListValue        (str, i);  i += _list  [1];  group.items.push(_list  [0]);  break; }
 
            case    RECTANGLE_VALUE: { const rect    = parseRectangleValue   (str, i);  i += rect   [1];  group.items.push(rect   [0]);  break; }
            case         LINE_VALUE: { const line    = parseLineValue        (str, i);  i += line   [1];  group.items.push(line   [0]);  break; }
            case      ELLIPSE_VALUE: { const ellipse = parseEllipseValue     (str, i);  i += ellipse[1];  group.items.push(ellipse[0]);  break; }
            case      TRAPEZE_VALUE: { const ellipse = parseTrapezeValue     (str, i);  i += ellipse[1];  group.items.push(ellipse[0]);  break; }
            case      POLYGON_VALUE: { const poly    = parsePolygonValue     (str, i);  i += poly   [1];  group.items.push(poly   [0]);  break; }
            case         STAR_VALUE: { const star    = parseStarValue        (str, i);  i += star   [1];  group.items.push(star   [0]);  break; }
            case   TEXT_SHAPE_VALUE: { const text    = parseTextShapeValue   (str, i);  i += text   [1];  group.items.push(text   [0]);  break; }
            case        POINT_VALUE: { const point   = parsePointValue       (str, i);  i += point  [1];  group.items.push(point  [0]);  break; }
            case  VECTOR_PATH_VALUE: { const path    = parseVectorPathValue  (str, i);  i += path   [1];  group.items.push(path   [0]);  break; }
            case      BOOLEAN_VALUE: { const path    = parseShapeBooleanValue(str, i);  i += path   [1];  group.items.push(path   [0]);  break; }
            case  SHAPE_GROUP_VALUE: { const _group  = parseShapeGroupValue  (str, i);  i += _group [1];  group.items.push(_group [0]);  break; }
            case        FRAME_VALUE: { const frame   = parseFrameValue       (str, i);  i += frame  [1];  group.items.push(frame  [0]);  break; }
        }
    }

    
    return [
        group, 
        i - iStart];
}



class FrameValue
extends ShapeValue
{
    x;
    y;
    width;
    height;
    round;
    children;



    constructor(nodeId, x, y, width, height, round, children)
    {
        super(FRAME_VALUE, nodeId);

        this.x        = x;
        this.y        = y;
        this.width    = width;
        this.height   = height;
        this.round    = round;
        this.children = children;

        this.objects = 
               children
            && children.objects 
            ? children.objects.map(o => o.copy()) 
            : [];
    }



    copy()
    {
        const copy = new FrameValue(
            this.nodeId,
            this.x       .copy(),
            this.y       .copy(),
            this.width   .copy(),
            this.height  .copy(),
            this.round   .copy(),
            this.children.copy());

        copy.copyBase(this);

        return copy;
    }



    equals(frame)
    {
        return frame
            && this.x       .equals(frame.x       )
            && this.y       .equals(frame.y       )
            && this.width   .equals(frame.width   )
            && this.height  .equals(frame.height  )
            && this.round   .equals(frame.round   )
            && this.children.equals(frame.children);
    }



    async eval(parse)
    {
        return this;
    }



    toString()
    {
        return      this.x       .toString()
            + ' ' + this.y       .toString()
            + ' ' + this.width   .toString()
            + ' ' + this.height  .toString()
            + ' ' + this.round   .toString()
            + ' ' + this.children.toString();
    }



    toPreviewString()
    {
        return      this.x       .toPreviewString()
            + ' ' + this.y       .toPreviewString()
            + ' ' + this.width   .toPreviewString()
            + ' ' + this.height  .toPreviewString()
            + ' ' + this.round   .toPreviewString()
            + ' ' + this.children.toPreviewString();
    }



    toDisplayString()
    {
        return      this.x       .toDisplayString()
            + ' ' + this.y       .toDisplayString()
            + ' ' + this.width   .toDisplayString()
            + ' ' + this.height  .toDisplayString()
            + ' ' + this.round   .toDisplayString()
            + ' ' + this.children.toDisplayString();
    }



    toValue()
    {
        return this.copy();
    }



    isValid()
    {
        return this.x       .isValid()
            && this.y       .isValid()
            && this.width   .isValid()
            && this.height  .isValid()
            && this.round   .isValid()
            && this.children.isValid()
            && super.isValid();
    }


    
    static NaN = new FrameValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        ListValue  .NaN);
}



function parseFrameValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [FrameValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x        = parseNumberValue(str[i]); i += x      [1];
    const y        = parseNumberValue(str[i]); i += y      [1];
    const width    = parseNumberValue(str[i]); i += width  [1];
    const height   = parseNumberValue(str[i]); i += height [1];
    const round    = parseNumberValue(str[i]); i += round  [1];
    const children = parseListValue  (str, i); i += children[1];

    const frame = new FrameValue(
        '', // set node ID elsewhere
        x       [0],
        y       [0],
        width   [0],
        height  [0],
        round   [0],
        children[0]);


    i = parseShapeBaseValue(str, i, frame);

    
    return [frame, i - iStart];
}



class GStart
extends GOperator1
{
    feedback = null;
    from     = null;

    loopId   = NULL;

    

    constructor(nodeId, options)
    {
        super(START, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.feedback = null;
        this.from     = null;
    }



    copy()
    {
        const copy = new GStart(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.value   ) copy.value    = this.value   .copy();
        if (this.feedback) copy.feedback = this.feedback.copy();

        return copy;
    }



    isCached()
    {
        return super.isCached()
            && (  !this.input 
                || this.input.isCached());
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const feedback = this.feedback ? (await this.feedback.eval(parse)).toValue() : null;


        this.value = 
            this.input 
            ? (await this.input.eval(parse)).toValue() 
            : NullValue;


        this.setUpdateValues(parse, 
        [
            ['feedback', feedback]
        ]);


        await this.evalObjects(parse, {feedback: feedback.value > 0});

        
        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        const repeat = parse.repeats.find(r => r.repeatId == this.loopId);


        this.updateObjects(
               this.from
            && repeat
            && repeat.iteration > 0
            && options.feedback
            ? this.from.iterationObjects 
            : (   this.input 
               && this.input.value.objects 
               ? this.input.value.objects 
               : []),
            repeat 
            ? repeat.iteration.toString()
            : '');

        this.from = null;

        
        await super.evalObjects(parse);
    }



    updateObjects(objects, iteration)
    {
        if (!this.value.isValid())
            return;
            
        this.value.objects = objects.map(o => o.copy());

        for (const obj of this.value.objects)
        {
            obj.nodeId   = this.nodeId;
            obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;
        }
    }
    

    
    toValue()
    {
        return this.value.copy();
    }



    isValid()
    {
        return super.isValid()
            && this.feedback && this.feedback.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.feedback) this.feedback.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        this.from = from;

        if (this.feedback) this.feedback.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.feedback) this.feedback.iterateLoop(parse);
    }
}



class GRepeat
extends GOperator1
{
    count = null;
   _while = null;
    loop  = null;

    iterationObjects = [];



    constructor(nodeId, options)
    {
        super(REPEAT, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this. count = null;
        this._while = null;
        this. loop  = null;

        this.iterationObjects = [];
    }



    copy()
    {
        const copy = new GRepeat(this.nodeId, this.options);

        copy.copyBase(this);

        if (this. value) copy. value = this. value.copy();
        if (this. count) copy. count = this. count.copy();
        if (this._while) copy._while = this._while.copy();
        if (this. loop ) copy. loop  = this. loop .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;
            

        let   count = (await this.count.eval(parse)).toValue();
        let  _while = new NumberValue(1);
        const loop  = (await this.loop.eval(parse)).toValue();


        count = 
            count
            ? new NumberValue(Math.floor(count.value))
            : new NumberValue(0);


        if (this.loop.type != NUMBER_VALUE) assertVolatile(this.loop, this);


        this.value = new ListValue();
        this.value.objects = [];


        if (count.value > 0)
        {
            if (this.input)
                //&& this.input.isValid())
            {
                const startTime    = Date.now();
                let   showProgress = false;


                const nRepeats = 
                       this.options.enabled 
                    ? count.value 
                    : 0;
                

                let repeat =
                {
                    repeatId:  this.nodeId,
                    iteration: 0,
                    total:     nRepeats
                };

                    
                parse.repeats.push(repeat);

                if (parse.repeats.length == 1)
                    parse.totalProgress += nRepeats;


                if (this.loop.type != NUMBER_VALUE) 
                    this.loop.initLoop(parse, this.nodeId);


                for (let i = 0, o = 0; i < Math.max(1, nRepeats); i++)
                {
                    _while = (await this._while.eval(parse)).toValue();
                    
                    if (_while.value == 0)
                        break;
                

                    if (  !showProgress
                        && Date.now() - startTime > 50)
                    {
                        genInitNodeProgress(this.nodeId);
                        showProgress = true;
                    }


                    repeat.iteration = i;


                    this.input.invalidateInputs(parse, this, false);

                    //if (this.loop.type != NUMBER_VALUE)
                    //{
                        //this.loop.invalidateInputs(parse, this, false);
                        //this.loop.iterateLoop(parse);
                    //}
                    

                    const input = (await this.input.eval(parse)).toValue();


                    if (   input
                        && nRepeats > 0)
                    {
                        this.value.items.push(input);


                        if (   this.options.active
                            || this.options.beforeActive)
                        {
                            this.iterationObjects = [];
                        
                            if (this.input.value.objects)
                            {
                                for (let j = 0; j < this.input.value.objects.length; j++, o++)
                                {
                                    const obj = copyFigmaObject(this.input.value.objects[j]);

                                    this.iterationObjects.push(obj.copy());

                                    obj.nodeId      = this.nodeId;
                                    obj.listId      = i;

                                    obj.objectId    = obj.objectId + OBJECT_SEPARATOR + this.nodeId + ':' + (o+1).toString();
                                    obj.objectName += ' ' + (o+1).toString();

                                    obj.itemIndex   = repeat.iteration;

                                    if (this.value.objects)
                                        this.value.objects.push(obj);
                                }
                            }
                        }
                    }


                    this.input.iterateLoop(parse);


                    if (parse.repeats.length == 1)
                    {
                        parse.currentProgress++;
                        
                        const stopRequestId = await genGetValueFromUi('stopRequestId');

                    //     if (   parse.requestId == stopRequestId.value
                    //         || curRequestIds.includes(parse.requestId)) 
                    //     { 
                    //         console.log('repeat stop');
                    //         parse.stopGenerate = true;
                    //         break; 
                    //     }
                    }


                    if (showProgress)
                        genUpdateNodeProgress(parse, this.nodeId, i / nRepeats);
                }


                if (this.loop.type != NUMBER_VALUE)
                    this.loop.resetLoop(parse, this.nodeId, true);


                if (this.startTimer > -1)
                {
                    clearTimeout(this.startTimer);
                    this.startTimer = -1;
                }


                genEndNodeProgress(this.nodeId);


                consoleAssert(parse.repeats.at(-1) == repeat, 'invalid nested repeat \'' + this.nodeId + '\'');
                parse.repeats.pop();
            }
            else if (this.input)
                await this.input.eval(parse);
        }
        else
        {
            if (this.input)
                await this.input.eval(parse);
        }


        this.setUpdateValues(parse,
        [
            ['type',  this.outputListType()],
            ['count', count                ]
        ]);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value.copy();
    }



    isValid()
    {
        return super.isValid()
            && this. count && this. count.isValid()
            && this._while && this._while.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this. count) this. count.pushValueUpdates(parse);
        if (this._while) this._while.pushValueUpdates(parse);
        if (this. loop ) this. loop .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this. count) this. count.invalidateInputs(parse, from, force);
        if (this._while) this._while.invalidateInputs(parse, from, force);
        if (this. loop ) this. loop .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this. count) this. count.iterateLoop(parse);
        if (this._while) this._while.iterateLoop(parse);
        if (this. loop ) this. loop .iterateLoop(parse);
    }
}



function assertVolatile(loop, node)
{
    consoleAssert(
           loop.type == DEFINE
        || loop.type == FREEZE
        || loop.type == NUMBER_RANGE
        || loop.type == NUMBER_WAVE
        || loop.type == NUMBER_SEQUENCE
        || loop.type == NUMBER_RANDOM
        || loop.type == NUMBER_NOISE
        || loop.type == NUMBER_PROBABILITY
        || loop.type == COMBINE
        || loop.type == PARAM, // for OpStart
        'only volatile types can be repeated');
}


class GNull
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(NULL_NODE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GNull(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.value) copy.value = this.value.copy();
        if (this.input) copy.input = this.input.copy();

        return copy;
    }



    async eval(parse)
    {
        // if (this.isCached())
        //     return this;


        this.value = 
            this.input 
            ? (await this.input.eval(parse)).toValue() 
            : NullValue;


        this.updateValueObjects();


        this.setUpdateValues(parse,
        [
            ['type', this.outputType()]
        ]);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }
}



class GVariable
extends GOperator
{
    varValue = null;



    constructor(nodeId, options, styleId)
    {
        super(VARIABLE, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.varValue = null;
    }



    copy()
    {
        const copy = new GColorStyle(this.nodeId, this.options);

        if (this.varValue) copy.varValue = this.varValue.copy();
        
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        this.value = 
            this.varValue
            ? (await this.varValue.eval(parse)).toValue()
            : NullValue;


        this.setUpdateValues(parse,
        [
            ['value', this.value]
        ]);


        this.validate();

        return this;
    }



    evalVariable(options = {})
    {
        if (!this.options.enabled)
            return;
    }



    isValid()
    {
        return this.varValue && this.varValue.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.varValue) this.varValue.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.varValue) this.varValue.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.varValue) this.varValue.iterateLoop(parse);
    }
}


class GVariableGroup
extends GOperator
{
    input = null;



    constructor(nodeId, options)
    {
        super(VARIABLE_GROUP, nodeId, options);
    }



    copy()
    {
        const copy = new GList(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();
        
        for (const key of this.keys())
        {
            if (this[key] instanceof GValue)
                Object.assign(copy, {[key]: this[key]});
        }

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = this.input ? (await this.input.eval(parse)).toValue() : ListValue.NaN;


        this.updateValues = [];

        
        // if (    this.value.isValid()
        //     && !isEmpty(this.value.items))
        // {
        //     for (let i = 0; i < this.value.items.length; i++)
        //     {
        //         const item = this.value.items[i];
                
        //         let valueId = 
        //             item.valueId.trim() != ''
        //             ? item.valueId
        //             : i.toString();

        //         valueId = getNewNumberId(
        //             valueId,
        //             id => this.value.items.find(i => 
        //                    i != item 
        //                 && i.valueId == id));

        //         Object.assign(this, {[valueId]: item});
        //         this.setUpdateValues(parse, [[valueId, item]], true);

        //         item.sortId = i;
        //     }

        //     this.updateValues.sort((a, b) => a.sortId - b.sortId);
        // }
        // else
            this.setUpdateValues(parse, [['', NullValue]], true);


        // if (this.value.objects)
        //     for (let j = 0; j < this.value.objects.length; j++)
        //         this.value.objects[j].nodeId = this.nodeId;


        this.validate();

        return this;
    }
    
    

    paramFromId(paramId)
    {
        return this.value
            && this.value.items
            && paramId != 'value'
            ? this.value.items.find(i => i.valueId == paramId) //this[paramId]
            : null;
    }



    toValue()
    {
        return this.value.copy();
    }



    isValid()
    {
        return this.input && this.input.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input) this.input.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.input) this.input.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input) this.input.iterateLoop(parse);
    }
}


class GCache
extends GOperator1
{
    cachedValue = null;



    constructor(nodeId, options)
    {
        super(CACHE, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.cachedValue = null;
    }



    copy()
    {
        const copy = new GCache(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.value) copy.value = this.value.copy();

        return copy;
    }



    async eval(parse)
    {
        if (!this.options.enabled)
            this.cachedValue = null;
            
        if (   this.isCached()
            && this.cachedValue)
            return this;


        if (this.cachedValue)
            this.value = this.cachedValue.copy();

        else
        {
            this.value = 
                this.input 
                ? (await this.input.eval(parse)).toValue() 
                : NullValue;

            if (this.options.enabled)
                this.cachedValue = this.value.copy();
        }


        this.updateValueObjects();


        this.setUpdateValues(parse,
        [
            ['type', this.outputType()]
        ]);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        const repeat = parse.repeats.find(r => r.repeatId == this.loopId);

        if (   repeat
            && repeat.nodeId == from.nodeId)
            this.cachedValue = null;
    }



    // iterateLoop(parse)
    // {
    //     super.iterateLoop(parse);

    //     this.cachedValue = null;
    // }
}



class GFreeze
extends GOperator1
{
    frozen = false;

    loopId = NULL;



    constructor(nodeId, options)
    {
        super(FREEZE, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.frozen = false;
    }



    copy()
    {
        const copy = new GFreeze(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.value) copy.value = this.value.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const repeat = parse.repeats.find(r => r.repeatId == this.loopId);


        if (      repeat
               && repeat.iteration == 0
            || !this.options.enabled)
            this.frozen = false;


        if (!this.frozen)
        {
            this.value = 
                this.input 
                ? (await this.input.eval(parse)).toValue()
                : NullValue;

            this.frozen = true;

            this.updateValueObjects();
        }


        this.setUpdateValues(parse,
        [
            ['type', this.outputType()]
        ]);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }
}



class GTimer
extends GOperator1
{
    interval = null;
   _while    = null;
    loop     = null;



    constructor(nodeId, options)
    {
        super(TIMER, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this. interval = null;
        this._while    = null;
        this. loop     = null;
    }



    copy()
    {
        const copy = new GTimer(this.nodeId, this.options);

        copy.copyBase(this);

        if (this. interval) copy. interval = this. interval.copy();
        if (this._while   ) copy._while    = this._while   .copy();
        if (this. loop    ) copy. loop     = this. loop    .copy();

        return copy;
    }



    isCached()
    {
        return super.isCached()
            && (  !this.input 
                || this.input.isCached());
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const  interval = (await this. interval.eval(parse)).toValue();
        const _while    = (await this._while   .eval(parse)).toValue();
        const  loop     = (await this. loop    .eval(parse)).toValue();
            

        if (this.loop.type != NUMBER_VALUE) assertVolatile(this.loop, this);

        if (_while.value == 0)
            return this;


        if (this.input)
        {
            this.input.invalidateInputs(parse, this, true);

            const input = (await this.input.eval(parse)).toValue();

            this.value = input ? input : NullValue;

            if (this.loop.type != NUMBER_VALUE)
                this.loop.iterateLoop(parse);
        }
        else
            this.value = NullValue.copy();
            

        this.setUpdateValues(parse,
        [
            ['value',    this.value],
            ['interval', interval  ]
        ]);

        
        this.updateValueObjects();


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value.copy();
    }



    isValid()
    {
        return super.isValid()
            && this.interval && this.interval.isValid()
            && this._while   && this._while  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this. interval) this. interval.pushValueUpdates(parse);
        if (this._while   ) this._while   .pushValueUpdates(parse);
        if (this. loop    ) this. loop    .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this. interval) this. interval.invalidateInputs(parse, from, force);
        if (this._while   ) this._while   .invalidateInputs(parse, from, force);
        if (this. loop    ) this. loop    .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this. interval) this. interval.iterateLoop(parse);
        if (this._while   ) this._while   .iterateLoop(parse);
        if (this. loop    ) this. loop    .iterateLoop(parse);
    }
}



class GValueName
extends GOperator1
{
    name = null;



    constructor(nodeId, options)
    {
        super(VALUE_NAME, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.name = null;
    }



    copy()
    {
        const copy = new GNull(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.value) copy.value = this.value.copy();
        if (this.name ) copy.name  = this.name .copy();

        return copy;
    }



    async eval(parse)
    {
        // if (this.isCached())
        //     return this;


        this.value = 
            this.input 
            ? (await this.input.eval(parse)).toValue() 
            : NullValue;

        
        const name = (await this.name.eval(parse)).toValue();

        if (this.value.isValid())
            this.value.valueId = name.value;


        this.updateValueObjects();


        this.setUpdateValues(parse,
        [
            ['type', this.outputType()],
            ['name', name             ]
        ]);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return super.isValid()
            && this.name && this.name.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.name) this.name.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.name) this.name.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.name) this.name.iterateLoop(parse);
    }
}



class GCombine
extends GOperator
{
    inputs = [];

    value;



    constructor(nodeId, options)
    {
        super(COMBINE, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.inputs = [];
    }



    copy()
    {
        const copy = new GCombine(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());
        copy.value  = this.value.copy();

        return copy;
    }



    isCached()
    {
        for (const input of this.inputs)
            if (!input.isCached())
                return false;

        return super.isCached();
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = new ListValue();

        this.value.objects = [];


        if (this.options.enabled)
        {
            for (let i = 0; i < this.inputs.length; i++)
            {
                const input = (await this.inputs[i].eval(parse)).toValue();


                if (input)
                {
                    if (isListType(input.type))
                    {
                        if (input.condensed === true)
                            this.value.items.push(input);//.copy());
                        else
                        {
                            for (const item of input.items)
                                this.value.items.push(item);//.copy());
                        }
                    }
                    else
                        this.value.items.push(input);//.copy());
                }


                const inputObjects = this.copyObjects(input, i);
                inputObjects.forEach(o => o.itemIndex = i);

                this.value.objects.push(...inputObjects);
            }


            // reset object space

            const bounds = getObjBounds(this.value.objects);

            const singlePoint =
                   this.value.objects.length  == 1 
                && this.value.objects[0].type == POINT;


            for (const obj of this.value.objects)
            {
                obj.createDefaultSpace(obj.sp0.x, obj.sp0.y);
                obj.resetSpace(bounds, singlePoint);
            }
        }


        const preview = new ListValue(this.value.items.slice(0, Math.min(this.value.items.length, 10)));
        const length  = new NumberValue(this.value.items.length);
        const type    = new TextValue(finalListTypeFromItems(this.value.items));

        
        this.setUpdateValues(parse,
        [
            ['preview', preview],
            ['length',  length ],
            ['type',    type   ]
        ]);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value.copy();
    }



    isValid()
    {
        return !this.inputs.find(i => !i.isValid());
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse));
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        this.inputs.forEach(i => i.invalidateInputs(parse, from, force));
    }



    initLoop(parse, loopId)
    {
        this.inputs.forEach(i => i.initLoop(parse, loopId));
    }



    invalidateLoop(parse, nodeId)
    {
        this.inputs.forEach(i => i.invalidateLoop(parse, nodeId));
    }



    iterateLoop(parse)
    {
        this.inputs.forEach(i => i.iterateLoop(parse));
    }



    resetLoop(parse, nodeId)
    {
        this.inputs.forEach(i => i.resetLoop(parse, nodeId));
    }
}


class GCondense
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(CONDENSE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GCondense(this.nodeId, this.options);

        copy.copyBase(this);

        //copy.value  = this.value.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = new ListValue();
        this.value.condensed = true;

        let length = 0;


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();


            length = input.items.length;
               
                
            if (input)
            {
                if (   isListType(input.type)
                    && this.options.enabled)
                {
                    for (const item of input.items)
                    {
                        const copy = item.copy();

                        this.value.items.push(copy);
                        //this.value.objects.push(...copy.objects);
                    }
                }
                else
                {
                    const copy = input.copy();

                    this.value.items.push(copy);
                    this.value.objects.push(...copy.objects);
                }
            }
        }


        this.updateValueObjects();
    

        this.setUpdateValues(parse,
        [
            ['length', new NumberValue(length)                              ],
            ['type', new TextValue(finalListTypeFromItems(this.value.items))]
        ]);
        

        this.validate();

        return this;
    }
}



class GExtract
extends GOperator1
{
    indices;


    
    constructor(nodeId, options)
    {
        super(EXTRACT, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.indices = null;
    }



    copy()
    {
        const copy = new GExtract(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.indices) copy.indices = this.indices.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const indices = this.indices ? (await this.indices.eval(parse)).toValue() : null;


        this.value = new ListValue();

        let length = 0;
        

        if (   this.input
            && indices)
        {
            const input = (await this.input.eval(parse)).toValue();

            
            if (   input
                && input.items)
            {
                length = input.items.length;


                if (this.options.enabled)
                {
                    for (let i = 0; i < indices.items.length; i++)
                    {
                        const item = input.items[Math.round(indices.items[i].value)];
                        
                        this.value.items.push(item ? item.copy() : NullValue);
                        
                        if (   item
                            && item.objects
                            && this.value.objects) 
                            this.value.objects.push(...item.objects);//input.items[i].objects);
                    }
                }
           }
            else
                this.value = ListValue.NaN.copy();
        }


        this.updateValueObjects();


        this.setUpdateValues(parse,
        [
            ['preview',    new ListValue(this.value.items.slice(0, Math.min(this.value.items.length, 11)))],
            ['type',       this.outputListType()                                                          ],
            ['length',     new NumberValue(this.value.items.length)                                       ], // used to set start and end maxima
            ['indices',    indices                                                                        ]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.indices && this.indices.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.indices) this.indices.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.indices) this.indices.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.indices) this.indices.iterateLoop(parse);
    }
}



class GSetParam
extends GOperator2
{
    name = null;


    
    constructor(nodeId, options)
    {
        super(EXTRACT_PARAM, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.name  = null;
    }



    copy()
    {
        const copy = new GExtractParam(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.name) copy.name = this.name.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input0 = this.input0 ? (await this.input0.eval(parse)).toValue() : null;
        const input1 = this.input1 ? (await this.input1.eval(parse)).toValue() : null;

        const name   = this.name  ? (await this.name .eval(parse)).toValue() : null;


        if (   input0
            && name)
        {
            let nameValue = name.value.trim();


            if (isListType(input0.type))
            {
                this.value = new ListValue();

                if (this.options.enabled)
                {
                    for (let i = 0; i < input0.items.length; i++)
                    {
                        const item = input0.items[i];

                        if (   input1
                            && name.value.trim() != '')
                            item.customParams.push([nameValue, input1]);

                        
                        if (   item
                            && item[nameValue]
                            && item[nameValue].objects 
                            && this.value.objects)
                            this.value.objects.push(...item[nameValue].objects);
                    }
                }
                else
                    this.value = input0;
            }
            else
            {
                this.value = input0;

                if (   input1
                    && nameValue != ''
                    && this.options.enabled)
                    this.value.customParams.push([nameValue, input1]);
            }
        }
        else
        {
            this.value = NullValue.copy();
        }


        this.updateValueObjects();


        this.setUpdateValues(parse,
        [
            ['type', this.outputType()],
            ['name', name             ]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.name && this.name.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.name) this.name.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.name) this.name.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.name) this.name.iterateLoop(parse);
    }
}



class GExtractParam
extends GOperator1
{
    name = null;


    
    constructor(nodeId, options)
    {
        super(EXTRACT_PARAM, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.name  = null;
    }



    copy()
    {
        const copy = new GExtractParam(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.name) copy.name = this.name.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input = this.input ? (await this.input.eval(parse)).toValue() : null;
        const name  = this.name  ? (await this.name .eval(parse)).toValue() : null;


        if (   input
            && name
            && name.value.trim() != '')
        {
            if (this.options.enabled)
            {
                if (isListType(input.type))
                {
                    this.value = new ListValue();

                    for (let i = 0; i < input.items.length; i++)
                        this.value.items.push(getExtractParamValue(input.items[i], name));
                }
                else
                    this.value = getExtractParamValue(input, name);
            }
            else
                this.value = input;
        }
        else
        {
            this.value = NullValue.copy();
        }


        this.updateValueObjects();


        this.setUpdateValues(parse,
        [
            // ['preview', isListType(this.value) 
            //             ? new ListValue(this.value.items.slice(0, Math.min(this.value.items.length, 11))) 
            //             : this.value  ],
            ['type',    this.outputType()],
            ['name',    name             ]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.name && this.name.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.name) this.name.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.name) this.name.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.name) this.name.iterateLoop(parse);
    }
}



function getExtractParamValue(input, name)
{
    let nameValue = name.value.trim();


    if (    input
        && !input[nameValue])
    {
             if (input[name.value.toUpperCase()]) nameValue = name.value.toUpperCase();
        else if (input[name.value.toLowerCase()]) nameValue = name.value.toLowerCase();
    }


    let value = null;

    if (   input
        && input[nameValue])
    {
        value = input[nameValue];//.copy();
    }
    else
    {
        const customIndex = input.customParams.findIndex(p => p[0] == nameValue);

        value =
            customIndex > -1
            ? input.customParams[customIndex][1]//.copy()
            : NullValue.copy();
    }


    if (   input
        && input[nameValue]
        && input[nameValue].objects 
        && this.value.objects)
        value.objects.push(...input[nameValue].objects);


    return value;
}


class GSublist
extends GOperator1
{
    start = null;
    end   = null;


    
    constructor(nodeId, options)
    {
        super(SUBLIST, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.start = null;
        this.end   = null;
    }



    copy()
    {
        const copy = new GSublist(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.start) copy.start = this.start.copy();
        if (this.end  ) copy.end   = this.end  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const start = this.start ? (await this.start.eval(parse)).toValue() : null;
        const end   = this.end   ? (await this.end  .eval(parse)).toValue() : null;


        this.value = new ListValue();
        this.value.objects = [];

        let length = 0;
        

        if (   this.input
            && start
            && end)
        {
            const input = (await this.input.eval(parse)).toValue();

            
            if (   input
                && input.items)
            {
                length = input.items.length;


                const _end =
                    end.isValid()
                    ? end
                    : new NumberValue(input.items.length);


                if (start.value < _end.value)
                {
                    if (this.options.enabled)
                    {
                        for (let i = start.value, j = 0; i < _end.value; i++, j++)
                        {
                            const item = input.items[i];
                            
                            this.value.items.push(item ? item.copy() : NullValue);
                            
                            if (   item
                                && this.value.objects
                                && input.objects)
                            {
                                const objects = input.objects.filter(o => o.itemIndex == i);
                                objects.forEach(o => o.itemIndex = j);

                                this.value.objects.push(...objects);
                            }
                        }
                    }
                    else
                        this.value = input;//.copy();
                }
            }
            else
                this.value = ListValue.NaN.copy();
        }


        this.updateValueObjects();


        this.setUpdateValues(parse,
        [
            ['preview',    new ListValue(this.value.items.slice(0, Math.min(this.value.items.length, 11)))],
            ['type',       this.outputListType()                                                          ],
            ['length',     new NumberValue(this.value.items.length)                                       ], // used to set start and end maxima
            ['fullLength', new NumberValue(length)                                                        ], // used to set start and end maxima
            ['start',      start                                                                          ],
            ['end',        end                                                                            ]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.start && this.start.isValid()
            && this.end   && this.end  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.start) this.start.pushValueUpdates(parse);
        if (this.end  ) this.end  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.start) this.start.invalidateInputs(parse, from, force);
        if (this.end  ) this.end  .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.start) this.start.iterateLoop(parse);
        if (this.end  ) this.end  .iterateLoop(parse);
    }
}



class GUnique
extends GOperator1
{
    counts  = null;
    indices = null;


    
    constructor(nodeId, options)
    {
        super(UNIQUE, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.counts  = null;
        this.indices = null;
    }



    copy()
    {
        const copy = new GUnique(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input = this.input ? (await this.input.eval(parse)).toValue() : null;


        this.counts  = new ListValue();
        this.indices = new ListValue();


        if (input)
        {
            if (this.options.enabled)
            {
                this.value = new ListValue();

                for (let i = 0; i < input.items.length; i++)
                {
                    const item       = input.items[i];
                    const foundIndex = this.value.items.findIndex(i => i.equals(item));

                    if (foundIndex < 0)
                    {
                        this.value.items.push(item.copy());

                        if (   this.value.objects
                            && item.objects)
                            this.value.objects.push(...item.objects);

                        this.counts.items.push(new NumberValue(1));
                        this.indices.items.push(new ListValue([new NumberValue(i)]));
                    }
                    else
                    {
                        this.counts .items[foundIndex].value++;
                        this.indices.items[foundIndex].items.push(new NumberValue(i));
                    }
                }
            }
            else
                this.value = input.copy();
        }
        else
            this.value = new ListValue();//TextValue.NaN;


        this.updateValueObjects();


        this.setUpdateValues(parse,
        [
            ['preview', new ListValue(this.value.items.slice(0, Math.min(this.value.items.length, 10)))],
            ['type',    this.outputListType()                                                          ],
            ['length',  new NumberValue(this.value.items.length)                                       ]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.counts && this.counts.isValid();
    }
}



class GReverseList
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(REVERSE_LIST, nodeId, options);
    }


    
    copy()
    {
        const copy = new GReverseList(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input = this.input ? (await this.input.eval(parse)).toValue() : null;


        this.counts = new ListValue();


        if (input)
        {
            if (this.options.enabled)
            {
                this.value = new ListValue();
                this.value.objects = [];

                for (let i = input.items.length-1; i >= 0; i--)
                    this.value.items.push(input.items[i]);//.copy());

                if (input.objects)
                {
                    for (let i = input.objects.length-1; i >= 0; i--)
                        this.value.objects.push(input.objects[i]);
                }
            }
            else
                this.value = input;//.copy();
        }
        else
            this.value = ListValue.NaN.copy();


        this.updateValueObjects();


        this.setUpdateValues(parse, 
        [
            ['preview', new ListValue(this.value.items.slice(0, Math.min(this.value.items.length, 10)))],
            ['type',    this.outputListType()                                                          ],
            ['length',  new NumberValue(this.value.items.length)                                       ]
        ]); 
               

        this.validate();

        return this;
    }
}



class GSort
extends GOperator1
{
    order   = null;
    reverse = null;

    firstSortNode = null;


    
    constructor(nodeId, options)
    {
        super(SORT, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.order   = null;
        this.reverse = null;
    }



    copy()
    {
        const copy = new GSort(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.order  ) copy.order   = this.order  .copy();
        if (this.reverse) copy.reverse = this.reverse.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const reverse = this.reverse ? (await this.reverse.eval(parse)).toValue() : null;


        if (this.options.enabled)
        {
            this.value = new ListValue();
            this.value.objects = [];

            let maxColumns = 0;

            
            if (   this.input
                && this.order
                && reverse)
            {
                const input = this.input ? (await this.input.eval(parse)).toValue() : null;
                const order = this.input ? (await this.order.eval(parse)).toValue() : null;

                
                if (   input 
                    && this.order
                    && this.order.getOrderNode)
                {
                    const orderNode = this.order.getOrderNode(parse);


                    if (orderNode)
                    {
                        const reverseMultiplier = reverse.value > 0 ? -1 : 1;
                        const unsorted          = [...input.items];


                        input.items = await asyncSort(
                            parse, 
                            unsorted, 
                            orderNode, 
                            this,
                            this.order, 
                            reverseMultiplier);
                        

                        input.items.forEach(i => maxColumns = Math.max(maxColumns, isListType(i.type) ? i.items.length : 1));
                        

                        for (let i = 0; i < input.items.length; i++)
                        {
                            const row       = input   .items[i];
                            const itemIndex = unsorted.indexOf(row);

                            this.value.items.push(row.copy());

                            if (   row.objects
                                && this.value.objects)
                            {
                                const objects = input.objects.filter(o => o.itemIndex == itemIndex).map(o => o.copy());
                                objects.forEach(o => o.itemIndex = i);

                                this.value.objects.push(...objects);
                            }
                        }
                    }
                }
                else
                    this.value = (await this.input.eval(parse)).toValue();
            }
            else
                this.value = (await this.input.eval(parse)).toValue();
        }
        else
            this.value = (await this.input.eval(parse)).toValue();


        this.updateValueObjects();


        const preview = new ListValue(this.value.items.slice(0, Math.min(this.value.items.length, 11)));


        this.setUpdateValues(parse,
        [
            ['preview', preview              ],
            ['type',    this.outputListType()],
            ['reverse', reverse              ]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.order   && this.order  .isValid()
            && this.reverse && this.reverse.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.order  ) this.order  .pushValueUpdates(parse);
        if (this.reverse) this.reverse.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.order  ) this.order  .invalidateInputs(parse, from, force);
        if (this.reverse) this.reverse.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.order  ) this.order  .iterateLoop(parse);
        if (this.reverse) this.reverse.iterateLoop(parse);
    }
}



async function asyncSort(parse, array, orderNode, node, order, reverseMultiplier)
{
    const sorted = [];

    for (const item of array)
    {
        const criterion = await getSortCriterion(parse, orderNode, node, order, item);
        //console.log('criterion =', criterion);
        sorted.push({item, criterion});
    }


    sorted.sort((a, b) =>
    {
        if (a.criterion < b.criterion) return -1 * reverseMultiplier;
        if (a.criterion > b.criterion) return  1 * reverseMultiplier;

        return 0;
    });


    return sorted.map(_item => _item.item);
}



async function getSortCriterion(parse, orderNode, node, order, item)
{
    orderNode.reset();

    orderNode.input = item.copy();
    order.invalidateInputs(parse, node, true); 

    return (await order.eval(parse)).toValue().value;
}



class GColumn
extends GOperator1
{
    index;


    
    constructor(nodeId, options)
    {
        super(COLUMN, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.index = null;
    }



    copy()
    {
        const copy = new GColumn(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.index) copy.index = this.index.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const index = (await this.index.eval(parse)).toValue();

        
        this.value = new ListValue();

        let maxColumns = 0;


        if (   this.input
            && index)
        {
            const input = (await this.input.eval(parse)).toValue();

            if (isTable(input))
            {
                input.items.forEach(i => maxColumns = Math.max(maxColumns, i.items.length));

                if (index.value < maxColumns)
                {
                    for (let i = 0; i < input.items.length; i++)
                    {
                        const row = input.items[i];

                        if (index.value < row.items.length)
                        {
                            this.value.items.push(row.items[index.value].copy());

                            if (   this.value.objects 
                                && row.items[index.value].objects)
                                this.value.objects.push(...row.items[index.value].objects);
                        }
                    }
                }
            }
            else if (isListType(input.type))
            {
                this.value = input.copy();
                maxColumns = 1;
            }
        }


        this.setUpdateValues(parse,
        [
            ['preview', new ListValue(this.value.items.slice(0, Math.min(this.value.items.length, 11)))],
            ['type',    this.outputListType()                                                          ],
            ['length',  new NumberValue(this.value.items.length)                                       ],
            ['columns', new NumberValue(maxColumns, 0)                                                 ],
            ['index',   index                                                                          ]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.index && this.index.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.index) this.index.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.index) this.index.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.index) this.index.iterateLoop(parse);
    }
}



function isTable(value)
{
    if (!isListType(value.type))
        return false;

    for (const item of value.items)
    {
        if (!isListType(item.type))
            return false;
    }

    return true;
}


class GCell
extends GOperator
{
    column;
    row;


    
    constructor(nodeId, options)
    {
        super(CELL, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.column = null;
        this.row    = null;
    }



    copy()
    {
        const copy = new GCell(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.column) copy.column = this.column.copy();
        if (this.row   ) copy.row    = this.row   .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const column = this.column ? (await this.column.eval(parse)).toValue() : null;
        const row    = this.row    ? (await this.row   .eval(parse)).toValue() : null;


        let columns = 0;
        let rows    = 0;

        if (   this.input
            && column
            && row)
        {
            const input = this.input ? (await this.input.eval(parse)).toValue() : null;

            
            if (   input
                && isTable(input))
            {
                rows = input.items.length;

                input.items.forEach(i => columns = Math.max(columns, i.items ? i.items.length : null));

                if (row.value < rows)
                {
                    const _row = input.items[row.value];

                    if (column.value < columns)
                        this.value = _row.items[column.value].copy()
                    else
                        this.value = NullValue.copy();
                }
                else
                    this.value = NullValue.copy();
            }
            else
                this.value = NullValue.copy();
        }
        else
            this.value = NullValue.copy();


        this.setUpdateValues(parse,
        [
            ['preview', this.value                 ],
            ['type',    this.outputType()          ],
            ['columns', new NumberValue(columns, 0)],
            ['rows',    new NumberValue(rows   , 0)]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.column && this.column.isValid()
            && this.row    && this.row   .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.column) this.column.pushValueUpdates(parse);
        if (this.row   ) this.row   .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.column) this.column.invalidateInputs(parse, from, force);
        if (this.row   ) this.row   .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.column) this.column.iterateLoop(parse);
        if (this.row   ) this.row   .iterateLoop(parse);
    }
}


class GList
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(LIST, nodeId, options);
    }



    copy()
    {
        const copy = new GList(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();
        
        for (const key of this.keys())
        {
            if (this[key] instanceof GValue)
                Object.assign(copy, {[key]: this[key]});
        }

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = this.input ? (await this.input.eval(parse)).toValue() : ListValue.NaN;


        this.updateValues = [];

        
        if (    this.value.isValid()
            && !isEmpty(this.value.items))
        {
            for (let i = 0; i < this.value.items.length; i++)
            {
                const item = this.value.items[i];
                
                let valueId = 
                    item.valueId.trim() != ''
                    ? item.valueId
                    : i.toString();

                valueId = getNewNumberId(
                    valueId,
                    id => this.value.items.find(i => 
                           i != item 
                        && i.valueId == id));

                Object.assign(this, {[valueId]: item});
                this.setUpdateValues(parse, [[valueId, item]], true);

                item.sortId = i;
            }

            this.updateValues.sort((a, b) => a.sortId - b.sortId);
        }
        else
            this.setUpdateValues(parse, [['', NullValue]], true);


        if (this.value.objects)
            for (let j = 0; j < this.value.objects.length; j++)
                this.value.objects[j].nodeId = this.nodeId;


        this.validate();

        return this;
    }
    
    

    paramFromId(paramId)
    {
        return this.value
            && this.value.items
            && paramId != 'value'
            ? this.value.items.find(i => i.valueId == paramId) //this[paramId]
            : null;
    }



    toValue()
    {
        return this.value.copy();
    }
}


class GSelect
extends GOperator1
{
    index = null;



    constructor(nodeId, options)
    {
        super(SELECT, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.index = null;
    }



    copy()
    {
        const copy = new GSelect(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) copy.input = this.input.copy();
        if (this.index) copy.index = this.index.copy();
        if (this.value) copy.value = this.value.copy();

        return copy;
    }



    isCached()
    {
        return super.isCached()
            && (  !this.input 
                || this.input.isCached());
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        let index = this.index ? (await this.index.eval(parse)).toValue() : null;


        let length = 0;


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();
            

            if (   index
                && input
                && input.items
                && input.items.length > 0)
            {
                length = input.items.length;


                index = 
                       index.isValid()
                    && index.value > -input.items.length
                    && index.value <  input.items.length
                    ? new NumberValue(Math.round(index.value))
                    : new NumberValue(0);


                if (   index.isValid()
                    && index.value > -input.items.length
                    && index.value <  input.items.length)
                {
                    this.value = input.items.at(index.value);

                    if (this.value.objects)
                    {
                        for (let i = 0; i < this.value.objects.length; i++)
                        {
                            const obj = this.value.objects[i];

                            obj.nodeId = this.nodeId;
                            obj.listId = -1;

                            obj.objectId = this.nodeId;
                            
                            if (obj.objectId != NULL) 
                                obj.objectId += '/';

                            obj.objectId += index.value.toString();
                        }
                    }
                }
                else
                {
                    this.value = NullValue.copy();
                    index      = NumberValue.NaN;
                }
            }
            else
            {
                this.value = NullValue.copy();
                index      = NumberValue.NaN;
            }
        }
        else
        {
            this.value = NullValue.copy();
            index      = NumberValue.NaN;
        }


        this.setUpdateValues(parse,
        [
            ['preview', this.value             ],
            ['type',    this.outputType()      ],
            ['length',  new NumberValue(length)],
            ['index',   index                  ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.index && this.index.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.index) this.index.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.index) this.index.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.index) this.index.iterateLoop(parse);
    }
}


class GListCount
extends GOperator1
{
    start = null;

    //value = null;



    constructor(nodeId, options)
    {
        super(LIST_COUNT, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.start = null;
    }



    copy()
    {
        const copy = new GListCount(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) copy.input = this.input.copy();
        if (this.start) copy.start = this.start.copy();
        
        if (this.count) copy.count = this.count.copy();

        return copy;
    }



    isCached()
    {
        return super.isCached()
            && (  !this.input 
                || this.input.isCached());
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const start = (await this.start.eval(parse)).toValue();

        
        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();
            this.value = new NumberValue(input.items.length - (start.value == 0 ? 1 : 0));
        }
        else
            this.value = NumberValue.NaN.copy();


        this.setUpdateValues(parse,
        [
            ['value', this.value],
            ['start', start     ]
        ]);


        this.validate();

        return this;
    }



    // toValue()
    // {
    //     return this.value.copy();
    // }



    isValid()
    {
        return super.isValid()
            && this.start && this.start.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.start) this.start.pushValueUpdates(parse);
    }    



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.start) this.start.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.start) this.start.iterateLoop(parse);
    }    
}


class GContains
extends GOperator2
{
    first;
    last;
    all;



    constructor(nodeId, options)
    {
        super(CONTAINS, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.first = null;
        this.last  = null;
        this.all   = null;
    }



    copy()
    {
        const copy = new GContains(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input0 = this.input0 ? (await this.input0.eval(parse)).toValue() : null;
        const input1 = this.input1 ? (await this.input1.eval(parse)).toValue() : null;
    

        if (   input0 && input0.isValid() 
            && input1 && input1.isValid())
        {
            const indices = [];

            
            if (   input1
                && input1.isValid())
            {
                for (let i = 0; i < input0.items.length; i++)
                {
                    if (input0.items[i].equals(input1))
                        indices.push(i);
                }  


                this.value = new NumberValue(indices.length > 0 ? 1 : 0);

                this.first = indices.length > 0 ? new NumberValue(indices.at( 0)) : NumberValue.NaN;
                this.last  = indices.length > 0 ? new NumberValue(indices.at(-1)) : NumberValue.NaN;

                this.all   = new ListValue();

                for (const index of indices)
                    this.all.items.push(new NumberValue(index));
            }
            else
            {
                this.value = new NumberValue(1);

                this.first = NumberValue.NaN;
                this.last  = NumberValue.NaN;
                this.all   =   ListValue.NaN;
            }
        }
        else                  
        {
            this.value = NumberValue.NaN;
            this.first = NumberValue.NaN;
            this.last  = NumberValue.NaN;
            this.all   =   ListValue.NaN;
        }
    

        this.setUpdateValues(parse,
        [
            ['value', this.value],
            ['first', this.first],
            ['last',  this.last ],
            ['all',   this.all  ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.first && this.first.isValid()
            && this.last  && this.last .isValid()
            && this.all   && this.all  .isValid();
    }
}


class GIfElse
extends GOperator
{
    input0    = null;
    input1    = null;

    condition = null;



    constructor(nodeId, options)
    {
        super(IF_ELSE, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.input0    = null;
        this.input1    = null;

        this.condition = null;
    }



    copy()
    {
        const copy = new GIfElse(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input0   ) copy.input0    = this.input0   .copy();
        if (this.input1   ) copy.input1    = this.input1   .copy();

        if (this.condition) copy.condition = this.condition.copy();

        if (this.value    ) copy.value     = this.value    .copy();

        return copy;
    }



    isCached()
    {
        return super.isCached()
            && (!this.input0 || this.input0.isCached())
            && (!this.input1 || this.input1.isCached());
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        const cond = (await this.condition.eval(parse)).toValue();


        if (   this.input0 
            && this.input1)
        {
            const input0 = (await this.input0.eval(parse)).toValue();
            const input1 = (await this.input1.eval(parse)).toValue();

            this.value = cond.value != 0 ? input0 : input1;
        }
        else if (this.input0)
        {
            const input0 = (await this.input0.eval(parse)).toValue();

            this.value = 
                cond.value != 0
                ? input0
                : null;
        }
        else if (this.input1)
        {
            const input1 = (await this.input1.eval(parse)).toValue();

            this.value = 
                cond.value == 0
                ? input1
                : null;
        }
        else                  
            this.value = null;


        this.updateValueObjects();


        this.setUpdateValues(parse,
        [
            ['type',      new TextValue(this.value ? this.value.type : ANY_VALUE)],
            ['condition', cond                                                   ]
        ]);
        
        
        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy() 
             : null;
    }



    isValid()
    {
        return this.input0    && this.input0   .isValid()
            && this.input1    && this.input1   .isValid()
            && this.condition && this.condition.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input0   ) this.input0   .pushValueUpdates(parse);
        if (this.input1   ) this.input1   .pushValueUpdates(parse);
        if (this.condition) this.condition.pushValueUpdates(parse);
    }    



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.input0   ) this.input0   .invalidateInputs(parse, from, force);
        if (this.input1   ) this.input1   .invalidateInputs(parse, from, force);
        if (this.condition) this.condition.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input0   ) this.input0   .iterateLoop(parse);
        if (this.input1   ) this.input1   .iterateLoop(parse);
        if (this.condition) this.condition.iterateLoop(parse);
    }    
}



class GArithmetic
extends GOperator
{
    inputs = [];



    reset()
    {
        super.reset();

        this.inputs = [];
    }



    getOrderNode()
    {
        const orderNodes = [];

        for (const input of this.inputs)
        {
            const orderNode = input.getOrderNode();
            if (orderNode) orderNodes.push(orderNode);            
        }

        console.assert(orderNodes.length < 2, 'Error: sort order requires not more than one order node');

        return orderNodes.length == 1
             ? orderNodes[0]
             : null;
    }



    isCached()
    {
        for (const input of this.inputs)
            if (!input.isCached())
                return false;

        return super.isCached();
    }



    isValid()
    {
        return  this.inputs.length > 0
            && !this.inputs.find(i => !i.isValid());
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse));
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        this.inputs.forEach(i => i.invalidateInputs(parse, from, force));
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        this.inputs.forEach(i => i.iterateLoop(parse));
    }
}



class GNumber
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(NUMBER, nodeId, options);
    }



    copy()
    {
        const copy = new GNumber(this.nodeId, this.options);
        
        copy.copyBase(this);

        copy.value = this.value;

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();
            //console.log('this.value.value =', this.value.value);
        }
        else if (this.value)
            await this.value.eval(parse);
        else
            this.value = NumberValue.NaN;


        this.setUpdateValues(parse, 
        [
            ['value', this.value]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return !this.input || this.input.isValid();
    }
}


class GSign
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(NUMBER_SIGN, nodeId, options);
    }


    
    copy()
    {
        const copy = new GSign(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();

            consoleAssert(
                this.value.type == NUMBER_VALUE, 
                'this.value.type must be NUMBER_VALUE');

            if (this.options.enabled)
                this.value.value = Math.sign(this.value.value);
        }
        else
            this.value = NumberValue.NaN;


        this.setUpdateValues(parse, 
        [
            ['value', this.value]
        ]);


        this.validate();

        return this;
    }
}


class GAbsolute
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(NUMBER_ABSOLUTE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GAbsolute(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();

            consoleAssert(
                this.value.type == NUMBER_VALUE, 
                'this.value.type must be NUMBER_VALUE');

            if (this.options.enabled)
                this.value.value = Math.abs(this.value.value);
        }
        else
            this.value = NumberValue.NaN;


        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}



class GRound
extends GOperator1
{
    type;
    decimals;



    constructor(nodeId, options)
    {
        super(NUMBER_ROUND, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.type     = null;
        this.decimals = null;
    }



    copy()
    {
        const copy = new GRound(this.nodeId, this.options);

        copy.copyBase(this);

        copy.type     = this.type    .copy();
        copy.decimals = this.decimals.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = new NumberValue(0);

        
        const type = (await this.type    .eval(parse)).toValue();
        const dec  = (await this.decimals.eval(parse)).toValue();


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();

            consoleAssert(
                this.value.type == NUMBER_VALUE, 
                'this.value.type must be NUMBER_VALUE');

            
            if (this.options.enabled)
            {
                switch (type.value)
                {
                    case 0: this.value.value = floorTo(this.value.value, dec.value); break;
                    case 1: this.value.value = roundTo(this.value.value, dec.value); break;
                    case 2: this.value.value =  ceilTo(this.value.value, dec.value); break;
                }

                this.value.decimals = dec.value;
            }
        }
        else
            this.value = NumberValue.NaN;


        this.setUpdateValues(parse,
        [
            ['value',    this.value],
            ['type',     type      ],
            ['decimals', dec       ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.type     && this.type    .isValid()
            && this.decimals && this.decimals.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.type    ) this.type    .pushValueUpdates(parse);
        if (this.decimals) this.decimals.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.type    ) this.type    .invalidateInputs(parse, from, force);
        if (this.decimals) this.decimals.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.type    ) this.type    .iterateLoop(parse);
        if (this.decimals) this.decimals.iterateLoop(parse);
    }
}



class GSimpleMinMax
extends GOperator1
{
    operand;
    operation;



    constructor(nodeId, options)
    {
        super(NUMBER_SIMPLE_MINMAX, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.operand   = null;
        this.operation = null;
    }



    copy()
    {
        const copy = new GRound(this.nodeId, this.options);

        copy.copyBase(this);

        copy.operand   = this.operand  .copy();
        copy.operation = this.operation.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = new NumberValue(0);

        
        const operand = (await this.operand  .eval(parse)).toValue();
        const op      = (await this.operation.eval(parse)).toValue();


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            if (isListType(input.type))
            {
                this.value = new ListValue();

                for (let i = 0; i < input.items.length; i++)
                {
                    const item = input.items[i];

                    this.value.items.push(
                        item.type == NUMBER_VALUE
                        ? getSimpleMinMaxValue(item, operand, op, this.options.enabled)
                        : NumberValue.NaN.copy());   
                }
            }
            else
            {
                this.value = getSimpleMinMaxValue(input, operand, op, this.options.enabled);
            }
        }
        else
            this.value = NumberValue.NaN.copy();


        this.setUpdateValues(parse,
        [
            ['value',     this.value       ],
            ['type',      this.outputType()],
            ['operand',   operand          ],
            ['operation', op               ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.operand   && this.operation.isValid()
            && this.operation && this.operand  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.operand  ) this.operand  .pushValueUpdates(parse);
        if (this.operation) this.operation.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.operand  ) this.operand  .invalidateInputs(parse, from, force);
        if (this.operation) this.operation.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.operand  ) this.operand  .iterateLoop(parse);
        if (this.operation) this.operation.iterateLoop(parse);
    }
}



function getSimpleMinMaxValue(input, operand, op, enabled)
{
    consoleAssert(
        input.type == NUMBER_VALUE, 
        'input.type is ' + input.type + ', must be NUMBER_VALUE');


    if (enabled)
    {
        op.value = Math.min(Math.max(0, Math.floor(op.value)), 1);

        return new NumberValue(op.value == 0
            ? Math.min(input.toNumber(), operand.toNumber())
            : Math.max(input.toNumber(), operand.toNumber()));
    }
    else
        return input;
}


class GMinMax
extends GArithmetic
{
    operation;



    constructor(nodeId, options)
    {
        super(NUMBER_MINMAX, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.operation = null;
    }



    copy()
    {
        const copy = new GMinMax(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs    = this.inputs.map(i => i.copy());
        copy.operation = this.operation.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const op = (await this.operation.eval(parse)).toValue().toInteger();

        if (this.options.enabled)
            op.value = Math.min(Math.max(0, op.value), MATH_OPS.length-1);
        

        this.value = await evalMinMaxInputs(this.inputs, op.value, parse);

        
        this.setUpdateValues(parse,
        [
            ['operation', op        ],
            ['value',     this.value]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.operation && this.operation.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.operation) this.operation.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.operation) this.operation.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.operation) this.operation.iterateLoop(parse);
    }
}



async function evalMinMaxInputs(inputs, op, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    let value = new NumberValue(0);


    const val0 = (await inputs[0].eval(parse)).toValue();


    if (   inputs.length == 1
        && val0.type == NUMBER_VALUE)
    {
        value = new NumberValue(-val0.value, val0.decimals);
    }
    else if (isListType(val0.type)
            && !isEmpty(val0.items))
    {
        //console.log('val0.items =', val0.items);
        value = val0.items[0].copy();
        
        for (let i = 1; i < val0.items.length; i++)
        {
            const item = val0.items[i];

            if (item.type == NUMBER_VALUE)
            {
                value = new NumberValue( 
                    op == 0
                    ? Math.min(value.toNumber(), item.toNumber())
                    : Math.max(value.toNumber(), item.toNumber()));
            }                    
        }
    }
    else
    {
        if (val0.type != NUMBER_VALUE)
            return NumberValue.NaN;

        value = val0;
    }


    for (let i = 1; i < inputs.length; i++)
    {
        const val = (await inputs[i].eval(parse)).toValue();


        if (isListType(val.type))
        {
            for (const item of val.items)
            {
                if (item.type == NUMBER_VALUE)
                {
                    value.value = 
                        op == 0
                        ? Math.min(value.value, item.value)
                        : Math.max(value.value, item.value);

                    value.decimals = Math.max(value.decimals, item.decimals);
                }                    
            }
        }
        else
        {
            consoleAssert(
                val.type == NUMBER_VALUE, 
                'val.type must be NUMBER_VALUE');
                
            value.value = 
                op == 0
                ? Math.min(value.value, val.value)
                : Math.max(value.value, val.value);

            value.decimals = Math.max(value.decimals, val.decimals);
        }
    }


    return value;
}


class GLimits
extends GOperator1
{
    min = null;
    max = null;


    
    constructor(nodeId, options)
    {
        super(NUMBER_LIMITS, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.min = null;
        this.max = null;
    }



    copy()
    {
        const copy = new GLimits(this.nodeId, this.options);

        copy.copyBase(this);

        copy.min = this.min.copy();
        copy.max = this.max.copy();

        return copy;
    }



    isCached()
    {
        return super.isCached()
            && (!this.min || this.min.isCached())
            && (!this.max || this.max.isCached());
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const min = (await this.min.eval(parse)).toValue();
        const max = (await this.max.eval(parse)).toValue();


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();

            consoleAssert(
                this.value.type == NUMBER_VALUE, 
                'this.value.type must be NUMBER_VALUE');


            if (this.options.enabled)
            {
                this.value.value = Math.min(Math.max(
                    min.value,
                    this.value.value),
                    max.value);
            }
        }
        else
            this.value = NumberValue.NaN;


        this.setUpdateValues(parse,
        [
            ['value', this.value],
            ['min',   min       ],
            ['max',   max       ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.min && this.min.isValid()
            && this.max && this.max.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input) this.input.pushValueUpdates(parse);
        if (this.min  ) this.min  .pushValueUpdates(parse);
        if (this.max  ) this.max  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.input) this.input.invalidateInputs(parse, from, force);
        if (this.min  ) this.min  .invalidateInputs(parse, from, force);
        if (this.max  ) this.max  .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input) this.input.iterateLoop(parse);
        if (this.min  ) this.min  .iterateLoop(parse);
        if (this.max  ) this.max  .iterateLoop(parse);
    }
}



class GNumberCurve
extends GOperator1
{
    min    = null;
    max    = null;
    power  = null;
    bias   = null;
    spread = null;


    
    constructor(nodeId, options)
    {
        super(NUMBER_CURVE, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.min    = null;
        this.max    = null;
        this.power  = null;
        this.bias   = null;
        this.spread = null;
    }



    copy()
    {
        const copy = new GLimits(this.nodeId, this.options);

        copy.copyBase(this);

        copy.min    = this.min   .copy();
        copy.max    = this.max   .copy();
        copy.power  = this.power .copy();
        copy.bias   = this.bias  .copy();
        copy.spread = this.spread.copy();

        return copy;
    }



    isCached()
    {
        return super.isCached()
            && (!this.min    || this.min   .isCached())
            && (!this.max    || this.max   .isCached())
            && (!this.power  || this.power .isCached())
            && (!this.bias   || this.bias  .isCached())
            && (!this.spread || this.spread.isCached());
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const min    = (await this.min   .eval(parse)).toValue();
        const max    = (await this.max   .eval(parse)).toValue();
        const power  = (await this.power .eval(parse)).toValue();
        const bias   = (await this.bias  .eval(parse)).toValue();
        const spread = (await this.spread.eval(parse)).toValue();


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            if (this.options.enabled)
            {
                let f = (input.value - min.value) / (max.value - min.value);

                f = Math.pow(f, power.value);
                f = getSpreadBias(f, bias.value, spread.value);
                
                f = min.value + f * (max.value - min.value);
                
                this.value = new NumberValue(f);
            }
            else
                this.value = input;
        }
        else
            this.value = NumberValue.NaN;


        this.setUpdateValues(parse,
        [
            ['value',  this.value],
            ['min',    min       ],
            ['max',    max       ],
            ['power',  power     ],
            ['bias',   bias      ],
            ['spread', spread    ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.min    && this.min   .isValid()
            && this.max    && this.max   .isValid()
            && this.power  && this.power .isValid()
            && this.bias   && this.bias  .isValid()
            && this.spread && this.spread.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input ) this.input .pushValueUpdates(parse);
        if (this.min   ) this.min   .pushValueUpdates(parse);
        if (this.max   ) this.max   .pushValueUpdates(parse);
        if (this.power ) this.power .pushValueUpdates(parse);
        if (this.bias  ) this.bias  .pushValueUpdates(parse);
        if (this.spread) this.spread.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.input ) this.input .invalidateInputs(parse, from, force);
        if (this.min   ) this.min   .invalidateInputs(parse, from, force);
        if (this.max   ) this.max   .invalidateInputs(parse, from, force);
        if (this.power ) this.power .invalidateInputs(parse, from, force);
        if (this.bias  ) this.bias  .invalidateInputs(parse, from, force);
        if (this.spread) this.spread.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input ) this.input .iterateLoop(parse);
        if (this.min   ) this.min   .iterateLoop(parse);
        if (this.max   ) this.max   .iterateLoop(parse);
        if (this.power ) this.power .iterateLoop(parse);
        if (this.bias  ) this.bias  .iterateLoop(parse);
        if (this.spread) this.spread.iterateLoop(parse);
    }
}



class GNaNisNumber
extends GOperator1
{
    _value = null;



    constructor(nodeId, options)
    {
        super(NUMBER_NAN, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this._value = null;
    }



    copy()
    {
        const copy = new GNaNisNumber(this.nodeId, this.options);

        copy.copyBase(this);

        copy._value = this._value.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const _value = (await this._value.eval(parse)).toValue();


        if (this.input)
        {
            const input = (await this. input.eval(parse)).toValue();

            if (isListType(input.type))
            {
                this.value = new ListValue();

                for (let i = 0; i < input.items.length; i++)
                {
                    const item = input.items[i];

                    this.value.items.push(
                        item.type == NUMBER_VALUE
                        ? getNaNisNumberValue(item, _value, this.options.enabled)
                        : TextValue.NaN.copy());   
                }
            }
            else
            {
                this.value = getNaNisNumberValue(input, _value, this.options.enabled);
            }
        }

        else
            this.value = NumberValue.NaN.copy();


        this.setUpdateValues(parse,
        [
            ['type',   this.outputType()],
            ['value', _value            ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.value && this.value.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.value) this.value.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.value) this.value.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.value) this.value.iterateLoop(parse);
    }
}



function getNaNisNumberValue(input, value, enabled)
{
    if (    enabled
        && !input.isValid())
        return value;
    else
        return input;
}


class GConstant
extends GOperator
{
    constant;



    constructor(nodeId, options)
    {
        super(NUMBER_CONSTANT, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.constant = null;
    }



    copy()
    {
        const copy = new GConstant(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.constant) copy.constant = this.constant.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;
            

        // input not used for evaluation


        const constant = (await this.constant.eval(parse)).toValue();
    
        let value;

        switch (Math.min(Math.max(0, constant.toNumber()), 5))
        {
            case 0: value = 1.4142135623; break; // √̅2
            case 1: value = 2.7182818284; break; // e
            case 2: value = 0.6180339887; break; // phi
            case 3: value = 1.6180339887; break; // PHI
            case 4: value = 3.1415926536; break; // pi
            case 5: value = 6.2831853072; break; // tau
        }


        this.value = new NumberValue(value);

        
        this.setUpdateValues(parse,
        [
            ['value',   this.value],
            ['constant', constant ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return this.constant && this.constant.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.constant) this.constant.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.constant) this.constant.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.constant) this.constant.iterateLoop(parse);
    }
}



class GDateTime
extends GOperator
{
    seconds   = null;
    minutes   = null;
    hours     = null;
    dayOfWeek = null;
    date      = null;
    month     = null;
    year      = null;
    
    
    
    constructor(nodeId, options)
    {
        super(NUMBER_LIMITS, nodeId, options);
    }


    
    reset()
    {
        super.reset();
        
        this.seconds   = null;
        this.minutes   = null;
        this.hours     = null;
        this.dayOfWeek = null;
        this.date      = null;
        this.month     = null;
        this.year      = null;
    }



    copy()
    {
        const copy = new GLimits(this.nodeId, this.options);
        
        copy.copyBase(this);
        
        copy.seconds   = this.seconds  .copy();
        copy.minutes   = this.minutes  .copy();
        copy.hours     = this.hours    .copy();
        copy.dayOfWeek = this.dayOfWeek.copy();
        copy.date      = this.date     .copy();
        copy.month     = this.month    .copy();
        copy.year      = this.year     .copy();

        return copy;
    }    
    
    
    
    isCached()
    {
        return super.isCached()
            && (!this.year      || this.year     .isCached())
            && (!this.month     || this.month    .isCached())
            && (!this.date      || this.date     .isCached())
            && (!this.dayOfWeek || this.dayOfWeek.isCached())
            && (!this.hours     || this.hours    .isCached())
            && (!this.minutes   || this.minutes  .isCached())
            && (!this.seconds   || this.seconds  .isCached())
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.updateValues = [];

        
        if (this.options.enabled)
        {
            const dateTime = new Date();

            const seconds   = new NumberValue(dateTime.getSeconds() );
            const minutes   = new NumberValue(dateTime.getMinutes() );
            const hours     = new NumberValue(dateTime.getHours()   );
            const dayOfWeek = new NumberValue(dateTime.getDay()     );
            const date      = new NumberValue(dateTime.getDate()    );
            const month     = new NumberValue(dateTime.getMonth()   );
            const year      = new NumberValue(dateTime.getFullYear());


            this.setUpdateValues(parse,
            [
                ['seconds',   seconds  ],
                ['minutes',   minutes  ],
                ['hours',     hours    ],
                ['dayOfWeek', dayOfWeek],
                ['date',      date     ],
                ['month',     month    ],
                ['year',      year     ]
            ]);    
        }    

        
        this.validate();

        return this;
    }    



    isValid()
    {
        return this.year      && this.year     .isValid()
            && this.month     && this.month    .isValid()
            && this.date      && this.date     .isValid()
            && this.dayOfWeek && this.dayOfWeek.isValid()
            && this.hours     && this.hours    .isValid()
            && this.minutes   && this.minutes  .isValid()
            && this.seconds   && this.seconds  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.year     ) this.year     .pushValueUpdates(parse);
        if (this.month    ) this.month    .pushValueUpdates(parse);
        if (this.date     ) this.date     .pushValueUpdates(parse);
        if (this.dayOfWeek) this.dayOfWeek.pushValueUpdates(parse);
        if (this.hours    ) this.hours    .pushValueUpdates(parse);
        if (this.minutes  ) this.minutes  .pushValueUpdates(parse);
        if (this.seconds  ) this.seconds  .pushValueUpdates(parse);
    }    



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.year     ) this.year     .invalidateInputs(parse, from, force);
        if (this.month    ) this.month    .invalidateInputs(parse, from, force);
        if (this.date     ) this.date     .invalidateInputs(parse, from, force);
        if (this.dayOfWeek) this.dayOfWeek.invalidateInputs(parse, from, force);
        if (this.hours    ) this.hours    .invalidateInputs(parse, from, force);
        if (this.minutes  ) this.minutes  .invalidateInputs(parse, from, force);
        if (this.seconds  ) this.seconds  .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.year     ) this.year     .iterateLoop(parse);
        if (this.month    ) this.month    .iterateLoop(parse);
        if (this.date     ) this.date     .iterateLoop(parse);
        if (this.dayOfWeek) this.dayOfWeek.iterateLoop(parse);
        if (this.hours    ) this.hours    .iterateLoop(parse);
        if (this.minutes  ) this.minutes  .iterateLoop(parse);
        if (this.seconds  ) this.seconds  .iterateLoop(parse);
    }    
}



class GDefine
extends GOperator
{
    inputs = [];



    constructor(nodeId, options)
    {
        super(DEFINE, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.input = [];
    }



    copy()
    {
        const copy = new GDefine(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const _values = [];

        for (let i = 0; i < this.inputs.length; i++)
        {
            const input = (await this.inputs[i].eval(parse)).toValue();

            if (   input
                && this.options.enabled)            
            {
                if (isListType(input.type))
                {
                    for (const item of input.items)
                        _values.push(item.copy());   
                }
                else
                    _values.push(input.copy());
            }
        }
            

        this.value = _values[this.iteration % _values.length];


        this.setUpdateValues(parse,
        [
            ['type', new TextValue(finalTypeFromItems(_values))]
        ]);
        

        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return !this.inputs.find(i => !i.isValid());
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse));
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        this.inputs.forEach(i => i.invalidateInputs(parse, from, force));
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        this.inputs.forEach(i => i.iterateLoop(parse));
    }
}



class GSequence
extends GOperator
{
    start    = null;
    multiply = null;
    add      = null;
    end      = null;

    current  = null;
    
    
    
    constructor(nodeId, options)
    {
        super(NUMBER_SEQUENCE, nodeId, options);
    }



    reset()
    {
        super.reset();
        
        this.start    = null;
        this.multiply = null;
        this.add      = null;
        this.end      = null;
    
        this.current  = null;
    }


   
    copy()
    {
        const copy = new GSequence(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.start   ) copy.start    = this.start   .copy();
        if (this.multiply) copy.multiply = this.multiply.copy();
        if (this.add     ) copy.add      = this.add     .copy();
        if (this.end     ) copy.end      = this.end     .copy();

        if (this.current) copy.current = this.current.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;
            

        const start = (await this.start   .eval(parse)).toValue();
        const mult  = (await this.multiply.eval(parse)).toValue();
        const add   = (await this.add     .eval(parse)).toValue();
        const end   = (await this.end     .eval(parse)).toValue();
    

        if (   start
            && mult
            && add
            && end)
        {
            const value = start.value + (this.options.enabled ? add.value * this.iteration : 0);

            if (!end.isValid())
                this.value = getSequenceValue(start, mult, add, this.iteration, this.options.enabled);

            else if (   end.isValid()   
                     && (   add.value == 0
                         || add.value >  0 && start.value < end.value
                                           &&       value < end.value
                         || add.value <  0 && start.value > end.value
                                           &&       value > end.value))
                this.value = getSequenceValue(start, mult, add, this.iteration, this.options.enabled);

            else
                this.value = NumberValue.NaN.copy();
        }
        else
            this.value = NumberValue.NaN.copy();


        this.setUpdateValues(parse,
        [
            ['start',    start],
            ['multiply', mult ],
            ['add',      add  ],
            ['end',      end  ]
        ]);
        

        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return this.start    && this.start   .isValid()
            && this.multiply && this.multiply.isValid()
            && this.add      && this.add     .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.start   ) this.start   .pushValueUpdates(parse);
        if (this.multiply) this.multiply.pushValueUpdates(parse);
        if (this.add     ) this.add     .pushValueUpdates(parse);
        if (this.end     ) this.end     .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.start   ) this.start   .invalidateInputs(parse, from, force);
        if (this.multiply) this.multiply.invalidateInputs(parse, from, force);
        if (this.add     ) this.add     .invalidateInputs(parse, from, force);
        if (this.end     ) this.end     .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.start   ) this.start   .iterateLoop(parse);
        if (this.multiply) this.multiply.iterateLoop(parse);
        if (this.add     ) this.add     .iterateLoop(parse);
        if (this.end     ) this.end     .iterateLoop(parse);
    }
}



function getSequenceValue(start, mult, add, iteration, enabled)
{
    let value = start.value;

    if (enabled)
    {
        const _mult = Math.pow(mult.value, iteration);
        const _add  = add.value * iteration;

        value = start.value * _mult + _add;
    }

    return new NumberValue(value);
}


class GRange
extends GOperator
{
    from   = null;
    start  = null;
    end    = null;
    bias   = null;
    spread = null;
    
    

    constructor(nodeId, options)
    {
        super(NUMBER_RANGE, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.from   = null;
        this.start  = null;
        this.end    = null;
        this.bias   = null;
        this.spread = null;
    }



    copy()
    {
        const copy = new GRange(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.from  ) copy.from   = this.from  .copy();
        if (this.start ) copy.start  = this.start .copy();
        if (this.end   ) copy.end    = this.end   .copy();
        if (this.bias  ) copy.bias   = this.bias  .copy();
        if (this.spread) copy.spread = this.spread.copy();

        if (this.current) copy.current = this.current.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const from   = (await this.from  .eval(parse)).toValue();
        const start  = (await this.start .eval(parse)).toValue();
        const end    = (await this.end   .eval(parse)).toValue();
        const bias   = (await this.bias  .eval(parse)).toValue();
        const spread = (await this.spread.eval(parse)).toValue();
    

        const repeat    = parse.repeats.find(r => r.repeatId == this.loopId);
        const iteration = repeat ? repeat.iteration : 0;


        let delta = end.value - start.value;

        let step = 
               repeat
            && this.options.enabled
            ? delta / Math.max(1, repeat.total - (from.value == 1 ? 1 : 0))
            : 0;

            
        let startOffset;

             if (from  .value == 2) startOffset = step;
        else if (from  .value == 1
              && repeat
              && repeat.total == 1) startOffset = delta/2;
        else                        startOffset = 0;


        let f;
        
        if (repeat)
        {
                 if (from.value == 2) f = iteration/repeat.total;
            else if (from.value == 1) f = (repeat.total > 1 ? iteration/(repeat.total-1) : 0);
            else if (from.value == 0) f = iteration/repeat.total;
        }
        else
            f = 0;


        f = getSpreadBias(f, bias.value, spread.value);


        this.value = new NumberValue(
            start.value + startOffset + delta * f,
            Math.max(start.decimals, end.decimals));


        this.setUpdateValues(parse,
        [
            ['from',   from  ],
            ['start',  start ],
            ['end',    end   ],
            ['bias',   bias  ],
            ['spread', spread]
        ]);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return this.from   && this.from  .isValid()
            && this.start  && this.start .isValid()
            && this.end    && this.end   .isValid()
            && this.bias   && this.bias  .isValid()
            && this.spread && this.spread.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.from  ) this.from  .pushValueUpdates(parse);
        if (this.start ) this.start .pushValueUpdates(parse);
        if (this.end   ) this.end   .pushValueUpdates(parse);
        if (this.bias  ) this.bias  .pushValueUpdates(parse);
        if (this.spread) this.spread.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.from  ) this.from  .invalidateInputs(parse, from, force);
        if (this.start ) this.start .invalidateInputs(parse, from, force);
        if (this.end   ) this.end   .invalidateInputs(parse, from, force);
        if (this.bias  ) this.bias  .invalidateInputs(parse, from, force);
        if (this.spread) this.spread.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.from  ) this.from  .iterateLoop(parse);
        if (this.start ) this.start .iterateLoop(parse);
        if (this.end   ) this.end   .iterateLoop(parse);
        if (this.bias  ) this.bias  .iterateLoop(parse);
        if (this.spread) this.spread.iterateLoop(parse);
    }
}



function getSpreadBias(f, bias, spread)
{
    const b = bias   / 50;
    const s = spread / 50;


    f = 
        b >= 0
        ? 1 - Math.pow(1-f, 1+b)
        :     Math.pow(  f, 1-b);


         if (s >= 0 && f >= 0.5) f = 1 - Math.pow((1-f)*2, 1+s) / 2;
    else if (s >= 0 && f <  0.5) f = Math.pow(f*2, 1+s) / 2;
    else if (s < 0)              f = lerp3(0, (1-s)/3, (2+s)/3, 1, f);


    return f;
}


class GWave
extends GOperator
{
    shape     = null;
    base      = null;
    amplitude = null;
    frequency = null;
    offset    = null;
    bias      = null;
    
    

    constructor(nodeId, options)
    {
        super(NUMBER_WAVE, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.shape     = null;
        this.base      = null;
        this.amplitude = null;
        this.frequency = null;
        this.offset    = null;
        this.bias      = null;
    }



    copy()
    {
        const copy = new GWave(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.shape    ) copy.shape     = this.shape    .copy();
        if (this.base     ) copy.base      = this.base     .copy();
        if (this.amplitude) copy.amplitude = this.amplitude.copy();
        if (this.frequency) copy.frequency = this.frequency.copy();
        if (this.offset   ) copy.offset    = this.offset   .copy();
        if (this.bias     ) copy.bias      = this.bias     .copy();

        if (this.current) copy.current = this.current.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;
            

        const shape  = this.shape     ? (await this.shape    .eval(parse)).toValue() : null;
        const base   = this.base      ? (await this.base     .eval(parse)).toValue() : null;
        const amp    = this.amplitude ? (await this.amplitude.eval(parse)).toValue() : null;
        const freq   = this.frequency ? (await this.frequency.eval(parse)).toValue() : null;
        const offset = this.offset    ? (await this.offset   .eval(parse)).toValue() : null;
        const bias   = this.bias      ? (await this.bias     .eval(parse)).toValue() : null;
    

        const repeat    = parse.repeats.find(r => r.repeatId == this.loopId);
        const iteration = repeat ? repeat.iteration : 0;

 
        let t;
        
        
        if (   repeat
            && shape
            && freq
            && offset)
        {
            t = (iteration/repeat.total) * freq.value - offset.value/freq.value*2;

            switch (shape.value)
            {
                case 0: t = (t%1) < 0.5 ? 1 : -1;      break; // square
                case 1: t = (1 - (t%1)*2);             break; // saw
                case 2: t = ((t%1)*2 - 1);             break; // back saw
                case 3: t = 1 - 2*Math.abs(2*(t%1)-1); break; // triangle
                case 4: t = Math.sin(t * Tau);         break; // sine
            }
        }
        else 
            t = 0;

        
        if (bias)
        {
            const b = bias.value / 100;

            if (b >= 0) t = t / (1+b) + b/2;
            else        t = t / (1-b) + b/2;
        }


        if (amp ) t = t * amp .value;
        if (base) t = t + base.value;


        this.value = new NumberValue(t);


        this.setUpdateValues(parse,
        [
            ['shape',     shape ],
            ['base',      base  ],
            ['amplitude', amp   ],
            ['frequency', freq  ],
            ['offset',    offset],
            ['bias',      bias  ]
        ]);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return this.shape     && this.shape    .isValid()
            && this.base      && this.base     .isValid()
            && this.amplitude && this.amplitude.isValid()
            && this.frequency && this.frequency.isValid()
            && this.offset    && this.offset   .isValid()
            && this.bias      && this.bias     .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.shape    ) this.shape    .pushValueUpdates(parse);
        if (this.base     ) this.base     .pushValueUpdates(parse);
        if (this.amplitude) this.amplitude.pushValueUpdates(parse);
        if (this.frequency) this.frequency.pushValueUpdates(parse);
        if (this.offset   ) this.offset   .pushValueUpdates(parse);
        if (this.bias     ) this.bias     .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.shape    ) this.shape    .invalidateInputs(parse, from, force);
        if (this.base     ) this.base     .invalidateInputs(parse, from, force);
        if (this.amplitude) this.amplitude.invalidateInputs(parse, from, force);
        if (this.frequency) this.frequency.invalidateInputs(parse, from, force);
        if (this.offset   ) this.offset   .invalidateInputs(parse, from, force);
        if (this.bias     ) this.bias     .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.shape    ) this.shape    .iterateLoop(parse);
        if (this.base     ) this.base     .iterateLoop(parse);
        if (this.amplitude) this.amplitude.iterateLoop(parse);
        if (this.frequency) this.frequency.iterateLoop(parse);
        if (this.offset   ) this.offset   .iterateLoop(parse);
        if (this.bias     ) this.bias     .iterateLoop(parse);
    }
}



class GRandom
extends GOperator
{
    seed   = null;
    min    = null;
    max    = null;
    bias   = null;
    spread = null;
    unique = null;

    random       = null;
    randomUnique = null;

    lastValue1   = -1;
    lastValue2   = -1;
    uniqueOffset =  0;



    constructor(nodeId, options)
    {
        super(NUMBER_RANDOM, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.seed   = null;
        this.min    = null;
        this.max    = null;
        this.bias   = null;
        this.spread = null;
        this.unique = null;
    }



    copy()
    {
        const copy = new GRandom(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.seed  ) copy.seed   = this.seed  .copy();
        if (this.min   ) copy.min    = this.min   .copy();
        if (this.max   ) copy.max    = this.max   .copy();
        if (this.bias  ) copy.bias   = this.bias  .copy();
        if (this.spread) copy.spread = this.spread.copy();
        if (this.unique) copy.unique = this.unique.copy();

        if (this.random) copy.random = this.random.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const seed   = (await this.seed  .eval(parse)).toValue();
        const min    = (await this.min   .eval(parse)).toValue();
        const max    = (await this.max   .eval(parse)).toValue();
        const bias   = (await this.bias  .eval(parse)).toValue();
        const spread = (await this.spread.eval(parse)).toValue();
        const unique = (await this.unique.eval(parse)).toValue();
    

        if (  !this.random
            || this.random.seed != seed.value)
        {
            this.random       = new Random(seed.value);
            this.randomUnique = new Random(seed.value+1);
        }



        let f = this.random.get(this.iteration + this.uniqueOffset);
        f = getSpreadBias(f, bias.value, spread.value);
        
        f = min.value + f * (max.value - min.value);
        
        this.value = new NumberValue(f, Math.max(min.decimals, max.decimals));

            
        const _unique = unique.value/100;
        

        if (max.value - min.value >= 1)
        {
            while (this.value.toNumber() == this.lastValue1
                && this.randomUnique.get(this.iteration) < _unique)
                this.value = new NumberValue(
                    min.value + this.random.get(this.iteration + ++this.uniqueOffset) * (max.value - min.value),
                    Math.max(min.decimals, max.decimals));
        }

        if (max.value - min.value >= 2)
        {
            while ((   this.value.toNumber() == this.lastValue1
                    || this.value.toNumber() == this.lastValue2)
                && this.randomUnique.get(this.iteration) < Math.max(_unique - 1))
                this.value = new NumberValue(
                    min.value + this.random.get(this.iteration + ++this.uniqueOffset) * (max.value - min.value),
                    Math.max(min.decimals, max.decimals));
        }        


        if (this.value.isValid())
            this.value.value = this.value.toNumber();

        this.lastValue2 = this.lastValue1;
        this.lastValue1 = this.value.value;


        this.setUpdateValues(parse,
        [
            ['seed',   seed  ],
            ['min',    min   ],
            ['max',    max   ],
            ['bias',   bias  ],
            ['spread', spread],
            ['unique', unique]
        ]);
        

        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return this.seed   && this.seed  .isValid()
            && this.min    && this.min   .isValid()
            && this.max    && this.max   .isValid()
            && this.bias   && this.bias  .isValid()
            && this.spread && this.spread.isValid()
            && this.unique && this.unique.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.seed  ) this.seed  .pushValueUpdates(parse);
        if (this.min   ) this.min   .pushValueUpdates(parse);
        if (this.max   ) this.max   .pushValueUpdates(parse);
        if (this.bias  ) this.bias  .pushValueUpdates(parse);
        if (this.spread) this.spread.pushValueUpdates(parse);
        if (this.unique) this.unique.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.seed  ) this.seed  .invalidateInputs(parse, from, force);
        if (this.min   ) this.min   .invalidateInputs(parse, from, force);
        if (this.max   ) this.max   .invalidateInputs(parse, from, force);
        if (this.bias  ) this.bias  .invalidateInputs(parse, from, force);
        if (this.spread) this.spread.invalidateInputs(parse, from, force);
        if (this.unique) this.unique.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.seed  ) this.seed  .iterateLoop(parse);
        if (this.min   ) this.min   .iterateLoop(parse);
        if (this.max   ) this.max   .iterateLoop(parse);
        if (this.bias  ) this.bias  .iterateLoop(parse);
        if (this.spread) this.spread.iterateLoop(parse);
        if (this.unique) this.unique.iterateLoop(parse);
    }



    initLoop(parse, nodeId)
    {
        super.initLoop(parse, nodeId);

        this.uniqueOffset = 0;
    }



    resetLoop(parse, nodeId)
    {
        super.resetLoop(parse, nodeId);

        this.uniqueOffset = 0;
    }
}



class GNoise
extends GOperator
{
    seed        = null;
    min         = null;
    max         = null;
    scale       = null;
    interpolate = null;
    offset      = null;
    detail      = null;
    
    random = null;
    
    
    
    constructor(nodeId, options)
    {
        super(NUMBER_NOISE, nodeId, options);
    }
    
    
    
    reset()
    {
        super.reset();
        
        this.seed        = null;
        this.min         = null;
        this.max         = null;
        this.scale       = null;
        this.interpolate = null;
        this.offset      = null;
        this.detail      = null;
    }



    copy()
    {
        const copy = new GNoise(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.seed       ) copy.seed        = this.seed       .copy();
        if (this.min        ) copy.min         = this.min        .copy();
        if (this.max        ) copy.max         = this.max        .copy();
        if (this.scale      ) copy.scale       = this.scale      .copy();
        if (this.offset     ) copy.offset      = this.offset     .copy();
        if (this.interpolate) copy.interpolate = this.interpolate.copy();
        if (this.detail     ) copy.detail      = this.detail     .copy();

        if (this.random     ) copy.random      = this.random     .copy();

        return copy;
    }



    async eval(parse)
    {
        const repeat    = parse.repeats.find(r => r.repeatId == this.loopId);
        const iteration = repeat ? repeat.iteration : 0;


        if (this.isCached())
            return this;


        const seed        = (await this.seed       .eval(parse)).toValue();
        const min         = (await this.min        .eval(parse)).toValue();
        const max         = (await this.max        .eval(parse)).toValue();
        const scale       = (await this.scale      .eval(parse)).toValue();
        const offset      = (await this.offset     .eval(parse)).toValue();
        const interpolate = (await this.interpolate.eval(parse)).toValue();
        const detail      = (await this.detail     .eval(parse)).toValue();
    

        if (  !this.random
            || this.random.seed != seed.value)
            this.random = new Random(seed.value);

        
        let size  = 1;
        let power = 1;
        
        const avg = (min.value + max.value) / 2;
        let   r;

        
        if (   this.options.enabled
            && scale
            && offset)
        {
            r = avg;
            
            for (let c = 0; c < detail.value; c++)
            {
                const i = this.iteration / (Math.max(0.000001, scale.value) * size) + offset.value;
                
                const i0 = Math.floor(i);
                const i1 = Math.ceil (i);

                const r0 = this.random.get(i0);
                const r1 = this.random.get(i1);


                let _r;
                
                switch (interpolate.value)
                {
                    case 0: _r = power * r0;                                                 break;
                    case 1: _r = power * lerp(r0, r1, i-i0);                                 break;
                    case 2: _r = power * (r0 + (r1 - r0) * (-Math.cos((i-i0)*Tau/2) + 1)/2); break;
                }

                r += 
                    - power * (avg       - min.value)
                    + _r    * (max.value - min.value);


                size  /= 2;
                power /= 2;
            }
        }
        else
        {
            r = min.value;
        }


        this.value = new NumberValue(r, Math.max(min.decimals, max.decimals));


        this.setUpdateValues(parse,
        [
            ['seed',        seed       ],
            ['min',         min        ],
            ['max',         max        ],
            ['scale',       scale      ],
            ['offset',      offset     ],
            ['interpolate', interpolate],
            ['detail',      detail     ]
        ]);
        

        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return this.seed        && this.seed       .isValid()
            && this.min         && this.min        .isValid()
            && this.max         && this.max        .isValid()
            && this.scale       && this.scale      .isValid()
            && this.offset      && this.offset     .isValid()
            && this.interpolate && this.interpolate.isValid()
            && this.detail      && this.detail     .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.seed       ) this.seed       .pushValueUpdates(parse);
        if (this.min        ) this.min        .pushValueUpdates(parse);
        if (this.max        ) this.max        .pushValueUpdates(parse);
        if (this.scale      ) this.scale      .pushValueUpdates(parse);
        if (this.offset     ) this.offset     .pushValueUpdates(parse);
        if (this.interpolate) this.interpolate.pushValueUpdates(parse);
        if (this.detail     ) this.detail     .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.seed       ) this.seed       .invalidateInputs(parse, from, force);
        if (this.min        ) this.min        .invalidateInputs(parse, from, force);
        if (this.max        ) this.max        .invalidateInputs(parse, from, force);
        if (this.scale      ) this.scale      .invalidateInputs(parse, from, force);
        if (this.offset     ) this.offset     .invalidateInputs(parse, from, force);
        if (this.interpolate) this.interpolate.invalidateInputs(parse, from, force);
        if (this.detail     ) this.detail     .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.seed       ) this.seed       .iterateLoop(parse);
        if (this.min        ) this.min        .iterateLoop(parse);
        if (this.max        ) this.max        .iterateLoop(parse);
        if (this.scale      ) this.scale      .iterateLoop(parse);
        if (this.offset     ) this.offset     .iterateLoop(parse);
        if (this.interpolate) this.interpolate.iterateLoop(parse);
        if (this.detail     ) this.detail     .iterateLoop(parse);
    }
}



class GProbability
extends GOperator
{
    seed   = null;
    chance = null;

    random = null;



    constructor(nodeId, options)
    {
        super(NUMBER_PROBABILITY, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.seed   = null;
        this.chance = null;
    }



    copy()
    {
        const copy = new GRandom(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.seed  ) copy.seed   = this.seed  .copy();
        if (this.chance) copy.chance = this.chance.copy();

        if (this.random) copy.random = this.random.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const seed   = (await this.seed  .eval(parse)).toValue();
        const chance = (await this.chance.eval(parse)).toValue();
    

        if (  !this.random
            || this.random.seed != seed.value)
            this.random = new Random(seed.value);


        const r = 
            this.options.enabled
            ? (this.random.get(this.iteration) > 1 - chance.value/100 ? 1 : 0)
            : 0;


        this.value = new NumberValue(Math.round(r));


        this.setUpdateValues(parse,
        [
            ['seed', seed  ],
            ['min',  chance],
        ]);
        

        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return this.seed   && this.seed  .isValid()
            && this.chance && this.chance.isValid()
            && this.max    && this.max   .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.seed  ) this.seed  .pushValueUpdates(parse);
        if (this.chance) this.chance.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.seed  ) this.seed  .invalidateInputs(parse, from, force);
        if (this.chance) this.chance.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.seed  ) this.seed  .iterateLoop(parse);
        if (this.chance) this.chance.iterateLoop(parse);
    }
}



class GAccumulate
extends GOperator
{
    current;
    when;



    constructor(nodeId, options)
    {
        super(NUMBER_ACCUMULATE, nodeId, options);

        this.current = new NumberValue(0);
    }


    
    reset()
    {
        super.reset();

        this.current = null;
        this.when    = null;
    }



    copy()
    {
        const copy = new GAccumulate(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.when   ) copy.when    = this.when   .copy();
        if (this.current) copy.current = this.current.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const when = (await this.when.eval(parse)).toValue();
            

        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            if (when.value == 0)
                this.value = this.current.copy();

            if (input)
            {
                this.current.value += input.value;
                this.current.decimals = Math.max(this.current.decimals, input.decimals);
            }

            if (when.value > 0)
                this.value = this.current.copy();
        }


        this.setUpdateValues(parse, [['', NullValue]]);
        

        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return super.isValid()
            && this.when && this.when.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.start) this.start.pushValueUpdates(parse);
        if (this.step ) this.step .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.start) this.start.invalidateInputs(parse, from, force);
        if (this.step ) this.step .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.start) this.start.iterateLoop(parse);
        if (this.step ) this.step .iterateLoop(parse);
    }



    resetLoop(parse, nodeId)
    {
        super.resetLoop(parse, nodeId);

        this.current = new NumberValue(0);
    }
}



class GInterpolate
extends GOperator2
{
    amount;


    constructor(nodeId, options)
    {
        super(NUMBER_INTERPOLATE, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.amount = null;
    }



    copy()
    {
        const copy = new GInterpolate(this.nodeId, this.options);

        copy.copyBase(this);

        copy.amount = this.amount.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const amount = (await this.amount.eval(parse)).toValue();


        if (   this.input0 
            && this.input1)
        {
            const val0 = (await this.input0.eval(parse)).toValue();
            const val1 = (await this.input1.eval(parse)).toValue();

            const maxDec = Math.max(val0.decimals, val1.decimals);

            this.value = new NumberValue(
                val0.value + amount.value * (val1.value - val0.value) / 100,
                maxDec);
        }
        else if (this.input0)
            this.value = (await this.input0.eval(parse)).toValue();

        else if (this.input1) 
            this.value = (await this.input1.eval(parse)).toValue();

        else                  
            this.value = NumberValue.NaN;


        this.setUpdateValues(parse,
        [
            ['amount', amount    ],
            ['value',  this.value]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.amount && this.amount.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.amount) this.amount.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.amount) this.amount.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.amount) this.amount.iterateLoop(parse);
    }
}



class GSolve
extends GOperator1
{
    current = null;
    target  = null;

    temp    = null;


    
    constructor(nodeId, options)
    {
        super(NUMBER_LIMITS, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.current = null;
        this.target  = null;
        this.temp    = null;
    }



    copy()
    {
        const copy = new GSolve(this.nodeId, this.options);

        copy.copyBase(this);

        copy.current = this.current.copy();
        copy.target  = this.target .copy();

        return copy;
    }



    isCached()
    {
        return super.isCached()
            && this.current.isCached()
            && this.target .isCached();
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        let   current = (await this.current.eval(parse)).toValue();
        const target  = (await this.target .eval(parse)).toValue();


        if (   this.input
            && current.isValid()
            && target .isValid())
        {
            let input = (await this.input.eval(parse)).toValue();

            consoleAssert(
                input.type == NUMBER_VALUE, 
                'input.type must be NUMBER_VALUE');


            if (this.options.enabled)
            {
                let   diff      = target.value - current.value;
                let   prevDiff  = 0;


                let   temp      = 0;
                let   step      = Number.MAX_SAFE_INTEGER/65536;


                let   iter      = 0;
                const maxIter   = 1000;
                

                genInitNodeProgress(this.nodeId);


                parse.totalProgress += maxIter;


                while (iter++ < maxIter)
                {
                    temp += step;


                    if (this.input.type == PARAM)
                    {
                        this.input.node[this.input.paramId].value    = temp;
                        this.input.node[this.input.paramId].decimals = decDigits(temp);
                    }

                        
                    this.current.invalidateInputs(parse, this);
                    current = (await this.current.eval(parse)).toValue();


                    // if (!current.isValid())
                    //     diff = Number.MAX_SAFE_INTEGER;
                    // else
                    if (current.isValid())
                    {
                        diff = target.value - current.value;
                        //console.log('diff =', diff);

                        if (Math.abs(diff) < 0.0000001)
                            break;
                            

                        if (   Math.abs (diff) >  Math.abs (prevDiff)
                            || Math.sign(diff) != Math.sign(prevDiff))
                            step /= -2;

                        // console.log('step =', step);
                        // console.log('');

                        prevDiff = diff;
                    }
                        

                    parse.currentProgress++;
                    genUpdateNodeProgress(parse, this.nodeId, iter / maxIter);
                }


                if (iter < maxIter)
                {
                    parse.currentProgress += maxIter - iter;

                    input = (await this.input.eval(parse)).toValue();
                    this.value = input;
                }
                else
                {
                    this.value = NumberValue.NaN;
                    console.warn('max solve iterations');
                }
            }
            else
                this.value = input;
        }
        else
        {
            if (this.input) 
                await this.input.eval(parse);

            this.value = NumberValue.NaN;
        }

        
        // TODO push good result value to input 

        this.setUpdateValues(parse,
        [
            //['value',   this.value],
            ['current', current   ],
            ['target',  target    ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.current && this.current.isValid()
            && this.target  && this.target .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.current) this.current.pushValueUpdates(parse);
        if (this.target ) this.target .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.current) this.current.invalidateInputs(parse, from, force);
        if (this.target ) this.target .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.current) this.current.iterateLoop(parse);
        if (this.target ) this.target .iterateLoop(parse);
    }
}



class GAnimate
extends GOperator
{
    from   = null;
    to     = null;
    curve  = null;
    repeat = null;
    length = null;
    time   = null;
    
    
    
    constructor(nodeId, options)
    {
        super(NUMBER_ANIMATE, nodeId, options);
    }
    
    
    
    reset()
    {
        super.reset();
        
        this.from   = null;
        this.to     = null;
        this.curve  = null;
        this.repeat = null;
        this.length = null;
        this.time   = null;
    }



    copy()
    {
        const copy = new GAnimate(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.from  ) copy.from   = this.from  .copy();
        if (this.to    ) copy.to     = this.to    .copy();
        if (this.curve ) copy.curve  = this.curve .copy();
        if (this.repeat) copy.repeat = this.repeat.copy();
        if (this.length) copy.length = this.length.copy();
        if (this.time  ) copy.time   = this.time  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const from   = (await this.from  .eval(parse)).toValue();
        const to     = (await this.to    .eval(parse)).toValue();
        const curve  = (await this.curve .eval(parse)).toValue();
        const repeat = (await this.repeat.eval(parse)).toValue();
        const length = (await this.length.eval(parse)).toValue();
        const time   = (await this.time  .eval(parse)).toValue();
    

        const maxDec = Math.max(from.decimals, to.decimals);

        switch (curve.value)
        {
            case 0: 
            {
                this.value = new NumberValue(
                    time.value < length.value ? from.value : to.value, 
                    maxDec);
    
                break;
            }
            case 1: 
            {
                this.value = new NumberValue(
                    from.value + (to.value - from.value) * time.value / length.value,
                    maxDec);

                break;
            }
            case 2: 
            {
                let f = time.value / length.value;

                f = 1 - sqr(1 - f);

                this.value = new NumberValue(
                    from.value + (to.value - from.value) * f,
                    maxDec);
    
                break;
            }
            case 3: 
            {
                let f = time.value / length.value;

                f = sqr(f);

                this.value = new NumberValue(
                    from.value + (to.value - from.value) * f,
                    maxDec);
    
                break;
            }
            case 4: 
            {
                let f = time.value / length.value;

                f = 6*Math.pow(f, 5) - 15*Math.pow(f, 4) + 10*Math.pow(f, 3);

                this.value = new NumberValue(
                    from.value + (to.value - from.value) * f,
                    maxDec);
    
                break;
            }
        }
        

        this.setUpdateValues(parse,
        [
            ['from',   from  ],
            ['to',     to    ],
            ['curve',  curve ],
            ['repeat', repeat],
            ['length', length],
            ['time',   time  ]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return this.from   && this.from  .isValid()
            && this.to     && this.to    .isValid()
            && this.curve  && this.curve .isValid()
            && this.repeat && this.repeat.isValid()
            && this.length && this.length.isValid()
            && this.time   && this.time  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.from  ) this.from  .pushValueUpdates(parse);
        if (this.to    ) this.to    .pushValueUpdates(parse);
        if (this.curve ) this.curve .pushValueUpdates(parse);
        if (this.repeat) this.repeat.pushValueUpdates(parse);
        if (this.length) this.length.pushValueUpdates(parse);
        if (this.time  ) this.time  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.from  ) this.from  .invalidateInputs(parse, from, force);
        if (this.to    ) this.to    .invalidateInputs(parse, from, force);
        if (this.curve ) this.curve .invalidateInputs(parse, from, force);
        if (this.repeat) this.repeat.invalidateInputs(parse, from, force);
        if (this.length) this.length.invalidateInputs(parse, from, force);
        if (this.time  ) this.time  .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.from  ) this.from  .iterateLoop(parse);
        if (this.to    ) this.to    .iterateLoop(parse);
        if (this.curve ) this.curve .iterateLoop(parse);
        if (this.repeat) this.repeat.iterateLoop(parse);
        if (this.length) this.length.iterateLoop(parse);
        if (this.time  ) this.time  .iterateLoop(parse);
    }
}



class GMath
extends GArithmetic
{
    operation;



    constructor(nodeId, options)
    {
        super(NUMBER_MATH, nodeId, options);
    }


    reset()
    {
        super.reset();

        this.operation = null;
    }



   
    copy()
    {
        const copy = new GMath(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        if (this.operation) copy.operation = this.operation.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const op = (await this.operation.eval(parse)).toValue().toInteger();

        op.value    = Math.min(Math.max(0, Math.round(op.value)), MATH_OPS.length-1);
        op.decimals = 0;


        switch (op.value)
        {
            case 0: this.value = await evalSubtractInputs(this.inputs, parse); break;
            case 1: this.value = await evalAddInputs     (this.inputs, parse); break;
            case 2: this.value = await evalModuloInputs  (this.inputs, parse); break;
            case 3: this.value = await evalDivideInputs  (this.inputs, parse); break;
            case 4: this.value = await evalMultiplyInputs(this.inputs, parse); break;
            case 5: this.value = await evalExponentInputs(this.inputs, parse); break;
        }


        this.setUpdateValues(parse,
        [
            ['value',     this.value],
            ['operation', op        ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.operation && this.operation.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.operation) this.operation.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.operation) this.operation.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.operation) this.operation.iterateLoop(parse);
    }
}



class GSimpleMath
extends GOperator1
{
    operation;
    operand;



    constructor(nodeId, options)
    {
        super(NUMBER_SIMPLE_MATH, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.operation = null;
        this.operand   = null;
    }



    copy()
    {
        const copy = new GRound(this.nodeId, this.options);

        copy.copyBase(this);

        copy.operation = this.operation.copy();
        copy.operand   = this.operand  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = new NumberValue(0);

        
        const op      = (await this.operation.eval(parse)).toValue();
        const operand = (await this.operand  .eval(parse)).toValue();

        op.value    = Math.min(Math.max(0, Math.round(op.value)), MATH_OPS.length-1);
        op.decimals = 0;


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            if (isListType(input.type))
            {
                this.value = new ListValue();

                for (let i = 0; i < input.items.length; i++)
                {
                    const item = input.items[i];

                    this.value.items.push(
                        item.type == NUMBER_VALUE
                        ? getSimpleMathValue(item, operand, op, this.options.enabled)
                        : NumberValue.NaN.copy());   
                }
            }
            else
            {
                this.value = getSimpleMathValue(input, operand, op, this.options.enabled);
            }
        }
        else
            this.value = NumberValue.NaN.copy();


        this.setUpdateValues(parse,
        [
            ['value',     this.value       ],
            ['type',      this.outputType()],
            ['operation', op               ],
            ['operand',   operand          ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.operation && this.operation.isValid()
            && this.operand   && this.operand  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.operation) this.operation.pushValueUpdates(parse);
        if (this.operand  ) this.operand  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.operation) this.operation.invalidateInputs(parse, from, force);
        if (this.operand  ) this.operand  .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.operation) this.operation.iterateLoop(parse);
        if (this.operand  ) this.operand  .iterateLoop(parse);
    }
}



function getSimpleMathValue(input, operand, op, enabled)
{
    consoleAssert(
        input.type == NUMBER_VALUE, 
        'input.type is ' + input.type + ', must be NUMBER_VALUE');


    if (enabled)
    {
        op.value = Math.min(Math.max(0, Math.floor(op.value)), MATH_OPS.length-1);

        switch (op.value)
        {
            case 0: 
                return new NumberValue(input.toNumber() - operand.toNumber());

            case 1: 
                return new NumberValue(input.toNumber() + operand.toNumber());

            case 2: 
                return new NumberValue(input.toNumber() % operand.toNumber());

            case 3: 
                if (operand.value == 0)
                    return NumberValue.NaN.copy();
                else
                    return new NumberValue(input.toNumber() / operand.toNumber());

            case 4: 
                return new NumberValue(input.toNumber() * operand.toNumber());

            case 5: 
                return new NumberValue(Math.pow(input.toNumber(), operand.toNumber()));
        }


        console.error('invalid math result')
        return input;
    }
    else
        return input;
}


class GAdd
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_ADD, nodeId, options);
    }


    
    copy()
    {
        const copy = new GAdd(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        this.value = await evalAddInputs(this.inputs, parse);
        
        this.setUpdateValues(parse, [['value', this.value]]);

        this.validate();

        return this;
    }
}



async function evalAddInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    const value = new NumberValue(0);


    for (let i = 0; i < inputs.length; i++)
    {
        const val = (await inputs[i].eval(parse)).toValue();
        
        if (   !val
            || !val.isValid())
            return NumberValue.NaN;

        if (isListType(val.type))
        {
            if (   isEmpty(val.items)
                || val.items[0].type != NUMBER_VALUE)
                return NumberValue.NaN;

            for (const item of val.items)
            {
                if (item.type == NUMBER_VALUE)
                {
                    value.value   += item.value;
                    value.decimals = Math.max(value.decimals, item.decimals);
                }
            }
        }
        else
        {
            consoleAssert(
                val.type == NUMBER_VALUE, 
                'val.type must be NUMBER_VALUE');

            value.value   += val.value;
            value.decimals = Math.max(value.decimals, val.decimals);
        }
    }


    return value;
}


class GSubtract
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_SUBTRACT, nodeId, options);
    }


    
    copy()
    {
        const copy = new GSubtract(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalSubtractInputs(this.inputs, parse);


        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}



async function evalSubtractInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    let value = new NumberValue(0);


    if (!isEmpty(inputs))
    {
        const val0 = (await inputs[0].eval(parse)).toValue();

        if (   !val0
            || !val0.isValid())
            return NumberValue.NaN;


        if (   inputs.length == 1
            && val0.type == NUMBER_VALUE)
        {
            value = new NumberValue(-val0.value, val0.decimals);
        }
        else if (isListType(val0.type)
             && !isEmpty(val0.items))
        {
            const item0 = val0.items[0];

            if (   !item0
                || !item0.isValid())
                return NumberValue.NaN;


            value.value    = item0.value;
            value.decimals = item0.decimals;

            for (let i = 1; i < val0.items.length; i++)
            {
                const item = val0.items[i];

                if (   !item
                    || !item.isValid())
                    return NumberValue.NaN;

                if (item.type == NUMBER_VALUE)
                {
                    value.value   -= item.value;
                    value.decimals = Math.max(value.decimals, item.decimals);
                }                    
            }
        }
        else
        {
            if (val0.type != NUMBER_VALUE)
                return NumberValue.NaN;

            value.value    = val0.value;
            value.decimals = val0.decimals;
        }


        for (let i = 1; i < inputs.length; i++)
        {
            const val = (await inputs[i].eval(parse)).toValue();

            if (   !val
                || !val.isValid())
                return NumberValue.NaN;


            if (isListType(val.type))
            {
                for (const item of val.items)
                {
                    if (item.type == NUMBER_VALUE)
                    {
                        value.value   -= item.value;
                        value.decimals = Math.max(value.decimals, item.decimals);
                    }                    
                }
            }
            else
            {
                consoleAssert(
                    val.type == NUMBER_VALUE, 
                    'val.type must be NUMBER_VALUE');
                    
                value.value   -= val.value;
                value.decimals = Math.max(value.decimals, val.decimals);
            }
        }
    }


    return value;
}


class GMultiply
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_MULTIPLY, nodeId, options);
    }



    copy()
    {
        const copy = new GMultiply(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }

    

    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalMultiplyInputs(this.inputs, parse);


        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}



async function evalMultiplyInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    const value = new NumberValue(0);


    if (!isEmpty(inputs))
    {
        value.value = 1;

        for (let i = 0; i < inputs.length; i++)
        {
            const val = (await inputs[i].eval(parse)).toValue();

            if (   !val
                || !val.isValid())
                return NumberValue.NaN;


            if (isListType(val.type))
            {
                if (   isEmpty(val.items)
                    || val.items[0].type != NUMBER_VALUE)
                    return NumberValue.NaN;

                for (const item of val.items)
                {
                    value.value   *= item.value;
                    value.decimals = Math.max(value.decimals, item.decimals);
                }
            }
            else
            {
                consoleAssert(
                    val.type == NUMBER_VALUE, 
                    'val.type must be NUMBER_VALUE');

                value.value   *= val.value;
                value.decimals = Math.max(value.decimals, val.decimals);
            }
        }
    }


    return value;
}


class GDivide
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_DIVIDE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GDivide(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        this.value = await evalDivideInputs(this.inputs, parse);
    
        
        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}



async function evalDivideInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;

        
    let value = new NumberValue(0);

        
    if (!isEmpty(inputs))
    {
        const val0 = (await inputs[0].eval(parse)).toValue();

        if (   !val0
            || !val0.isValid())
            return NumberValue.NaN;


        if (    isListType(val0.type)
            && !isEmpty(val0.items))
        {
            const item0 = val0.items[0];

            if (   !item0
                || !item0.isValid())
                return NumberValue.NaN;


            value.value    = item0.value;
            value.decimals = item0.decimals;

            for (let i = 1; i < val0.items.length; i++)
            {
                const item = val0.items[i];

                if (   !item
                    || !item.isValid())
                    return NumberValue.NaN;

                    
                if (item.type == NUMBER_VALUE)
                {
                    if (item.value == 0) 
                    { 
                        value.value    = Number.NaN; 
                        value.decimals = 0;
                        break; 
                    }

                    value.value    = value.value / item.value;
                    value.decimals = Math.max(Math.max(value.decimals, item.decimals), decDigits(value.value));
                }                    
            }
        }
        else
        {
            if (val0.type != NUMBER_VALUE)
                return NumberValue.NaN;

            value.value    = val0.value;
            value.decimals = val0.decimals;
        }

        
        for (let i = 1; i < inputs.length; i++)
        {
            const val = (await inputs[i].eval(parse)).toValue();

            if (   !val
                || !val.isValid())
                return NumberValue.NaN;


            if (isListType(val.type))
            {
                for (const item of val.items)
                {
                    if (   !item
                        || !item.isValid())
                        return NumberValue.NaN;


                    if (item.type == NUMBER_VALUE)
                    {
                        if (item.value == 0) 
                        { 
                            value.value    = Number.NaN; 
                            value.decimals = 0;
                            break; 
                        }

                        value = new NumberValue(value.toNumber() / item.toNumber());
                        // value.value    = value.value / item.value;
                        // value.decimals = Math.max(Math.max(value.decimals, item.decimals), decDigits(value.value));
                    }                    
                }
            }
            else
            {
                consoleAssert(
                    val.type == NUMBER_VALUE, 
                    'val.type must be NUMBER_VALUE');

                if (val.value == 0) 
                { 
                    value.value    = Number.NaN; 
                    value.decimals = 0;
                    break; 
                }
    
                value = new NumberValue(value.toNumber() / val.toNumber());
                
                // value.value    = value.value / val.value;
                // value.decimals = Math.max(Math.max(value.decimals, val.decimals), decDigits(value.value));
            }
        }
    }


    return value;
}


class GModulo
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_MODULO, nodeId, options);
    }


    
    copy()
    {
        const copy = new GModulo(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalModuloInputs(this.inputs, parse);


        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}



async function evalModuloInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;

        
    const value = new NumberValue(0);

        
    if (!isEmpty(inputs))
    {
        const val0 = (await inputs[0].eval(parse)).toValue();

        if (   !val0
            || !val0.isValid())
            return NumberValue.NaN;


        if (    isListType(val0.type)
            && !isEmpty(val0.items))
        {
            const item0 = val0.items[0];

            if (   !item0
                || !item0.isValid())
                return NumberValue.NaN;


            value.value    = item0.value;
            value.decimals = item0.decimals;

            for (let i = 1; i < val0.items.length; i++)
            {
                const item = val0.items[i];
                
                if (   !item
                    || !item.isValid())
                    return NumberValue.NaN;


                if (item.type == NUMBER_VALUE)
                {
                    if (item.value == 0) 
                    { 
                        value.value    = Number.NaN; 
                        value.decimals = 0;
                        break; 
                    }

                    value.decimals = Math.max(value.decimals, item.decimals);
                    value.value    = value.value % item.value;
                }                    
            }
        }
        else
        {
            if (val0.type != NUMBER_VALUE)
                return NumberValue.NaN;

            value.value    = val0.value;
            value.decimals = val0.decimals;
        }


        for (let i = 1; i < inputs.length; i++)
        {
            const val = (await inputs[i].eval(parse)).toValue();

            if (   !val
                || !val.isValid())
                return NumberValue.NaN;


            if (isListType(val.type))
            {
                for (const item of val.items)
                {
                    if (   !item
                        || !item.isValid())
                        return NumberValue.NaN;


                    if (item.type == NUMBER_VALUE)
                    {
                        if (item.value == 0) 
                        { 
                            value.value    = Number.NaN; 
                            value.decimals = 0;
                            break; 
                        }

                        value.decimals = Math.max(value.decimals, item.decimals);
                        value.value    = floorTo(value.value % item.value, value.decimals);
                    }                    
                }
            }
            else
            {
                consoleAssert(
                    val.type == NUMBER_VALUE, 
                    'val.type must be NUMBER_VALUE');

                if (val.value == 0) 
                { 
                    value.value    = Number.NaN; 
                    value.decimals = 0;
                    break; 
                }

                value.decimals = Math.max(value.decimals, val.decimals);
                value.value    = floorTo(value.value % val.value, value.decimals);
            }
        }
    }


    return value;
}


class GExponent
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_EXPONENT, nodeId, options);
    }


    
    copy()
    {
        const copy = new GExponent(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalExponentInputs(this.inputs, parse);


        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}



async function evalExponentInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    const value = new NumberValue(0);


    if (!isEmpty(inputs))
    {
        const val0 = (await inputs[0].eval(parse)).toValue();

        if (   !val0
            || !val0.isValid())
            return NumberValue.NaN;


        if (    isListType(val0.type)
            && !isEmpty(val0.items))
        {
            const item0 = val0.items[0];

            if (   !item0
                || !item0.isValid())
                return NumberValue.NaN;


            value.value    = item0.value;
            value.decimals = item0.decimals;

            for (let i = 1; i < val0.items.length; i++)
            {
                const item = val0.items[i];
                
                if (   !item
                    || !item.isValid())
                    return NumberValue.NaN;


                if (item.type == NUMBER_VALUE)
                {
                    value.value    = Math.pow(value.value,    item.value);
                    value.decimals = Math.max(value.decimals, item.decimals);
                }                    
            }
        }
        else
        {
            if (val0.type != NUMBER_VALUE)
                return NumberValue.NaN;

            value.value    = val0.value;
            value.decimals = val0.decimals;
        }


        for (let i = 1; i < inputs.length; i++)
        {
            const val = (await inputs[i].eval(parse)).toValue();

            if (   !val
                || !val.isValid())
                return NumberValue.NaN;


            if (isListType(val.type))
            {
                for (const item of val.items)
                {
                    if (   !item
                        || !item.isValid())
                        return NumberValue.NaN;

                    if (item.type == NUMBER_VALUE)
                    {
                        value.value    = Math.pow(value.value,    item.value);
                        value.decimals = Math.max(value.decimals, item.decimals);
                    }                    
                }
            }
            else
            {
                consoleAssert(
                    val.type == NUMBER_VALUE, 
                    'val.type must be NUMBER_VALUE');

                value.value    = Math.pow(value.value,    val.value);
                value.decimals = Math.max(value.decimals, val.decimals);
            }
        }
    }


    return value;
}


class GBoolean
extends GArithmetic
{
    operation;



    constructor(nodeId, options)
    {
        super(NUMBER_BOOLEAN, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.operation = null;
    }


   
    copy()
    {
        const copy = new GBoolean(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs    = this.inputs.map(i => i.copy());
        copy.operation = this.operation.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const op = (await this.operation.eval(parse)).toValue().toInteger();

        op.value = op.initValue = Math.min(Math.max(0, op.value), BOOLEAN_OPS.length-1);

        
        switch (op.value)
        {
            case BOOLEAN_NOT: this.value = await evalNandInputs(this.inputs, parse); break;
            case BOOLEAN_XOR: this.value = await evalXorInputs (this.inputs, parse); break;
            case BOOLEAN_OR:  this.value = await evalOrInputs  (this.inputs, parse); break;
            case BOOLEAN_AND: this.value = await evalAndInputs (this.inputs, parse); break;
        }

        
        this.setUpdateValues(parse,
        [
            ['value',     this.value],
            ['operation', op        ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.operation && this.operation.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.operation) this.operation.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.operation) this.operation.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.operation) this.operation.iterateLoop(parse);
    }
}


class GNot
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_NOT, nodeId, options);
    }


    
    copy()
    {
        const copy = new GNot(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalNandInputs(this.inputs, parse);
        

        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}



async function evalNandInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    const value = new NumberValue();


    if (!isEmpty(inputs))
    {
        const val0 = (await inputs[0].eval(parse)).toValue();
        if (!val0.isValid()) return NumberValue.NaN;

        if (    isListType(val0.type)
            && !isEmpty(val0.items))
        {
            const item0 = val0.items[0];

            value.value = item0.toNumber() != 0 ? 0 : 1;

            for (let i = 1; i < val0.items.length; i++)
            {
                const item = val0.items[i];
                
                if (   item.type == NUMBER_VALUE
                    && item.toNumber() == 0)
                    value.value = 1;
            }
        }
        else
        {
            if (val0.type != NUMBER_VALUE)
                return NumberValue.NaN;

            value.value = val0.toNumber() != 0 ? 0 : 1;
        }


        for (let i = 1; i < inputs.length; i++)
        {
            const val = (await inputs[i].eval(parse)).toValue();
            if (!val.isValid()) return NumberValue.NaN;

            if (isListType(val.type))
            {
                for (const item of val.items)
                {
                    if (   item.type == NUMBER_VALUE
                        && item.toNumber() == 0)
                        value.value = 1;
                }
            }
            else
            {
                consoleAssert(
                    val.type == NUMBER_VALUE, 
                    'val.type must be NUMBER_VALUE');

                if (val.toNumber() == 0)
                    value.value = 1;
            }
        }
    }


    return value;
}



class GAnd
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_AND, nodeId, options);
    }


    
    copy()
    {
        const copy = new GAnd(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalAndInputs(this.inputs, parse);
        

        this.setUpdateValues(parse, [['value', this.value]]);

        
        this.validate();

        return this;
    }
}



async function evalAndInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    const value = new NumberValue();


    if (!isEmpty(inputs))
    {
        const val0 = (await inputs[0].eval(parse)).toValue();
        if (!val0.isValid()) return NumberValue.NaN;

        if (    isListType(val0.type)
            && !isEmpty(val0.items))
        {
            const item0 = val0.items[0];

            value.value = item0.toNumber();

            for (let i = 1; i < val0.items.length; i++)
            {
                const item = val0.items[i];
                
                if (item.type == NUMBER_VALUE)
                    value.value = Math.min(value.value, item.toNumber());
            }
        }
        else
        {
            if (val0.type != NUMBER_VALUE)
                return NumberValue.NaN;

            value.value = val0.toNumber();
        }


        for (let i = 1; i < inputs.length; i++)
        {
            const val = (await inputs[i].eval(parse)).toValue();
            if (!val.isValid()) return NumberValue.NaN;

            if (isListType(val.type))
            {
                for (const item of val.items)
                {
                    if (item.type == NUMBER_VALUE)
                        value.value = Math.min(value.value, item.toNumber());
                }
            }
            else
            {
                consoleAssert(
                    val.type == NUMBER_VALUE, 
                    'val.type must be NUMBER_VALUE');

                value.value = Math.min(value.value, val.toNumber());
            }
        }

        
        if (value.value != 0)
            value.value = 1;
    }


    return value;
}


class GOr
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_OR, nodeId, options);
    }


    
    copy()
    {
        const copy = new GOr(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalOrInputs(this.inputs, parse);
        

        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}



async function evalOrInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    const value = new NumberValue();


    if (!isEmpty(inputs))
    {
        const val0 = (await inputs[0].eval(parse)).toValue();
        if (!val0.isValid()) return NumberValue.NaN;

        if (    isListType(val0.type)
            && !isEmpty(val0.items))
        {
            const item0 = val0.items[0];

            value.value = item0.toNumber();

            for (let i = 1; i < val0.items.length; i++)
            {
                const item = val0.items[i];
                
                if (item.type == NUMBER_VALUE)
                    value.value = Math.max(value.value, item.toNumber());
            }
        }
        else
        {
            if (val0.type != NUMBER_VALUE)
                return NumberValue.NaN;

            value.value = val0.toNumber();
        }


        for (let i = 1; i < inputs.length; i++)
        {
            const val = (await inputs[i].eval(parse)).toValue();
            if (!val.isValid()) return NumberValue.NaN;

            if (isListType(val.type))
            {
                for (const item of val.items)
                {
                    if (item.type == NUMBER_VALUE)
                        value.value = Math.max(value.value, item.toNumber());
                }
            }
            else
            {
                consoleAssert(
                    val.type == NUMBER_VALUE, 
                    'val.type must be NUMBER_VALUE');
                    
                value.value = Math.max(value.value, val.toNumber());
            }
        }


        if (value.value != 0)
            value.value = 1;
    }


    return value;
}


class GXor
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_XOR, nodeId, options);
    }


    
    copy()
    {
        const copy = new GXor(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalXorInputs(this.inputs, parse);
        

        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}



async function evalXorInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    const value = new NumberValue(0);


    let flipped;

    if (!isEmpty(inputs))
    {
        const val0 = (await inputs[0].eval(parse)).toValue();
        if (!val0.isValid()) return NumberValue.NaN;

        if (    isListType(val0.type)
            && !isEmpty(val0.items))
        {
            const item0 = val0.items[0];

            flipped = item0.toNumber() != 0;

            for (let i = 1; i < val0.items.length; i++)
            {
                const item = val0.items[i];
                
                if (   item.type == NUMBER_VALUE
                    && item.toNumber() != 0)
                    flipped++;
            }
        }
        else
        {
            if (val0.type != NUMBER_VALUE)
                return NumberValue.NaN;

            flipped = val0.toNumber() != 0;
        }


        for (let i = 1; i < inputs.length; i++)
        {
            const val = (await inputs[i].eval(parse)).toValue();
            if (!val.isValid()) return NumberValue.NaN;

            if (isListType(val.type))
            {
                for (const item of val.items)
                {
                    if (   item.type == NUMBER_VALUE
                        && item.toNumber() != 0)
                        flipped++;
                    }
            }
            else
            {
                consoleAssert(
                    val.type == NUMBER_VALUE, 
                    'val.type must be NUMBER_VALUE');
                    
                if (val.toNumber() != 0)
                    flipped++;
            }
        }


        value.value = flipped == 1 ? 1 : 0;
    }


    return value;
}


class GCondition
extends GOperator1
{
    operation;
    operand;



    constructor(nodeId, options)
    {
        super(NUMBER_CONDITION, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.operation = null;
        this.operand   = null;
    }



    copy()
    {
        const copy = new GCondition(this.nodeId, this.options);

        copy.copyBase(this);

        copy.operation = this.operation.copy();
        copy.operand   = this.operand  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const op      = (await this.operation.eval(parse)).toValue();
        const operand = (await this.operand  .eval(parse)).toValue();

        op.value = Math.min(Math.max(0, op.value), CONDITION_OPS.length-1);

        
        switch (op.value)
        {
            case CONDITION_LESS:              this.value = await evalConditionInputs(this.input, operand, ((a, b) => a <  b), parse);  break;
            case CONDITION_LESS_OR_EQUAL:     this.value = await evalConditionInputs(this.input, operand, ((a, b) => a <= b), parse);  break;
            case CONDITION_NOT_EQUAL:         this.value = await evalConditionInputs(this.input, operand, ((a, b) => a != b), parse);  break;
            case CONDITION_EQUAL:             this.value = await evalConditionInputs(this.input, operand, ((a, b) => a == b), parse);  break;
            case CONDITION_GREATER_OR_EQUAL:  this.value = await evalConditionInputs(this.input, operand, ((a, b) => a >= b), parse);  break;
            case CONDITION_GREATER:           this.value = await evalConditionInputs(this.input, operand, ((a, b) => a >  b), parse);  break;
        }


        this.setUpdateValues(parse,
        [
            ['value',     this.value],
            ['operation', op        ],
            ['operand',   operand   ]
        ]);


        this.validate();

    return this;
    }



    isValid()
    {
        return super.isValid()
            && this.operation && this.operation.isValid()
            && this.operand   && this.operand  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.operation) this.operation.pushValueUpdates(parse);
        if (this.operand  ) this.operand  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.operation) this.operation.invalidateInputs(parse, from, force);
        if (this.operand  ) this.operand  .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.operation) this.operation.iterateLoop(parse);
        if (this.operand  ) this.operand  .iterateLoop(parse);
    }
}



async function evalConditionInputs(input0, input1, op, parse) 
{
    const val0 = input0 ? (await input0.eval(parse)).toValue() : NumberValue.NaN;
    const val1 = input1 ? (await input1.eval(parse)).toValue() : NumberValue.NaN;

    if (   val0.isValid() 
        && val1.isValid())
        return new NumberValue(op(val0.toNumber(), val1.toNumber()) ? 1 : 0);
    else                  
        return NumberValue.NaN;
}


class GEqual
extends GOperator2
{
    constructor(nodeId, options)
    {
        super(NUMBER_EQUAL, nodeId, options);
    }


    
    copy()
    {
        const copy = new GEqual(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalConditionInputs(
            this.input0, 
            this.input1, 
            (a, b) => a == b, 
            parse);
            

        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}



class GNotEqual
extends GOperator2
{
    constructor(nodeId, options)
    {
        super(NUMBER_NOT_EQUAL, nodeId, options);
    }


    
    copy()
    {
        const copy = new GNotEqual(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalConditionInputs(
            this.input0, 
            this.input1, 
            (a, b) => a != b, 
            parse);
        

        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}


class GLess
extends GOperator2
{
    constructor(nodeId, options)
    {
        super(NUMBER_LESS, nodeId, options);
    }


    
    copy()
    {
        const copy = new GLess(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalConditionInputs(
            this.input0, 
            this.input1, 
            (a, b) => a < b, 
            parse);
            

        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}


class GLessOrEqual
extends GOperator2
{
    constructor(nodeId, options)
    {
        super(NUMBER_LESS_OR_EQUAL, nodeId, options);
    }


    
    copy()
    {
        const copy = new GLessOrEqual(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalConditionInputs(
            this.input0, 
            this.input1, 
            (a, b) => a <= b, 
            parse);
            

        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}



class GGreater
extends GOperator2
{
    constructor(nodeId, options)
    {
        super(NUMBER_GREATER, nodeId, options);
    }


    
    copy()
    {
        const copy = new GGreater(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalConditionInputs(
            this.input0, 
            this.input1, 
            (a, b) => a > b, 
            parse);
        

        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}


class GGreaterOrEqual
extends GOperator2
{
    constructor(nodeId, options)
    {
        super(NUMBER_GREATER_OR_EQUAL, nodeId, options);
    }


    
    copy()
    {
        const copy = new GGreaterOrEqual(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalConditionInputs(
            this.input0, 
            this.input1, 
            (a, b) => a >= b, 
            parse);
            

        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}



class GTrig
extends GOperator1
{
    function;



    constructor(nodeId, options)
    {
        super(NUMBER_TRIG, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.function = null;
    }



    copy()
    {
        const copy = new GTrig(this.nodeId, this.options);

        copy.copyBase(this);

        copy.function = this.function.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const func = (await this.function.eval(parse)).toValue().toInteger();

        func.value = Math.min(Math.max(0, func.value), TRIG_OPS.length-1);

        
        switch (func.value)
        {
            case TRIG_SIN: this.value = await evalSine   (this.input, parse);  break;
            case TRIG_COS: this.value = await evalCosine (this.input, parse);  break;
            case TRIG_TAN: this.value = await evalTangent(this.input, parse);  break;
        }


        this.setUpdateValues(parse,
        [
            ['value',    this.value],
            ['function', func      ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.function && this.function.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.function) this.function.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.function) this.function.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.function) this.function.iterateLoop(parse);
    }
}


class GSine
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(NUMBER_SIN, nodeId, options);
    }


    
    copy()
    {
        const copy = new GSine(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) copy.input = this.input.copy();
        
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalSine(this.input, parse);


        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value.copy();
    }
}



async function evalSine(input, parse)
{
    if (!input)
        return NumberValue.NaN;

    let value = (await input.eval(parse)).toValue();

    const val = Math.sin(value.value);

    value = new NumberValue(val, decDigits(val));

    return value;
}


class GCosine
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(NUMBER_COS, nodeId, options);
    }


    
    copy()
    {
        const copy = new GCosine(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) copy.input = this.input.copy();
        
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalCosine(this.input, parse);


        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}



async function evalCosine(input, parse)
{
    if (!input)
        return NumberValue.NaN;

    let value = (await input.eval(parse)).toValue();

    const val = Math.cos(value.value);

    value = new NumberValue(val, decDigits(val));

    return value;
}


class GTangent
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(NUMBER_TAN, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTangent(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) copy.input = this.input.copy();
        
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalTangent(this.input, parse);


        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}



async function evalTangent(input, parse)
{
    if (!input)
        return NumberValue.NaN;

    let value = (await input.eval(parse)).toValue();

    const val = Math.tan(value.value);
    
    value = new NumberValue(val, decDigits(val));

    return value;
}


class GConvertAngle
extends GOperator1
{
    from;



    constructor(nodeId, options)
    {
        super(CONVERT_ANGLE, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.from = null;
    }



    copy()
    {
        const copy = new GConvertAngle(this.nodeId, this.options);

        copy.copyBase(this);

        copy.from = this.from.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = new NumberValue(0);

        
        const from = (await this.from.eval(parse)).toValue();


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();

            consoleAssert(
                this.value.type == NUMBER_VALUE, 
                'this.value.type must be NUMBER_VALUE');

            
            if (this.options.enabled)
            {
                switch (from.value)
                {
                    case 0: this.value.value = this.value.value/360 * Tau; break;
                    case 1: this.value.value = this.value.value/Tau * 360; break;
                }
            }

            this.value.decimals = decDigits(this.value.value);
        }
        else
            this.value = NumberValue.NaN;


        this.setUpdateValues(parse,
        [
            ['value', this.value],
            ['from',  from      ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.from && this.from.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.from) this.from.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.from) this.from.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.from) this.from.iterateLoop(parse);
    }
}



class GText
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(TEXT, nodeId, options);
    }



    copy()
    {
        const copy = new GText(this.nodeId, this.options);
        
        copy.copyBase(this);

        copy.value = this.value;
        
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        if (this.input)
            this.value = (await this.input.eval(parse)).toValue();
        else if (this.value)
            await this.value.eval(parse);
        else
            this.value = new TextValue();//TextValue.NaN;


        this.setUpdateValues(parse,
        [
            ['value', this.value]
        ]);

        
        this.validate();

        return this;
    }



    isValid()
    {
        return   !this.input
               && this.value != NAN_CHAR 
            || this.input.isValid();
    }



    isValid()
    {
        return ;
    }
}


class GTextLength
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(TEXT_LENGTH, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextLength(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.length) copy.length = this.length.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        let length;


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();
            consoleAssert(input.type == TEXT_VALUE, 'input must be TEXT_VALUE');

            length = new NumberValue(input.value.length);
        }
        else
            length = NumberValue.NaN;
    

        this.setUpdateValues(parse,
        [
            ['length', length]
        ]);


        this.validate();

        return this;
    }
}



class GTextTrim
extends GOperator1
{
    start = null;
    end   = null;


    
    constructor(nodeId, options)
    {
        super(TEXT_TRIM, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.start = null;
        this.end   = null;
    }



    copy()
    {
        const copy = new GTextTrim(this.nodeId, this.options);

        copy.copyBase(this);

        copy.start = this.start.copy();
        copy.end   = this.end  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const start = (await this.start.eval(parse)).toValue();
        const end   = (await this.end  .eval(parse)).toValue();


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();
            
            if (isListType(input.type))
            {
                this.value = new ListValue();

                for (let i = 0; i < input.items.length; i++)
                {
                    const item = input.items[i];

                    this.value.items.push(
                        item.type == TEXT_VALUE
                        ? getTrimValue(item, start, end, this.options.enabled)
                        : new TextValue());   
                }
            }
            else
            {
                this.value = getTrimValue(input, start, end, this.options.enabled);
            }
        }
        else
            this.value = new TextValue();//TextValue.NaN;


        this.setUpdateValues(parse,
        [
            ['value', this.value       ],
            ['type',  this.outputType()],
            ['start', start            ],
            ['end',   end              ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.start && this.start.isValid()
            && this.end   && this.end  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.start) this.start.pushValueUpdates(parse);
        if (this.end  ) this.end  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.start) this.start.invalidateInputs(parse, from, force);
        if (this.end  ) this.end  .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.start) this.start.iterateLoop(parse);
        if (this.end  ) this.end  .iterateLoop(parse);
    }
}



function getTrimValue(input, start, end, enabled)
{
    consoleAssert(input.type == TEXT_VALUE, 'input.type must be TEXT_VALUE');
               
    const value = input.copy();

    if (enabled)
    {
        if (start.value.length > 0) value.value = trimCharFromStart(value.value, unescapeString(start.value));
        if (end  .value.length > 0) value.value = trimCharFromEnd  (value.value, unescapeString(end  .value));
    }

    return value;
}


class GTextSubstring
extends GOperator1
{
    start = null;
    end   = null;


    
    constructor(nodeId, options)
    {
        super(TEXT_SUBSTRING, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.start = null;
        this.end   = null;
    }



    copy()
    {
        const copy = new GTextSubstring(this.nodeId, this.options);

        copy.copyBase(this);

        copy.start = this.start.copy();
        copy.end   = this.end  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const start = (await this.start.eval(parse)).toValue();
        const end   = (await this.end  .eval(parse)).toValue();

        let   length = 0;


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();
            
            length = input.value.length;
            
            this.value = input.copy();
            
            consoleAssert(this.value.type == TEXT_VALUE, 'this.value.type must be TEXT_VALUE');
                
                
            const _end =
                end.isValid()
                ? end
                : new NumberValue(input.value.length);


            if (start.value <= _end.value)
            {
                if (this.options.enabled)
                    this.value.value = this.value.value.substring(start.value, _end.value);
            }
            else
                this.value = new TextValue();//TextValue.NaN;
        }
        else
            this.value = new TextValue();//TextValue.NaN;


        this.setUpdateValues(parse,
        [
            ['value',  this.value             ],
            ['length', new NumberValue(length)], // used to set start and end maxima
            ['start',  start                  ],
            ['end',    end                    ]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.start && this.start.isValid()
            && this.end   && this.end  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.start) this.start.pushValueUpdates(parse);
        if (this.end  ) this.end  .pushValueUpdates(parse);
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.start) this.start.pushValueUpdates(parse);
        if (this.end  ) this.end  .pushValueUpdates(parse);
    }



    iterateLoop(parse, from)
    {
        super.iterateLoop(parse, from);

        if (this.start) this.start.iterateLoop(parse, from);
        if (this.end  ) this.end  .iterateLoop(parse, from);
    }
}



class GTextContains
extends GOperator2
{
    first;
    last;
    all;



    constructor(nodeId, options)
    {
        super(TEXT_CONTAINS, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.first = null;
        this.last  = null;
        this.all   = null;
    }



    copy()
    {
        const copy = new GTextContains(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input0 = this.input0 ? (await this.input0.eval(parse)).toValue() : null;
        const input1 = this.input1 ? (await this.input1.eval(parse)).toValue() : null;
    

        if (   input0 && input0.isValid() 
            && input1 && input1.isValid())
        {
            const indices = [];
            let   index   = 0;

            if (input1.value != '')
            {
                while (index != -1) 
                {
                    index = input0.value.indexOf(input1.value, index);

                    if (index != -1) 
                    {
                        indices.push(index);
                        index += 1;
                    }
                }

                
                this.value = new NumberValue(indices.length > 0 ? 1 : 0);

                this.first = indices.length > 0 ? new NumberValue(indices.at( 0)) : NumberValue.NaN;
                this.last  = indices.length > 0 ? new NumberValue(indices.at(-1)) : NumberValue.NaN;

                this.all   = new ListValue();

                for (const index of indices)
                    this.all.items.push(new NumberValue(index));
            }
            else
            {
                this.value = new NumberValue(1);

                this.first = NumberValue.NaN;
                this.last  = NumberValue.NaN;
                this.all   =   ListValue.NaN;
            }
        }
        else                  
        {
            this.value = NumberValue.NaN;
            this.first = NumberValue.NaN;
            this.last  = NumberValue.NaN;
            this.all   =   ListValue.NaN;
        }
    

        this.setUpdateValues(parse,
        [
            ['value', this.value],
            ['first', this.first],
            ['last',  this.last ],
            ['all',   this.all  ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.first && this.first.isValid()
            && this.last  && this.last .isValid()
            && this.all   && this.all  .isValid();
    }
}


class GTextCase
extends GOperator1
{
    case;


    
    constructor(nodeId, options)
    {
        super(TEXT_CASE, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.case = null;
    }



    copy()
    {
        const copy = new GTextCase(this.nodeId, this.options);

        copy.copyBase(this);

        copy.case = this.case.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const _case = (await this.case.eval(parse)).toValue();


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();
            
            consoleAssert(this.value.type == TEXT_VALUE, 'this.value.type must be TEXT_VALUE');
                
                
            if (this.options.enabled)
            {
                const val = this.value.value;

                if (_case.value == 0) 
                     this.value.value = val.toLowerCase();

                else if (_case.value == 1)
                {
                    this.value.value = '';

                    if (val.length > 0) this.value.value += val.substring(0, 1).toUpperCase();
                    if (val.length > 1) this.value.value += val.substring(1)   .toLowerCase();
                }

                else if (_case.value == 2)
                {
                    this.value.value = '';

                    let i = 0;
                    while (i < val.length)
                    {
                        while (i < val.length
                            && /\s/.test(val.charAt(i)))
                            this.value.value += val.charAt(i++);

                        if (i < val.length)
                            this.value.value += val.charAt(i++).toUpperCase();

                        while (i < val.length
                            && !/\s/.test(val.charAt(i)))
                            this.value.value += val.charAt(i++).toLowerCase();
                    }
                }

                else if (_case.value == 3) 
                    this.value.value = val.toUpperCase();
            }
        }
        else
            this.value = new TextValue();//TextValue.NaN;


        this.setUpdateValues(parse,
        [
            ['value', this.value],
            ['case',  _case     ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.case && this.case.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.case) this.case.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.case) this.case.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.case) this.case.iterateLoop(parse);
    }
}



class GNumberToText
extends GOperator1
{
    format;


    
    constructor(nodeId, options)
    {
        super(NUMBER_TO_TEXT, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.format = null;
    }



    copy()
    {
        const copy = new GNumberToText(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.format) copy.format = this.format.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const format = (await this.format.eval(parse)).toValue();


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();


            if (isListType(input.type))
            {
                this.value = new ListValue();

                for (let i = 0; i < input.items.length; i++)
                {
                    const item = input.items[i];

                    this.value.items.push(
                        item.type == NUMBER_VALUE
                        ? getNumberToTextValue(item, format)
                        : TextValue.NaN.copy());   
                }
            }
            else
            {
                this.value = getNumberToTextValue(input, format);
            }
        }

        else
            this.value = TextValue.NaN;


        this.setUpdateValues(parse,
        [
            ['type',   this.outputType()],
            ['format', format           ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.format && this.format.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.format) this.format.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.format) this.format.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.format) this.format.iterateLoop(parse);
    }
}



function getNumberToTextValue(input, format)
{
    let str = NAN_CHAR;

    switch (format.value)
    {
        case 0: // dec
            str = numToString(input.value, -input.decimals);
            break;

        case 1: // hex
            str = numToString(Math.round(input.value), input.decimals, true).toUpperCase();
            break;
    }

    return new TextValue(str);
}


class GColorToText
extends GOperator1
{
    format;


    
    constructor(nodeId, options)
    {
        super(COLOR_TO_TEXT, nodeId, options);
    }


    reset()
    {
        super.reset();

        this.format = null;
    }



   
    copy()
    {
        const copy = new GColorToText(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.format) copy.format = this.format.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const format = (await this.format.eval(parse)).toValue();


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();


            if (isListType(input.type))
            {
                this.value = new ListValue();

                for (let i = 0; i < input.items.length; i++)
                {
                    const item = input.items[i];

                    this.value.items.push(
                        item.type == NUMBER_VALUE
                        ? getColorToTextValue(item, format)
                        : TextValue.NaN.copy());   
                }
            }
            else
            {
                this.value = getColorToTextValue(input, format);
            }
        }

        else
            this.value = TextValue.NaN;


        this.setUpdateValues(parse,
        [
            ['type',   this.outputType()],
            ['format', format           ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.format && this.format.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.format) this.format.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.format) this.format.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.format) this.format.iterateLoop(parse);
    }
}



function getColorToTextValue(input, format)
{
    let str = NAN_CHAR;

    const rgb = input.toRgb();

    switch (format.value)
    {
        case 0: // hex
            str = rgb2hex(rgb);
            break;

        case 1: // rgb 1.0
            str = 
                  numToString(rgb[0], -3) + ', '
                + numToString(rgb[1], -3) + ', '
                + numToString(rgb[2], -3);
            break;

        case 2: // rgb 255
            str = 
                  Math.round(rgb[0] * 255) + ', '
                + Math.round(rgb[1] * 255) + ', '
                + Math.round(rgb[2] * 255);
            break;
    }

    return new TextValue(str);
}


class GTextToNumber
extends GOperator1
{
    format = null;


    
    constructor(nodeId, options)
    {
        super(TEXT_TO_NUMBER, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.format = null;
    }



    copy()
    {
        const copy = new GTextToNumber(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.format) copy.format = this.format.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const format = (await this.format.eval(parse)).toValue();


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();


            if (isListType(input.type))
            {
                this.value = new ListValue();

                for (let i = 0; i < input.items.length; i++)
                {
                    const item = input.items[i];

                    this.value.items.push(
                        item.type == TEXT_VALUE
                        ? getTextToNumberValue(item, format)
                        : NumberValue.NaN.copy());   
                }
            }
            else
            {
                this.value = getTextToNumberValue(input, format);
            }
        }

        else
            this.value = NumberValue.NaN;


        this.setUpdateValues(parse,
        [
            ['type',   this.outputType()],
            ['format', format           ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.format && this.format.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.format) this.format.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.format) this.format.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.format) this.format.iterateLoop(parse);
    }
}



function getTextToNumberValue(input, format)
{
    let num = Number.NaN;

    switch (format.value)
    {
        case 0: // dec
            num = parseFloat(input.value);
            break;

        case 1: // hex
            num = parseInt(input.value, 16);
            break;
    }

    return new NumberValue(num, decDigits(num));
}


class GTextToColor
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(TEXT_TO_COLOR, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextToColor(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            if (isListType(input.type))
            {
                this.value = new ListValue();

                for (let i = 0; i < input.items.length; i++)
                {
                    const item = input.items[i];

                    this.value.items.push(
                        item.type == TEXT_VALUE
                        ? getTextToColorValue(item)
                        : NumberValue.NaN.copy());   
                }
            }
            else
            {
                this.value = getTextToColorValue(input);
            }
        }
        else
            this.value = ColorValue.NaN;


        this.setUpdateValues(parse,
        [
            ['value', this.value       ],
            ['type',  this.outputType()]
        ]);


        this.validate();

        return this;
    }
}



function getTextToColorValue(input)
{
    const str = input.value.trim();

    let rgb = 
        str != ''
        ? validHex2rgb(str)
        : rgb_NaN;
        
    return ColorValue.fromRgb(scaleRgb(rgb));
}


class GTextCharacter
extends GOperator1
{
    code;


    
    constructor(nodeId, options)
    {
        super(TEXT_CHAR, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.code = null;
    }



    copy()
    {
        const copy = new GTextCharacter(this.nodeId, this.options);

        copy.copyBase(this);

        copy.code = this.code.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const code = (await this.code.eval(parse)).toValue();


        this.value = new TextValue(String.fromCharCode(code.value));


        this.setUpdateValues(parse,
        [
            ['value', this.value],
            ['code',  code      ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.code && this.code.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.code) this.code.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.code) this.code.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.code) this.code.iterateLoop(parse);
    }
}



class GIndexToName
extends GOperator
{
    name;
    index;


    
    constructor(nodeId, options)
    {
        super(INDEX_TO_NAME, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.index = null;
    }



    copy()
    {
        const copy = new GIndexToName(this.nodeId, this.options);

        copy.copyBase(this);

        copy.name  = this.name .copy();
        copy.index = this.index.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const name  = (await this.name .eval(parse)).toValue();
        const index = (await this.index.eval(parse)).toValue();


        switch (name.value)
        {
            case 0:
                this.value = new TextValue(figUniqueFontNames[index.value]);
                break;

            case 1: this.value = new TextValue(
                [
                    'monday', 
                    'tuesday', 
                    'wednesday', 
                    'thursday', 
                    'friday', 
                    'saturday', 
                    'sunday'
                ] 
                [index.value-1]);

                break;

            case 2: this.value = new TextValue(
                [
                    'january', 
                    'february', 
                    'march', 
                    'april', 
                    'may', 
                    'june', 
                    'july',
                    'august',
                    'september',
                    'october',
                    'november',
                    'december'
                ] 
                [index.value-1]);

                break;
        }


        this.setUpdateValues(parse,
        [
            ['value', this.value],
            ['name',  name      ],
            ['index', index     ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.index && this.index.isValid()
            && this.name  && this.name .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.index) this.index.pushValueUpdates(parse);
        if (this.name ) this.name .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.index) this.index.invalidateInputs(parse, from, force);
        if (this.name ) this.name .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.index) this.index.iterateLoop(parse);
        if (this.name ) this.name .iterateLoop(parse);
    }
}



class GTextReplace
extends GOperator1
{
    what  = null;
    with  = null;
    regex = null;



    constructor(nodeId, options)
    {
        super(TEXT_REPLACE, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.what  = null;
        this.with  = null;
        this.regex = null;
    }



    copy()
    {
        const copy = new GTextReplace(this.nodeId, this.options);

        copy.copyBase(this);

        copy.what  = this.what .copy();
        copy.with  = this.with .copy();
        copy.regex = this.regex.copy();

        copy.value = this.value.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const _what  = (await this.what .eval(parse)).toValue();
        const _with  = (await this.with .eval(parse)).toValue();
        const _regex = (await this.regex.eval(parse)).toValue();


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();
            
            if (isListType(input.type))
            {
                this.value = new ListValue();

                for (let i = 0; i < input.items.length; i++)
                {
                    const item = input.items[i];

                    this.value.items.push(
                        item.type == TEXT_VALUE
                        ? getReplaceValue(item, _what, _with, _regex)
                        : new TextValue());   
                }
            }
            else
            {
                this.value = getReplaceValue(input, _what, _with, _regex);
            }
        }
        else
            this.value = new TextValue();


        this.setUpdateValues(parse,
        [
            ['value',  this.value       ],
            ['type',   this.outputType()],
            ['what',  _what             ],
            ['with',  _with             ],
            ['regex', _regex            ]
        ]);

        
        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.what  && this.what .isValid()
            && this.with  && this.with .isValid()
            && this.regex && this.regex.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.what ) this.what .pushValueUpdates(parse);
        if (this.with ) this.with .pushValueUpdates(parse);
        if (this.regex) this.regex.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.what ) this.what .invalidateInputs(parse, from, force);
        if (this.with ) this.with .invalidateInputs(parse, from, force);
        if (this.regex) this.regex.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.what ) this.what .iterateLoop(parse);
        if (this.with ) this.with .iterateLoop(parse);
        if (this.regex) this.regex.iterateLoop(parse);
    }
}



function getReplaceValue(input, _what, _with, _regex)
{
    consoleAssert(input.type == TEXT_VALUE, 'input.type must be TEXT_VALUE');

    const value = new TextValue();

    
    if (_regex.value > 0)
    {
        try
        {
            const regex = new RegExp(_what.value, 'g');

            value.value = input.value.replace(
                regex,
                _with.value);
        }
        catch (e)
        {
        
        }
    }
    else
    {
        value.value = input.value.replaceAll(
            unescapeString(_what.value),
            unescapeString(_with.value));
    }


    return value;
}


class GTextJoin
extends GOperator
{
    inputs = [];

    with = null;


    
    constructor(nodeId, options)
    {
        super(TEXT_JOIN, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.inputs = [];
        
        this.with = null;
    }


   
    copy()
    {
        const copy = new GTextJoin(this.nodeId, this.options);
        copy.copyBase(this);
        
        copy.inputs = this.inputs.map(i => i.copy());
        copy.with   = this.with;

        return copy;
    }



    isCached()
    {
        for (const input of this.inputs)
            if (!input.isCached())
                return false;

        return super.isCached();
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const _with = (await this.with.eval(parse)).toValue();

        this.value = await evalJoinInputs(this.inputs, _with, parse);

        
        this.setUpdateValues(parse,
        [
            ['value', this.value],
            ['with',  _with     ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return !this.inputs.find(i => !i.isValid())
            && this.with && this.with.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse));
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        this.inputs.forEach(i => i.invalidateInputs(parse, from, force));
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        this.inputs.forEach(i => i.iterateLoop(parse));
    }
}



async function evalJoinInputs(inputs, _with, parse)
{
    if (isEmpty(inputs))
        return new TextValue();//TextValue.NaN;


    const value = new TextValue();
    const w     = unescapeString(_with.value);

    for (let i = 0; i < inputs.length; i++)
    {
        const val = (await inputs[i].eval(parse)).toValue();
        if (!val) continue;


        if (i > 0)
            value.value += w;


        if (isListType(val.type))
        {
            for (let j = 0; j < val.items.length; j++)
            {
                if (j > 0)
                    value.value += w;


                const item = val.items[j];

                if (item.type == TEXT_VALUE)
                    value.value += item.value;
            }
        }
        else
        {
            consoleAssert(val.type == TEXT_VALUE, 'val.type must be TEXT_VALUE');

            value.value += val.value;
        }
    }


    return value;
}


class GTextPad
extends GOperator1
{
    startPad   = null;
    startCount = null;
    endPad     = null;
    endCount   = null;
    
    
    
    constructor(nodeId, options)
    {
        super(TEXT_PAD, nodeId, options);
    }


    
    reset()
    {
        super.reset();
        
        this.startPad   = null;
        this.startCount = null;
        this.endPad     = null;
        this.endCount   = null;
    }



    copy()
    {
        const copy = new GTextPad(this.nodeId, this.options);

        copy.copyBase(this);

        copy.startPad   = this.startPad  .copy();
        copy.startCount = this.startCount.copy();
        copy.endPad     = this.endPad    .copy();
        copy.endCount   = this.endCount  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const startPad   = (await this.startPad  .eval(parse)).toValue();
        const startCount = (await this.startCount.eval(parse)).toValue();
        const endPad     = (await this.endPad    .eval(parse)).toValue();
        const endCount   = (await this.endCount  .eval(parse)).toValue();


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();
            
            if (isListType(input.type))
            {
                this.value = new ListValue();

                for (let i = 0; i < input.items.length; i++)
                {
                    const item = input.items[i];

                    this.value.items.push(
                        item.type == TEXT_VALUE
                        ? getPadValue(
                            item, 
                            startPad, 
                            startCount, 
                            endPad, 
                            endCount, 
                            this.options.enabled)
                        : new TextValue());   
                }
            }
            else
            {
                this.value = getPadValue(
                    input, 
                    startPad, 
                    startCount, 
                    endPad, 
                    endCount, 
                    this.options.enabled);
            }
        }
        else
            this.value = new TextValue();//TextValue.NaN;


        this.setUpdateValues(parse,
        [
            ['value',      this.value       ],
            ['type',       this.outputType()],
            ['startPad',   startPad         ],
            ['startCount', startCount       ],
            ['endPad',     endPad           ],
            ['endCount',   endCount         ]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.startPad   && this.startPad  .isValid()
            && this.startCount && this.startCount.isValid()
            && this.endPad     && this.endPad    .isValid()
            && this.endCount   && this.endCount  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.startPad  ) this.startPad  .pushValueUpdates(parse);
        if (this.startCount) this.startCount.pushValueUpdates(parse);
        if (this.endPad    ) this.endPad    .pushValueUpdates(parse);
        if (this.endCount  ) this.endCount  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.startPad  ) this.startPad  .invalidateInputs(parse, from, force);
        if (this.startCount) this.startCount.invalidateInputs(parse, from, force);
        if (this.endPad    ) this.endPad    .invalidateInputs(parse, from, force);
        if (this.endCount  ) this.endCount  .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.startPad  ) this.startPad  .iterateLoop(parse);
        if (this.startCount) this.startCount.iterateLoop(parse);
        if (this.endPad    ) this.endPad    .iterateLoop(parse);
        if (this.endCount  ) this.endCount  .iterateLoop(parse);
    }
}



function getPadValue(input, startPad, startCount, endPad, endCount, enabled)
{
    consoleAssert(input.type == TEXT_VALUE, 'input.type must be TEXT_VALUE');

    const value = input.copy();
    
    if (enabled)
        value.value = input.value
            .padStart(startCount.value, unescapeString(startPad.value))
            .padEnd  (  endCount.value, endPad.value != '' ? unescapeString(endPad.value) : unescapeString(startPad.value));

    return value;
}


class GTextSplit
extends GOperator1
{
    value;
    separator;



    constructor(nodeId, options)
    {
        super(TEXT_SPLIT, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.value     = null;
        this.separator = null;
    }


   
    copy()
    {
        const copy = new GTextSplit(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.value    ) copy.value     = this.value    .copy();
        if (this.separator) copy.separator = this.separator.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const separator = this.separator ? (await this.separator.eval(parse)).toValue() : null;


        this.value = new ListValue();


        if (   this.input
            && separator)
        {
            const input = (await this.input.eval(parse)).toValue();
            
            if (   input
                && input.value)
            {
                consoleAssert(input.type == TEXT_VALUE, 'input must be TEXT_VALUE');
                const items = input.value.split(unescapeString(separator.value));

                for (const item of items)
                    this.value.items.push(new TextValue(item));
            }
        }
    

        this.setUpdateValues(parse,
        [
            ['value',     this.value],
            ['separator', separator ]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.separator && this.separator.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.separator) this.separator.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.separator) this.separator.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.separator) this.separator.iterateLoop(parse);
    }
}



class GTextCompare
extends GOperator2
{
    operation;



    constructor(nodeId, options)
    {
        super(TEXT_COMPARE, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.operation = null;
    }



    copy()
    {
        const copy = new GTextCompare(this.nodeId, this.options);

        copy.copyBase(this);

        copy.operation = this.operation.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const op = (await this.operation.eval(parse)).toValue().toInteger();

        op.value = Math.min(Math.max(0, op.value), CONDITION_OPS.length-1);

        
        let result;

        switch (op.value)
        {
            case CONDITION_LESS:              result = await evalCompareInputs(this.input0, this.input1, ((a, b) => a <  b), parse);  break;
            case CONDITION_LESS_OR_EQUAL:     result = await evalCompareInputs(this.input0, this.input1, ((a, b) => a <= b), parse);  break;
            case CONDITION_NOT_EQUAL:         result = await evalCompareInputs(this.input0, this.input1, ((a, b) => a != b), parse);  break;
            case CONDITION_EQUAL:             result = await evalCompareInputs(this.input0, this.input1, ((a, b) => a == b), parse);  break;
            case CONDITION_GREATER_OR_EQUAL:  result = await evalCompareInputs(this.input0, this.input1, ((a, b) => a >= b), parse);  break;
            case CONDITION_GREATER:           result = await evalCompareInputs(this.input0, this.input1, ((a, b) => a >  b), parse);  break;
        }


        this.setUpdateValues(parse,
        [
            ['result',    result],
            ['operation', op    ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.operation && this.operation.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.operation) this.operation.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.operation) this.operation.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.operation) this.operation.iterateLoop(parse);
    }
}



async function evalCompareInputs(input0, input1, op, parse) 
{
    const val0 = input0 ? (await input0.eval(parse)).toValue() : TextValue.NaN;
    const val1 = input1 ? (await input1.eval(parse)).toValue() : TextValue.NaN;

    if (   val0 && val0.isValid() 
        && val1 && val1.isValid())
        return new NumberValue(op(val0.value, val1.value) ? 1 : 0);
    else                  
        return NullValue;//new NumberValue(0);
}


class GTextCSV
extends GOperator1
{
    rowSeparator;
    columnSeparator;



    constructor(nodeId, options)
    {
        super(TEXT_CSV, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.rowSeparator    = null;
        this.columnSeparator = null;
    }



    copy()
    {
        const copy = new GTextCSV(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.rowSeparator   ) copy.rowSeparator    = this.rowSeparator   .copy();
        if (this.columnSeparator) copy.columnSeparator = this.columnSeparator.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const rowSeparator    = this.rowSeparator    ? (await this.rowSeparator   .eval(parse)).toValue() : null;
        const columnSeparator = this.columnSeparator ? (await this.columnSeparator.eval(parse)).toValue() : null;


        this.value = new ListValue();


        let maxColumns = 0;

        
        let nRows    = 0;
        let nColumns = 0;


        if (   this.input
            && rowSeparator
            && columnSeparator
            && rowSeparator.value != '')
        {
            const input = this.input ? (await this.input.eval(parse)).toValue() : null;
            

            const rows = 
                   input
                && input.value            
                ? input.value.split(unescapeString(rowSeparator.value))
                : [];


            for (const _row of rows)
            {
                const cells = 
                    _row
                    ? _row.split(unescapeString(columnSeparator.value))
                    : [];


                const row = new ListValue();

                for (const cell of cells)
                    row.items.push(new TextValue(cell));

                maxColumns = Math.max(maxColumns, row.items.length);


                this.value.items.push(row);
            }


            nRows    = this.value.items.length;
            nColumns = maxColumns;
        }
    

        this.setUpdateValues(parse,
        [
            ['preview',         new ListValue(this.value.items.slice(0, Math.min(this.value.items.length, 11)))],
            ['rowSeparator',    rowSeparator             ],
            ['columnSeparator', columnSeparator          ],
            ['rows',            new NumberValue(nRows   )],
            ['columns',         new NumberValue(nColumns)]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.rowSeparator    && this.rowSeparator   .isValid()
            && this.columnSeparator && this.columnSeparator.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.rowSeparator   ) this.rowSeparator   .pushValueUpdates(parse);
        if (this.columnSeparator) this.columnSeparator.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.rowSeparator   ) this.rowSeparator   .invalidateInputs(parse, from, force);
        if (this.columnSeparator) this.columnSeparator.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.rowSeparator   ) this.rowSeparator   .iterateLoop(parse);
        if (this.columnSeparator) this.columnSeparator.iterateLoop(parse);
    }
}



class GTextJson
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(TEXT_JSON, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextJson(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = new ListValue();


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();
            
            try
            {
                const json = JSON.parse(input.value);
                this.value = this.evalItems(json);
            }
            catch (e)
            {
                this.value = new ListValue();
            }
        }
    

        // console.log('this.value =', this.value);
        this.setUpdateValues(parse,
        [
            ['preview', new ListValue(this.value.items.slice(0, Math.min(this.value.items.length, 11)))],
            ['length',  new NumberValue(this.value.items.length)]
            //['value',   this.value]
        ]);
        

        this.validate();

        return this;
    }



    evalItems(json)
    {
        let list = new ListValue();


        for (const key in json)
        {
            if (   typeof json[key] === 'object'
                && json[key] !== null)
            {
                const obj = this.evalItems(json[key]);
                obj.valueId = key;
                list.items.push(obj);
            }
            else
            {
                let value;

                if (   typeof json[key] === 'number'
                    || isValidFloatString(json[key]))
                    value = NumberValue.fromString(json[key].toString());
                else if (typeof json[key] === 'boolean')
                    value = new NumberValue(parseBool(json[key].toString()) ? 1 : 0);
                else
                    value = new TextValue(json[key]);

                    
                value.valueId = 
                    key == 'value'
                    ? '(value)' // reserved param name in Generator
                    : key;

                list.items.push(value);
            }
        }

        
        return list;
    }
}



class GTextFetch
extends GOperator
{
    request;
    cachedValue;



    constructor(nodeId, options)
    {
        super(TEXT_FETCH, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.request     = null;
        this.cachedValue = null;
    }



    copy()
    {
        const copy = new GTextFetch(this.nodeId, this.options);

        copy.copyBase(this);

        copy.request     = this.request    .copy();
        copy.cachedValue = this.cachedValue.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const request     = (await this.request    .eval(parse)).toValue();
        const cachedValue = (await this.cachedValue.eval(parse)).toValue();

        
        genInitNodeProgress(this.nodeId);


        if (cachedValue.value == '')
        {
            try 
            {
                const response = await fetch(request.value);
                const content  = await response.text();
                
                this.value = new TextValue(content);
            }
            catch (e)
            {
                // const parts = e.message.split(':');
                
                this.value = 
                    request.value.trim() == NULL
                    ? new TextValue()
                    : new TextValue('invalid request');//parts[Math.min(1, parts.length-1)]);
            }
        }
        else
        {
            this.value = this.cachedValue.copy();
        }


        this.setUpdateValues(parse,
        [
            ['preview', this.value],
            ['value',   this.value],
            ['request', request   ]
        ]);
        
        
        this.validate();

        return this;
    }



    isValid()
    {
        return this.request && this.request.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.request) this.request.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.request) this.request.invalidateInputs(parse, from, force);

        this.cachedValue = new TextValue();
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.request) this.request.iterateLoop(parse);
    }
}


class GTextFile
extends GOperator
{
    //path;
    
    cachedValue = null;



    constructor(nodeId, options)
    {
        super(TEXT_FILE, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.cachedValue = null;
    }



    copy()
    {
        const copy = new GTextFile(this.nodeId, this.options);

        copy.copyBase(this);

        copy.cachedValue = this.cachedValue.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const cachedValue = this.cachedValue ? (await this.cachedValue.eval(parse)).toValue() : null;
        //const path        = this.path        ? (await this.path       .eval(parse)).toValue() : null;

        
        genInitNodeProgress(this.nodeId);


        this.value = cachedValue ?? new TextValue();


        this.setUpdateValues(parse,
        [
            ['preview', this.value]//,
            //['path',    path      ]
        ]);
        
        
        this.validate();

        return this;
    }



    isValid()
    {
        return false;//return this.path && this.path.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.path) this.path.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.path) this.path.invalidateInputs(parse, from, force);

        //this.cachedValue = new TextValue();
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.path) this.path.iterateLoop(parse);
    }
}


class ColorCorrection
{
    name; // 'H', 'C', or 'L'
    max;
    value;
    
    constructor(name = '', max = 0, value = 0)//, locked = false)
    {
        this.name  = name;
        this.max   = max;
        this.value = value;
    }
}



async function findCorrection(parse,
                        nodeId,
                        color,
                        order, _c1, _c2, _c3,
                        lockedOrder, locked1, locked2, locked3) 
{
    const refOklab = dataColor2array(dataColor2oklab(color));

    
    let closestColor = [...color],
        closestOklab = null, 
        closestOrder = order ? order.value : -1,
        closest1     = -1,
        closest2     = -1,
        closest3     = -1;


    let progress = 0,
        total    = 6 * Math.pow(2, Tau);

        
    let d = 1;
        
    parse.totalProgress += 1024;


    dLoop:
    while (d > 1/1024)
    {
        if (parse.stop()) break dLoop;

        let _closestColor = [...closestColor];


        for (let _order = 0; _order < 6; _order++)
        {
            if (parse.stop()) break dLoop;

            closestColor = [..._closestColor];

            const [min1, min2, min3] = getMinCorrections(color[0], _order);
            const [max1, max2, max3] = getMaxCorrections(color[0], _order);

            let start1 = lerp(min1, closest1, 1-d),  end1 = lerp(max1, closest1, 1-d),
                start2 = lerp(min2, closest2, 1-d),  end2 = lerp(max2, closest2, 1-d),
                start3 = lerp(min3, closest3, 1-d),  end3 = lerp(max3, closest3, 1-d);
               
                
            if (locked1) { closest1 = _c1.toNumber(); start1 = closest1; end1 = closest1+Epsilon; }
            if (locked2) { closest2 = _c2.toNumber(); start2 = closest2; end2 = closest2+Epsilon; }
            if (locked3) { closest3 = _c3.toNumber(); start3 = closest3; end3 = closest3+Epsilon; }
            

          [ closestColor,
            closestOklab,
            closestOrder,
            closest1,
            closest2,
            closest3,
            progress ] = await findCorrectionInOrder(
                parse,
                nodeId,
                refOklab,
                _order, 
                lockedOrder, 
                locked1,  locked2,  locked3,
                closest1, closest2, closest3,
                start1,   start2,   start3, 
                end1,     end2,     end3,
                [...closestColor],
                closestOklab, 
                closestOrder,
                progress,
                total);
        }


        if (parse.stopGenerate)
            break;

        
        d /= 2;


        parse.currentProgress++;
    }


    if (   !parse.stop()
        && !parse.stopGenerate)
    {
        // reduce closest to necessary minimums

        const closestRgb = getCorrectedColor(color, closestOrder, closest1, closest2, closest3)[2];

        let c1 = closest1;
        let c2 = closest2;
        let c3 = closest3;

        while (c1 >= 0 && rgbEqual(getCorrectedColor(color, closestOrder, c1-1, closest2, closest3)[2], closestRgb)) c1--;
        while (c2 >= 0 && rgbEqual(getCorrectedColor(color, closestOrder, closest1, c2-1, closest3)[2], closestRgb)) c2--;
        while (c3 >= 0 && rgbEqual(getCorrectedColor(color, closestOrder, closest1, closest2, c3-1)[2], closestRgb)) c3--;

        closest1 = Math.max(0, c1);
        closest2 = Math.max(0, c2);
        closest3 = Math.max(0, c3);
    }

    
    return [
        closestOrder,
        closest1,
        closest2,
        closest3 ];
}



async function findCorrectionInOrder(parse,
                                     nodeId,
                                     refOklab,
                                     order, 
                                     lockedOrder, 
                                     locked1,  locked2,  locked3,
                                     closest1, closest2, closest3,
                                     start1,   start2,   start3, 
                                     end1,     end2,     end3,
                                     closestColor,
                                     closestOklab,
                                     closestOrder,
                                     progress,
                                     total)
{
    const color = [...closestColor];
    
    let nSteps1 = locked1 ? 1 : 2;
    let nSteps2 = locked2 ? 1 : 2;
    let nSteps3 = locked3 ? 1 : 2;


    cLoop:
    for (let m1 = start1; m1 < end1; m1 += (end1-start1)/nSteps1)
    {
       if (parse.stop()) break cLoop;

        for (let m2 = start2; m2 < end2; m2 += (end2-start2)/nSteps2)
        {
            if (parse.stop()) break cLoop;

            for (let m3 = start3; m3 < end3; m3 += (end3-start3)/nSteps3)
            {
                if (parse.stop()) break cLoop;

                const [_color, _oklab, _rgb] = getCorrectedColor(color, order, m1, m2, m3);

                if (   rgbIsOk(_rgb)
                    && (  !closestOklab
                        || rgbDistance(refOklab, _oklab) < rgbDistance(refOklab, closestOklab)))
                {
                    closestColor = _color;
                    closestOklab = _oklab;
                    
                    if (!lockedOrder)
                        closestOrder = order;

                    closest1     = m1;
                    closest2     = m2;
                    closest3     = m3;
                }

                progress++;
            }
        }

        
        if (parse.repeats.length == 1)
        {
            const stopRequestId = await genGetValueFromUi('stopRequestId');

            if (   parse.requestId == stopRequestId.value
                || curRequestIds.includes(parse.requestId)) 
            { 
                parse.stopGenerate = true;
                break; 
            }
        }


        genUpdateNodeProgress(parse, nodeId, progress / total, false);
    }

    
    return [
        closestColor,
        closestOklab,
        closestOrder,
        closest1,
        closest2,
        closest3,
        progress ];
}



function getCorrectedColor(color, order, m1, m2, m3)
{
    const _color = correctColor(color, order, m1, m2, m3);
    const oklab  = dataColor2array(dataColor2oklab(_color));
    const rgb    = oklab2rgb(oklab);

    return [_color, oklab, rgb];
}



function correctColor(color, order, c1, c2, c3)
{
    if (order < 0)
        return color;


    const [i1, i2, i3] = getCorrectionsInOrder(order);

                               color = correctChannel(color, i1, c1);
    if (!dataColorIsOk(color)) color = correctChannel(color, i2, c2);
    if (!dataColorIsOk(color)) color = correctChannel(color, i3, c3);


    // clip colors that are reasonably valid but stick over the fence
    
    let rgb = dataColor2rgb(color);

    if (rgbIsOk(rgb))
        rgb = invalid2validRgb(rgb);
    
        
    color = convertDataColorToSpace(
        rgb2dataColor(rgb),
        color[0]);

        
    return color;
}



function correctChannel(color, iChan, margin)
{
    const factor = colorSpaceFactor(color[0]);

    margin /= factor[iChan];


    const savedColor = [...color];
    const savedValue = color[iChan+1];

    const d = 0.001;


    let _c  = savedValue,
         c_ = savedValue;

    let _valid  = dataColorIsOk(color);
    let  valid_ = _valid;


    let stackOverflowProtect = 1/d;


    while (   !_valid
           && ! valid_
           && stackOverflowProtect-- > 0)
    {
        _c  -= d;  _valid  = isColorOk(_c , iChan, savedColor);
         c_ += d;   valid_ = isColorOk( c_, iChan, savedColor);
    }


    stackOverflowProtect = 1/d;
    color = [...savedColor];


    if (_valid) 
    { 
        _valid = dataColorIsOk(color);
        _c     = savedValue;

        while (   !_valid
               && margin > 0
               && stackOverflowProtect-- > 0)
        {
            _c -= d; 
            _valid = isColorOk(_c, iChan, savedColor);
            margin -= d;
        }

        color[iChan+1] = _c;
    }
    else if (valid_)
    { 
        valid_ = dataColorIsOk(color);
        c_     = savedValue;

        while (   !valid_
               && margin > 0
               && stackOverflowProtect-- > 0)
        {
            c_ += d; 
            valid_ = isColorOk(c_, iChan, savedColor);
            margin -= d;
        }

        color[iChan+1] = c_;
    }


    return color;
}



function isColorOk(c, iChan, savedColor)
{
    let color = [...savedColor];
    color[iChan+1] = c; 
    return dataColorIsOk(color);
}



function getCorrectionsInOrder(order)
{
    switch (order)
    {
        case 0: return [0, 1, 2];
        case 1: return [1, 0, 2];
        case 2: return [1, 2, 0];
        case 3: return [0, 2, 1];
        case 4: return [2, 0, 1];
        case 5: return [2, 1, 0];
    }

    // should never get here
    consoleError('invalid correction order ' + order);
    return [0, 0, 0];
}



function getMinCorrections(space, order)
{
    const [c1, c2, c3] = getCorrectionsInOrder(order);

    let min;

    switch (space)
    {
        case 'hex':
        case 'rgb':    min = [0, 0, 0]; break

        case 'hsv': 
        case 'hsl':    min = [0, 0, 0]; break;

        case 'hclok':
        case 'hclab':
        case 'hcluv': min = [0, 0, 0]; break;

        case 'oklab':
        case 'lab':
        case 'luv':    min = [0, -oppFactor[1]/2, -oppFactor[2]/2]; break;
        
        default:
            // should never get here
            consoleError('invalid validation order ' + order);
            return [0, 0, 0];
    }

    return [min[c1], min[c2], min[c3]];
}



function getMaxCorrections(space, order)
{
    const [c1, c2, c3] = getCorrectionsInOrder(order);

    let max;

    switch (space)
    {
        case 'hex':
        case 'rgb':    max = [...rgbFactor]; break;

        case 'hsv': 
        case 'hsl':    max = [hs_Factor[0]/2, hs_Factor[1], hs_Factor[2]]; break;

        case 'hclok':
        case 'hclab':
        case 'hcluv': max = [hclFactor[0]/2, hclFactor[1], hclFactor[2]]; break;

        case 'oklab':
        case 'lab':
        case 'luv':    max = [...oppFactor]; break;
        
        default:
            // should never get here
            consoleError('invalid validation order ' + order);
            return [0, 0, 0];
    }

    return [max[c1], max[c2], max[c3]];
}



function reorderCorrection(closestOrder,
                           closest1, closest2, closest3,
                           locked1,  locked2,  locked3)
{
    let c1 = { closest: closest1, locked: locked1 };
    let c2 = { closest: closest2, locked: locked2 };
    let c3 = { closest: closest3, locked: locked3 };

    if (   c1.closest <  Epsilon
        && c2.closest <  Epsilon
        && c3.closest >= Epsilon)
    {
        switch (closestOrder)
        {
            case 0: closestOrder = 4; break;
            case 1: closestOrder = 5; break;
            case 2: closestOrder = 0; break;
            case 3: closestOrder = 1; break;
            case 4: closestOrder = 2; break;
            case 5: closestOrder = 3; break;
        }

        const tmp = c2;
        c1 = c3;
        c2 = c1;
        c3 = tmp;
    }
    else if (c1.closest >= Epsilon
          && c2.closest <  Epsilon)
    {
        switch (closestOrder)
        {
            case 0: closestOrder = 3; break;
            case 1: closestOrder = 2; break;
            case 2: closestOrder = 1; break;
            case 3: closestOrder = 0; break;
            case 4: closestOrder = 5; break;
            case 5: closestOrder = 4; break;
        }

        const tmp = c2;
        c2 = c3;
        c3 = tmp;
    }
    else if (c1.closest < Epsilon)
    {
        switch (closestOrder)
        {
            case 0: closestOrder = 2; break;
            case 1: closestOrder = 3; break;
            case 2: closestOrder = 4; break;
            case 3: closestOrder = 5; break;
            case 4: closestOrder = 0; break;
            case 5: closestOrder = 1; break;
        }

        const tmp = c1;
        c1 = c2;
        c2 = c3;
        c3 = tmp;
    }


    return [
        closestOrder,
        c1.closest, c2.closest, c3.closest,
        c1.locked,  c2.locked,  c3.locked ];
}



function getColorCorrections(colorSpace)
{
    switch (colorSpace)
    {
    case 'hex':
    case 'rgb':
        return [
            new ColorCorrection('R', rgbFactor[0]),
            new ColorCorrection('G', rgbFactor[1]),
            new ColorCorrection('B', rgbFactor[2]) ];

    case 'hsv':
        return [
            new ColorCorrection('H', hs_Factor[0]/2),
            new ColorCorrection('S', hs_Factor[1]),
            new ColorCorrection('V', hs_Factor[2]) ];

    case 'hsl':
        return [
            new ColorCorrection('H', hs_Factor[0]/2),
            new ColorCorrection('S', hs_Factor[1]),
            new ColorCorrection('L', hs_Factor[2]) ];

    case 'hclok':
    case 'hclab':
    case 'hcluv':
        return [
            new ColorCorrection('H', hclFactor[0]/2),
            new ColorCorrection('C', hclFactor[1]),
            new ColorCorrection('L', hclFactor[2]) ];

    case 'oklab': 
    case 'lab':
        return [
            new ColorCorrection('L', oppFactor[0]),
            new ColorCorrection('a', oppFactor[1]),
            new ColorCorrection('b', oppFactor[2]) ];

    case 'luv':
        return [
            new ColorCorrection('L', oppFactor[0]),
            new ColorCorrection('u', oppFactor[1]),
            new ColorCorrection('v', oppFactor[2]) ];
    }


    consoleError('invalid color space ' + colorSpace);
    return [
        new ColorCorrection(),
        new ColorCorrection(),
        new ColorCorrection() ];
}


class GColor
extends GOperator1
{
    space   = null;
    
   _c1      = null;
   _c2      = null;
   _c3      = null;
    
    c1      = null;
    c2      = null;
    c3      = null;

    convert = null;
    
    hasInputs;



    constructor(nodeId, options)
    {
        super(COLOR, nodeId, options);
    }

    
    
    reset()
    {
        super.reset();
        
        this.space   = null;
        
        this._c1     = null;
        this._c2     = null;
        this._c3     = null;
        
        this.c1      = null;
        this.c2      = null;
        this.c3      = null;
    
        this.convert = null;
    }



    copy()
    {
        const copy = new GColor(this.nodeId, this.options);

        copy.copyBase(this);

        copy.space = this.space.copy();

        if (this._c1) copy._c1 = this._c1.copy();
        if (this._c2) copy._c2 = this._c2.copy();
        if (this._c3) copy._c3 = this._c3.copy();

        if (this. c1) copy. c1 = this. c1.copy();
        if (this. c2) copy. c2 = this. c2.copy();
        if (this. c3) copy. c3 = this. c3.copy();

        if (this.convert) 
            copy.convert = this.convert.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const space = this.space ? (await this.space.eval(parse)).toValue().toInteger() : null; 
        let   c1    = this._c1   ? (await this._c1  .eval(parse)).toValue()             : null;
        let   c2    = this._c2   ? (await this._c2  .eval(parse)).toValue()             : null;
        let   c3    = this._c3   ? (await this._c3  .eval(parse)).toValue()             : null;

        
        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            
            if (   input.isValid())
                // && this.input.type != START)
            {
                if (this.options.enabled)
                {
                    this.value = input.copy();
                    

                    const fromSpaceIndex = input.space.value;

                    const toSpaceIndex = Math.min(Math.max(
                        0,
                        Math.round(space.value)), // round because a value can come in with decimals (TODO fix this)
                        colorSpaceCount(parse)-1);


                    if (toSpaceIndex != fromSpaceIndex)
                    {
                        this.convertColor(
                            this.value,
                            colorSpace(fromSpaceIndex), 
                            colorSpace(  toSpaceIndex));

                        this.value.space.value = toSpaceIndex;
                    }

                    
                    if (!c1) c1 = this.value.c1;
                    if (!c2) c2 = this.value.c2;
                    if (!c3) c3 = this.value.c3;
 
                    if (c1) { this.value.c1 = c1; this.c1 = c1; }
                    if (c2) { this.value.c2 = c2; this.c2 = c2; }
                    if (c3) { this.value.c3 = c3; this.c3 = c3; }
                }
                else
                    this.value = input;
            }
            else
                this.value = ColorValue.NaN.copy();

                
            if (!this.convert)
                this.convert = NumberValue.NaN.copy();
        }
        else
        {
            this.value = new ColorValue(space, c1, c2, c3);


            const toSpaceIndex = Math.min(Math.max(
                0,
                Math.round(this.value.space.value)), // round because a value can come in with decimals (TODO fix this)
                colorSpaceCount(parse)-1);

            this.value.space.value = toSpaceIndex;

            if (    this.convert
                &&  this.convert.isValid()
                &&  this.convert.value > -1
                &&  this.value.isValid()
                && !this.hasInputs)
            {
                await this.convert.eval(parse);

                this.convertColor(
                    this.value,
                    colorSpace(this.convert.value), 
                    colorSpace(toSpaceIndex));
            }
        }


        if (!this.value.space.isValid())
            this.value = new ColorValue(
                this.space.toValue(),
                NumberValue.NaN,
                NumberValue.NaN,
                NumberValue.NaN);


        this.setUpdateValues(parse,
        [
            ['convert', this.convert    ],
            ['space',   this.value.space],
            ['c1',      this.value.c1   ],
            ['c2',      this.value.c2   ],
            ['c3',      this.value.c3   ]
        ]);


        // if (!this.c1) this.c1 = this.value.c1.copy();
        // if (!this.c2) this.c2 = this.value.c2.copy();
        // if (!this.c3) this.c3 = this.value.c3.copy();


        this.validate();

        return this;
    }



    convertColor(color, fromSpace, toSpace)
    {
        let col = [
            fromSpace, 
            getNormalColorValue(color.c1.value, fromSpace, 0),
            getNormalColorValue(color.c2.value, fromSpace, 1),
            getNormalColorValue(color.c3.value, fromSpace, 2) ];

        col = getScaledDataColor(convertDataColorToSpace(col, toSpace));

        color.c1.value = col[1];
        color.c2.value = col[2];
        color.c3.value = col[3];
    }



    toValue()
    {
        return this.options.enabled
             ? this.value.copy()
             : ColorValue.NaN.copy();
    }



    isValid()
    {
        return (!this.input || this.input.isValid())
            && this.space && this.space.isValid()
            && this.c1    && this.c1   .isValid()
            && this.c2    && this.c2   .isValid()
            && this.c3    && this.c3   .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.space) this.space.pushValueUpdates(parse);
        if (this._c1  ) this._c1  .pushValueUpdates(parse);
        if (this._c2  ) this._c2  .pushValueUpdates(parse);
        if (this._c3  ) this._c3  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.space) this.space.invalidateInputs(parse, from, force);
        if (this._c1  ) this._c1  .invalidateInputs(parse, from, force);
        if (this._c2  ) this._c2  .invalidateInputs(parse, from, force);
        if (this._c3  ) this._c3  .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.space) this.space.iterateLoop(parse);
        if (this._c1  ) this._c1  .iterateLoop(parse);
        if (this._c2  ) this._c2  .iterateLoop(parse);
        if (this._c3  ) this._c3  .iterateLoop(parse);
    }
}


class GValidColor
extends GOperator1
{
    quality      = null;

    corrections  = [];



    constructor(nodeId, options)
    {
        super(VALID_COLOR, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.quality     = null;
        this.corrections = [];
    }



    copy()
    {
        const copy = new GValidColor(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.value  ) copy.value   = this.value  .copy();
        if (this.quality) copy.quality = this.quality.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const quality = this.quality ? (await this.quality.eval(parse)).toValue().toInteger() : null;


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            if (this.options.enabled)
            {
                if (isListType(input.type))
                {
                    this.value = new ListValue();

                    for (let i = 0; i < input.items.length; i++)
                        this.value.items.push(await getValidColorValue(parse, this, input.items[i], quality));
                }
                else
                    this.value = await getValidColorValue(parse, this, input, quality);
            }
            else
                this.value = input;
        }
        else
            this.value = ColorValue.NaN.copy();


        
        this.setUpdateValues(parse,
        [
            ['value',   this.value       ],
            ['type',    this.outputType()],
            ['quality', quality          ]
        ]);

        
        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.quality && this.quality.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.quality) this.quality.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.quality) this.quality.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.quality) this.quality.iterateLoop(parse);
    }
}



async function getValidColorValue(parse, node, input, quality)
{
    let rgb = input.toRgb();

    if (quality.value == 0) // clip sRGB
    {
        rgb[0] = Math.round(Math.min(Math.max(0, rgb[0]), 1) * 0xff);   
        rgb[1] = Math.round(Math.min(Math.max(0, rgb[1]), 1) * 0xff);   
        rgb[2] = Math.round(Math.min(Math.max(0, rgb[2]), 1) * 0xff); 
        
        return ColorValue.fromRgb(rgb);
    }
    else if (quality.value == 1) // clip chroma
    {
        rgb = clipChroma(rgb);

        rgb[0] = Math.round(rgb[0] * 0xff);
        rgb[1] = Math.round(rgb[1] * 0xff);
        rgb[2] = Math.round(rgb[2] * 0xff);

        return ColorValue.fromRgb(rgb);
    }
    else // find corrections
    {
        if (!rgbIsOk(rgb))
            genInitNodeProgress(node.nodeId);
        

        const inputColor = input.toDataColor();


        const
      [ closestOrder,
        closest1,
        closest2,
        closest3 ] = await findCorrection(
            parse,
            node.nodeId,
            inputColor,
            quality, null,  null,  null,
            false,   false, false, false);

            
        if (!parse.stopGenerate)
        {
            if (   closestOrder >= 0
                && closestOrder <  6)
            {
                node._color = correctColor(
                    inputColor,
                    closestOrder,
                    closest1,
                    closest2,
                    closest3);

                return ColorValue.fromDataColor(node._color);
            }
            else
            {
                return ColorValue.NaN.copy();
            }
        }
    }    


    return NullValue.copy();
}


class GCorrectColor
extends GOperator1
{
    _order  = null;
    _c1     = null;
    _c2     = null;
    _c3     = null;
    
    order   = null;
    c1      = null;
    c2      = null;
    c3      = null;

    corrections = [];



    constructor(nodeId, options)
    {
        super(CORRECT_COLOR, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this._order  = null;
        this._c1     = null;
        this._c2     = null;
        this._c3     = null;
        
        this.order   = null;
        this.c1      = null;
        this.c2      = null;
        this.c3      = null;
    
        this.corrections = [];
    }



    copy()
    {
        const copy = new GCorrectColor(this.nodeId, this.options);

        copy.copyBase(this);
        
        if (this._order) copy._order = this.order .copy();
        if (this._c1   ) copy._c1    = this._c1   .copy();
        if (this._c2   ) copy._c2    = this._c2   .copy();
        if (this._c3   ) copy._c3    = this._c3   .copy();
        
        if (this. order) copy. order = this.order .copy();
        if (this. c1   ) copy. c1    = this. c1   .copy();
        if (this. c2   ) copy. c2    = this. c2   .copy();
        if (this. c3   ) copy. c3    = this. c3   .copy();
        
        if (this.value ) copy. value = this. value.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const order = this._order ? (await this._order.eval(parse)).toValue().toInteger() : null;
        const c1    = this._c1    ? (await this._c1   .eval(parse)).toValue()             : null;
        const c2    = this._c2    ? (await this._c2   .eval(parse)).toValue()             : null;
        const c3    = this._c3    ? (await this._c3   .eval(parse)).toValue()             : null;

    
        if (order)
            order.value = Math.min(Math.max(0, order.value), 5);


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();


            if (this.options.enabled)
            {
                const rgb = input.toRgb();
                
                if (!rgbIsOk(rgb))
                    genInitNodeProgress(this.nodeId);


                const inputColor = input.toDataColor();


                const
              [ closestOrder,
                closest1,
                closest2,
                closest3 ] = await findCorrection(
                    parse,
                    this.nodeId,
                    inputColor, 
                    order, c1, c2, c3, 
                    this.order != null,
                    this.c1    != null, 
                    this.c2    != null, 
                    this.c3    != null); 

                    
                if (   !parse.stop()
                    && !parse.stopGenerate)
                {
                    if (   closestOrder >= 0 
                        && closestOrder <  6)
                    {
                        this._color = correctColor(
                            inputColor,
                            closestOrder,
                            closest1,
                            closest2,
                            closest3);

                            
                        this.order = new NumberValue(closestOrder);
                        this.c1    = new NumberValue(closest1);
                        this.c2    = new NumberValue(closest2);
                        this.c3    = new NumberValue(closest3);
                        

                        this.value = ColorValue.fromDataColor(this._color);

                        this.value.c1.decimals = input.c1.decimals;
                        this.value.c2.decimals = input.c2.decimals;
                        this.value.c3.decimals = input.c3.decimals;


                        this.setUpdateValues(parse,
                        [
                            ['order', new NumberValue(closestOrder)],
                            ['c1',    new NumberValue(closest1    )],
                            ['c2',    new NumberValue(closest2    )],
                            ['c3',    new NumberValue(closest3    )],
                            ['value', this.value                   ]
                        ]);
                    }
                }
                else
                {
                    this.order = NumberValue.NaN;
                    this.c1    = NumberValue.NaN;
                    this.c2    = NumberValue.NaN;
                    this.c3    = NumberValue.NaN;
                    this.value = input;
    
                    this.setUpdateValues(parse,
                    [
                        ['order', this.order],
                        ['c1',    this.c1   ],
                        ['c2',    this.c2   ],
                        ['c3',    this.c3   ],
                        ['value', this.value]
                    ]);
                }
            }
            else
            {
                this.order = NumberValue.NaN;
                this.c1    = NumberValue.NaN;
                this.c2    = NumberValue.NaN;
                this.c3    = NumberValue.NaN;
                this.value = input;

                this.setUpdateValues(parse,
                [
                    ['order', this.order],
                    ['c1',    this.c1   ],
                    ['c2',    this.c2   ],
                    ['c3',    this.c3   ],
                    ['value', this.value]
                ]);
            }
        }
        else
        {
            this.order = NumberValue.NaN;
            this.c1    = NumberValue.NaN;
            this.c2    = NumberValue.NaN;
            this.c3    = NumberValue.NaN;
            this.value = ColorValue .NaN;

            this.setUpdateValues(parse,
            [
                ['order', NumberValue.NaN],
                ['c1',    NumberValue.NaN],
                ['c2',    NumberValue.NaN],
                ['c3',    NumberValue.NaN],
                ['value', ColorValue .NaN]
            ]);
        }


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.order && this.order.isValid()
            && this.c1    && this.c1   .isValid()
            && this.c2    && this.c2   .isValid()
            && this.c3    && this.c3   .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this._order) this._order.pushValueUpdates(parse);
        if (this._c1   ) this._c1   .pushValueUpdates(parse);
        if (this._c2   ) this._c2   .pushValueUpdates(parse);
        if (this._c3   ) this._c3   .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this._order) this._order.invalidateInputs(parse, from, force);
        if (this._c1   ) this._c1   .invalidateInputs(parse, from, force);
        if (this._c2   ) this._c2   .invalidateInputs(parse, from, force);
        if (this._c3   ) this._c3   .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this._order) this._order.iterateLoop(parse);
        if (this._c1   ) this._c1   .iterateLoop(parse);
        if (this._c2   ) this._c2   .iterateLoop(parse);
        if (this._c3   ) this._c3   .iterateLoop(parse);
    }
}



class GColorContrast
extends GOperator2
{
    standard = null;
    contrast = null;


    constructor(nodeId, options)
    {
        super(COLOR_CONTRAST, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.standard = null;
        this.contrast = null;
    }



    copy()
    {
        const copy = new GColorContrast(this.nodeId, this.options);

        copy.copyBase(this);

        copy.standard = this.standard.copy();
        copy.contrast = this.contrast.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const standard = (await this.standard.eval(parse)).toValue().toInteger();

        
        if (standard.isValid())
            standard.value = Math.min(Math.max(0, standard.value), 1);


        if (   this.input0 
            && this.input1)
        {
            const input0 = (await this.input0.eval(parse)).toValue();
            const input1 = (await this.input1.eval(parse)).toValue();


            if (   input0.isValid()
                && input1.isValid())
            {
                if (   dataColorIsValid(input0.toDataColor())
                    && dataColorIsValid(input1.toDataColor()))
                {
                    if (standard.value == 0)
                    {
                        const value = getContrastRatio2(input0.toRgb(), input1.toRgb());
                        this.contrast = new NumberValue(value, 2);
                    }
                    else
                    {
                        const value = getContrastRatio3(input0.toRgb(), input1.toRgb());
                        this.contrast = new NumberValue(value, 1);
                    }
                }
                else
                    this.contrast = NumberValue.NaN.copy();
            }
            else
                this.contrast = NumberValue.NaN.copy();


            this.value = 
                input0 
                ? input0//.copy() 
                : ColorValue.NaN.copy();


            this.setUpdateValues(parse,
            [
                ['text', input0],
                ['back', input1]
            ]);
        }

        else if (this.input0) 
        {
            const input0 = (await this.input0.eval(parse)).toValue();

            this.setUpdateValues(parse,
            [
                ['text', input0.isValid() ? input0 : ColorValue.NaN],
                ['back', ColorValue.NaN                            ]
            ]);
            
            this.value    = input0;//.copy();
            this.contrast = NumberValue.NaN.copy();
        }

        else if (this.input1) 
        {
            const input1 = (await this.input1.eval(parse)).toValue();

            this.setUpdateValues(parse,
            [
                ['text', ColorValue.NaN                            ],
                ['back', input1.isValid() ? input1 : ColorValue.NaN]
            ]);

            this.value    = ColorValue.NaN.copy();
            this.contrast = NumberValue.NaN.copy();
        }

        else
        {
            this.value    = ColorValue.NaN.copy();
            this.contrast = NumberValue.NaN.copy();

            this.setUpdateValues(parse,
            [
                ['text', ColorValue.NaN],
                ['back', ColorValue.NaN]
            ]);
        }
        


        this.setUpdateValues(parse,
        [
            ['standard', standard     ],
            ['contrast', this.contrast]
        ],
        true);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.standard && this.standard.isValid()
            && (!this.contrast || this.contrast.isValid());
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.standard) this.standard.pushValueUpdates(parse);
        if (this.contrast) this.contrast.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.standard) this.standard.invalidateInputs(parse, from, force);
        if (this.contrast) this.contrast.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.standard) this.standard.iterateLoop(parse);
        if (this.contrast) this.contrast.iterateLoop(parse);
    }
}



class GConvertP3
extends GOperator1
{
    from = null;



    constructor(nodeId, options)
    {
        super(COLOR_CONVERT_P3, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.from = null;
    }



    copy()
    {
        const copy = new GConvertP3(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.value) copy.value = this.value.copy();
        if (this.from ) copy.from  = this.from .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const from = this.from ? (await this.from.eval(parse)).toValue().toInteger() : null;


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            if (this.options.enabled)
            {
                if (isListType(input.type))
                {
                    this.value = new ListValue();

                    for (let i = 0; i < input.items.length; i++)
                        this.value.items.push(await getConvertP3Value(input.items[i], from));
                }
                else
                    this.value = await getConvertP3Value(input, from);
            }
            else
                this.value = input;
        }
        else
            this.value = ColorValue.NaN.copy();


        
        this.setUpdateValues(parse,
        [
            ['value',   this.value       ],
            ['type',    this.outputType()],
            ['quality', from             ]
        ]);

        
        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.from && this.from.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.from) this.from.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.from) this.from.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.from) this.from.iterateLoop(parse);
    }
}



function getConvertP3Value(input, from)
{
    return ColorValue.fromRgb(
        from.value == 0
        ? scaleRgb(srgb2p3(input.toRgb()))
        : scaleRgb(p32srgb(input.toRgb())));
}


class GColorBlind
extends GOperator1
{
    l;
    m;
    s;


    constructor(nodeId, options)
    {
        super(COLORBLIND, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.l = null;
        this.m = null;
        this.s = null;
    }



    copy()
    {
        const copy = new GColorBlind(this.nodeId, this.options);

        copy.copyBase(this);

        copy.l = this.l.copy();
        copy.m = this.m.copy();
        copy.s = this.s.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const l = (await this.l.eval(parse)).toValue();        
        const m = (await this.m.eval(parse)).toValue();
        const s = (await this.s.eval(parse)).toValue();


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();


            if (this.options.enabled)
            {
                if (isListType(input.type))
                {
                    this.value = new ListValue();

                    for (let i = 0; i < input.items.length; i++)
                        this.value.items.push(getColorBlindValue(input.items[i], l, m, s));
                }
                else
                    this.value = getColorBlindValue(input, l, m, s);
            }
            else
                this.value = input;
        }
        else
            this.value = ColorValue.NaN.copy();


        this.setUpdateValues(parse,
        [
            ['value',  this.value       ],
            ['type',   this.outputType()],
            ['l',      l                ],
            ['m',      m                ],
            ['s',      s                ]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.l && this.l.isValid()
            && this.m && this.m.isValid()
            && this.s && this.s.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.l) this.l.pushValueUpdates(parse);
        if (this.m) this.m.pushValueUpdates(parse);
        if (this.s) this.s.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.l) this.l.invalidateInputs(parse, from, force);
        if (this.m) this.m.invalidateInputs(parse, from, force);
        if (this.s) this.s.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.l) this.l.iterateLoop(parse);
        if (this.m) this.m.iterateLoop(parse);
        if (this.s) this.s.iterateLoop(parse);
    }
}



function getColorBlindValue(input, l, m, s)
{
    const rgb   = input.toRgb();

    const rgbCb = rgb2colorblind(
        rgb,
        l.value / 2,
        m.value / 2,
        s.value / 2);

    if (   !rgbIsNaN(rgb  )
        && !rgbIsNaN(rgbCb))
    {
        const validRgbCb = rgbCb;
    
        const validCol = convertDataColorToSpace(
            rgb2dataColor(validRgbCb), 
            colorSpace(input.space.value));

        return ColorValue.fromDataColor(validCol);
    }
    else
        return ColorValue.NaN.copy();
}


class GColorInterpolate
extends GOperator2
{
    space;
    amount;
    gamma;


    constructor(nodeId, options)
    {
        super(COLOR_INTERPOLATE, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.space  = null;
        this.amount = null;
        this.gamma  = null;
    }



    copy()
    {
        const copy = new GColorInterpolate(this.nodeId, this.options);

        copy.copyBase(this);

        copy.space  = this.space .copy();
        copy.amount = this.amount.copy();
        copy.gamma  = this.gamma .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const space  = (await this.space .eval(parse)).toValue().toInteger();
        const amount = (await this.amount.eval(parse)).toValue();
        const gamma  = (await this.gamma .eval(parse)).toValue();


        if (   this.input0 
            && this.input1)
        {
            const input0 = (await this.input0.eval(parse)).toValue();
            const input1 = (await this.input1.eval(parse)).toValue();

            consoleAssert(
                amount.type == NUMBER_VALUE, 
                'this.result.type must be NUMBER_VALUE');

            const f = amount.value / 100;


            const spaceIndex = Math.min(Math.max(0, space.value), colorSpaceCount()-1);
            const gammaValue = Math.max(0.0001, gamma.value);

            const _space = colorSpace(spaceIndex);

            const _color = this.interpolate(
                spaceIndex,
                convertDataColorToSpace(input0.toDataColor(), _space),
                convertDataColorToSpace(input1.toDataColor(), _space),
                f,
                gammaValue);


            // allow interpolating invalid colors,
            // so no valid color check here

            this.value = ColorValue.fromDataColor(_color, spaceIndex);
        }

        else if (this.input0) 
            this.value = (await this.input0.eval(parse)).toValue();

        else if (this.input1) 
            this.value = (await this.input1.eval(parse)).toValue();
            
        else 
            this.value = ColorValue.NaN.copy();


        this.setUpdateValues(parse,
        [
            ['space',  space     ],
            ['amount', amount    ],
            ['gamma',  gamma     ],
            ['value',  this.value]
        ]);
        

        this.validate();
        
        return this;
    }



    interpolate(space, col0, col1, f, gamma)
    {
        if (   space <= 1
            || space >  6) // hex, rgb, okLab, lab, luv
        {
            gamma = Math.max(0.01, gamma);

            const r0 = Math.sign(col0[1]) * Math.pow(Math.abs(col0[1]), gamma);  
            const g0 = Math.sign(col0[2]) * Math.pow(Math.abs(col0[2]), gamma);  
            const b0 = Math.sign(col0[3]) * Math.pow(Math.abs(col0[3]), gamma);  

            const r1 = Math.sign(col1[1]) * Math.pow(Math.abs(col1[1]), gamma);
            const g1 = Math.sign(col1[2]) * Math.pow(Math.abs(col1[2]), gamma);
            const b1 = Math.sign(col1[3]) * Math.pow(Math.abs(col1[3]), gamma);

            const r = lerp(r0, r1, f);        
            const g = lerp(g0, g1, f);            
            const b = lerp(b0, b1, f);        

            return [
                colorSpace(space),
                Math.sign(r) * Math.pow(Math.abs(r), 1/gamma),
                Math.sign(g) * Math.pow(Math.abs(g), 1/gamma),
                Math.sign(b) * Math.pow(Math.abs(b), 1/gamma) ];
        }
        else // hsv/hsl/hcl
        {
            const h0 = col0[1] * Tau;  const h1 = col1[1] * Tau;
            const c0 = col0[2];        const c1 = col1[2];
            const l0 = col0[3];        const l1 = col1[3];

            return [
                colorSpace(space),
                normalAngle(h0 + angleDiff(h0, h1) * f) / Tau,
                lerp(c0, c1, f),
                lerp(l0, l1, f) ];
        }
    }



    isValid()
    {
        return super.isValid()
            && this.space  && this.space .isValid()
            && this.amount && this.amount.isValid()
            && this.gamma  && this.gamma .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.space ) this.space .pushValueUpdates(parse);
        if (this.amount) this.amount.pushValueUpdates(parse);
        if (this.gamma ) this.gamma .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.space ) this.space .invalidateInputs(parse, from, force);
        if (this.amount) this.amount.invalidateInputs(parse, from, force);
        if (this.gamma ) this.gamma .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.space ) this.space .iterateLoop(parse);
        if (this.amount) this.amount.iterateLoop(parse);
        if (this.gamma ) this.gamma .iterateLoop(parse);
    }
}



class GColorBlend
extends GOperator2
{
    mode    = null;
    opacity = null;
    

    constructor(nodeId, options)
    {
        super(COLOR_BLEND, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.mode    = null;
        this.opacity = null;
    }



    copy()
    {
        const copy = new GColorBlend(this.nodeId, this.options);

        copy.copyBase(this);

        copy.mode    = this.mode   .copy();
        copy.opacity = this.opacity.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const mode    = (await this.mode   .eval(parse)).toValue().toInteger();
        const opacity = (await this.opacity.eval(parse)).toValue();


        if (   this.input0 
            && this.input1)
        {
            const input0 = (await this.input0.eval(parse)).toValue();
            const input1 = (await this.input1.eval(parse)).toValue();

            consoleAssert(
                opacity.type == NUMBER_VALUE, 
                'this.result.type must be NUMBER_VALUE');

            const _opacity = opacity.value / 100;

            const modeIndex = Math.min(Math.max(0, mode.value), BlendModes.length-1);


            const col = this.blend(
                modeIndex,
                input0.toRgb(),
                input1.toRgb(),
                _opacity);

            this.value = ColorValue.fromRgb(scaleRgb(col));
        }

        else if (this.input0) 
            this.value = (await this.input0.eval(parse)).toValue();

        else if (this.input1) 
            this.value = (await this.input1.eval(parse)).toValue();
            
        else 
            this.value = ColorValue.NaN.copy();


        this.setUpdateValues(parse,
        [
            ['value',   this.value],
            ['mode',    mode      ],
            ['opacity', opacity   ]
        ]);


        this.validate();
        
        return this;
    }



    blend(mode, col0, col1, opacity)
    {
        switch (mode)
        {
            case  0: return blendNormal    (col0, col1, opacity);

            case  1: return blendDarken    (col0, col1, opacity);
            case  2: return blendMultiply  (col0, col1, opacity);
            case  3: return blendColorBurn (col0, col1, opacity);

            case  4: return blendLighten   (col0, col1, opacity);
            case  5: return blendScreen    (col0, col1, opacity);
            case  6: return blendColorDodge(col0, col1, opacity);

            case  7: return blendOverlay   (col0, col1, opacity);
            case  8: return blendSoftLight (col0, col1, opacity);
            case  9: return blendHardLight (col0, col1, opacity);

            case 10: return blendDifference(col0, col1, opacity);
            case 11: return blendExclusion (col0, col1, opacity);

            case 12: return blendHue       (col0, col1, opacity);
            case 13: return blendSaturation(col0, col1, opacity);
            case 14: return blendColor     (col0, col1, opacity);
            case 15: return blendLuminosity(col0, col1, opacity);
        }
    }



    isValid()
    {
        return super.isValid()
            && this.mode    && this.mode   .isValid()
            && this.opacity && this.opacity.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.mode   ) this.mode   .pushValueUpdates(parse);
        if (this.opacity) this.opacity.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.mode   ) this.mode   .invalidateInputs(parse, from, force);
        if (this.opacity) this.opacity.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.mode   ) this.mode   .iterateLoop(parse);
        if (this.opacity) this.opacity.iterateLoop(parse);
    }
}



function blendNormal(col, back, opacity)
{
    return [ col[0] * opacity + back[0] * (1 - opacity),
             col[1] * opacity + back[1] * (1 - opacity),
             col[2] * opacity + back[2] * (1 - opacity) ];
}



function blendDarken(col, back, opacity)
{
    return blendNormal(
        [ Math.min(back[0], col[0]),
          Math.min(back[1], col[1]),
          Math.min(back[2], col[2]) ],
        back,
        opacity);
}



function chanMultiply(c, b)
{
    return c * b;
}



function blendMultiply(col, back, opacity)
{
    return blendNormal(
        [ chanMultiply(col[0], back[0]),
          chanMultiply(col[1], back[1]),
          chanMultiply(col[2], back[2]) ],
        back,
        opacity);
}



function chanColorBurn(c, b)
{
         if (b == 1) return 1;
    else if (c == 0) return 0;
    else             return 1 - Math.min((1 - b) / c, 1);
}



function blendColorBurn(col, back, opacity)
{
    return blendNormal(
         [ chanColorBurn(col[0], back[0]),
           chanColorBurn(col[1], back[1]),
           chanColorBurn(col[2], back[2]) ],
        back,
        opacity);
}



function blendLighten(col, back, opacity)
{
    return blendNormal(
        [ Math.max(back[0], col[0]),
          Math.max(back[1], col[1]),
          Math.max(back[2], col[2]) ],
        back,
        opacity);
}



function chanScreen(c, b)
{
    return b + c - b*c;
}



function blendScreen(col, back, opacity)
{
    return blendNormal(
        [ chanScreen(col[0], back[0]),
          chanScreen(col[1], back[1]),
          chanScreen(col[2], back[2]) ],
        back,
        opacity);
}



function chanColorDodge(c, b)
{
         if (b == 0) return 0;
    else if (c == 1) return 1;
    else             return Math.min(b / (1 - c), 1);
}



function blendColorDodge(col, back, opacity)
{
    return blendNormal(
        [ chanColorDodge(col[0], back[0]),
          chanColorDodge(col[1], back[1]),
          chanColorDodge(col[2], back[2]) ],
        back,
        opacity);
}



function blendOverlay(col, back, opacity)
{
    return blendNormal(
        [ chanHardLight(back[0], col[0]),
          chanHardLight(back[1], col[1]),
          chanHardLight(back[2], col[2]) ],
        back,
        opacity);
}



function bSL_D(b)
{
    return b <= 0.25
         ? ((16 * b - 12) * b + 4) * b
         : Math.sqrt(b);
}



function chanSoftLight(c, b)
{
    return c <= 0.5
         ? b - (1 - 2*c) * b * (1 - b)
         : b + (2*c - 1) * (bSL_D(b) - b);
}



function blendSoftLight(col, back, opacity)
{
    return blendNormal(
        [ chanSoftLight(col[0], back[0]),
          chanSoftLight(col[1], back[1]),
          chanSoftLight(col[2], back[2]) ],
        back,
        opacity);
}



function chanHardLight(c, b)
{
    if (c <= 0.5) return chanMultiply(b, 2 * c);
    else          return chanScreen(b, 2 * c - 1);
}



function blendHardLight(col, back, opacity)
{
    return blendNormal(
        [ chanHardLight(col[0], back[0]),
          chanHardLight(col[1], back[1]),
          chanHardLight(col[2], back[2]) ],
        back,
        opacity);
}



function blendDifference(col, back, opacity)
{
    return [ Math.abs(back[0] - col[0]),
             Math.abs(back[1] - col[1]),
             Math.abs(back[2] - col[2]) ];
}



function chanExclusion(c, b)
{
    return b + c - 2*b*c;
}



function blendExclusion(col, back, opacity)
{
    return blendNormal(
        [ chanExclusion(col[0], back[0]),
          chanExclusion(col[1], back[1]),
          chanExclusion(col[2], back[2]) ],
        back,
        opacity);
}



function bl_lum(col)
{
    return col[0] * 0.30
         + col[1] * 0.59
         + col[2] * 0.11;
}



function bl_setLum(_col, l)
{
    const col = [..._col];

    const d = l - bl_lum(col);

    col[0] += d;
    col[1] += d;
    col[2] += d;

    return bl_clamp(col);
}



function bl_sat(col)
{
    return Math.max(col[0], col[1], col[2]) 
         - Math.min(col[0], col[1], col[2]);
}



function bl_min(col)
{
         if (col[0] <= col[1] 
          && col[0] <= col[2]) return 0;
    else if (col[1] <= col[1] 
          && col[1] <= col[2]) return 1;
    else                       return 2;
}



function bl_mid(col)
{
         if (   col[0] >= col[1] 
             && col[0] <= col[2]
          ||    col[0] <= col[1] 
             && col[0] >= col[2]) return 0;
    else if (   col[1] >= col[0] 
             && col[1] <= col[2]
          ||    col[1] <= col[0] 
             && col[1] >= col[2]) return 1;
    else                          return 2;
}



function bl_max(col)
{
         if (col[0] >= col[1] 
          && col[0] >= col[2]) return 0;
    else if (col[1] >= col[1] 
          && col[1] >= col[2]) return 1;
    else                       return 2;
}



function bl_ndx(col) // get min/mid/max chan indices
{
    if (   col[0] == col[1] 
        && col[0] == col[2])
        return [0, 1, 2];

    else 
        return [
            bl_min(col), 
            bl_mid(col), 
            bl_max(col)];
}



function bl_setSat(_col, s)
{
    const col       = [..._col];
    const [n, d, x] = bl_ndx(col);

    if (col[x] > col[n])
    {
        col[d] = (((col[d] - col[n]) * s) / (col[x] - col[n]));
        col[x] = s;
    }
    else
        col[d] = col[x] = 0;

    col[n] = 0;

    return col;
}



function bl_chanClamp(c, l, n, x)
{
         if (n < 0) return l + (((c - l) * l) / (l - n));
    else if (x > 1) return l + (((c - l) * (1 - l)) / (x - l));
    else            return c;
}



function bl_clamp(col)
{
    const l   = bl_lum(col);

    const n = Math.min(col[0], col[1], col[2]);
    const x = Math.max(col[0], col[1], col[2]);

    return [ bl_chanClamp(col[0], l, n, x),
             bl_chanClamp(col[1], l, n, x),
             bl_chanClamp(col[2], l, n, x) ];
}



function blendHue(col, back, opacity)
{
    return blendNormal(
        bl_setLum(bl_setSat(col, bl_sat(back)), bl_lum(back)),
        back,
        opacity);
}



function blendSaturation(col, back, opacity)
{
    return blendNormal(
        bl_setLum(bl_setSat(back, bl_sat(col)), bl_lum(back)),
        back,
        opacity);
}



function blendColor(col, back, opacity)
{
    return blendNormal(
        bl_setLum(col, bl_lum(back)),
        back,
        opacity);
}



function blendLuminosity(col, back, opacity)
{
    return blendNormal(
        bl_setLum(back, bl_lum(col)),
        back,
        opacity);
}


class GColorStyle
extends GOperator
{
    id;

    colorStyle;
    genValue;

    //existing;
    linked;



    constructor(nodeId, options, styleId)
    {
        super(COLOR_STYLE, nodeId, options);

        this.id == styleId;
    }



    copy()
    {
        const copy = new GColorStyle(this.nodeId, this.options);

        copy.id         = this.id;
        copy.colorStyle = this.colorStyle.copy();
        copy.genValue   = this.genValue  .copy();
        
        //copy.existing   = this.existing;
        copy.linked     = this.linked;

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        this.value = (await this.genValue.eval(parse)).toValue();


        if (   this.value.isValid()
            && this.linked)
            // (  !this.existing
            //     || this.linked))
        {
            if (this.value.type == COLOR_VALUE)
                this.value = FillValue.fromRgb(scaleRgb(this.value.toRgb()), 0xff);

            const rgba       = this.value.toRgba();
            const rgbaStripe = rgb_a(getStripeBackColor(rgba), rgba[3]);

            this.evalStyle({rgba: rgbaStripe});
        }
        else
            this.value = FillValue.NaN;


        this.setUpdateValues(parse,
        [
            ['value', this.value]
        ]);


        this.validate();

        return this;
    }



    evalStyle(options = {})
    {
        if (!this.options.enabled)
            return;

            
        const colorStyle = new FigmaColorStyle(this.nodeId, this.id, this.name);

        //colorStyle.existing = this.existing;


        colorStyle.paints = 
        [
            [ 'SOLID', 
                      Math.round(options.rgba[0] * 0xff)
              + ' ' + Math.round(options.rgba[1] * 0xff)
              + ' ' + Math.round(options.rgba[2] * 0xff)
              + ' ' + Math.round(options.rgba[3] * 100 ) ]
        ];


        this.colorStyle = colorStyle;
    }



    isValid()
    {
        return this.genValue && this.genValue.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.genValue) this.genValue.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.genValue) this.genValue.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.genValue) this.genValue.iterateLoop(parse);
    }
}


class GFill
extends GOperator1
{
    color   = null;
    opacity = null;
    blend   = null;



    constructor(nodeId, options)
    {
        super(FILL, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.color   = null;
        this.opacity = null;
        this.blend   = null;
    }



    copy()
    {
        const copy = new GFill(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.color  ) copy.color   = this.color  .copy();
        if (this.opacity) copy.opacity = this.opacity.copy();
        if (this.blend  ) copy.blend   = this.blend  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        let color   = this.color   ? (await this.color  .eval(parse)).toValue() : null;
        let opacity = this.opacity ? (await this.opacity.eval(parse)).toValue() : null;
        let blend   = this.blend   ? (await this.blend  .eval(parse)).toValue() : null;


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            this.value = new FillValue(
                color   ?? input.color,
                opacity ?? input.opacity,
                blend   ?? input.blend);
        }
        else
        {
            this.value = new FillValue(
                color, 
                opacity,
                blend);
        }


        this.setUpdateValues(parse,
        [
            ['value',   this.value],
            ['color',   color     ],
            ['opacity', opacity   ],
            ['blend',   blend     ]
        ]);
        

        if (!this.color  ) this.color   = this.value.color  .copy();
        if (!this.opacity) this.opacity = this.value.opacity.copy();
        if (!this.blend  ) this.blend   = this.value.blend  .copy();


        this.validate();

        return this;
    }



    toValue()
    {
        return this.options.enabled
            ? new FillValue(
                this.color   ? this.color  .toValue() : this.input.value.color  .toValue(),
                this.opacity ? this.opacity.toValue() : this.input.value.opacity.toValue(),
                this.blend   ? this.blend  .toValue() : this.input.value.blend  .toValue())
            : FillValue.NaN;
    }



    isValid()
    {
        return (!this.input || this.input.isValid())
            && this.color   && this.color  .isValid()
            && this.opacity && this.opacity.isValid()
            && this.blend   && this.blend  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.color  ) this.color  .pushValueUpdates(parse);
        if (this.opacity) this.opacity.pushValueUpdates(parse);
        if (this.blend  ) this.blend  .pushValueUpdates(parse);
    }
    
    
    
    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.color  ) this.color  .invalidateInputs(parse, from, force);
        if (this.opacity) this.opacity.invalidateInputs(parse, from, force);
        if (this.blend  ) this.blend  .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.color  ) this.color  .iterateLoop(parse);
        if (this.opacity) this.opacity.iterateLoop(parse);
        if (this.blend  ) this.blend  .iterateLoop(parse);
    }
}


class GColorStop
extends GOperator1
{
    fill     = null;
    position = null;



    constructor(nodeId, options)
    {
        super(COLOR_STOP, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.fill     = null;
        this.position = null;
    }



    copy()
    {
        const copy = new GColorStop(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.fill    ) copy.fill     = this.fill    .copy();
        if (this.position) copy.position = this.position.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        let fill = this.fill ? (await this.fill.eval(parse)).toValue() : null;

        fill = this.validateFill(fill);


        const position = this.position ? (await this.position.eval(parse)).toValue() : null;


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            this.value = new ColorStopValue(
                fill     ?? input.fill,
                position ?? input.position);
        }
        else
        {
            this.value = new ColorStopValue(
                fill, 
                position);
        }


        this.setUpdateValues(parse, 
        [
            ['value', this.value]
        ]);
        

        if (!this.fill    ) this.fill     = this.value.fill    .copy();
        if (!this.position) this.position = this.value.position.copy();


        this.validate();

        return this;
    }



    validateFill(fill)
    {
        if (!fill)
            return null;


        if (fill.type == COLOR_VALUE)
            return FillValue.fromRgb(scaleRgb(fill.toRgb()), 100);
        else
            return fill;
    }



    toValue()
    {
        return new ColorStopValue(
            this.options.enabled
            ? this.validateFill(this.fill ? this.fill.toValue() : this.input.fill.toValue())
            : FillValue.NaN,
            this.position ? this.position.toValue() : this.input.position.toValue());
    }                 



    isValid()
    {
        return (!this.input || this.input.isValid())
            && this.fill     && this.fill    .isValid()
            && this.position && this.position.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.fill    ) this.fill    .pushValueUpdates(parse);
        if (this.position) this.position.pushValueUpdates(parse);
    }    

    
    
    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.fill    ) this.fill    .invalidateInputs(parse, from, force);
        if (this.position) this.position.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.fill    ) this.fill    .iterateLoop(parse);
        if (this.position) this.position.iterateLoop(parse);
    }
}


class GGradient
extends GOperator
{
    inputs = [];

    gradType = null;
    x        = null;
    y        = null;
    size     = null;
    angle    = null;
    aspect   = null;
    skew     = null;
    blend    = null;
    
    
    
    constructor(nodeId, options)
    {
        super(GRADIENT, nodeId, options);
    }
    
    
    
    reset()
    {
        super.reset();
        
        this.inputs = [];
    
        this.gradType = null;
        this.x        = null;
        this.y        = null;
        this.size     = null;
        this.angle    = null;
        this.aspect   = null;
        this.skew     = null;
        this.blend    = null;
    }



    copy()
    {
        const copy = new GGradient(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        if (this.gradType) copy.gradType = this.x     .copy();
        if (this.x       ) copy.x        = this.x     .copy();
        if (this.y       ) copy.y        = this.y     .copy();
        if (this.size    ) copy.size     = this.size  .copy();
        if (this.angle   ) copy.angle    = this.angle .copy();
        if (this.aspect  ) copy.aspect   = this.aspect.copy();
        if (this.skew    ) copy.skew     = this.skew  .copy();
        if (this.blend   ) copy.blend    = this.blend .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        const gradType = this.gradType ? (await this.gradType.eval(parse)).toValue() : null;
        const x        = this.x        ? (await this.x       .eval(parse)).toValue() : null;
        const y        = this.y        ? (await this.y       .eval(parse)).toValue() : null;
        const size     = this.size     ? (await this.size    .eval(parse)).toValue() : null;
        const angle    = this.angle    ? (await this.angle   .eval(parse)).toValue() : null;
        const aspect   = this.aspect   ? (await this.aspect  .eval(parse)).toValue() : null;
        const skew     = this.skew     ? (await this.skew    .eval(parse)).toValue() : null;
        const blend    = this.blend    ? (await this.blend   .eval(parse)).toValue() : null;


        const stops = new ListValue();

        for (let i = 0, o = 0; i < this.inputs.length; i++)
        {
            const input = (await this.inputs[i].eval(parse)).toValue();


            if (   input
                && this.options.enabled)
            {
                if (isListType(input.type))
                {
                    for (const item of input.items)
                        stops.items.push(item);
                }
                else
                    stops.items.push(input);
            }
        }


        this.value = new GradientValue(
            stops,
            gradType,
            x, 
            y, 
            size, 
            angle, 
            aspect,
            skew,
            blend);

            
        this.setUpdateValues(parse,
        [
            ['value', this.value]
        ]);
        

        if (!this.gradType) this.gradType = this.value.gradType.copy();
        if (!this.x       ) this.x        = this.value.x       .copy();
        if (!this.y       ) this.y        = this.value.y       .copy();
        if (!this.size    ) this.size     = this.value.size    .copy();
        if (!this.angle   ) this.angle    = this.value.angle   .copy();
        if (!this.aspect  ) this.aspect   = this.value.aspect  .copy();
        if (!this.skew    ) this.skew     = this.value.skew    .copy();
        if (!this.blend   ) this.blend    = this.value.blend   .copy();


        this.validate();

        return this;
    }

    
    
    toValue()
    {
        const stops = new ListValue();

        for (let i = 0, o = 0; i < this.inputs.length; i++)
            stops.items.push(this.inputs[i].toValue());


        return new GradientValue(
            stops,
            this.gradType ? this.gradType.toValue() : this.input.gradType.toValue(),
            this.x        ? this.x       .toValue() : this.input.x       .toValue(),
            this.y        ? this.y       .toValue() : this.input.y       .toValue(),
            this.size     ? this.size    .toValue() : this.input.size    .toValue(),
            this.angle    ? this.angle   .toValue() : this.input.angle   .toValue(),
            this.aspect   ? this.aspect  .toValue() : this.input.aspect  .toValue(),
            this.skew     ? this.skew    .toValue() : this.input.skew    .toValue(),
            this.blend    ? this.blend   .toValue() : this.input.blend   .toValue());
    }                 



    isValid()
    {
        return !this.inputs.find(i => !i.isValid())
            && this.gradType && this.gradType.isValid()
            && this.x        && this.x       .isValid()
            && this.y        && this.y       .isValid()
            && this.size     && this.size    .isValid()
            && this.angle    && this.angle   .isValid()
            && this.aspect   && this.aspect  .isValid()
            && this.skew     && this.skew    .isValid()
            && this.blend    && this.blend   .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse));

        if (this.gradType) this.gradType.pushValueUpdates(parse);
        if (this.x       ) this.x       .pushValueUpdates(parse);
        if (this.y       ) this.y       .pushValueUpdates(parse);
        if (this.size    ) this.size    .pushValueUpdates(parse);
        if (this.angle   ) this.angle   .pushValueUpdates(parse);
        if (this.aspect  ) this.aspect  .pushValueUpdates(parse);
        if (this.skew    ) this.skew    .pushValueUpdates(parse);
        if (this.blend   ) this.blend   .pushValueUpdates(parse);
    }    



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        this.inputs.forEach(i => i.invalidateInputs(parse, from, force));
        
        if (this.gradType) this.gradType.invalidateInputs(parse, from, force);
        if (this.x       ) this.x       .invalidateInputs(parse, from, force);
        if (this.y       ) this.y       .invalidateInputs(parse, from, force);
        if (this.size    ) this.size    .invalidateInputs(parse, from, force);
        if (this.angle   ) this.angle   .invalidateInputs(parse, from, force);
        if (this.aspect  ) this.aspect  .invalidateInputs(parse, from, force);
        if (this.skew    ) this.skew    .invalidateInputs(parse, from, force);
        if (this.blend   ) this.blend   .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        this.inputs.forEach(i => i.iterateLoop(parse));

        if (this.gradType) this.gradType.iterateLoop(parse);
        if (this.x       ) this.x       .iterateLoop(parse);
        if (this.y       ) this.y       .iterateLoop(parse);
        if (this.size    ) this.size    .iterateLoop(parse);
        if (this.angle   ) this.angle   .iterateLoop(parse);
        if (this.aspect  ) this.aspect  .iterateLoop(parse);
        if (this.skew    ) this.skew    .iterateLoop(parse);
        if (this.blend   ) this.blend   .iterateLoop(parse);
    }    
}


class GStroke
extends GOperator1
{
    fills  = null;
   _fills  = null; // actual fills that might need to be converted to a list, in case it's a color or a fill
    weight = null;
    fit    = null;
    join   = null;
    miter  = null;
    cap    = null;
    dashes = null;
    
    

    constructor(nodeId, options)
    {
        super(STROKE, nodeId, options);
    }
    

    
    reset()
    {
        super.reset();
        
        this. fills  = null;
        this._fills  = null; // actual fills that might need to be converted to a list, in case it's a color or a fill
        this. weight = null;
        this. fit    = null;
        this. join   = null;
        this. miter  = null;
        this. cap    = null;
        this. dashes = null;
    }



    copy()
    {
        const copy = new GStroke(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.fills ) copy.fills  = this.fills .copy();
        if (this._fills) copy._fills = this._fills.copy();
        if (this.weight) copy.weight = this.weight.copy();
        if (this.fit   ) copy.fit    = this.fit   .copy();
        if (this.join  ) copy.join   = this.join  .copy();
        if (this.miter ) copy.miter  = this.miter .copy();
        if (this.cap   ) copy.cap    = this.cap   .copy();
        if (this.dashes) copy.dashes = this.dashes.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        let fills = this._fills ? (await this._fills.eval(parse)).toValue() : null;

        fills = this.validateFills(fills);

        if (!isListType(this._fills.type))
            this.fills = fills;


        const weight = this.weight ? (await this.weight.eval(parse)).toValue() : null;
        const fit    = this.fit    ? (await this.fit   .eval(parse)).toValue() : null;
        const join   = this.join   ? (await this.join  .eval(parse)).toValue() : null;
        const miter  = this.miter  ? (await this.miter .eval(parse)).toValue() : null;
        const cap    = this.cap    ? (await this.cap   .eval(parse)).toValue() : null;
        const dashes = this.dashes ? (await this.dashes.eval(parse)).toValue() : null;


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            this.value = new StrokeValue(
                fills  ?? input.fills,
                weight ?? input.weight,
                fit    ?? input.fit,
                join   ?? input.join,
                miter  ?? input.miter,
                cap    ?? input.cap,
                dashes ?? input.dashes);
        }
        else
        {
            this.value = new StrokeValue(
                fills, 
                weight, 
                fit, 
                join,
                miter,
                cap,
                dashes);
        }


        if (!this.fills ) this.fills  = this.value.fills .copy();
        if (!this.weight) this.weight = this.value.weight.copy();
        if (!this.fit   ) this.fit    = this.value.fit   .copy();
        if (!this.join  ) this.join   = this.value.join  .copy();
        if (!this.miter ) this.miter  = this.value.miter .copy();
        if (!this.cap   ) this.cap    = this.value.cap   .copy();
        if (!this.dashes) this.dashes = this.value.dashes.copy();


        // if (this.nodeId == 'stroke')
        //     console.log('this.value =', this.value);


        this.setUpdateValues(parse,
        [
            ['value',  this.value],
            ['fills',  fills     ],
            ['weight', weight    ],
            ['fit',    fit       ],
            ['join',   join      ],
            ['miter',  miter     ],
            ['cap',    cap       ],
            ['dashes', dashes    ]
        ]);


        this.validate();

        return this;
    }



    validateFills(fills)
    {            
        if (!fills)
            return null;

        if (fills.type == COLOR_VALUE)
            return new ListValue([FillValue.fromRgb(scaleRgb(fills.toRgb()), 100)]);

        else if (fills.type ==     FILL_VALUE
              || fills.type == GRADIENT_VALUE)
            return new ListValue([fills]);
        else
        {
            consoleAssert(fills.type == LIST_VALUE, 'stroke.fills must be a LIST_VALUE');
            return fills;
        }
    }



    toValue()
    {
        return new StrokeValue(
            this.options.enabled
            ? this.validateFills(this.fills ? this.fills.toValue() : this.input.fills.toValue())
            : new ListValue(),
            this.weight ? this.weight.toValue() : this.input.weight.toValue(),
            this.fit    ? this.fit   .toValue() : this.input.fit   .toValue(),
            this.join   ? this.join  .toValue() : this.input.join  .toValue(),
            this.miter  ? this.miter .toValue() : this.input.miter .toValue(),
            this.cap    ? this.cap   .toValue() : this.input.cap   .toValue(),
            this.dashes ? this.dashes.toValue() : this.input.dashes.toValue());
    }                 



    isValid()
    {
        return (!this.input || this.input.isValid())
            && this.fills  && this.fills .isValid()
            && this.weight && this.weight.isValid()
            && this.fit    && this.fit   .isValid()
            && this.join   && this.join  .isValid()
            && this.miter  && this.miter .isValid()
            && this.cap    && this.cap   .isValid()
            && this.dashes && this.dashes.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this._fills) this._fills.pushValueUpdates(parse);
        if (this.weight) this.weight.pushValueUpdates(parse);
        if (this.fit   ) this.fit   .pushValueUpdates(parse);
        if (this.join  ) this.join  .pushValueUpdates(parse);
        if (this.miter ) this.miter .pushValueUpdates(parse);
        if (this.cap   ) this.cap   .pushValueUpdates(parse);
        if (this.dashes) this.dashes.pushValueUpdates(parse);
    }    
    
    

    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this._fills) this._fills.invalidateInputs(parse, from, force);
        if (this.weight) this.weight.invalidateInputs(parse, from, force);
        if (this.fit   ) this.fit   .invalidateInputs(parse, from, force);
        if (this.join  ) this.join  .invalidateInputs(parse, from, force);
        if (this.miter ) this.miter .invalidateInputs(parse, from, force);
        if (this.cap   ) this.cap   .invalidateInputs(parse, from, force);
        if (this.dashes) this.dashes.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this._fills) this._fills.iterateLoop(parse);
        if (this.weight) this.weight.iterateLoop(parse);
        if (this.fit   ) this.fit   .iterateLoop(parse);
        if (this.join  ) this.join  .iterateLoop(parse);
        if (this.miter ) this.miter .iterateLoop(parse);
        if (this.cap   ) this.cap   .iterateLoop(parse);
        if (this.dashes) this.dashes.iterateLoop(parse);
    }    
}


class GRoundCorners
extends GOperator1
{
    tl = null;
    tr = null;
    bl = null;
    br = null;
    
    

    constructor(nodeId, options)
    {
        super(ROUND_CORNERS, nodeId, options);
    }

    
    
    reset()
    {
        super.reset();
        
        this.tl = null;
        this.tr = null;
        this.bl = null;
        this.br = null;
    }



    copy()
    {
        const copy = new GRoundCorners(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.tl) copy.tl = this.tl.copy();
        if (this.tr) copy.tr = this.tr.copy();
        if (this.bl) copy.bl = this.bl.copy();
        if (this.br) copy.br = this.br.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;
``

        const tl = this.tl ? (await this.tl.eval(parse)).toValue() : null;
        const tr = this.tr ? (await this.tr.eval(parse)).toValue() : null;
        const bl = this.bl ? (await this.bl.eval(parse)).toValue() : null;
        const br = this.br ? (await this.br.eval(parse)).toValue() : null;


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            this.value = new RoundCornersValue(
                tl ?? input.tl,
                tr ?? input.tr,
                bl ?? input.bl,
                br ?? input.br,
                this.options.enabled);
        }
        else
        {
            this.value = new RoundCornersValue(
                tl, 
                tr, 
                bl, 
                br,
                this.options.enabled);
        }


        this.setUpdateValues(parse,
        [
            ['tl', this.value.tl],
            ['tr', this.value.tr],
            ['bl', this.value.bl],
            ['br', this.value.br]
        ]);
        

        if (!this.tl) this.tl = this.value.tl.copy();
        if (!this.tr) this.tr = this.value.tr.copy();
        if (!this.bl) this.bl = this.value.bl.copy();
        if (!this.br) this.br = this.value.br.copy();


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return super.isValid()
            && this.tl && this.tl.isValid()
            && this.tr && this.tr.isValid()
            && this.bl && this.bl.isValid()
            && this.br && this.br.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.tl) this.tl.pushValueUpdates(parse);
        if (this.tr) this.tr.pushValueUpdates(parse);
        if (this.bl) this.bl.pushValueUpdates(parse);
        if (this.br) this.br.pushValueUpdates(parse);
    }
    
    
    
   invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.tl) this.tl.invalidateInputs(parse, from, force);
        if (this.tr) this.tr.invalidateInputs(parse, from, force);
        if (this.bl) this.bl.invalidateInputs(parse, from, force);
        if (this.br) this.br.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.tl) this.tl.iterateLoop(parse);
        if (this.tr) this.tr.iterateLoop(parse);
        if (this.bl) this.bl.iterateLoop(parse);
        if (this.br) this.br.iterateLoop(parse);
    }
}


class GDropShadow
extends GOperator1
{
    x      = null;
    y      = null;
    blur   = null;
    spread = null;
    fill   = null;
    blend  = null;
    behind = null;
    
    

    constructor(nodeId, options)
    {
        super(DROP_SHADOW, nodeId, options);
    }

    
    
    reset()
    {
        super.reset();
        
        this.x      = null;
        this.y      = null;
        this.blur   = null;
        this.spread = null;
        this.fill   = null;
        this.blend  = null;
        this.behind = null;
    }



    copy()
    {
        const copy = new GDropShadow(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.x     ) copy.x      = this.x     .copy();
        if (this.y     ) copy.y      = this.y     .copy();
        if (this.blur  ) copy.blur   = this.blur  .copy();
        if (this.spread) copy.spread = this.spread.copy();
        if (this.fill  ) copy.fill   = this.fill  .copy();
        if (this.blend ) copy.blend  = this.blend .copy();
        if (this.behind) copy.behind = this.behind.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;
``

        const x      = this.x      ? (await this.x     .eval(parse)).toValue() : null;
        const y      = this.y      ? (await this.y     .eval(parse)).toValue() : null;
        const blur   = this.blur   ? (await this.blur  .eval(parse)).toValue() : null;
        const spread = this.spread ? (await this.spread.eval(parse)).toValue() : null;
        let   fill   = this.fill   ? (await this.fill  .eval(parse)).toValue() : null;
        const blend  = this.blend  ? (await this.blend .eval(parse)).toValue() : null;
        const behind = this.behind ? (await this.behind.eval(parse)).toValue() : null;


        if (   fill
            && fill.type == COLOR_VALUE)
            fill = new FillValue(fill);

        
        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            this.value = new DropShadowValue(
                x      ?? input.x,
                y      ?? input.y,
                blur   ?? input.blur,
                spread ?? input.spread,
                fill   ?? input.fill,
                blend  ?? input.blend,
                behind ?? input.behind,
                this.options.enabled);
        }
        else
        {
            this.value = new DropShadowValue(
                x, 
                y, 
                blur, 
                spread, 
                fill, 
                blend, 
                behind,
                this.options.enabled);
        }


        this.setUpdateValues(parse,
        [
            ['x',      this.value.x     ],
            ['y',      this.value.y     ],
            ['blur',   this.value.blur  ],
            ['spread', this.value.spread],
            ['fill',   this.value.fill  ],
            ['blend',  this.value.blend ],
            ['behind', this.value.behind]
        ]);
        

        if (!this.x     ) this.x      = this.value.x     .copy();
        if (!this.y     ) this.y      = this.value.y     .copy();
        if (!this.blur  ) this.blur   = this.value.blur  .copy();
        if (!this.spread) this.spread = this.value.spread.copy();
        if (!this.fill  ) this.fill   = this.value.fill  .copy();
        if (!this.blend ) this.blend  = this.value.blend .copy();
        if (!this.behind) this.behind = this.value.behind.copy();


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return super.isValid()
            && this.x      && this.x     .isValid()
            && this.y      && this.y     .isValid()
            && this.blur   && this.blur  .isValid()
            && this.spread && this.spread.isValid()
            && this.fill   && this.fill  .isValid()
            && this.blend  && this.blend .isValid()
            && this.behind && this.behind.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.x     ) this.x     .pushValueUpdates(parse);
        if (this.y     ) this.y     .pushValueUpdates(parse);
        if (this.blur  ) this.blur  .pushValueUpdates(parse);
        if (this.spread) this.spread.pushValueUpdates(parse);
        if (this.fill  ) this.fill  .pushValueUpdates(parse);
        if (this.blend ) this.blend .pushValueUpdates(parse);
        if (this.behind) this.behind.pushValueUpdates(parse);
    }
    
    
    
   invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.x     ) this.x     .invalidateInputs(parse, from, force);
        if (this.y     ) this.y     .invalidateInputs(parse, from, force);
        if (this.blur  ) this.blur  .invalidateInputs(parse, from, force);
        if (this.spread) this.spread.invalidateInputs(parse, from, force);
        if (this.fill  ) this.fill  .invalidateInputs(parse, from, force);
        if (this.blend ) this.blend .invalidateInputs(parse, from, force);
        if (this.behind) this.behind.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.x     ) this.x     .iterateLoop(parse);
        if (this.y     ) this.y     .iterateLoop(parse);
        if (this.blur  ) this.blur  .iterateLoop(parse);
        if (this.spread) this.spread.iterateLoop(parse);
        if (this.fill  ) this.fill  .iterateLoop(parse);
        if (this.blend ) this.blend .iterateLoop(parse);
        if (this.behind) this.behind.iterateLoop(parse);
    }
}


class GInnerShadow
extends GOperator1
{
    x      = null;
    y      = null;
    blur   = null;
    spread = null;
    fill   = null;
    blend  = null;
    
    

    constructor(nodeId, options)
    {
        super(INNER_SHADOW, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.x      = null;
        this.y      = null;
        this.blur   = null;
        this.spread = null;
        this.fill   = null;
        this.blend  = null;
    }



    copy()
    {
        const copy = new GInnerShadow(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.x     ) copy.x      = this.x     .copy();
        if (this.y     ) copy.y      = this.y     .copy();
        if (this.blur  ) copy.blur   = this.blur  .copy();
        if (this.spread) copy.spread = this.spread.copy();
        if (this.fill  ) copy.fill   = this.fill  .copy();
        if (this.blend ) copy.blend  = this.blend .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;
``

        const x      = this.x      ? (await this.x     .eval(parse)).toValue() : null;
        const y      = this.y      ? (await this.y     .eval(parse)).toValue() : null;
        const blur   = this.blur   ? (await this.blur  .eval(parse)).toValue() : null;
        const spread = this.spread ? (await this.spread.eval(parse)).toValue() : null;
        let   fill   = this.fill   ? (await this.fill  .eval(parse)).toValue() : null;
        const blend  = this.blend  ? (await this.blend .eval(parse)).toValue() : null;

        
        if (   fill
            && fill.type == COLOR_VALUE)
            fill = new FillValue(fill);


         if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            this.value = new InnerShadowValue(
                x      ?? input.x,
                y      ?? input.y,
                blur   ?? input.blur,
                spread ?? input.spread,
                fill   ?? input.fill,
                blend  ?? input.blend,
                this.options.enabled);
        }
        else
        {
            this.value = new InnerShadowValue(
                x, 
                y, 
                blur, 
                spread, 
                fill, 
                blend,
                this.options.enabled);
        }


        this.setUpdateValues(parse,
        [
            ['x',      this.value.x     ],
            ['y',      this.value.y     ],
            ['blur',   this.value.blur  ],
            ['spread', this.value.spread],
            ['fill',   this.value.fill  ],
            ['blend',  this.value.blend ],
        ]);
        

        if (!this.x     ) this.x      = this.value.x     .copy();
        if (!this.y     ) this.y      = this.value.y     .copy();
        if (!this.blur  ) this.blur   = this.value.blur  .copy();
        if (!this.spread) this.spread = this.value.spread.copy();
        if (!this.fill  ) this.fill   = this.value.fill  .copy();
        if (!this.blend ) this.blend  = this.value.blend .copy();


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return super.isValid()
            && this.x      && this.x     .isValid()
            && this.y      && this.y     .isValid()
            && this.blur   && this.blur  .isValid()
            && this.spread && this.spread.isValid()
            && this.fill   && this.fill  .isValid()
            && this.blend  && this.blend .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.x     ) this.x     .pushValueUpdates(parse);
        if (this.y     ) this.y     .pushValueUpdates(parse);
        if (this.blur  ) this.blur  .pushValueUpdates(parse);
        if (this.spread) this.spread.pushValueUpdates(parse);
        if (this.fill  ) this.fill  .pushValueUpdates(parse);
        if (this.blend ) this.blend .pushValueUpdates(parse);
    }
    
    
    
    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.x     ) this.x     .invalidateInputs(parse, from, force);
        if (this.y     ) this.y     .invalidateInputs(parse, from, force);
        if (this.blur  ) this.blur  .invalidateInputs(parse, from, force);
        if (this.spread) this.spread.invalidateInputs(parse, from, force);
        if (this.fill  ) this.fill  .invalidateInputs(parse, from, force);
        if (this.blend ) this.blend .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.x     ) this.x     .iterateLoop(parse);
        if (this.y     ) this.y     .iterateLoop(parse);
        if (this.blur  ) this.blur  .iterateLoop(parse);
        if (this.spread) this.spread.iterateLoop(parse);
        if (this.fill  ) this.fill  .iterateLoop(parse);
        if (this.blend ) this.blend .iterateLoop(parse);
    }
}


class GLayerBlur
extends GOperator1
{
    radius = null;



    constructor(nodeId, options)
    {
        super(LAYER_BLUR, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.radius = null;
    }



    copy()
    {
        const copy = new GLayerBlur(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.radius) copy.radius = this.radius.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;
``

        const radius = this.radius ? (await this.radius.eval(parse)).toValue() : null;

        
        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            this.value = new LayerBlurValue(
                radius ?? input.radius,
                this.options.enabled);
        }
        else
        {
            this.value = new LayerBlurValue(
                radius,
                this.options.enabled);
        }


        this.setUpdateValues(parse,
        [
            ['radius', this.value.radius]
        ]);
        

        if (!this.radius) this.radius = this.value.radius.copy();


        this.validate();

        return this;
    }



    toValue()
    {
        return new LayerBlurValue(
            this.radius ? this.radius.toValue() : this.input.radius.toValue(),
            this.options.enabled);
    }



    isValid()
    {
        return super.isValid()
            && this.radius && this.radius.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.radius) this.radius.pushValueUpdates(parse);
    }
    
    
    
    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.radius) this.radius.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.radius) this.radius.iterateLoop(parse);
    }
}


class GBackBlur
extends GOperator1
{
    radius = null;



    constructor(nodeId, options)
    {
        super(BACK_BLUR, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.radius = null;
    }



    copy()
    {
        const copy = new GBackBlur(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.radius) copy.radius = this.radius.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;
``

        const radius = this.radius ? (await this.radius.eval(parse)).toValue() : null;

        
        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            this.value = new BackBlurValue(
                radius ?? input.radius,
                this.options.enabled);
        }
        else
        {
            this.value = new BackBlurValue(
                radius,
                this.options.enabled);
        }


        this.setUpdateValues(parse,
        [
            ['radius', this.value.radius]
        ]);
        

        if (!this.radius) this.radius = this.value.radius.copy();


        this.validate();

        return this;
    }



    toValue()
    {
        return new BackBlurValue(
            this.radius ? this.radius.toValue() : this.input.radius.toValue(),
            this.options.enabled);
    }



    isValid()
    {
        return super.isValid()
            && this.radius && this.radius.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.radius) this.radius.pushValueUpdates(parse);
    }
    
    
    
    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.radius) this.radius.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.radius) this.radius.iterateLoop(parse);
    }
}


class GLayerBlend
extends GOperator
{
    opacity;
    blend;



    constructor(nodeId, options)
    {
        super(LAYER_BLEND, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.opacity = null;
        this.blend   = null;
    }



    copy()
    {
        const copy = new GLayerBlend(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.opacity) copy.opacity = this.opacity.copy();
        if (this.blend  ) copy.blend   = this.blend  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;
``

        const opacity = (await this.opacity.eval(parse)).toValue();
        const blend   = (await this.blend  .eval(parse)).toValue();


        this.value = 
            this.options.enabled
            ? new LayerBlendValue(opacity, blend)
            : new LayerBlendValue(new NumberValue(100), new NumberValue(0));


        this.setUpdateValues(parse, 
        [
            ['opacity', opacity],
            ['blend',   blend  ]
        ]);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value.copy();
    }



    isValid()
    {
        return this.opacity && this.opacity.isValid()
            && this.blend   && this.blend  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.opacity) this.opacity.pushValueUpdates(parse);
        if (this.blend  ) this.blend  .pushValueUpdates(parse);
    }
    
    
    
    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.opacity) this.opacity.invalidateInputs(parse, from, force);
        if (this.blend  ) this.blend  .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.opacity) this.opacity.iterateLoop(parse);
        if (this.blend  ) this.blend  .iterateLoop(parse);
    }
}


class GLayerMask
extends GOperator
{
    maskType;



    constructor(nodeId, options)
    {
        super(LAYER_MASK, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.maskType = null;
    }



    copy()
    {
        const copy = new GLayerMask(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.maskType) copy.maskType = this.maskType.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;
``

        const maskType = (await this.maskType.eval(parse)).toValue();


        this.value = new LayerMaskValue(maskType, this.options.enabled);


        this.setUpdateValues(parse, 
        [
            ['maskType', maskType]
        ]);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value.copy();
    }



    isValid()
    {
        return this.maskType && this.maskType.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.maskType) this.maskType.pushValueUpdates(parse);
    }
    
    
    
    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.maskType) this.maskType.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.maskType) this.maskType.iterateLoop(parse);
    }
}


class GShapeBase
extends GOperator
{
    x      = null;
    y      = null;
    width  = null;
    height = null;



    constructor(type, nodeId, options)
    {
        super(type, nodeId, options);
    }



    reset()
    {
        super.reset();
        
        this.x      = null;
        this.y      = null;
        this.width  = null;
        this.height = null;
    }



    copyBase(base)
    {
        super.copyBase(base);

        if (base.x     ) this.x      = base.x     .copy();
        if (base.y     ) this.y      = base.y     .copy();
        if (base.width ) this.width  = base.width .copy();
        if (base.height) this.height = base.height.copy();
    }



    async evalBaseParams(parse, evalHeight = true)
    {
        const x      = this.x      ? (await this.x     .eval(parse)).toValue() : null;
        const y      = this.y      ? (await this.y     .eval(parse)).toValue() : null;
        const width  = this.width  ? (await this.width .eval(parse)).toValue() : null;

        const height = evalHeight
                    && this.height ? (await this.height.eval(parse)).toValue() : null;

        return [x, y, width, height];
    }



    evalStyle(options = {})
    {
        // for (const style of this.styles)
        //     style.nodeId = this.nodeId;
    }



    isValid()
    {
        return this.x      && this.x     .isValid()
            && this.y      && this.y     .isValid()
            && this.width  && this.width .isValid()
            && this.height && this.height.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.x     ) this.x     .pushValueUpdates(parse);
        if (this.y     ) this.y     .pushValueUpdates(parse);
        if (this.width ) this.width .pushValueUpdates(parse);
        if (this.height) this.height.pushValueUpdates(parse);
    }


    
    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.x     ) this.x     .invalidateInputs(parse, from, force);
        if (this.y     ) this.y     .invalidateInputs(parse, from, force);
        if (this.width ) this.width .invalidateInputs(parse, from, force);
        if (this.height) this.height.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.x     ) this.x     .iterateLoop(parse);
        if (this.y     ) this.y     .iterateLoop(parse);
        if (this.width ) this.width .iterateLoop(parse);
        if (this.height) this.height.iterateLoop(parse);
    }
}



function validateObjectRect(x, y, w, h, a = 0, _a = 0)
{
    if (w < 0)
    {
        x += w * Math.cos(_a);
        y += w * Math.sin(_a);
    }

    if (h < 0)
    {
        y += h * Math.cos(_a);
        x -= h * Math.sin(_a);
    }
  
    
    w = Math.abs(w);
    h = Math.abs(h);


    return [x, y, w, h, a, _a];
}


class GShape
extends GShapeBase
{
    input = null;

    props = null;
   


    constructor(type, nodeId, options)
    {
        super(type, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.input = null;
        this.props = null;
    }



    copyBase(base)
    {
        super.copyBase(base);
        
        if (base.input) this.input = base.input.copy();
        if (base.props) this.props = base.props.copy();
    }



    baseIsValid()
    {
        return this.value
            && this.value.props
            && this.value.props.isValid();
    }



    isCached()
    {
        return super.isCached()
            && (  !this.input 
                || this.input.isCached());
    }



    async evalShapeBase(parse, add = false, input = null)
    {
        let props = this.props ? (await this.props.eval(parse)).toValue() : null;

        if (   props
            && STYLE_VALUES.includes(props.type))
            props = new ListValue([props]);

        
        if (this.value)
        {
            if (this.input)
            {
                // console.log('this.input =', this.input);

                if (add)
                {
                    this.value.props = new ListValue();

                    
                    if (this.input.toValue().props.type == LIST_VALUE)
                        this.value.props.items.push(...this.input.toValue().props.items);
                    else
                        this.value.props.items.push(input.props);
                    

                    if (props)
                        this.value.props.items.push(...props.items);
                }
                else
                    this.value.props = props ?? this.input.toValue().props;
            }
            else
                this.value.props = props;

                    
            if (   this.value
                && this.value.isValid()
                && this.value.props != undefined) 
            {
                this.setUpdateValues(parse, 
                [
                    ['props', this.value.props]
                ], 
                true);


                if (!this.props) this.props = this.value.props.copy();
            }
        }
    }



    async evalObjects(parse)
    {
        if (!this.value)
            return;


        for (const obj of this.value.objects)
        {
            consoleAssert(obj.fills,   'obj.fills must not be null'  );
            consoleAssert(obj.strokes, 'obj.strokes must not be null');
            consoleAssert(obj.effects, 'obj.effects must not be null');


            if (  !this.value.props
                || this.value.props.items == undefined) 
                continue;


            for (let i = this.value.props.items.length-1; i >= 0; i--)
            {
                const prop = this.value.props.items[i];
                
                     if (prop.type ==         COLOR_VALUE)  addColorProp       (obj, prop);
                else if (prop.type ==          FILL_VALUE)  addFillProp        (obj, prop);
                else if (prop.type ==      GRADIENT_VALUE)  addGradientProp    (obj, prop);
                else if (prop.type ==        STROKE_VALUE)  addStrokeProp      (obj, prop);
                else if (prop.type == ROUND_CORNERS_VALUE)  addRoundCornersProp(obj, prop);
                else if (prop.type ==   DROP_SHADOW_VALUE)  addDropShadowProp  (obj, prop);
                else if (prop.type ==  INNER_SHADOW_VALUE)  addInnerShadowProp (obj, prop);
                else if (prop.type ==    LAYER_BLUR_VALUE)  addLayerBlurProp   (obj, prop);
                else if (prop.type ==     BACK_BLUR_VALUE)  addBackBlurProp    (obj, prop);
                else if (prop.type ==   LAYER_BLEND_VALUE)  addLayerBlendProp  (obj, prop);
                else if (prop.type ==    LAYER_MASK_VALUE)  addMaskProp        (obj, prop);
            }
        }
    }



    evalStyle(options = {})
    {

    }



    isValid()
    {
        return super.isValid()
            && (!this.input || this.input.isValid())
            && this.props && this.props.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input) this.input.pushValueUpdates(parse);
        if (this.props) this.props.pushValueUpdates(parse);
    }


    
    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.input) this.input.invalidateInputs(parse, from, force);
        if (this.props) this.props.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input) this.input.iterateLoop(parse);
        if (this.props) this.props.iterateLoop(parse);
    }
}


class GRectangle
extends GShape
{
    round = null;



    constructor(nodeId, options)
    {
        super(RECTANGLE, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.round = null;
    }



    copy()
    {
        const copy = new GRectangle(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.round) copy.round = this.round.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        const [x, y, width, height] = await this.evalBaseParams(parse);

        const round = this.round ? (await this.round.eval(parse)).toValue() : null;


        let input = null;

        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();
            
            this.value = new RectangleValue(
                this.nodeId,
                x      ?? input.x,
                y      ?? input.y,
                width  ?? input.width,
                height ?? input.height,
                round  ?? input.round);

            this.value.copyCustomParams(input);
        }
        else
        {
            this.value = new RectangleValue(
                this.nodeId, 
                x, 
                y, 
                width, 
                height, 
                round);
        }

       
        this.setUpdateValues(parse, 
        [
            ['value', this.value]
        ]);


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        if (!this.x     ) this.x      = this.value.x     .copy();
        if (!this.y     ) this.y      = this.value.y     .copy();
        if (!this.width ) this.width  = this.value.width .copy();
        if (!this.height) this.height = this.value.height.copy();
        if (!this.round ) this.round  = this.value.round .copy();


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
     
        
        this.value.objects = [];


        if (   super.baseIsValid()   
            && this.value.x     .isValid()
            && this.value.y     .isValid()
            && this.value.width .isValid()
            && this.value.height.isValid()
            && this.value.round .isValid())
        {
            let   x = this.value.x     .value;
            let   y = this.value.y     .value;
            let   w = this.value.width .value;
            let   h = this.value.height.value;
            const r = Math.max(0, this.value.round.value);


            [x, y, w, h, , ] = validateObjectRect(x, y, w, h);


            if (   w != 0 
                && h != 0)
            {
                const rect = new FigmaRectangle(
                    this.nodeId, 
                    this.nodeId, 
                    this.nodeName, 
                    x, y, w, h, r);

                rect.createDefaultTransform(x, y);
                rect.createDefaultTransformPoints(x, y, w, h);

                this.value.objects.push(rect);
            }
        }

        
        await super.evalObjects(parse);
        
    }



    toValue()
    {
        const rect = new RectangleValue(
            this.nodeId,
            this.x     .toValue(),
            this.y     .toValue(),
            this.width .toValue(),
            this.height.toValue(),
            this.round .toValue());

        rect.copyCustomParams(this.value);

        rect.props   = this.props.toValue();
        rect.objects = this.value.objects.map(o => o.copy());

        return rect;
    }



    isValid()
    {
        return super.isValid()
            && this.round && this.round.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.round) this.round.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.round) this.round.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.round) this.round.iterateLoop(parse);
    }
}


class GLine
extends GShape
{
    constructor(nodeId, options)
    {
        super(LINE, nodeId, options);
    }



    copy()
    {
        const copy = new GLine(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const [x, y, width, ] = await this.evalBaseParams(parse, false);

            
        let input = null;

        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();

            this.value = new LineValue(
                this.nodeId,
                x     ?? input.x,
                y     ?? input.y,
                width ?? input.width);

            this.value.copyCustomParams(input);
        }
        else
        {
            this.value = new LineValue(
                this.nodeId, 
                x, 
                y, 
                width);
        }


        this.setUpdateValues(parse, [['value', this.value]]);


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        if (!this.x    ) this.x     = this.value.x    .copy();
        if (!this.y    ) this.y     = this.value.y    .copy();
        if (!this.width) this.width = this.value.width.copy();


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            

        this.value.objects = [];


        if (   super.baseIsValid()   
            && this.value.x    .isValid()
            && this.value.y    .isValid()
            && this.value.width.isValid()) 
        {
            let x = this.value.x    .value;
            let y = this.value.y    .value;
            let w = this.value.width.value;


            [x, y, w, , , ] = validateObjectRect(x, y, w, 0);


            if (w != 0)
            {
                const line = new FigmaLine(
                    this.nodeId,
                    this.nodeId,
                    this.nodeName,
                    x, y, w);

                line.createDefaultTransform(x, y);
                line.createDefaultTransformPoints(x, y, w, 0.01);
                
                this.value.objects.push(line);
            }
        }

        
        await super.evalObjects(parse);
    }



    toValue()
    {
        const line = new LineValue(
            this.nodeId,
            this.x     .toValue(),
            this.y     .toValue(),
            this.width .toValue());

        line.copyCustomParams(this.value);

        line.props   = this.props.toValue();
        line.objects = this.value.objects.map(o => o.copy());

        return line;
    }
}


class GEllipse
extends GShape
{
    position = null;
    round    = null;
    from     = null;
    to       = null;
    inner    = null;



    constructor(nodeId, options)
    {
        super(ELLIPSE, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.position = null;
        this.round    = null;
        this.from     = null;
        this.to       = null;
        this.inner    = null;
    }



    copy()
    {
        const copy = new GEllipse(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.position) copy.position = this.position.copy();
        if (this.round   ) copy.round    = this.round   .copy();
        if (this.from    ) copy.from     = this.from    .copy();
        if (this.to      ) copy.to       = this.to      .copy();
        if (this.inner   ) copy.inner    = this.inner   .copy();
        
        return copy;
    }


    async eval(parse)
    {
        if (this.isCached())
            return this;


        const [x, y, width, height] = await this.evalBaseParams(parse);

        const pos   = this.position ? (await this.position.eval(parse)).toValue() : null;
        const round = this.round    ? (await this.round   .eval(parse)).toValue() : null;
        const from  = this.from     ? (await this.from    .eval(parse)).toValue() : null;
        const to    = this.to       ? (await this.to      .eval(parse)).toValue() : null;
        const inner = this.inner    ? (await this.inner   .eval(parse)).toValue() : null;


        let input = null;


        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();


            const  _pos   = pos    ?? input.position;
            const  _x     = x      ?? input.x;
            const  _y     = y      ?? input.y;
            const  _w     = width  ?? input.width;
            const  _h     = height ?? input.height;
            const  _round = round  ?? input.round;
            const  _from  = from   ?? input.from;
            const  _to    = to     ?? input.to;
            const  _inner = inner  ?? input.inner;

            const __x = _pos.value == 0 ? _x : new NumberValue(_x.value + _w.value/2, Math.max(_x.decimals, _w.decimals));
            const __y = _pos.value == 0 ? _y : new NumberValue(_y.value + _h.value/2, Math.max(_y.decimals, _h.decimals));
            const __w = _pos.value == 0 ? _w : new NumberValue(_w.value/2, Math.max(_x.decimals, _w.decimals));
            const __h = _pos.value == 0 ? _h : new NumberValue(_h.value/2, Math.max(_y.decimals, _h.decimals));            


            this.value = new EllipseValue(
                this.nodeId,
                _pos,
                _x, _y, _w, _h,
                _round,
                _from,
                _to,
                _inner);
            
            this.value.copyCustomParams(input);
            

            this.setUpdateValues(parse, 
            [
                ['position', _pos      ],
                ['x',        __x       ],
                ['y',        __y       ],
                ['width',    __w       ],
                ['height',   __h       ],
                ['round',    _round    ],
                ['from',     _from     ],
                ['to',       _to       ],
                ['inner',    _inner    ],
                ['value',    this.value]
            ]);
        }
        else
        {
            const _x = x;
            const _y = y;
            const _w = width;
            const _h = height;

            const __x = pos.value == 0 ? _x : new NumberValue(_x.value - _w.value, Math.max(_x.decimals, _w.decimals));
            const __y = pos.value == 0 ? _y : new NumberValue(_y.value - _h.value, Math.max(_y.decimals, _h.decimals));
            const __w = pos.value == 0 ? _w : new NumberValue(_w.value*2, Math.max(_x.decimals, _w.decimals));
            const __h = pos.value == 0 ? _h : new NumberValue(_h.value*2, Math.max(_y.decimals, _h.decimals));            

            this.value = new EllipseValue(
                this.nodeId,
                pos,
                __x, __y, __w, __h,
                round,
                from,
                to,
                inner);


            this.setUpdateValues(parse, 
            [
                ['position', pos       ],
                ['x',        _x        ],
                ['y',        _y        ],
                ['width',    _w        ],
                ['height',   _h        ],
                ['round',    round     ],
                ['from',     from      ],
                ['to',       to        ],
                ['inner',    inner     ],
                ['value',    this.value]
            ]);
        }


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        if (!this.position) this.position = this.value.position.copy();
        if (!this.x       ) this.x        = this.value.x       .copy();
        if (!this.y       ) this.y        = this.value.y       .copy();
        if (!this.width   ) this.width    = this.value.width   .copy();
        if (!this.height  ) this.height   = this.value.height  .copy();
        if (!this.round   ) this.round    = this.value.round   .copy();
        if (!this.from    ) this.from     = this.value.from    .copy();
        if (!this.to      ) this.to       = this.value.to      .copy();
        if (!this.inner   ) this.inner    = this.value.inner   .copy();


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
       if (!this.options.enabled)
           return;
           
           
        this.value.objects = [];


        if (   super.baseIsValid()
            && this.value.x     .isValid()
            && this.value.y     .isValid()
            && this.value.width .isValid()
            && this.value.height.isValid()) 
        {
            let   x = this.value.x     .value;
            let   y = this.value.y     .value;
            let   w = this.value.width .value;
            let   h = this.value.height.value;
            let   r = this.value.round .value;
            const f = this.value.from  .value;
            const t = this.value.to    .value;
            const i = this.value.inner .value;


            [x, y, w, h, , ] = validateObjectRect(x, y, w, h);


            if (   w != 0 
                && h != 0)
            {
                const ellipse = new FigmaEllipse(
                    this.nodeId,
                    this.nodeId,
                    this.nodeName,
                    x, y, w, h, r, f, t, i);

                ellipse.createDefaultTransform(x, y);
                ellipse.createDefaultTransformPoints(x, y, w, h);

                this.value.objects.push(ellipse);
            }
        }

       
        await super.evalObjects(parse);
    }
   
    
        
    toValue()
    {
        const ellipse = new EllipseValue(
            this.nodeId,
            this.position.toValue(),
            this.x       .toValue(),
            this.y       .toValue(),
            this.width   .toValue(),
            this.height  .toValue(),
            this.round   .toValue(),
            this.from    .toValue(),
            this.to      .toValue(),
            this.inner   .toValue());

        ellipse.copyCustomParams(this.value);

        ellipse.props = this.props.toValue();

        ellipse.objects = 
            this.value.objects
            ? this.value.objects.map(o => o.copy())
            : [];
        
        return ellipse;
    }
    

    
    isValid()
    {
        return super.isValid()
            && this.position && this.position.isValid()
            && this.round    && this.round   .isValid()
            && this.from     && this.from    .isValid()
            && this.to       && this.to      .isValid()
            && this.inner    && this.inner   .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);
 
        if (this.position) this.position.pushValueUpdates(parse);
        if (this.round   ) this.round   .pushValueUpdates(parse);
        if (this.from    ) this.from    .pushValueUpdates(parse);
        if (this.to      ) this.to      .pushValueUpdates(parse);
        if (this.inner   ) this.inner   .pushValueUpdates(parse);
    }

   
        
    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.position) this.position.invalidateInputs(parse, from, force);
        if (this.round   ) this.round   .invalidateInputs(parse, from, force);
        if (this.from    ) this.from    .invalidateInputs(parse, from, force);
        if (this.to      ) this.to      .invalidateInputs(parse, from, force);
        if (this.inner   ) this.inner   .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);
 
        if (this.position) this.position.iterateLoop(parse);
        if (this.round   ) this.round   .iterateLoop(parse);
        if (this.from    ) this.from    .iterateLoop(parse);
        if (this.to      ) this.to      .iterateLoop(parse);
        if (this.inner   ) this.inner   .iterateLoop(parse);
    }
}


class GTrapeze
extends GShape
{
    round = null;
    bias  = null;



    constructor(nodeId, options)
    {
        super(TRAPEZE, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.round = null;
        this.bias  = null;
    }



    copy()
    {
        const copy = new GTrapeze(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.round) copy.round = this.round.copy();
        if (this.bias ) copy.bias  = this.bias .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        const [x, y, width, height] = await this.evalBaseParams(parse);

        const round = this.round ? (await this.round.eval(parse)).toValue() : null;
        const bias  = this.bias  ? (await this.bias .eval(parse)).toValue() : null;


        let input = null;

        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();

            this.value = new TrapezeValue(
                this.nodeId,
                x      ?? input.x,
                y      ?? input.y,
                width  ?? input.width,
                height ?? input.height,
                round  ?? input.round,
                bias   ?? input.bias);

            this.value.copyCustomParams(input);
        }
        else
        {
            this.value = new TrapezeValue(
                this.nodeId, 
                x, 
                y, 
                width, 
                height, 
                round,
                bias);
        }

       
        this.setUpdateValues(parse, 
        [
            ['value', this.value]
        ]);


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        if (!this.x     ) this.x      = this.value.x     .copy();
        if (!this.y     ) this.y      = this.value.y     .copy();
        if (!this.width ) this.width  = this.value.width .copy();
        if (!this.height) this.height = this.value.height.copy();
        if (!this.round ) this.round  = this.value.round .copy();
        if (!this.bias  ) this.bias   = this.value.bias  .copy();


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
     
        
        this.value.objects = [];


        if (   super.baseIsValid()   
            && this.value.x     .isValid()    
            && this.value.y     .isValid()    
            && this.value.width .isValid()
            && this.value.height.isValid()
            && this.value.round .isValid()
            && this.value.bias  .isValid())
        {
            let   x = this.value.x     .value;
            let   y = this.value.y     .value;
            let   w = this.value.width .value;
            let   h = this.value.height.value;
            const r = Math.max(0, this.value.round.value);
            let   b = this.value.bias  .value;


            [x, y, w, h, , ] = validateObjectRect(x, y, w, h);


            if (   w != 0 
                && h != 0)
            {
                const trapeze = new FigmaTrapeze(
                    this.nodeId, 
                    this.nodeId, 
                    this.nodeName, 
                    x, y, w, h, r, b);

                trapeze.createDefaultTransform(x, y);
                trapeze.createDefaultTransformPoints(x, y, w, h);

                this.value.objects.push(trapeze);
            }
        }


        await super.evalObjects(parse);
    }



    toValue()
    {
        const trap = new TrapezeValue(
            this.nodeId,
            this.x     .toValue(),
            this.y     .toValue(),
            this.width .toValue(),
            this.height.toValue(),
            this.round .toValue(),
            this.bias  .toValue());

        trap.copyCustomParams(this.value);

        trap.props   = this.props.toValue();
        trap.objects = this.value.objects.map(o => o.copy());

        return trap;
    }



    isValid()
    {
        return super.isValid()
            && this.round && this.round.isValid()
            && this.bias  && this.bias .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.round) this.round.pushValueUpdates(parse);
        if (this.bias ) this.bias .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.round) this.round.invalidateInputs(parse, from, force);
        if (this.bias ) this.bias .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.round) this.round.iterateLoop(parse);
        if (this.bias ) this.bias .iterateLoop(parse);
    }
}


class GPolygon
extends GShape
{
    position = null;
    round    = null;
    corners  = null;



    constructor(nodeId, options)
    {
        super(POLYGON, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.position = null;
        this.round    = null;
        this.corners  = null;
    }



    copy()
    {
        const copy = new GPolygon(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.position) copy.position = this.position.copy();
        if (this.round   ) copy.round    = this.round   .copy();
        if (this.corners ) copy.corners  = this.corners .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const [x, y, width, height] = await this.evalBaseParams(parse);

        const pos     = this.position ? (await this.position.eval(parse)).toValue() : null;
        const round   = this.round    ? (await this.round   .eval(parse)).toValue() : null;
        const corners = this.corners  ? (await this.corners .eval(parse)).toValue() : null;


        let input = null;
             
        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();

            const  _pos     = pos     ?? input.position;
            const  _x       = x       ?? input.x;
            const  _y       = y       ?? input.y;
            const  _w       = width   ?? input.width;
            const  _h       = height  ?? input.height;
            const  _round   = round   ?? input.round;
            const  _corners = corners ?? input.corners;

            const __x = _pos.value == 0 ? _x : new NumberValue(_x.value + _w.value/2, Math.max(_x.decimals, _w.decimals));
            const __y = _pos.value == 0 ? _y : new NumberValue(_y.value + _h.value/2, Math.max(_y.decimals, _h.decimals));
            const __w = _pos.value == 0 ? _w : new NumberValue(_w.value/2, Math.max(_x.decimals, _w.decimals));
            const __h = _pos.value == 0 ? _h : new NumberValue(_h.value/2, Math.max(_y.decimals, _h.decimals));            
            
            this.value = new PolygonValue(
                this.nodeId,
                _pos,
                _x, _y, _w, _h,
                _round,
                _corners);

            this.value.copyCustomParams(input);

                
            this.setUpdateValues(parse, 
            [
                ['position', _pos      ],
                ['x',        __x       ],
                ['y',        __y       ],
                ['width',    __w       ],
                ['height',   __h       ],
                ['value',    this.value]
            ]);
        }
        else
        {
            const _x = x;
            const _y = y;
            const _w = width;
            const _h = height;

            const __x = pos.value == 0 ? _x : new NumberValue(_x.value - _w.value, Math.max(_x.decimals, _w.decimals));
            const __y = pos.value == 0 ? _y : new NumberValue(_y.value - _h.value, Math.max(_y.decimals, _h.decimals));
            const __w = pos.value == 0 ? _w : new NumberValue(_w.value*2, Math.max(_x.decimals, _w.decimals));
            const __h = pos.value == 0 ? _h : new NumberValue(_h.value*2, Math.max(_y.decimals, _h.decimals));            

            this.value = new PolygonValue(
                this.nodeId,
                pos,
                __x, __y, __w, __h,
                round,
                corners);


            this.setUpdateValues(parse, 
            [
                ['position', pos       ],
                ['x',        _x        ],
                ['y',        _y        ],
                ['width',    _w        ],
                ['height',   _h        ],
                ['value',    this.value]
            ]);
        }


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        if (!this.position) this.position = this.value.position.copy();
        if (!this.x       ) this.x        = this.value.x       .copy();
        if (!this.y       ) this.y        = this.value.y       .copy();
        if (!this.width   ) this.width    = this.value.width   .copy();
        if (!this.height  ) this.height   = this.value.height  .copy();
        if (!this.round   ) this.round    = this.value.round   .copy();
        if (!this.corners ) this.corners  = this.value.corners .copy();


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            
            
        this.value.objects = [];


        if (   super.baseIsValid()   
            && this.value.x      .isValid()
            && this.value.y      .isValid()
            && this.value.width  .isValid()
            && this.value.height .isValid()
            && this.value.round  .isValid()
            && this.value.corners.isValid())
        {
            let   x = this.value.x      .value;
            let   y = this.value.y      .value;
            let   w = this.value.width  .value;
            let   h = this.value.height .value;
            const r = Math.max(0, this.value.round.value);
            const c = Math.max(3, Math.floor(this.value.corners.value));


            [x, y, w, h, , ] = validateObjectRect(x, y, w, h);


            if (   w != 0 
                && h != 0)
            {
                const poly = new FigmaPolygon(
                    this.nodeId,
                    this.nodeId,
                    this.nodeName,
                    x, y, w, h, r, c);

                poly.createDefaultTransform(x, y);
                poly.createDefaultTransformPoints(x, y, w, h);

                this.value.objects.push(poly);
            }
        }

        
        await super.evalObjects(parse);
    }



    toValue()
    {
        const poly = new PolygonValue(
            this.nodeId,
            this.position.toValue(),
            this.x       .toValue(),
            this.y       .toValue(),
            this.width   .toValue(),
            this.height  .toValue(),
            this.round   .toValue(),
            this.corners .toValue());

        poly.copyCustomParams(this.value);

        poly.props   = this.props.toValue();
        poly.objects = this.value.objects.map(o => o.copy());

        return poly;
    }



    isValid()
    {
        return super.isValid()
            && this.position && this.position.isValid()
            && this.round    && this.round   .isValid()
            && this.corners  && this.corners .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.position) this.position.pushValueUpdates(parse);
        if (this.round   ) this.round   .pushValueUpdates(parse);
        if (this.corners ) this.corners .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.position) this.position.invalidateInputs(parse, from, force);
        if (this.round   ) this.round   .invalidateInputs(parse, from, force);
        if (this.corners ) this.corners .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.position) this.position.iterateLoop(parse);
        if (this.round   ) this.round   .iterateLoop(parse);
        if (this.corners ) this.corners .iterateLoop(parse);
    }
}



class GStar
extends GShape
{
    position = null;
    round    = null;
    points   = null;
    convex   = null;



    constructor(nodeId, options)
    {
        super(STAR, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.position = null;
        this.round    = null;
        this.points   = null;
        this.convex   = null;
    }



    copy()
    {
        const copy = new GStar(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.position) copy.position = this.position.copy();
        if (this.round   ) copy.round    = this.round   .copy();
        if (this.points  ) copy.points   = this.points  .copy();
        if (this.convex  ) copy.convex   = this.convex  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const [x, y, width, height] = await this.evalBaseParams(parse);

        const pos    = this.position ? (await this.position.eval(parse)).toValue() : null;
        const round  = this.round    ? (await this.round   .eval(parse)).toValue() : null;
        const points = this.points   ? (await this.points  .eval(parse)).toValue() : null;
        const convex = this.convex   ? (await this.convex  .eval(parse)).toValue() : null;


        let input = null;

        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();

            const  _pos    = pos    ?? input.x;
            const  _x      = x      ?? input.x;
            const  _y      = y      ?? input.y;
            const  _w      = width  ?? input.width;
            const  _h      = height ?? input.height;
            const  _round  = height ?? input.round;
            const  _points = height ?? input.points;
            const  _convex = height ?? input.convex;

            const __x = _pos.value == 0 ? _x : new NumberValue(_x.value + _w.value/2, Math.max(_x.decimals, _w.decimals));
            const __y = _pos.value == 0 ? _y : new NumberValue(_y.value + _h.value/2, Math.max(_y.decimals, _h.decimals));
            const __w = _pos.value == 0 ? _w : new NumberValue(_w.value/2, Math.max(_x.decimals, _w.decimals));
            const __h = _pos.value == 0 ? _h : new NumberValue(_h.value/2, Math.max(_y.decimals, _h.decimals));            
            
            this.value = new StarValue(
                this.nodeId,
                _pos,
                _x, _y, _w, _h,
                _round,
                _points,
                _convex);

            this.value.copyCustomParams(input);


            this.setUpdateValues(parse, 
            [
                ['position', _pos      ],
                ['x',        __x       ],
                ['y',        __y       ],
                ['width',    __w       ],
                ['height',   __h       ],
                ['value',    this.value]
            ]);
        }
        else
        {
            const _x = x;
            const _y = y;
            const _w = width;
            const _h = height;

            const __x = pos.value == 0 ? _x : new NumberValue(_x.value - _w.value, Math.max(_x.decimals, _w.decimals));
            const __y = pos.value == 0 ? _y : new NumberValue(_y.value - _h.value, Math.max(_y.decimals, _h.decimals));
            const __w = pos.value == 0 ? _w : new NumberValue(_w.value*2, Math.max(_x.decimals, _w.decimals));
            const __h = pos.value == 0 ? _h : new NumberValue(_h.value*2, Math.max(_y.decimals, _h.decimals));            

            this.value = new StarValue(
                this.nodeId,
                pos,
                __x, __y, __w, __h,
                round,
                points,
                convex);


            this.setUpdateValues(parse, 
            [
                ['position', pos       ],
                ['x',        _x        ],
                ['y',        _y        ],
                ['width',    _w        ],
                ['height',   _h        ],
                ['value',    this.value]
            ]);
        }


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        if (!this.position) this.position = this.value.position.copy();
        if (!this.x       ) this.x        = this.value.x       .copy();
        if (!this.y       ) this.y        = this.value.y       .copy();
        if (!this.width   ) this.width    = this.value.width   .copy();
        if (!this.height  ) this.height   = this.value.height  .copy();
        if (!this.round   ) this.round    = this.value.round   .copy();
        if (!this.points  ) this.points   = this.value.points  .copy();
        if (!this.convex  ) this.convex   = this.value.convex  .copy();



        this.validate();

        return this;
   }



   async evalObjects(parse, options = {})
   {
        if (!this.options.enabled)
           return;
           
           
        this.value.objects = [];


        if (   super.baseIsValid()   
            && this.value.x     .isValid()
            && this.value.y     .isValid()
            && this.value.width .isValid()
            && this.value.height.isValid() 
            && this.value.round .isValid()
            && this.value.points.isValid()
            && this.value.convex.isValid())
        {
            let   x = this.value.x     .value;
            let   y = this.value.y     .value;
            let   w = this.value.width .value;
            let   h = this.value.height.value;
            const r = Math.max(0, this.value.round.value);
            const p = Math.max(3, Math.floor(this.value.points.value));
            const c = this.value.convex.value;


            if (   w != 0
                && h != 0)
            {
                const star = new FigmaStar(
                    this.nodeId,
                    this.nodeId,
                    this.nodeName,
                    x, y, w, h, r, p, c);

                star.createDefaultTransform(x, y);
                star.createDefaultTransformPoints(x, y, w, h);

                this.value.objects.push(star);
            }
        }

       
        await super.evalObjects(parse);
    }



    toValue()
    {
        const star = new StarValue(
            this.nodeId,
            this.position.toValue(),
            this.x       .toValue(),
            this.y       .toValue(),
            this.width   .toValue(),
            this.height  .toValue(),
            this.round   .toValue(),
            this.points  .toValue(),
            this.convex  .toValue());

        star.copyCustomParams(this.value);

        star.props   = this.props.toValue();
        star.objects = this.value.objects.map(o => o.copy());
 
        return star;
    }



    isValid()
    {
        return super.isValid()
            && this.position && this.position.isValid()
            && this.round    && this.round   .isValid()
            && this.points   && this.points  .isValid()
            && this.convex   && this.convex  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.position) this.position.pushValueUpdates(parse);
        if (this.round   ) this.round   .pushValueUpdates(parse);
        if (this.points  ) this.points  .pushValueUpdates(parse);
        if (this.convex  ) this.convex  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.position) this.position.invalidateInputs(parse, from, force);
        if (this.round   ) this.round   .invalidateInputs(parse, from, force);
        if (this.points  ) this.points  .invalidateInputs(parse, from, force);
        if (this.convex  ) this.convex  .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.position) this.position.iterateLoop(parse);
        if (this.round   ) this.round   .iterateLoop(parse);
        if (this.points  ) this.points  .iterateLoop(parse);
        if (this.convex  ) this.convex  .iterateLoop(parse);
    }
}


class GTextShape
extends GShape
{
    text          = null;
    x             = null;
    y             = null;
    width         = null;
    height        = null;
    font          = null;
    size          = null;
    style         = null;
    alignH        = null;
    alignV        = null;
    lineHeight    = null;
    letterSpacing = null;
    
    

    constructor(nodeId, options)
    {
        super(TEXT_SHAPE, nodeId, options);
    }


    
    reset()
    {
        super.reset();
        
        this.text          = null;
        this.x             = null;
        this.y             = null;
        this.width         = null;
        this.height        = null;
        this.font          = null;
        this.size          = null;
        this.style         = null;
        this.alignH        = null;
        this.alignV        = null;
        this.lineHeight    = null;
        this.letterSpacing = null;
    }



    copy()
    {
        const copy = new GTextShape(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.text         ) copy.text          = this.text         .copy();
        if (this.x            ) copy.x             = this.x            .copy();
        if (this.y            ) copy.y             = this.y            .copy();
        if (this.width        ) copy.width         = this.width        .copy();
        if (this.height       ) copy.height        = this.height       .copy();
        if (this.font         ) copy.font          = this.font         .copy();
        if (this.style        ) copy.style         = this.style        .copy();
        if (this.size         ) copy.size          = this.size         .copy();
        if (this.alignH       ) copy.alignH        = this.alignH       .copy();
        if (this.alignV       ) copy.alignV        = this.alignV       .copy();
        if (this.lineHeight   ) copy.lineHeight    = this.lineHeight   .copy();
        if (this.letterSpacing) copy.letterSpacing = this.letterSpacing.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const text          = this.text          ? (await this.text         .eval(parse)).toValue() : null;
        const x             = this.x             ? (await this.x            .eval(parse)).toValue() : null;
        const y             = this.y             ? (await this.y            .eval(parse)).toValue() : null;
        const width         = this.width         ? (await this.width        .eval(parse)).toValue() : null;
        const height        = this.height        ? (await this.height       .eval(parse)).toValue() : null;
        const font          = this.font          ? (await this.font         .eval(parse)).toValue() : null;
        const style         = this.style         ? (await this.style        .eval(parse)).toValue() : null;
        const size          = this.size          ? (await this.size         .eval(parse)).toValue() : null;
        const alignH        = this.alignH        ? (await this.alignH       .eval(parse)).toValue() : null;
        const alignV        = this.alignV        ? (await this.alignV       .eval(parse)).toValue() : null;
        const lineHeight    = this.lineHeight    ? (await this.lineHeight   .eval(parse)).toValue() : null;
        const letterSpacing = this.letterSpacing ? (await this.letterSpacing.eval(parse)).toValue() : null;


        let input = null;

        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();

            this.value = new TextShapeValue(
                this.nodeId,
                text          ?? input.text,
                x             ?? input.x,
                y             ?? input.y,
                width         ?? input.width,
                height        ?? input.height,
                font          ?? input.font,
                style         ?? input.style,
                size          ?? input.size,
                alignH        ?? input.alignH,
                alignV        ?? input.alignV,
                lineHeight    ?? input.lineHeight,
                letterSpacing ?? input.letterSpacing);

            this.value.copyCustomParams(input);
        }
        else
        {
            this.value = new TextShapeValue(
                this.nodeId, 
                text, 
                x, 
                y, 
                width, //this.width .type != NUMBER_VALUE ? width  : new NumberValue(0), 
                height, //this.height.type != NUMBER_VALUE ? height : new NumberValue(0), 
                font, 
                style,
                size,
                alignH,
                alignV,
                lineHeight,
                letterSpacing);
        }

       
        this.setUpdateValues(parse, 
        [
            ['value', this.value]
        ]);


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        if (!this.text         ) this.text          = this.value.text         .copy();
        if (!this.x            ) this.x             = this.value.x            .copy();
        if (!this.y            ) this.y             = this.value.y            .copy();
        if (!this.width        ) this.width         = this.value.width        .copy();
        if (!this.height       ) this.height        = this.value.height       .copy();
        if (!this.font         ) this.font          = this.value.font         .copy();
        if (!this.style        ) this.style         = this.value.style        .copy();
        if (!this.size         ) this.size          = this.value.size         .copy();
        if (!this.alignH       ) this.alignH        = this.value.alignH       .copy();
        if (!this.alignV       ) this.alignV        = this.value.alignV       .copy();
        if (!this.lineHeight   ) this.lineHeight    = this.value.lineHeight   .copy();
        if (!this.letterSpacing) this.letterSpacing = this.value.letterSpacing.copy();
        

        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;

        
        this.value.objects = [];


        if (   super.baseIsValid()   
            && this.value.text         .isValid()
            && this.value.x            .isValid()
            && this.value.y            .isValid()
            && this.value.width        .isValid()
            && this.value.height       .isValid()
            && this.value.font         .isValid()
            && this.value.style        .isValid()
            && this.value.size         .isValid()
            && this.value.alignH       .isValid()
            && this.value.alignV       .isValid()
            && this.value.lineHeight   .isValid()
            && this.value.letterSpacing.isValid())
        {
            let x = this.value.x     .value;
            let y = this.value.y     .value;
            let w = this.value.width .value;
            let h = this.value.height.value;

            const fontName   = figUniqueFontNames[this.value.font.value];
            const fontStyles = getFontStyles(fontName);

            const text = new FigmaText(
                this.nodeId,
                this.nodeId,
                this.nodeName,
                this.value.text.value,
                x, y, w, h,
                fontName,
                this.value.size         .value,
                fontStyles[Math.min(this.value.style.value, fontStyles.length-1)],
                this.value.alignH       .value,
                this.value.alignV       .value,
                this.value.lineHeight   .value,
                this.value.letterSpacing.value);

                
            text.createDefaultTransform(x, y);
 
            // if (   text.width  == 0
            //     && text.height == 0)
            // {
            //     const {objectId, width, height} = await genGetObjectSizeFromFigma(text.toData());

            //     text.width  = width;
            //     text.height = height;

            //     this.value.width.value  = width;
            //     this.value.height.value = height;

            //     text.createDefaultTransformPoints(x, y, width, height);

            //     this.value.objects.push(text);
            // }
            // else
            // {
                text.createDefaultTransformPoints(x, y, w, h)

                this.value.objects.push(text);
            // }
        }

        
        await super.evalObjects(parse);
    }



    isValid()
    {
        return super.isValid()
            && this.text          && this.text         .isValid()
            && this.x             && this.x            .isValid()
            && this.y             && this.y            .isValid()
            && this.width         && this.width        .isValid()
            && this.height        && this.height       .isValid()
            && this.font          && this.font         .isValid()
            && this.style         && this.style        .isValid()
            && this.size          && this.size         .isValid()
            && this.alignH        && this.alignH       .isValid()
            && this.alignV        && this.alignV       .isValid()
            && this.lineHeight    && this.lineHeight   .isValid()
            && this.letterSpacing && this.letterSpacing.isValid();
    }



    toValue()
    {
        const text = new TextShapeValue(
            this.nodeId,
            this.text         .toValue(),
            this.x            .toValue(),
            this.y            .toValue(),
            this.width        .toValue(),
            this.height       .toValue(),
            this.font         .toValue(),
            this.style        .toValue(),
            this.size         .toValue(),
            this.alignH       .toValue(),
            this.alignV       .toValue(),
            this.lineHeight   .toValue(),
            this.letterSpacing.toValue());

        text.copyCustomParams(this.value);
           
        text.props   = this.props.toValue();
        text.objects = this.value.objects.map(o => o.copy());
        
        return text;
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);
        
        if (this.text         ) this.text         .pushValueUpdates(parse);
        if (this.x            ) this.x            .pushValueUpdates(parse);
        if (this.y            ) this.y            .pushValueUpdates(parse);
        if (this.width        ) this.width        .pushValueUpdates(parse);
        if (this.height       ) this.height       .pushValueUpdates(parse);
        if (this.font         ) this.font         .pushValueUpdates(parse);
        if (this.style        ) this.style        .pushValueUpdates(parse);
        if (this.size         ) this.size         .pushValueUpdates(parse);
        if (this.alignH       ) this.alignH       .pushValueUpdates(parse);
        if (this.alignV       ) this.alignV       .pushValueUpdates(parse);
        if (this.lineHeight   ) this.lineHeight   .pushValueUpdates(parse);
        if (this.letterSpacing) this.letterSpacing.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);
        
        if (this.text         ) this.text         .invalidateInputs(parse, from, force);
        if (this.x            ) this.x            .invalidateInputs(parse, from, force);
        if (this.y            ) this.y            .invalidateInputs(parse, from, force);
        if (this.width        ) this.width        .invalidateInputs(parse, from, force);
        if (this.height       ) this.height       .invalidateInputs(parse, from, force);
        if (this.font         ) this.font         .invalidateInputs(parse, from, force);
        if (this.style        ) this.style        .invalidateInputs(parse, from, force);
        if (this.size         ) this.size         .invalidateInputs(parse, from, force);
        if (this.alignH       ) this.alignH       .invalidateInputs(parse, from, force);
        if (this.alignV       ) this.alignV       .invalidateInputs(parse, from, force);
        if (this.lineHeight   ) this.lineHeight   .invalidateInputs(parse, from, force);
        if (this.letterSpacing) this.letterSpacing.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);
        
        if (this.text         ) this.text         .iterateLoop(parse);
        if (this.x            ) this.x            .iterateLoop(parse);
        if (this.y            ) this.y            .iterateLoop(parse);
        if (this.width        ) this.width        .iterateLoop(parse);
        if (this.height       ) this.height       .iterateLoop(parse);
        if (this.font         ) this.font         .iterateLoop(parse);
        if (this.style        ) this.style        .iterateLoop(parse);
        if (this.size         ) this.size         .iterateLoop(parse);
        if (this.alignH       ) this.alignH       .iterateLoop(parse);
        if (this.alignV       ) this.alignV       .iterateLoop(parse);
        if (this.lineHeight   ) this.lineHeight   .iterateLoop(parse);
        if (this.letterSpacing) this.letterSpacing.iterateLoop(parse);
    }
}


class GPoint
extends GOperator1
{
    x = null;
    y = null;



    constructor(nodeId, options)
    {
        super(POINT, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.x = null;
        this.y = null;
    }



    copy()
    {
        const copy = new GPoint(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.value) copy.value = this.value.copy();
        if (this.x    ) copy.x     = this.x    .copy();
        if (this.y    ) copy.y     = this.y    .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        const x = this.x ? (await this.x.eval(parse)).toValue() : null;
        const y = this.y ? (await this.y.eval(parse)).toValue() : null;


        let input = null;

        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();

            this.value = new PointValue(
                this.nodeId,
                x && this.x.type != NUMBER_VALUE ? x : input.x,
                y && this.y.type != NUMBER_VALUE ? y : input.y);
        }
        else
        {
            this.value = new PointValue(
                this.nodeId, 
                x, 
                y);
        }


        await this.evalObjects(parse);


        this.setUpdateValues(parse, 
        [
            ['value', this.value]
        ]);


        if (this.input)
        { 
            this.x = this.value.x.copy();
            this.y = this.value.y.copy();
        }


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            
            
        this.value.objects = [];


        if (   this.value.x.isValid()
            && this.value.y.isValid())
        {
            const x = this.value.x.value;
            const y = this.value.y.value;

            const point = new FigmaPoint(
                this.nodeId, 
                this.nodeId, 
                this.nodeName, 
                x, 
                y, 
                this.smooth ? this.smooth.value/100 : 1);

            point.createDefaultTransform(x, y);

            this.value.objects = [point];
        }


        await super.evalObjects(parse);
    }



    toValue()
    {
        const point = new PointValue(
            this.nodeId,
            this.x.toValue(),
            this.y.toValue());

        point.objects = 
            this.value.objects
            ? this.value.objects.map(o => o.copy())
            : [];

        return point;
    }



    isValid()
    {
        return super.isValid()
            && this.x && this.x.isValid()
            && this.y && this.y.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.x) this.x.pushValueUpdates(parse);
        if (this.y) this.y.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.x) this.x.invalidateInputs(parse, from, force);
        if (this.y) this.y.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.x) this.x.iterateLoop(parse);
        if (this.y) this.y.iterateLoop(parse);
    }
}


class GPointCorner
extends GOperator1
{
    smooth = null;



    constructor(nodeId, options)
    {
        super(POINT_CORNER, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.smooth = null;
    }



    copy()
    {
        const copy = new GPointCorner(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.value ) copy.value  = this.value .copy();
        if (this.smooth) copy.smooth = this.smooth.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        const input  = this.input  ? (await this.input .eval(parse)).toValue() : null;
        const smooth = this.smooth ? (await this.smooth.eval(parse)).toValue() : null;
        
        if (input)
        {
            this.value        = input;
            this.value.smooth = smooth;
        }
        else
        {
            this.value = PointValue.NaN.copy();
        }


        await this.evalObjects(parse);


        this.setUpdateValues(parse, 
        [
            ['value',  this.value],
            ['smooth', smooth    ]
        ]);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            
            
        this.value.objects = [];


        if (   this.value.x.isValid()
            && this.value.y.isValid())
        {
            const x      = this.value.x.value;
            const y      = this.value.y.value;
            const smooth = this.value.smooth ? this.value.smooth.value/100 : 1;

            const point = new FigmaPoint(this.nodeId, this.nodeId, this.nodeName, x, y, smooth);

            point.createDefaultTransform(x, y);

            this.value.objects = [point];
        }


        await super.evalObjects(parse);
    }



    toValue()
    {
        return this.value.copy();
    //     const point = new PointValue(
    //         this.nodeId,
    //         this.x.toValue(),
    //         this.y.toValue());

    //     point.objects = 
    //         this.value.objects
    //         ? this.value.objects.map(o => o.copy())
    //         : [];

    //     return point;
    }



    isValid()
    {
        return super.isValid()
            && this.smooth && this.smooth.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.smooth) this.smooth.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.smooth) this.smooth.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.smooth) this.smooth.iterateLoop(parse);
    }
}


class GVectorPath
extends GShape
{
    points  = null;
    closed  = null;
    degree  = null;
    winding = null;
    round   = null;



    constructor(nodeId, options)
    {
        super(VECTOR_PATH, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.points  = null;
        this.closed  = null;
        this.degree  = null;
        this.winding = null;
        this.round   = null;
    }



    copy()
    {
        const copy = new GVectorPath(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.points ) copy.points  = this.points .copy();
        if (this.closed ) copy.closed  = this.closed .copy();
        if (this.degree ) copy.degree  = this.degree .copy();
        if (this.winding) copy.winding = this.winding.copy();
        if (this.round  ) copy.round   = this.round  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const points  = this.points  ? (await this.points .eval(parse)).toValue() : null;
        const closed  = this.closed  ? (await this.closed .eval(parse)).toValue() : null;
        const degree  = this.degree  ? (await this.degree .eval(parse)).toValue() : null;
        const winding = this.winding ? (await this.winding.eval(parse)).toValue() : null;
        const round   = this.round   ? (await this.round  .eval(parse)).toValue() : null;


        let input = null;

        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();


            if (   input
                && input.points
                && input.points.items
                && input.points.objects)
            {
                consoleAssert(
                    input.points.items.length == input.points.objects.length,
                    'Vector path points input item count must match object count');

                for (let i = 0; i < input.points.items.length; i++)
                {
                    const item = input.points.items  [i];
                    const obj  = input.points.objects[i];

                    if (item && obj)
                    {
                        item.x = new NumberValue(obj.x);
                        item.y = new NumberValue(obj.y);
                    }
                }
            }


            this.value = new VectorPathValue(
                this.nodeId,
                points && points.items.length > 0 ? points : input.points,
                closed  ?? input.closed,
                degree  ?? input.degree,
                winding ?? input.winding,
                round   ?? input.round);

            this.value.copyCustomParams(input);
        }
        else
        {
            this.value = new VectorPathValue(
                this.nodeId, 
                points, 
                closed, 
                degree, 
                winding, 
                round);
        }

        
        this.setUpdateValues(parse, 
        [
            ['value', this.value]
        ]);


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        if (  !this.points 
            || this.points.items == 0) 
                           this.points  = this.value.points .copy();
        if (!this.closed ) this.closed  = this.value.closed .copy();
        if (!this.degree ) this.degree  = this.value.degree .copy();
        if (!this.winding) this.winding = this.value.winding.copy();
        if (!this.round  ) this.round   = this.value.round  .copy();



        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            

        const points = [];

        if (this.value.points.objects)
        {
            const objPoints = this.value.points.objects.filter(o => o.type == POINT);

            for (const pt of objPoints)
            {
                const p = PointValue.create(this.nodeId, pt.x, pt.y);
                
                if (pt.smooth != null)
                    p.smooth = new NumberValue(pt.smooth);

                points.push(p);
            }
        }


        this.value.objects = [];


        if (   super.baseIsValid()   
            && points.length >= 2
            && this.value.closed .isValid()
            && this.value.degree .isValid()
            && this.value.winding.isValid()
            && this.value.round  .isValid())
        {
            const path = new FigmaVectorPath(
                this.nodeId,
                this.nodeId,
                this.nodeName,
                points,
                this.value.closed .value,
                this.value.degree .value,
                this.value.winding.value,
                this.value.round  .value);

            
            const bounds = getObjBounds([path]);

            let x = bounds.x;
            let y = bounds.y;
            let w = bounds.w;
            let h = bounds.h;

            
            path.createDefaultTransform(x, y);
            path.createDefaultTransformPoints(x, y, w, h);

            this.value.objects.push(path);
        }


        await super.evalObjects(parse);
    }



    toValue()
    {
        const path = new VectorPathValue(
            this.nodeId,
            this.points .toValue(),
            this.closed .toValue(),
            this.degree .toValue(),
            this.winding.toValue(),
            this.round  .toValue());

        path.copyCustomParams(this.value);

        path.props   = this.props.toValue();
        path.objects = this.value.objects.map(o => o.copy());

        return path;
    }



    isValid()
    {
        return super.isValid()
            && this.points  && this.points .isValid()
            && this.closed  && this.closed .isValid()
            && this.degree  && this.degree .isValid()
            && this.winding && this.winding.isValid()
            && this.round   && this.round  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.points ) this.points .pushValueUpdates(parse);
        if (this.closed ) this.closed .pushValueUpdates(parse);
        if (this.degree ) this.degree .pushValueUpdates(parse);
        if (this.winding) this.winding.pushValueUpdates(parse);
        if (this.round  ) this.round  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.points ) this.points .invalidateInputs(parse, from, force);
        if (this.closed ) this.closed .invalidateInputs(parse, from, force);
        if (this.degree ) this.degree .invalidateInputs(parse, from, force);
        if (this.winding) this.winding.invalidateInputs(parse, from, force);
        if (this.round  ) this.round  .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.points ) this.points .iterateLoop(parse);
        if (this.closed ) this.closed .iterateLoop(parse);
        if (this.degree ) this.degree .iterateLoop(parse);
        if (this.winding) this.winding.iterateLoop(parse);
        if (this.round  ) this.round  .iterateLoop(parse);
    }
}


class GVectorVertex
extends GOperator1
{
    x     = null;
    y     = null;
    join  = null;
    cap   = null;
    round = null;



    constructor(nodeId, options)
    {
        super(VECTOR_VERTEX, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.x     = null;
        this.y     = null;
        this.join  = null;
        this.cap   = null;
        this.round = null;
    }



    copy()
    {
        const copy = new GVectorVertex(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.x    ) copy.x     = this.x    .copy();
        if (this.y    ) copy.y     = this.y    .copy();
        if (this.join ) copy.join  = this.join .copy();
        if (this.cap  ) copy.cap   = this.cap  .copy();
        if (this.round) copy.round = this.round.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        const x     = this.x     ? (await this.x    .eval(parse)).toValue() : null;
        const y     = this.y     ? (await this.y    .eval(parse)).toValue() : null;
        const join  = this.join  ? (await this.join .eval(parse)).toValue() : null;
        const cap   = this.cap   ? (await this.cap  .eval(parse)).toValue() : null;
        const round = this.round ? (await this.round.eval(parse)).toValue() : null;


        let input = null;

        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();

            this.value = new VectorVertexValue(
                this.nodeId,
                x     ?? input.x,
                y     ?? input.y,
                join  ?? input.join,
                cap   ?? input.cap,
                round ?? input.round);
        }
        else
        {
            this.value = new VectorVertexValue(
                this.nodeId, 
                x, 
                y, 
                join, 
                cap, 
                round);
        }

       
        await this.evalObjects(parse);


        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            
            
        this.value.objects = [];


        if (   this.value.x    
            && this.value.y    
            && this.value.join 
            && this.value.cap  
            && this.value.round)
        {
            const x     = this.value.x    .value;
            const y     = this.value.y    .value;
            //const join  = this.value.join .value;
            //const cap   = this.value.cap  .value;
            //const round = this.value.round.value;

            const point = new FigmaPoint(this.nodeId, this.nodeId, this.nodeName, x, y);

            point.createDefaultTransform(x, y);

            this.value.objects = [point];
        }


        await super.evalObjects(parse);
    }



    toValue()
    {
        const point = new VectorVertexValue(
            this.nodeId,
            this.x    .toValue(),
            this.y    .toValue(),
            this.join .toValue(),
            this.cap  .toValue(),
            this.round.toValue());

        point.copyCustomParams(this.value);

        point.objects  = this.value.objects.map(o => o.copy());
        point.uniqueId = this.value.uniqueId;

        return point;
    }



    isValid()
    {
        return super.isValid()
            && this.x    .isValid()
            && this.y    .isValid()
            && this.join .isValid()
            && this.cap  .isValid()
            && this.round.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.x    ) this.x    .pushValueUpdates(parse);
        if (this.y    ) this.y    .pushValueUpdates(parse);
        if (this.join ) this.join .pushValueUpdates(parse);
        if (this.cap  ) this.cap  .pushValueUpdates(parse);
        if (this.round) this.round.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.x    ) this.x    .invalidateInputs(parse, from, force);
        if (this.y    ) this.y    .invalidateInputs(parse, from, force);
        if (this.join ) this.join .invalidateInputs(parse, from, force);
        if (this.cap  ) this.cap  .invalidateInputs(parse, from, force);
        if (this.round) this.round.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.x    ) this.x    .iterateLoop(parse);
        if (this.y    ) this.y    .iterateLoop(parse);
        if (this.join ) this.join .iterateLoop(parse);
        if (this.cap  ) this.cap  .iterateLoop(parse);
        if (this.round) this.round.iterateLoop(parse);
    }
}


class GVectorEdge
extends GOperator1
{
    input0       = null;
    input1       = null;

    startTangent = null;
    endTangent   = null;
    
    
    
    constructor(nodeId, options)
    {
        super(VECTOR_EDGE, nodeId, options);
    }



    reset()
    {
        super.reset();
        
        this.input0       = null;
        this.input1       = null;
    
        this.startTangent = null;
        this.endTangent   = null;
    }



    copy()
    {
        const copy = new GVectorEdge(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input0      ) copy.input0       = this.input0      .copy();
        if (this.input1      ) copy.input1       = this.input1      .copy();
        if (this.startTangent) copy.startTangent = this.startTangent.copy();
        if (this.endTangent  ) copy.endTangent   = this.endTangent  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        const input0       = this.input0       ? (await this.input0      .eval(parse)).toValue() : VectorVertexValue.NaN;
        const input1       = this.input1       ? (await this.input1      .eval(parse)).toValue() : VectorVertexValue.NaN;
        const startTangent = this.startTangent ? (await this.startTangent.eval(parse)).toValue() : PointValue.NaN;
        const   endTangent = this.  endTangent ? (await this.  endTangent.eval(parse)).toValue() : PointValue.NaN;


        this.value = new VectorEdgeValue(
            this.nodeId,
            input0,
            input1,
            startTangent,
              endTangent);


        await this.evalObjects(parse);


        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (   !this.options.enabled
            || !this.value.start.isValid()
            || !this.value.end  .isValid())
            return;
            
            
        this.value.objects = [];


        if (   this.value.start.isValid()
            && this.value.end  .isValid())
        {
            const path = new FigmaVectorPath(
                this.nodeId,
                this.nodeId,
                this.nodeName,
                [ this.value.start,
                  this.value.startTangent.isValid() ? this.value.startTangent : this.value.start,
                  this.value.endTangent  .isValid() ? this.value.  endTangent : this.value.end,
                  this.value.end ],
                0,
                2, // cubic
                0,
                0);

            
            const bounds = getObjBounds([path]);

            let x = bounds.x;
            let y = bounds.y;
            let w = bounds.w;
            let h = bounds.h;


            path.createDefaultTransform(x, y);
            path.createDefaultTransformPoints(x, y, w, h);

            this.value.objects.push(path);
        }


        await super.evalObjects(parse);
    }



    toValue()
    {
        const edge = new VectorEdgeValue(
            this.nodeId,
            this.input0 ? this.input0.toValue() : VectorVertexValue.NaN,
            this.input1 ? this.input1.toValue() : VectorVertexValue.NaN,
            this.startTangent.toValue(),
            this.endTangent  .toValue());

        edge.copyCustomParams(this.value);

        edge.uniqueId = this.value.uniqueId;
        edge.objects  = this.value.objects.map(o => o.copy());

        return edge;
    }



    isValid()
    {
        return super.isValid()
            && this.input0      .isValid()
            && this.input1      .isValid()
            && this.startTangent.isValid()
            && this.endTangent  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input0      ) this.input0      .pushValueUpdates(parse);
        if (this.input1      ) this.input1      .pushValueUpdates(parse);
        if (this.startTangent) this.startTangent.pushValueUpdates(parse);
        if (this.endTangent  ) this.endTangent  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.input0      ) this.input0      .invalidateInputs(parse, from, force);
        if (this.input1      ) this.input1      .invalidateInputs(parse, from, force);
        if (this.startTangent) this.startTangent.invalidateInputs(parse, from, force);
        if (this.endTangent  ) this.endTangent  .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input0      ) this.input0      .iterateLoop(parse);
        if (this.input1      ) this.input1      .iterateLoop(parse);
        if (this.startTangent) this.startTangent.iterateLoop(parse);
        if (this.endTangent  ) this.endTangent  .iterateLoop(parse);
    }
}


class GVectorRegion
extends GShape
{
    inputs  = [];

    loops   = null;
    winding = null;



    constructor(nodeId, options)
    {
        super(VECTOR_REGION, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.inputs  = [];

        this.loops   = null;
        this.winding = null;
    }



    copy()
    {
        const copy = new GVectorRegion(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        if (this.winding) copy.winding = this.winding.copy();

        return copy;
    }



    isCached()
    {
        for (const input of this.inputs)
            if (!input.isCached())
                return false;

        return super.isCached()
            && this.winding.isCached();
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        const winding = this.winding ? (await this.winding.eval(parse)).toValue() : null;


        this.loops = new ListValue();


        const loop = new ListValue();

        for (let i = 0; i < this.inputs.length; i++)
        {
            const input = (await this.inputs[i].eval(parse)).toValue();

            if (isListType(input.type))
            {
                const _loop = new ListValue();

                for (const item of input.items)
                {
                    if (item.type == VECTOR_EDGE_VALUE)
                        _loop.items.push(item);
                }

                if (!isEmpty(_loop.items))
                    loops.items.push(_loop);
            }
            else
            {
                consoleAssert(
                     input.type == VECTOR_EDGE_VALUE, 
                    'input.type must be VECTOR_EDGE_VALUE');

                loop.items.push(input);
            }
        }


        if (!isEmpty(loop.items))
            this.loops.items.push(loop);


        this.value = new VectorRegionValue(
            this.nodeId,
            this.loops, 
            winding);


        this.setUpdateValues(parse,
        [
            ['value',   this.value],
            ['winding', winding   ]
        ]);


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (   !this.options.enabled
            || !this.value.isValid())
            return;
            
            
        this.value.objects = [];

        
        if (   this.loops  .isValid()
            && this.winding.isValid())
        {
            const regions = [];


            for (let i = 0; i < this.loops.items.length; i++)
            {
                const loop = this.loops.items[i];


                const points = [];
    
                for (let j = 0; j < loop.items.length; j++)
                {
                    const edge = loop.items[j  ];
                    const next = loop.items[j == loop.items.length-1 ? 0 : j+1];

                    points.push(
                           edge.start.uniqueId == next.start.uniqueId
                        || edge.start.uniqueId == next.end  .uniqueId
                        ? edge.end  
                        : edge.start);
                }


                regions.push(new FigmaVectorPath(
                    this.nodeId,
                    this.nodeId + '/' + i,
                    this.nodeName,
                    points,
                    1,
                    0, // linear
                    this.winding.value,
                    0));
            }
            

            let bounds = getObjBounds(regions);

            let x = bounds.x;
            let y = bounds.y;
            let w = bounds.w;
            let h = bounds.h;


            for (const region of regions)
            {
                region.createDefaultTransform(x, y);
                region.createDefaultTransformPoints(x, y, w, h);

                this.value.objects.push(region);
            }
        }


        await super.evalObjects(parse);
    }



    toValue()
    {
        const region = new VectorRegionValue(
            this.nodeId,
            this.loops  .toValue(),
            this.winding.toValue(),
            this.props  .toValue());

        region.copyCustomParams(this.value);

        region.uniqueId = this.value.uniqueId;
        region.objects  = this.value.objects.map(o => o.copy());

        return region;
    }



    isValid()
    {
        if (!super.isValid())
            return false;
            
        for (const input of this.inputs)
            if (!input.isCached())
                return false;
        
        return this.winding.isValid()
            && this.props  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse));

        if (this.winding) this.winding.pushValueUpdates(parse);
        if (this.props  ) this.props  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        this.inputs.forEach(i => i.invalidateInputs(parse, from, force));

        if (this.winding) this.winding.invalidateInputs(parse, from, force);
        if (this.props  ) this.props  .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        this.inputs.forEach(i => i.iterateLoop(parse));

        if (this.winding) this.winding.iterateLoop(parse);
        if (this.props  ) this.props  .iterateLoop(parse);
    }
}


class GVectorNetwork
extends GShape
{
    inputs = [];



    constructor(nodeId, options)
    {
        super(VECTOR_NETWORK, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.inputs = [];
    }



    copy()
    {
        const copy = new GVectorNetwork(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        return copy;
    }



    isCached()
    {
        for (const input of this.inputs)
            if (!input.isCached())
                return false;

        return super.isCached();
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        const regions = new ListValue();

        for (let i = 0; i < this.inputs.length; i++)
        {
            const input = (await this.inputs[i].eval(parse)).toValue();

            consoleAssert(
                 input.type == VECTOR_REGION_VALUE, 
                'input.type must be VECTOR_REGION_VALUE');

            regions.items.push(input);
        }


        this.value = new VectorNetworkValue(
            this.nodeId,
            regions);


        this.setUpdateValues(parse, [['value', this.value]]);


        await this.evalShapeBase(parse);

        
        await this.evalObjects(parse);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (   !this.options.enabled
            || !this.value.isValid())
            return;
            
            
        this.value.objects = [];


        if (!isEmpty(this.value.regions.items))
        {
            let points  = [];
            let edges   = [];
            let regions = [];


            for (const region of this.value.regions.items)
            {
                if (!isEmpty(region.objects))
                    region.fills = region.objects[0].fills;


                if (region.loops)
                {
                    for (const loop of region.loops.items)
                    {
                        for (const edge of loop.items)
                        {
                            pushUniqueBy(points, edge.start, p => p.uniqueId == edge.start.uniqueId);
                            pushUniqueBy(points, edge.end,   p => p.uniqueId == edge.end  .uniqueId);

                            pushUniqueBy(edges, edge, e => e.uniqueId == edge.uniqueId);
                        }
                    }

                    pushUniqueBy(regions, region, r => r.uniqueId == region.uniqueId);
                }
            }

            
            const network = new FigmaVectorNetwork(
                this.nodeId,
                this.nodeId,
                this.nodeName,
                points,
                edges,
                regions);

            
            const bounds = getObjBounds([network]);

            let x = bounds.x;
            let y = bounds.y;
            let w = bounds.w;
            let h = bounds.h;


            network.createDefaultTransform(x, y);
            network.createDefaultTransformPoints(x, y, w, h);

            this.value.objects.push(network);
        }


        await super.evalObjects(parse);
    }



    toValue()
    {
        const network = new VectorNetworkValue(
            this.nodeId,
            this.regions.toValue());

        network.copyCustomParams(this.value);

        network.uniqueId = this.value.uniqueId;
        network.objects  = this.value.objects.map(o => o.copy());

        return network;
    }



    isValid()
    {
        return super.isValid()
            && this.regions.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse));
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        this.inputs.forEach(i => i.pushValueUpdates(parse));
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        this.inputs.forEach(i => i.iterateLoop(parse));
    }
}


class GShapeGroup
extends GShapeBase
{
    inputs = [];



    constructor(nodeId, options)
    {
        super(SHAPE_GROUP, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.inputs = [];
    }



    copy()
    {
        const copy = new GShapeGroup(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = new ShapeGroupValue(this.nodeId);

        this.value.objects = [];

       
        const inputs = [];
        
        if (this.options.enabled)
        {
            for (let i = 0; i < this.inputs.length; i++)
            {
                const input = (await this.inputs[i].eval(parse)).toValue();

                if (input)            
                {
                    inputs.push(input);

                    if (   input.type == SHAPE_LIST_VALUE
                        || input.type == LIST_VALUE)
                    {
                        for (const item of input.items)
                        {
                            if (!SHAPE_VALUES.includes(item.type))
                                continue;

                            this.value.items.push(item);//.copy());   
                            //this.value.objects.push(...item.objects.map(o => this.copyObject(o, i)));
                        }
                    }
                    else
                    {
                        this.value.items.push(input);//.copy());
                        //this.value.objects.push(...input.objects.map(o => this.copyObject(o, i)));
                    }
                }
            }
        }


        this.setUpdateValues(parse, 
        [
            ['value', this.value]
        ]);


        //await this.evalShapeBase(parse);


        await this.evalObjects(parse, {inputs: inputs});


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            

        if (this.value.items)
        {
            const group = new FigmaShapeGroup(
                this.nodeId,
                this.nodeId,
                this.nodeName);


            for (const input of options.inputs)
            {
                for (let i = 0; i < input.objects.length; i++)
                {
                    const obj = input.objects[i];//.copy();

                    obj.nodeId   = this.nodeId;
                    obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;
                    obj.listId   = -1;

                    group.children.push(obj);
                }
            }


            let bounds = Rect.NaN;

            for (const obj of group.children)
                bounds = expandRect(bounds, obj.getBounds());
    
            group.x      = bounds.x;
            group.y      = bounds.y;
            group.width  = bounds.width;
            group.height = bounds.height;

            
            group.createDefaultSpace();
            group.resetSpace(bounds);

            group.createDefaultTransform(bounds.x, bounds.y);
            group.createDefaultTransformPoints(bounds.x, bounds.y, bounds.width, bounds.height);


            this.value.objects = [group];
        }
        else
        {
            this.value.objects = [];
        }


        await super.evalObjects(parse);
    }



    toValue()
    {
        return this.value.copy();
    }



    isValid()
    {
        if (!super.isValid()) 
            return false;

        for (const input of this.inputs)
            if (!input.isValid())
                return false;

        return true;
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse));
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        this.inputs.forEach(i => i.invalidateInputs(parse, from, force));
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        this.inputs.forEach(i => i.iterateLoop(parse));
    }
}


class GFrame
extends GShape
{
    round    = null;
    children = null;



    constructor(nodeId, options)
    {
        super(FRAME, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.round    = null;
        this.children = null;
    }



    copy()
    {
        const copy = new GFrame(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.round   ) copy.round    = this.round   .copy();
        if (this.children) copy.children = this.children.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const [x, y, width, height] = await this.evalBaseParams(parse);

        const round    = this.round    ? (await this.round   .eval(parse)).toValue() : null;
        let   children = this.children ? (await this.children.eval(parse)).toValue() : null;

        if (   children
            && SHAPE_VALUES.includes(children.type)
            && children.type != SHAPE_LIST_VALUE)
        {
            const objects    = children.objects;
            children         = new ListValue([children]);
            children.objects = objects;
        }


        let input = null;

        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();

            this.value = new FrameValue(
                this.nodeId,
                x        ?? input.x,
                y        ?? input.y,
                width    ?? input.width,
                height   ?? input.height,
                round    ?? input.round,
                children ?? input.children);
        }
        else
        {
            this.value = new FrameValue(
                this.nodeId, 
                x, 
                y, 
                width,
                height, 
                round, 
                children);
        }


        this.setUpdateValues(parse, 
        [
            ['value', this.value]
        ]);


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        if (!this.x       ) this.x        = this.value.x       .copy();
        if (!this.y       ) this.y        = this.value.y       .copy();
        if (!this.width   ) this.width    = this.value.width   .copy();
        if (!this.height  ) this.height   = this.value.height  .copy();
        if (!this.round   ) this.round    = this.value.round   .copy();
        if (!this.children) this.children = this.value.children.copy();


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            

        if (   this.value.x
            && this.value.y
            && this.value.width
            && this.value.height
            && this.value.round)
        {
            let   x = this.value.x     .value;
            let   y = this.value.y     .value;
            let   w = this.value.width .value;
            let   h = this.value.height.value;
            const r = Math.max(0, this.value.round.value);


            const frame = new FigmaFrame(
                this.nodeId,
                this.nodeId,
                this.nodeName,
                x, y, w, h, r);


            //console.log('this.value.objects =', [...this.value.objects]);
            for (let i = 0; i < this.value.objects.length; i++)
                this.addChildObject(frame.children, this.value.objects[i]);


            frame.createDefaultTransform(x, y);
            frame.createDefaultTransformPoints(x, y, w, h);
        
            this.value.objects = [frame];

            
            this.setUpdateValues(parse, 
            [
                ['nChildren', new NumberValue(frame.children.length)]
            ], 
            true);
        }


        await super.evalObjects(parse);
    }



    addChildObject(objects, _obj)
    {
        const obj = copyFigmaObject(_obj);
                    
        obj.nodeId   = this.nodeId;
        obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;
        obj.listId   = -1;
        
        objects.push(obj);
    }



    toValue()
    {
        return this.value.copy();
    }



    isValid()
    {
        return super.isValid()
            && this.round    && this.round   .isValid()
            && this.children && this.children.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.round   ) this.round   .pushValueUpdates(parse);
        if (this.children) this.children.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.round   ) this.round   .invalidateInputs(parse, from, force);
        if (this.children) this.children.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.round   ) this.round   .iterateLoop(parse);
        if (this.children) this.children.iterateLoop(parse);
    }
}


class GApply
extends GShape
{
    replace;



    constructor(nodeId, options)
    {
        super(SHAPE_APPLY, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.replace = null;
    }



    copy()
    {
        const copy = new GApply(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.replace) copy.replace = this.replace.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        const [, , , ] = await this.evalBaseParams(parse);
        const replace  = (await this.replace.eval(parse)).toValue();



        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            this.value = input.copy();

            if (this.options.enabled)
                await this.evalShapeBase(parse, replace.value == 0, input);

            await this.evalObjects(parse);
        }
        else
        {
            await this.evalShapeBase(parse); // to updated anything connected to styles
            this.value = NullValue.copy();
        }

       
        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (this.value.isValid())
        {
            this.value.objects = 
                   this.input 
                && this.input.value
                ? this.input.value.objects.map(o => o.copy()) 
                : [];
        }

            
        for (const obj of this.value.objects)
        {
            obj.nodeId   = this.nodeId;
            obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;

            if (this.options.enabled)
            {
                obj.fills    = [];
                obj.strokes  = [];
                obj.effects  = [];

                obj.maskType = 0;
            }
        }

        
        await super.evalObjects(parse);
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }
}


class GShapeBoolean
extends GShapeBase
{
    input     = null;

    operation = null
    children  = null;



    constructor(nodeId, options)
    {
        super(BOOLEAN, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.input     = null;
        this.operation = null;
        this.children  = null;
    }



    copy()
    {
        const copy = new GShapeBoolean(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        if (this.operation) copy.operation = this.operation.copy();
        if (this.children ) copy.children  = this.children .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        await this.evalBaseParams(parse);

        const operation = this.operation ? (await this.operation.eval(parse)).toValue() : null;
        let   children  = this.children  ? (await this.children .eval(parse)).toValue() : null;


        if (   children
            && SHAPE_VALUES.includes(children.type)
            && children.type != SHAPE_LIST_VALUE)
            children = new ListValue([children]);


        let input = null;

        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();

            this.value = new ShapeBooleanValue(
                this.nodeId,
                operation ?? input.operation,
                children  ?? input.children);
        }
        else
        {
            this.value = new ShapeBooleanValue(
                this.nodeId, 
                operation,
                children);
        }


        this.setUpdateValues(parse,
        [
            ['value',     this.value          ],
            ['operation', this.value.operation],
            ['children',  this.value.children ]
        ]);


        await this.evalShapeBase(parse);

        await this.evalObjects(parse);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            

        if (this.value.children)
        {
            const bool = new FigmaBoolean(
                this.nodeId,
                this.nodeId,
                this.nodeName,
                this.operation);


            if (this.children.objects)
            {
                for (let i = 0; i < this.children.objects.length; i++)
                {
                    const obj    = this.children.objects[i].copy();
                    obj.nodeId   = this.nodeId;
                    obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;
                    obj.listId   = -1;
                    bool.children.push(obj);
                }
            }


            this.value.objects = [bool];

            this.updateValues.push(['nObjects', new NumberValue(
                this.children.objects 
                ? this.children.objects.length
                : 0)]);
        }
        else
        {
            this.value.objects = [];
            this.updateValues.push(['nObjects', new NumberValue(0)]);
        }

        
        await super.evalObjects(parse);
    }



    toValue()
    {
        return this.value.copy();
    }



    isValid()
    {
        return super.isValid()
            && this.children.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input   ) this.input   .pushValueUpdates(parse);
        if (this.children) this.children.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.input   ) this.input   .invalidateInputs(parse, from, force);
        if (this.children) this.children.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input   ) this.input   .iterateLoop(parse);
        if (this.children) this.children.iterateLoop(parse);
    }
}














class GRender
extends GShapeBase
{
    inputs = [];

    retain = null;

    finalize;



    constructor(nodeId, options)
    {
        super(RENDER, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.inputs = [];
        this.retain = null;
    }



    copy()
    {
        const copy = new GRender(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        const retain   = (await this.retain.eval(parse)).toValue();
        const finalize = this.finalize.value > 0;


        this.value = new ListValue();

        this.value.objects = [];


        for (let i = 0, o = 0; i < this.inputs.length; i++)
        {
            await this.inputs[i].eval(parse);

            const objects = getValidObjects(this.inputs[i].value);
        
            
            if (   this.options.enabled
                && (   finalize
                    || retain.value == 1))
            {
                for (let j = 0; j < objects.length; j++, o++)
                {
                    let obj = objects[j];

                    //obj = copyFigmaObject(obj);

                    obj.nodeId   = this.nodeId;
                    obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;
                    obj.listId   = -1;

                    if (  (   !isEmpty(obj.fills  )
                           || !isEmpty(obj.strokes))
                        && !obj.isDeco)
                            obj.retain = finalize ? 2 : 1;
                            
                    this.value.objects.push(obj);
                }
            }
        }


        this.setUpdateValues(parse, [['', NullValue]]);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return super.isValid()
            && !this.inputs.find(i => !i.isValid())
            && this.retain && this.retain.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse));

        if (this.retain) this.retain.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        this.inputs.forEach(i => i.invalidateInputs(parse, from, force));

        if (this.retain) this.retain.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        this.inputs.forEach(i => i.iterateLoop(parse));

        if (this.retain) this.retain.iterateLoop(parse);
    }
}


class GMove
extends GOperator1
{
    moveType    = null;
    x           = null;
    y           = null;
    affectSpace = null;
    showCenter  = null;
    
    

    constructor(nodeId, options)
    {
        super(MOVE, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.moveType    = null;
        this.x           = null;
        this.y           = null;
        this.affectSpace = null;
        this.showCenter  = null;
    }



    copy()
    {
        const copy = new GMove(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.moveType   ) copy.moveType    = this.moveType   .copy();
        if (this.x          ) copy.x           = this.x          .copy();
        if (this.y          ) copy.y           = this.y          .copy();
        if (this.affectSpace) copy.affectSpace = this.affectSpace.copy();
        if (this.showCenter ) copy.showCenter  = this.showCenter .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const moveType    = this.moveType    ? (await this.moveType   .eval(parse)).toValue() : null;
        const x           = this.x           ? (await this.x          .eval(parse)).toValue() : null;
        const y           = this.y           ? (await this.y          .eval(parse)).toValue() : null;
        const affectSpace = this.affectSpace ? (await this.affectSpace.eval(parse)).toValue() : null;
        const showCenter  = this.showCenter  ? (await this.showCenter .eval(parse)).toValue() : null;


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();

            if (this.value)
                this.value.nodeId = this.nodeId;
        }
        else
        {
            this.value = NullValue.copy();
        }


        await this.evalObjects(
            parse, 
            {
                moveType:    moveType,
                x:           x, 
                y:           y,
                showCenter:  showCenter,
                affectSpace: affectSpace
            });


        this.setUpdateValues(parse,
        [
            ['type',        this.outputType()],
            ['moveType',    moveType         ],
            ['x',           x                ],
            ['y',           y                ],
            ['affectSpace', affectSpace      ],
            ['showCenter',  showCenter       ]
        ]);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (   this.value
            && this.value.isValid()
            && options.moveType
            && options.x
            && options.y
            && options.affectSpace
            && options.showCenter)
        {
            this.value.objects = getValidObjects(this.input.value);

            if (isListType(this.value.type))
            {
                for (let i = 0; i < this.value.items.length; i++)
                    this.value.items[i].objects = this.value.objects.filter(o => o.itemIndex == i);
            }
            // else if (this.value.type == SHAPE_GROUP_VALUE)
            // {
            //     const group = this.value.objects[0];

            //     for (let i = 0; i < group.children.length; i++)
            //         group.children[i].objects = this.value.objects.filter(o => o.itemIndex == i);
            // }
    
            
            const moveType    = options.moveType   .value;
            const x           = options.x          .value;
            const y           = options.y          .value;
            const affectSpace = options.affectSpace.value;
            const showCenter  = options.showCenter .value;


            const _a = y/360*Tau;
            const _v = vector(_a, x);
            
            const _x = moveType == 0 ? x : _v.x;
            const _y = moveType == 0 ? y : _v.y;


            const xform = 
                moveType == 0
                ? createTransform(_x, _y)
                : mulm3m3(
                    createTransform(_x, _y),
                    createRotateTransform(-_a)); // for vector movement

            for (const obj of this.value.objects)
            {
                obj.nodeId   = this.nodeId;
                obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;

                if (this.options.enabled)
                    obj.applyTransform(xform, affectSpace > 0);
            }


            if (   this.value.type == VECTOR_PATH_VALUE
                && this.value.objects
                && this.value.objects.length > 0)
            {
                for (let i = 0; i < this.value.objects[0].points.length; i++)
                {
                    const p = this.value.objects[0].points[i].toPoint();
    
                    this.value.points.objects[i].x = p.x;
                    this.value.points.objects[i].y = p.y;
                }
            }


            if (showCenter > 0)
            {
                const objects = [...this.value.objects]; // avoids infinite growth
                objects.forEach(o => addObjectCenter(this, o, parse.viewportZoom));
            }
        }
        
        
        await super.evalObjects(parse);
    }



    toValue()
    {
        return this.value
        ? this.value.copy()
        : null;
    }
    
    
    
    isValid()
    {
        return super.isValid()
            && this.moveType    && this.moveType   .isValid()
            && this.x           && this.x          .isValid()
            && this.y           && this.y          .isValid()
            && this.affectSpace && this.affectSpace.isValid()
            && this.showCenter  && this.showCenter .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.moveType   ) this.moveType   .pushValueUpdates(parse);
        if (this.x          ) this.x          .pushValueUpdates(parse);
        if (this.y          ) this.y          .pushValueUpdates(parse);
        if (this.affectSpace) this.affectSpace.pushValueUpdates(parse);
        if (this.showCenter ) this.showCenter .pushValueUpdates(parse);
    }



   invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.moveType   ) this.moveType   .invalidateInputs(parse, from, force);
        if (this.x          ) this.x          .invalidateInputs(parse, from, force);
        if (this.y          ) this.y          .invalidateInputs(parse, from, force);
        if (this.affectSpace) this.affectSpace.invalidateInputs(parse, from, force);
        if (this.showCenter ) this.showCenter .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.moveType   ) this.moveType   .iterateLoop(parse);
        if (this.x          ) this.x          .iterateLoop(parse);
        if (this.y          ) this.y          .iterateLoop(parse);
        if (this.affectSpace) this.affectSpace.iterateLoop(parse);
        if (this.showCenter ) this.showCenter .iterateLoop(parse);
    }
}


class GAffine
extends GOperator1
{
    showCenter  = null;
    affectSpace = null;



    constructor(type, nodeId, options)
    {
        super(type, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.showCenter  = null;
        this.affectSpace = null;
    }



    copyBase(base)
    {
        super.copyBase(base);

        if (base.showCenter ) this.showCenter  = base.showCenter .copy();
        if (base.affectSpace) this.affectSpace = base.affectSpace.copy();
    }



    async evalBaseParams(parse)
    {
        const showCenter  = this.showCenter  ? (await this.showCenter .eval(parse)).toValue() : null;
        const affectSpace = this.affectSpace ? (await this.affectSpace.eval(parse)).toValue() : null;

        return [showCenter, affectSpace];
    }



    async evalAffineObjects(parse, options, scaleCorners, scaleStyle, getXform)
    {
        if (   !this.value
            || !this.value.isValid())
            return Rect.NaN;


        this.value.objects = getValidObjects(this.input.value);
        
        if (isListType(this.value.type))
        {
            for (let i = 0; i < this.value.items.length; i++)
                this.value.items[i].objects = this.value.objects.filter(o => o.itemIndex == i);
        }


        const bounds = getObjBounds(this.value.objects);
        const xform  = getXform();


        for (const obj of this.value.objects)
        {
            obj.nodeId   = this.nodeId;
            obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;


            if (this.options.enabled)
            {
                obj.applyTransform(xform, options.affectSpace.value > 0);

                obj.scaleCorners *= Math.abs(scaleCorners);
                obj.scaleStyle   *= Math.abs(scaleStyle  );

                
                if (obj.type == TEXT_SHAPE)
                {
                    const sx = Math.sqrt(sqr(xform[0][0]) + sqr(xform[0][1]));
                    const sy = Math.sqrt(sqr(xform[1][0]) + sqr(xform[1][1]));

                    obj.size *= Math.min(sx, sy);
                }
            }
        }


        if (   this.value.type == VECTOR_PATH_VALUE
            && this.value.objects
            && this.value.objects.length > 0)
        {
            for (let i = 0; i < this.value.objects[0].points.length; i++)
            {
                const p = this.value.objects[0].points[i].toPoint();

                this.value.points.objects[i].x = p.x;
                this.value.points.objects[i].y = p.y;
            }
        }


        if (options.showCenter.value > 0)
        {
            const objects = [...this.value.objects]; // avoids infinite growth
            objects.forEach(o => addObjectCenter(this, o, parse.viewportZoom));
        }


        return bounds;
    }



    isValid()
    {
        return super.isValid()
            && this.showCenter  && this.showCenter .isValid()
            && this.affectSpace && this.affectSpace.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.showCenter ) this.showCenter .pushValueUpdates(parse);
        if (this.affectSpace) this.affectSpace.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.showCenter ) this.showCenter .invalidateInputs(parse, from, force);
        if (this.affectSpace) this.affectSpace.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.showCenter ) this.showCenter .iterateLoop(parse);
        if (this.affectSpace) this.affectSpace.iterateLoop(parse);
    }
}


class GRotate
extends GAffine
{
    angle = null;



    constructor(nodeId, options)
    {
        super(ROTATE, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.angle = null;
    }



    copy()
    {
        const copy = new GRotate(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.angle) copy.angle = this.angle.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const angle = this.angle ? (await this.angle.eval(parse)).toValue() : null;

        const [showCenter, affectSpace] = await this.evalBaseParams(parse);


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();

            if (this.value)
                this.value.nodeId = this.nodeId;
        }
        else
        {
            this.value = NullValue.copy();
        }

       
        const _bounds = await this.evalObjects(
            parse, 
            {
                angle:       angle, 
                showCenter:  showCenter,
                affectSpace: affectSpace
            });

        
        const bounds = new RectangleValue(
            this.nodeId,
            new NumberValue(_bounds.x     ), 
            new NumberValue(_bounds.y     ), 
            new NumberValue(_bounds.width ),
            new NumberValue(_bounds.height),
            new NumberValue(0));


        this.setUpdateValues(parse,
        [
            ['type',        this.outputType()],
            ['angle',       angle            ],
            ['showCenter',  showCenter       ],
            ['affectSpace', affectSpace      ],
            ['bounds',      bounds           ]
        ]);


        this.validate();

        return this;
    }



    async evalObjects(parse, options)
    {
        const a     = options.angle.value/360*Tau;
        const xform = createRotateTransform(a);

        return await this.evalAffineObjects(
            parse,
            options, 
            1, 
            1,
            () => xform);
    }



    toValue()
    {
        return this.value
        ? this.value.copy()
        : null;
    }
    
    
    
    isValid()
    {
        return super.isValid()
            && this.angle && this.angle.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.angle) this.angle.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force)

        if (this.angle) this.angle.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.angle) this.angle.iterateLoop(parse);
    }
}


class GScale
extends GAffine
{
    scaleX        = null;
    scaleY        = null;
    affectCorners = null;
    affectStyle   = null;

    

    constructor(nodeId, options)
    {
        super(SCALE, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.scaleX        = null;
        this.scaleY        = null;
        this.affectCorners = null;
        this.affectStyle   = null;
    }



    copy()
    {
        const copy = new GScale(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.scaleX       ) copy.scaleX        = this.scaleX       .copy();
        if (this.scaleY       ) copy.scaleY        = this.scaleY       .copy();
        if (this.affectCorners) copy.affectCorners = this.affectCorners.copy();
        if (this.affectStyle  ) copy.affectStyle   = this.affectStyle  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const scaleX        = this.scaleX        ? (await this.scaleX       .eval(parse)).toValue() : null;
        const scaleY        = this.scaleY        ? (await this.scaleY       .eval(parse)).toValue() : null;
        const affectCorners = this.affectCorners ? (await this.affectCorners.eval(parse)).toValue() : null;
        const affectStyle   = this.affectStyle   ? (await this.affectStyle  .eval(parse)).toValue() : null;

        const [showCenter, affectSpace] = await this.evalBaseParams(parse);


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();

            if (this.value)
                this.value.nodeId = this.nodeId;
        }
        else
        {
            this.value = NullValue.copy();
        }

       
        const _bounds = await this.evalObjects(
            parse, 
            {
                scaleX:        scaleX, 
                scaleY:        scaleY, 
                showCenter:    showCenter,
                affectSpace:   affectSpace,
                affectCorners: affectCorners,
                affectStyle:   affectStyle
            });


        const bounds = new RectangleValue(
            this.nodeId,
            new NumberValue(_bounds.x     ), 
            new NumberValue(_bounds.y     ), 
            new NumberValue(_bounds.width ),
            new NumberValue(_bounds.height),
            new NumberValue(0));


        this.setUpdateValues(parse,
        [
            ['type',          this.outputType()],
            ['scaleX',        scaleX           ],
            ['scaleY',        scaleY           ],
            ['showCenter',    showCenter       ],
            ['affectSpace',   affectSpace      ],
            ['affectCorners', affectCorners    ],
            ['affectStyle',   affectStyle      ],
            ['bounds',        bounds           ]
        ]);
        

        this.validate();

        return this;
    }



    async evalObjects(parse, options)
    {
        let sx = hardZero(options.scaleX.value / 100);
        let sy = hardZero(options.scaleY.value / 100);

        const scale = Math.min(sx, sy);

        return await this.evalAffineObjects(
            parse,
            options, 
            this.affectCorners.value > 0 ? scale : 1,
            this.affectStyle  .value > 0 ? scale : 1,
            () => [[sx, 0,  0],
                   [0,  sy, 0],
                   [0,  0,  1]]);
    }



    isValid()
    {
        return super.isValid()
            && this.scaleX        && this.scaleX       .isValid()
            && this.scaleY        && this.scaleY       .isValid()
            && this.affectCorners && this.affectCorners.isValid()
            && this.affectStyle   && this.affectStyle  .isValid();
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.scaleX       ) this.scaleX       .pushValueUpdates(parse);
        if (this.scaleY       ) this.scaleY       .pushValueUpdates(parse);
        if (this.affectCorners) this.affectCorners.pushValueUpdates(parse);
        if (this.affectStyle  ) this.affectStyle  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.scaleX       ) this.scaleX       .invalidateInputs(parse, from, force);
        if (this.scaleY       ) this.scaleY       .invalidateInputs(parse, from, force);
        if (this.affectCorners) this.affectCorners.invalidateInputs(parse, from, force);
        if (this.affectStyle  ) this.affectStyle  .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.scaleX       ) this.scaleX       .iterateLoop(parse);
        if (this.scaleY       ) this.scaleY       .iterateLoop(parse);
        if (this.affectCorners) this.affectCorners.iterateLoop(parse);
        if (this.affectStyle  ) this.affectStyle  .iterateLoop(parse);
    }
}


class GSkew
extends GAffine
{
    skewX = null;
    skewY = null;



    constructor(nodeId, options)
    {
        super(SKEW, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.skewX = null;
        this.skewY = null;
    }



    copy()
    {
        const copy = new GSkew(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.skewX) copy.skewX = this.skewX.copy();
        if (this.skewY) copy.skewY = this.skewY.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const skewX = this.skewX ? (await this.skewX.eval(parse)).toValue() : null;
        const skewY = this.skewY ? (await this.skewY.eval(parse)).toValue() : null;

        const [showCenter, affectSpace] = await this.evalBaseParams(parse);


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();

            if (this.value)
                this.value.nodeId = this.nodeId;
        }
        else
        {
            this.value = NullValue.copy();
        }

        
        const _bounds = await this.evalObjects(
            parse, 
            {
                skewX:       skewX, 
                skewY:       skewY, 
                showCenter:  showCenter,
                affectSpace: affectSpace
            });


        const bounds = new RectangleValue(
            this.nodeId,
            new NumberValue(_bounds.x     ), 
            new NumberValue(_bounds.y     ), 
            new NumberValue(_bounds.width ),
            new NumberValue(_bounds.height),
            new NumberValue(0));


        this.setUpdateValues(parse,
        [
            ['type',        this.outputType()],
            ['skewX',       skewX            ],
            ['skewY',       skewY            ],
            ['showCenter',  showCenter       ],
            ['affectSpace', affectSpace      ],
            ['bounds',      bounds           ]
        ]);


        this.validate();

        return this;
    }



    async evalObjects(parse, options)
    {
        const sx = -options.skewX.value / 100;
        const sy = -options.skewY.value / 100;

        return await this.evalAffineObjects(
            parse,
            options, 
            1, 1,
            () => [[1,  sx, 0],
                   [sy, 1,  0],
                   [0,  0,  1]]);
    }



    isValid()
    {
        return super.isValid()
            && this.skewX && this.skewX.isValid()
            && this.skewY && this.skewY.isValid();
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);GVectorPath

        if (this.skewX) this.skewX.pushValueUpdates(parse);
        if (this.skewY) this.skewY.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.skewX) this.skewX.invalidateInputs(parse, from, force);
        if (this.skewY) this.skewY.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);GVectorPath

        if (this.skewX) this.skewX.iterateLoop(parse);
        if (this.skewY) this.skewY.iterateLoop(parse);
    }
}


class GCenter
extends GOperator1
{
    centerX    = null;
    centerY    = null;
    showCenter = null;



    constructor(nodeId, options)
    {
        super(CENTER, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.centerX    = null;
        this.centerY    = null;
        this.showCenter = null;
    }



    copy()
    {
        const copy = new GMove(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.centerX   ) copy.centerX    = this.centerX   .copy();
        if (this.centerY   ) copy.centerY    = this.centerY   .copy();
        if (this.showCenter) copy.showCenter = this.showCenter.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const centerX    = this.centerX    ? (await this.centerX   .eval(parse)).toValue() : null;
        const centerY    = this.centerY    ? (await this.centerY   .eval(parse)).toValue() : null;
        const showCenter = this.showCenter ? (await this.showCenter.eval(parse)).toValue() : null;


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();

            if (this.value)
                this.value.nodeId = this.nodeId;
        }
        else
        {
            this.value = NullValue.copy();
        }

        
        await this.evalObjects(
            parse, 
            {
                centerX:    centerX, 
                centerY:    centerY,
                showCenter: showCenter
            });


        this.setUpdateValues(parse,
        [
            ['centerX',    centerX   ],
            ['centerY',    centerY   ],
            ['showCenter', showCenter]
        ]);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (   this.value
            && this.value.isValid())
        {
            this.value.objects = getValidObjects(this.input.value);

            
            const centerX     = options.centerX   .value;
            const centerY     = options.centerY   .value;
            const showCenter  = options.showCenter.value;
     
            const cx          = centerX/100;
            const cy          = centerY/100;


            const bounds      = getObjBounds(this.value.objects);

            const singlePoint =  
                   this.value.objects.length  == 1 
                && this.value.objects[0].type == POINT;


            for (const obj of this.value.objects)
            {
                obj.nodeId   = this.nodeId;
                obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;

                if (this.options.enabled)
                    obj.resetSpace(bounds, singlePoint, cx, cy);
            }


            if (showCenter > 0)
            {
                const objects = [...this.value.objects]; // avoids infinite growth
                objects.forEach(o => addObjectCenter(this, o, parse.viewportZoom));
            }
        }
        
        
        await super.evalObjects(parse);
    }



    toValue()
    {
        return this.value
            ? this.value.copy()
            : null;
    }
    
    
    
    isValid()
    {
        return super.isValid()
            && this.centerX    && this.centerX   .isValid()
            && this.centerY    && this.centerY   .isValid()
            && this.showCenter && this.showCenter.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.centerX   ) this.centerX   .pushValueUpdates(parse);
        if (this.centerY   ) this.centerY   .pushValueUpdates(parse);
        if (this.showCenter) this.showCenter.pushValueUpdates(parse);
    }



   invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.centerX   ) this.centerX   .invalidateInputs(parse, from, force);
        if (this.centerY   ) this.centerY   .invalidateInputs(parse, from, force);
        if (this.showCenter) this.showCenter.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.centerX   ) this.centerX   .iterateLoop(parse);
        if (this.centerY   ) this.centerY   .iterateLoop(parse);
        if (this.showCenter) this.showCenter.iterateLoop(parse);
    }
}


class GResetTransform
extends GOperator1
{
    showCenter = null;



    constructor(nodeId, options)
    {
        super(RESET_XFORM, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.showCenter = null;
    }



    copy()
    {
        const copy = new GResetTransform(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.showCenter) copy.showCenter = this.showCenter.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const showCenter = this.showCenter ? (await this.showCenter.eval(parse)).toValue() : null;


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();

            if (this.value)
                this.value.nodeId = this.nodeId;
        }
        else
            this.value = NullValue.copy();

        
        await this.evalObjects(parse, { showCenter: showCenter });


        this.setUpdateValues(parse,
        [
            ['showCenter', showCenter]
        ]);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (   this.value
            && this.value.isValid())
        {
            this.value.objects = getValidObjects(this.input.value);


            const showCenter = options.showCenter.value;


            const bounds = getObjBounds(this.value.objects);

            const singlePoint =
                   this.value.objects.length  == 1 
                && this.value.objects[0].type == POINT;


            for (const obj of this.value.objects)
            {
                obj.nodeId   = this.nodeId;
                obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;

                if (this.options.enabled)
                {
                    obj.createDefaultSpace();
                    obj.resetSpace(bounds, singlePoint);
                }
            }


            if (showCenter)
            {
                const objects = [...this.value.objects]; // avoids infinite growth
                objects.forEach(o => addObjectCenter(this, o, parse.viewportZoom));
            }
        }
        
        
        await super.evalObjects(parse);
    }



    toValue()
    {
        return this.value
        ? this.value.copy()
        : null;
    }
    
    
    
    isValid()
    {
        return super.isValid()
            && this.showCenter && this.showCenter.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.showCenter) this.showCenter.pushValueUpdates(parse);
    }



   invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.showCenter) this.showCenter.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.showCenter) this.showCenter.iterateLoop(parse);
    }
}


class GMeasurePoints
extends GOperator2
{
    distance = null;
    angle    = null;


    
    constructor(nodeId, options)
    {
        super(MEASURE_POINTS, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.distance = null;
        this.angle    = null;
    }



    copy()
    {
        const copy = new GMeasurePoints(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.distance) copy.distance = this.distance.copy();
        if (this.angle   ) copy.angle    = this.angle   .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        if (   this.input0
            && this.input1)
        {
            const input0 = this.input0 ? (await this.input0.eval(parse)).toValue() : null;
            const input1 = this.input1 ? (await this.input1.eval(parse)).toValue() : null;

            if (   input0
                && input1)
            {
                // console.log('input0 =', input0.toPoint());
                // console.log('input1 =', input1.toPoint());
                // console.log('');

                const dist = distance(input0.toPoint(), input1.toPoint());

                let ang = angle(subv(input1.toPoint(), input0.toPoint()));
                if (ang > Tau/2) ang -= Tau;

                this.distance = new NumberValue(dist);
                this.angle    = new NumberValue(ang / Tau * 360);
            }
            else
            {
                this.distance = NumberValue.NaN;
                this.angle    = NumberValue.NaN;
            }
        }
        else
        {
            this.distance = NumberValue.NaN;
            this.angle    = NumberValue.NaN;
        }


        this.setUpdateValues(parse,
        [
            ['distance', this.distance],
            ['angle',    this.angle   ]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.distance && this.distance.isValid()
            && this.angle    && this.angle   .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.distance) this.distance.pushValueUpdates(parse);
        if (this.angle   ) this.angle   .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.distance) this.distance.invalidateInputs(parse, from, force);
        if (this.angle   ) this.angle   .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.distance) this.distance.iterateLoop(parse);
        if (this.angle   ) this.angle   .iterateLoop(parse);
    }
}


class GCircleCenter
extends GOperator3
{
    constructor(nodeId, options)
    {
        super(CIRCLE_CENTER, nodeId, options);
    }


    
    // reset()
    // {
    //     super.reset();
    // }



    copy()
    {
        const copy = new GCircleCenter(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        if (   this.input0
            && this.input1
            && this.input2)
        {
            const input0 = this.input0 ? (await this.input0.eval(parse)).toValue() : null;
            const input1 = this.input1 ? (await this.input1.eval(parse)).toValue() : null;
            const input2 = this.input2 ? (await this.input2.eval(parse)).toValue() : null;

            if (   input0
                && input1
                && input2)
            {
                const pc = circleCenter(
                    input0.toPoint(),
                    input1.toPoint(),
                    input2.toPoint());

                this.value = PointValue.fromPoint(this.nodeId, pc);
            }
            else
            {
                this.value = PointValue.NaN.copy();
            }
        }
        else
        {
            this.value = PointValue.NaN.copy();
        }


        await this.evalObjects(parse);


        this.setUpdateValues(parse, 
        [
            ['value', this.value]
        ]);
        

        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            
            
        this.value.objects = [];


        if (   this.value.x.isValid()
            && this.value.y.isValid())
        {
            const x = this.value.x.value;
            const y = this.value.y.value;

            const point = new FigmaPoint(this.nodeId, this.nodeId, this.nodeName, x, y);

            point.createDefaultTransform(x, y);

            this.value.objects = [point];
        }


        await super.evalObjects(parse);
    }
}


class GIntersectLines
extends GOperator4
{
    segment = null;



    constructor(nodeId, options)
    {
        super(INTERSECT_LINES, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        if (this.segment) this.segment.reset();
    }



    copy()
    {
        const copy = new GIntersectLines(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.segment) copy.segment = this.segment.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const segment = this.segment ? (await this.segment.eval(parse)).toValue() : null;


        if (   this.input0
            && this.input1
            && this.input2
            && this.input3)
        {
            const input0 = this.input0 ? (await this.input0.eval(parse)).toValue() : null;
            const input1 = this.input1 ? (await this.input1.eval(parse)).toValue() : null;
            const input2 = this.input2 ? (await this.input2.eval(parse)).toValue() : null;
            const input3 = this.input3 ? (await this.input3.eval(parse)).toValue() : null;

            if (   input0
                && input1
                && input2
                && input3)
            {
                const p = intersectLines(
                    input0.toPoint(),
                    input1.toPoint(),
                    input2.toPoint(),
                    input3.toPoint(),
                    segment.value != 0);

                this.value = PointValue.fromPoint(this.nodeId, p);
            }
            else
            {
                this.value = PointValue.NaN.copy();
            }
        }
        else
        {
            this.value = PointValue.NaN.copy();
        }


        await this.evalObjects(parse);


        this.setUpdateValues(parse, 
        [
            ['value',   this.value],
            ['segment', segment   ]
        ]);
        

        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            
            
        this.value.objects = [];


        if (   this.value.x.isValid()
            && this.value.y.isValid())
        {
            const x = this.value.x.value;
            const y = this.value.y.value;

            const point = new FigmaPoint(this.nodeId, this.nodeId, this.nodeName, x, y);

            point.createDefaultTransform(x, y);

            this.value.objects = [point];
        }


        await super.evalObjects(parse);
    }



    isValid()
    {
        return super.isValid()
            && this.segment && this.segment.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.segment) this.segment.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.segment) this.segment.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.segment) this.segment.iterateLoop(parse);
    }
}


class GInterpolatePoint
extends GOperator2
{
    amount     = null;
    transform  = null;
    showCenter = null;


    
    constructor(nodeId, options)
    {
        super(INTERPOLATE_POINT, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.amount     = null;
        this.transform  = null;
        this.showCenter = null;
    }



    copy()
    {
        const copy = new GInterpolatePoint(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.amount    ) copy.amount     = this.amount    .copy();
        if (this.transform ) copy.transform  = this.transform .copy();
        if (this.showCenter) copy.showCenter = this.showCenter.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const amount     = this.amount     ? (await this.amount    .eval(parse)).toValue() : null;
        const transform  = this.transform  ? (await this.transform .eval(parse)).toValue() : null;
        const showCenter = this.showCenter ? (await this.showCenter.eval(parse)).toValue() : null;


        if (   this.input0
            && this.input1)
        {
            const input0 = this.input0 ? (await this.input0.eval(parse)).toValue() : null;
            const input1 = this.input1 ? (await this.input1.eval(parse)).toValue() : null;

            if (   input0
                && input1
                && input0.isValid()
                && input1.isValid())
            {
                const p0  = point(input0.objects[0].x, input0.objects[0].y);
                const p1  = point(input1.objects[0].x, input1.objects[0].y);
                const amt = amount.value / 100;

                const p   = lerpv(p0, p1, amt);

                    
                let sp0 = lerpv(input0.objects[0].sp0, input1.objects[0].sp0, amt);
                let sp1 = lerpv(input0.objects[0].sp1, input1.objects[0].sp1, amt);
                let sp2 = lerpv(input0.objects[0].sp2, input1.objects[0].sp2, amt);

                if (transform.value > 0)
                {
                    const l1 = distance(sp0, sp1);
                    const l2 = distance(sp0, sp2);

                    sp0 = clone(p);
                    sp1 = addv(sp0, mulvs(unitv(subv(p1, p0)), l1));
                    sp2 = addv(sp0, crossv(mulvs(unitv(subv(p1, p0)), l2)));
                }


                this.value = new PointValue(this.nodeId, new NumberValue(p.x), new NumberValue(p.y));

                const pt = new FigmaPoint(this.nodeId, this.nodeId, this.nodeName, p.x, p.y);
                pt.createDefaultTransform(p.x, p.y);
                this.value.objects = [pt];

                this.value.objects[0].sp0 = sp0;
                this.value.objects[0].sp1 = sp1;
                this.value.objects[0].sp2 = sp2;


                if (showCenter.value > 0)
                {
                    const objects = [...this.value.objects]; // avoids infinite growth
                    objects.forEach(o => addObjectCenter(this, o, parse.viewportZoom));
                }
            }
        }


        this.setUpdateValues(parse,
        [
            ['amount',     amount    ],
            ['transform',  transform ],
            ['showCenter', showCenter]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.amount     && this.amount    .isValid()
            && this.transform  && this.transform .isValid()
            && this.showCenter && this.showCenter.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.amount    ) this.amount    .pushValueUpdates(parse);
        if (this.transform ) this.transform .pushValueUpdates(parse);
        if (this.showCenter) this.showCenter.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.amount    ) this.amount    .invalidateInputs(parse, from, force);
        if (this.transform ) this.transform .invalidateInputs(parse, from, force);
        if (this.showCenter) this.showCenter.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.amount    ) this.amount    .iterateLoop(parse);
        if (this.transform ) this.transform .iterateLoop(parse);
        if (this.showCenter) this.showCenter.iterateLoop(parse);
    }
}


class GPointOnPath
extends GOperator2
{
    measure    = null;
    amount     = null;
    transform  = null;
    showCenter = null;
    
    
    
    constructor(nodeId, options)
    {
        super(POINT_ON_PATH, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.measure    = null;
        this.amount     = null;
        this.transform  = null;
        this.showCenter = null;
    }



    copy()
    {
        const copy = new GPointOnPath(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.measure   ) copy.measure    = this.measure   .copy();
        if (this.amount    ) copy.amount     = this.amount    .copy();
        if (this.transform ) copy.transform  = this.transform .copy();
        if (this.showCenter) copy.showCenter = this.showCenter.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const measure    = this.measure    ? (await this.measure   .eval(parse)).toValue() : null;
        const amount     = this.amount     ? (await this.amount    .eval(parse)).toValue() : null;
        const transform  = this.transform  ? (await this.transform .eval(parse)).toValue() : null;
        const showCenter = this.showCenter ? (await this.showCenter.eval(parse)).toValue() : null;


        if (   this.input0
            && this.input1)
        {
            const input0 = this.input0 ? (await this.input0.eval(parse)).toValue() : null;
            const input1 = this.input1 ? (await this.input1.eval(parse)).toValue() : null;

            if (   input0
                && input1)
            {
                // const p0  = point(input0.objects[0].x, input0.objects[0].y);
                // const p1  = point(input1.objects[0].x, input1.objects[0].y);
                // const amt = amount.value / 100;

                // const p   = lerpv(p0, p1, amt);

                    
                // let sp0 = lerpv(input0.objects[0].sp0, input1.objects[0].sp0, amt);
                // let sp1 = lerpv(input0.objects[0].sp1, input1.objects[0].sp1, amt);
                // let sp2 = lerpv(input0.objects[0].sp2, input1.objects[0].sp2, amt);

                // if (transform.value > 0)
                // {
                //     const l1 = distance(sp0, sp1);
                //     const l2 = distance(sp0, sp2);

                //     sp0 = clone(p);
                //     sp1 = addv(sp0, mulvs(unitv(subv(p1, p0)), l1));
                //     sp2 = addv(sp0, crossv(mulvs(unitv(subv(p1, p0)), l2)));
                // }


                // this.value = new PointValue(this.nodeId, new NumberValue(p.x), new NumberValue(p.y));

                // const pt = new FigmaPoint(this.nodeId, this.nodeId, this.nodeName, p.x, p.y);
                // pt.createDefaultTransform(p.x, p.y);
                // this.value.objects = [pt];

                // this.value.objects[0].sp0 = sp0;
                // this.value.objects[0].sp1 = sp1;
                // this.value.objects[0].sp2 = sp2;


                // if (showCenter.value > 0)
                // {
                //     const objects = [...this.value.objects]; // avoids infinite growth
                //     objects.forEach(o => addObjectCenter(this, o, parse.viewportZoom));
                // }
            }
        }


        this.setUpdateValues(parse,
        [
            ['measure',    measure   ],
            ['amount',     amount    ],
            ['transform',  transform ],
            ['showCenter', showCenter]
        ]);
        

        this.validate();

        return this;
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.measure   ) this.measure   .pushValueUpdates(parse);
        if (this.amount    ) this.amount    .pushValueUpdates(parse);
        if (this.transform ) this.transform .pushValueUpdates(parse);
        if (this.showCenter) this.showCenter.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.measure   ) this.measure   .invalidateInputs(parse, from, force);
        if (this.amount    ) this.amount    .invalidateInputs(parse, from, force);
        if (this.transform ) this.transform .invalidateInputs(parse, from, force);
        if (this.showCenter) this.showCenter.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.measure   ) this.measure   .iterateLoop(parse);
        if (this.amount    ) this.amount    .iterateLoop(parse);
        if (this.transform ) this.transform .iterateLoop(parse);
        if (this.showCenter) this.showCenter.iterateLoop(parse);
    }
}


class GPlace
extends GOperator1
{
    position   = null;
    transform  = null;
    showCenter = null;
    
    

    constructor(nodeId, options)
    {
        super(PLACE, nodeId, options);
    }



    reset()
    {
        super.reset();
        
        this.position   = null;
        this.transform  = null;
        this.showCenter = null;
    }



    copy()
    {
        const copy = new GPlace(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.position  ) copy.position   = this.position  .copy();
        if (this.transform ) copy.transform  = this.transform .copy();
        if (this.showCenter) copy.showCenter = this.showCenter.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const position   = this.position   ? (await this.position  .eval(parse)).toValue() : null;
        const transform  = this.transform  ? (await this.transform .eval(parse)).toValue() : null;
        const showCenter = this.showCenter ? (await this.showCenter.eval(parse)).toValue() : null;

        if (   this.input
            && position)
        {
            this.value = (await this.input.eval(parse)).toValue();

            if (this.value)
                this.value.nodeId = this.nodeId;
        }
        else
            this.value = null;//NullValue.copy();



        if (   position
            && position.isValid())
            // && position.objects
            // && position.objects.length > 0)
        {
            const p0 = position.toPoint();//point(
                // position/*.objects[0]*/.x, 
                // position/*.objects[0]*/.y);

            const p1 = addv(p0, subv(position/*.objects[0]*/.sp1, position/*.objects[0]*/.sp0));
            const p2 = addv(p0, subv(position/*.objects[0]*/.sp2, position/*.objects[0]*/.sp0));

            await this.evalObjects(
                parse, 
                {
                    transform:  transform,
                    showCenter: showCenter,
                    sp0:        p0,
                    sp1:        p1,
                    sp2:        p2
                });
        }

        
        this.setUpdateValues(parse,
        [
            ['position',   position  ],
            ['transform',  transform ],
            ['showCenter', showCenter]
        ]);


        this.validate();

        return this;
    }



    async evalObjects(parse, options)
    {
        if (   this.value
            && this.value.isValid())
        {
            this.value.objects = getValidObjects(this.input.value);


            const place = createTransform(
                options.sp0 ? options.sp0.x : 0,
                options.sp0 ? options.sp0.y : 0);


            for (const obj of this.value.objects)
            {
                obj.nodeId   = this.nodeId;
                obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;


                if (this.options.enabled)
                {
                    let xform = mulm3m3(
                        createTransform(
                            -obj.sp0.x, 
                            -obj.sp0.y),
                        place);


                    if (   options.transform.value > 0
                        && options.sp0
                        && options.sp1
                        && options.sp2)
                    {
                        const sp = getTransformFromPoints(
                            options.sp0, 
                            options.sp1, 
                            options.sp2);

                        xform = mulm3m3(xform, sp);

                        obj.sp1 = addv(obj.sp0, point(1, 0));
                        obj.sp2 = addv(obj.sp0, point(0, 1));
                    }


                    obj.applyTransform(xform, true);
                }
            }


            if (options.showCenter.value > 0)
            {
                const objects = [...this.value.objects]; // avoids infinite growth
                objects.forEach(o => addObjectCenter(this, o, parse.viewportZoom));
            }
        }
        
        
        await super.evalObjects(parse);
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }
    
    
    
    isValid()
    {
        return super.isValid()
            && this.position   && this.position  .isValid()
            && this.transform  && this.transform .isValid()
            && this.showCenter && this.showCenter.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.position  ) this.position  .pushValueUpdates(parse);
        if (this.transform ) this.transform .pushValueUpdates(parse);
        if (this.showCenter) this.showCenter.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.position  ) this.position  .invalidateInputs(parse, from, force);
        if (this.transform ) this.transform .invalidateInputs(parse, from, force);
        if (this.showCenter) this.showCenter.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.position  ) this.position  .iterateLoop(parse);
        if (this.transform ) this.transform .iterateLoop(parse);
        if (this.showCenter) this.showCenter.iterateLoop(parse);
    }
}



function getTransformFromPoints(p0, p1, p2) 
{
    const dx   = p1.x - p0.x;
    const dy   = p1.y - p0.y;

    const a    = Math.atan2(dy, dx);
  
    const cosa = Math.cos(a);
    const sina = Math.sin(a);


    const sx   = ((p1.y - p0.y) / nozero(p1.x - p0.x));
    const sy   = ((p2.x - p0.x) / nozero(p2.y - p0.y));

    // TODO add skew 

    return [[ cosa,         -sina /** sy*/, 0 ], 
            [ sina /** sx*/, cosa,          0 ], 
            [ 0,             0,             1 ]];
}


class GGroupNode
extends GOperator
{
    paramIds = [];
    params   = [];



    constructor(nodeId, options)
    {
        super(GROUP_NODE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GGroupNode(this.nodeId, this.options);

        copy.copyBase(this);

        copy.params = this.params.map(p => p.copy());

        return copy;
    }



    paramFromId(paramId)
    {
        return this.params[this.paramIds.findIndex(id => id == paramId)];
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.updateValues = [];


        if (!isEmpty(this.params))
        {
            for (let i = 0; i < this.params.length; i++)
            {
                const param = await this.params[i].eval(parse);
                this.setUpdateValues(parse, [[this.paramIds[i], param.toValue()]], true);
            }
        }
        else
            this.setUpdateValues(parse, [['', NullValue]], true);
                
        
        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy() 
             : null;
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse))
        this.params.forEach(p => p.pushValueUpdates(parse))
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        this.inputs.forEach(i => i.invalidateInputs(parse, from, force))
        this.params.forEach(p => p.invalidateInputs(parse, from, force))
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        this.inputs.forEach(i => i.iterateLoop(parse))
        this.params.forEach(p => p.iterateLoop(parse))
    }
}



class GGroupParam
extends GOperator
{
    input = null;
    
    dataType = NULL;



    constructor(nodeId, options)
    {
        super(GROUP_PARAM, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.input    = null;
        this.dataType = null;
    }



    copy()
    {
        const copy = new GGroupParam(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();
        
        copy.dataType = this.dataType;
      
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        if (this.input)
        {
            if (!this.input.value)
                await this.input.eval(parse);

            this.value = this.input.toValue();
        }

        else if (this.dataType != NULL)
            this.value = nanFromType(this.dataType);
        
        else
            this.value = NullValue.copy();


        this.setUpdateValues(parse,
        [
            ['value', this.value]
        ]);


        this.validate();

        return this;
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input) this.input.pushValueUpdates(parse);
    }



    toValue()
    {
        return this.value.copy();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input) this.input.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.input) this.input.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input) this.input.iterateLoop(parse);
    }
}


class GComment
extends GOperator
{
    constructor(nodeId, options)
    {
        super(COMMENT, nodeId, options);
    }


    
    copy()
    {
        const copy = new GComment(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = NullValue.copy();


        this.setUpdateValues(parse, [['', NullValue]]);
        
        
        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy() 
             : null;
    }
}



class GCommentArrow
extends GOperator
{
    constructor(nodeId, options)
    {
        super(COMMENT_ARROW, nodeId, options);
    }


    
    copy()
    {
        const copy = new GCommentArrow(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = NullValue.copy();


        this.setUpdateValues(parse, [['', NullValue]]);
        
        
        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy() 
             : null;
    }
}



class GPanel
extends GOperator
{
    constructor(nodeId, options)
    {
        super(PANEL, nodeId, options);
    }


    
    copy()
    {
        const copy = new GPanel(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = NullValue.copy();


        this.setUpdateValues(parse, [['', NullValue]]);
        
        
        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy() 
             : null;
    }
}



var genFigMessagePosted = false;

var uiMessages          = [];


var figFonts            = [];
var figUniqueFontNames  = [];



// --> from UI
///////////////////////////////////////////////////////////////////////////////////////////////////

var lastMessage = null;


onmessage = function(e)
{
    const msg = JSON.parse(e.data);


    if (msg.cmd == 'returnUiGetValue') // ignore this message in the queue
        return;
    

    if (msg.cmd == 'genRequest')
    {
        if (   lastMessage
            && lastMessage.cmd == 'genRequest')
            return;


        genRequest(msg.request, msg.save);         
    }
    else
    {
        switch (msg.cmd)
        {
            case 'initFonts':        initFonts(msg.fonts, msg.uniqueFontNames); break;
        
            case 'genEndUiMessage':  genEndUiMessage (msg.msgCmd);              break;
            case 'genEndFigMessage': genEndFigMessage();                        break;
        }

        lastMessage = null;
    }


    genPostMessageToUi(
    {
        cmd:   'uiEndGenMessage',
        msgCmd: msg.cmd
    });
};

///////////////////////////////////////////////////////////////////////////////////////////////////



// <-- to UI
///////////////////////////////////////////////////////////////////////////////////////////////////

function genPostMessageToUi(msg)
{
    if (msg == undefined)
    {
        consoleError('undefined message');
        console.trace();
    }

    postMessage(JSON.stringify(msg));
}



function genQueueMessageToUi(msg)
{
    uiMessages.push(msg);
    genPostNextMessageToUi();
}



function genPostNextMessageToUi(msg)
{
    if (!isEmpty(uiMessages))
    //    && !genFigMessagePosted)
    {
        //console.log('yes');
        let msg = uiMessages.shift();

        // while (   !isEmpty(uiMessages)
        //        &&  uiMessages[0].cmd     == 'uiUpdateValuesAndObjects'
        //        &&  uiMessages[0].chunkId == 0)
        // {
        //     const nextFirst = uiMessages.find(m => 
        //            m.cmd     == msg.cmd 
        //         && m.chunkId == 0);

        //     if (nextFirst)
        //     {
        //         while (!isEmpty(uiMessages)
        //             &&  uiMessages[0].cmd           == msg.cmd
        //             &&  uiMessages[0].updateNodeId  == msg.updateNodeId
        //             &&  uiMessages[0].updateParamId == msg.updateParamId
        //             &&  uiMessages[0].cmd.chunkId   >  0)
        //             msg = uiMessages.shift();

        //         msg = uiMessages.shift();
        //     }
        // }

        genPostMessageToUi(msg);
    }
}



function genEndUiMessage(msgCmd)
{
    //console.log('next UI message');
    genPostNextMessageToUi();
}



function genEndFigMessage()
{
    genFigMessagePosted = false;
    
    if (   !isEmpty(lastUpdateValues )
        || !isEmpty(lastUpdateObjects)
        || !isEmpty(lastUpdateStyles ))
        genUpdateValuesAndObjects(lastRequestId, -1, lastUpdateNodeId, lastUpdateParamId, [], [], [], false);

    genPostNextMessageToUi();
}

///////////////////////////////////////////////////////////////////////////////////////////////////


var lastRequestId      = -1;
var lastUpdateNodeId   =  NULL;
var lastUpdateParamId  =  NULL;
var lastUpdateValues   =  [];
var lastUpdateObjects  =  [];
var lastUpdateStyles   =  [];


var curRequestIds      = [];



function initFonts(fonts, uniqueFontNames)
{
    figFonts           = fonts;
    figUniqueFontNames = uniqueFontNames;
}



function genRequest(request, save)
{
    const requestId     = parseInt(request[0]);
    const actionId      = parseInt(request[1]);
    const set           = parseInt(request[2]);

    curRequestIds.push(requestId);


    const settings =
    {
        showAllColorSpaces:  (set >> 0) & 1 != 0,
        logRequests:         (set >> 1) & 1 != 0,
        showTransformPoints: (set >> 2) & 1 != 0
    };


    const updateNodeId  = request[3];
    const updateParamId = request[4];

    const viewportZoom  = request[5];


    const parse = new Parse(
        request, 
        6,
        requestId,
        updateNodeId, 
        updateParamId, 
        viewportZoom,
        settings,
        save);


    const stackOverflowProtect = 100;

    while (   parse.pos < parse.request.length
           && parse.so  < stackOverflowProtect)
        genParse(parse);


    if (settings.logRequests)
        logRequest(parse);


    const    paramNodes = parse.paramNodeIds.map(id => parse.parsedNodes.find(n => n.nodeId == id));
    const topLevelNodes = parse.parsedNodes.filter(n => n.topLevel);

    
    (async () =>
    {
        for (const node of paramNodes) 
        { 
            await node.eval(parse);

            if (parse.stop()) 
            {
                genPostMessageToUi({cmd: 'uiEndRequest', requestId: requestId});
                genPostMessageToUi({cmd: 'uiEndGlobalProgress'});
                return; 
            }
        } 


        if (!parse.stop()) 
        {
            for (const node of topLevelNodes) 
            { 
                await node.eval(parse); 

                if (parse.stop()) 
                {
                    genPostMessageToUi({cmd: 'uiEndRequest', requestId: requestId});
                    genPostMessageToUi({cmd: 'uiEndGlobalProgress'});
                    return; 
                }
            }
        }
        else
        {
            genPostMessageToUi({cmd: 'uiEndRequest', requestId: requestId});
            genPostMessageToUi({cmd: 'uiEndGlobalProgress'});
            return;
        }


        genQueueMessageToUi({cmd: 'uiEndGlobalProgress'});


        if (parse.stop()) return;

        
        for (const node of topLevelNodes) 
            node.pushValueUpdates(parse);
        
        
        for (const node of parse.parsedNodes)
        {
            if (node.options.active === true)
            {
                if (   node.value
                    && node.value.objects)
                    node.value.objects.forEach(o => genPushUpdateObject(parse, o));

                if (node.colorStyle) 
                    genPushUpdateColorStyle(parse, node.colorStyle);
            }
        }


        if (parse.settings.showTransformPoints)
        {
            for (const node of parse.parsedNodes)
            {
                if (   node.options.active === true
                    && node.value)
                {
                    for (const obj of node.value.objects)
                    {
                        if (  !obj.isDeco
                            && obj.xp0
                            && obj.xp1
                            && obj.xp2)
                        {
                            const xp0 = clone(obj.xp0);//.toPoint();
                            const xp1 = clone(obj.xp1);//.toPoint();
                            const xp2 = clone(obj.xp2);//.toPoint();
                            const xp3 = addv(xp2, subv(xp1, xp0));

                            genPushUpdateObject(
                                parse, 
                                createDecoPoly(
                                    node, 
                                    obj.sp0, 
                                    [xp0, xp2, xp3, xp1], 
                                    true,
                                    '1, 2',
                                    [12, 140, 233], 
                                    XFORM_SUFFIX));
                        }
                    }
                }
            }
        }


        genUpdateValuesAndObjects(
            requestId,
            actionId,
            parse.updateNodeId,
            parse.updateParamId,
            parse.updateValues,
            parse.updateObjects,
            parse.updateStyles,
            save);


        genPostMessageToUi(
        {
            cmd:      'uiEndRequest',
            requestId: requestId
        });
    })();
}



function genPushUpdateValue(parse, nodeId, paramId, value)
{
    if (!value)
        return;
    
    // if (  !parse.save
    //     && value.hasInitValue())
    //     return;

    
    removeFromArrayWhere(parse.updateValues, v =>
           v.nodeId     == nodeId
        && v.paramId    == paramId
        && v.value.type == value.type);

        
    parse.updateValues.push(
    {
        nodeId:  nodeId,
        paramId: paramId,
        type:    value.type, // needed to correctly parse NAN_DISPLAY
        value:   value.toJson()
    });
}



function genPushUpdateObject(parse, object)
{
    pushUniqueExcept(
        parse.updateObjects,
        object,
        o =>    o.nodeId   == object.nodeId
             && o.objectId == object.objectId);
}



function genPushUpdateColorStyle(parse, style)
{
    pushUniqueExcept(
        parse.updateStyles,
        style,
        o => o.nodeId == style.nodeId);
}



function clearLastUpdate()
{
    lastRequestId     = -1;
    lastUpdateNodeId  =  NULL;
    lastUpdateParamId =  NULL;

    lastUpdateValues  =  [];
    lastUpdateObjects =  [];
    lastUpdateStyles  =  [];
}



function genUpdateValuesAndObjects(requestId, actionId, updateNodeId, updateParamId, updateValues, updateObjects, updateStyles, save)
{
    if (   isEmpty(updateValues )
        && isEmpty(updateObjects)
        && isEmpty(updateStyles ))
    {
        requestId     = lastRequestId;
        updateNodeId  = lastUpdateNodeId;
        updateParamId = lastUpdateParamId;
        
        updateValues  = lastUpdateValues;
        updateObjects = lastUpdateObjects;
        updateStyles  = lastUpdateStyles;

        clearLastUpdate();
    }
    else if (genFigMessagePosted)
    {
        lastRequestId     = requestId;
        lastUpdateNodeId  = updateNodeId;
        lastUpdateParamId = updateParamId;

        lastUpdateValues  = updateValues;
        lastUpdateObjects = updateObjects;
        lastUpdateStyles  = updateStyles;

        return;
    }


    const nodeIds = filterUnique(updateValues.map(v => v.nodeId));
    const counts  = nodeIds.map(id => updateValues.filter(v => v.nodeId == id).length);


    // send updates in chunks

    const approxNodeChunkSize = 1000000;//20;
    const objChunkSize        = 1000000;//200;
    const styleChunkSize      = 1000000;//20;

    
    let n  = 0; // node
    let o  = 0; // object
    let s  = 0; // style

    let nc = 0; // node chunk count
    let oc = 0; // object chunk count
    let sc = 0; // style chunk count


    let nodeValChunk   = [],
        objChunk       = [],
        styleChunk     = [];

    let nodeValChunkId = 0;

    let isFirstChunk   = true;
        

    genQueueMessageToUi(
    {
        cmd:      'uiInitGlobalProgress',
        requestId: requestId
    });


    while (   n < nodeIds      .length
           || o < updateObjects.length
           || s < updateStyles .length)
    {
        if (n < nodeIds.length)
        {
            nodeValChunk.push(nodeIds[n], counts[n]);

            const values = updateValues.filter(v => v.nodeId == nodeIds[n]);
            values.sort((a, b) => a.paramId - b.paramId);

            for (const v of values)
                nodeValChunk.push(v.paramId, v.type, v.value);

            n++, nc++;
        }


        if (o < updateObjects.length)
        {
            objChunk.push(updateObjects[o].toData());
            o++, oc++;
        }


        if (s < updateStyles.length)
        {
            styleChunk.push(updateStyles[s].toData());
            s++, sc++;
        }


        const chunkNotEmpty =
               nc >= approxNodeChunkSize
            || oc == objChunkSize
            || sc == styleChunkSize;


        if (chunkNotEmpty)
        {
            const isLastChunk =    
                   n >= nodeIds      .length
                && o >= updateObjects.length
                && s >= updateStyles .length
                && (   !isEmpty(nodeValChunk)
                    || !isEmpty(objChunk    )
                    || !isEmpty(styleChunk  ));

            genQueueChunk(
                requestId,
                actionId,
                updateNodeId,
                updateParamId,
                nodeValChunkId++,
                nodeValChunk,
                objChunk,
                styleChunk,
                n,
                nodeIds.length,
                isFirstChunk,
                isLastChunk,
                save);

            nodeValChunk = [];  nc = 0;
            objChunk     = [];  oc = 0;
            styleChunk   = [];  sc = 0;

            isFirstChunk = false;
        }
    }


    const lastChunkNotEmpty =
           !isEmpty(nodeValChunk)
        || !isEmpty(objChunk    )
        || !isEmpty(styleChunk  );


    if (lastChunkNotEmpty)
    {
        genQueueChunk(
            requestId,
            actionId,
            updateNodeId,
            updateParamId,
            nodeValChunkId++,
            nodeValChunk,
            objChunk,
            styleChunk,
            nodeIds.length,
            nodeIds.length,
            false,
            true,
            save);
    }


    genQueueMessageToUi({
        cmd: 'uiForwardToFigma',
        msg: {cmd: 'figCommitUndo'}
    })
}



function genQueueChunk(requestId, actionId, updateNodeId, updateParamId, nodeValChunkId, nodeValChunk, objChunk, styleChunk, updatedNodes, totalNodes, isFirstChunk, isLastChunk, save)
{
    genQueueMessageToUi({
        cmd:          'uiUpdateValuesAndObjects',
        requestId:     requestId,
        actionId:      actionId,
        updateNodeId:  updateNodeId,
        updateParamId: updateParamId,
        chunkId:       nodeValChunkId,
        values:        [...nodeValChunk].map(v => v.toString()),
        objects:       [...objChunk    ],
        styles:        [...styleChunk  ],
        updatedNodes:  updatedNodes,
        totalNodes:    totalNodes,
        isFirstChunk:  isFirstChunk,
        isLastChunk:   isLastChunk,
        save:          save
    });


    if (   !isEmpty(objChunk  )
        || !isEmpty(styleChunk))
        genFigMessagePosted = true;
}



function genInitNodeProgress(nodeId)
{
    genQueueMessageToUi(
    {
        cmd:   'uiInitNodeProgress',
        nodeId: nodeId
    });
}



function genUpdateNodeProgress(parse, nodeId, progress, updateGlobal = true)
{
    genQueueMessageToUi(
    {
        cmd:           'uiUpdateNodeProgress',
        nodeId:         nodeId,
        progress:       progress,
        globalProgress: parse.currentProgress / parse.totalProgress,
        updateGlobal:   updateGlobal
    });
}



function genEndNodeProgress(nodeId, endGlobal)
{
    genQueueMessageToUi(
    {
        cmd:      'uiEndNodeProgress',
        nodeId:    nodeId,
        endGlobal: endGlobal
    });
}



async function genGetObjectSizeFromFigma(obj) 
{
    return new Promise((resolve, reject) => 
    {
        const timeout = 1000;

        genPostMessageToUi(
        {
            cmd: 'uiForwardToFigma',
            msg:  
            {
                cmd:   'figGetObjectSize',
                object: obj
            }
        });

        const timeoutId = setTimeout(() => 
            reject(new Error('Timeout: Result not received within the specified time')),
            timeout);

        function handleMessage(event) 
        {
            const msg = JSON.parse(event.data);

            if (msg.cmd === 'returnFigGetObjectSize') 
            {
                clearTimeout(timeoutId);
                
                const { objectId, width, height } = msg;
                resolve({ objectId, width, height });

                self.removeEventListener('message', handleMessage);
            }
        }

        self.addEventListener('message', handleMessage);
    });
}



async function genGetValueFromUi(key) 
{
    return new Promise((resolve, reject) => 
    {
        const timeout = 60000;

        genPostMessageToUi(
        {
            cmd: 'uiGetValue',
            key:  key 
        });

        const timeoutId = setTimeout(() => 
            reject(new Error('Timeout: Result not received within the specified time')),
            timeout);

        function handleMessage(event) 
        {
            const msg = JSON.parse(event.data);

            if (msg.cmd === 'returnUiGetValue') 
            {
                clearTimeout(timeoutId);

                resolve(
                { 
                    key:   msg.key, 
                    value: msg.value 
                });

                self.removeEventListener('message', handleMessage);
            }
        }

        self.addEventListener('message', handleMessage);
    });
}


function genParseColorValue(parse)
{
    parse.pos++; // COLOR_VALUE

    const col = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(COLOR_VALUE, col, parse);

    return parseColorValue(col)[0];
}



function genParseColor(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const col = new GColor(nodeId, options);

    col.hasInputs = options.hasInputs;
    
  
    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(col, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, col);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    
    let paramIds;

    if (nInputs == 1)
    {
        col.input = genParse(parse);
        paramIds = parse.move().split(',');
    }
    else
        paramIds = ['space', 'convert', 'c1', 'c2', 'c3'];


    parse.inParam = false;
    
    for (const id of paramIds)
    {
        switch (id)
        {
        case 'space':   col.space        = genParse(parse);  break;
        case 'convert': col.convert      = genParse(parse);  break;
        case 'c1':      col._c1 = col.c1 = genParse(parse);  break;
        case 'c2':      col._c2 = col.c2 = genParse(parse);  break;
        case 'c3':      col._c3 = col.c3 = genParse(parse);  break;
        }
    }
    

    parse.nTab--;


    genParseNodeEnd(parse, col);
    return col;
}



function genParseValidColor(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const valid = new GValidColor(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(valid, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, valid);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        valid.input = genParse(parse);


    valid.quality = genParse(parse);
    valid.value   = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, valid);
    return valid;
}



function genParseCorrectColor(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const corr = new GCorrectColor(nodeId, options);

    corr.hasInputs = options.hasInputs;


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(corr, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, corr);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    let paramIds;

    if (nInputs == 1)
        corr.input = genParse(parse);


    paramIds = parse.move().split(',');

    parse.inParam = false;
    
    for (const id of paramIds)
    {
        switch (id)
        {
        case 'order':  corr._order = corr.order = genParse(parse);  break;
        case 'c1':     corr._c1    = corr.c1    = genParse(parse);  break;
        case 'c2':     corr._c2    = corr.c2    = genParse(parse);  break;
        case 'c3':     corr._c3    = corr.c3    = genParse(parse);  break;
        case 'value':  corr.value               = genParse(parse);  break;
        }
    }
                

    parse.nTab--;


    genParseNodeEnd(parse, corr);
    return corr;
}



function genParseColorContrast(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const cnt = new GColorContrast(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }


    const valueIndex = 
        nInputs == 1
        ? parseInt(parse.move())
        : -1;

    
    if (parse.settings.logRequests) 
        logReqColorContrast(cnt, nInputs, valueIndex, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, cnt);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    if (nInputs == 2)
    {
        cnt.input0   = genParse(parse);
        cnt.input1   = genParse(parse);
        cnt.standard = genParse(parse);
    }
    else if (nInputs == 1)
    {
             if (valueIndex == 0) cnt.input0 = genParse(parse); 
        else if (valueIndex == 1) cnt.input1 = genParse(parse); 

        cnt.standard = genParse(parse);
    }
    else if (nInputs == 0)
    {
        cnt.standard = genParse(parse);
    }

    parse.nTab--;


    genParseNodeEnd(parse, cnt);
    return cnt;
}



function genParseColorConvertP3(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const convert = new GConvertP3(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(convert, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, convert);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        convert.input = genParse(parse);


    convert.from = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, convert);
    return convert;
}



function genParseColorBlind(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const cb = new GColorBlind(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(cb, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, cb);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        cb.input = genParse(parse);

    cb.l = genParse(parse);
    cb.m = genParse(parse);
    cb.s = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, cb);
    return cb;
}



function genParseColorInterpolate(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const lerp = new GColorInterpolate(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }

    
    if (parse.settings.logRequests) 
        logReq(lerp, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, lerp);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 2)
    {
        lerp.input0 = genParse(parse);
        lerp.input1 = genParse(parse);
    }

    else if (nInputs == 1)
        lerp.input0 = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same

    else if (nInputs != 0)
        consoleError('nInputs must be [0, 2]');


    lerp.space  = genParse(parse);
    lerp.amount = genParse(parse);
    lerp.gamma  = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, lerp);
    return lerp;
}



function genParseColorBlend(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const blend = new GColorBlend(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }

    
    if (parse.settings.logRequests) 
        logReq(blend, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, blend);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 2)
    {
        blend.input0 = genParse(parse);
        blend.input1 = genParse(parse);
    }

    else if (nInputs == 1)
        blend.input0 = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same

    else if (nInputs != 0)
        consoleError('nInputs must be [0, 2]');


    blend.mode    = genParse(parse);
    blend.opacity = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, blend);
    return blend;
}


function genParseNull(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const _null = new GNull(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(_null, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, _null);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        _null.input = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, _null);
    return _null;
}



function genParseVariable(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const variable = new GVariable(nodeId, options);

    variable.existing = options.existing;


    if (parse.settings.logRequests) 
        logReq(variable, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, variable);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;
    parse.inParam = false;


    const nParams = parseInt(parse.move());

    if (nParams == 1)
        variable.varValue = genParse(parse);

    
    parse.nTab--;

    
    variable.linked = variable.id != NULL;


    genParseNodeEnd(parse, variable);
    return variable;
}



function genParseVariableGroup(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const group = new GVariableGroup(nodeId, options);

    
    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(group, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, group);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        group.input = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, group);
    return group;
}



function genParseListValue(parse)
{
    parse.pos++; // LIST_VALUE

    const list = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(LIST_VALUE, list, parse);

    return parseListValue(list)[0];
}



function genParseJoin(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const list = new GCombine(nodeId, options);

    
    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(list, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, list);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    
    for (let i = 0; i < nInputs; i++)
        list.inputs.push(genParse(parse));


    parse.nTab--;

        
    genParseNodeEnd(parse, list);
    return list;
}



function genParseCondense(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const condense = new GCondense(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(condense, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, condense);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        condense.input = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, condense);
    return condense;
}



function genParseExtract(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const extr = new GExtract(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(extr, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, extr);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        extr.input = genParse(parse);

    extr.indices = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, extr);
    return extr;
}



function genParseSetParam(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const set = new GSetParam(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(set, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, set);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 2)
    {
        set.input0 = genParse(parse);
        set.input1 = genParse(parse);
        set.name   = genParse(parse);
    }
    else if (nInputs == 1)
    {
        set.input0 = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same
        set.name   = genParse(parse);
    }
    else if (nInputs == 0)
    {
        set.name   = genParse(parse);
    }

    
    parse.nTab--;


    genParseNodeEnd(parse, set);
    return set;
}



function genParseExtractParam(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const extr = new GExtractParam(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(extr, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, extr);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        extr.input = genParse(parse);

    extr.name = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, extr);
    return extr;
}



function genParseSublist(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const sub = new GSublist(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(sub, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, sub);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        sub.input = genParse(parse);

    sub.start = genParse(parse);
    sub.end   = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, sub);
    return sub;
}



function genParseUnique(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const unique = new GUnique(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(unique, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, unique);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        unique.input = genParse(parse);
  
    
    parse.nTab--;


    genParseNodeEnd(parse, unique);
    return unique;
}



function genParseReverseList(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const reverse = new GReverseList(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(reverse, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, reverse);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        reverse.input = genParse(parse);
  
    
    parse.nTab--;


    genParseNodeEnd(parse, reverse);
    return reverse;
}



function genParseSort(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const sort = new GSort(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(sort, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, sort);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        sort.input = genParse(parse);

    sort.order   = genParse(parse);
    sort.reverse = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, sort);
    return sort;
}



function genParseColumn(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const column = new GColumn(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(column, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, column);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        column.input = genParse(parse);

    column.index = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, column);
    return column;
}



function genParseCell(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const cell = new GCell(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(cell, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, cell);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        cell.input = genParse(parse);

    cell.column = genParse(parse);
    cell.row    = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, cell);
    return cell;
}



function genParseList(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const list = new GList(nodeId, options);

    
    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(list, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, list);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        list.input = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, list);
    return list;
}



function genParseSelect(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const sel = new GSelect(nodeId, options);
    

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(sel, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, sel);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        sel.input = genParse(parse);

    sel.index = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, sel);
    return sel;
}



function genParseListCount(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const count = new GListCount(nodeId, options);

    
    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(count, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, count);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        count.input = genParse(parse);

    count.start = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, count);
    return count;
}



function genParseListContains(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const cont = new GContains(nodeId, options);
   

    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }

    
    if (parse.settings.logRequests) 
        logReq(cont, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, cont);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 2)
    {
        cont.input0 = genParse(parse);
        cont.input1 = genParse(parse);
    }
    else if (nInputs == 1)
    {
        cont.input0 = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same
    }
  
    
    parse.nTab--;


    genParseNodeEnd(parse, cont);
    return cont;
}



function genParseIfElse(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const ifElse = new GIfElse(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }


    const valueIndex = 
        nInputs == 1
        ? parseInt(parse.move())
        : -1;


    if (parse.settings.logRequests) 
        logReq(ifElse, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, ifElse);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    if (nInputs == 2)
    {
        ifElse.input0    = genParse(parse);
        ifElse.input1    = genParse(parse);
        ifElse.condition = genParse(parse);
    }
    else if (nInputs == 1)
    {
             if (valueIndex == 0) ifElse.input0 = genParse(parse); 
        else if (valueIndex == 1) ifElse.input1 = genParse(parse); 

        ifElse.condition = genParse(parse);
    }
    else if (nInputs == 0)
    {
        ifElse.condition = genParse(parse);
    }

    parse.nTab--;


    genParseNodeEnd(parse, ifElse);
    return ifElse;
}



function genParseStart(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const feedback = new GStart(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(feedback, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, feedback);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        feedback.input = genParse(parse);

    feedback.feedback = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, feedback);
    return feedback;
}



function genParseRepeat(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const repeat = new GRepeat(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(repeat, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, repeat);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        repeat.input = genParse(parse);

    repeat. count = genParse(parse);
    repeat._while = genParse(parse);
    repeat. loop  = genParse(parse);  // don't set target here


    parse.nTab--;


    genParseNodeEnd(parse, repeat);
    return repeat;
}



function genParseCache(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const cache = new GCache(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(cache, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, cache);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        cache.input = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, cache);
    return cache;
}



function genParseFreeze(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const freeze = new GFreeze(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(freeze, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, freeze);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        freeze.input = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, freeze);
    return freeze;
}



function genParseTimer(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const timer = new GTimer(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(timer, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, timer);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        timer.input = genParse(parse);


    timer.interval = genParse(parse);
    timer._while   = genParse(parse);
    timer. loop    = genParse(parse);  // don't set target here


    parse.nTab--;


    genParseNodeEnd(parse, timer);
    return timer;
}



function genParseValueName(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const name = new GValueName(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(name, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, name);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        name.input = genParse(parse);

    name.name = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, name);
    return name;
}



function genParseComment(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const cmnt = new GComment(nodeId, options);

    
    if (parse.settings.logRequests) 
        logReq(cmnt, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, cmnt);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    genParseNodeEnd(parse, cmnt);
    return cmnt;
}



function genParseCommentArrow(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const cmnt = new GCommentArrow(nodeId, options);

    
    if (parse.settings.logRequests) 
        logReq(cmnt, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, cmnt);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    genParseNodeEnd(parse, cmnt);
    return cmnt;
}



function genParsePanel(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const panel = new GPanel(nodeId, options);

    
    if (parse.settings.logRequests) 
        logReq(panel, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, panel);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    genParseNodeEnd(parse, panel);
    return panel;
}


function genParseGroupNode(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const group = new GGroupNode(nodeId, options);


    let nParams = -1;
    
    if (!ignore)
    {
        nParams = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(group, parse, ignore);//, nParams);


    if (ignore)
    {
        genParseNodeEnd(parse, group);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    //const nParams = parseInt(parse.move());

    for (let i = 0; i < nParams; i++)
    {
        group.paramIds.push(parse.move());
        group.params  .push(genParse(parse));
    }


    parse.nTab--;


    genParseNodeEnd(parse, group);
    return group;
}



function genParseGroupParam(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const param = new GGroupParam(nodeId, options);


    let nInputs  = -1;
    let nOutputs = -1;
    
    if (!ignore)
    {
        nInputs  = parseInt(parse.move());
        nOutputs = parseInt(parse.move());

        consoleAssert(nInputs  == 0 || nInputs  == 1,  'nInputs must be [0, 1]');
        consoleAssert(nOutputs == 0 || nOutputs == 1, 'nOutputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(param, parse, ignore);//, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, param);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
    {
        param.input    = genParse(parse);
        param.dataType = parse.move();
    }
    else if (nOutputs == 1)
        param.dataType = parse.move();


    parse.nTab--;


    genParseNodeEnd(parse, param);
    return param;
}



function genParseFillValue(parse)
{
    parse.pos++; // FILL_VALUE

    const fill = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(FILL_VALUE, fill, parse);

    return parseFillValue(fill)[0];
}



function genParseFill(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const fill = new GFill(nodeId, options);

    fill.hasInputs = options.hasInputs;


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(fill, parse, ignore, nInputs);


    if (ignore)
    {
        genParseNodeEnd(parse, fill);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    let paramIds;

    if (nInputs == 1)
    {
        fill.input = genParse(parse);
        paramIds = parse.move().split(',');
    }
    else
        paramIds = ['color', 'opacity', 'blend'];


    parse.inParam = false;

    for (const id of paramIds)
    {
        switch (id)
        {
        case 'color':   fill.color   = genParse(parse); break;
        case 'opacity': fill.opacity = genParse(parse); break;
        case 'blend':   fill.blend   = genParse(parse); break;
        }
    }

    
    parse.nTab--;


    genParseNodeEnd(parse, fill);
    return fill;
}



function genParseFillParam(parse)
{
    const fill = genParse(parse); 

    if (COLOR_TYPES.includes(fill.type))
        fill.options.opacity = genParse(parse);

    return fill;
}



function genParseGradientValue(parse)
{
    parse.pos++; // GRADIENT_VALUE

    const grad = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(GRADIENT_VALUE, grad, parse);

    return parseGradientValue(grad)[0];
}



function genParseGradient(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const grad = new GGradient(nodeId, options);

    grad.hasInputs = options.hasInputs;


    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(grad, parse, ignore, nInputs);


    if (ignore)
    {
        genParseNodeEnd(parse, grad);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    for (let i = 0; i < nInputs; i++)
        grad.inputs.push(genParse(parse));


    grad.gradType = genParse(parse); 
    grad.x        = genParse(parse); 
    grad.y        = genParse(parse); 
    grad.size     = genParse(parse); 
    grad.angle    = genParse(parse); 
    grad.aspect   = genParse(parse); 
    grad.skew     = genParse(parse); 
    grad.blend    = genParse(parse); 

    
    parse.nTab--;


    genParseNodeEnd(parse, grad);
    return grad;
}



// function genParseGradientParam(parse)
// {
//     const grd = genParse(parse); 

//     if (COLOR_TYPES.includes(grd.type))
//         grd.options.opacity = genParse(parse);

//     return grd;
// }



function genParseColorStopValue(parse)
{
    parse.pos++; // COLOR_STOP_VALUE

    const stop = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(COLOR_STOP_VALUE, stop, parse);

    return parseColorStopValue(stop)[0];
}



function genParseColorStop(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const stop = new GColorStop(nodeId, options);

    stop.hasInputs = options.hasInputs;


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(stop, parse, ignore, nInputs);


    if (ignore)
    {
        genParseNodeEnd(parse, stop);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    let paramIds;

    if (nInputs == 1)
    {
        stop.input = genParse(parse);
        paramIds = parse.move().split(',');
    }
    else
        paramIds = ['fill', 'position'];


    parse.inParam = false;

    for (const id of paramIds)
    {
        switch (id)
        {
        case 'fill':     stop.fill     = genParse(parse); break;
        case 'position': stop.position = genParse(parse); break;
        }
    }
    
    
    parse.nTab--;


    genParseNodeEnd(parse, stop);
    return stop;
}



function genParseStrokeValue(parse)
{
    parse.pos++; // STROKE_VALUE

    const stroke = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(STROKE_VALUE, stroke, parse);

    return parseStrokeValue(stroke)[0];
}



function genParseStroke(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const stroke = new GStroke(nodeId, options);

    stroke.hasInputs = options.hasInputs;


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(stroke, parse, ignore, nInputs);


    if (ignore)
    {
        genParseNodeEnd(parse, stroke);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    let paramIds;

    if (nInputs == 1)
    {
        stroke.input = genParse(parse);
        paramIds = parse.move().split(',');
    }
    else
        paramIds = ['fill', 'weight', 'fit', 'join', 'miter', 'cap', 'dashes'];


    parse.inParam = false;

    for (const id of paramIds)
    {
        switch (id)
        {
        case 'fill':   stroke._fills = genParse(parse); stroke.fills = stroke._fills; break;
        case 'weight': stroke.weight = genParse(parse); break;
        case 'fit':    stroke.fit    = genParse(parse); break;
        case 'join':   stroke.join   = genParse(parse); break;
        case 'miter':  stroke.miter  = genParse(parse); break;
        case 'cap':    stroke.cap    = genParse(parse); break;
        case 'dashes': stroke.dashes = genParse(parse); break;
        }
    }
    
    
    parse.nTab--;


    genParseNodeEnd(parse, stroke);
    return stroke;
}



function genParseStrokeParam(parse)
{
    const stroke = genParse(parse); 

    if (    FILL_TYPES.includes(stroke.type)
        || COLOR_TYPES.includes(stroke.type))
        stroke.data.weight = genParse(parse);

    return stroke;
}



function genParseRoundCornersValue(parse)
{
    parse.pos++; // ROUND_CORNERS_VALUE

    const corners = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(ROUND_CORNERS_VALUE, corners, parse);

    return parseRoundCornersValue(corners)[0];
}



function genParseRoundCorners(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const corners = new GRoundCorners(nodeId, options);

    corners.hasInputs = options.hasInputs;


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(corners, parse, ignore, nInputs);


    if (ignore)
    {
        genParseNodeEnd(parse, corners);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    let paramIds;

    if (nInputs == 1)
    {
        corners.input = genParse(parse);
        paramIds = parse.move().split(',');
    }
    else
        paramIds = ['tl', 'tr', 'bl', 'br'];


    parse.inParam = false;

    for (const id of paramIds)
    {
        switch (id)
        {
        case 'tl': corners.tl = genParse(parse); break;
        case 'tr': corners.tr = genParse(parse); break;
        case 'bl': corners.bl = genParse(parse); break;
        case 'br': corners.br = genParse(parse); break;
        }
    }
    
    
    parse.nTab--;


    genParseNodeEnd(parse, corners);
    return corners;
}



function genParseDropShadowValue(parse)
{
    parse.pos++; // DROP_SHADOW_VALUE

    const shadow = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(DROP_SHADOW_VALUE, shadow, parse);

    return parseDropShadowValue(shadow)[0];
}



function genParseDropShadow(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const shadow = new GDropShadow(nodeId, options);

    shadow.hasInputs = options.hasInputs;


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(shadow, parse, ignore, nInputs);


    if (ignore)
    {
        genParseNodeEnd(parse, shadow);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    let paramIds;

    if (nInputs == 1)
    {
        shadow.input = genParse(parse);
        paramIds = parse.move().split(',');
    }
    else
        paramIds = ['x', 'y', 'blur', 'spread', 'fill', 'blend', 'behind'];


    parse.inParam = false;

    for (const id of paramIds)
    {
        switch (id)
        {
        case 'x':      shadow.x      = genParse(parse); break;
        case 'y':      shadow.y      = genParse(parse); break;
        case 'blur':   shadow.blur   = genParse(parse); break;
        case 'spread': shadow.spread = genParse(parse); break;
        case 'fill':   shadow.fill   = genParse(parse); break;
        case 'blend':  shadow.blend  = genParse(parse); break;
        case 'behind': shadow.behind = genParse(parse); break;
        }
    }
    
    
    parse.nTab--;


    genParseNodeEnd(parse, shadow);
    return shadow;
}



function genParseInnerShadowValue(parse)
{
    parse.pos++; // INNER_SHADOW_VALUE

    const shadow = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(INNER_SHADOW_VALUE, shadow, parse);

    return parseInnerShadowValue(shadow)[0];
}



function genParseInnerShadow(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const shadow = new GInnerShadow(nodeId, options);

    shadow.hasInputs = options.hasInputs;


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(shadow, parse, ignore, nInputs);


    if (ignore)
    {
        genParseNodeEnd(parse, shadow);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    let paramIds;

    if (nInputs == 1)
    {
        shadow.input = genParse(parse);
        paramIds = parse.move().split(',');
    }
    else
        paramIds = ['x', 'y', 'blur', 'spread', 'fill', 'blend'];


    parse.inParam = false;

    for (const id of paramIds)
    {
        switch (id)
        {
        case 'x':      shadow.x      = genParse(parse); break;
        case 'y':      shadow.y      = genParse(parse); break;
        case 'blur':   shadow.blur   = genParse(parse); break;
        case 'spread': shadow.spread = genParse(parse); break;
        case 'fill':   shadow.fill   = genParse(parse); break;
        case 'blend':  shadow.blend  = genParse(parse); break;
        }
    }
    
    
    parse.nTab--;


    genParseNodeEnd(parse, shadow);
    return shadow;
}



function genParseLayerBlurValue(parse)
{
    parse.pos++; // LAYER_BLUR_VALUE

    const blur = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(LAYER_BLUR_VALUE, blur, parse);

    return parseLayerBlurValue(blur)[0];
}



function genParseLayerBlur(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const blur = new GLayerBlur(nodeId, options);

    blur.hasInputs = options.hasInputs;


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(blur, parse, ignore, nInputs);


    if (ignore)
    {
        genParseNodeEnd(parse, blur);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    let paramIds;

    if (nInputs == 1)
    {
        blur.input = genParse(parse);
        paramIds = parse.move().split(',');
    }
    else
        paramIds = ['radius'];


    parse.inParam = false;

    for (const id of paramIds)
    {
        switch (id)
        {
        case 'radius': blur.radius = genParse(parse); break;
        }
    }
    
    
    parse.nTab--;


    genParseNodeEnd(parse, blur);
    return blur;
}



function genParseBackBlurValue(parse)
{
    parse.pos++; // BACK_BLUR_VALUE

    const blur = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(BACK_BLUR_VALUE, blur, parse);

    return parseBackBlurValue(blur)[0];
}



function genParseBackBlur(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const blur = new GBackBlur(nodeId, options);

    blur.hasInputs = options.hasInputs;


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(blur, parse, ignore, nInputs);


    if (ignore)
    {
        genParseNodeEnd(parse, blur);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    let paramIds;

    if (nInputs == 1)
    {
        blur.input = genParse(parse);
        paramIds = parse.move().split(',');
    }
    else
        paramIds = ['radius'];


    parse.inParam = false;

    for (const id of paramIds)
    {
        switch (id)
        {
        case 'radius': blur.radius = genParse(parse); break;
        }
    }
    
    
    parse.nTab--;


    genParseNodeEnd(parse, blur);
    return blur;
}



function genParseLayerBlendValue(parse)
{
    parse.pos++; // LAYER_BLEND_VALUE

    const layer = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(LAYER_BLEND_VALUE, layer, parse);

    return parseLayerBlendValue(layer)[0];
}



function genParseLayerBlend(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const layer = new GLayerBlend(nodeId, options);


    if (parse.settings.logRequests) 
        logReq(layer, parse, ignore);


    if (ignore)
    {
        genParseNodeEnd(parse, layer);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    layer.opacity = genParse(parse);
    layer.blend   = genParse(parse);
    
    
    genParseNodeEnd(parse, layer);
    return layer;
}



function genParseLayerMaskValue(parse)
{
    parse.pos++; // LAYER_MASK_VALUE

    const mask = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(LAYER_MASK_VALUE, mask, parse);

    return parseLayerMaskValue(mask)[0];
}



function genParseLayerMask(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const mask = new GLayerMask(nodeId, options);


    if (parse.settings.logRequests) 
        logReq(mask, parse, ignore);


    if (ignore)
    {
        genParseNodeEnd(parse, mask);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    mask.maskType = genParse(parse);
    
    
    genParseNodeEnd(parse, mask);
    return mask;
}


function genParseNumValue(parse)
{
    parse.pos++; // N

    const val = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(NUMBER_VALUE, val, parse);

    return val.indexOf(',') >= 0
         ? parseNumberValue      (val)[0]
         : parseSimpleNumberValue(val)[0];
}



function genParseNumber(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const num = new GNumber(nodeId, options);

    
    if (parse.settings.logRequests) 
        logReq(num, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, num);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;
    parse.inParam = false;


    if (parse.next == NUMBER_VALUE) num.value = genParse(parse);
    else                            num.input = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, num);
    return num;
}



function genParseConstant(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const _const = new GConstant(nodeId, options);


    if (parse.settings.logRequests) 
        logReq(_const, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, _const);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    _const.constant = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, _const);
    return _const;
}



function genParseDateTime(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const dateTime = new GDateTime(nodeId, options);


    if (parse.settings.logRequests) 
        logReq(dateTime, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, dateTime);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    dateTime.seconds   = genParse(parse);
    dateTime.minutes   = genParse(parse);
    dateTime.hours     = genParse(parse);
    dateTime.dayOfWeek = genParse(parse);
    dateTime.date      = genParse(parse);
    dateTime.month     = genParse(parse);
    dateTime.year      = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, dateTime);
    return dateTime;
}



function genParseSign(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const sign = new GSign(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(sign, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, sign);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        sign.input = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, sign);
    return sign;
}



function genParseAbsolute(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const abs = new GAbsolute(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(abs, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, abs);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        abs.input = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, abs);
    return abs;
}



function genParseRound(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const round = new GRound(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(round, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, round);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        round.input = genParse(parse);

    round.type     = genParse(parse);
    round.decimals = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, round);
    return round;
}



function genParseSimpleMinMax(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const sminmax = new GSimpleMinMax(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(sminmax, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, sminmax);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        sminmax.input = genParse(parse);

    sminmax.operand   = genParse(parse);
    sminmax.operation = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, sminmax);
    return sminmax;
}



function genParseMinMax(parse)
{
    const [type, nodeId, options, ignore] = genParseNodeStart(parse);


    const minmax = new GMinMax(nodeId, options);

    
    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(minmax, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, minmax);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    for (let i = 0; i < nInputs; i++)
        minmax.inputs.push(genParse(parse));


    minmax.operation = genParse(parse);


    parse.nTab--;

        
    genParseNodeEnd(parse, minmax);
    return minmax;
}



function genParseLimits(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const limits = new GLimits(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(limits, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, limits);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        limits.input = genParse(parse);

    limits.min = genParse(parse);
    limits.max = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, limits);
    return limits;
}



function genParseNumberCurve(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const curve = new GNumberCurve(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(curve, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, curve);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        curve.input = genParse(parse);

    curve.min    = genParse(parse);
    curve.max    = genParse(parse);
    curve.power  = genParse(parse);
    curve.bias   = genParse(parse);
    curve.spread = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, curve);
    return curve;
}



function genParseNaNisNumber(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const nanIsNum = new GNaNisNumber(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(nanIsNum, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, nanIsNum);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        nanIsNum.input = genParse(parse);

    nanIsNum._value = genParse(parse);

    parse.nTab--;


    genParseNodeEnd(parse, nanIsNum);
    return nanIsNum;
}



function genParseMath(parse, newNode)
{
    const [type, nodeId, options, ignore] = genParseNodeStart(parse);


    const math = newNode(nodeId, options);

    
    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(math, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, math);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    for (let i = 0; i < nInputs; i++)
        math.inputs.push(genParse(parse));


    math.operation = genParse(parse);


    parse.nTab--;

        
    genParseNodeEnd(parse, math);
    return math;
}



function genParseSimpleMath(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const smath = new GSimpleMath(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(smath, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, smath);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        smath.input = genParse(parse);

    smath.operation = genParse(parse);
    smath.operand   = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, smath);
    return smath;
}



function genParseArithmetic(parse, newNode)
{
    const [type, nodeId, options, ignore] = genParseNodeStart(parse);


    const arith = newNode(nodeId, options);


    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(arith, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, arith);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    for (let i = 0; i < nInputs; i++)
        arith.inputs.push(genParse(parse));

    parse.nTab--;

        
    genParseNodeEnd(parse, arith);
    return arith;
}



function genParseConvertAngle(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const convert = new GConvertAngle(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(convert, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, convert);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        convert.input = genParse(parse);

    convert.from = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, convert);
    return convert;
}



function genParseDefine(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const define = new GDefine(nodeId, options);


    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(define, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, define);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    
    for (let i = 0; i < nInputs; i++)
        define.inputs.push(genParse(parse));


    parse.nTab--;


    genParseNodeEnd(parse, define);
    return define;
}



function genParseRange(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const dist = new GRange(nodeId, options);


    if (parse.settings.logRequests) 
        logReq(dist, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, dist);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    dist.from   = genParse(parse);
    dist.start  = genParse(parse);
    dist.end    = genParse(parse);
    dist.bias   = genParse(parse);
    dist.spread = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, dist);
    return dist;
}



function genParseWave(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const wave = new GWave(nodeId, options);


    if (parse.settings.logRequests) 
        logReq(wave, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, wave);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    wave.shape     = genParse(parse);
    wave.base      = genParse(parse);
    wave.amplitude = genParse(parse);
    wave.frequency = genParse(parse);
    wave.offset    = genParse(parse);
    wave.bias      = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, wave);
    return wave;
}



function genParseSequence(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const seq = new GSequence(nodeId, options);


    if (parse.settings.logRequests) 
        logReq(seq, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, seq);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    seq.start    = genParse(parse);
    seq.multiply = genParse(parse);
    seq.add      = genParse(parse);
    seq.end      = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, seq);
    return seq;
}



function genParseRandom(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const rnd = new GRandom(nodeId, options);


    if (parse.settings.logRequests) 
        logReq(rnd, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, rnd);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    rnd.seed        = genParse(parse);
    rnd.min         = genParse(parse);
    rnd.max         = genParse(parse);
    rnd.bias        = genParse(parse);
    rnd.spread      = genParse(parse);
    rnd.unique      = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, rnd);
    return rnd;
}



function genParseNoise(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const noise = new GNoise(nodeId, options);


    if (parse.settings.logRequests) 
        logReq(noise, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, noise);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    noise.seed        = genParse(parse);
    noise.min         = genParse(parse);
    noise.max         = genParse(parse);
    noise.scale       = genParse(parse);
    noise.offset      = genParse(parse);
    noise.interpolate = genParse(parse);
    noise.detail      = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, noise);
    return noise;
}



function genParseProbability(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const prob = new GProbability(nodeId, options);


    if (parse.settings.logRequests) 
        logReq(prob, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, prob);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    prob.seed   = genParse(parse);
    prob.chance = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, prob);
    return prob;
}



function genParseAccumulate(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const accum = new GAccumulate(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(accum, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, accum);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        accum.input = genParse(parse);

    accum.when = genParse(parse);

        
    parse.nTab--;


    genParseNodeEnd(parse, accum);
    return accum;
}



function genParseInterpolate(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const lerp = new GInterpolate(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }

    
    if (parse.settings.logRequests) 
        logReq(lerp, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, lerp);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    if (nInputs == 2)
    {
        lerp.input0 = genParse(parse);
        lerp.input1 = genParse(parse);
        lerp.amount = genParse(parse);
    }
    else if (nInputs == 1)
    {
        lerp.input0 = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same
        lerp.amount = genParse(parse);
    }
    else if (nInputs == 0)
    {
        lerp.amount = genParse(parse);
    }

    parse.nTab--;


    genParseNodeEnd(parse, lerp);
    return lerp;
}



function genParseBoolean(parse)
{
    const [type, nodeId, options, ignore] = genParseNodeStart(parse);


    const bool = new GBoolean(nodeId, options);

    
    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(bool, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, bool);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    for (let i = 0; i < nInputs; i++)
        bool.inputs.push(genParse(parse));


    bool.operation = genParse(parse);


    parse.nTab--;

        
    genParseNodeEnd(parse, bool);
    return bool;
}



function genParseCondition(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const cond = new GCondition(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(cond, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, cond);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        cond.input = genParse(parse);
  
    
    cond.operation = genParse(parse);
    cond.operand   = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, cond);
    return cond;
}



function genParseConditionBase(parse, newNode)
{
    const [type, nodeId, options, ignore] = genParseNodeStart(parse);


    const cond = newNode(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }

    
    if (parse.settings.logRequests)
        logReq(cond, parse, ignore, nInputs); 


    if (ignore) 
    {
        genParseNodeEnd(parse, cond);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    if (nInputs == 2)
    {
        cond.input0 = genParse(parse);
        cond.input1 = genParse(parse);
    }
    else if (nInputs == 1)
    {
        cond.input0 = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same
    }

    parse.nTab--;


    genParseNodeEnd(parse, cond);
    return cond;
}



function genParseTrigonometric(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const trig = new GTrig(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(trig, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, trig);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        trig.input = genParse(parse);

    trig.function = genParse(parse);

    parse.nTab--;


    genParseNodeEnd(parse, trig);
    return trig;
}



function genParseTrigBase(parse, newNode)
{
    const [type, nodeId, options, ignore] = genParseNodeStart(parse);


    const trig = newNode(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests)
        logReq(trig, parse, ignore, nInputs); 


    if (ignore) 
    {
        genParseNodeEnd(parse, trig);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        trig.input = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, trig);
    return trig;
}



function genParseSolve(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const solve = new GSolve(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(solve, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, solve);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        solve.input = genParse(parse);

    solve.current = genParse(parse);
    solve.target  = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, solve);
    return solve;
}



function genParseAnimate(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const anim = new GAnimate(nodeId, options);


    if (parse.settings.logRequests) 
        logReq(anim, parse);


    if (ignore) 
    {
        genParseNodeEnd(parse, anim);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    anim.from   = genParse(parse);
    anim.to     = genParse(parse);
    anim.curve  = genParse(parse);
    anim.repeat = genParse(parse);
    anim.length = genParse(parse);
    anim.time   = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, anim);
    return anim;
}



function genParseRectangle(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const rect = new GRectangle(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(rect, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, rect);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        rect.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {
        case 'x':      rect.x      = genParse(parse); break;
        case 'y':      rect.y      = genParse(parse); break;
        case 'width':  rect.width  = genParse(parse); break;
        case 'height': rect.height = genParse(parse); break;
        case 'round':  rect.round  = genParse(parse); break;
        case 'props':  rect.props  = genParse(parse); break;
        }
    }


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, rect);
    return rect;
}



function genParseLine(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);

  
    const line = new GLine(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(line, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, rect);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        line.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {
        case 'x':     line.x     = genParse(parse); break;
        case 'y':     line.y     = genParse(parse); break;
        case 'width': line.width = genParse(parse); break;
        case 'props': line.props = genParse(parse); break;
        }
    }


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, line);
    return line;
}



function genParseEllipse(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const ellipse = new GEllipse(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(ellipse, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, ellipse);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        ellipse.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {
        case 'position': ellipse.position = genParse(parse); break;
        case 'x':        ellipse.x        = genParse(parse); break;
        case 'y':        ellipse.y        = genParse(parse); break;
        case 'width':    ellipse.width    = genParse(parse); break;
        case 'height':   ellipse.height   = genParse(parse); break;
        case 'round':    ellipse.round    = genParse(parse); break;
        case 'from':     ellipse.from     = genParse(parse); break;
        case 'to':       ellipse.to       = genParse(parse); break;
        case 'inner':    ellipse.inner    = genParse(parse); break;
        case 'props':    ellipse.props    = genParse(parse); break;
        }
    }
    
    
    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, ellipse);
    return ellipse;
}



function genParseTrapeze(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const trapeze = new GTrapeze(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(trapeze, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, trapeze);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        trapeze.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {
        case 'x':      trapeze.x      = genParse(parse); break;
        case 'y':      trapeze.y      = genParse(parse); break;
        case 'width':  trapeze.width  = genParse(parse); break;
        case 'height': trapeze.height = genParse(parse); break;
        case 'round':  trapeze.round  = genParse(parse); break;
        case 'bias':   trapeze.bias   = genParse(parse); break;
        case 'props':  trapeze.props  = genParse(parse); break;
        }
    }
    
    
    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, trapeze);
    return trapeze;
}



function genParsePolygon(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const poly = new GPolygon(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(poly, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, poly);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        poly.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {
        case 'position': poly.position = genParse(parse); break;
        case 'x':        poly.x        = genParse(parse); break;
        case 'y':        poly.y        = genParse(parse); break;
        case 'width':    poly.width    = genParse(parse); break;
        case 'height':   poly.height   = genParse(parse); break;
        case 'round':    poly.round    = genParse(parse); break;
        case 'corners':  poly.corners  = genParse(parse); break;
        case 'props':    poly.props    = genParse(parse); break;
        }
    }
    
    
    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, poly);
    return poly;
}



function genParseStar(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const star = new GStar(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(star, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, star);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        star.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {
        case 'position': star.position = genParse(parse); break;
        case 'x':        star.x        = genParse(parse); break;
        case 'y':        star.y        = genParse(parse); break;
        case 'width':    star.width    = genParse(parse); break;
        case 'height':   star.height   = genParse(parse); break;
        case 'round':    star.round    = genParse(parse); break;
        case 'points':   star.points   = genParse(parse); break;
        case 'convex':   star.convex   = genParse(parse); break;
        case 'props':    star.props    = genParse(parse); break;
        }
    }
    
    
    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, star);
    return star;
}



function genParseTextShape(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const text = new GTextShape(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(text, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, text);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        text.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {       
        case 'text':          text.text          = genParse(parse); break;
        case 'x':             text.x             = genParse(parse); break;
        case 'y':             text.y             = genParse(parse); break;
        case 'width':         text.width         = genParse(parse); break;
        case 'height':        text.height        = genParse(parse); break;
        case 'font':          text.font          = genParse(parse); break;
        case 'size':          text.size          = genParse(parse); break;
        case 'style':         text.style         = genParse(parse); break;
        case 'props':         text.props         = genParse(parse); break;
        case 'alignH':        text.alignH        = genParse(parse); break;
        case 'alignV':        text.alignV        = genParse(parse); break;
        case 'lineHeight':    text.lineHeight    = genParse(parse); break;
        case 'letterSpacing': text.letterSpacing = genParse(parse); break;
        }
    }


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, text);
    return text;
}



function genParsePointValue(parse)
{
    parse.pos++; // POINT_VALUE

    const point = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(POINT_VALUE, point, parse);

    return parsePointValue(point)[0];
}



function genParsePoint(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const point = new GPoint(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(point, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, point);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        point.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {
        case 'x': point.x = genParse(parse); break;
        case 'y': point.y = genParse(parse); break;
        }
    }


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, point);
    return point;
}



function genParsePointCorner(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const corner = new GPointCorner(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(corner, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, corner);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        corner.input = genParse(parse);

    corner.smooth = genParse(parse);


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, corner);
    return corner;
}



function genParseVectorPathValue(parse)
{
    parse.pos++; // VECTOR_PATH_VALUE

    const path = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(VECTOR_PATH_VALUE, path, parse);

    return parseVectorPathValue(path)[0];
}



function genParseVectorPath(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const path = new GVectorPath(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(path, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, path);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        path.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {       
        case 'points':  path.points  = genParse(parse); break;
        case 'closed':  path.closed  = genParse(parse); break;
        case 'degree':  path.degree  = genParse(parse); break;
        case 'winding': path.winding = genParse(parse); break;
        case 'round':   path.round   = genParse(parse); break;
        case 'props':   path.props   = genParse(parse); break;
        }
    }


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, path);
    return path;
}



function genParseVectorVertexValue(parse)
{
    parse.pos++; // VECTOR_POINT_VALUE

    const point = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(VECTOR_VERTEX_VALUE, point, parse);

    return parseVectorVertexValue(point)[0];
}



function genParseVectorVertex(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const point = new GVectorVertex(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(point, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, point);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        point.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {
        case 'x':     point.x     = genParse(parse); break;
        case 'y':     point.y     = genParse(parse); break;
        case 'join':  point.join  = genParse(parse); break;
        case 'cap':   point.cap   = genParse(parse); break;
        case 'round': point.round = genParse(parse); break;
        }
    }


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, point);
    return point;
}



function genParseVectorEdgeValue(parse)
{
    parse.pos++; // VECTOR_EDGE_VALUE

    const edge = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(VECTOR_EDGE_VALUE, edge, parse);

    return parseVectorEdgeValue(edge)[0];
}



function genParseVectorEdge(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const edge = new GVectorEdge(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }

    
    if (parse.settings.logRequests) 
        logReq(edge, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, edge);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 2)
    {
        edge.input0 = genParse(parse);
        edge.input1 = genParse(parse);
    }
    else if (nInputs == 1)
    {
        edge.input0 = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same
    }


    edge.startTangent = genParse(parse);
    edge.  endTangent = genParse(parse);


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, edge);
    return edge;
}



function genParseVectorRegionValue(parse)
{
    parse.pos++; // VECTOR_REGION_VALUE

    const region = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(VECTOR_REGION_VALUE, region, parse);

    return parseVectorRegionValue(region)[0];
}



function genParseVectorRegion(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const region = new GVectorRegion(nodeId, options);


    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(region, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, region);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    for (let i = 0; i < nInputs; i++)
        region.inputs.push(genParse(parse));


    region.winding = genParse(parse);
    region.props   = genParse(parse);


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, region);
    return region;
}



function genParseVectorNetworkValue(parse)
{
    parse.pos++; // VECTOR_NETWORKO_VALUE

    const region = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(VECTOR_NETWORK_VALUE, region, parse);

    return parseVectorNetworkValue(region)[0];
}



function genParseVectorNetwork(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const network = new GVectorNetwork(nodeId, options);


    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(network, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, network);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    for (let i = 0; i < nInputs; i++)
        network.inputs.push(genParse(parse));

    network.props = genParse(parse);


    parse.nTab--;



    genParseNodeEnd(parse, network);
    return network;
}



function genParseShapeBoolean(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const bool = new GShapeBoolean(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(bool, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, bool);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        bool.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {
        case 'children':  bool.children  = genParse(parse); break;
        case 'operation': bool.operation = genParse(parse); break;
        }
    }


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, bool);
    return bool;
}



function genParseShapeGroup(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const group = new GShapeGroup(nodeId, options);


    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(group, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, group);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    for (let i = 0; i < nInputs; i++)
        group.inputs.push(genParse(parse));


    parse.nTab--;


    genParseNodeEnd(parse, group);
    return group;
}



function genParseFrame(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const frame = new GFrame(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(frame, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, frame);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        frame.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {
        case 'x':        frame.x        = genParse(parse); break;
        case 'y':        frame.y        = genParse(parse); break;
        case 'width':    frame.width    = genParse(parse); break;
        case 'height':   frame.height   = genParse(parse); break;
        //case 'angle':    frame.angle    = genParse(parse); break;
        case 'round':    frame.round    = genParse(parse); break;
        case 'children': frame.children = genParse(parse); break;
        case 'props':    frame.props    = genParse(parse); break;
        }
    }


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, frame);
    return frame;
}



function genParseMove(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const move = new GMove(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(move, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, move);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        move.input = genParse(parse);

    move.moveType    = genParse(parse);
    move.x           = genParse(parse);
    move.y           = genParse(parse);
    move.affectSpace = genParse(parse);
    move.showCenter  = genParse(parse);


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, move);
    return move;
}



function genParseRotate(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const rotate = new GRotate(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(rotate, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, rotate);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        rotate.input = genParse(parse);

    rotate.angle       = genParse(parse);
    rotate.showCenter  = genParse(parse);
    rotate.affectSpace = genParse(parse);

    
    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, rotate);
    return rotate;
}



function genParseScale(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const scale = new GScale(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(scale, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, scale);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        scale.input = genParse(parse);

    scale.scaleX        = genParse(parse);
    scale.scaleY        = genParse(parse);
    scale.affectCorners = genParse(parse);
    scale.affectStyle   = genParse(parse);
    scale.showCenter    = genParse(parse);
    scale.affectSpace   = genParse(parse);

    
    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, scale);
    return scale;
}



function genParseSkew(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const skew = new GSkew(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(skew, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, skew);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        skew.input = genParse(parse);

    skew.skewX       = genParse(parse);
    skew.skewY       = genParse(parse);
    skew.showCenter  = genParse(parse);
    skew.affectSpace = genParse(parse);


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, skew);
    return skew;
}



function genParseCenter(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const center = new GCenter(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(center, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, center);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        center.input = genParse(parse);

    center.centerX    = genParse(parse);
    center.centerY    = genParse(parse);
    center.showCenter = genParse(parse);


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, center);
    return center;
}



function genParseResetTransform(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const reset = new GResetTransform(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(reset, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, reset);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        reset.input = genParse(parse);

    reset.showCenter = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, reset);
    return reset;
}



function genParseMeasurePoints(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const measure = new GMeasurePoints(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }

    
    if (parse.settings.logRequests) 
        logReq(measure, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, measure);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    
    if (nInputs == 2)
    {
        measure.input0 = genParse(parse);
        measure.input1 = genParse(parse);
    }
    else if (nInputs == 1)
    {
        measure.input0 = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same
    }


    parse.nTab--;


    genParseNodeEnd(parse, measure);
    return measure;
}



function genParseCircleCenter(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const center = new GCircleCenter(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 3, 'nInputs must be [0, 3]');
    }

    
    if (parse.settings.logRequests) 
        logReq(center, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, center);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    
    if (nInputs == 3)
    {
        center.input0 = genParse(parse);
        center.input1 = genParse(parse);
        center.input2 = genParse(parse);
    }
    else if (nInputs == 2)
    {
        center.input0 = genParse(parse);
        center.input1 = genParse(parse);
    }
    else if (nInputs == 1)
    {
        center.input0 = genParse(parse);
    }


    parse.nTab--;


    genParseNodeEnd(parse, center);
    return center;
}



function genParseIntersectLines(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const inter = new GIntersectLines(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 4, 'nInputs must be [0, 4]');
    }

    
    if (parse.settings.logRequests) 
        logReq(inter, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, inter);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    
    if (nInputs == 4)
    {
        inter.input0 = genParse(parse);
        inter.input1 = genParse(parse);
        inter.input2 = genParse(parse);
        inter.input3 = genParse(parse);
    }
    else if (nInputs == 3)
    {
        inter.input0 = genParse(parse);
        inter.input1 = genParse(parse);
        inter.input2 = genParse(parse);
    }
    else if (nInputs == 2)
    {
        inter.input0 = genParse(parse);
        inter.input1 = genParse(parse);
    }
    else if (nInputs == 1)
    {
        inter.input0 = genParse(parse);
    }


    inter.segment = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, inter);
    return inter;
}



function genParseInterpolatePoint(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const lerp = new GInterpolatePoint(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }

    
    if (parse.settings.logRequests) 
        logReq(lerp, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, lerp);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 2)
    {
        lerp.input0 = genParse(parse);
        lerp.input1 = genParse(parse);
    }
    else if (nInputs == 1)
    {
        lerp.input0 = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same
    }


    lerp.amount     = genParse(parse);
    lerp.transform  = genParse(parse);
    lerp.showCenter = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, lerp);
    return lerp;
}



function genParsePointOnPath(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const pop = new GPointOnPath(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }

    
    if (parse.settings.logRequests) 
        logReq(pop, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, pop);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 2)
    {
        pop.input0 = genParse(parse);
        pop.input1 = genParse(parse);
    }
    else if (nInputs == 1)
    {
        pop.input0 = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same
    }


    pop.measure    = genParse(parse);
    pop.amount     = genParse(parse);
    pop.transform  = genParse(parse);
    pop.showCenter = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, pop);
    return pop;
}



function genParsePlace(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const place = new GPlace(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(place, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, place);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        place.input = genParse(parse);

    place.position   = genParse(parse);
    place.transform  = genParse(parse);
    place.showCenter = genParse(parse);


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, place);
    return place;
}



function genParseShapeApply(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const apply = new GApply(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(apply, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, apply);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        apply.input = genParse(parse);

    apply.props   = genParse(parse);
    apply.replace = genParse(parse);


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, apply);
    return apply;
}



function genParseRender(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const render = new GRender(nodeId, options);


    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(render, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, render);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    for (let i = 0; i < nInputs; i++)
        render.inputs.push(genParse(parse));

    render.retain   = genParse(parse);
    render.finalize = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, render);
    return render;
}


// function genParseColorStyleValue(parse)
// {
//     parse.pos++; // COLOR_STYLE_VALUE

//     const style = parse.move();

//     if (parse.settings.logRequests) 
//         logReqStyleValue(style, parse);

//     return parseColorStyleValue(style)[0];
// }



function genParseColorStyle(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const style = new GColorStyle(nodeId, options);

    style.existing = options.existing;


    if (parse.settings.logRequests) 
        logReq(style, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, style);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;
    parse.inParam = false;


    style.id       = parse.move();
    style.name     = options.nodeName;
    
    style.genValue = genParse(parse);

    
    parse.nTab--;

    
    style.linked = style.id != NULL;


    genParseNodeEnd(parse, style);
    return style;
}



//function genParseStyleParam(parse)
//{
    // const style = genParse(parse); 

    // if (STYLE_TYPES.includes(style.type))
    //     style.options.opacity = genParse(parse);

    // return style;
//}




function genParseTextValue(parse)
{
    parse.pos++; // tag

    const val = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(TEXT_VALUE, val, parse);

    return parseTextValue(val)[0];
}



function genParseText(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const text = new GText(nodeId, options);

    
    if (parse.settings.logRequests) 
        logReq(text, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, text);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;
    parse.inParam = false;


    if (parse.next == TEXT_VALUE) text.value = genParse(parse);
    else                          text.input = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, text);
    return text;
}



function genParseTextLength(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const len = new GTextLength(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(len, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, len);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        len.input = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, len);
    return len;
}



function genParseTextTrim(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const trim = new GTextTrim(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(trim, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, trim);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        trim.input = genParse(parse);

    trim.start = genParse(parse);
    trim.end   = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, trim);
    return trim;
}



function genParseTextSubstring(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const sub = new GTextSubstring(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(sub, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, sub);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        sub.input = genParse(parse);

    sub.start = genParse(parse);
    sub.end   = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, sub);
    return sub;
}



function genParseTextContains(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const cont = new GTextContains(nodeId, options);
   

    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }

    
    if (parse.settings.logRequests) 
        logReq(cont, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, cont);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 2)
    {
        cont.input0 = genParse(parse);
        cont.input1 = genParse(parse);
    }
    else if (nInputs == 1)
    {
        cont.input0 = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same
    }
  
    
    parse.nTab--;


    genParseNodeEnd(parse, cont);
    return cont;
}



function genParseTextCase(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const _case = new GTextCase(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(_case, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, _case);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        _case.input = genParse(parse);

    _case.case = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, _case);
    return _case;
}



function genParseTextReplace(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const replace = new GTextReplace(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(replace, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, replace);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        replace.input = genParse(parse);

    replace.what  = genParse(parse);
    replace.with  = genParse(parse);
    replace.regex = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, replace);
    return replace;
}




// function genParseTextRegex(parse)
// {
//     const [, nodeId, options, ignore] = genParseNodeStart(parse);


//     const regex = new GTextRegex(nodeId, options);
   

//     let nInputs = -1;
    
//     if (!ignore)
//     {
//         nInputs = parseInt(parse.move());
//         consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
//     }

    
//     if (parse.settings.logRequests) 
//         logReq(regex, parse, ignore, nInputs);


//     if (ignore) 
//     {
//         genParseNodeEnd(parse, regex);
//         return parse.parsedNodes.find(n => n.nodeId == nodeId);
//     }


//     parse.nTab++;


//     if (nInputs == 1)
//         regex.input = genParse(parse);

//     regex.pattern = genParse(parse);
//     regex.what    = genParse(parse);
//     regex.with    = genParse(parse);

    
//     parse.nTab--;


//     genParseNodeEnd(parse, regex);
//     return regex;
// }




function genParseTextJoin(parse, newNode)
{
    const [type, nodeId, options, ignore] = genParseNodeStart(parse);


    const join = new GTextJoin(nodeId, options);


    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(join, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, join);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    for (let i = 0; i < nInputs; i++)
        join.inputs.push(genParse(parse));


    join.with = genParse(parse);

    
    parse.nTab--;

        
    genParseNodeEnd(parse, join);
    return join;
}



function genParseTextPad(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const pad = new GTextPad(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(pad, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, pad);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        pad.input = genParse(parse);

    pad.startPad   = genParse(parse);
    pad.startCount = genParse(parse);
    pad.endPad     = genParse(parse);
    pad.endCount   = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, pad);
    return pad;
}



function genParseTextCompare(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const cmp = new GTextCompare(nodeId, options);
   

    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }

    
    if (parse.settings.logRequests) 
        logReq(cmp, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, cmp);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 2)
    {
        cmp.input0 = genParse(parse);
        cmp.input1 = genParse(parse);
    }
    else if (nInputs == 1)
    {
        cmp.input0 = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same
    }
  
    
    cmp.operation = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, cmp);
    return cmp;
}



function genParseTextCharacter(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const char = new GTextCharacter(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(char, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, char);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        char.input = genParse(parse);

    char.code = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, char);
    return char;
}



function genParseIndexToName(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const index = new GIndexToName(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(index, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, index);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    index.name  = genParse(parse);
    index.index = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, index);
    return index;
}



function genParseNumberToText(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const num2text = new GNumberToText(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(num2text, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, num2text);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        num2text.input = genParse(parse);

    num2text.format = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, num2text);
    return num2text;
}



function genParseColorToText(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const col2text = new GColorToText(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(col2text, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, col2text);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        col2text.input = genParse(parse);

    col2text.format = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, col2text);
    return col2text;
}



function genParseTextToNumber(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const text2num = new GTextToNumber(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(text2num, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, text2num);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        text2num.input = genParse(parse);

    text2num.format = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, text2num);
    return text2num;
}



function genParseTextToColor(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const text2col = new GTextToColor(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(text2col, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, text2col);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        text2col.input = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, text2col);
    return text2col;
}



function genParseTextSplit(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const split = new GTextSplit(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(split, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, split);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        split.input = genParse(parse);

    split.separator = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, split);
    return split;
}



function genParseTextCSV(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const csv = new GTextCSV(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(csv, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, csv);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        csv.input = genParse(parse);

    csv.rowSeparator    = genParse(parse);
    csv.columnSeparator = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, csv);
    return csv;
}



function genParseTextJson(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const json = new GTextJson(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(json, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, json);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        json.input = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, json);
    return json;
}



function genParseTextFetch(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const fetch = new GTextFetch(nodeId, options);
   

    if (parse.settings.logRequests) 
        logReq(fetch, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, fetch);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    fetch.request     = genParse(parse);
    fetch.cachedValue = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, fetch);
    return fetch;
}



function genParseTextFile(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const file = new GTextFile(nodeId, options);
   

    if (parse.settings.logRequests) 
        logReq(file, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, file);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    file.cachedValue = genParse(parse);
    //file.path        = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, file);
    return file;
}


class Parse
{
    request;
    requestId;
    
    pos; 
    so;

    settings = {};

    save;


    log  = '';
    
    nTab = 0;

    get tab() { return this.inParam ? ' ' : (NL + HTAB.repeat(Math.max(0, this.nTab))); }

    
    inParam = false;

    
    updateNodeId;
    updateParamId;

    viewportZoom;

    currentProgress = 0;
    totalProgress   = 0;

    scope         = []; // current parse stack
    parsedNodes   = []; // must be evaluated to create the value updates


    repeats       = [];

    stopGenerate  = false;


    paramNodeIds  = [];

    updateParams  = [];
    updateValues  = [];
    updateObjects = [];
    updateStyles  = [];

    

    get next() { return this.request[this.pos]; }

    get afterNext() 
    { 
        return this.pos+1 < this.request.length 
             ? this.request[this.pos+1]
             : null;
    }



    constructor(request, firstPos, requestId, updateNodeId, updateParamId, viewportZoom, settings, save)
    {
        this.request       = request;
        this.requestId     = requestId;
          
        this.pos           = firstPos; 
        this.so            = 0;
        
        this.updateNodeId  = updateNodeId; 
        this.updateParamId = updateParamId;
   
        this.viewportZoom  = viewportZoom;

        this.settings      = settings;

        this.save          = save;
    }



    move()
    {
        //return this.request[this.pos++];

        const token = this.request[this.pos++];
        //console.log('token =', token);
        return token;
    }



    isLastRepeat() 
    {
        return isEmpty(this.repeats)
            ||    this.repeats.length == 1
               && this.repeats[0].iteration == this.repeats[0].total-1;
    }



    stop()
    {
        if (curRequestIds.includes(this.requestId))
        {
            removeFromArray(curRequestIds, this.requestId);
            true;
        }

        return this.stopGenerate;
    }
}



function genParse(parse, inParam = true)
{
    //console.log('parse.next', parse.next);

    if (!inParam)
        parse.inParam = false;


    let result = null;


         if (parse.next == PARAM                  ) result = genParseParam             (parse);
        
    else if (parse.next ==        LIST_VALUE             
          || parse.next == NUMBER_LIST_VALUE             
          || parse.next ==   TEXT_LIST_VALUE             
          || parse.next ==  SHAPE_LIST_VALUE      ) result = genParseListValue         (parse);
 
    else if (parse.next == NULL_NODE              ) result = genParseNull              (parse);
    else if (parse.next == VARIABLE               ) result = genParseVariable          (parse);
    else if (parse.next == VARIABLE_GROUP         ) result = genParseVariableGroup     (parse);
    else if (parse.next == IF_ELSE                ) result = genParseIfElse            (parse);
    else if (parse.next == START                  ) result = genParseStart             (parse);
    else if (parse.next == REPEAT                 ) result = genParseRepeat            (parse);
    else if (parse.next == CACHE                  ) result = genParseCache             (parse);
    else if (parse.next == DEFINE                 ) result = genParseDefine            (parse);
    else if (parse.next == FREEZE                 ) result = genParseFreeze            (parse);
    else if (parse.next == TIMER                  ) result = genParseTimer             (parse);
    else if (parse.next == VALUE_NAME             ) result = genParseValueName         (parse);

    else if (parse.next == COMBINE                ) result = genParseJoin              (parse);
    else if (parse.next == CONDENSE               ) result = genParseCondense          (parse);
    else if (parse.next == EXTRACT                ) result = genParseExtract           (parse);
    else if (parse.next == SET_PARAM              ) result = genParseSetParam          (parse);
    else if (parse.next == EXTRACT_PARAM          ) result = genParseExtractParam      (parse);
    else if (parse.next == SUBLIST                ) result = genParseSublist           (parse);
    else if (parse.next == UNIQUE                 ) result = genParseUnique            (parse);
    else if (parse.next == REVERSE_LIST           ) result = genParseReverseList       (parse);
    else if (parse.next == SORT                   ) result = genParseSort              (parse);
    else if (parse.next == COLUMN                 ) result = genParseColumn            (parse);
    else if (parse.next == CELL                   ) result = genParseCell              (parse);
    else if (parse.next == LIST                   ) result = genParseList              (parse);
    else if (parse.next == SELECT                 ) result = genParseSelect            (parse);
    else if (parse.next == LIST_COUNT             ) result = genParseListCount         (parse);
    else if (parse.next == CONTAINS               ) result = genParseListContains      (parse);
     
    else if (parse.next == NUMBER_VALUE           ) result = genParseNumValue          (parse);
    else if (parse.next == NUMBER                 ) result = genParseNumber            (parse);
     
    else if (parse.next == NUMBER_SIGN            ) result = genParseSign              (parse);
    else if (parse.next == NUMBER_ABSOLUTE        ) result = genParseAbsolute          (parse);
    else if (parse.next == NUMBER_ROUND           ) result = genParseRound             (parse);
    else if (parse.next == NUMBER_MINMAX          ) result = genParseMinMax            (parse);
    else if (parse.next == NUMBER_SIMPLE_MINMAX   ) result = genParseSimpleMinMax      (parse);
    else if (parse.next == NUMBER_LIMITS          ) result = genParseLimits            (parse);
    else if (parse.next == NUMBER_CURVE           ) result = genParseNumberCurve       (parse);
    else if (parse.next == NUMBER_NAN             ) result = genParseNaNisNumber       (parse);
    else if (parse.next == NUMBER_CONSTANT        ) result = genParseConstant          (parse);
    else if (parse.next == NUMBER_DATETIME        ) result = genParseDateTime          (parse);
    else if (parse.next == NUMBER_SEQUENCE        ) result = genParseSequence          (parse);
    else if (parse.next == NUMBER_RANGE           ) result = genParseRange             (parse);
    else if (parse.next == NUMBER_WAVE            ) result = genParseWave              (parse);
    else if (parse.next == NUMBER_RANDOM          ) result = genParseRandom            (parse);
    else if (parse.next == NUMBER_NOISE           ) result = genParseNoise             (parse);
    else if (parse.next == NUMBER_PROBABILITY     ) result = genParseProbability       (parse);
    else if (parse.next == NUMBER_ACCUMULATE      ) result = genParseAccumulate        (parse);
    else if (parse.next == NUMBER_INTERPOLATE     ) result = genParseInterpolate       (parse);
    else if (parse.next == NUMBER_SOLVE           ) result = genParseSolve             (parse);
    else if (parse.next == NUMBER_ANIMATE         ) result = genParseAnimate           (parse);
    
    else if (parse.next == NUMBER_MATH            ) result = genParseMath              (parse, (nodeId, options) => new GMath          (nodeId, options));
    else if (parse.next == NUMBER_SIMPLE_MATH     ) result = genParseSimpleMath        (parse, (nodeId, options) => new GMath          (nodeId, options));
    else if (parse.next == NUMBER_ADD             ) result = genParseArithmetic        (parse, (nodeId, options) => new GAdd           (nodeId, options));
    else if (parse.next == NUMBER_SUBTRACT        ) result = genParseArithmetic        (parse, (nodeId, options) => new GSubtract      (nodeId, options));
    else if (parse.next == NUMBER_MULTIPLY        ) result = genParseArithmetic        (parse, (nodeId, options) => new GMultiply      (nodeId, options));
    else if (parse.next == NUMBER_DIVIDE          ) result = genParseArithmetic        (parse, (nodeId, options) => new GDivide        (nodeId, options));
    else if (parse.next == NUMBER_MODULO          ) result = genParseArithmetic        (parse, (nodeId, options) => new GModulo        (nodeId, options));
    else if (parse.next == NUMBER_EXPONENT        ) result = genParseArithmetic        (parse, (nodeId, options) => new GExponent      (nodeId, options));
     
    else if (parse.next == NUMBER_BOOLEAN         ) result = genParseBoolean           (parse);
    else if (parse.next == NUMBER_NOT             ) result = genParseArithmetic        (parse, (nodeId, options) => new GNot           (nodeId, options));
    else if (parse.next == NUMBER_AND             ) result = genParseArithmetic        (parse, (nodeId, options) => new GAnd           (nodeId, options));
    else if (parse.next == NUMBER_OR              ) result = genParseArithmetic        (parse, (nodeId, options) => new GOr            (nodeId, options));
    else if (parse.next == NUMBER_XOR             ) result = genParseArithmetic        (parse, (nodeId, options) => new GXor           (nodeId, options));
     
    else if (parse.next == NUMBER_CONDITION       ) result = genParseCondition         (parse);
    else if (parse.next == NUMBER_EQUAL           ) result = genParseConditionBase     (parse, (nodeId, options) => new GEqual         (nodeId, options));
    else if (parse.next == NUMBER_NOT_EQUAL       ) result = genParseConditionBase     (parse, (nodeId, options) => new GNotEqual      (nodeId, options));
    else if (parse.next == NUMBER_LESS            ) result = genParseConditionBase     (parse, (nodeId, options) => new GLess          (nodeId, options));
    else if (parse.next == NUMBER_LESS_OR_EQUAL   ) result = genParseConditionBase     (parse, (nodeId, options) => new GLessOrEqual   (nodeId, options));
    else if (parse.next == NUMBER_GREATER         ) result = genParseConditionBase     (parse, (nodeId, options) => new GGreater       (nodeId, options));
    else if (parse.next == NUMBER_GREATER_OR_EQUAL) result = genParseConditionBase     (parse, (nodeId, options) => new GGreaterOrEqual(nodeId, options));
 
    else if (parse.next == NUMBER_TRIG            ) result = genParseTrigonometric     (parse);
    else if (parse.next == NUMBER_SIN             ) result = genParseTrigBase          (parse, (nodeId, options) => new GSine          (nodeId, options));
    else if (parse.next == NUMBER_COS             ) result = genParseTrigBase          (parse, (nodeId, options) => new GCosine        (nodeId, options));
    else if (parse.next == NUMBER_TAN             ) result = genParseTrigBase          (parse, (nodeId, options) => new GTangent       (nodeId, options));

    else if (parse.next == CONVERT_ANGLE          ) result = genParseConvertAngle      (parse);
 
    else if (parse.next == TEXT_VALUE             ) result = genParseTextValue         (parse);
    else if (parse.next == TEXT                   ) result = genParseText              (parse);
    else if (parse.next == TEXT_LENGTH            ) result = genParseTextLength        (parse);
    else if (parse.next == TEXT_TRIM              ) result = genParseTextTrim          (parse);
    else if (parse.next == TEXT_SUBSTRING         ) result = genParseTextSubstring     (parse);
    else if (parse.next == TEXT_CONTAINS          ) result = genParseTextContains      (parse);
    else if (parse.next == TEXT_CASE              ) result = genParseTextCase          (parse);
    else if (parse.next == TEXT_CHAR              ) result = genParseTextCharacter     (parse);
    else if (parse.next == INDEX_TO_NAME          ) result = genParseIndexToName          (parse);
    else if (parse.next == NUMBER_TO_TEXT         ) result = genParseNumberToText      (parse);
    else if (parse.next == COLOR_TO_TEXT          ) result = genParseColorToText       (parse);
    else if (parse.next == TEXT_TO_NUMBER         ) result = genParseTextToNumber      (parse);
    else if (parse.next == TEXT_TO_COLOR          ) result = genParseTextToColor       (parse);
    else if (parse.next == TEXT_REPLACE           ) result = genParseTextReplace       (parse);
    else if (parse.next == TEXT_JOIN              ) result = genParseTextJoin          (parse);
    else if (parse.next == TEXT_PAD               ) result = genParseTextPad           (parse);
    else if (parse.next == TEXT_COMPARE           ) result = genParseTextCompare       (parse);
    else if (parse.next == TEXT_SPLIT             ) result = genParseTextSplit         (parse);
    else if (parse.next == TEXT_CSV               ) result = genParseTextCSV           (parse);
    else if (parse.next == TEXT_JSON              ) result = genParseTextJson          (parse);
    else if (parse.next == TEXT_FETCH             ) result = genParseTextFetch         (parse);
    else if (parse.next == TEXT_FILE              ) result = genParseTextFile          (parse);
 
    else if (parse.next == COLOR_VALUE            ) result = genParseColorValue        (parse);
    else if (parse.next == COLOR                  ) result = genParseColor             (parse);
    else if (parse.next == VALID_COLOR            ) result = genParseValidColor        (parse);
    else if (parse.next == CORRECT_COLOR          ) result = genParseCorrectColor      (parse);
    else if (parse.next == COLOR_CONTRAST         ) result = genParseColorContrast     (parse);
    else if (parse.next == COLOR_CONVERT_P3       ) result = genParseColorConvertP3    (parse);
    else if (parse.next == COLORBLIND             ) result = genParseColorBlind        (parse);
    else if (parse.next == COLOR_INTERPOLATE      ) result = genParseColorInterpolate  (parse);
    else if (parse.next == COLOR_BLEND            ) result = genParseColorBlend        (parse);
      
    else if (parse.next == FILL_VALUE             ) result = genParseFillValue         (parse);
    else if (parse.next == FILL                   ) result = genParseFill              (parse);
      
    else if (parse.next == COLOR_STOP_VALUE       ) result = genParseColorStopValue    (parse);
    else if (parse.next == COLOR_STOP             ) result = genParseColorStop         (parse);
      
    else if (parse.next == GRADIENT_VALUE         ) result = genParseGradientValue     (parse);
    else if (parse.next == GRADIENT               ) result = genParseGradient          (parse);
      
    else if (parse.next == STROKE_VALUE           ) result = genParseStrokeValue       (parse);
    else if (parse.next == STROKE                 ) result = genParseStroke            (parse);
      
    else if (parse.next == ROUND_CORNERS_VALUE    ) result = genParseRoundCornersValue (parse);
    else if (parse.next == ROUND_CORNERS          ) result = genParseRoundCorners      (parse);
      
    else if (parse.next == DROP_SHADOW_VALUE      ) result = genParseDropShadowValue   (parse);
    else if (parse.next == DROP_SHADOW            ) result = genParseDropShadow        (parse);
      
    else if (parse.next == INNER_SHADOW_VALUE     ) result = genParseInnerShadowValue  (parse);
    else if (parse.next == INNER_SHADOW           ) result = genParseInnerShadow       (parse);
      
    else if (parse.next == LAYER_BLUR_VALUE       ) result = genParseLayerBlurValue    (parse);
    else if (parse.next == LAYER_BLUR             ) result = genParseLayerBlur         (parse);
      
    else if (parse.next == BACK_BLUR_VALUE        ) result = genParseBackBlurValue     (parse);
    else if (parse.next == BACK_BLUR              ) result = genParseBackBlur          (parse);

    else if (parse.next == LAYER_BLEND_VALUE      ) result = genParseLayerBlendValue   (parse);
    else if (parse.next == LAYER_BLEND            ) result = genParseLayerBlend        (parse);
      
    else if (parse.next == LAYER_MASK_VALUE       ) result = genParseLayerMaskValue    (parse);
    else if (parse.next == LAYER_MASK             ) result = genParseLayerMask         (parse);
      
    else if (parse.next == COLOR_STYLE            ) result = genParseColorStyle        (parse);
      
    else if (parse.next == RECTANGLE              ) result = genParseRectangle         (parse);
    else if (parse.next == LINE                   ) result = genParseLine              (parse);
    else if (parse.next == ELLIPSE                ) result = genParseEllipse           (parse);
    else if (parse.next == TRAPEZE                ) result = genParseTrapeze           (parse);
    else if (parse.next == POLYGON                ) result = genParsePolygon           (parse);
    else if (parse.next == STAR                   ) result = genParseStar              (parse);
    else if (parse.next == TEXT_SHAPE             ) result = genParseTextShape         (parse);
 
    else if (parse.next == POINT_VALUE            ) result = genParsePointValue        (parse);
    else if (parse.next == POINT                  ) result = genParsePoint             (parse);
    else if (parse.next == POINT_CORNER           ) result = genParsePointCorner       (parse);
    else if (parse.next == VECTOR_PATH_VALUE      ) result = genParseVectorPathValue   (parse);
    else if (parse.next == VECTOR_PATH            ) result = genParseVectorPath        (parse);
    
    else if (parse.next == VECTOR_VERTEX_VALUE    ) result = genParseVectorVertexValue (parse);
    else if (parse.next == VECTOR_VERTEX          ) result = genParseVectorVertex      (parse);
    else if (parse.next == VECTOR_EDGE_VALUE      ) result = genParseVectorEdgeValue   (parse);
    else if (parse.next == VECTOR_EDGE            ) result = genParseVectorEdge        (parse);
    else if (parse.next == VECTOR_REGION_VALUE    ) result = genParseVectorRegionValue (parse);
    else if (parse.next == VECTOR_REGION          ) result = genParseVectorRegion      (parse);
    else if (parse.next == VECTOR_NETWORK_VALUE   ) result = genParseVectorNetworkValue(parse);
    else if (parse.next == VECTOR_NETWORK         ) result = genParseVectorNetwork     (parse);

    else if (parse.next == BOOLEAN_VALUE          ) result = genParseShapeBooleanValue (parse);
    else if (parse.next == BOOLEAN                ) result = genParseShapeBoolean      (parse);

    else if (parse.next == SHAPE_GROUP_VALUE      ) result = genParseShapeGroupValue   (parse);
    else if (parse.next == SHAPE_GROUP            ) result = genParseShapeGroup        (parse);
 
    else if (parse.next == FRAME_VALUE            ) result = genParseFrameValue        (parse);
    else if (parse.next == FRAME                  ) result = genParseFrame             (parse);
 
    else if (parse.next == MOVE                   ) result = genParseMove              (parse);
    else if (parse.next == ROTATE                 ) result = genParseRotate            (parse);
    else if (parse.next == SCALE                  ) result = genParseScale             (parse);
    else if (parse.next == SKEW                   ) result = genParseSkew              (parse);

    else if (parse.next == CENTER                 ) result = genParseCenter            (parse);
    else if (parse.next == RESET_XFORM            ) result = genParseResetTransform    (parse);

    else if (parse.next == MEASURE_POINTS         ) result = genParseMeasurePoints     (parse);
    else if (parse.next == CIRCLE_CENTER          ) result = genParseCircleCenter      (parse);
    else if (parse.next == INTERSECT_LINES        ) result = genParseIntersectLines    (parse);
    else if (parse.next == INTERPOLATE_POINT      ) result = genParseInterpolatePoint  (parse);
    else if (parse.next == POINT_ON_PATH          ) result = genParsePointOnPath       (parse);

    else if (parse.next == PLACE                  ) result = genParsePlace             (parse);
    else if (parse.next == SHAPE_APPLY            ) result = genParseShapeApply        (parse);
    
    else if (parse.next == RENDER                 ) result = genParseRender            (parse);
 
    else if (parse.next == GROUP_NODE             ) result = genParseGroupNode         (parse);
    else if (parse.next == GROUP_PARAM            ) result = genParseGroupParam        (parse);
 
    else if (parse.next == COMMENT                ) result = genParseComment           (parse);
    else if (parse.next == COMMENT_ARROW          ) result = genParseCommentArrow      (parse);
    else if (parse.next == PANEL                  ) result = genParsePanel             (parse);

    else consoleError('unknown parse token \'' + parse.next + '\' @ ' + parse.pos);


    parse.inParam = false;


    if (result)
        return result;
    else
    {
        parse.so++;
        return null;
    }
}



function genParseNodeStart(parse)
{
    const type     = parse.move();
    const nodeId   = parse.move();
    const nodeName = parse.move();

    
    parse.scope.push(nodeId);


    if (parse.parsedNodes.find(n => n.nodeId == nodeId))
        return [type, nodeId, {nodeName: nodeName}, true];


    const options = genParseNodeOptions(parse);

    options.nodeName = nodeName;


    return [type, nodeId, options, false];
}



function genParseNodeEnd(parse, node = null)
{
    parse.scope.pop();

    if (node)
    {
        if (isEmpty(parse.scope))
            node.topLevel = true;

        pushUnique(parse.parsedNodes, node);
    }
}



function genParseNodeOptions(parse)
{
    const opt = parseInt(parse.move());

    const options = 
    {
        active:       ((opt >>  0) & 1) != 0,
        beforeActive: ((opt >>  1) & 1) != 0,
        enabled:      ((opt >>  2) & 1) != 0,
        cached:       ((opt >>  3) & 1) != 0,
        unknown:      ((opt >>  4) & 1) != 0,
        hasInputs:    ((opt >> 20) & 1) != 0,
        existing:     ((opt >> 21) & 1) != 0
    };

    return options;
}



function genParseParamCount(parse)
{
    const nParamIds = parseInt(parse.move());

    if (parse.settings.logRequests) 
        parse.log += parse.tab + nParamIds;

    return nParamIds;
}



function genParseParam(parse)
{
    if (parse.next != PARAM) 
        return null;
        
    parse.move(); // PARAM
    const type = parse.move(); // type

    
    const nodeId  = parse.move();
    const paramId = parse.move();
    
    const param   = new GParam(nodeId, paramId);
 
    
    pushUnique(parse.paramNodeIds, nodeId);


    if (parse.settings.logRequests) 
        logReqParam(param, type, parse);


    return param;
}



function genParseParamId(parse)
{
    const paramId = parse.move();

    if (parse.settings.logRequests)
        parse.log += parse.tab + paramId;

    return paramId;
}


class RequestSettings
{
    request;
    pos;

    so            = 0;
    nTab          = 0;
  
    skipNewLine   = false;

    loggedNodeIds = [];
    


    constructor(request, pos)
    {
        this.request = request;
        this.pos     = pos;
    }


    get tab() 
    { 
        if (this.skipNewLine)
        {
            this.skipNewLine = false;
            return '';
        }
        else 
            return NL + HTAB.repeat(Math.max(0, this.nTab)); 
    }
}



function log(str)
{
    debugInfo.innerHTML = str;
}



function logFunction(funcName, obj = null)
{
    let str = funcName;

    if (obj)
        str = obj.id + '.' + str;

    console.log(
        '%c ' + str + ' ', 
        'background: #fc0; color: #632;');
}



function logString(str, color = 'white', background = 'red')
{
    console.log(
        '%c ' + str + ' ', 
        'background: ' + background + '; color: ' + color + ';');
}



function logValueUpdates(updateNodeId, updateParamId, values)
{
    //console.log('values = ', values);

    let log     = '';
    let newLine = true;

    if (   updateNodeId  != '' 
        || updateParamId != '')
        log = '↓ ' + logReqId(updateNodeId) + '.' + logReqId(updateParamId);
    else
        newLine = false;

          
    let i    = 0;
    let nTab = 0;

    while (i < values.length)
    {
        const nodeId  = values[i++];
        const nInputs = parseInt(values[i++]);

        log += 
              (newLine ? NL : '') + HTAB.repeat(Math.max(0, nTab))
            + nodeId;// + ' ' + nInputs;

        newLine = true;

        nTab++;

        for (let j = 0; j < nInputs; j++)
        {
            const index = values[i++];
            const type  = values[i++];
            const value = values[i++];

            log += 
                  NL + HTAB.repeat(Math.max(0, nTab))
                + index + ' ' + displayValue(type, value);
        }

        nTab--;
    }


    console.log(
        '%c%s', 
        'background: #e70; color: white;', 
        log);
}



function logObjectUpdates(objects)
{
    console.log(
        '%cobjects', 
        'background: #07e; color: white;', 
        objects);
}



function logStyleUpdates(styles)
{
    console.log(
        '%cstyles', 
        'background: #b4d; color: white;', 
        styles);
}



function logSavePages(pageJson)
{
    console.log('%cSAVING PAGES\n' + pageJson, 'color: black; background: #ddeeee;');
}



function logSaveNodes(nodeJson)
{
    console.log('%cSAVING NODES\n' + nodeJson, 'color: black; background: #ddeeff;');
}



function logSaveConnections(conns)
{
    let log = 'SAVING ' + conns.length + ' ' + countString(conns.length, 'CONNECTION');

    for (const conn of conns)
        log += '\n' + conn.toJson();

    console.log(
        '%c' + log, 
        'color: black; background: #ddeeff;');
}



function logUpdateSavedConnections(conns)
{
    let log = 'UPDATING ' + conns.length + ' ' + countString(conns.length, 'SAVED CONNECTION');

    for (const conn of conns)
        log += '\n' + conn.toJson();

    console.log(
        '%c' + log, 
        'color: black; background: #ddeeff;');
}



function logUndoStack()
{
    let log = 
        'UNDO STACK:\n'
        + actionManager.actions.map(a => '    ' + a.name).join('\n');

    console.log('%c%s', 'background: #ffd; color: #b80;', log);
}



function logRedoStack()
{
    let log = 
         'REDO STACK:\n'
        + actionManager.redoActions.map(a => '    ' + a.name).join('\n');

    console.log('%c%s', 'background: #fff4e8; color: #c64;', log);
}


function logRequest(parse)
{
    let log = '';

    if (   parse.updateNodeId  != '' 
        || parse.updateParamId != '')
        log = '↓ ' + logReqId(parse.updateNodeId) + '.' + logReqId(parse.updateParamId);

    log += parse.log;

    console.log(
        '%c%s', 
        'background: #60aa60; color: #fff', 
         log);
}



function logReq(node, parse, ignore, nInputs = -1)
{
    parse.log += parse.tab + node.type;
    parse.log += logReqNodeId(node, ignore);

    if (    nInputs > -1
        && !ignore)
        parse.log += ' ' + nInputs;
}



function logReqNodeId(node, ignore = false)
{
    return ' ' 
         + logReqId(node.nodeId) 
         + ' ' + logReqId(node.nodeName)
         + (!ignore
            ? logReqOptions(node)
            : '');
}



function logReqId(nodeId)
{
    return nodeId == '' ? '\'\'' : nodeId;
}



function logReqOptions(node)
{
    let log = '';

    if ( node.options.active      ) log += ' ' + ACTIVE;
    if ( node.options.beforeActive) log += ' ' + BEFORE_ACTIVE;
    if (!node.options.enabled     ) log += ' ' + DISABLED;

    if (!node.cached              ) log += ' ' + NOCACHE;

    return log;
}



function logReqParam(param, type, parse)
{
    parse.log += 
                parse.tab + PARAM
        + ' ' + type 
        + ' ' + logReqId(param.nodeId) 
        + '.' + logReqId(param.paramId);
}



function logReqNode(node, parse)
{
    parse.log += parse.tab + node.type;
    parse.log += logReqNodeId(node);
}



function logReqColorContrast(lerp, nInputs, valueIndex, parse, ignore)
{
    parse.log += parse.tab + COLOR_CONTRAST;
    parse.log += logReqNodeId(lerp, ignore);

    if (!ignore)
    {
        parse.log += ' ' + nInputs;

        if (nInputs == 1)
            parse.log += ' ' + valueIndex;
    }
}



function logReqValue(type, val, parse)
{
    parse.log += parse.tab + type + ' ' + displayValue(type, val);
}



// function logReqListValue(list, parse, ignore)
// {
//     parse.log += parse.tab + LIST_VALUE + ' ' + displayValue(LIST_VALUE, list);
// }



// function logReqColorValue(val, parse, ignore)
// {
//     parse.log += parse.tab + COLOR_VALUE + ' ' + displayValue(COLOR_VALUE, val);
// }



// function logReqNumberValue(val, parse, ignore)
// {
//     parse.log += parse.tab + NUMBER_VALUE + ' ' + displayValue(NUMBER_VALUE, val);
// }



// function logReqFillValue(fill, parse, ignore)
// {
//     parse.log += parse.tab + FILL_VALUE + ' ' + displayValue(FILL_VALUE, fill);
// }



// function logReqStrokeValue(stroke, parse, ignore)
// {
//     // parse.log += parse.tab + STROKE_VALUE + ' ' + displayValue(STROKE_VALUE, stroke);
// }



// function logReqColorStopValue(stop, parse, ignore)
// {
//     // parse.log += parse.tab + COLOR_STOP_VALUE + ' ' + displayValue(COLOR_STOP_VALUE, stop);
// }



function logSavedNode(nodeKey, darkMode)
{
    const log  = formatSavedNodeJson(figGetPageData(nodeKey, false));

    if (darkMode)
    {
        console.log(
            '%c%s\n%c%s', 
            'background: #fa24; color: white;', 
            noNodeTag(nodeKey), 
            'background: #fa44; color: #edc;',
            log);
    }
    else
    {
        console.log(
            '%c%s\n%c%s', 
            'background: #fdb; color: black;', 
            noNodeTag(nodeKey), 
            'background: #fed; color: black;',
            log);
    }
}



function formatSavedNodeJson(json)
{
    let formJson = json
        .replace('{\n', '')
        .replace('\n}', '')

        .replace('[\n' + HTAB, '')
        .replace('\n' + HTAB + ']', '')

        .split(HTAB + '"params":\n').join('') // have to do .split().join() because there's no .replace() in TS

        .split('": "').join(': ')
        .split('", "').join(': ')

        .split(HTAB + '"').join(HTAB)
        .split(HTAB + HTAB + '["').join(HTAB + HTAB)
        
        .split('",\n').join('\n')
        .split('"\n').join('\n')
        
        .split('"],\n').join('\n');


    if (formJson[formJson.length-1] == '"')
        formJson = formJson.substring(0, formJson.length - 1);

    if (formJson.substring(formJson.length-2) == '"]')    
        formJson = formJson.substring(0, formJson.length - 2);

    return formJson;
}



function formatSavedDataJson(json)
{
    let formJson = json
        .replace('{\n', '')
        .replace('\n}', '')
        .replace('[\n' + HTAB, '')
        .replace('\n' + HTAB + ']', '');

    return formJson;
}



function logSavedConn(conn, darkMode)
{
    const strConn = connToString(conn, true);

    if (darkMode)
    {
        console.log(
            '%c%s', 
            'background: #4f44; color: #ded', 
            strConn); 
    }
    else
    {
        console.log(
            '%c%s', 
            'background: #cfc; color: black;', 
            strConn); 
    }
}


// Observer = 2°

const D65 = [0.95047, 1, 1.08883]; 


function createColorSpace(R, G, B, Y, W, gamma, degamma, regamma, luminance)
{
    return {    
        R:         R,
        G:         G,
        B:         B,

        Y:         Y,

        W:         W,

        lin2xyz:   rgbMatrix(R, G, B, W),
        xyz2lin:   inversem3(rgbMatrix(R, G, B, W)),

        gamma:     gamma,
        
        degamma:   degamma,
        regamma:   regamma,
        
        luminance: luminance
    };
}


function rgbMatrix(R, G, B, W)
{
    const C0 = colorVector(R);
    const C1 = colorVector(G);
    const C2 = colorVector(B);

    const M = [ [ C0[0], C1[0], C2[0] ], 
                [ C0[1], C1[1], C2[1] ], 
                [ C0[2], C1[2], C2[2] ] ];

    const S = mulv3m3(W, inversem3(M));

    return [ [ S[0]*C0[0], S[1]*C1[0], S[2]*C2[0] ],
             [ S[0]*C0[1], S[1]*C1[1], S[2]*C2[1] ],
             [ S[0]*C0[2], S[1]*C1[2], S[2]*C2[2] ] ];
}


function colorVector(c)
{
    const x = c[0],
          y = c[1];

    return [x/y, 1, (1-x-y)/y];
}



const sRGB = createColorSpace
(
    [0.64, 0.33], // R
    [0.3,  0.6 ], // G
    [0.15, 0.06], // B

    [0.212656,
     0.715158,
     0.072186], // Y

    D65,        // W

    2.4,        // gamma



    function(v) // degamma
    {
        return v >= 0.04045
               ? Math.pow((v + 0.055) / 1.055, this.gamma)
               : v / 12.92;
    },
    


    function(v) // regamma
    {
        return v > 0.0031308
               ? 1.055 * Math.pow(v, 1/this.gamma) - 0.055
               : v * 12.92;
    },
    

    
    function(rgb) // luminance
    {
        return  this.Y[0] * this.degamma(rgb[0]) 
              + this.Y[1] * this.degamma(rgb[1]) 
              + this.Y[2] * this.degamma(rgb[2]);
    }
);



function rgbSaturateHsv(rgb, amount)
{
    const hsv = rgb2hsv(rgb);
    hsv[1] *= amount;
    return hsv2rgb(hsv);
}



function rgbSaturateHsl(rgb, amount)
{
    const hsl = rgb2hsl(rgb);
    hsl[1] *= amount;
    return hsl2rgb(hsl);
}


function rgb2hsv_(r, g, b)
{
    let h, s, v;

    let min = Math.min(Math.min(r, g), b),
        max = Math.max(Math.max(r, g), b);

    let delta = max - min;

    v = max;
    s = max == 0 ? 0 : delta / max;
	
    if      (max == r) h = 1/6 * (g - b) / delta + 1;   // between yellow and magenta
    else if (max == g) h = 1/6 * (b - r) / delta + 1/3; // between cyan and yellow
    else if (max == b) h = 1/6 * (r - g) / delta + 2/3; // between between magenta and cyan

	if (h > 1) h -= 1;
	//if (h < 0) h += 1;

    return [h, s, v];
}



function rgb2hsv(rgb)
{
    return rgb2hsv_(rgb[0], rgb[1], rgb[2]);
}



function hsv2rgb_(h, s, v)
{
    while (h < 0) h++;
    h %= 1;

    if (s == 0)
        return [v, v, v]; // achromatic

    h *= 6 - 0.0000001;

    let i = Math.floor(h);
    let f = h - i;
	
    let p = v * (1 - s);
    let q = v * (1 - s * f);
    let t = v * (1 - s * (1 - f));

    switch (i)
    {
        case 0:  return [v, t, p];
        case 1:  return [q, v, p];
        case 2:  return [p, v, t];
        case 3:  return [p, q, v];
        case 4:  return [t, p, v];
        default: return [v, p, q];
    }
}



function hsv2rgb(hsv)
{
	return hsv2rgb_(hsv[0], hsv[1], hsv[2]);
}


function rgb2hsl_(r, g, b)
{
    let h, s, l;

    let min = Math.min(Math.min(r, g), b),
        max = Math.max(Math.max(r, g), b);

    let delta = max - min;

    l = (max + min) / 2;

         if (max == min) h = 0;
    else if (max == r  ) h = 1/6 * (g - b) / delta + 1;
    else if (max == g  ) h = 1/6 * (b - r) / delta + 1/3;
    else if (max == b  ) h = 1/6 * (r - g) / delta + 2/3;

         if (max == min) s = 0;
    else if (l <= 0.5)   s = delta / (2 * l);
    else if (l >  0.5)   s = delta / (2 - 2 * l);

    return [h, s, l];
}



function rgb2hsl(rgb)
{
    return rgb2hsl_(rgb[0], rgb[1], rgb[2]);
}



function hsl2rgb_(h, s, l)
{
    while (h < 0) h++;
    h %= 1;

    let q =
        l < 0.5
        ? l * (1 + s)
        : l + s - l * s;

    let p = 2 * l - q;

    let tr = h + 1/3;
    let tg = h;
    let tb = h - 1/3;

    if (tr < 0) tr += 1; if (tr > 1) tr -= 1;
    if (tg < 0) tg += 1; if (tg > 1) tg -= 1;
    if (tb < 0) tb += 1; if (tb > 1) tb -= 1;

    let r, g, b;

    let qp6 = (q - p) * 6; 

         if (tr <  1/6)				r = p + qp6 * tr;
    else if (tr >= 1/6 && tr < 0.5)	r = q;
    else if (tr >= 0.5 && tr < 2/3)	r = p + qp6 * (2/3 - tr);
    else							r = p;
	
         if (tg <  1/6)				g = p + qp6 * tg;
    else if (tg >= 1/6 && tg < 0.5)	g = q;
    else if (tg >= 0.5 && tg < 2/3) g = p + qp6 * (2/3 - tg);
    else							g = p;

         if (tb <  1/6)				b = p + qp6 * tb;
    else if (tb >= 1/6 && tb < 0.5) b = q;
    else if (tb >= 0.5 && tb < 2/3) b = p + qp6 * (2/3 - tb);
    else							b = p;

    return [r, g, b];
}



function hsl2rgb(hsl)
{
    return hsl2rgb_(hsl[0], hsl[1], hsl[2]);
}


function xyz2lms(xyz)
{
    return mulv3m3(xyz, CAT);//HPE);
}



function lms2xyz(lms)
{
    return mulv3m3(lms, invCAT);//invHPE);
}



function rgb2xyz(rgb, cs = sRGB)
{ 
    return lrgb2xyz(degamma(rgb, cs), cs);
}    



function lrgb2xyz(rgb, cs = sRGB)
{
    return mulv3m3(rgb, cs.lin2xyz);
}        



function xyz2rgb(xyz, cs = sRGB)
{
    return regamma(xyz2lrgb(xyz, cs), cs);
}



function xyz2lrgb(xyz, cs = sRGB)
{
    return mulv3m3(xyz, cs.xyz2lin);
}


function rgb2luv(rgb, cs = sRGB)
{
    return xyz2luv(rgb2xyz(rgb, cs), cs.W);
}



function luv2rgb(luv, cs = sRGB)
{
    return xyz2rgb(luv2xyz(luv, cs.W), cs);
}



function xyz2luv(xyz, W = sRGB.W)
{
    const x = xyz[0], 
          y = xyz[1], 
          z = xyz[2];

    const e = cube(6/29);
    const k = cube(29/3);

    const yw = y / W[1];

    let l = 
        yw > e
        ? 116 * Math.cbrt(yw) - 16
        : k * yw;

    const u_ = 4*x / (x + 15*y + 3*z);
    const v_ = 9*y / (x + 15*y + 3*z);
    
    const uw = 4*W[0] / (W[0] + 15*W[1] + 3*W[2]);
    const vw = 9*W[1] / (W[0] + 15*W[1] + 3*W[2]);
    
    const u = 13*l * (u_ - uw);
    const v = 13*l * (v_ - vw);

    return [
        l / 100, 
        u / 100, 
        v / 100];
}



function luv2xyz(luv, W = sRGB.W)
{
    let l = luv[0] * 100, 
        u = luv[1] * 100, 
        v = luv[2] * 100;

    const e = cube(6/29);    
    const k = cube(29/3);

    const uw = 4*W[0] / (W[0] + 15*W[1] + 3*W[2]);
    const vw = 9*W[1] / (W[0] + 15*W[1] + 3*W[2]);
    
    const y = 
        l > e*k
        ? cube((l + 16) / 116)
        : l / k;
    
    const a = (52*l / nozero(u + 13*l*uw) - 1) / 3;
    const b = -5 * y;
    const c = -1/3;
    const d =  y * (39*l / nozero(v + 13*l*vw) - 5);

    const x = (d - b) / nozero(a - c);

    const z = x*a + b;

    return [x, y, z];
}


function rgb2lab(rgb, cs = sRGB)
{
    return xyz2lab(rgb2xyz(rgb, cs), cs.W);
}



function lab2rgb(lab, cs = sRGB)
{
    return xyz2rgb(lab2xyz(lab, cs.W), cs);
}



function xyz2lab(xyz, W = sRGB.W)
{
    const x = xyz[0], 
          y = xyz[1], 
          z = xyz[2];

    const e = 0.008856; //cube(6/29);
    const k = 903.3;    //cube(29/3);

    let xw = x / W[0];
    let yw = y / W[1];
    let zw = z / W[2];

    xw = xw > e ? Math.cbrt(xw) : (k / 100 * xw + 0.16) / 1.16;
    yw = yw > e ? Math.cbrt(yw) : (k / 100 * yw + 0.16) / 1.16;
    zw = zw > e ? Math.cbrt(zw) : (k / 100 * zw + 0.16) / 1.16;


    const l = (1.16 * yw) - 0.16;
    const a = 5 * (xw - yw);
    const b = 2 * (yw - zw);

    return [l, a, b];
}



function lab2xyz(lab, W = sRGB.W)
{
    const l = lab[0], 
          a = lab[1], 
          b = lab[2];

    const e = 0.008856 / 100; //cube(6/29) / 100;
    const k = 903.3    / 100; //cube(29/3) / 100;

    const yw = (l + 0.16)/1.16;
    const xw = a/5 + yw;
    const zw = yw - b/2;

    let x = cube(xw) > e ? cube(xw) : (1.16*xw - 0.16) / k;
    let y = cube(yw) > e ? cube(yw) : (1.16*yw - 0.16) / k;
    let z = cube(zw) > e ? cube(zw) : (1.16*zw - 0.16) / k;

    x *= W[0];
    y *= W[1];
    z *= W[2];
 
    return [x, y, z];
}


function rgb2oklab(rgb, cs = sRGB)
{
    return rgb2oklab_(rgb[0], rgb[1], rgb[2], cs);
}



function rgb2oklab_(r, g, b, cs = sRGB) 
{
    return oklms2oklab(rgb2oklms_(r, g, b, cs));
}



function rgb2oklms_(r, g, b, cs = sRGB) 
{
    r = cs.degamma(r);
    g = cs.degamma(g);
    b = cs.degamma(b);

    return [
        0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b,
	    0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b,
	    0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b ];
}        



function oklms2oklab(lms) 
{
    const l = Math.cbrt(lms[0]);
    const m = Math.cbrt(lms[1]);
    const s = Math.cbrt(lms[2]);

    const l_ = 0.2104542553 * l + 0.7936177850 * m - 0.0040720468 * s;
    const a_ = 1.9779984951 * l - 2.4285922050 * m + 0.4505937099 * s;
    const b_ = 0.0259040371 * l + 0.7827717662 * m - 0.8086757660 * s;

    return [
        l_,
        a_, 
        b_ ];
}        



function oklab2rgb(lab, cs = sRGB)
{
    return oklms2rgb(oklab2oklms(lab), cs);
}



function oklab2rgb_(l, a, b, cs = sRGB) 
{
    return oklab2rgb([l, a, b], cs);
}



function oklab2oklms(lab)
{
    return oklab2oklms_(lab[0], lab[1], lab[2]);
}



function oklab2oklms_(l, a, b) 
{
    return [
        l + 0.3963377774 * a + 0.2158037573 * b,
        l - 0.1055613458 * a - 0.0638541728 * b,
        l - 0.0894841775 * a - 1.2914855480 * b ];
}



function oklms2rgb(lms, cs = sRGB) 
{
    const l = cube(lms[0]);
    const m = cube(lms[1]);
    const s = cube(lms[2]);

	const r =  4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s;
	const g = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s;
	const b = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s;

    return [
        cs.regamma(r),
        cs.regamma(g),
        cs.regamma(b) ];
}


const hclok_C_scale = 0.89;


function opp2pol(opp) // opponent to polar
{
    // either lab or luv, 
    // the polar transformation is the same

    const l = opp[0], 
          a = opp[1], 
          b = opp[2];

    const h = Math.atan2(b, a);
    const c = Math.sqrt(a*a + b*b);

    return [h, c, l];
}



function pol2opp(pol) // polar to opponent
{
    // either lab or luv, 
    // the polar transformation is the same

    const h = pol[0], 
          c = pol[1], 
          l = pol[2];

    const a = c * Math.cos(h);
    const b = c * Math.sin(h);

    return [l, a, b];
}


function hclok2rgb(hcl, cs = sRGB)
{
    hcl = [...hcl];

    hcl[0] *= Tau;
    hcl[1] *= hcl[2]; 

    return oklab2rgb(pol2opp(hcl), cs);
}    



function hclok2rgb_(h, c, l, cs = sRGB)
{
    return hclok2rgb_([h, c, l], cs);
}    
    
    
    
function rgb2hclok(rgb, cs = sRGB)
{
    const hcl = opp2pol(rgb2oklab(rgb, cs));

    hcl[0] /= Tau;
    hcl[1] /= nozero(hcl[2]);

    while (hcl[0] < 0) hcl[0] += 1;
    while (hcl[0] > 1) hcl[0] -= 1;

    return hcl;
}



function rgb2hclok_(r, g, b, cs = sRGB)
{
    return rgb2hclok([r, g, b], cs);
}



function hclab2lab(hcl)
{
    hcl = [...hcl];

    hcl[0] *= Tau;
    hcl[1] *= hcl[2];

    return pol2opp(hcl);
}



function hclab2rgb(hcl, cs = sRGB)
{
    return lab2rgb(hclab2lab(hcl), cs);
}



function lab2hclab(lab)
{
    let hcl = opp2pol(lab);

    hcl[0] /= Tau;
    hcl[1] /= hcl[2];

    while (hcl[0] < 0) hcl[0] += 1;
    while (hcl[0] > 1) hcl[0] -= 1;

    return hcl;
}



function rgb2hclab(rgb, cs = sRGB)
{
    return lab2hclab(rgb2lab(rgb, cs));
}



function hcluv2luv(hcl)
{
    hcl = [...hcl];

    hcl[0] *= Tau;
    hcl[1] *= hcl[2];

    return pol2opp(hcl);
}



function hcluv2rgb(hcl, cs = sRGB)
{
    return luv2rgb(hcluv2luv(hcl), cs);
}



function luv2hcluv(luv)
{
    let hcl = opp2pol(luv);

    hcl[0] /= Tau;
    hcl[1] /= hcl[2];

    while (hcl[0] < 0) hcl[0] += 1;
    while (hcl[0] > 1) hcl[0] -= 1;

    return hcl;
}



function rgb2hcluv(rgb, cs = sRGB)
{
    return luv2hcluv(rgb2luv(rgb, cs));
}


function srgb2p3(rgb)
{
    const p3 = 
        [ [ 0.8225, 0.1774, 0      ],
          [ 0.0332, 0.9669, 0      ],
          [ 0.0171, 0.0724, 0.9108 ] ];

    rgb = degamma(rgb);

    return regamma(dot3(p3, rgb));
}



function p32srgb(rgb) 
{
    const invp3 = 
        [ [ 1.2249, -0.2247, 0      ],
          [-0.0420,  1.0419, 0      ],
          [-0.0197, -0.0786, 1.0979 ] ];
  
    rgb = dot3(invp3, degamma(rgb));
  
    return regamma(rgb);
}


const ColorSpaces = 
[
    ['hex',   'Hex'   ],
    ['rgb',   'RGB'   ], 
    ['hsv',   'HSV'   ], 
    ['hsl',   'HSL'   ], 
    ['hclok', 'HCL/ok'],
    ['hclab', 'HCL/ab'],
    ['hcluv', 'HCL/uv'],
    ['oklab', 'okLab' ],
    ['lab',   'Lab'   ],
    ['luv',   'Luv'   ]
];



class ColorSpace
{
    hex   = Object.freeze(0);
    rgb   = Object.freeze(1);
    hsv   = Object.freeze(2);
    hsl   = Object.freeze(3);
    hclok = Object.freeze(4);
    hclab = Object.freeze(5);
    hcluv = Object.freeze(6);
    oklab = Object.freeze(7);
    lab   = Object.freeze(8);
    luv   = Object.freeze(9);
}



class Color
extends Float32Array
{
    get r() { return this[0]; }
    get g() { return this[1]; }
    get b() { return this[2]; }
    get a() { return this[3]; }
    get s() { return this[4]; }

    set r(r) { this[0] = r; }
    set g(g) { this[1] = g; }
    set b(b) { this[2] = b; }
    set a(a) { this[3] = a; }
    set s(s) { this[4] = s; }



    constructor(c = null)
    {
        super(5); // c1, c2, c3, a, s (space)

        if (c)
        {
            this.r = c.r;
            this.g = c.g;
            this.b = c.b;
            this.a = c.a;
            this.s = c.s;
        }
        else
        {
            this.r = 0;
            this.g = 0;
            this.b = 0;
            this.a = 0;
            this.s = ColorSpace.rgb;
        }
    }
}


const ColorEpsilon = 0.001;



function rgb2dataColor(rgb)
{
    const _space = 'rgb';

    return [
        _space, 
        getNormalColorValue(rgb[0], _space, 0), 
        getNormalColorValue(rgb[1], _space, 1), 
        getNormalColorValue(rgb[2], _space, 2) ]; 
}



function makeDataColor(space, c1, c2, c3)
{
    const _space = colorSpace(space.value);

    return [
        _space, 
        getNormalColorValue(c1.value, _space, 0), 
        getNormalColorValue(c2.value, _space, 1), 
        getNormalColorValue(c3.value, _space, 2) ]; 
}



function dataColorIsNaN(c)
{
    return isNaN(c[1])
        || isNaN(c[2])
        || isNaN(c[3]);
}



function dataColorIsValid(col, lim = ColorEpsilon)
{
    return rgbIsValid(dataColor2rgb(col), lim);
}



function dataColorIsOk(col, lim = ColorEpsilon)
{
    return rgbIsOk(dataColor2rgb(col), lim);
}


const rgb_NaN = [
    Number.NaN,
    Number.NaN,
    Number.NaN ];

const rgba_NaN = [
    Number.NaN,
    Number.NaN,
    Number.NaN,
    Number.NaN ];


const rgbInvalid  = [0xff, 0, 0xff];
const rgbaInvalid = [0xff, 0, 0xff, 0xff];


const dataColor_NaN = Object.freeze([
    'rgb',
    Number.NaN,
    Number.NaN,
    Number.NaN ]);


// Hunt-Pointer-Estevez
// const HPE = [[ 0.4002, 0.7076, -0.0808],
//              [-0.2263, 1.1653,  0.0457],
//              [ 0,      0,       0.9182]];

// const invHPE = inversem3(HPE);


// CIECAM02
const CAT = [[ 0.7328, 0.4296, -0.1624],
             [-0.7036, 1.6975,  0.0061],
             [ 0.0030, 0.0136,  0.9834]];

const invCAT = inversem3(CAT);


const M1 = [[ 0.8189330101, 0.3618667424, -0.1288597137 ],
            [ 0.0329845436, 0.9293118715,  0.0361456387 ],
            [ 0.0482003018, 0.2643662691,  0.6338517070 ]];

const invM1 = inversem3(M1);



function rgbIsNaN(rgb) 
{
    return isNaN(rgb[0])
        || isNaN(rgb[1])
        || isNaN(rgb[2]);
}



function rgbaIsNaN(rgba) 
{
    return isNaN(rgba[0])
        || isNaN(rgba[1])
        || isNaN(rgba[2])
        || isNaN(rgba[3]);
}



function rgbIsValid(rgb, lim = ColorEpsilon)
{
    return rgb[0] > -lim && rgb[0] < 1 + lim 
        && rgb[1] > -lim && rgb[1] < 1 + lim 
        && rgb[2] > -lim && rgb[2] < 1 + lim;
}



function rgbaIsValid(rgba, lim = ColorEpsilon)
{
    return rgba[0] > -lim && rgba[0] < 1 + lim 
        && rgba[1] > -lim && rgba[1] < 1 + lim 
        && rgba[2] > -lim && rgba[2] < 1 + lim
        && rgba[3] > -lim && rgba[3] < 1 + lim;
}



function rgbIsOk(rgb, lim = ColorEpsilon)
{
    return !rgbIsNaN  (rgb)
        &&  rgbIsValid(rgb, lim);
}



function rgbaIsOk(rgba, lim = ColorEpsilon)
{
    return !rgbaIsNaN  (rgba)
        &&  rgbaIsValid(rgba, lim);
}



function invalid2validRgb(rgb)
{
    return [
        Math.min(Math.max(0, rgb[0]), 1),
        Math.min(Math.max(0, rgb[1]), 1),
        Math.min(Math.max(0, rgb[2]), 1) ];
}



function rgbLerp(rgb1, rgb2, t)
{
    return [ lerp(rgb1[0], rgb2[0], t),
             lerp(rgb1[1], rgb2[1], t),
             lerp(rgb1[2], rgb2[2], t) ];
}



function rgbaLerp(rgba1, rgba2, t)
{
    return [ lerp(rgba1[0], rgba2[0], t),
             lerp(rgba1[1], rgba2[1], t),
             lerp(rgba1[2], rgba2[2], t),
             lerp(rgba1[3], rgba2[3], t) ];
}



function rgbAdd(rgb1, rgb2)
{
    return [ rgb1[0] + rgb2[0],
             rgb1[1] + rgb2[1],
             rgb1[2] + rgb2[2] ];
}



function rgbSub(rgb1, rgb2)
{
    return [ rgb1[0] - rgb2[0],
             rgb1[1] - rgb2[1],
             rgb1[2] - rgb2[2] ];
}



function rgbMuls(rgb, s)
{
    return [ rgb[0] * s,
             rgb[1] * s,
             rgb[2] * s ];
}



function rgbAvg(rgb1, rgb2)
{
    return [ (rgb1[0] + rgb2[0]) / 2,
             (rgb1[1] + rgb2[1]) / 2,
             (rgb1[2] + rgb2[2]) / 2 ];
}



function rgbMax(rgb1, rgb2)
{
    return [ Math.max(rgb1[0], rgb2[0]),
             Math.max(rgb1[1], rgb2[1]),
             Math.max(rgb1[2], rgb2[2]) ];
}



function rgbPow(col, p)
{
    return [
        Math.pow(col[0], p), 
        Math.pow(col[1], p), 
        Math.pow(col[2], p) ]
}



function allConesWork(cones)
{
    return cones.l == 1 
        && cones.m == 1 
        && cones.s == 1;
}



function rgbToString(rgb)
{
    return '{' + Math.round(rgb[0] * 255) + ', '
               + Math.round(rgb[1] * 255) + ', '
               + Math.round(rgb[2] * 255) + '}';
}



function colorStyle_(r, g, b, a)
{
    if (a !== undefined)
    {
        return 'rgba('
            + Math.round(r * 0xff) + ', '
            + Math.round(g * 0xff) + ', '
            + Math.round(b * 0xff) + ', '
            + a + ')';
    }
    else
    {
        return 'rgb('
            + Math.round(r * 0xff) + ', '
            + Math.round(g * 0xff) + ', '
            + Math.round(b * 0xff) + ')';
    }
}



function colorStyleRgb_(r, g, b)
{
    return colorStyle_(r, g, b, 1);
}



function rgb2style(rgb)
{
    return colorStyle_(rgb[0], rgb[1], rgb[2], 1);
}



function colorStyleRgba_(r, g, b, a)
{
    return colorStyle_(r, g, b, a);
}



function rgba2style(rgba)
{
    return colorStyle_(rgba[0], rgba[1], rgba[2], rgba[3]);
}



function rgb2style_a(rgb, a = 1)
{
    return colorStyle_(rgb[0], rgb[1], rgb[2], a);
}



function toRgba(rgb_)
{
    return rgb_.length == 3
         ? [...rgb_, 1]
         : rgb_;
}



function rgb_a(rgb, a = 1)
{
    return [rgb[0], rgb[1], rgb[2], a];
}



function isDark(rgb, threshold = 0.71)
{
    return rgb2hclok(rgb)[2] < threshold;
}



function rgbDistance(col1, col2)
{
    const d0 = col2[0] - col1[0];
    const d1 = col2[1] - col1[1];
    const d2 = col2[2] - col1[2];

    return Math.sqrt(d0*d0 + d1*d1 + d2*d2);
}



function rgbaMul(rgba, v)
{
    return [
        rgba[0] * v,
        rgba[1] * v,
        rgba[2] * v,
        rgba[3] * v ];
}



function rgbaDiv(rgba, v)
{
    return [
        rgba[0] / v,
        rgba[1] / v,
        rgba[2] / v,
        rgba[3] / v ];
}



function maxRgbDistance(col1, col2)
{
    return Math.max(Math.max(Math.max(
        Math.abs(col2[0] - col1[0]),
        Math.abs(col2[1] - col1[1])),
        Math.abs(col2[2] - col1[2])));
}



function rgbEqual(rgb1, rgb2)
{
    return Math.abs(rgb1[0] - rgb2[0]) < ColorEpsilon
        && Math.abs(rgb1[1] - rgb2[1]) < ColorEpsilon
        && Math.abs(rgb1[2] - rgb2[2]) < ColorEpsilon;        
}



function style2rgba(style) // SLOW
{
    utilContext.fillStyle = style;
    utilContext.fillRect(0, 0, 1, 1);

    return rgbaDiv(utilContext.getImageData(0, 0, 1, 1).data, 0xFF);
}



function computedStyle2rgba(obj, style) // SLOW
{
    utilContext.fillStyle = getStyleValue(obj, style);
    utilContext.fillRect(0, 0, 1, 1);

    return rgbaDiv(utilContext.getImageData(0, 0, 1, 1).data, 0xFF);
}



function getTextColorFromBackColor(rgb, opacity = 1)
{
    return !rgbIsNaN(rgb)
           ? (opacity >= 0.5
               ? (isDark(rgb) ? [1, 1, 1, 0.75] : [0, 0, 0, 0.75])
               : (darkMode ? [1, 1, 1, 0.75] : [0, 0, 0, 0.75]))
           : (darkMode ? rgbaNoColorTextDark : rgbaNoColorTextLight);
}



function getDefaultWarningRgba(rgb)
{
    return !rgbIsNaN(rgb)
         ? (isDark(rgb)  ? [1, 1, 1, 0.133] : [0, 0, 0, 0.161])  
         : (darkMode ? [1, 1, 1, 0.031] : [0, 0, 0, 0.031]);  
}



function getWarningStyles(colBack)
{
    let warnStyle1, 
        warnStyle2;
    
        
    const colWarning = getDefaultWarningRgba(colBack);

     
    if (!rgbIsNaN(colBack))
    {
        const hclBack = rgb2hclok(colBack);

        const hclBack1 = [...hclBack];
        const hclBack2 = [...hclBack];

        hclBack1[0] += 1/12;  if (hclBack1[0] > 1) hclBack1[0] -= 1;
        hclBack2[0] -= 1/12;  if (hclBack2[0] < 0) hclBack2[0] += 1;


        const altBack1 = rgb_a(clampRgb(hclok2rgb(hclBack1)), 0.35);
        const altBack2 = rgb_a(clampRgb(hclok2rgb(hclBack2)), 0.35);

        const factor   = getWarningFactor(colBack);

        const colWarn1 = rgbaLerp(colWarning, altBack1, factor);
        const colWarn2 = rgbaLerp(colWarning, altBack2, factor);
        
        warnStyle1     = rgba2style(colWarn1);
        warnStyle2     = rgba2style(colWarn2);
    }
    else
    {
        warnStyle1 = rgba2style(colWarning);
        warnStyle2 = rgba2style(colWarning);
    }


    return [warnStyle1, 
            warnStyle2];
}



function getWarningGradient(i, style1, style2)
{
    return 'repeating-linear-gradient('
            + '-45deg, '
            + 'transparent 0 ' + i   + 'px,' 
            +  style1 + ' '    + i   + 'px ' + i*2 +'px,'
            + 'transparent '   + i*2 + 'px ' + i*3 +'px,'
            +  style2 + ' '    + i*3 + 'px ' + i*4 +'px)';
}



function getWarningFactor(colBack)
{
    let dr, dg, db;

    if (colBack[0] < 0) dr = -colBack[0]; else if (colBack[0] > 1) dr = colBack[0] - 1; else dr = 0;
    if (colBack[1] < 0) dg = -colBack[1]; else if (colBack[1] > 1) dg = colBack[1] - 1; else dg = 0;
    if (colBack[2] < 0) db = -colBack[2]; else if (colBack[2] > 1) db = colBack[2] - 1; else db = 0;
    
    const d   = [dr, dg, db].sort()[1];
    const avg = (dr + dg + db) / 3;

    const factor = Math.min((d + avg) / 2, 1);

    // if (this.id == 'color')
    // {
    //     console.log('colBack =', colBack);
    //     console.log('dr     =', dr);
    //     console.log('dg     =', dg);
    //     console.log('db     =', db);
    //     console.log('d      =', d);
    //     console.log('avg    =', avg);
    //     console.log('factor =', factor);
    //     console.log('');
    // }

    return factor;
}



function getStripeBackColor(rgbBack)
{
    let rgbStripeBack = [...rgbBack];
        
    const factor = getWarningFactor(rgbBack);

    if (factor > 0)
    {
        const hcl = rgb2hclok(clampRgb(rgbBack));
        hcl[1] /= 2;
        

        rgbStripeBack = rgbLerp(rgbBack, clipChroma(hclok2rgb(hcl)), factor);
    }

    return rgbStripeBack;
}



function getDefaultWarningStyle(rgba)
{
    return !rgbaIsNaN(rgba)
         ? (isDark(rgba)  ? '#ffffff29' : '#00000022')
         : (darkMode ? '#ffffff08' : '#00000006'); 
}



function clampRgb(_rgb)
{
    const rgb = [..._rgb];

    rgb[0] = Math.min(Math.max(0, rgb[0]), 1);   
    rgb[1] = Math.min(Math.max(0, rgb[1]), 1);   
    rgb[2] = Math.min(Math.max(0, rgb[2]), 1); 

    return rgb;
}



function clampChan(val)
{
    return Math.min(Math.max(0, val), 1);
}



function setChan(_col, chan, val)
{
    const col = [..._col];
    col[chan] = val;
    return col;
}



function clipChroma(rgb)
{
    let hcl = rgb2hclok(rgb);

    let loopProtect = 10000;

    while (!rgbIsValid(hclok2rgb(hcl))
         && hcl[1] > 0.001
         && loopProtect-- > 0)
        hcl[1] -= 0.001;

    rgb = hclok2rgb(hcl);

    rgb[0] = Math.min(Math.max(0, rgb[0]), 1);   
    rgb[1] = Math.min(Math.max(0, rgb[1]), 1);   
    rgb[2] = Math.min(Math.max(0, rgb[2]), 1); 

    return rgb;
}



function noColorStyle(rgba)
{
    if (!rgbaIsNaN(rgba))
        return 'transparent';
    else
    {
        return darkMode
            ? 'rgba(56, 56, 56, 0.95)'
            : 'rgba(255, 255, 255, 0.95)';
    }
}


// https://ixora.io/projects/colorblindness/color-blindness-simulation-research/


const lmsW = xyz2lms(lrgb2xyz([1, 1, 1]));
const lmsB = xyz2lms(lrgb2xyz([0, 0, 1]));
const lmsR = xyz2lms(lrgb2xyz([1, 0, 0]));

const lq1 = (lmsW[2]*lmsB[0] - lmsB[2]*lmsW[0]) / (lmsW[2]*lmsB[1] - lmsB[2]*lmsW[1]);
const lq2 = (lmsW[1]*lmsB[0] - lmsB[1]*lmsW[0]) / (lmsW[1]*lmsB[2] - lmsB[1]*lmsW[2]);

const mq1 = (lmsW[2]*lmsB[1] - lmsB[2]*lmsW[1]) / (lmsW[2]*lmsB[0] - lmsB[2]*lmsW[0]);
const mq2 = (lmsW[0]*lmsB[1] - lmsB[0]*lmsW[1]) / (lmsW[0]*lmsB[2] - lmsB[0]*lmsW[2]);

const sq1 = (lmsW[1]*lmsR[2] - lmsR[1]*lmsW[2]) / (lmsW[1]*lmsR[0] - lmsR[1]*lmsW[0]);
const sq2 = (lmsW[0]*lmsR[2] - lmsR[0]*lmsW[2]) / (lmsW[0]*lmsR[1] - lmsR[0]*lmsW[1]);

const bq1 = lmsW[0] / lmsW[2];
const bq2 = lmsW[1] / lmsW[2];


// this is a number I made up following the information here: https://www.color-blindness.com/2007/07/20/monochromacy-complete-color-blindness/
// the simulation itself gives grayscale
// on the site the simulation has color in it, so I decided to leave some color in as well,
// but the amount is completely arbitrary, I just felt that this particular value matches
// the description on that site without being unrealistically exaggerated
const blueMono = 0.88;


function rgb2colorblind(rgb, l, m, s, cs = sRGB)
{
    if (   l == 0
        && m == 0
        && s == 0)
    {
        // achromatopsia is simulated by taking only the luminance

        const a = 
              cs.Y[0] * rgb[0]
            + cs.Y[1] * rgb[1]
            + cs.Y[2] * rgb[2];

        rgb = [a, a, a];
    }
    else
    {
        const xyz = rgb2xyz(rgb, cs);
        const lms = xyz2lms(xyz);

        const a = 
              cs.Y[0] * rgb[0]
            + cs.Y[1] * rgb[1]
            + cs.Y[2] * rgb[2];

        const lm = Math.min(l + m, 1);


        const lms_ = [
            lms[0] + lerp(blueMono * (bq1*lms[2] - lms[0]), (1 - l) * ((lq1*lms[1] + lq2*lms[2]) - lms[0]), lm),
            lms[1] + lerp(blueMono * (bq2*lms[2] - lms[1]), (1 - m) * ((mq1*lms[0] + mq2*lms[2]) - lms[1]), lm),
            lms[2] + lerp(0,                     lerp(s, 1 - s, lm) * ((sq1*lms[0] + sq2*lms[1]) - lms[2]), lm) ];

        const xyz_ = lms2xyz(lms_);
              rgb  = xyz2rgb(xyz_, cs);


        let bm_ = rgb2lab(rgb, cs);
        bm_[0] = lerp(a, bm_[0], lm);
        rgb = lab2rgb(bm_, cs);

        
        rgb = rgbLerp(
            [a, a, a], 
            rgb, 
            Math.min(s + lm, 1));
    }
    

    return rgb;
}


function rgb2hex(rgb)
{
    let hex =
          Math.round(rgb[0] * 0xff).toString(16).padStart(2, '0').toUpperCase()
        + Math.round(rgb[1] * 0xff).toString(16).padStart(2, '0').toUpperCase()
        + Math.round(rgb[2] * 0xff).toString(16).padStart(2, '0').toUpperCase();

    return hex;
}



function rgba2hex(rgba)
{
    let hex =
          Math.round(rgba[0] * 0xff).toString(16).padStart(2, '0').toUpperCase()
        + Math.round(rgba[1] * 0xff).toString(16).padStart(2, '0').toUpperCase()
        + Math.round(rgba[2] * 0xff).toString(16).padStart(2, '0').toUpperCase()
        + Math.round(rgba[3] * 0xff).toString(16).padStart(2, '0').toUpperCase();

    return hex;
}



function validHex2rgb(hex) // can process invalid '-'
{
    return hex.indexOf(NAN_DISPLAY) > -1 
           ? rgb_NaN 
           : hex2rgb(hex);
}



function validHex2rgba(hex) // can process invalid '-'
{
    return hex.indexOf(NAN_DISPLAY) > -1 
           ? rgba_NaN 
           : hex2rgba(hex);
}



function hex2rgb(hex)
{
    if (hex[0] == '#')
        hex = hex.substring(1);

        
    let rgb = [];

    if (hex.length >= 6)
    {
        rgb[0] = parseInt(hex.slice(0, 2), 16); 
        rgb[1] = parseInt(hex.slice(2, 4), 16); 
        rgb[2] = parseInt(hex.slice(4, 6), 16); 
    }
    else if (hex.length >= 3)
    {
        rgb[0] = parseInt(hex[0], 16) * 0x11; 
        rgb[1] = parseInt(hex[1], 16) * 0x11; 
        rgb[2] = parseInt(hex[2], 16) * 0x11; 
    }
    else if (hex.length == 2)
    {
        let v = parseInt(hex, 16);
        
        rgb[0] = v; 
        rgb[1] = v; 
        rgb[2] = v; 
    }
    else if (hex.length == 1)
    {
        let v = parseInt(hex, 16);
        
        rgb[0] = v * 0x11; 
        rgb[1] = v * 0x11; 
        rgb[2] = v * 0x11; 
    }
    else if (hex.length == 0)
    {
        rgb[0] = 0; 
        rgb[1] = 0; 
        rgb[2] = 0;         
    }


    rgb[0] /= 0xff;
    rgb[1] /= 0xff;
    rgb[2] /= 0xff;

    
    return rgb;
}



function hex2rgba(hex)
{
    if (hex[0] == '#')
        hex = hex.substring(1);

        
    let rgba = [];

    if (hex.length >= 8)
    {
        rgba[0] = parseInt(hex.slice(0, 2), 16); 
        rgba[1] = parseInt(hex.slice(2, 4), 16); 
        rgba[2] = parseInt(hex.slice(4, 6), 16); 
        rgba[3] = parseInt(hex.slice(6, 8), 16); 
    }
    else if (hex.length >= 6)
    {
        rgba[0] = parseInt(hex.slice(0, 2), 16); 
        rgba[1] = parseInt(hex.slice(2, 4), 16); 
        rgba[2] = parseInt(hex.slice(4, 6), 16); 
        rgba[3] = 0xff; 
    }
    else if (hex.length >= 4)
    {
        rgba[0] = parseInt(hex[0], 16) * 0x11; 
        rgba[1] = parseInt(hex[1], 16) * 0x11; 
        rgba[2] = parseInt(hex[2], 16) * 0x11; 
        rgba[3] = parseInt(hex[3], 16) * 0x11; 
    }
    else if (hex.length == 3)
    {
        rgba[0] = parseInt(hex[0], 16) * 0x11; 
        rgba[1] = parseInt(hex[1], 16) * 0x11; 
        rgba[2] = parseInt(hex[2], 16) * 0x11; 
        rgba[3] = 0xff; 
    }
    else if (hex.length == 2)
    {
        let v = parseInt(hex, 16);
        
        rgba[0] = v; 
        rgba[1] = v; 
        rgba[2] = v; 
        rgba[3] = 0xff; 
    }
    else if (hex.length == 1)
    {
        let v = parseInt(hex, 16);
        
        rgba[0] = v * 0x11; 
        rgba[1] = v * 0x11; 
        rgba[2] = v * 0x11; 
        rgba[3] = 0xff; 
    }
    else if (hex.length == 0)
    {
        rgba[0] = 0; 
        rgba[1] = 0; 
        rgba[2] = 0;         
        rgba[3] = 0; 
    }


    rgba[0] /= 0xff;
    rgba[1] /= 0xff;
    rgba[2] /= 0xff;
    rgba[3] /= 0xff;


    return rgba;
}


function getContrastRatio2(textColor, backColor)
{
    if (    rgbIsNaN  (textColor)
        || !rgbIsValid(textColor))
        return Number.NaN;

    const txtY = sRGB.luminance(textColor);
    const  bgY = sRGB.luminance(backColor);

    return (
        bgY > txtY
        ? ( bgY + 0.05) / (txtY + 0.05)
        : (txtY + 0.05) / ( bgY + 0.05));
}



function getContrastRating2(ratio)
{
         if (ratio >= 7  ) return 'AAA';
    else if (ratio >= 4.5) return 'AA';
    else if (ratio >= 3  ) return 'AA<sub>L</sub>'
    else                   return '';
}



function getContrastRatio3(textColor, backColor)
{
    if (!rgbIsOk(textColor))
        return Number.NaN;

    return APCAcontrast(
        sRGBtoY(textColor),
        sRGBtoY(backColor));
}



// I copied the code below from https://github.com/Myndex/SAPC-APCA/blob/master/WEBTOOLS/APCA/JS/DEV.0.1.2.G_SAPCsRGB.js
// and refactored it to fit my code style.

const mainTRC     = 2.4; // 2.4 exponent emulates actual monitor perception
       
const sRco        = 0.2126729, 
      sGco        = 0.7151522, 
      sBco        = 0.0721750; // sRGB coefficients
   
const normBG      = 0.56, 
      normTXT     = 0.57,
      revTXT      = 0.62,
      revBG       = 0.65; // G-4g constants for use with 2.4 exponent
   
const blkThrs     = 0.022,
      blkClmp     = 1.414, 
      scaleBoW    = 1.14,
      scaleWoB    = 1.14,
      loBoWthresh = 0.035991,
      loWoBthresh = 0.035991,
      loBoWfactor = 27.7847239587675,
      loWoBfactor = 27.7847239587675,
      loBoWoffset = 0.027,
      loWoBoffset = 0.027,
      loClip      = 0.001,
      deltaYmin   = 0.0005;



function sRGBtoY(rgb) 
{
    // NOTE this is not the actual sRGB luminance as it
    // ignores the straight section. Using actual sRGB
    // luminance gives a slightly different contrast score.

    return sRco * Math.pow(rgb[0], mainTRC) 
         + sGco * Math.pow(rgb[1], mainTRC)
         + sBco * Math.pow(rgb[2], mainTRC);
}



function APCAcontrast(txtY, bgY)
{
    let SAPC           = 0; // For raw SAPC values
    let outputContrast = 0; // For weighted final values

    txtY = 
        txtY > blkThrs 
        ? txtY 
        : txtY + Math.pow(blkThrs - txtY, blkClmp);
        
    bgY = 
        bgY > blkThrs 
        ? bgY 
        : bgY + Math.pow(blkThrs - bgY, blkClmp);

    if (Math.abs(bgY - txtY) < deltaYmin)  
        return 0; 


    if (bgY > txtY) 
    {  
        SAPC = (Math.pow(bgY, normBG) - Math.pow(txtY, normTXT)) * scaleBoW;

        outputContrast = 
            SAPC < loClip 
            ? 0 
            : SAPC < loBoWthresh
              ? SAPC - SAPC * loBoWfactor * loBoWoffset 
              : SAPC - loBoWoffset;
    } 
    else 
    {  
        SAPC = (Math.pow(bgY, revBG) - Math.pow(txtY, revTXT)) * scaleWoB;

        outputContrast = 
            SAPC > -loClip 
            ? 0 
            : SAPC > -loWoBthresh 
              ? SAPC - SAPC * loWoBfactor * loWoBoffset 
              : SAPC + loWoBoffset;
    }


    return outputContrast * 100;
}


function colorSpace     (index) { return ColorSpaces[index][0]; }
function colorSpaceIndex(space) { return ColorSpaces.findIndex(s => s[0] == space); }

function colorSpaceCount(parse = null)
{ 
    const set = parse ? parse.settings : settings;

    return set.showAllColorSpaces 
           ? ColorSpaces.length
        : ColorSpaces.length - 5; 
}



const rgbFactor  = [255, 255, 255];
const hs_Factor  = [360, 100, 100];
const hclFactor  = [360, 100, 100];
const oppFactor  = [100, 100, 100];
  
 
const rgbScale   = [255, 255, 255];
  
const hs_Scale   = [360, 100, 100];
 
const hclokScale = [360, 50,  100];
const hclabScale = [360, 400, 100];
const hcluvScale = [360, 330, 100];
 
 
const oklabScale = [100,  30,  30];
const labScale   = [100, 100, 100];
const luvScale   = [100, 150, 150];
 


function colorFactor(space)
{
    switch (space)
    {
        case 'hex':
        case 'rgb':   return rgbFactor;

        case 'hsv':
        case 'hsl':   return hs_Factor;

        case 'hclok':
        case 'hclab':
        case 'hcluv': return hclFactor;

        case 'oklab':  
        case 'lab':      
        case 'luv':   return oppFactor;   
        
        default:      consoleError('invalid color factor from space \''+space+'\''); break;
    }
}



function scaleColor(col, space)
{
    let scale;

    switch (space)
    {
        case 'hex':    
        case 'rgb':   scale = rgbScale;   break;

        case 'hsv':    
        case 'hsl':   scale = hs_Scale;   break;

        case 'hclok': scale = hclokScale; break;
        case 'hclab': scale = hclabScale; break;
        case 'hcluv': scale = hcluvScale; break;

        case 'oklab': scale = oklabScale; break;
        case 'lab':   scale = labScale;   break;
        case 'luv':   scale = luvScale;   break;
    }

    return [
        col[0] * scale[0],
        col[1] * scale[1],
        col[2] * scale[2] ];
}



function normalizeRgb(rgb)
{
    return [ rgb[0] / 255,
             rgb[1] / 255,
             rgb[2] / 255 ];
}



function scaleRgb(rgb)
{
    return [ Math.round(rgb[0] * 255),
             Math.round(rgb[1] * 255),
             Math.round(rgb[2] * 255) ];
}



function switchToSpace(node, space)
{
    switch (space)
    {
        case 'hex':   switchToHex   (node); break;
        case 'rgb':   switchToRgb   (node); break;

        case 'hsv':   switchToHsv   (node); break;
        case 'hsl':   switchToHsl   (node); break;

        case 'hclok': switchToHclok (node); break;
        case 'hclab': switchToHclab (node); break;
        case 'hcluv': switchToHcluv (node); break;

        case 'oklab': switchToOklab (node); break;
        case 'lab':   switchToLab   (node); break;
        case 'luv':   switchToLuv   (node); break;
    }

    node.resetAllControlRanges();
}



function switchToHex  (node) { switchToRgbControls   (node); switchToTextbox(node); }
function switchToRgb  (node) { switchToRgbControls   (node);                        }

function switchToHsv  (node) { switchToHs_Controls   (node, 'V');                   }
function switchToHsl  (node) { switchToHs_Controls   (node, 'L');                   }
             
function switchToHclok(node) { switchToHclOklControls(node);                        }
function switchToHclab(node) { switchToHclLabControls(node);                        }
function switchToHcluv(node) { switchToHclLuvControls(node);                        }
             
function switchToOklab(node) { switchToOklabControls (node, 'a', 'b');              }
function switchToLab  (node) { switchToLabControls   (node, 'a', 'b');              }
function switchToLuv  (node) { switchToLuvControls   (node, 'u', 'v');              }
   


function switchToRgbControls(node)
{
    switchToControls(node, 
        'R', 0, rgbScale[0], '', false, 
        'G', 0, rgbScale[1], 
        'B', 0, rgbScale[2]);  

    node.param1.controls[0].min = 
    node.param2.controls[0].min = 
    node.param3.controls[0].min = Number.MIN_SAFE_INTEGER; // allow extrapolation

    node.param1.controls[0].max = 
    node.param2.controls[0].max = 
    node.param3.controls[0].max = Number.MAX_SAFE_INTEGER; // allow extrapolation

    showRgbControlHex(node, false);    
}



function switchToHs_Controls(node, v_or_l) 
{ 
    switchToControls(node, 
        'H',    0, hs_Scale[0], '°', true,  
        'S',    0, hs_Scale[1], 
        v_or_l, 0, hs_Scale[2]);  

    node.param1.controls[0].suffixOffsetY = -4;

    node.param2.controls[0].min = 
    node.param3.controls[0].min = Number.MIN_SAFE_INTEGER; // allow extrapolation

    node.param2.controls[0].max = 
    node.param3.controls[0].max = Number.MAX_SAFE_INTEGER; // allow extrapolation

    showRgbControlHex(node, false); 
}



function switchToHclControls(node, scale) 
{ 
    switchToControls(node, 
        'H', 0, scale[0], '°', true,  
        'C', 0, scale[1], 
        'L', 0, scale[2]);  

    node.param1.controls[0].suffixOffsetY = -4;

    node.param2.controls[0].min = 
    node.param3.controls[0].min = Number.MIN_SAFE_INTEGER; // allow extrapolation

    node.param2.controls[0].max = 
    node.param3.controls[0].max = Number.MAX_SAFE_INTEGER; // allow extrapolation

    showRgbControlHex(node, false); 
}



function switchToHclOklControls(node) { switchToHclControls(node, hclokScale); }
function switchToHclLabControls(node) { switchToHclControls(node, hclabScale); }
function switchToHclLuvControls(node) { switchToHclControls(node, hcluvScale); }



function switchToOppControls(node, c2, c3, scale)
{ 
    switchToControls(node, 
        'L', 0,        scale[0], '', false,  
        c2, -scale[1], scale[1], 
        c3, -scale[2], scale[2]);  

    showRgbControlHex(node, false); 
}



function switchToOklabControls(node) { switchToOppControls(node, 'a', 'b', oklabScale); }
function switchToLabControls  (node) { switchToOppControls(node, 'a', 'b', labScale  ); }
function switchToLuvControls  (node) { switchToOppControls(node, 'u', 'v', luvScale  ); }



function showRgbControlHex(node, show)
{
    node.param1.controls[0].showHex = show;
    node.param2.controls[0].showHex = show;
    node.param3.controls[0].showHex = show;
}



function switchToControls(node, c1, c1min, c1max, c1suffix, c1wrap, c2, c2min, c2max, c3, c3min, c3max)
{
    switchToSliders(node);

    node.param1.setName(c1, false); 
    node.param2.setName(c2, false); 
    node.param3.setName(c3, false);

    node.param1.controls[0].wrapValue = c1wrap;
    node.param1.controls[0].setSuffix(c1suffix, c1suffix != '');

    node.param1.controls[0].setMin(c1min); 
    node.param2.controls[0].setMin(c2min);
    node.param3.controls[0].setMin(c3min);
    
    node.param1.controls[0].setMax(c1max); 
    node.param2.controls[0].setMax(c2max); 
    node.param3.controls[0].setMax(c3max); 
    
    node.param1.updateControls();
    node.param2.updateControls();
    node.param3.updateControls();

    node.param1.controls[0].suffixOffsetY = 0;
}



function switchToTextbox(node)
{
    removeOpColorParamWires(node);

    removeDivFrom(node.param1.div, node.paramHolder);
    removeDivFrom(node.param2.div, node.paramHolder);
    removeDivFrom(node.param3.div, node.paramHolder);
        
    appendDivTo(node.paramColor.div, node.paramHolder);
}



function removeParamDivs(node)
{
    removeOpColorParamWires(node);

    removeDivFrom(node.param1.div,     node.paramHolder);
    removeDivFrom(node.param2.div,     node.paramHolder);
    removeDivFrom(node.param3.div,     node.paramHolder);
    
    removeDivFrom(node.paramColor.div, node.paramHolder);
}



function removeOpColorParamWires(node)
{
    for (let i = node.inputs.length-1; i >= 2; i--)
        if (node.inputs[i].connected)
            uiDisconnect(node.inputs[i]);

    for (let i = node.outputs.length-1; i >= 2; i--)
        for (const input of node.outputs[i].connectedInputs)
            uiDisconnect(input);
}



function switchToSliders(node)
{
    removeDivFrom(node.paramColor.div, node.paramHolder);

    appendDivTo(node.param1.div, node.paramHolder);
    appendDivTo(node.param2.div, node.paramHolder);
    appendDivTo(node.param3.div, node.paramHolder);
}



function rgb2dataColor(rgb)
{
    return [
       'rgb',
        rgb[0],
        rgb[1],
        rgb[2] ];
}



function getNormalColorValue(value, space, chan)
{
    switch (space)
    {
        case 'hex':
        case 'rgb':   return getNormalValueRgb_(value, chan);

        case 'hsv':   
        case 'hsl':   return getNormalValueHs_ (value, chan);

        case 'hclok': 
        case 'hclab': 
        case 'hcluv': return getNormalValueHcl (value, chan);

        case 'oklab':  
        case 'lab':    
        case 'luv':   return getNormalValueOpp (value, chan);
    }
}



function getNormalValueRgb_(value, chan)
{
    switch (chan)
    {
        case 0: return value / rgbFactor[0];
        case 1: return value / rgbFactor[1]; 
        case 2: return value / rgbFactor[2];
    }
}



function getNormalValueHs_(value, chan)
{
    switch (chan)
    {
        case 0: return value / hs_Factor[0];
        case 1: return value / hs_Factor[1]; 
        case 2: return value / hs_Factor[2];
    }
}



function getNormalValueOpp(value, chan)
{
    switch (chan)
    {
        case 0: return value / oppFactor[0];
        case 1: return value / oppFactor[1]; 
        case 2: return value / oppFactor[2];
    }
}



function getNormalValueHcl(value, chan)
{
    switch (chan)
    {
        case 0: return value / hclFactor[0];
        case 1: return value / hclFactor[1]; 
        case 2: return value / hclFactor[2];
    }
}



function getNormalColor(color)
{
    return getNormalColor_(
        color[0], 
        color[1], 
        color[2], 
        color[3])
}



function getNormalColor_(space, c1, c2, c3)
{
    switch (space)
    {
        case 'hex':
        case 'rgb':   return getNormalColorRgb_(c1, c2, c3);

        case 'hsv':   
        case 'hsl':   return getNormalColorHs_(c1, c2, c3);

        case 'hclok': 
        case 'hclab': 
        case 'hcluv': return getNormalColorHcl(c1, c2, c3);

        case 'oklab': 
        case 'lab': 
        case 'luv':   return getNormalColorOpp(c1, c2, c3);
    }
}



function getNormalColorRgb_(c1, c2, c3)
{
    return [
        c1 / rgbFactor[0], 
        c2 / rgbFactor[1], 
        c3 / rgbFactor[2]];
}



function getNormalColorHs_(c1, c2, c3)
{
    return [
        c1 / hs_Factor[0], 
        c2 / hs_Factor[1], 
        c3 / hs_Factor[2]];
}



function getNormalColorHcl(c1, c2, c3)
{
    return [
        c1 / hclFactor[0], 
        c2 / hclFactor[1], 
        c3 / hclFactor[2]];
}



function getNormalColorOpp(c1, c2, c3)
{
    return [
        c1 / oppFactor[0], 
        c2 / oppFactor[1], 
        c3 / oppFactor[2]];
}



function getScaledDataColor(color)
{
    switch (color[0])
    {
        case 'hex':
        case 'rgb':   return getScaledDataColorRgb(         color[1], color[2], color[3]);

        case 'hsv':   return getScaledDataColorHs_('hsv',   color[1], color[2], color[3]);
        case 'hsl':   return getScaledDataColorHs_('hsl',   color[1], color[2], color[3]);

        case 'hclok': return getScaledDataColorHcl('hclok', color[1], color[2], color[3]);
        case 'hclab': return getScaledDataColorHcl('hclab', color[1], color[2], color[3]);
        case 'hcluv': return getScaledDataColorHcl('hcluv', color[1], color[2], color[3]);

        case 'oklab': return getScaledDataColorOpp('oklab', color[1], color[2], color[3]);
        case 'lab':   return getScaledDataColorOpp('lab',   color[1], color[2], color[3]);
        case 'luv':   return getScaledDataColorOpp('luv',   color[1], color[2], color[3]);
    }
}



function getScaledDataColorRgb(c1, c2, c3)
{
    return [
       'rgb',
        c1 * rgbFactor[0], 
        c2 * rgbFactor[1], 
        c3 * rgbFactor[2] ];
}



function getScaledDataColorHs_(space, c1, c2, c3)
{
    return [
        space,
        c1 * hs_Factor[0], 
        c2 * hs_Factor[1], 
        c3 * hs_Factor[2] ];
}



function getScaledDataColorHcl(space, c1, c2, c3)
{
    return [
        space,
        c1 * hclFactor[0], 
        c2 * hclFactor[1], 
        c3 * hclFactor[2] ];
}



function getScaledDataColorOpp(space, c1, c2, c3)
{
    return [
        space,
        c1 * oppFactor[0], 
        c2 * oppFactor[1], 
        c3 * oppFactor[2] ];
}



function setDataColorToCurrentSpace(node, color)
{
    const toSpace = colorSpace(node.paramSpace.value);
    node._color   = convertDataColorToSpace(color, toSpace);

    node.setColorParams(node._color);
}



function colorSpaceFactor(space)
{
    switch (space)
    {
        case 'hex':
        case 'rgb':   return rgbFactor;

        case 'hsv':   
        case 'hsl':   return hs_Factor;

        case 'hclok': 
        case 'hclab': 
        case 'hcluv': return hclFactor;

        case 'oklab': 
        case 'lab': 
        case 'luv':   return oppFactor;
    }    
}



function getColorSpaceScale(space)
{
    switch (space)
    {
        case 'hex':
        case 'rgb':   return rgbScale;

        case 'hsv':   
        case 'hsl':   return hs_Scale;

        case 'hclok': return hclokScale;
        case 'hclab': return hclabScale;
        case 'hcluv': return hcluvScale;

        case 'oklab': return oklabScale;
        case 'lab':   return labScale;
        case 'luv':   return luvScale;
    }    
}


function dataColor2array(color)
{
    return [
        color[1], 
        color[2], 
        color[3]];
}



function dataColor2rgb(color)
{
    const col = dataColor2array(color);

    switch (color[0])
    {
        case 'hex':
        case 'rgb':   return           col;

        case 'hsv':   return hsv2rgb  (col);
        case 'hsl':   return hsl2rgb  (col);

        case 'hclok': return hclok2rgb(col);
        case 'hclab': return hclab2rgb(col);
        case 'hcluv': return hcluv2rgb(col);

        case 'oklab': return oklab2rgb(col);
        case 'lab':   return lab2rgb  (col);
        case 'luv':   return luv2rgb  (col);
    }
}



function convertDataColorToSpace(color, toSpace)
{
    switch (toSpace)
    {
        case 'hex':    
        case 'rgb':   return convert2rgb    (color);

        case 'hsv':   return convert2hsv    (color);
        case 'hsl':   return convert2hsl    (color);

        case 'hclok': return convert2hclok  (color);
        case 'hclab': return convert2hclab  (color);
        case 'hcluv': return convert2hcluv  (color);

        case 'oklab': return dataColor2oklab(color);
        case 'lab':   return convert2lab    (color);
        case 'luv':   return convert2luv    (color);
    }
}



function convert2rgb(fromColor)
{
    const col = dataColor2array(fromColor);

    let rgb;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   rgb =           col;  break;

        case 'hsv':   rgb = hsv2rgb  (col); break;
        case 'hsl':   rgb = hsl2rgb  (col); break;

        case 'hclok': rgb = hclok2rgb(col); break;
        case 'hclab': rgb = hclab2rgb(col); break;
        case 'hcluv': rgb = hcluv2rgb(col); break;

        case 'oklab': rgb = oklab2rgb(col); break;
        case 'lab':   rgb = lab2rgb  (col); break;
        case 'luv':   rgb = luv2rgb  (col); break;
    }

    return rgb2dataColor(rgb);
}



function convert2hsv(fromColor)
{
    const col = dataColor2array(fromColor);
    
    let hsv;
    
    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   hsv = rgb2hsv(          col ); break;

        case 'hsv':   hsv =                   col;   break;
        case 'hsl':   hsv = rgb2hsv(hsl2rgb  (col)); break;

        case 'hclok': hsv = rgb2hsv(hclok2rgb(col)); break;
        case 'hclab': hsv = rgb2hsv(hclab2rgb(col)); break;
        case 'hcluv': hsv = rgb2hsv(hcluv2rgb(col)); break;

        case 'oklab': hsv = rgb2hsv(oklab2rgb(col)); break;
        case 'lab':   hsv = rgb2hsv(lab2rgb  (col)); break;
        case 'luv':   hsv = rgb2hsv(luv2rgb  (col)); break;
    }
    
    if (isNaN(hsv[0]))
        hsv[0] = 5/6;
    
    return [
       'hsv',
        hsv[0],
        hsv[1],
        hsv[2] ];
}



function convert2hsl(fromColor)
{
    const col = dataColor2array(fromColor);

    let hsl;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   hsl = rgb2hsl(          col ); break;

        case 'hsv':   hsl = rgb2hsl(hsv2rgb  (col)); break;
        case 'hsl':   hsl =                   col;   break;

        case 'hclok': hsl = rgb2hsl(hclok2rgb(col)); break;
        case 'hclab': hsl = rgb2hsl(hclab2rgb(col)); break;
        case 'hcluv': hsl = rgb2hsl(hcluv2rgb(col)); break;

        case 'oklab': hsl = rgb2hsl(oklab2rgb(col)); break;
        case 'lab':   hsl = rgb2hsl(lab2rgb  (col)); break;
        case 'luv':   hsl = rgb2hsl(luv2rgb  (col)); break;
    }

    return [
       'hsl',
        hsl[0],
        hsl[1],
        hsl[2] ];
}



function dataColor2oklab(fromColor)
{
    const col = dataColor2array(fromColor);

    let lab;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   lab = rgb2oklab(          col ); break;

        case 'hsv':   lab = rgb2oklab(hsv2rgb  (col)); break;
        case 'hsl':   lab = rgb2oklab(hsl2rgb  (col)); break;

        case 'hclok': lab = rgb2oklab(hclok2rgb(col)); break;
        case 'hclab': lab = rgb2oklab(hclab2rgb(col)); break;
        case 'hcluv': lab = rgb2oklab(hcluv2rgb(col)); break;

        case 'oklab': lab =                     col;   break;
        case 'lab':   lab = rgb2oklab(lab2rgb  (col)); break;
        case 'luv':   lab = rgb2oklab(luv2rgb  (col)); break;
    }

    return [
       'oklab',
        lab[0],
        lab[1],
        lab[2] ];
}



function convert2lab(fromColor)
{
    const col = dataColor2array(fromColor);

    let lab;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   lab = rgb2lab(          col ); break;

        case 'hsv':   lab = rgb2lab(hsv2rgb  (col)); break;
        case 'hsl':   lab = rgb2lab(hsl2rgb  (col)); break;

        case 'hclok': lab = rgb2lab(hclok2rgb(col)); break;
        case 'hclab': lab =         hclab2lab(col);  break;
        case 'hcluv': lab = rgb2lab(hcluv2rgb(col)); break;

        case 'oklab': lab = rgb2lab(oklab2rgb(col)); break;
        case 'lab':   lab =                   col;   break;
        case 'luv':   lab = rgb2lab(luv2rgb  (col)); break;
    }

    return [
       'lab',
        lab[0],
        lab[1],
        lab[2] ];
}



function convert2luv(fromColor)
{
    const col = dataColor2array(fromColor);

    let luv;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   luv = rgb2luv(          col ); break;

        case 'hsv':   luv = rgb2luv(hsv2rgb  (col)); break;
        case 'hsl':   luv = rgb2luv(hsl2rgb  (col)); break;

        case 'hclok': luv = rgb2luv(hclok2rgb(col)); break;
        case 'hclab': luv = rgb2luv(hclab2rgb(col)); break;
        case 'hcluv': luv =         hcluv2luv(col);  break;

        case 'oklab': luv = rgb2luv(oklab2rgb(col)); break;
        case 'lab':   luv = rgb2luv(lab2rgb  (col)); break;
        case 'luv':   luv =                   col;   break;
    }

    return [
       'luv',
        luv[0],
        luv[1],
        luv[2] ];
}



function convert2hclok(fromColor)
{
    const col = dataColor2array(fromColor);

    let hcl;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   hcl = rgb2hclok(          col);  break;

        case 'hsv':   hcl = rgb2hclok(hsv2rgb  (col)); break;
        case 'hsl':   hcl = rgb2hclok(hsl2rgb  (col)); break;

        case 'hclok': hcl =                     col;   break;
        case 'hclab': hcl = rgb2hclok(hclab2rgb(col)); break;
        case 'hcluv': hcl = rgb2hclok(hcluv2rgb(col)); break;

        case 'oklab': hcl = rgb2hclok(oklab2rgb(col)); break;
        case 'lab':   hcl = rgb2hclok(lab2rgb  (col)); break;
        case 'luv':   hcl = rgb2hclok(luv2rgb  (col)); break;
    }

    return [
       'hclok',
        hcl[0],
        hcl[1],
        hcl[2] ];
}



function convert2hclab(fromColor)
{
    const col = dataColor2array(fromColor);

    let lab;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   lab = rgb2hclab(          col) ; break;
        
        case 'hsv':   lab = rgb2hclab(hsv2rgb  (col)); break;
        case 'hsl':   lab = rgb2hclab(hsl2rgb  (col)); break;
        
        case 'hclok': lab = rgb2hclab(hclok2rgb(col)); break;
        case 'hclab': lab =                     col;   break;
        case 'hcluv': lab = rgb2hclab(hcluv2rgb(col)); break;
        
        case 'oklab': lab = rgb2hclab(oklab2rgb(col)); break;
        case 'lab':   lab = lab2hclab(          col ); break;
        case 'luv':   lab = rgb2hclab(luv2rgb  (col)); break;
    }

    return [
       'hclab',
        lab[0],
        lab[1],
        lab[2] ];
}



function convert2hcluv(fromColor)
{
    const col = dataColor2array(fromColor);

    let hcl;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   hcl = rgb2hcluv(          col ); break;

        case 'hsv':   hcl = rgb2hcluv(hsv2rgb  (col)); break;
        case 'hsl':   hcl = rgb2hcluv(hsl2rgb  (col)); break;

        case 'hclab': hcl = rgb2hcluv(hclab2rgb(col)); break;
        case 'hcluv': hcl =                     col;   break;
        case 'hclok': hcl = rgb2hcluv(hclok2rgb(col)); break;

        case 'oklab': hcl = rgb2hcluv(oklab2rgb(col)); break;
        case 'lab':   hcl = rgb2hcluv(lab2rgb  (col)); break;
        case 'luv':   hcl = luv2hcluv(          col ); break;
    }

    return [
       'hcluv',
        hcl[0],
        hcl[1],
        hcl[2] ];
}


</script>