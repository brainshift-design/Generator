<script id="generatorScript" type="javascript/worker">
'use strict';




const generatorVersion     = 441;


const MAX_INT32            = 2147483647;
  
const NULL                 = '';
const NULL_VALUE           = 'NULL';
  
const HTAB                 = '  '; // half-tab
const TAB                  = '    ';
const NL                   = '\n';
  
const PLUGIN_LOGO          = '◦ G •';
const PLUGIN_NAME          = 'Generator';
const PLUGIN_LOGO_AND_NAME = PLUGIN_LOGO + ' ' + PLUGIN_NAME;

const OBJECT_PREFIX        = PLUGIN_LOGO + ' ';

const nodeTag              = 'G_NODE';
const connTag              = 'G_CONN';
const pageTag              = 'G_PAGE';
const tempTag              = 'G_TEMP';


const minWindowWidth       = 602;
const minWindowHeight      =  39;


const identity = Object.freeze(
    [[1, 0, 0],
     [0, 1, 0],
     [0, 0, 1]]);



const Epsilon = 0.0000001;
const Tau     = Math.PI * 2;



var enableAsserts = false;



function hardZero(x, eps = 0.000000001) 
{ 
    return Math.abs(x) < eps ? 0 : x;
}



function nozero(x, eps = 0.000000001) 
{ 
    return x != 0 
         ? x 
         : (x < 0 ? -eps : eps);
}



function nozerov(v, eps = 0.000000001) 
{ 
    return point(
        nozero(v.x, eps), 
        nozero(v.y, eps)); 
}



function equal(a, b, eps = 0.000000001)
{
    return Math.abs(b - a) < eps;
}



function sqr (x) { return x*x;   };
function cube(x) { return x*x*x; };
 

function toInt(f) { return Math.floor(f) | 0; }



function nextPow2(x)
{
    x = toInt(x);

    x--;

    x |= x >>  1;
    x |= x >>  2;
    x |= x >>  4;
    x |= x >>  8;
    x |= x >> 16;
    x |= x >> 32;

    return ++x;
}



function gcd(a, b)
{
    let temp;
    while (1)
    {
        temp = a % b;

        if (temp == 0)
          return b;

        a = b;
        b = temp;
    }
}



function distv(p1, p2)
{
    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;

    return Math.sqrt(dx*dx + dy*dy);
}



function anglev(v)
{
    let angle = Math.atan2(v.y, v.x);
    if (angle < 0) angle += Tau;

    return angle;
}



function anglev2(v1, v2)
{
    return anglev2_(v1.x, v1.y, v2.x, v2.y);
}



function anglev2_(x1, y1, x2, y2)
{
    const dx = x2 - x1;
    const dy = y2 - y1;

    let angle = Math.atan2(dy, dx);
    if (angle < 0) angle += Tau;

    return angle;
}



function lengthv(v)
{
    return Math.sqrt(v.x*v.x + v.y*v.y);
}



function lengthv_(x, y)
{
    return Math.sqrt(x*x + y*y);
}



function unitv(v)
{
    return point(
        v.x == 0 ? 0 : v.x / lengthv(v),
        v.y == 0 ? 0 : v.y / lengthv(v));
}



function dotv(v1, v2)
{
    return v1.x * v2.x + v1.y * v2.y;
}



function angleDiff(a1, a2)
{
    let diff = a2 - a1;

    while (diff <= -Tau/2) diff += Tau;
    while (diff >   Tau/2) diff -= Tau;

    return diff; // |-Tau/2, Tau/2]
}



function mulv2m3(v, m)
{
    let v3 = [v.x, v.y, 1];
    let r  = mulv3m3(v3, m);

    return point(r[0], r[1]);
}



function mulm3m3(...mm)
{
    consoleAssert(mm.length > 0, 'mulm3m3() must take at least one argument');

    let result = clone(mm[0]);

    for (let a = 1; a < mm.length; a++)
    {
        const m1 = result;
        const m2 = mm[a];

        const m = [[0, 0, 0],
                   [0, 0, 0],
                   [0, 0, 0]];

        for (let i = 0; i < 3; i++)
        {
            for (let j = 0; j < 3; j++)
            {
                /*	calculate the dot product of ith row 
                    of this and jth column of m  */
                for (let k = 0; k < 3; k++)
                    m[i][j] += m1[i][k] * m2[k][j];
            }
        }

        result = m;
    }

    return result;
}



function divm3s(m, s)
{
    for (let i = 0; i < 3; i++)
        for (let j = 0; j < 3; j++)
            m[i][j] /= s;

    return m;
}



function adjugate(m)
{
    return cofactor(transpose(m));
}



function transpose(m)
{
    return [[m[0][0], m[1][0], m[2][0]],
            [m[0][1], m[1][1], m[2][1]],
            [m[0][2], m[1][2], m[2][2]]];
}



function cofactor(m)
{
    return [[  m[1][1] * m[2][2] - m[2][1] * m[1][2], -(m[1][0] * m[2][2] - m[2][0] * m[1][2]),  m[1][0] * m[2][1] - m[2][0] * m[1][1] ],
            [-(m[0][1] * m[2][2] - m[2][1] * m[0][2]),  m[0][0] * m[2][2] - m[2][0] * m[0][2], -(m[0][0] * m[2][1] - m[2][0] * m[0][1])],
            [  m[0][1] * m[1][2] - m[1][1] * m[0][2], -(m[0][0] * m[1][2] - m[1][0] * m[0][2]),  m[0][0] * m[1][1] - m[1][0] * m[0][1] ]]; 
}



function determinant(m)
{
    return   m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1])
           - m[0][1] * (m[1][0] * m[2][2] - m[2][0] * m[1][2])
           + m[0][2] * (m[1][0] * m[2][1] - m[2][0] * m[1][1]);
}



function inversem3(m)
{
    return divm3s(adjugate(m), determinant(m));
}



function createRotateTransform(angle)
{
    const cosA = hardZero(Math.cos(angle));
    const sinA = hardZero(Math.sin(angle));

    return [[ cosA, sinA, 0],
            [-sinA, cosA, 0],
            [ 0,    0,    1]];
}



function createTransform(x = 0, y = 0, scaleX = 1, scaleY = 1, angle = 0, skewX = 0, skewY = 0)
{
    const cosA = Math.cos(angle);
    const sinA = Math.sin(angle);

    return [[scaleX*cosA -  skewY*sinA, -skewX*cosA + scaleY*sinA, x],
            [ skewY*cosA + scaleX*sinA, scaleY*cosA +  skewX*sinA, y],
            [0,                         0,                         1]];
}



function crossv2(v1, v2)
{
    // returns the magnitude of v1×v2 = ‖v1‖‖v2‖sinθ "perpendicular dot product",
    // equivalent to dotv(v1, cross(v2)) (same as in 3D with a Z component of 0)
    // also the area of the parallelogram between the two vectors
    // also determinant of 2×2 matrix built from the two vectors
    // positive if turn from v1 to v2 is clockwise

    return v1.x * v2.y - v1.y * v2.x;
}	



function addv(v1, v2)
{
    return point(
        v1.x + v2.x,
        v1.y + v2.y);
}	



function sqrv(v)
{
    return mulv(v, v);
}



function mulv(v1, v2)
{
    return point(
        v1.x * v2.x,
        v1.y * v2.y);
}	



function mulvs(v, s)
{
    return point(
        v.x * s,
        v.y * s);
}	



function divv(v1, v2)
{
    return point(
        v1.x / v2.x,
        v1.y / v2.y);
}	



function divvs(v, s)
{
    return point(
        v.x / s,
        v.y / s);
}	



function subv(v1, v2)
{
    return point(
        v1.x - v2.x,
        v1.y - v2.y);
}	



function toUtf8(str) 
{
    return decodeURI(encodeURIComponent(str));
}



function fromUtf8(str) 
{
    return decodeURIComponent(encodeURI(str));
}



function charCodeArrayToString(bytes) 
{
    let str = '';

    for (let i = 0; i < bytes.length; i++)
        str += String.fromCharCode(bytes[i]);

    return str;
}



function stringToCharCodeArray(str)
{
    return Array.from(fromUtf8(str), c => c.charCodeAt(0));
}



function newSizeArrayFrom(array, size) // resizes an array and returns a new array
{
    const newArray = new Uint8Array(size);
    copyArray(array, newArray);
    return newArray;
}



function copyArray(src, dst)
{
    copyArrayAt(
        src, 0, src.length,
        dst, 0, dst.length);
}



function copyArrayAt(src, srcStart, srcSize, dst, dstStart, dstSize)
{
    const size = Math.min(srcSize, dstSize);

    for (let i = 0; i < size; i++)
        dst[dstStart + i] = src[srcStart + i];
}



function arraysAreEqual(arr1, arr2)
{
    if (arr1.length != arr2.length)
        return false;

    for (let i = 0; i < arr1.length; i++)
    {
        if (arr1[i] != arr2[i])
            return false;
    }

    return true;
}



function arraysIntersect(array1, array2)
{
    return array1.findIndex(i => array2.includes(i)) > -1;
}



function  leftArrowChar(list) { return list ? '<==' : '<--'; }; 
function rightArrowChar(list) { return list ? '==>' : '-->'; }; 

function nodeNameForStorage(nodeId) { return nodeTag + ' ' + nodeId; }
function connNameForStorage(name)   { return connTag + ' ' + name;   }
function pageNameForStorage(name)   { return pageTag + ' ' + name;   }



function parseBool(str) 
{ 
    return str.toLowerCase() == 'true'
        || str == '1';
}



function connToString(_conn, logSpace = false)
{
    return getConnectionString(
        _conn.outputNodeId,
        _conn.outputId,
        _conn.outputOrder,
        _conn.inputNodeId,
        _conn.inputId,
        _conn.list,
        logSpace);
}



function getConnectionKey(outputNodeId, outputId, outputOrder, inputNodeId, inputId)
{
    return connNameForStorage(
          outputNodeId + ' '
        + outputId     + ' '
        + outputOrder  + ' '
        + inputNodeId  + ' '
        + inputId);
}



function getStorageConnKey(conn)
{
    return getConnectionKey(
        conn.outputNodeId,
        conn.outputId,
        conn.outputOrder,
        conn.inputNodeId,
        conn.inputId);
}



function getConnKey(conn)
{
    return getConnectionKey(
        conn.output.node.id,
        conn.output.id,
        conn.outputOrder,
        conn.input.node.id,
        conn.input.id);
}



function getConnString(conn, logSpace = false)
{
    return getConnectionString(
        conn.output.node.id,
        conn.output.id,
        conn.outputOrder,
        conn.input.node.id,
        conn.input.id,
        conn.list,
        logSpace);
}



function getConnectionString(outputNodeId, outputId, outputOrder, inputNodeId, inputId, list, logSpace = false)
{
    const  sp   = logSpace ? ' ' : '  '; 
    const jsp   = logSpace ? ''  : ' '; 

    const arrow = 
          sp 
        + subscriptNumber(typeof outputOrder == 'string' ? parseInt(outputOrder) : outputOrder) 
        + rightArrowChar(typeof list == 'string' ? parseBool(list) : list) 
        + sp;

    const join  = jsp + '.' + jsp;

    return /*'( ' +*/ outputNodeId + join + outputId
         + arrow
         + inputNodeId  + join + inputId;
         //+ ' )';
}



function getPageKey(pageId)
{
    return pageNameForStorage(pageId);
}



function superscriptNumber(num)
{
    const str = num.toString();

    let sup = '';

    for (const c of str)
        sup += superscriptChar(c);

    return sup;
}



function superscriptChar(c)
{
    switch (c)
    {
        case '0': return '⁰';
        case '1': return '¹';
        case '2': return '²';
        case '3': return '³';
        case '4': return '⁴';
        case '5': return '⁵';
        case '6': return '⁶';
        case '7': return '⁷';
        case '8': return '⁸';
        case '9': return '⁹';
        case '.': return '·';
    }
}



function subscriptNumber(num)
{
    const str = num.toString();

    let sup = '';

    for (const c of str)
        sup += subscriptChar(c);

    return sup;
}



function subscriptChar(c)
{
    switch (c)
    {
        case '0': return '₀';
        case '1': return '₁';
        case '2': return '₂';
        case '3': return '₃';
        case '4': return '₄';
        case '5': return '₅';
        case '6': return '₆';
        case '7': return '₇';
        case '8': return '₈';
        case '9': return '₉';
        case '.': return ' ';
    }
}



function boolToString(bool)
{
    return bool ? 'true' : 'false';
}



function isValid(val)
{
    return val != undefined
        && val != null;
}



function isEmpty(array)
{
    return array.length == 0;
}



function removeFrom(array, item)
{
    removeAt(array, array.indexOf(item));
}



function removeAt(array, index)
{
    if (   index > -1 
        && index < array.length)
        array.splice(index, 1);
}



function removeLast(array)
{
    if (isEmpty(array))
        return null;

    let last = array.at(-1);
    array.splice(array.length-1, 1);

    return last;
}



function lastOf(array)
{
    return array[array.length-1];
}



function moveInArray(array, from, to) 
{
    const item = array[from];
    array.splice(from, 1);
    array.splice(to, 0, item);
}



function removeFromArray(array, item)
{
    const index = array.indexOf(item);
    
    if (index > -1)
        array.splice(index, 1);
}



function removeArrayFromArray(fromArray, array)
{
    for (const item of array)
    {
        const index = fromArray.indexOf(item);
        
        if (index > -1)
            fromArray.splice(index, 1);
    }
}



function removeFromArrayWhere(array, where)
{
    const index = array.findIndex(where);
    
    if (index > -1)
        array.splice(index, 1);
}



function cleanStyleId(styleId)
{
    return styleId.split(',')[0] + ',';
}



function getLinearPathData(points)
{
    let pathData = '';


    if (points.length < 2)
        return pathData;


    pathData += 'M';
    pathData += ' ' + hardZero(points[0].x);
    pathData += ' ' + hardZero(points[0].y);

    for (let i = 1; i < points.length; i++)
    {
        pathData += 
              ' L'
            + ' ' + hardZero(points[i].x)
            + ' ' + hardZero(points[i].y);
    }


    return pathData;
}



function point(x, y) { return {x: x, y: y}; }



function mulv3m3(v, m)
{
    let r = [0, 0, 0];

    for (let i = 0; i < 3; i++)
        for (let j = 0; j < 3; j++)
            r[i] += v[j] * m[i][j];

    return r;
}



function clone(val) 
{
    const type = typeof val;
    
    if (val === null) 
      return null;

    else if (type === 'undefined' 
          || type === 'number' 
          || type === 'string' 
          || type === 'boolean') 
        return val;

    else if (type === 'object') 
    {
        if (val instanceof Array) 
            return val.map(x => clone(x));

        else if (val instanceof Uint8Array) 
            return new Uint8Array(val);

        else 
        {
            let obj = {};

            for (const key in val) 
                obj[key] = clone(val[key]);

            return obj;
        }
    }

    throw 'unknown';
}



function pushUnique(array, item, equal = null)
{
    if (equal)
    {
        if (Array.isArray(item))
            item.forEach(i => pushUnique(array, i, equal));
        else if (!array.find(i => equal(i, item)))
            array.push(item);
    }
    else
    {
        if (Array.isArray(item))
            item.forEach(i => pushUnique(array, i));
        else if (!array.includes(item))
            array.push(item);
    }
}



function pushUniqueBy(array, item, equal)
{
    if (Array.isArray(item))
        item.forEach(i => pushUniqueBy(array, i, equal));
    else if (!array.find(equal))
        array.push(item);
}



function pushUniqueExcept(array, item, except)
{
    if (Array.isArray(item))
        item.forEach(i => pushUniqueExcept(array, i, except));
    else if (!array.find(except))
        array.push(item);
}



function consoleAssert(...args)
{
    // if (  !settings 
    //     || settings.enableAsserts)
    if (enableAsserts)
    {
        console.assert(...args);
        //console.trace();
    }
}



function consoleError(...args)
{
    // if (  !settings
    //     || settings.enableAsserts)
    if (enableAsserts)
        console.error(...args);
}



function trimCharFromStart(str, trim) 
{
    while (str.length >= trim.length
        && str.substring(0, trim.length) == trim) 
        str = str.substring(trim.length);

    return str;
}



function trimCharFromEnd(str, trim) 
{
    while (str.length >= trim.length
        && str.substring(str.length - trim.length) == trim) 
        str = str.substring(0, str.length - trim.length);

    return str;
}



function getObjectFills(genObjFills)
{
    const fills = [];


    for (const fill of genObjFills)
    {
        switch (fill[0])
        {
            case 'SOLID':
            {
                const color = {
                    r: Math.min(Math.max(0, fill[1] / 0xff), 1), 
                    g: Math.min(Math.max(0, fill[2] / 0xff), 1), 
                    b: Math.min(Math.max(0, fill[3] / 0xff), 1) };

                const opacity = Math.min(Math.max(0, fill[4] / 100), 1);


                if (   !isNaN(color.r)
                    && !isNaN(color.g)
                    && !isNaN(color.b)
                    && !isNaN(opacity))
                    fills.push(
                    {
                        type:      fill[0], 
                        color:     color,
                        opacity:   opacity,
                        blendMode: fill[5]
                    });


                break;
            }

            case 'GRADIENT_LINEAR':
            case 'GRADIENT_RADIAL':
            case 'GRADIENT_ANGULAR':
            case 'GRADIENT_DIAMOND':
            {
                const [p0, p1, p2] = fill[1];

                const identityHandles = 
                    [[0,   1,   0],
                     [0.5, 0.5, 1],
                     [1,   1,   1]];

                let xform = [
                    [p0.x, p1.x, p2.x],
                    [p0.y, p1.y, p2.y],
                    [1,    1,    1   ]];

                xform = mulm3m3(identityHandles, inversem3(xform));
                xform = [xform[0], xform[1]];


                const stops = [];

                for (const stop of fill[2])
                {
                    stops.push({
                        color: 
                        {
                            r: Math.min(Math.max(0, stop[0]), 1),
                            g: Math.min(Math.max(0, stop[1]), 1),
                            b: Math.min(Math.max(0, stop[2]), 1),
                            a: Math.min(Math.max(0, stop[3]), 1)
                        },
                        position: stop[4]
                    });  
                }


                fills.push(
                {
                    type:              fill[0],
                    gradientTransform: xform,
                    gradientStops:     stops,
                    blendMode:         fill[3]
                });


                break;
            }
        }
    }


    return fills;
}



function isListValueType(type)
{
    return LIST_VALUES.includes(type);
}



function isValueListOfLists(value)
{
    if (!isListValueType(value.type))
        return false;

    for (const item of value.items)
    {
        if (!isListValueType(item.type))
            return false;
    }

    return true;
}



function isValueListOfCondensedLists(value)
{
    if (!isListValueType(value.type))
        return false;
    
    for (const item of value.items)
    {
        if (  !isListValueType(item.type)
            || item.condensed !== true)
            return false;
    }

    return true;
}


function rgbFromType(type, active)
{
    return rgbFromTypeMode(type, active, darkMode);
}



function rgbFromTypeMode(type, active, darkMode)
{
    if (NUMBER_TYPES.includes(type))
        return active 
            ? (darkMode ? rgbActiveNumberDark : rgbActiveNumberLight)
            : (darkMode ? rgbNumberDark       : rgbNumberLight      );

    else if (TEXT_TYPES.includes(type))
        return active 
            ? (darkMode ? rgbActiveTextDark   : rgbActiveTextLight)
            : (darkMode ? rgbTextDark         : rgbTextLight      );

    else if (SHAPE_TYPES.includes(type)
         || EFFECT_TYPES.includes(type))
        return active 
            ? (darkMode ? rgbActiveShapeDark  : rgbActiveShapeLight)
            : (darkMode ? rgbShapeDark        : rgbShapeLight      );

    else if (GROUP_TYPES.includes(type))
        return active 
            ? (darkMode ? rgbActiveGroupDark  : rgbActiveGroupLight)
            : (darkMode ? rgbGroupDark        : rgbGroupLight      );

    else if (FLOW_TYPES.includes(type)
          || type == ANY_VALUE)
        return active 
            ? (darkMode ? rgbActiveFlowDark   : rgbActiveFlowLight)
            : (darkMode ? rgbFlowDark         : rgbFlowLight      );

    else if (type == COLOR_STYLE)
        return active 
            ? (darkMode ? rgbActiveFlowDark   : rgbActiveFlowLight)
            : (darkMode ? rgbFlowDark         : rgbFlowLight      );


    switch (type)
    {
        case COLOR_VALUE:      
        case FILL_VALUE:
        case STROKE_VALUE:
        case COLOR_STOP_VALUE:
        case GRADIENT_VALUE:

        case COLOR:           
        case COLOR_INTERPOLATE:
        case CORRECT_COLOR:
        case COLOR_CONTRAST:
        case COLORBLIND:
        case COLOR_BLEND:

        case COLOR_STOP:
        case GRADIENT:

            return darkMode 
                 ? rgbFlowDark         
                 : rgbFlowLight;

            // return active 
            //     ? (mode ? rgbActiveFlowDark : rgbActiveFlowLight)
            //     : (mode ? rgbFlowDark       : rgbFlowLight      );
    }

    
    // return [0xff, 0, 0xff];
    return darkMode 
         ? rgbFlowDark         
         : rgbFlowLight;
}



function isDataColorNaN(color)
{
    return isNaN(color[1])
        || isNaN(color[2])
        || isNaN(color[3]);
}


function noNaN(x, replace)
{
    return !isNaN(x) ? x : replace;
}



function isSimpleLatinLetter(c)
{
    return c >= 'a' && c <= 'z'
        || c >= 'A' && c <= 'Z';
}


function getDigitCount(i)
{
    if (i == 0) return 1;

    let l = Math.floor(Math.log10(Math.abs(i))); // the minus sign doesn't count as a digit;

    return l + 1;
}



function getDecimalFactor(dec)
{
    return Math.pow(10, -dec);
}



function isDigit(c)
{
    return c >= '0' 
        && c <= '9';
}



function isHexDigit(c)
{
    return c.length == 1
        && (   c >= 'A' && c <= 'F'
            || c >= 'a' && c <= 'f');
}



function decDigits(num) 
{
    if (typeof num !== 'number')
        consoleError('Input must be a number');
    
    const strNum = num.toFixed(10);
    const iDec   = strNum.indexOf('.');
    
    if (iDec === -1)
        return 0;
    
    let count        = strNum.length - iDec - 1;
    let nonZeroFound = false;
    
    for (let i = strNum.length-1; i > iDec; i--)
    {
        if (strNum[i] === '0')
            count--;
        else
            break;
    }
    
    return count;
}



function isArrowKey(code)
{
    return code == 'ArrowLeft'
        || code == 'ArrowRight'
        || code == 'ArrowUp'
        || code == 'ArrowDown';
}



function numToString(num, dec = 0, showHex = false, decSep = '.', thouSep = '')
{
    return showHex
         ? numToStringHex(num, dec, decSep, thouSep)
         : numToStringDec(num, dec, decSep, thouSep);
}



function numToStringDec(num, dec, decSep = '.', thouSep = '')
{
    const _dec = Math.abs(dec);
    let    str = Number(num).toFixed(_dec).toString(10);
    

    // find decimal place
    
    let i = str.length-1;
    
    while (i >= 0
        && str[i] !== '.' 
        && str[i] !== ',')
        i--;

    if (i < 0) // if no decimal place
        return addGroupSeparator(str, thouSep, 3);

    
    let whole = str.slice(0, i);
    let frac  = str.slice(i+1);


    // format fraction

    i = frac.length-1;

    if (dec < 0)
    {
        while (i >= 0 && frac[i] === '0')
            frac = frac.substring(0, i--);
    }    


    return addGroupSeparator(whole, thouSep, 3) + (frac != '' ? decSep : '') + frac;
}



function numToStringHex(num, dec, decSep = '.', thouSep = '')
{
    const _num = Number(num);
    const _dec = Math.abs(dec);

    let   _str = Number(num).toFixed(_dec).toString(10);
    let    str = Math.abs(_num).toString(16);


    // find decimal place
    
    let i = str.length-1;

    while (i >= 0
        && str[i] !== '.' 
        && str[i] !== ',')
        i--;

    if (i < 0) // if no decimal place
        return addGroupSeparator(str, thouSep, 2);

    
    let whole = str.slice(0, i);
    let frac  = _str.slice(i+1);


    // format fraction
    
    i = frac.length-1;

    let _frac = parseFloat(frac);
    frac = '';

    while (_frac != 0)
    {
        _frac *= 16;

        const decFrac = Math.floor(_frac);

        frac += decFrac.toString(16);
        _frac -= decFrac;
    }    


    if (whole.length % 2 > 0) whole = '0' + whole;
    if (frac .length % 2 > 0) frac  = frac + '0';


    const neg = num < 0 ? '-' : '';

    return neg + addGroupSeparator(whole, thouSep, 2) + decSep + addHexFracGroupSeparator(frac, thouSep, 2);
}



function addGroupSeparator(_str, sep, groupSize)
{
    let str = '';

    for (let i = _str.length-1, t = 0; i >= 0; i--, t++)
    {
        if (t == groupSize)
        {
            str = sep + str;
            t = 0;
        }

        str = _str[i] + str;
    }

    return str;
}



function addHexFracGroupSeparator(_str, sep, groupSize)
{
    let str = '';

    for (let i = 0, t = 0; i < _str.length; i++, t++)
    {
        if (t == groupSize)
        {
            str += sep;
            t = 0;
        }

        str += _str[i];
    }

    return str;
}



// function numToString(num, dec)
// {
//     lst str = Number(num).toFixed(dec).toString();

//     let i = 0;

//     // find decimal place

//     while (   i < str.length 
//            && str[i] !== '.' 
//            && str[i] !== ',')
//         i++;

//     if (i >= str.length) // if no decimal place
//         return str;

//     i = str.length-1;

//     while (i >= 0 && str[i] === '0')
//         str = str.substring(0, i--);

//     if (str[i] === '.' || str[i] === ',') // hack because JavaScript has shit support for locales
//         str = str.substring(0, i--);

//     return str;
// }



function capitalize(str)
{
    let cap = "";

    if (str.length > 0)
        cap += str[0].toUpperCase();

    if (str.length > 1)
        cap += str.substring(1).toLowerCase();

    return cap;
}



function getQueryVariable(strVar)
{
    const query = window.location.search.substring(1);
    const vars  = query.split('&');

    for (let i = 0; i < vars.length; i++) 
    {
        let pair = vars[i].split('=');

        if (pair[0] == strVar)
            return pair[1];
    }

    return false;
}


const phi = (Math.sqrt(5) - 1) / 2; // 0.618
const Phi = (Math.sqrt(5) + 1) / 2; // 1.618



function floorTo(x, dec)
{
    const div = Math.round(Math.pow(10, dec));
    return Math.floor((x + Number.EPSILON) * div) / div;    
}



function roundTo(x, dec)
{
    const div = Math.round(Math.pow(10, dec));
    return Math.round((x + Number.EPSILON) * div) / div;    
}



function ceilTo(x, dec)
{
    const div = Math.ceil(Math.pow(10, dec));
    return Math.ceil((x + Number.EPSILON) * div) / div;    
}



function distance_(x1, y1, x2, y2)
{
    const dx = x2 - x1;
    const dy = y2 - y1;

    return Math.sqrt(dx*dx + dy*dy);
}



function vector(angle, dist)
{
    return point( 
        dist * Math.cos(angle), 
        dist * Math.sin(angle));
}



function equalv(v1, v2)
{
    return v1.x == v2.x
        && v1.y == v2.y;
}



function saltv(v, salt = 0.0000000001)
{
    return addv(v, point(
        -salt + Math.random() * salt*2, 
        -salt + Math.random() * salt*2));
}



function negv(v)
{
    return point(-v.x, -v.y);
}



function crossv(v)
{
    // returns a cross product of v and the unit vector pointing up the Z axis

    return point(v.y, -v.x);
}



function trimAngle(angle, min = 0, max = Tau)
{
    while (angle <  min) angle += max - min;
    while (angle >= max) angle -= max - min;

    return angle;
}



function anglev(v)
{
    let angle = Math.atan2(v.y, v.x);
    if (angle < 0) angle += Tau;

    return angle;
}



function anglev_(p0, p1)
{
    const v = subv(p1, p0);
    
    let angle = Math.atan2(v.y, v.x);
    if (angle < 0) angle += Tau;

    return angle;
}



function angle_(x, y)
{
    let angle = Math.atan2(y, x);
    if (angle < 0) angle += Tau;

    return angle;
}



function clipEdge(p, q, t0, t1)
{
    if (p == 0 && q < 0)
    {
        return null;
    }
    else if (p < 0)
    {
        let r = q/p;

             if (r > t1) return null;
        else if (r > t0) t0 = r;
    }
    else if (p > 0)
    {
        let r = q/p;

             if (r < t0) return null;
        else if (r < t1) t1 = r;
    }

    return [t0, t1];
}



function clipLine(x1, y1, x2, y2, left, top, right, bottom)
{
    let t0 = 0;
    let t1 = 1;

    let dx = x2 - x1;
    let dy = y2 - y1;

    let cl = clipEdge(-dx, -(left - x1), t0, t1); if (cl != null) { t0 = cl[0]; t1 = cl[1]; } else return null;
    let cr = clipEdge( dx, right - x1,   t0, t1); if (cr != null) { t0 = cr[0]; t1 = cr[1]; } else return null;
    let ct = clipEdge(-dy, -(top - y1),  t0, t1); if (ct != null) { t0 = ct[0]; t1 = ct[1]; } else return null;
    let cb = clipEdge( dy, bottom - y1,  t0, t1); if (cb != null) { t0 = cb[0]; t1 = cb[1]; } else return null;

    if (t1 < 1)
    {
        x2 = x1 + t1*dx;
        y2 = y1 + t1*dy;
    }

    if (t0 > 0)
    {
        x1 = x1 + t0*dx;
        y1 = y1 + t0*dy;
    }

    return [
        point(x1, y1), 
        point(x2, y2) ];
}



function intersect(p1, p2, q1, q2, segment)
{
    if (   equalv(p1, p2) 
        || equalv(q1, q2)) 
        return point_NaN; // undefined line

    let v1 = subv(p2, p1);
    let v2 = subv(q2, q1);

    if (crossv2(v1, v2) == 0) 
        return point_NaN; // parallel lines

    let t1 = crossv2(subv(q1, p1), v2) / crossv2(v1, v2);
    let t2 = crossv2(subv(q1, p1), v1) / crossv2(v1, v2);

    if ((  0 <= t1 && t1 <= 1
        && 0 <= t2 && t2 <= 1)
        || !segment)
        return addv(p1, mulvs(v1, t1));
        
    return point_NaN;
}



function closestPointOnLine(l0, l1, p, segment)
{
    if (equalv(p, l0))
        return l0;
        
    let d = mulvs(
        unitv(crossv(subv(l1, l0))), // perpendicular unit vector from p towards the line
        distv(p, l0));            // the distance to any of the two points guarantees intersection with the line

    return intersect(l0, l1, p, subv(p, d), segment);
}



function signedPosOnLine(p0, p1, p)
{
    let cp = closestPointOnLine(p0, p1, p, false);

    let xform = mulm3m3(
        xmove(negv(p0)),
        xrotate(-anglev2(p0, p1)));
        
    p0 = transform(p0, xform);
    p1 = transform(p1, xform);
    cp = transform(cp, xform);

    return (cp.x - p0.x) / nozero(p1.x - p0.x);
}



function transform(p, xform)
{
    return mulv2m3(p, xform);
}



function xmove(v)
{
    return [[1, 0, v.x],
            [0, 1, v.y],
            [0, 0, 1  ]];
}



function xrotate(angle)
{
    return [[ Math.cos(angle), Math.sin(angle), 0],
            [-Math.sin(angle), Math.cos(angle), 0],
            [ 0,               0,               1]];
}



// function ipow(n, e)
// {
//     let res = 1;

//     for (;;)
//     {
//         if (e & 1 != 0)
//             res *= n;

//         e >>= 1;

//         if (e == 0)
//             break;

//         n *= n;
//     }

//     return res;
// }



const MaxDigits = 100000;
 
function multRes(x, res, resSize)
{
    let carry = 0n;
    
    // multiply individual digits of res[] by n
    for (let i = 0; i < resSize; i++) 
    {
        const prod = res[i] * x + carry;
    
        res[i] = prod % 10n; // store last digit of prod in res[]
        carry  = prod / 10n; // put rest in carry
    }
    
    // put carry in res and
    // increase result size
    while (carry)
    {
        res[resSize] = carry % 10n;
        carry        = carry / 10n;
        resSize++;
    }

    return resSize;
}



function randomPrime(max = Number.MAX_SAFE_INTEGER/2)
{
    const num = Math.floor(Math.random() * max);
    return nextPrime(num);
}



function nextPrime(x) 
{
    while (!isPrime(++x));
    return x;
}



function isPrime(n, k = millerRabinIterations) // Miller-Rabin
{
    if (n <= 1) return false; 
    if (n <= 3) return true; // prime
    
    if (n % 2 == 0) 
        return false; // composite
    
    
    let d = n - 1;     // find d      
    while (d % 2 == 0) // so that x = 2^d * r + 1 
        d /= 2;        // for r >= 1
    
    
    for (let i = 0; i < k; i++)    
        if (!millerTest(d, n))
            return false; // composite
    
    
    return true; // maybe prime        
}    



function millerTest(d, n)
{
    return bigMillerTest(
        BigInt(d),
        BigInt(n));
}        



function uintFromBuffer(buffer, size)
{
    return uintFromBufferAt(buffer, 0, size);
}



function uintFromBufferAt(buffer, start, size)
{
    let val = 0;
    let mul = 1;

    for (let i = start+size-1; i >= start; i--) // little-endian
    {
        val += mul * buffer[i];
        mul <<= 8;
    }

    return val;
}



function uintToBuffer(val, buffer, bufferSize)
{
    uintToBufferAt(val, buffer, 0, bufferSize);
}



function uintToBufferAt(val, buffer, start, bufferSize)
{
    let size = Math.ceil(bigBitCount(val) / 8);
    
    size = Math.min(size, buffer.length - start);

    start += bufferSize - size;

    for (let i = start+size-1; i >= start; i--) // little-endian
    {
        buffer[i] = val & 0xFF; 
        val >>= 8;
    }
}



function lerpCos(a, b, t)
{
    return a < b
         ? a + (b - a) * (-Math.cos(t*Tau/2)+1)/2
         : a + (b - a) * (-Math.cos(t*Tau/2)+1)/2;
}



function lerp(a, b, t)
{
    return a + (b - a) * t;
}



function lerp2(p0, p1, p2, t)
{
    const c0 = lerp(p0, p1, t);
    const c1 = lerp(p1, p2, t);

    return lerp(c0, c1, t);
}



function tangent2(p0, p1, p2, t)
{
    return addv(mulvs(p0, -2*(1-t)), addv(mulvs(p1, 2*(1-2*t)), mulvs(p2, 2*t)));
}



function tangent3(p0, p1, p2, p3, t)
{
    return addv(
        mulvs(subv(p1, p0), 3 * Math.pow(1-t, 2)),
        addv(
           mulvs(subv(p2, p1), 6 * (1-t) * t),
           mulvs(subv(p3, p2), 3 * Math.pow(t, 2))));
}



function lerp3(p0, p1, p2, p3, t)
{
    const c0  = lerp(p0, p1, t);
    const c1  = lerp(p1, p2, t);
    const c2  = lerp(p2, p3, t);

    const c01 = lerp(c0, c1, t);
    const c12 = lerp(c1, c2, t);

    return lerp(c01, c12, t);
}



function normalAngle(angle)
{
    while (angle <  0  ) angle += Tau;
    while (angle >= Tau) angle -= Tau;

    return angle; // [0, Tau|
}



function dot3(m, v) 
{
    const result = [];

    for (let i = 0; i < m.length; i++) 
    {
        let sum = 0;

        for (let j = 0; j < v.length; j++) 
            sum += m[i][j] * v[j];

        result.push(sum);
    }
   
    return result;
}



function smoothstep(x)
{
    if (   x < 0 
        || x > 1) 
        return x;

    return 3*x*x - 2*x*x*x;
}



function getMean(values)
{
    return values.length > 0
         ? values.reduce((acc, cur) => acc + cur, 0) / values.length
         : Number.NaN;
}



function getTrimmedMean(values, trimStart, trimEnd = trimStart)
{
    if (   trimStart <  0
        || trimStart >= 0.5
        || trimEnd   <  0
        || trimEnd   >= 0.5)
        throw new Error('trimStart = ' + trimStart + ', trimEnd = ' + trimEnd + ', trim must be between 0 and 0.5');

    
    const sorted         = values.slice().sort((a, b) => a - b);

    const trimCountStart = Math.floor(sorted.length * trimStart);
    const trimCountEnd   = Math.floor(sorted.length * trimEnd  );

    const trimmed   = sorted.slice(trimCountStart, sorted.length - trimCountEnd);
    const sum       = trimmed.reduce((acc, val) => acc + val, 0);

    return trimmed.length > 0
         ? sum / values.length
         : Number.NaN;
}



function getMedian(values)
{
    const sorted = [...values].sort((a, b) => a - b);
    const middle = Math.floor(sorted.length / 2);

    return sorted.length % 2 == 0
         ? (sorted[middle-1] + sorted[middle]) / 2
         : sorted[middle];
}


const point_NaN = point(Number.NaN, Number.NaN);



function pointIsNaN(p) { return isNaN(p.x) || isNaN(p.y); }



function unit(v)
{
    return v.X != 0 
        || v.Y != 0
        ? mulvs(v, 1 / lengthv(v))
        : point(0, 0);
}



function lerpv(p0, p1, t)
{
    return point(
        lerp(p0.x, p1.x, t),
        lerp(p0.y, p1.y, t));
}



function lerpv2(p0, p1, p2, t)
{
    return point(
        lerp2(p0.x, p1.x, p2.x, t),
        lerp2(p0.y, p1.y, p2.y, t));
}



function lerpv3(p0, p1, p2, p3, t)
{
    return point(
        lerp3(p0.x, p1.x, p2.x, p3.x, t),
        lerp3(p0.y, p1.y, p2.y, p3.y, t));
}



function clipEdge(p, q, t0, t1)
{
    if (p == 0 && q < 0)
    {
        return null;
    }
    else if (p < 0)
    {
        const r = q/p;

             if (r > t1) return null;
        else if (r > t0) t0 = r;
    }
    else if (p > 0)
    {
        const r = q/p;

             if (r < t0) return null;
        else if (r < t1) t1 = r;
    }

    return [t0, t1];
}



function clipLine(x1, y1, x2, y2, left, top, right, bottom)
{
    let   t0 = 0;
    let   t1 = 1;

    const dx = x2 - x1;
    const dy = y2 - y1;

    const cl = clipEdge(-dx, -(left - x1), t0, t1); if (cl != null) { t0 = cl[0]; t1 = cl[1]; } else return null;
    const cr = clipEdge( dx,  right - x1,  t0, t1); if (cr != null) { t0 = cr[0]; t1 = cr[1]; } else return null;
    const ct = clipEdge(-dy,  -(top - y1), t0, t1); if (ct != null) { t0 = ct[0]; t1 = ct[1]; } else return null;
    const cb = clipEdge( dy,  bottom - y1, t0, t1); if (cb != null) { t0 = cb[0]; t1 = cb[1]; } else return null;

    if (t1 < 1)
    {
        x2 = x1 + t1*dx;
        y2 = y1 + t1*dy;
    }

    if (t0 > 0)
    {
        x1 = x1 + t0*dx;
        y1 = y1 + t0*dy;
    }

    return [
        point(x1, y1), 
        point(x2, y2) ];
}



function intersectLines(p1, p2, q1, q2, segment)
{
    if (   equalv(p1, p2) 
        || equalv(q1, q2)) 
        return point_NaN; // undefined line

    const v1 = subv(p2, p1);
    const v2 = subv(q2, q1);

    if (crossv2(v1, v2) == 0) 
        return point_NaN; // parallel lines

    const t1 = crossv2(subv(q1, p1), v2) / crossv2(v1, v2);
    const t2 = crossv2(subv(q1, p1), v1) / crossv2(v1, v2);

    if (   (   0 <= t1 && t1 <= 1
            && 0 <= t2 && t2 <= 1)
        || !segment)
        return addv(p1, mulvs(v1, t1));
        
    return point_NaN;
}



function closestPointOnLine(l0, l1, p, segment, constrain = 0)
{
    if (equalv(p, l0))
        return l0;

    const v    = unitv(crossv(subv(l1, l0)));      // perpendicular unit vector from p towards the line
    const dist = distv(p, lerpv(l0, l1, 1/2)) * 2; // the distance to any of the two points guarantees intersection with the line

    const c    = lerpv(l0, l1, 1/2);
    const dir  = distv(addv(p, v), c) < distv(p, c);


    let d;
    
         if (constrain == 2) d = point(dir ? -dist : dist, 0);
    else if (constrain == 1) d = point(0, dir ? -dist : dist);
    else                     d = mulvs(v, dir ? -dist : dist); 

    return intersectLines(l0, l1, p, subv(p, d), segment);
}



function signedPosOnLine(p0, p1, p)
{
    let cp = closestPointOnLine(p0, p1, p, false);

    const xform = mulm3m3(
        xmove(-p0),
        xrotate(-anglev2(p0, p1)));

    p0 = transform(p0, xform);
    p1 = transform(p1, xform);
    cp = transform(cp, xform);

    return (cp.X - p0.X) / nozero(p1.X - p0.X);
}



function rectInside(rect1, rect2)
{
    return rect1.l >= rect2.l
        && rect1.r <= rect2.r
        && rect1.t >= rect2.t
        && rect1.b <= rect2.b; 
}



function rectsIntersect(rect1, rect2)
{
    return !(
           rect1.l >= rect2.r
        || rect1.r <= rect2.l
        || rect1.t >= rect2.b
        || rect1.b <= rect2.t); 
}



function clipRect(rect, clip)
{
    if (!rectsIntersect(rect, clip))
        return Rect.NaN;

    return new AbsRect(
        Math.max(rect.l, clip.l),
        Math.max(rect.t, clip.t),
        Math.min(rect.r, clip.r),
        Math.min(rect.b, clip.b));
}



function validateRect(rect)
{
    return new Rect(
        rect.x + Math.min(rect.w, 0),
        rect.y + Math.min(rect.h, 0),
        Math.abs(rect.w),
        Math.abs(rect.h));
}



function validateRect_(x, y, w, h)
{
    return [
        x + Math.min(w, 0),
        y + Math.min(h, 0),
        Math.abs(w),
        Math.abs(h) ];
}



function transform(p, xform)
{
    return mulv2m3(p, xform);
}



function xmove(v)
{
    return [[1, 0, v.x],
            [0, 1, v.y],
            [0, 0, 1  ]];
}



function xrotate(angle)
{
    return [[ Math.cos(angle), Math.sin(angle), 0],
            [-Math.sin(angle), Math.cos(angle), 0],
            [ 0,               0,               1]];
}



function offsetRect(elem)
{
    return new Rect(
        elem.offsetLeft,
        elem.offsetTop,
        elem.offsetWidth,
        elem.offsetHeight);
}



function boundingRect(elem)
{
    const bounds = elem.getBoundingClientRect();

    return new Rect(
        bounds.x,
        bounds.y,
        bounds.width,
        bounds.height);
}



function circleCenter(p0, p1, p2)
{
    const v0  = subv(p1, p0);
    const v1  = subv(p2, p1);
    
    const pm0 = divvs(addv(p0, p1), 2);
    const pm1 = divvs(addv(p1, p2), 2);
    
    return intersectLines(
        pm0, addv(pm0, crossv(v0)), 
        pm1, subv(pm1, crossv(v1)), 
        false);
}



function halfArcAngle(p1, p2, p3)
{
    // returns the angle of the first half of the arc p1-p2

    const pc = circleCenter(p1, p2, p3);

    let a = angleDiff(
        anglev(subv(p1, pc)),
        anglev(subv(p2, pc)));

    // console.log('anglev(subv(p1, pc) =', anglev(subv(p1, pc)));    
    // console.log('anglev(subv(p2, pc) =', anglev(subv(p2, pc)));        
    // while (a < 0)
    //     a += Tau;

    return a;
}



function makeWave(shape, x, y, width, amplitude, frequency, offset, alignX, alignY)
{
    const startX = x;
    const w      = width / frequency;
    

    x += offset;
    
    
    while (x >  -w) x -= w;
    while (x <= -w) x += w;


    if (alignY == 1)
        amplitude *= 2;

        
    let height = amplitude;


    const points = [];


    if (Math.abs(w) > 0.0000001)
    {
        switch (shape)
        {
            case 0: makeSquareWave  (x, y, width, height, startX, w, points); break;
            case 1: makeSawWave     (x, y, width, height, startX, w, points); break;
            case 2: makeBackSawWave (x, y, width, height, startX, w, points); break;
            case 3: makeTriangleWave(x, y, width, height, startX, w, points); break;
            case 4: makeSineWave    (x, y, width, height, startX, w, points); break;
        }

        
        points.forEach(p =>
        {
                 if (alignX == 1) p.x -= width/2;
            else if (alignX == 2) p.x -= width;
        });

        points.forEach(p =>
        {
                 if (alignY == 1) p.y -= height/2;
            else if (alignY == 2) p.y -= height;
        });
    }


    return points;
}



function makeSquareWave(x, y, width, height, startX, w, points)
{
    let p0, p1;

    
    while (x < startX + width)
    {
        if (x + w/2 > startX)
        {
            p0 = point(x,     y);
            p1 = point(x+w/2, y);

            clipLineSegment(p0, p1, startX, width);

            points.push(p0, p1);
        }

        x += w/2;


        if (x < startX + width)
        {
            p0 = point(x,     y+height);
            p1 = point(x+w/2, y+height);
            
            clipLineSegment(p0, p1, startX, width);
            
            points.push(p0, p1);
        }

        x += w/2;
    }
}



function makeSawWave(x, y, width, height, startX, w, points)
{
    let p0, p1;

    
    while (x < startX + width)
    {
        if (x + w > startX)
        {
            p0 = point(x,   y       );
            p1 = point(x+w, y+height);

            clipLineSegment(p0, p1, startX, width);

            points.push(p0, p1);
        }

        x += w;
    }
}



function makeBackSawWave(x, y, width, height, startX, w, points)
{
    let p0, p1;

    
    while (x < startX + width)
    {
        if (x + w > startX)
        {
            p0 = point(x,   y+height);
            p1 = point(x+w, y       );

            clipLineSegment(p0, p1, startX, width);

            points.push(p0, p1);
        }

        x += w;
    }
}



function makeTriangleWave(x, y, width, height, startX, w, points)
{
    let p0, p1;

    let i = 0;
    while (x < startX + width)
    {
        if (x + w/2 > startX)
        {
            p0 = point(x,     y+height);
            p1 = point(x+w/2, y       );

            clipLineSegment(p0, p1, startX, width);

            if (i++ == 0) points.push(p0);
            points.push(p1);
        }

        x += w/2;


        if (x < startX + width)
        {
            p0 = point(x,     y       );
            p1 = point(x+w/2, y+height);

            clipLineSegment(p0, p1, startX, width);

            if (i++ == 0) points.push(p0);
            points.push(p1);
        }

        x += w/2;
    }
}



function makeSineWave(x, y, width, height, startX, w, points)
{
    let p0, p1, p2, p3;

    let i = 0;
    while (x < startX + width)
    {
        if (x + w/2 > startX)
        {
            p0 = point(x,                              y+height);
            p1 = point(x     + (x+w/2 - x)   * 0.3615, y+height);
            p2 = point(x+w/2 + (x - (x+w/2)) * 0.3615, y       );
            p3 = point(x+w/2,                          y       );

            clipSinSegment(p0, p1, p2, p3, startX, width);

            if (i++ == 0) points.push(p0);
            points.push(p1, p2, p3);
        }

        x += w/2;


        if (x < startX + width)
        {
            p0 = point(x,                              y       );
            p1 = point(x     + (x+w/2 - x)   * 0.3615, y       );
            p2 = point(x+w/2 + (x - (x+w/2)) * 0.3615, y+height);
            p3 = point(x+w/2,                          y+height);
            
            clipSinSegment(p0, p1, p2, p3, startX, width);
            
            if (i++ == 0) points.push(p0);
            points.push(p1, p2, p3);
        }

        x += w/2;
    }
}



function clipLineSegment(p0, p1, startX, width)
{
    if (   p0.x <  startX
        && p1.x >= startX)
    {
        const t        = (startX - p0.x) / nozero(p1.x - p0.x);
        const segments = splitLineSeg(p0, p1, t);
        const seg      = segments[1];

        p0.x = seg[0].x;  p0.y = seg[0].y;
        p1.x = seg[1].x;  p1.y = seg[1].y;
    }
    
    if (   p0.x <  startX + width
        && p1.x >= startX + width)
    {
        const t        = (startX + width - p0.x) / nozero(p1.x - p0.x);
        const segments = splitLineSeg(p0, p1, t);
        const seg      = segments[0];

        p0.x = seg[0].x;  p0.y = seg[0].y;
        p1.x = seg[1].x;  p1.y = seg[1].y;
    }
}



function clipSinSegment(p0, p1, p2, p3, startX, width)
{
    if (   p0.x <  startX
        && p3.x >= startX)
    {
        const t        = findTforX3(p0, p1, p2, p3, startX);
        const segments = splitSeg3(p0, p1, p2, p3, t);
        const seg      = segments[1];

        p0.x = seg[0].x;  p0.y = seg[0].y;
        p1.x = seg[1].x;  p1.y = seg[1].y;
        p2.x = seg[2].x;  p2.y = seg[2].y;
        p3.x = seg[3].x;  p3.y = seg[3].y;
    }
    
    if (   p0.x <  startX + width
        && p3.x >= startX + width)
    {
        const t        = findTforX3(p0, p1, p2, p3, startX + width);
        const segments = splitSeg3(p0, p1, p2, p3, t);
        const seg      = segments[0];

        p0.x = seg[0].x;  p0.y = seg[0].y;
        p1.x = seg[1].x;  p1.y = seg[1].y;
        p2.x = seg[2].x;  p2.y = seg[2].y;
        p3.x = seg[3].x;  p3.y = seg[3].y;
    }
}


const quadrantKappa   = 4 * (Math.sqrt(2) - 1) / 3;        // or use the value 0.55191502449 from http://spencermortensen.com/articles/bezier-circle/
const kappaCorrection = 0.9993391093366649465402826439248; // slight improvement (see Bézier Curves p. 13, Gernot Hoffmann);



function bezierTangent(x0, y0, x1, y1, x2, y2, x3, y3, t)
{
    const p0 = point(x0, y0);
    const p1 = point(x1, y1);
    const p2 = point(x2, y2);
    const p3 = point(x3, y3);

    return unit(addv(addv(
        mulvs(subv(p1, p0), 3*sqr(1-t)),
        mulvs(subv(p2, p1), 6*(1-t)*t)),
        mulvs(subv(p3, p2), 3*sqr(t))));
}



function pointAlongLine(p0, p1, dist)
{
    return addv(p0, mulvs(unitv(subv(p1, p0)), dist));
}



function pointAlongSegment2(p0, p1, p2, dist, error = 0.001)
{
    const hullLength = 
          distv(p0, p1) 
        + distv(p1, p2);

    if (hullLength == 0)
        return Number.NAN;


    let t = dist / hullLength;

    if (t < 0 || t > 1)
        return Number.NAN;

        
    let halves = splitSeg2(p0, p1, p2, t);
    let l      = halves[0];

    let length = arcLength2(l[0], l[1], l[2], error);


    let loopProtect = 1000;

    while (Math.abs(dist - length) > error
        && loopProtect-- > 0)
    {
        t += (dist - length) / hullLength;

        halves = splitSeg2(p0, p1, p2, t);
        l      = halves[0];

        length = arcLength2(l[0], l[1], l[2], error);
    }

    if (loopProtect == 0)
        consoleError('endless loop in pointAlongSegment2()');


    return t;
}



function pointAlongSegment3(p0, p1, p2, p3, dist, error = 0.001)
{
    const hullLength = 
          distv(p0, p1) 
        + distv(p1, p2)
        + distv(p2, p3);

    if (hullLength == 0)
        return Number.NAN;


    let t = dist / hullLength;

    if (t < 0 || t > 1)
        return Number.NAN;

        
    let halves = splitSeg3(p0, p1, p2, p3, t);
    let l      = halves[0];

    let length = arcLength3(l[0], l[1], l[2], l[3], error);


    let loopProtect = 1000;

    while (Math.abs(dist - length) > error
        && loopProtect-- > 0)
    {
        t += (dist - length) / hullLength;

        halves = splitSeg3(p0, p1, p2, p3, t);
        l      = halves[0];

        length = arcLength3(l[0], l[1], l[2], l[3], error);
    }

    if (loopProtect == 0)
        consoleError('endless loop in pointAlongSegment3()');


    return t;
}



function tangentAlongSegment2(p0, p1, p2, dist, error = 0.001)
{
    const hullLength = 
          distv(p0, p1) 
        + distv(p1, p2);

    if (hullLength == 0)
        return Number.NAN;


    let t = dist / hullLength;

    if (t < 0 || t > 1)
        return Number.NAN;

        
    let halves = splitSeg2(p0, p1, p2, t);
    let l      = halves[0];

    let length = arcLength2(l[0], l[1], l[2], error);


    let loopProtect = 1000;

    while (Math.abs(dist - length) > error
        && loopProtect-- > 0)
    {
        t += (dist - length) / hullLength;

        halves = splitSeg2(p0, p1, p2, t);
        l      = halves[0];

        length = arcLength2(l[0], l[1], l[2], error);
    }

    if (loopProtect == 0)
        consoleError('endless loop in pointAlongSegment2()');


    return t;
}



function tangentAlongSegment3(p0, p1, p2, p3, dist, error = 0.001)
{
    const hullLength = 
          distv(p0, p1) 
        + distv(p1, p2)
        + distv(p2, p3);

    if (hullLength == 0)
        return Number.NAN;


    let t = dist / hullLength;

    if (t < 0 || t > 1)
        return Number.NAN;

        
    let halves = splitSeg3(p0, p1, p2, p3, t);
    let l      = halves[0];

    let length = arcLength3(l[0], l[1], l[2], l[3], error);


    let loopProtect = 1000;

    while (Math.abs(dist - length) > error
        && loopProtect-- > 0)
    {
        t += (dist - length) / hullLength;

        halves = splitSeg3(p0, p1, p2, p3, t);
        l      = halves[0];

        length = arcLength3(l[0], l[1], l[2], l[3], error);
    }

    if (loopProtect == 0)
        consoleError('endless loop in pointAlongSegment3()');


    return t;
}



function splitLineSeg(p0, p1, t)
{
    const c = lerpv(p0, p1, t);

    return [ [p0, c],
             [c, p1] ];
}



function splitSeg2(p0, p1, p2, t)
{
    const c0  = lerpv(p0, p1, t);
    const c1  = lerpv(p1, p2, t);

    const c01 = lerpv(c0, c1, t);

    return [ [p0, c0, c01],
             [c01, c1, p2] ];
}



function splitSeg3(p0, p1, p2, p3, t)
{
    const c0   = lerpv(p0, p1, t);
    const c1   = lerpv(p1, p2, t);
    const c2   = lerpv(p2, p3, t);
                
    const c01  = lerpv(c0, c1, t);
    const c12  = lerpv(c1, c2, t);

    const c012 = lerpv(c01, c12, t);

    return [ [p0, c0, c01, c012],
             [c012, c12, c2, p3] ];
}



function arcLength2(p0, p1, p2, error = 0.0000001)
{
    const arcLen =
          distv(p0, p1)
        + distv(p1, p2);

    const chord = distv(p0, p2);
    // console.log('arcLen =', arcLen);
    // console.log('chord =', chord);

    if (arcLen - chord > error)
    {
        const halves = splitSeg2(p0, p1, p2, 0.5);
        const l      = halves[0];
        const r      = halves[1];
            
        return arcLength2(l[0], l[1], l[2], error)
             + arcLength2(r[0], r[1], r[2], error);
    }

    return arcLen;
}



function arcLength3(p0, p1, p2, p3, error = 0.0000001)
{
    const arcLen = 
          distv(p0, p1)
        + distv(p1, p2)
        + distv(p2, p3);

    const chord = distv(p0, p3);

    if ((arcLen - chord) > error)
    {
        const halves = splitSeg3(p0, p1, p2, p3, 0.5);
        const l      = halves[0];
        const r      = halves[1];
            
        return arcLength3(l[0], l[1], l[2], l[3], error)
             + arcLength3(r[0], r[1], r[2], r[3], error);
    }

    return arcLen;
}



function bounds2(p0, p1, p2)
{
    let rect = Rect.NaN;


    rect = expandRect_(rect, p0);
    rect = expandRect_(rect, p2);

    /*	if p1 is between p0 and p2 then 
        p0 and p2 are opposite corners of the bounds  */

    if (   (   p0.x <= p1.x && p1.x <= p2.x
            || p2.x <= p1.x && p1.x <= p0.x)
        && (   p0.y <= p1.y && p1.y <= p2.y
            || p2.y <= p1.y && p1.y <= p0.y))
        return rect;


    const ax = p0.x - 2*p1.x + p2.x;
    const bx = 2 * (p1.x - p0.x);
    
    const ay = p0.y - 2*p1.y + p2.y;
    const by = 2 * (p1.y - p0.y);


    const tx = -bx / nozero(2*ax);
    const ty = -by / nozero(2*ay);


    if (tx >= 0 && tx <= 1) rect = expandRect_(rect, lerpv2(p0, p1, p2, tx));
    if (ty >= 0 && ty <= 1) rect = expandRect_(rect, lerpv2(p0, p1, p2, ty));
    

    return rect;
}



function bounds3(p0, p1, p2, p3)
{
    let rect = Rect.NaN;

    rect = expandRect_(rect, p0);
    rect = expandRect_(rect, p3);


    const ax =   -p0.x + 3*p1.x - 3*p2.x + p3.x;
    const bx =  3*p0.x - 6*p1.x + 3*p2.x;
    const cx = -3*p0.x + 3*p1.x;

    const ay =   -p0.y + 3*p1.y - 3*p2.y + p3.y;
    const by =  3*p0.y - 6*p1.y + 3*p2.y;
    const cy = -3*p0.y + 3*p1.y;


    const roots = []; // there will be ≤4 solutions

    bounds3t(ax, bx, cx, roots);
    bounds3t(ay, by, cy, roots);


    for (const root of roots)
    {
        const v = lerpv3(p0, p1, p2, p3, root);

        // console.log('p0 =', p0);
        // console.log('p1 =', p1);
        // console.log('p2 =', p2);
        // console.log('p3 =', p3);
        // console.log('v  =', v );

        rect = expandRect_(
            rect, 
            v);
    }


    // console.log('bounds rect =', clone(rect));
    return rect;
}



function bounds3t(a, b, c, roots)
{
    a *= 3;
    b *= 2;


    let D = b*b - 4*a*c;
    let r;

    if (   Math.abs(a) < 1e-6
        && Math.abs(b) > 1e-6) // avoid division by 0
    {
        r = -c/b;  if (r >= 0 && r <= 1) roots.push(r);
        return;
    }


    if (D >= 0) // real roots exist
    {
        const sqrtD = Math.sqrt(D);

        r = (-b + sqrtD) / (2*a);  if (r >= 0 && r <= 1) roots.push(r);
        r = (-b - sqrtD) / (2*a);  if (r >= 0 && r <= 1) roots.push(r);
    }
}



function pointAlongCurve(degree, points, distance, error = 0.000001)
{
    let length    = 0;
    let segLength = 0;


    let i;
    for (i = 0; i < points.length - degree - 1; i += degree)
    {
        switch (degree)
        {
        case 1:  segLength = distv     (points[i], points[i+1]);                                  break;
        case 2:  segLength = arcLength2(points[i], points[i+1], points[i+2],              error); break;
        case 3:  segLength = arcLength3(points[i], points[i+1], points[i+2], points[i+3], error); break;
        default: consoleAssert(false);
        }

        if (length + segLength >= distance)
            break;

        length += segLength;
    }


    switch (degree)
    {
    case 1:  return pointAlongLine(points[i], points[i+1], distance - length);
    case 2:  return lerpv2        (points[i], points[i+1], points[i+2],              pointAlongSegment2(points[i], points[i+1], points[i+2],              distance - length));
    case 3:  return lerpv3        (points[i], points[i+1], points[i+2], points[i+3], pointAlongSegment3(points[i], points[i+1], points[i+2], points[i+3], distance - length));
    default: consoleAssert(false); 
    }

    
    return point_NaN;
}



function tangentAlongCurve(degree, points, distance, error = 0.000001)
{
    let length    = 0;
    let segLength = 0;


    let i;
    for (i = 0; i < points.length - degree - 1; i += degree)
    {
        switch (degree)
        {
        case 1:  segLength = distv     (points[i], points[i+1]);                                  break;
        case 2:  segLength = arcLength2(points[i], points[i+1], points[i+2],              error); break;
        case 3:  segLength = arcLength3(points[i], points[i+1], points[i+2], points[i+3], error); break;
        default: consoleAssert(false);
        }

        if (length + segLength >= distance)
            break;

        length += segLength;
    }


    switch (degree)
    {
    case 1:  return subv    (points[i+1], points[i]);
    case 2:  return tangent2(points[i], points[i+1], points[i+2],              pointAlongSegment2(points[i], points[i+1], points[i+2],              distance - length));
    case 3:  return tangent3(points[i], points[i+1], points[i+2], points[i+3], pointAlongSegment3(points[i], points[i+1], points[i+2], points[i+3], distance - length));
    default: consoleAssert(false); 
    }

    
    return point_NaN;
}



function curveLength(degree, points)
{
    let length = 0;

    for (let i = 0; i < points.length - degree; i += degree)
    {
        switch (degree)
        {
            case 1:
                length += distv(
                    points[i  ], 
                    points[i+1]);
                break;

            case 2:
                length += arcLength2(
                    points[i  ], 
                    points[i+1],
                    points[i+2]);
                break;

            case 3:
                length += arcLength3(
                    points[i  ], 
                    points[i+1],
                    points[i+2],
                    points[i+3]);
                break;
        }
    }

    return length;
}



function linear2cubic(linear)
{
    if (linear.length == 0)
        return [];


    const cubic = [linear[0]];
    
    for (let i = 0; i < linear.length-1; i++)
    {
        const p0 = linear[i  ];
        const p1 = linear[i+1];

        cubic.push(
            lerpv(p0, p1, 1/3),
            lerpv(p0, p1, 2/3),
            p1);
    }

    return cubic;
}



function quad2cubic(quad)
{
    if (quad.length == 0)
        return [];


    const cubic = [quad[0]];
    
    for (let i = 0; i < quad.length-2; i += 2)
    {
        const p0 = quad[i  ];
        const p1 = quad[i+1];
        const p2 = quad[i+2];

        cubic.push(
            lerpv(p0, p1, 2/3),
            lerpv(p2, p1, 2/3),
            p2);
    }

    return cubic;
}



function makeArc(p1, p2, p3)
{
    if (areClockwise(p1, p2, p3))
    {
        const pt = p1;
        p1 = p3;
        p3 = pt;
    }

    const pc = circleCenter(p1, p2, p3);

    const sa = anglev(subv(p1, pc));
    let   ea = anglev(subv(p3, pc));

    while (ea > sa) ea -= Tau; // construction is CCW

    return makeArc_(
        pc,
        lengthv(subv(p1, pc)),
        sa,
        ea);
}



function makeArc_(center, radius, startAngle, endAngle)
{
    let diff  = endAngle - startAngle;
    let angle = startAngle;


    const points = [];


    while (Math.abs(diff) > 0)
    {
        const da = 
            diff >= 0 
            ? Math.min(diff,  Tau/4) 
            : Math.max(diff, -Tau/4);

        const handle = radius * arcKappa(da) * kappaCorrection;

        const p1 = addv(center, vector(angle,      radius));
        const p2 = addv(center, vector(angle + da, radius));
    
        const v1 = subv(p1, center);
        const v2 = subv(p2, center);


        points.push(
            p1,
            subv(p1, mulvs(crossv(unitv(v1)), handle)),
            addv(p2, mulvs(crossv(unitv(v2)), handle)));

        angle += da;
        diff  -= da;
    }

    
    points.push(addv(center, vector(endAngle, radius)));


    return points;
}



function arcKappa(angle) 
{
    return 4 * Math.tan(angle/4) / 3; 
}




function areClockwise(p0, p1, p2)
{
    return crossv2(subv(p1, p0), subv(p2, p1)) >= 0;
}



function createCompleteCurve(degree, pathPoints, closed)
{
    const segPoints = pathPoints.slice(0, Math.floor((pathPoints.length-1) / degree) * degree + 1);
    let   points;
    
    
    if (closed)
    {
        if (   pathPoints.length == segPoints.length
            && equalv(pathPoints[0], pathPoints.at(-1)))
            points = pathPoints;
        else if (pathPoints.length - segPoints.length == degree-1)
            points = [...pathPoints, pathPoints[0]];
        else
        {
            switch (degree)
            {
            case 1: points = [...segPoints,                                                                                         segPoints[0]]; break;
            case 2: points = [...segPoints, lerpv(segPoints.at(-1), segPoints[0], 1/2),                                             segPoints[0]]; break;
            case 3: points = [...segPoints, lerpv(segPoints.at(-1), segPoints[0], 1/3), lerpv(segPoints.at(-1), segPoints[0], 2/3), segPoints[0]]; break;
            }
        }
    }
    else
        points = segPoints;


    return points;
}



function findTforX3(p0, p1, p2, p3, x) 
{
    // Newton-Raphson method: t1 = t0 - f(t0) / f'(t0)


    let precision     = 0.00001;
    let t             = 0.5; // initial guess
    let maxIterations = 20;
    let i             = 0;
  
    while (i < maxIterations) 
    {
        let xAtT =     (1 - t)**3        * p0.x
                 + 3 * (1 - t)**2 * t    * p1.x
                 + 3 * (1 - t)    * t**2 * p2.x
                 +                  t**3 * p3.x;
    
        let dAtT = -3 * (1 - t)**2 * p0.x 
                  + 3 * (1 - t)**2 * p1.x - 6 * t * (1 - t) * p1.x 
                  - 3 *      t **2 * p2.x + 6 * t * (1 - t) * p2.x 
                  + 3 *      t **2 * p3.x;
    
        let tNext = t - (xAtT - x) / dAtT;
    

        if (Math.abs(tNext - t) < precision) 
          return tNext;

          
        t = tNext;
        i++;
    }
  

    return t;
}
  
  
  
  function closestPointOnCurve(degree, points, p)
{
    const closestPoints = [];

    let i;
    for (i = 0; i < points.length - degree; i += degree)
    {
        switch (degree)
        {
        case 1:  closestPoints.push(closestPointOnLine(points[i], points[i+1], p, true));
        case 2:  closestPoints.push(lerpv2(points[i], points[i+1], points[i+2],              closestPointOnSegment2(points[i], points[i+1], points[i+2],              p, 0, 1)));
        case 3:  closestPoints.push(lerpv3(points[i], points[i+1], points[i+2], points[i+3], closestPointOnSegment3(points[i], points[i+1], points[i+2], points[i+3], p, 0, 1)));
        default: consoleAssert(false);
        }
    }


    let closest = point_NaN;

    for (const cp of closestPoints)
    {
        if (   pointIsNaN(closest)
            || distv(cp, p) < distv(closest, p))
            closest = cp;
    }


    return closest;
}



function closestTangentOnCurve(degree, points, p, constrain = 0)
{
    const closestPoints = [];

    let i;
    for (i = 0; i < points.length - degree; i += degree)
    {
        switch (degree)
        {
        case 1:  
            closestPoints.push([
                closestPointOnLine(points[i], points[i+1], p, true, constrain),
                subv(points[i+1], points[i])]);

            break;

        case 2:  
        {
            const t = closestPointOnSegment2(points[i], points[i+1], points[i+2], p, 0, 1, constrain);

            closestPoints.push([
                lerpv2  (points[i], points[i+1], points[i+2], t), 
                tangent2(points[i], points[i+1], points[i+2], t)]); 

            break;
        }
        case 3:  
        {
            const t = closestPointOnSegment3(points[i], points[i+1], points[i+2], points[i+3], p, 0, 1, constrain);

            closestPoints.push([
                lerpv3  (points[i], points[i+1], points[i+2], points[i+3], t),
                tangent3(points[i], points[i+1], points[i+2], points[i+3], t)]); 

            break;
        }
        default: consoleAssert(false);
        }
    }


    let closest = point_NaN;
    let tangent = point_NaN;

    for (let i = 0; i < closestPoints.length; i++)
    {
        const cp = closestPoints[i][0];

        if (   pointIsNaN(closest)
            || distv(cp, p) < distv(closest, p))
        {
            closest = cp;
            tangent = closestPoints[i][1];
        }
    }


    return [closest, tangent];
}



function closestPointOnSegment2(p0, p1, p2, p, start, end, constrain = 0, nSlices = 1000, nIterations = 1000)
{
    if (nIterations <= 0) 
        return (start + end) / 2;
    

    
    const tick = (end - start) / nSlices;

    if (tick <= 0.000001)
        return (start + end) / 2;


    let best = 0;

    let bestDistance = Number.MAX_SAFE_INTEGER;
    let currentDistance;


    let t = start;
    
    while (t <= end) 
    {
        const hp  = lerpv2(p0, p1, p2, t);
        const dp2 = sqrv(subv(hp, p));

        currentDistance = 
              (constrain != 2 ? dp2.x : 0) 
            + (constrain != 1 ? dp2.y : 0);

        if (currentDistance < bestDistance) 
        {
            bestDistance = currentDistance;
            best = t;
        }
        
        t += tick;
    }


    return closestPointOnSegment2(
        p0, p1, p2,
        p, 
        Math.max(best - tick, 0), 
        Math.min(best + tick, 1), 
        constrain,
        nSlices,
        nIterations - 1);
}



function closestPointOnSegment3(p0, p1, p2, p3, p, start, end, constrain = 0, nSlices = 1000, nIterations = 1000)
{
    if (nIterations <= 0)
        return (start + end) / 2;

    
    const tick = (end - start) / nSlices;

    if (tick <= 0.000001)
        return (start + end) / 2;


    let best = 0;

    let bestDistance = Number.MAX_SAFE_INTEGER;
    let currentDistance;


    let t = start;
    
    while (t <= end) 
    {
        const hp  = lerpv3(p0, p1, p2, p3, t);
        const dp2 = sqrv(subv(hp, p));
        
        currentDistance = 
              (constrain != 2 ? dp2.x : 0) 
            + (constrain != 1 ? dp2.y : 0);

        if (currentDistance < bestDistance) 
        {
            bestDistance = currentDistance;
            best = t;
        }
        
        t += tick;
    }


    return closestPointOnSegment3(
        p0, p1, p2, p3,
        p, 
        Math.max(best - tick, 0), 
        Math.min(best + tick, 1), 
        nSlices,
        nIterations - 1);
}


class Point
{
    x;
    y;

    constructor(x, y)
    {
        this.x = x;
        this.y = y;
    }
}


class Rect
{
    x;
    y;
    w;
    h;


    get l()            { return this.x;            }
    get c()            { return this.x + this.w/2; }
    get r()            { return this.x + this.w;   }
           
    get t()            { return this.y;            }
    get m()            { return this.y + this.h/2  }
    get b()            { return this.y + this.h;   }
          
    get tl()           { return point(this.l, this.t); }
    get tc()           { return point(this.c, this.t); }
    get tr()           { return point(this.r, this.t); }
    get ml()           { return point(this.l, this.m); }
    get mc()           { return point(this.c, this.m); }
    get cm()           { return point(this.c, this.m); }
    get mr()           { return point(this.r, this.m); }
    get bl()           { return point(this.l, this.b); }
    get bc()           { return point(this.c, this.b); }
    get br()           { return point(this.r, this.b); }
      
      
    get width()        { return this.w; }
    get height()       { return this.h; }
      
    get left()         { return this.l; }
    get center()       { return this.c; }
    get right()        { return this.r; }
          
    get top()          { return this.t; }
    get middle()       { return this.m; }
    get bottom()       { return this.b; }

    get topLeft()      { return this.tl; }
    get topCenter()    { return this.tc; }
    get topRight()     { return this.tr; }
    get middleLeft()   { return this.ml; }
    get middleCenter() { return this.mc; }
    get centerMiddle() { return this.cm; }
    get middleRight()  { return this.mr; }
    get bottomLeft()   { return this.bl; }
    get bottomCenter() { return this.bc; }
    get bottomRight()  { return this.br; }



    constructor(x, y, w, h)
    {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
    }



    static fromRect(rect)
    {
        return new Rect(rect.x, rect.y, rect.width, rect.height); 
    }



    // w & h are kept 0 so that isEmpty() works logically on NaN rects
    static get NaN () { return new Rect(Number.NaN, Number.NaN, 0, 0) };
    static get Zero() { return new Rect(0, 0, 0, 0); }



    get isNaN()
    {
        return isNaN(this.x)
            || isNaN(this.y)
            || isNaN(this.w)
            || isNaN(this.h);
    }



	get isEmpty()
	{
		return (this.w == 0
			 || this.h == 0);
	}



    assign(rect)
    {
        this.x = rect.x;
        this.y = rect.y;
        this.w = rect.w;
        this.h = rect.h;
    }
}



class   AbsRect
extends Rect
{
    constructor(l, t, r, b)
    {
        super(l, t, r-l, b-t);
    }
}



function expandRect(rect1, rect2)
{
    if (rect1.isNaN) return Rect.fromRect(rect2);
    if (rect2.isNaN) return Rect.fromRect(rect1);
    
    return new AbsRect(
        Math.min(rect2.l, rect1.l),
        Math.min(rect2.t, rect1.t),
        Math.max(rect2.r, rect1.r),
        Math.max(rect2.b, rect1.b));
}



function expandRect_(rect, p)
{
    if (rect.isNaN) 
        return new Rect(p.x, p.y, 0, 0);

    return new AbsRect(
        Math.min(p.x, rect.l),
        Math.min(p.y, rect.t),
        Math.max(p.x, rect.r),
        Math.max(p.y, rect.b));
}



class Random
{
    seed;
    index; // for next()

    cache;



    constructor(seed = 0)
    { 
        this.seed  = seed; 
        this.index = 0;
        
        this.updateCache(256);
    }



    copy()
    {
        return new Random(this.seed);
    }



    updateCache(size)
    {
        this.cache = new Int32Array(size);
        
        let seed = this.seed;

        for (let i = 0; i < size; i++)
            this.cache[i] = seed = this.generate(seed);
    }



    next()
    {
        if (this.index >= this.cache.length)
            this.updateCache(nextPow2(this.index));

        return this.cache[this.index++] / -0x7fffffff;
    }



    get(index)
    {
        if (index >= this.cache.length)
            this.updateCache(nextPow2(index+1));

        return this.cache[index] / -0x7fffffff;
    }



    generate(seed)
    {
        seed = (seed + 0x7ed55d16) + (seed << 12);
        seed = (seed ^ 0xc761c23c) ^ (seed >> 19);
        seed = (seed + 0x165667b1) + (seed <<  5);
        seed = (seed + 0xd3a2646c) ^ (seed <<  9);
        seed = (seed + 0xfd7046c5) + (seed <<  3);
        seed = (seed ^ 0xb55a4f09) ^ (seed >> 16);

        return seed;
    }
}


class Random2
{
    seed;
    cache;

    width;
    height;



    constructor(seed = 0)
    { 
        this.seed  = seed; 
        this.updateCache(256, 16);
    }



    copy()
    {
        return new Random(this.seed);
    }



    updateCache(width, height)
    {
        if (   width  <= this.width
            && height <= this.height)
            return;

        this.width  = width;
        this.height = height;
        
        const seeds = new Array(this.width);
        this.cache  = new Array(this.width);


        let seed = this.seed;

        for (let i = 0; i < this.width; i++)
        {
            seeds[i] = seed;
            seed = this.generate1(seed);
        }


        for (let i = 0; i < this.width; i++)
        {
            this.cache[i] = new Array(this.height);
            seed = seeds[i];

            for (let j = 0; j < this.height; j++)
            {
                this.cache[i][j] = seed;
                seed = this.generate2(seed);
            }
        }
    }



    get(x, y)
    {
          if (   x >= this.width 
              && y >= this.height) this.updateCache(nextPow2(x+1), nextPow2(y+1));
        else if (x >= this.width ) this.updateCache(nextPow2(x+1), this.height  );
        else if (y >= this.height) this.updateCache(this.width,    nextPow2(y+1));

        return this.cache[x][y] / -0x7fffffff;
    }



    generate1(seed)
    {
        seed = (seed + 0x7ed55d16) + (seed << 12);
        seed = (seed ^ 0xc761c23c) ^ (seed >> 19);
        seed = (seed + 0x165667b1) + (seed <<  5);
        seed = (seed + 0xd3a2646c) ^ (seed <<  9);
        seed = (seed + 0xfd7046c5) + (seed <<  3);
        seed = (seed ^ 0xb55a4f09) ^ (seed >> 16);

        return seed;
    }



    generate2(seed)
    {
        seed = (seed + 0x7f4a7c13) + (seed << 12);
        seed = (seed ^ 0xe17a1465) ^ (seed >> 19);
        seed = (seed + 0x59f89f1b) + (seed <<  5);
        seed = (seed + 0xac564b05) ^ (seed <<  9);
        seed = (seed + 0x65291958) + (seed <<  3);
        seed = (seed ^ 0x4ab1db4f) ^ (seed >> 16);
    
        return -seed;
    }
}


const isMac = navigator.platform.toLowerCase().indexOf('mac') >= 0;



var utilCanvas;
var utilContext;
    


const console_trace = console.trace;
    
console.trace = msg =>
{
    console.groupCollapsed(msg || 'trace');
    console_trace.apply(this);
    console.groupEnd();
};



function initUtilContext()
{
    utilCanvas  = document.createElement('canvas');
    utilContext = utilCanvas.getContext('2d');

    utilContext.willReadFrequently = true;
}



function avg(a, b)
{
    return (a + b) / 2;
}



function swap(a, b)
{
    return [b, a];
}



function flipBit(value, index)
{
    const bit = ((value >> index) & 1) != 0;

    return value
        & ~(1 << index)
        | (!bit ? 1 : 0) << index;
}



function indexOfChild(parent, child)
{
    return Array.prototype.indexOf.call(parent.children, child);
}



function countString(count, singular, plural = singular)
{
    if (singular == plural)
    {
        const lastChar   = singular.at(-1);
        const pluralChar = lastChar == lastChar.toUpperCase() ? 'S' : 's';

        return singular + (count == 1 ? '' : pluralChar);
    }
    else
    {
        const lastChar = plural.at(-1);

        if (lastChar == lastChar.toUpperCase())
            plural = plural.toUpperCase();

        return count == 1
            ? singular
            : plural;
    }
}



function decCount(strValue)
{
    const dotIndex   = strValue.indexOf('.');
    const commaIndex = strValue.indexOf(',');

    return dotIndex >= 0
         ? strValue.length-1 - dotIndex
         : (commaIndex >= 0
            ? strValue.length-1 - commaIndex
            : 0);
}



function getUserDecimalSeparator()
{
    const num = 1.1;

    return num
        .toLocaleString(navigator.language)
        .substring(1, 2);
}



function isEmptyObject(obj)
{
    if (obj == null)
        return false;
        
    return (
           Object.keys(obj).length === 0 
        && obj.constructor === Object);
}



function shallowCopy(obj)
{
    return Object.assign(Object.create(Object.getPrototypeOf(obj)), obj);
}



function deepCopy(obj)
{
    return JSON.parse(JSON.stringify(obj));
}



function filterUnique(array)
{
    return array.filter((value, index) => 
        array.indexOf(value) === index);
}



function createSvg(element)
{
    const svg = document.createElementNS("http://www.w3.org/2000/svg", element);
    svg.style.pointerEvents = 'none';
    return svg;
}



function isVisible(element)
{ 
    return element.style.visibility == 'visible'; 
}



function isLastInArray(array, item)
{
    return array.indexOf(item) == array.length-1;
}



function clearChildren(parent) 
{
    while (parent.firstChild)
        parent.removeChild(parent.firstChild);
}



// function replaceInStringAt(str, index, replace)
// {
//     return str.substring(0, index) 
//          + replace 
//          + str.substring(index + replace.length);
// }



function strFromData(data)
{
    let str = '';

    for (let i = 0; i < data.length; i++)
        str += String.fromCharCode(data[si]);

    return str;
}



// function clearConsole()
// {
//     setTimeout(console.clear.bind(console));
// }



function log(...params)
{
    setTimeout(console.log.bind(console, ...params)); // doesn't show log source, which makes logs cleaner
}



function logTrace()
{
    setTimeout(console.trace.bind(console));
}



function printNum(num)
{
    return !isNaN(num) ? num : NAN_DISPLAY;
}



function parseNum(str)
{
    return str == NAN_DISPLAY
         ? Number.NaN 
         : parseFloat(str);
}



function isTrue(strBool)
{
    return strBool == 'true';
}



function strIsNum(str) 
{
    if (typeof str != 'string') 
        return false; // only process strings

    if (str == 'NaN') // explicitly support NaN
        return true;

    return !isNaN(str) // use type coercion to parse the whole string
        && !isNaN(parseFloat(str)); // ensure strings of whitespace fail
}



function reflow(elem)
{
    void(elem.offsetHeight);
}


function readonly(target, name, descriptor)
{
    descriptor.writable = false;
    return descriptor;
}



function osCtrl     (plus = true) { return isMac ? ('⌘' + (plus ? ' ' : '')) : ('Ctrl'  + (plus ? '+' : '')); }
function osAlt      (plus = true) { return isMac ? ('⌥' + (plus ? ' ' : '')) : ('Alt'   + (plus ? '+' : '')); }
function osShift    (plus = true) { return isMac ? ('⇧' + (plus ? ' ' : '')) : ('Shift' + (plus ? '+' : '')); }
function osCtrlShift(plus = true) { return isMac ? osShift(plus) + osCtrl(plus) : osCtrl(plus) + osShift(plus); }



function getCreateNodeAction(type, creatingButton, options)
{
    return  options.insert != undefined
        &&  options.insert
        && (    options.autoConnect == undefined
            || !options.autoConnect)
        ? new CreateInsertNodeAction(type, creatingButton, options)
        : new CreateNodeAction      (type, creatingButton, options, options.autoConnect != undefined && options.autoConnect);
}



function simpleIntHash(x)
{
    return (x * 2654435761 % Math.pow(2, 32)) / Math.pow(2, 32);
}



function getNewNumberId(curId, countExisting, id = curId, join = '', startNum = 2, addZero = false)
{
    if (   addZero
        && (    id.length == 0
            || !isDigit(id.at(-1)))
        && countExisting(id) > 1)
        id += '0';


    if (countExisting(id) == 0)
        return id;
    

    let numLength = getNumLength(id);

    if (numLength > 0)
    {
        const len = id.length - numLength;
        let   num = parseInt(id.substring(len));

        let newId = '';
        while (newId == '' || countExisting(newId) > 0)
            newId = id.substring(0, len + join.length) + join + (++num);

        return newId;
    }

    else if (numLength == 0)
    {
        let num   = startNum;
        let newId = id + join + num;

        while (countExisting(newId) > 0)
            newId = id + join + (++num);

        return newId;
    }

    else
        return id;
}



function getNumLength(name)
{
    let numLength = 0;

    for (let i = name.length - 1; i >= 0; i--)
    {
        if (isDigit(name[i])) numLength++;
        else break;
    }

    return numLength;
}



function isValidFloatString(str) 
{
    return /^-?\d*\.?\d*(e-?\d+)?$/.test(str);
}



function setControlFont(control, family, size, align = 'left')
{
    control.style.fontFamily = family;
    control.style.fontSize   = size + 'px';
    control.style.textAlign  = align;
}



function daysInMonth(month, year)
{
    if (month == 2)
    {
        return year % 4 != 0
             ? 28
             : 29;
    }
    else if (month == 4
          || month == 7
          || month == 9
          || month == 11)
        return 30;
    else
        return 31;
}



function getFontStyles(fontName)
{
    let fonts = figFonts.filter(f => f.fontName.family == fontName);


    fonts.sort((a, b) =>
    {
        if (a.fontName.style != b.fontName.style)
            return FONT_WEIGHTS.findIndex(w => w[0] == a.fontName.style.toLowerCase())
                 - FONT_WEIGHTS.findIndex(w => w[0] == b.fontName.style.toLowerCase());

        return 0;
    });

    
    return fonts.map(f => f.fontName.style);
}



function unescapeString(str)
{
    return str.replaceAll(/\\(.)/g, (match, char) => 
    {
        const replacements = 
        {
            'n':  '\n',
            'r':  '\r',
            't':  '\t',
            '\\': '\\',
            '\'': '\'',
            '\"': '\"',
            '\`': '\`'
        };
      
        return replacements[char] || match;
    });
}



function unescapeRegexPattern(str)
{
    return str.replace(/\\([\\.*+?^${}()|\[\]])/g, '$1');
}



function unescapeRegexReplacement(str)
{
    return str.replace(/\\([\\$&`'])/g, '$1');
}



// function getEditDistance(str1, str2)
// {
//     // calculate the Levenshtein distance between two strings
//     // implementation taken from http://blog.softwx.net/2014/12/optimizing-levenshtein-algorithm-in-c.html

//     // TODO replace with Damerau-Levenshtein

//     if (str1.length == 0) return str2.length;
//     if (str2.length == 0) return str1.length;

//     // make sure str1 is the shorter string

//     if (str1.length > str2.length)
//     {
//         const _str = str1;
//         str1 = str2;
//         str2 = _str;
//     } 

//     let len1 = str1.length; // min length of the two strings
//     let len2 = str2.length;

//     // suffix common to both strings can be ignored

//     while (len1 > 0 
//         && str1[len1 - 1] == str2[len2 - 1])
//     {
//         len1--; 
//         len2--; 
//     }

//     let start = 0;

//     // if there's a shared prefix or str1 == str2's suffix

//     if (str1[0] == str2[0])
//     {
//         while (start < len1 
//             && str1[start] == str2[start]) 
//             start++;

//         len1 -= start; // length of the part excluding common prefix and suffix
//         len2 -= start;

//         // if str1 == prefix and/or suffix of str2, 
//         // edit distance is just the number of additional characters in str2

//         if (len1 == 0) return len2;

//         str2 = str2.substring(start, len2); // faster than str2[start + j] in inner loop below
//     }

//     //

//     let v0 = [];
    
//     for (let j = 0; j < len2; j++) 
//         v0.push(j + 1);

//     //

//     let current = 0;

//     for (let i = 0; i < len1; i++)
//     {
//         const c = str1[start + i];

//         let left = current = i;

//         for (let j = 0; j < len2; j++)
//         {
//             const above = current;
           
//             current = left; // cost on diagonal (substitution)
//             left = v0[j];

//             if (c != str2[j])
//             {
//                 current++; // substitution

//                 let insDel = above + 1; // deletion

//                 if (insDel < current) 
//                     current = insDel;

//                 insDel = left + 1; // insertion

//                 if (insDel < current) 
//                     current = insDel;
//             }

//             v0[j] = current;
//         }
//     }
    
//     return current;
// }



function getEditDistance(str1, str2) 
{
    // using Damerau-Levenshtein
    
    const len1 = str1.length;
    const len2 = str2.length;
    const dist = [];


    // initialize the distance matrix
    
    for (let i = 0; i <= len1; i++) dist[i]    = [i];
    for (let j = 1; j <= len2; j++) dist[0][j] =  j;

    
    // populate the distance matrix
    
    for (let i = 1; i <= len1; i++) 
    {
        for (let j = 1; j <= len2; j++) 
        {
            const cost = str1[i-1] === str2[j-1] ? 0 : 1;

            dist[i][j] = Math.min(
                dist[i-1][j  ] + 1,     // deletion
                dist[i  ][j-1] + 1,     // insertion
                dist[i-1][j-1] + cost); // substitution

            // check for transpositions
 
            if (   i > 1 
                && j > 1 
                && str1[i-1] === str2[j-2] 
                && str1[i-2] === str2[j-1])
                dist[i][j] = Math.min(dist[i][j], dist[i-2][j-2] + cost); // transposition
        }
    }

    
    return dist[len1][len2];
}



function skipRandom(count)
{
    for (let i = 0; i < count; i++) 
        Math.random();
}



function includesSimilar(str, sub, levenshteinDistance)
{
    if (sub.length > str.length)
        return false;
    
    if (str.includes(sub))
        return true;
    
    for (let i = 0; i <= str.length - sub.length; i++) 
    {
        const s = str.substring(i, i + sub.length);
        
        if (getEditDistance(sub, s) <= levenshteinDistance)
            return true;
    }
}



function degamma(rgb, cs = sRGB)
{
    return [ cs.degamma(rgb[0]),
             cs.degamma(rgb[1]),
             cs.degamma(rgb[2]) ];
}



function regamma(rgb, cs = sRGB)
{
    return [ cs.regamma(rgb[0]),
             cs.regamma(rgb[1]),
             cs.regamma(rgb[2]) ];
}



String.prototype.replaceAt = function(index, replacement) 
{
    return this.substring(0, index) 
         + replacement 
         + this.substring(index+1);// + replacement.length);
};



function findAllIndices(array, condition)
{
    const items   = array.filter(condition);
    const indices = [];
    
    for (const item of items)
        indices.push(items.indexOf(item));

    return indices;
}



function createRandomString(length)
{
    const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'.split('');

    let str = '';

    for (let i = 0; i < length; i++)
        str += letters[Math.floor(Math.random() * letters.length)];

    return str;
}



function rectToString(rect)
{
    return '{'
             /*+ rect.x
        + ', ' + rect.y
        + ', '*/ + rect.width
        + ', '   + rect.height
        + '}';
}



function replaceLast(str, _what, _with)
{
    var lastIndex = str.lastIndexOf(_what);

    if (lastIndex === -1) 
        return str;

    return str.substring(0, lastIndex) + _with + str.substring(lastIndex + _what.length);
}



function getPanelHeaderUnder(x, y)
{
    const unders = document.elementsFromPoint(x, y)
        .filter(el => 
               el.node
            && el.className == 'nodeLabelWrapper');

    unders.reverse();

    return unders.length > 0 
         ? unders[0]
         : null;
}



function measureHtmlText(text, font, fontSize)
{
    divTextMeasure.style.font = fontSize + 'px \'' + font + '\'';
    divTextMeasure.innerHTML = text;
        
    return boundingRect(divTextMeasure);
}



function strline(tab, string = '', firstLine = false)
{
    return (firstLine ? '' : '\n')
         + '\t'.repeat(tab) 
         + string;
}


function currentUserIsDev()
{
    return devUsers.includes(currentUser.id);
}



function setSvgLinearGradientStroke(svg, target, color1, color2, x1, y1, x2, y2, contrast = 0) 
{
    if (!(svg instanceof SVGElement))
        throw new Error('\'svg\' must be an SVG element');

    
    let defs = svg.querySelector('defs');

    if (!defs) 
    {
        defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        svg.insertBefore(defs, svg.firstChild);
    }


    const existingGradients = defs.querySelectorAll('linearGradient');
    const gradientId        = `svgLinearGradient-${target.curveId}`;
    
    existingGradients.forEach(gradient => 
    {
        if (gradient.id == gradientId)
            gradient.remove();
    });


    const linearGradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');

    linearGradient.setAttribute('id', gradientId);
    linearGradient.setAttribute('x1', x1+'%');
    linearGradient.setAttribute('y1', y1+'%');
    linearGradient.setAttribute('x2', x2+'%');
    linearGradient.setAttribute('y2', y2+'%');

    
    const contrastDist = 35;

    const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
    stop1.setAttribute('offset', '0%');
    stop1.setAttribute('stop-color', color1);

    const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
    stop2.setAttribute('offset', roundTo(contrastDist*contrast, 2) + '%');
    stop2.setAttribute('stop-color', color1);

    const stop3 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
    stop3.setAttribute('offset', roundTo(100 - contrastDist*contrast, 2) + '%');
    stop3.setAttribute('stop-color', color2);

    const stop4 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
    stop4.setAttribute('offset', '100%');
    stop4.setAttribute('stop-color', color2);

 
    linearGradient.appendChild(stop1);
    linearGradient.appendChild(stop2);
    linearGradient.appendChild(stop3);
    linearGradient.appendChild(stop4);

    defs.appendChild(linearGradient);


    target.style.stroke = `url(#${gradientId})`;


    return gradientId;
}


// const yamlData = `
// Total Budget: 1000000
// Operations: 400000
//     Salaries: 200000
//         Management: 100000
//         Staff: 100000
//     Office Supplies: 50000
//         Stationery: 20000
//         Equipment: 30000
//     Utilities: 100000
//         Electricity: 60000
//         Water: 20000
//         Internet: 20000
//     Maintenance: 50000
//         Building Maintenance: 30000
//         Equipment Maintenance: 20000
// Marketing: 150000
//     Advertising: 70000
//         Online Ads: 40000
//         Print Ads: 30000
//     Promotions: 50000
//         Discounts: 30000
//         Events: 20000
//     Market Research: 30000
//         Surveys: 15000
//         Focus Groups: 15000
// Research and Development: 200000
//     Product Development: 150000
//         New Products: 100000
//         Product Improvements: 50000
//     Innovation: 50000
//         Technology: 30000
//         Processes: 20000
// Sales: 100000
//     Sales Team Salaries: 60000
//         Senior Sales: 30000
//         Junior Sales: 30000
//     Travel Expenses: 20000
//     Client Entertainment: 20000
// Human Resources: 50000
//     Recruitment: 20000
//         Job Advertisements: 10000
//         Recruitment Agencies: 10000
//     Training and Development: 30000
//         Workshops: 15000
//         Online Courses: 15000
// IT: 100000
//     Hardware: 40000
//         Computers: 25000
//         Servers: 15000
//     Software: 30000
//         Licenses: 20000
//         Subscriptions: 10000
//     IT Support: 30000
//         Internal Support: 20000
//         External Services: 10000
// Miscellaneous: 50000
//     Legal Fees: 20000
//     Insurance: 30000
// `;

// function parseYAML(yaml) {
//     const lines = yaml.split('\n').filter(line => line.trim() !== '');
//     const result = {};
//     const stack = [{ obj: result, indent: -1 }];

//     lines.forEach(line => {
//         const indent = line.search(/\S/);
//         const [key, value] = line.trim().split(/:\s*(.*)/);
//         const parsedValue = value === undefined ? {} : isNaN(value) ? value : Number(value);

//         while (stack[stack.length - 1].indent >= indent) {
//             stack.pop();
//         }

//         const parent = stack[stack.length - 1].obj;
//         parent[key] = parsedValue;
//         stack.push({ obj: parent[key], indent });
//     });

//     return result;
// }

// const parsedData = parseYAML(yamlData);
// console.log(JSON.stringify(parsedData, null, 2));



"use strict";

// Base64 / binary data / UTF-8 strings utilities
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding


// byte array to Base64 string decoding

function base64toUint6(c) 
{
    return    c > 64 
           && c < 91 
           ? c - 65 
           :    c > 96 
             && c < 123 
             ? c - 71
             :    c > 47 
               && c < 58 
               ? c + 4
               : c === 43 
                 ? 62
                 : c === 47 ? 63 : 0;
}



function base64toArray(str, blocksSize) 
{
    const base64 = str.replace(/[^A-Za-z0-9\+\/]/g, "");
    const inLen  = base64.length;

    const outLen = 
        blocksSize 
        ? Math.ceil((inLen * 3 + 1 >> 2) / blocksSize) * blocksSize 
        : inLen * 3 + 1 >> 2;
        
    const bytes = new Uint8Array(outLen);

    for (let mod3, 
             mod4, 
             uint24 = 0, 
             out    = 0, 
        i = 0; 
        i < inLen; 
        i++) 
    {
        mod4 = i & 3;
        uint24 |= base64toUint6(base64.charCodeAt(i)) << 6 * (3 - mod4);

        if (   mod4 === 3 
            || inLen - i === 1) 
        {
            for (mod3 = 0; mod3 < 3 && out < outLen; mod3++, out++) 
                bytes[out] = uint24 >>> (16 >>> mod3 & 24) & 255;

            uint24 = 0;
        }
    }

    return bytes;
}



// Base64 string to array encoding

function uint6toBase64(i) 
{
    return i < 26 
           ? i + 65
           : i < 52 
             ? i + 71
             : i < 62 
               ? i - 4
               : i === 62 
                 ? 43
                 : i === 63 ? 47 : 65;
}



function arrayToBase64(bytes)
{
    let mod3   = 2, 
        base64 = "";

    const length = bytes.length;

    for (let i = 0, uint24 = 0; i < length; i++) 
    {
        mod3 = i % 3;

        if (i > 0 && (i * 4 / 3) % 76 === 0) 
            base64 += "\r\n";

        uint24 |= bytes[i] << (16 >>> mod3 & 24);

        if (   mod3 === 2 
            || bytes.length - i === 1) 
        {
            base64 += String.fromCharCode(
                uint6toBase64(uint24 >>> 18 & 0x3F), 
                uint6toBase64(uint24 >>> 12 & 0x3F), 
                uint6toBase64(uint24 >>>  6 & 0x3F), 
                uint6toBase64(uint24        & 0x3F));
                
            uint24 = 0;
        }
    }

    return base64.substring(0, base64.length - 2 + mod3) + (mod3 === 2 ? '' : mod3 === 1 ? '=' : '==');
}



// UTF-8 array to DOMString and vice versa

function utf8ArrToStr(bytes) 
{
    let   str    = "";

    const length = bytes.length;

    for (let i = 0; i < length; i++) 
    {
        const byte = bytes[i];

        str += String.fromCharCode(
               byte > 251 
            && byte < 254 
            && i + 5 < length // six bytes
            ? (byte - 252) * 1073741824 + (bytes[++i] - 128 << 24) + (bytes[++i] - 128 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
            :    byte > 247 
              && byte < 252 
              && i + 4 < length // five bytes
              ? (byte - 248 << 24) + (bytes[++i] - 128 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
              :    byte > 239 
                && byte < 248 
                && i + 3 < length // four bytes
                ? (byte - 240 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
                :    byte > 223 
                  && byte < 240 
                  && i + 2 < length // three bytes
                  ? (byte - 224 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
                  :    byte > 191 
                    && byte < 224 
                    && i + 1 < length // two bytes
                    ? (byte - 192 << 6) + bytes[++i] - 128 /* nPart < 127 ? */ // one byte
                    : byte);
    }

    return str;
}



function strToUtf8Arr(str) 
{
    let strLen = str.length, 
        arrLen = 0;


    // mapping

    for (let i = 0; i < strLen; i++) 
    {
        const chr = str.charCodeAt(i);
        arrLen += chr < 0x80 ? 1 : chr < 0x800 ? 2 : chr < 0x10000 ? 3 : chr < 0x200000 ? 4 : chr < 0x4000000 ? 5 : 6;
    }

    const bytes = new Uint8Array(arrLen);


    // transcription

    for (let i = 0, iChr = 0; i < arrLen; iChr++) 
    {
        const chr = str.charCodeAt(iChr);
     
        if (chr < 0x80) // one byte
        {
            bytes[i++] = chr;
        } 
        else if (chr < 0x800) // two bytes
        {
            bytes[i++] = 192 + (chr >>> 6);
            bytes[i++] = 128 + (chr        & 0x3F);
        } 
        else if (chr < 0x10000) // three bytes
        {
            bytes[i++] = 224 + (chr >>> 12);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        }
        else if (chr < 0x200000) // four bytes
        {
            bytes[i++] = 240 + (chr >>> 18);
            bytes[i++] = 128 + (chr >>> 12 & 0x3F);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        } 
        else if (chr < 0x4000000) // five bytes
        {
            bytes[i++] = 248 + (chr >>> 24);
            bytes[i++] = 128 + (chr >>> 18 & 0x3F);
            bytes[i++] = 128 + (chr >>> 12 & 0x3F);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        } 
        else //if (nChr <= 0x7fffffff) // six bytes
        {
            bytes[i++] = 252 + (chr >>> 30);
            bytes[i++] = 128 + (chr >>> 24 & 0x3F);
            bytes[i++] = 128 + (chr >>> 18 & 0x3F);
            bytes[i++] = 128 + (chr >>> 12 & 0x3F);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        }
    }


    return bytes;
}


function position(e)
{
    return point(e.clientX, e.clientY);
}



function getStyleValue(obj, style)
{
    return window.getComputedStyle(obj).getPropertyValue(style);
}



function getCtrlKey(e)
{
    return isMac ? e.metaKey : e.ctrlKey;
    // return  isMac && e.metaKey
    //     || !isMac && e.ctrlKey;
}



function dispatchNewEvent(target, proto)
{
    target.dispatchEvent(new proto.constructor(proto.type, proto));
}



function createDiv(className = '', id = '')
{
    const div = document.createElement('div');
    
    if (className != '')
        div.className = className;
    
    if (id != '')
        div.id = id;

    return div;
}



function appendDivTo(div, to)
{
    if (!to.contains(div))
        to.appendChild(div);
}



function removeDivFrom(div, from)
{
    if (from.contains(div))
        from.removeChild(div);
}



function createTextbox(className = '')
{
    const textbox = document.createElement('INPUT');
    textbox.setAttribute('type', 'text'); 

    if (className.trim() != '')
        textbox.className = className;
    
    return textbox;
}



function createTextarea(className = '')
{
    const textarea = document.createElement('textarea');

    if (className.trim() != '')
        textarea.className = className;
    
    textarea.spellcheck = false;
    
    return textarea;
}



function createCanvas(className = '')
{
    const canvas = document.createElement('canvas');

    if (className.trim() != '')
        canvas.className = className;
    
    return canvas;
}



function enableElementText(elem, enable, bold = true)
{
    elem.style.fontStyle  = enable ? 'normal' : 'italic'; 

    if (bold)
        elem.style.fontWeight = enable ? 'normal' : 'bold';
}



function hasFocus(elem)
{
    return elem == document.activeElement;
}



function setStyle(id, properties)
{
    const elem = document.getElementById(id);

    for (const property of properties)
        elem.style[property] = properties[property];
}



function containsChild(parent, child)
{
    return child.parentNode == parent;
}



function forwardEvent(event, element)
{
    const e = new event.constructor(event.type, event);
    element.dispatchEvent(e);
}



function offsetRect(element)
{
    return new Rect(
        element.offsetLeft,
        element.offsetTop,
        element.offsetWidth,
        element.offsetHeight);
}



function clientRect(element)
{
    return new Rect(
        element.clientLeft,
        element.clientTop,
        element.clientWidth,
        element.clientHeight);
}



// function triggerMouseEvent(element, event, px, py, button = 0)
// {
//     const e = new MouseEvent(event, 
//     {
//         clientX: px,
//         clientY: py,
//         button:  button
//     });
//
//     element.dispatchEvent(e);
// }



function selectElementText(elementId)
{
    if (document.selection) // IE
    {
        var range = document.body.createTextRange();
        range.moveToElementText(document.getElementById(elementId));
        range.select();
    }
    else if (window.getSelection) 
    {
        var range = document.createRange();
        range.selectNode(document.getElementById(elementId));
        window.getSelection().removeAllRanges();
        window.getSelection().addRange(range);
    }
}



function isTouchpad(e)
{
    return Math.abs(e.deltaX) < 100
        && Math.abs(e.deltaY) < 100;
}



function showElement(element, show = true) 
{
    const showStyle = 'block';
    const hideStyle = 'none';

    if (  !show
        && element.style.display != hideStyle)
        element.oldDisplay = element.style.display;

    element.style.display = 
        show 
        ? (   element.style.oldDisplay 
           && element.style.oldDisplay != hideStyle
           ? element.style.oldDsplay
           : showStyle)
        : hideStyle; 
}


function hideElement(element)              
{ 
    showElement(element, false); 
}



function isVisible(element)
{
    return element.offsetParent !== null;
}



function getSelectedText(element) // only allow input[type=text] & textarea
{ 
    if (   element.tagName === 'TEXTAREA' 
        || (   element.tagName === 'INPUT' 
            && element.type === 'text')) 
    {
        return element.value.substring(
            element.selectionStart,
            element.selectionEnd);
    }
}



function clearSelectedText(element)
{
    if (   element.tagName === 'TEXTAREA' 
        || (   element.tagName === 'INPUT' 
            && element.type === 'text')) 
    {
        const str = element.value;

        element.value = 
              str.slice(0, element.selectionStart) 
            + str.slice(element.selectionEnd)
    }
}



function scrollbarVisible(element) 
{
    return element.scrollHeight > element.clientHeight;
}



function clientPos(e)
{
    return point(e.clientX, e.clientY);
}



function elementHasSelectedText(div)
{
    const selection = window.getSelection();

    if (selection.rangeCount > 0) 
    {
        const range = selection.getRangeAt(0);
        
        if (   range.commonAncestorContainer === div
            || div.contains(range.commonAncestorContainer))
        {
            const selectedText = range.toString().trim();

            if (selectedText.length > 0)
                return true;
        }
    }

    return false; 
}



function selectDivText(div)
{
    var range = document.createRange();
    range.selectNode(div);

    window.getSelection().removeAllRanges();
    window.getSelection().addRange(range);    
}



function loadFromLocalFile(callback)
{
    const input = document.createElement('input');

    input.type   = 'file';
    input.accept = '.gen';
    
    input.onchange = e => 
    { 
        const file = e.target.files[0]; 

        const reader = new FileReader();
        reader.readAsText(file,'UTF-8');

        reader.onload = e => callback(e.target.result);
    }; 

    input.click();
}



function getLocalFile(callback)
{
    const input = document.createElement('input');

    input.type   = 'file';
    input.accept = '*.*';
    
    input.onchange = e => 
    { 
        callback(e.target.files[0]); 
    }; 

    input.click();
}



async function saveToLocalFile(content, filename, contentType)
{
    const a    = document.createElement('a');
    const file = new Blob([content], {type: contentType});

    a.download = filename;
    a.href     = URL.createObjectURL(file);

    a.click();

    await new Promise(resolve => setTimeout(resolve, 500));
    
    URL.revokeObjectURL(a.href);
}


const htmlColors = 
[
    {name: 'AliceBlue',            color: 'f0f8ff'},
    {name: 'AntiqueWhite',         color: 'faebd7'},
    {name: 'Aqua',                 color: '00ffff'},
    {name: 'Aquamarine',           color: '7fffd4'},
    {name: 'Azure',                color: 'f0ffff'},
    {name: 'Beige',                color: 'f5f5dc'},
    {name: 'Bisque',               color: 'ffe4c4'},
    {name: 'Black',                color: '000000'},
    {name: 'BlanchedAlmond',       color: 'ffebcd'},
    {name: 'Blue',                 color: '0000ff'},
    {name: 'BlueViolet',           color: '8a2be2'},
    {name: 'Brown',                color: 'a52a2a'},
    {name: 'BurlyWood',            color: 'deb887'},
    {name: 'CadetBlue',            color: '5f9ea0'},
    {name: 'Chartreuse',           color: '7fff00'},
    {name: 'Chocolate',            color: 'd2691e'},
    {name: 'Coral',                color: 'ff7f50'},
    {name: 'CornflowerBlue',       color: '6495ed'},
    {name: 'Cornsilk',             color: 'fff8dc'},
    {name: 'Crimson',              color: 'dc143c'},
    {name: 'Cyan',                 color: '00ffff'},
    {name: 'DarkBlue',             color: '00008b'},
    {name: 'DarkCyan',             color: '008b8b'},
    {name: 'DarkGoldenRod',        color: 'b8860b'},
    {name: 'DarkGray',             color: 'a9a9a9'},
    {name: 'DarkGrey',             color: 'a9a9a9'},
    {name: 'DarkGreen',            color: '006400'},
    {name: 'DarkKhaki',            color: 'bdb76b'},
    {name: 'DarkMagenta',          color: '8b008b'},
    {name: 'DarkOliveGreen',       color: '556b2f'},
    {name: 'DarkOrange',           color: 'ff8c00'},
    {name: 'DarkOrchid',           color: '9932cc'},
    {name: 'DarkRed',              color: '8b0000'},
    {name: 'DarkSalmon',           color: 'e9967a'},
    {name: 'DarkSeaGreen',         color: '8fbc8f'},
    {name: 'DarkSlateBlue',        color: '483d8b'},
    {name: 'DarkSlateGray',        color: '2f4f4f'},
    {name: 'DarkSlateGrey',        color: '2f4f4f'},
    {name: 'DarkTurquoise',        color: '00ced1'},
    {name: 'DarkViolet',           color: '9400d3'},
    {name: 'DeepPink',             color: 'ff1493'},
    {name: 'DeepSkyBlue',          color: '00bfff'},
    {name: 'DimGray',              color: '696969'},
    {name: 'DimGrey',              color: '696969'},
    {name: 'DodgerBlue',           color: '1e90ff'},
    {name: 'FireBrick',            color: 'b22222'},
    {name: 'FloralWhite',          color: 'fffaf0'},
    {name: 'ForestGreen',          color: '228b22'},
    {name: 'Fuchsia',              color: 'ff00ff'},
    {name: 'Gainsboro',            color: 'dcdcdc'},
    {name: 'GhostWhite',           color: 'f8f8ff'},
    {name: 'Gold',                 color: 'ffd700'},
    {name: 'GoldenRod',            color: 'daa520'},
    {name: 'Gray',                 color: '808080'},
    {name: 'Grey',                 color: '808080'},
    {name: 'Green',                color: '008000'},
    {name: 'GreenYellow',          color: 'adff2f'},
    {name: 'HoneyDew',             color: 'f0fff0'},
    {name: 'HotPink',              color: 'ff69b4'},
    {name: 'IndianRed',            color: 'cd5c5c'},
    {name: 'Indigo',               color: '4b0082'},
    {name: 'Ivory',                color: 'fffff0'},
    {name: 'Khaki',                color: 'f0e68c'},
    {name: 'Lavender',             color: 'e6e6fa'},
    {name: 'LavenderBlush',        color: 'fff0f5'},
    {name: 'LawnGreen',            color: '7cfc00'},
    {name: 'LemonChiffon',         color: 'fffacd'},
    {name: 'LightBlue',            color: 'add8e6'},
    {name: 'LightCoral',           color: 'f08080'},
    {name: 'LightCyan',            color: 'e0ffff'},
    {name: 'LightGoldenRodYellow', color: 'fafad2'},
    {name: 'LightGray',            color: 'd3d3d3'},
    {name: 'LightGrey',            color: 'd3d3d3'},
    {name: 'LightGreen',           color: '90ee90'},
    {name: 'LightPink',            color: 'ffb6c1'},
    {name: 'LightSalmon',          color: 'ffa07a'},
    {name: 'LightSeaGreen',        color: '20b2aa'},
    {name: 'LightSkyBlue',         color: '87cefa'},
    {name: 'LightSlateGray',       color: '778899'},
    {name: 'LightSlateGrey',       color: '778899'},
    {name: 'LightSteelBlue',       color: 'b0c4de'},
    {name: 'LightYellow',          color: 'ffffe0'},
    {name: 'Lime',                 color: '00ff00'},
    {name: 'LimeGreen',            color: '32cd32'},
    {name: 'Linen',                color: 'faf0e6'},
    {name: 'Magenta',              color: 'ff00ff'},
    {name: 'Maroon',               color: '800000'},
    {name: 'MediumAquaMarine',     color: '66cdaa'},
    {name: 'MediumBlue',           color: '0000cd'},
    {name: 'MediumOrchid',         color: 'ba55d3'},
    {name: 'MediumPurple',         color: '9370db'},
    {name: 'MediumSeaGreen',       color: '3cb371'},
    {name: 'MediumSlateBlue',      color: '7b68ee'},
    {name: 'MediumSpringGreen',    color: '00fa9a'},
    {name: 'MediumTurquoise',      color: '48d1cc'},
    {name: 'MediumVioletRed',      color: 'c71585'},
    {name: 'MidnightBlue',         color: '191970'},
    {name: 'MintCream',            color: 'f5fffa'},
    {name: 'MistyRose',            color: 'ffe4e1'},
    {name: 'Moccasin',             color: 'ffe4b5'},
    {name: 'NavajoWhite',          color: 'ffdead'},
    {name: 'Navy',                 color: '000080'},
    {name: 'OldLace',              color: 'fdf5e6'},
    {name: 'Olive',                color: '808000'},
    {name: 'OliveDrab',            color: '6b8e23'},
    {name: 'Orange',               color: 'ffa500'},
    {name: 'OrangeRed',            color: 'ff4500'},
    {name: 'Orchid',               color: 'da70d6'},
    {name: 'PaleGoldenRod',        color: 'eee8aa'},
    {name: 'PaleGreen',            color: '98fb98'},
    {name: 'PaleTurquoise',        color: 'afeeee'},
    {name: 'PaleVioletRed',        color: 'db7093'},
    {name: 'PapayaWhip',           color: 'ffefd5'},
    {name: 'PeachPuff',            color: 'ffdab9'},
    {name: 'Peru',                 color: 'cd853f'},
    {name: 'Pink',                 color: 'ffc0cb'},
    {name: 'Plum',                 color: 'dda0dd'},
    {name: 'PowderBlue',           color: 'b0e0e6'},
    {name: 'Purple',               color: '800080'},
    {name: 'RebeccaPurple',        color: '663399'},
    {name: 'Red',                  color: 'ff0000'},
    {name: 'RosyBrown',            color: 'bc8f8f'},
    {name: 'RoyalBlue',            color: '4169e1'},
    {name: 'SaddleBrown',          color: '8b4513'},
    {name: 'Salmon',               color: 'fa8072'},
    {name: 'SandyBrown',           color: 'f4a460'},
    {name: 'SeaGreen',             color: '2e8b57'},
    {name: 'SeaShell',             color: 'fff5ee'},
    {name: 'Sienna',               color: 'a0522d'},
    {name: 'Silver',               color: 'c0c0c0'},
    {name: 'SkyBlue',              color: '87ceeb'},
    {name: 'SlateBlue',            color: '6a5acd'},
    {name: 'SlateGray',            color: '708090'},
    {name: 'SlateGrey',            color: '708090'},
    {name: 'Snow',                 color: 'fffafa'},
    {name: 'SpringGreen',          color: '00ff7f'},
    {name: 'SteelBlue',            color: '4682b4'},
    {name: 'Tan',                  color: 'd2b48c'},
    {name: 'Teal',                 color: '008080'},
    {name: 'Thistle',              color: 'd8bfd8'},
    {name: 'Tomato',               color: 'ff6347'},
    {name: 'Turquoise',            color: '40e0d0'},
    {name: 'Violet',               color: 'ee82ee'},
    {name: 'Wheat',                color: 'f5deb3'},
    {name: 'White',                color: 'ffffff'},
    {name: 'WhiteSmoke',           color: 'f5f5f5'},
    {name: 'Yellow',               color: 'ffff00'},
    {name: 'YellowGreen',          color: '9acd32'}
];



const genColorNameLightness =
[
    {name: 'pale',   value: 0.87},
    {name: 'light',  value: 0.76},
    {name: 'bright', value: 0.65},
    {name: 'deep',   value: 0.35},
    {name: 'dim',    value: 0.22},
    {name: 'dark',   value: 0.12}
];



const genColorNameSaturation =
[
    {name: 'calm',  value: 0.72},
    {name: 'dull',  value: 0.46},
    {name: 'dirty', value: 0.21}
];



const genColorNameHue =
[
    {name: 'violet',  value: 285},
    {name: 'purple',  value: 269},
    {name: 'indigo',  value: 252},
    {name: 'blue',    value: 241},
    {name: 'cobalt',  value: 222},
    {name: 'sky',     value: 211},
    {name: 'aqua',    value: 193},
    {name: 'cyan',    value: 177},
    {name: 'jade',    value: 154},
    {name: 'green',   value: 112},
    {name: 'lime',    value:  74},
    {name: 'yellow',  value:  54},
    {name: 'mango',   value:  42},
    {name: 'orange',  value:  30},
    {name: 'amber',   value:  17},
    {name: 'salmon',  value:  11},
    {name: 'red',     value:   0},
    {name: 'rose',    value: 335},
    {name: 'magenta', value: 310}
];



function parseColorNameLightness(name) 
{
    for (const item of genColorNameLightness) 
    {
        if (   name.startsWith(item.name) 
            ||     getEditDistance(name.slice(0, item.name.length), item.name) <= 1
               && !genColorNameHue.find(h => h.name.startsWith(name))) 
        {
            return { value:     item.value, 
                     remaining: name.slice(item.name.length) };
        }
    }

    return { value:     null, 
             remaining: name };
}



function parseColorNameSaturation(name) 
{
    for (const item of genColorNameSaturation) 
    {
        if (   name.startsWith(item.name) 
            ||     getEditDistance(name.slice(0, item.name.length), item.name) <= 1
               && !genColorNameHue.find(h => h.name.startsWith(name))) 
        {
            return { value:     item.value, 
                     remaining: name.slice(item.name.length) };
        }
    }

    return { value:     null, 
             remaining: name };
}



function parseColorNameHue(name) 
{
    for (const item of genColorNameHue) 
    {
        if (   name === item.name 
            || getEditDistance(name.slice(0, item.name.length), item.name) <= 1) 
        {
            return item.value;
        }
    }

    return null;
}



function parseColorName(_colorName) 
{
    let colorName = _colorName.replace(/\s+/g, '');


    if (   colorName === 'black' 
        || getEditDistance(colorName, 'black') <= 1)
        return [0, 0, 0];

    if (   colorName === 'white' 
        || getEditDistance(colorName, 'white') <= 1)
        return [0, 0, 1];

        
    const grayVariants = ['gray', 'grey'];

    let isGray = false;
    let gl     = 0.5;

    for (const grayVariant of grayVariants) 
    {
        if (   colorName.endsWith(grayVariant) 
            || getEditDistance(colorName.slice(-grayVariant.length), grayVariant) <= 1) 
        {
            isGray = true;
        
            const grayPrefix = colorName.slice(0, -grayVariant.length);
            
            if (grayPrefix) 
            {
                const { value } = parseColorNameLightness(grayPrefix);
                
                if (value !== null) 
                    gl = value;
            }

            break;
        }
    }


    if (isGray)
        return [0, 0, gl];


    let h = null;
    let s = null;
    let l = null;

    
    // try lightness first
    
    let result  = parseColorNameLightness(colorName);
        l       = result.value;
    let remName = result.remaining;

        result  = parseColorNameSaturation(remName);
        s       = result.value;
        remName = result.remaining;

        h       = parseColorNameHue(remName);


    // reset if the first check fails
    // and try saturation first
    
    if (   h === null 
        || s === null 
        || l === null) 
    {
        h = null;
        s = null;
        l = null;

        result  = parseColorNameSaturation(colorName);
        s       = result.value;
        remName = result.remaining;

        result  = parseColorNameLightness(remName);
        l       = result.value;
        remName = result.remaining;

        h       = parseColorNameHue(remName);
    }


    if (h === null) return null; // hue is mandatory
    if (l === null) l = 0.5;
    if (s === null) s = 1.0;

    
    return [h / 360, s, l];
}



function createColorName(rgb)
{
    if (rgb.length > 3 && rgba[3] == 0)
        return 'transparent';


    const hsl = rgb2hsl(rgb);

    let   h = hsl[0] * 360;

    while (h >= 360) h -= 360;
    while (h <    0) h += 360;
    
    const s = hsl[1];
    const l = hsl[2];


         if (l >= 0.94) return 'white';
    else if (l <  0.06) return 'black';


    let strH = '';
    let strS = '';
    let strL = '';


         if (l >= 0.81 && l < 0.94) strL = 'pale ';
    else if (l >= 0.69 && l < 0.81) strL = 'light ';
    else if (l >= 0.56 && l < 0.69) strL = 'bright ';
    else if (l >= 0.31 && l < 0.44) strL = 'deep ';
    else if (l >= 0.19 && l < 0.31) strL = 'dim ';
    else if (l >= 0.06 && l < 0.19) strL = 'dark ';
    

    if (l > 0.25 && l < 0.75) 
    {
             if (s >= 0.62 && s < 0.88) strS = 'calm ';
        else if (s >= 0.31 && s < 0.62) strS = 'dull ';
        else if (s >= 0.12 && s < 0.31) strS = 'dirty ';
    }


    if (s >= 0.12)
    {
             if (h < 293 && h >= 278) strH = 'violet';
        else if (h < 278 && h >= 259) strH = 'purple';
        else if (h < 259 && h >= 248) strH = 'indigo';
        else if (h < 248 && h >= 233) strH = 'blue';
        else if (h < 233 && h >= 221) strH = 'cobalt';
        else if (h < 221 && h >= 201) strH = 'sky';
        else if (h < 201 && h >= 185) strH = 'aqua';
        else if (h < 185 && h >= 169) strH = 'cyan';
        else if (h < 169 && h >= 139) strH = 'jade';
        else if (h < 139 && h >=  86) strH = 'green';
        else if (h <  86 && h >=  63) strH = 'lime';
        else if (h <  63 && h >=  45) strH = 'yellow';
        else if (h <  45 && h >=  40) strH = 'mango';
        else if (h <  40 && h >=  21) strH = 'orange';
        else if (h <  21 && h >=  13) strH = 'amber';
        else if (h <  13 && h >=   8) strH = 'salmon';
        else if (h <   8 || h >= 352) strH = 'red';
        else if (h < 352 && h >= 328) strH = 'rose';
        else if (h < 328 && h >= 293) strH = 'magenta';
        else 
            console.error('error parsing hue name');
    }
    else 
        strH = 'gray';


    return strL + strS + strH;
}



var _clipboard = '';



function writeTextToClipboard(str) 
{
    if (subscribed())
    {
        if (   navigator.clipboard 
            && window.isSecureContext) 
            return navigator.clipboard.writeText(str);

        else 
        {
            const prevActive = document.activeElement;
            const textArea   = document.createElement('textarea');

            textArea.value = str;

            textArea.style.position = 'fixed';
            textArea.style.left     = '-999999px';
            textArea.style.top      = '-999999px';
            
            document.body.appendChild(textArea);
            
            textArea.focus();
            textArea.select();
            
            return new Promise((res, rej) => 
            {
                document.execCommand('copy') ? res() : rej();
                textArea.remove();

                prevActive.focus();
            });
        }
    }
    else
        _clipboard = str;
}



function readTextFromClipboard() 
{
    if (subscribed())
    {
        if (   navigator.clipboard 
            && window.isSecureContext) 
            return navigator.clipboard.readText();

        else 
        {
            let textArea = document.createElement('textarea');

            textArea.style.position = 'fixed';
            textArea.style.left     = '-999999px';
            textArea.style.top      = '-999999px';
            
            document.body.appendChild(textArea);
            
            textArea.focus({preventScroll: true});
            textArea.select();
            
            return new Promise((res, rej) => 
            {
                document.execCommand('paste') ? res(textArea.value) : rej();
                textArea.remove();
            });
        }
    }
    else
        return new Promise((res, rej) => res(_clipboard));
}


function isTagKey(key, tag) 
{
    return key.substring(0, tag.length+1) == tag + ' ';
}



function noTag(key, tag)
{
    return key.substring(tag.length+1);
}



function isPageKey(key) { return isTagKey(key, pageTag); }
function isNodeKey(key) { return isTagKey(key, nodeTag); }
function isConnKey(key) { return isTagKey(key, connTag); }



function noPageTag(key) { return noTag(key, pageTag); }
function noNodeTag(key) { return noTag(key, nodeTag); }
function noConnTag(key) { return noTag(key, connTag); }


const NAN_CHAR               = '\uFFFD';
const NAN_DISPLAY            = '?';

const SEP                    = ' ';
    
const UNKNOWN_CHAR           = '?';
const UNKNOWN_DISPLAY        = UNKNOWN_CHAR;//'🤷‍♂️';

const NAME_SEPARATOR         = ' ';
const OBJECT_SEPARATOR       = ' > ';
const   PROP_SEPARATOR       = ' / ';
const  INPUT_SEPARATOR       = ':';

const CENTER_SUFFIX          = ' •';
const  XFORM_SUFFIX          = ' ◇';
    

const  TRUE_DISPLAY_LIGHT    = '<svg width="13" height="11" viewBox="0 1 13 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.3645 1.82058L10.2676 0.599976L5.1191 8.58091L2.44314 6.06144L0.800003 7.67327L5.54161 12.1958L12.3645 1.82058Z" fill="#2AD400"/></svg>';
const FALSE_DISPLAY_LIGHT    = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="#F43D3D"/></svg>';    

const  TRUE_DISPLAY_DARK     = '<svg width="12" height="11" viewBox="0 0 12 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M11.1 0.998457L9.41674 0L4.20109 8.01592L1.50123 5.4381L0.1 6.77599L4.52397 11L11.1 0.998457Z" fill="#3FF911"/></svg>';
const FALSE_DISPLAY_DARK     = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="#FF3E3E"/></svg>';

const  TRUE_DISPLAY_LIGHT_BW = '<svg width="11" height="11" viewBox="0 0 11 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.7157 0.893364L9.55198 0.139526L4.15187 8.47598L1.20316 5.59262L0.248535 6.5928L4.41886 10.5815L5.04702 9.60025L10.7157 0.893364Z" fill="black"/></svg>';
const FALSE_DISPLAY_LIGHT_BW = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.13479 0.1521L0.1521 1.13479L3.51727 4.49997L0.152106 7.86514L1.1348 8.84783L4.49997 5.48266L7.86511 8.8478L8.8478 7.86511L5.48266 4.49997L8.84781 1.13482L7.86511 0.152129L4.49997 3.51727L1.13479 0.1521Z" fill="black"/></svg>';

const  TRUE_DISPLAY_DARK_BW  = '<svg width="12" height="11" viewBox="0 0 12 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M11.1 0.998457L9.41672 0L4.20107 8.01592L1.50121 5.4381L0.0999756 6.77599L4.52395 11L11.1 0.998457Z" fill="white"/></svg>';
const FALSE_DISPLAY_DARK_BW  = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="white"/></svg>';

const  TRUE_DISPLAY_MENU     = '<svg width="12" height="11" viewBox="0 0 12 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M11.1 0.998457L9.41675 0L4.2011 8.01592L1.50124 5.4381L0.100006 6.77599L4.52398 11L11.1 0.998457Z" fill="white"/></svg>';
const FALSE_DISPLAY_MENU     = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="white"/></svg>';



function getTrueDisplay(color = true)
{
    return darkMode
         ? (color ? TRUE_DISPLAY_DARK  : TRUE_DISPLAY_DARK_BW )
         : (color ? TRUE_DISPLAY_LIGHT : TRUE_DISPLAY_LIGHT_BW);
}



function getFalseDisplay(color = true)
{
    return darkMode
         ? (color ? FALSE_DISPLAY_DARK  : FALSE_DISPLAY_DARK_BW )
         : (color ? FALSE_DISPLAY_LIGHT : FALSE_DISPLAY_LIGHT_BW);
}


var showDebugInfo = false;

var debugFlag1    = false;



function nodeIdArrayToString(nodeIds)
{
    let str = '';

    for (let i = 0; i < nodeIds.length; i++)
    {
        if (i > 0) str += ', ';
        str += nodeIds[i];
    }

    return str;
}



function nodeArrayToString(nodes)
{
    let str = '';

    nodes.map(n => n ? n.id : 'undefined').join(', ');

    // for (let i = 0; i < nodes.length; i++)
    // {
    //     if (i > 0) str += ', ';
    //     str += nodes[i] ? nodes[i].id : 'undefined';
    // }

    return str;
}



function updateDebugInfo()
{
    if (showDebugInfo)
    {
        debugInfoText.style.display = 'inline-block';

        debugInfoText.innerHTML =
                        'pan = '  + graph.currentPage.pan.x.toFixed(2) + ', ' + graph.currentPage.pan.y.toFixed(2)
            + '<br/>' + 'zoom = ' + graph.currentPage.zoom.toFixed(4);
    }
    else
        debugInfoText.style.display = 'none';
}


const INTER_STEP   = 0,
      INTER_LINEAR = 1,
      INTER_COSINE = 2,
      INTER_CUBIC  = 3;



class NoiseSeed
{
    initial;
    current;

    

    constructor()
    {
        this.reset();
    }
    


    set(seed)
    {
        this.initial = seed;
        this.current = seed;
    }    
    


    rotate()
    {
        this.current = (this.current + 0x7ed55d16) + (this.current << 12);
        this.current = (this.current ^ 0xc761c23c) ^ (this.current >> 19);
        this.current = (this.current + 0x165667b1) + (this.current <<  5);
        this.current = (this.current + 0xd3a2646c) ^ (this.current <<  9);
        this.current = (this.current + 0xfd7046c5) + (this.current <<  3);
        this.current = (this.current ^ 0xb55a4f09) ^ (this.current >> 16);
    }    
    


    next()
    {
        const seed = this.current;
        this.rotate();
        return seed;
    }



    reset()
    {
        this.current = this.initial;
    }
};



class Noise
{
	interpolation = INTER_CUBIC;
	clip = false;

	seed = new NoiseSeed();

	v0;
	v1;
	v2;
	v3;

	step = 0;


    constructor(seed = 0)
    {
        this.seed.set(seed);
        this.reset();
    }


    next(scale = 1)
    {
        //scale = Math.pow(Phi, scale) / Phi;
        scale = Math.max(1, scale);

        let next = this.v1;

        if (this.step >= 1)
        {
            // get the next random value
        
            this.seed.rotate();

            this.v0 = this.v1;
        //------------------------
            this.v1 = this.v2;
            this.v2 = this.v3;
        //------------------------
            this.v3 = normalizeSeed(this.seed.current);

            this.step -= 1;
        }

        // get the next 'noise' value

        switch (this.interpolation)
        {
            case INTER_STEP:
            {
                next = this.v1;
                break;
            }
            case INTER_LINEAR:
            {
                next = this.v1 + this.step * (this.v2 - this.v1);
                break;
            }
            case INTER_COSINE:
            {
                const ft = this.step * Math.PI;
                const f  = (1 - Math.cos(ft)) * 0.5;
                
                next = this.v1 + f * (this.v2 - this.v1);
                break;
            }
            case INTER_CUBIC:
            {
                const p = (this.v3 - this.v2) - (this.v0 - this.v1);
                const q = (this.v0 - this.v1) - p;
                const r =  this.v2 - this.v0;
                const s =  this.v1;

                const val = 
                      p * cube(this.step) 
                    + q * sqr(this.step) 
                    + r * this.step 
                    + s;

                next = this.clip 
                    ? Math.max(0, Math.min(val, 1)) 
                    : val;

                break;
            }
        }

        this.step += 1 / scale;

        return next;
    }

   
    reset()
    {
        this.seed.reset();

        this.v0 = normalizeSeed(this.seed.current); this.seed.rotate();
        this.v1 = normalizeSeed(this.seed.current); this.seed.rotate();
        this.v2 = normalizeSeed(this.seed.current); this.seed.rotate();
        this.v3 = normalizeSeed(this.seed.current); this.seed.rotate();

        this.step = 0;
    }
}


function normalizeSeed(x)
{
    return x / -0x7fffffff;
}


const settings =
{
    debugMode:                     false,
        
    enableZoomedOutParams:         false,
    minZoomForParams:              0.35,
    objectCenterSize:              18,
    objectBatchSize:               500,
    showPages:                     false,
    showAllColorSpaces:            false,
    showNodeIcons:                 true,
    showBoolValues:                true,
    separateThousands:             true,
    allowInvertParams:    true,
    activateDeactiatesOthers:      true,
    preferHtmlColorNames:          false,
    randomShiftR:                  true,
    colorShiftR:                   true,

    showSnapshots:                 false,
    showRestartInfo:               true,
    showColorLegendInMenus:        false,
    showClearUndoWarning:          true,
    shareUsageMetrics:             true,
    showObjectCount:               true,
    showDebugMenu:                 false,
        
    showNodeId:                    false, // instead of name
    showTransformPoints:           false,
    enableAsserts:                 false,

    showTooltipLongText:           false,
    showTooltipLists:              false,
    showTooltipColorInterpolation: true,
    showTooltipColorBlindness:     true,
    showTooltipColorContrast:      true,
    showTooltipColorNames:         true,
    showTooltipAscii:              true,

    enableBetaFeatures:            false,
            
    logThreadMessages:             false,
    logDataMessages:               false,
    logMessages:                   false,

    logActions:                    false, 
            
    logLoading:                    false, 
    logRequests:                   false, 
    logValueUpdates:               false, 
    logObjectUpdates:              false,
    logStyleUpdates:               false,
            
    logRawLoadPages:               false, 
    logRawLoadNodes:               false, 
    logRawLoadConnections:         false, 
        
    logRawSavePages:               false, 
    logRawSaveNodes:               false, 
    logRawSaveConnections:         false, 
        
    logRawRequests:                false, 
    logRawValues:                  false,

    sessionId:                     ''
};



function updateSetting(settingName, value)
{
    switch (settingName)
    {
        case 'debugMode':                     settings.debugMode                     = value;  break;
                
        case 'enableZoomedOutParams':         settings.enableZoomedOutParams         = value;  break;
        case 'minZoomForParams':              settings.minZoomForParams              = value;  break;
        case 'objectCenterSize':              settings.objectCenterSize              = value;  break;
        case 'objectBatchSize':               settings.objectBatchSize               = value;  break;
        case 'showPages':                     settings.showPages                     = value;  break;
        case 'showAllColorSpaces':            settings.showAllColorSpaces            = value;  break;
        case 'showNodeIcons':                 settings.showNodeIcons                 = value;  break;
        case 'showBoolValues':                settings.showBoolValues                = value;  break;
        case 'separateThousands':             settings.separateThousands             = value;  break;
        case 'allowInvertParams':             settings.allowInvertParams             = value;  break;
        case 'activateDeactiatesOthers':      settings.activateDeactiatesOthers      = value;  break;
        case 'preferHtmlColorNames':          settings.preferHtmlColorNames          = value;  break;
        case 'randomShiftR':                  settings.randomShiftR                  = value;  break;
        case 'colorShiftR':                   settings.colorShiftR                   = value;  break;
        
        case 'showSnapshots':                 settings.showSnapshots                 = value;  break;
        case 'showRestartInfo':               settings.showRestartInfo               = value;  break;
        case 'showColorLegendInMenus':        settings.showColorLegendInMenus        = value;  break;
        case 'showClearUndoWarning':          settings.showClearUndoWarning          = value;  break;
        case 'shareUsageMetrics':             settings.shareUsageMetrics             = value;  break;
        case 'showObjectCount':               settings.showObjectCount               = value;  break;
        case 'showDebugMenu':                 settings.showDebugMenu                 = value;  break;
                        
        case 'showNodeId':                    settings.showNodeId                    = value;  break;
        case 'showTransformPoints':           settings.showTransformPoints           = value;  break;
        case 'enableAsserts':                 settings.enableAsserts                 = value;  break;

        case 'showTooltipLists':              settings.showTooltipLists              = value;  break;
        case 'showTooltipLongText':           settings.showTooltipLongText           = value;  break;
        case 'showTooltipColorInterpolation': settings.showTooltipColorInterpolation = value;  break;
        case 'showTooltipColorBlindness':     settings.showTooltipColorBlindness     = value;  break;
        case 'showTooltipColorContrast':      settings.showTooltipColorContrast      = value;  break;
        case 'showTooltipColorNames':         settings.showTooltipColorNames         = value;  break;
        case 'showTooltipAscii':              settings.showTooltipAscii              = value;  break;

        case 'enableBetaFeatures':            settings.enableBetaFeatures            = value;  break;
                   
        case 'logThreadMessages':             settings.logThreadMessages             = value;  break;
        case 'logDataMessages':               settings.logDataMessages               = value;  break;
        case 'logMessages':                   settings.logMessages                   = value;  break;

        case 'logActions':                    settings.logActions                    = value;  break;
        case 'logLoading':                    settings.logLoading                    = value;  break;
        case 'logRequests':                   settings.logRequests                   = value;  break;
        case 'logValueUpdates':               settings.logValueUpdates               = value;  break;
        case 'logObjectUpdates':              settings.logObjectUpdates              = value;  break;
        case 'logStyleUpdates':               settings.logStyleUpdates               = value;  break;
                   
        case 'logRawLoadPages':               settings.logRawLoadPages               = value;  break;
        case 'logRawLoadNodes':               settings.logRawLoadNodes               = value;  break;
        case 'logRawLoadConnections':         settings.logRawLoadConnections         = value;  break;
                
        case 'logRawSavePages':               settings.logRawSavePages               = value;  break;
        case 'logRawSaveNodes':               settings.logRawSaveNodes               = value;  break;
        case 'logRawSaveConnections':         settings.logRawSaveConnections         = value;  break;
                
        case 'logRawRequests':                settings.logRawRequests                = value;  break;
        case 'logRawValues':                  settings.logRawValues                  = value;  break;

        case 'sessionId':                     settings.sessionId                     = value;  break;
    } 


    switch (settingName)
    {
        case 'objectCenterSize':
            uiPostMessageToFigma(
            {
                cmd:             'figUpdateObjectCenterSize',
                objectCenterSize: settings.objectCenterSize
            });
            break;
    }
}



function updateSettingAndMenu(settingName, valid, value, save = true)
{
    switch (settingName)
    {
        case 'debugMode':                     updateSettingAndMenu_(valid, settingName, value, menuItemDebugMode                    ); break;
              
        case 'enableZoomedOutParams':         updateSettingAndMenu_(valid, settingName, value, menuItemEnableZoomedOutParams        ); break;
        case 'showPages':                     updateSettingAndMenu_(valid, settingName, value, menuItemShowPages                    ); break;
        case 'showAllColorSpaces':            updateSettingAndMenu_(valid, settingName, value, menuItemShowAllColorSpaces           ); break;
        case 'showNodeIcons':                 updateSettingAndMenu_(valid, settingName, value, menuItemShowNodeIcons                ); break;
        case 'showBoolValues':                updateSettingAndMenu_(valid, settingName, value, menuItemShowBoolValues               ); break;
        case 'separateThousands':             updateSettingAndMenu_(valid, settingName, value, menuItemSeparateThousands            ); break;
        case 'allowInvertParams':             updateSettingAndMenu_(valid, settingName, value, menuItemAllowInvertParams            ); break;
        case 'activateDeactiatesOthers':      updateSettingAndMenu_(valid, settingName, value, menuItemActivateDeactiatesOthers     ); break;
        case 'preferHtmlColorNames':          updateSettingAndMenu_(valid, settingName, value, menuItemPreferHtmlColorNames         ); break;
        case 'randomShiftR':                  updateSettingAndMenu_(valid, settingName, value, menuItemRandomShiftR                 ); break;
        case 'colorShiftR':                   updateSettingAndMenu_(valid, settingName, value, menuItemColorShiftR                  ); break;

        case 'showSnapshots':                 updateSettingAndMenu_(valid, settingName, value, menuItemShowSnapshots                ); break;
        case 'showRestartInfo':               updateSettingAndMenu_(valid, settingName, value, menuItemShowRestartInfo              ); break;
        case 'showColorLegendInMenus':        updateSettingAndMenu_(valid, settingName, value, menuItemShowColorLegendInMenus       ); break;
        case 'showClearUndoWarning':          updateSettingAndMenu_(valid, settingName, value, menuItemShowClearUndoWarning         ); break;
        case 'shareUsageMetrics':             updateSettingAndMenu_(valid, settingName, value, menuItemShareUsageMetrics            ); break;
        case 'showObjectCount':               updateSettingAndMenu_(valid, settingName, value, menuItemShowObjectCount              ); break;
        case 'showDebugMenu':                 updateSettingAndMenu_(valid, settingName, value, menuItemShowDebugMenu                ); break;
                      
        case 'showNodeId':                    updateSettingAndMenu_(valid, settingName, value, menuItemShowNodeId                   ); break;
        case 'showTransformPoints':           updateSettingAndMenu_(valid, settingName, value, menuItemShowTransformPoints          ); break;
        case 'enableAsserts':                 updateSettingAndMenu_(valid, settingName, value, menuItemEnableAsserts                ); enableAsserts = value; break;
        
        case 'showTooltipLists':              updateSettingAndMenu_(valid, settingName, value, menuItemShowTooltipLists             ); break;
        case 'showTooltipLongText':           updateSettingAndMenu_(valid, settingName, value, menuItemShowTooltipLongText          ); break;
        case 'showTooltipColorInterpolation': updateSettingAndMenu_(valid, settingName, value, menuItemShowTooltipColorInterpolation); break;
        case 'showTooltipColorBlindness':     updateSettingAndMenu_(valid, settingName, value, menuItemShowTooltipColorBlindness    ); break;
        case 'showTooltipColorContrast':      updateSettingAndMenu_(valid, settingName, value, menuItemShowTooltipColorContrast     ); break;
        case 'showTooltipColorNames':         updateSettingAndMenu_(valid, settingName, value, menuItemShowTooltipColorNames        ); break;
        case 'showTooltipAscii':              updateSettingAndMenu_(valid, settingName, value, menuItemShowTooltipColorBlindness    ); break;

        case 'enableBetaFeatures':            updateSettingAndMenu_(valid, settingName, value, menuItemEnableBetaFeatures           ); break;
                      
        case 'logThreadMessages':             updateSettingAndMenu_(valid, settingName, value, menuItemLogThreadMessages            ); break;
        case 'logDataMessages':               updateSettingAndMenu_(valid, settingName, value, menuItemLogDataMessages              ); break;
        case 'logMessages':                   updateSettingAndMenu_(valid, settingName, value, menuItemLogMessages                  ); break;

        case 'logActions':                    updateSettingAndMenu_(valid, settingName, value, menuItemLogActions                   ); break;
        case 'logLoading':                    updateSettingAndMenu_(valid, settingName, value, menuItemLogLoading                   ); break;
        case 'logRequests':                   updateSettingAndMenu_(valid, settingName, value, menuItemLogRequests                  ); break;
        case 'logValueUpdates':               updateSettingAndMenu_(valid, settingName, value, menuItemLogValueUpdates              ); break;
        case 'logObjectUpdates':              updateSettingAndMenu_(valid, settingName, value, menuItemLogObjectUpdates             ); break;
        case 'logStyleUpdates':               updateSettingAndMenu_(valid, settingName, value, menuItemLogStyleUpdates              ); break;
                      
        case 'logRawLoadPages':               updateSettingAndMenu_(valid, settingName, value, menuItemLogRawLoadPages              ); break;
        case 'logRawLoadNodes':               updateSettingAndMenu_(valid, settingName, value, menuItemLogRawLoadNodes              ); break;
        case 'logRawLoadConnections':         updateSettingAndMenu_(valid, settingName, value, menuItemLogRawLoadConnections        ); break;
                      
        case 'logRawSavePages':               updateSettingAndMenu_(valid, settingName, value, menuItemLogRawSavePages              ); break;
        case 'logRawSaveNodes':               updateSettingAndMenu_(valid, settingName, value, menuItemLogRawSaveNodes              ); break;
        case 'logRawSaveConnections':         updateSettingAndMenu_(valid, settingName, value, menuItemLogRawSaveConnections        ); break;
                      
        case 'logRawRequests':                updateSettingAndMenu_(valid, settingName, value, menuItemLogRawRequests               ); break;
        case 'logRawValues':                  updateSettingAndMenu_(valid, settingName, value, menuItemLogRawValues                 ); break;
    } 


    if (save)
        //&& settingName != 'showAllColorSpaces')
        uiSetLocalData(settingName, boolToString(value));
}



function updateSettingAndMenu_(valid, setting, value, menu)
{
    if (valid) 
        settings[setting] = value;  


    switch (setting)
    {
        case 'showNodeId':
            uiPostMessageToFigma(
            {
                cmd:    'figUpdateShowIds',
                showIds: settings.showNodeId
            });
            break;
    }


    if (menu)
        menu.setChecked(settings[setting]);
}



function updateSettingsMenus()
{
    menuItemDebugMode                    .setVisible(settings.debugMode                    );
                
    menuItemEnableZoomedOutParams        .setChecked(settings.enableZoomedOutParams        );
    menuItemShowPages                    .setChecked(settings.showPages                    );
    menuItemShowAllColorSpaces           .setChecked(settings.showAllColorSpaces           );
    menuItemShowNodeIcons                .setChecked(settings.showNodeIcons                );
    menuItemShowBoolValues               .setChecked(settings.showBoolValues               );
    menuItemSeparateThousands            .setChecked(settings.separateThousands            );
    menuItemAllowInvertParams            .setChecked(settings.allowInvertParams            );
    menuItemActivateDeactiatesOthers     .setChecked(settings.activateDeactiatesOthers     );
    menuItemPreferHtmlColorNames         .setChecked(settings.preferHtmlColorNames         );
    menuItemRandomShiftR                 .setChecked(settings.randomShiftR                 );
    menuItemColorShiftR                  .setChecked(settings. colorShiftR                 );

    menuItemShowSnapshots                .setChecked(settings.showSnapshots                );
    menuItemShowRestartInfo              .setChecked(settings.showRestartInfo              );
    menuItemShowColorLegendInMenus       .setChecked(settings.showColorLegendInMenus       );
    menuItemShowClearUndoWarning         .setChecked(settings.showClearUndoWarning         );
    menuItemShareUsageMetrics            .setChecked(settings.shareUsageMetrics            );
    menuItemShowObjectCount              .setChecked(settings.showObjectCount              );
    menuItemShowDebugMenu                .setChecked(settings.showDebugMenu                );
                
    menuItemShowNodeId                   .setChecked(settings.showNodeId                   );
    menuItemShowTransformPoints          .setChecked(settings.showTransformPoints          );
    menuItemEnableAsserts                .setChecked(settings.enableAsserts                );

    menuItemShowTooltipLists             .setChecked(settings.showTooltipLists             );
    menuItemShowTooltipLongText          .setChecked(settings.showTooltipLongText          );
    menuItemShowTooltipColorInterpolation.setChecked(settings.showTooltipColorInterpolation);
    menuItemShowTooltipColorBlindness    .setChecked(settings.showTooltipColorBlindness    );
    menuItemShowTooltipColorContrast     .setChecked(settings.showTooltipColorContrast     );
    menuItemShowTooltipColorNames        .setChecked(settings.showTooltipColorNames        );
    menuItemShowTooltipAscii             .setChecked(settings.showTooltipAscii             );

  //menuItemEnableBetaFeatures           .setChecked(settings.enableBetaFeatures           );
                  
    menuItemLogThreadMessages            .setChecked(settings.logThreadMessages            );
    menuItemLogDataMessages              .setChecked(settings.logDataMessages              );
    menuItemLogMessages                  .setChecked(settings.logMessages                  );

    menuItemLogActions                   .setChecked(settings.logActions                   );
                  
    menuItemLogLoading                   .setChecked(settings.logLoading                   );
    menuItemLogRequests                  .setChecked(settings.logRequests                  );
    menuItemLogValueUpdates              .setChecked(settings.logValueUpdates              );
    menuItemLogObjectUpdates             .setChecked(settings.logObjectUpdates             );
    menuItemLogStyleUpdates              .setChecked(settings.logStyleUpdates              );
                  
    menuItemLogRawLoadNodes              .setChecked(settings.logRawLoadPages              );
    menuItemLogRawLoadNodes              .setChecked(settings.logRawLoadNodes              );
    menuItemLogRawLoadConnections        .setChecked(settings.logRawLoadConnections        );
                    
    menuItemLogRawSavePages              .setChecked(settings.logRawSaveNodes              );
    menuItemLogRawSaveNodes              .setChecked(settings.logRawSaveNodes              );
    menuItemLogRawSaveConnections        .setChecked(settings.logRawSaveConnections        );
                
    menuItemLogRawRequests               .setChecked(settings.logRawRequests               );
    menuItemLogRawValues                 .setChecked(settings.logRawValues                 );
}



function updateMenuItemShowPages()
{
    uiSetPageData('showPages', boolToString(settings.showPages));
    graph.updatePages();
    graphView.update();
}



function updateMenuItemShowSnapshots()
{
    uiSetPageData('showSnapshots', boolToString(settings.showSnapshots));

    snapshotBar.style.display = settings.showSnapshots ? 'block' : 'none';
    //graphView.updateScrollWithBounds();
}



function updateMenuItemShowAllColorSpaces()
{
    uiSetPageData('showAllColorSpaces', boolToString(settings.showAllColorSpaces));

    graph.nodes
        .filter(n => COLOR_TYPES.includes(n.type))
        .forEach(n => n.updateNode());
}



function updateMenuItemShowNodeIcons()
{
    graph.nodes.forEach(n => n.updateNode());
}



function updateMenuItemShowBoolValues()
{
    graph.nodes
        .filter(n => n.params.find(p => p.type == NUMBER_VALUE) != null)
        .forEach(n => n.updateNode());
}



function updateMenuItemSeparateThousands()
{
    graph.nodes
        .filter(n => n.params.find(p => p.type == NUMBER_VALUE) != null)
        .forEach(n => n.updateNode());
}



function updateMenuItemAllowInvertParams()
{
    graph.nodes
        .filter(n => n.type == NUMBER_SIMPLE_MATH)
        .forEach(n => n.updateNode());
}



function updateMenuItemShowColorLegendInMenus()
{
    for (const menu of menuBarMenus)
        menu.items.forEach(i => i.updateLegend());
}



function enableFeatures(sub)
{
    enableMenuItem(menuItemUpgrade,            true, sub, false, !sub);
    enableMenuItem(menuItemSetValueNames,      true, sub);
    enableMenuItem(menuItemEnableBetaFeatures, true, sub);
    enableMenuItem(menuItemCopyLLMPrompt,      true, sub, true, currentUserIsDev());
 // enableMenuItem(menuItemShowSnapshots,      true, sub);
    enableMenuItem(menuItemShowRestartInfo,    true, sub);
    enableMenuItem(menuItemValueName,          true, sub);
    enableMenuItem(menuItemObjectName,         true, sub);
    enableMenuItem(menuItemVarGroup,           true, sub, true);
    enableMenuItem(menuItemTimer,              true, sub);
    enableMenuItem(menuItemAnimate,            true, sub, true);
    enableMenuItem(menuItemSaveToFile,         true, sub);
    enableMenuItem(menuItemSaveSelected,       true, sub);
    enableMenuItem(menuItemFetch,              true, sub);
    enableMenuItem(menuItemDateTime,           true, sub);
    enableMenuItem(menuItemSolve,              true, sub, true);
    enableMenuItem(menuItemParseJson,          true, sub);
    enableMenuItem(menuItemCorrectColor,       true, sub);
    enableMenuItem(menuItemConvertToP3,        true, sub);
    enableMenuItem(menuItemPersist,            true, sub);
    enableMenuItem(menuItemVectorNetworks,     true, sub, true);
    enableMenuItem(menuItemVectorVertex,       true, sub, true);
    enableMenuItem(menuItemVectorEdge,         true, sub, true);
    enableMenuItem(menuItemVectorRegion,       true, sub, true);
    enableMenuItem(menuItemVectorNetwork,      true, sub, true);
    enableMenuItem(menuItemBooleanShape,       true, sub, true);
    enableMenuItem(menuItemSaveTemplate,       true, sub);
    enableMenuItem(menuItemManageTemplates,    true, sub);


    updatePanelButton();


    graph.nodes.forEach(n => n.updateSubscribeStatus(sub));
}



function updatePanelButton()
{
    if (btnPanel     ) btnPanel     .div.style.display = !(settings.enableBetaFeatures && subscribed()) ? 'inline-block' : 'none';
    if (btnDecoration) btnDecoration.div.style.display =  (settings.enableBetaFeatures && subscribed()) ? 'inline-block' : 'none';
}



function enableMenuItem(menuItem, enable, sub, beta = false, show = true)
{
    if (!menuItem) return;

    menuItem.enabled = enable;
    menuItem.sub     = sub;

    menuItem.setVisible(
           show 
        && (
              !beta
            || beta && sub && settings.enableBetaFeatures));

    menuItem.update();
}



function updateMenuItemShowDebugMenu()
{
    updateElementDisplay(menuDebug.div, settings.showDebugMenu);

    menuMain.update(
        boundingRect(menuMain.div).x + 6,
        boundingRect(menuMain.div).y - 4,
        true);
}

 

function updateElementDisplay(menuItem, enable)
{
    menuItem.style.display = enable ? 'block' : 'none';
}



function loadLocalSettings()
{
    uiGetLocalData('debugMode'                    );
        
    uiGetLocalData('enableZoomedOutParams'        );
    uiGetLocalData('minZoomForParams'             );
    uiGetLocalData('objectCenterSize'             );
    uiGetLocalData('objectBatchSize'              );
    uiGetLocalData('showAllColorSpaces'           );
    uiGetLocalData('showNodeIcons'                );
    uiGetLocalData('showBoolValues'               );
    uiGetLocalData('separateThousands'            );
    uiGetLocalData('allowInvertParams'   );
    uiGetLocalData('activateDeactiatesOthers'     );
    uiGetLocalData('preferHtmlColorNames'         );
    uiGetLocalData('randomShiftR'                 );
    uiGetLocalData('colorShiftR'                  );

    uiGetLocalData('showSnapshots'                );
    uiGetLocalData('showRestartInfo'              );
    uiGetLocalData('showColorLegendInMenus'       );
    uiGetLocalData('showPages'                    );
    uiGetLocalData('showClearUndoWarning'         );
    uiGetLocalData('shareUsageMetrics'            );
    uiGetLocalData('showObjectCount'              );
    uiGetLocalData('showDebugMenu'                );
        
    uiGetLocalData('showNodeId'                   );
    uiGetLocalData('showTransformPoints'          );
    uiGetLocalData('enableAsserts'                );

    uiGetLocalData('showTooltipLists'             );
    uiGetLocalData('showTooltipLongText'          );
    uiGetLocalData('showTooltipColorInterpolation');
    uiGetLocalData('showTooltipColorBlindness'    );
    uiGetLocalData('showTooltipColorContrast'     );
    uiGetLocalData('showTooltipColorNames'        );
    uiGetLocalData('showTooltipAscii'             );

    uiGetLocalData('enableBetaFeatures'           );
            
    uiGetLocalData('logThreadMessages'            );
    uiGetLocalData('logDataMessages'              );
    uiGetLocalData('logMessages'                  );

    uiGetLocalData('logActions'                   );
            
    uiGetLocalData('logLoading'                   );
    uiGetLocalData('logRequests'                  );
    uiGetLocalData('logValueUpdates'              );
    uiGetLocalData('logObjectUpdates'             );
    uiGetLocalData('logStyleUpdates'              );
            
    uiGetLocalData('logRawLoadPages'              );
    uiGetLocalData('logRawLoadNodes'              );
    uiGetLocalData('logRawLoadConnections'        );
        
    uiGetLocalData('logRawSavePages'              );
    uiGetLocalData('logRawSaveNodes'              );
    uiGetLocalData('logRawSaveConnections'        );
        
    uiGetLocalData('logRawRequests'               );
    uiGetLocalData('logRawValues'                 );
}


const LIST_VALUE           = 'LIST#';

const NUMBER_LIST_VALUE    = 'NLIST#';
const   TEXT_LIST_VALUE    = 'TLIST#';
const  SHAPE_LIST_VALUE    = 'SLIST#';


const NULL_NODE            = 'NULL';
const VARIABLE_GROUP       = 'VARGRP';
const FEEDBACK             = 'FEEDBK';
const REPEAT               = 'REPT';
const CACHE                = 'CACHE';
const FREEZE               = 'FRZ';
const TIMER                = 'TIMER';
const GET_VALUE_NAME       = 'GVNAME';
const SET_VALUE_NAME       = 'SVNAME';
const GET_LIST_VALUE_NAMES = 'GVNAMES';
const SET_LIST_VALUE_NAMES = 'SVNAMES';
const SET_OBJECT_NAME      = 'SONAME';


const VARIABLE             = 'VAR';
const VARIABLE_VALUE       = 'VAR#';
const VARIABLE_TYPES       = [VARIABLE_VALUE, VARIABLE];


const COMBINE              = 'CMB';
const LIST_AS_ITEM         = 'LSASIT';
const EXTRACT              = 'EXTR';
const SET_PARAM            = 'SETP';
const GET_PARAM            = 'GETP';
const SUBLIST              = 'SUBLST';
const UNIQUE               = 'UNIQ';
const REORDER_LIST         = 'RORD';
const SHIFT_LIST           = 'SHFTLST';
const REVERSE_LIST         = 'REVLST';
const BUCKLE_LIST          = 'BUKLST';
const SORT                 = 'SORT';
const COLUMN               = 'CLMN';
const CELL                 = 'CELL';
const LIST                 = 'LIST';
const LIST_COUNT           = 'COUNT';
const OBJECT_COUNT         = 'OBJCOUNT';
const LIST_CONTAINS        = 'LCONT';
const LIST_FIND            = 'LFIND';
const SELECT               = 'SELECT';
const SELECT_FROM_LIST     = 'LSTSEL';
const IF_ELSE              = 'IF';
const FILTER               = 'LSTFLT';


const ANY_VALUE            = 'ANY#';


const LIST_TYPES =
[
    LIST_VALUE,
    NUMBER_LIST_VALUE,
    TEXT_LIST_VALUE,
    SHAPE_LIST_VALUE,
    COMBINE,
    EXTRACT,
    SET_PARAM,
    GET_PARAM,
    SUBLIST,
    LIST,
    LIST_COUNT,
    LIST_CONTAINS,
    LIST_FIND,
    REPEAT
];


const LIST_VALUES =
[
           LIST_VALUE,
    NUMBER_LIST_VALUE,
      TEXT_LIST_VALUE,
     SHAPE_LIST_VALUE
];


const ITERATE                 = 'ITER';  
const PROBABILITY             = 'PROB';  
const HOLD                    = 'HOLD';


const BOOLEAN_NUMBER          = 'BOOL';

const NUMBER_VALUE            = 'NUM#';  
const NUMBER                  = 'NUM';   
const NUMBER_PRECISION        = 'NPREC';   
const NUMBER_SIGN             = 'NSIGN';   
const NUMBER_ABSOLUTE         = 'ABS';   
const NUMBER_NEGATIVE         = 'NEG';   
const NUMBER_ROUND            = 'ROUND';   
const NUMBER_QUANTIZE         = 'QUANT';   
const NUMBER_SIMPLE_MINMAX    = 'SMINMAX';   
const NUMBER_MINMAX           = 'MINMAX';   
const NUMBER_LIMITS           = 'LIM';   
const NUMBER_CURVE            = 'NCURVE';   
const NUMBER_MAP              = 'NMAP';   
const NUMBER_BIAS             = 'NBIAS';   
const NUMBER_NAN              = 'NANISNUM';
const NUMBER_CONSTANT         = 'CONST';  
const NUMBER_DATETIME         = 'DATE';  
const NUMBER_SEQUENCE         = 'SEQ';  
const NUMBER_RANGE            = 'RANGE';  
const NUMBER_WAVE             = 'WAVE';  
const NUMBER_RANDOM           = 'RAND';  
const NUMBER_NOISE            = 'NOISE';  
const NUMBER_ACCUMULATE       = 'ACCUM';  
const NUMBER_INTERPOLATE      = 'LERP'; 
const NUMBER_SOLVE            = 'SOLVE';
const NUMBER_ANIMATE          = 'NANIM';

const NUMBER_SIMPLE_MATH      = 'SMATH';  
const NUMBER_MATH             = 'MATH';  
const NUMBER_ADD              = 'ADD';   
const NUMBER_SUBTRACT         = 'SUB';   
const NUMBER_MULTIPLY         = 'MUL';   
const NUMBER_DIVIDE           = 'DIV';   
const NUMBER_MODULO           = 'MOD';   
const NUMBER_EXPONENT         = 'EXP';

const NUMBER_BOOLEAN          = 'NBOOL';  
const NUMBER_NOT              = 'NOT';
const NUMBER_AND              = 'AND';
const NUMBER_OR               = 'OR';
const NUMBER_XOR              = 'XOR';

const NUMBER_CONDITION        = 'COND';
const NUMBER_EQUAL            = 'EQ';
const NUMBER_NOT_EQUAL        = 'NE';
const NUMBER_LESS             = 'LT';
const NUMBER_LESS_OR_EQUAL    = 'LE';
const NUMBER_GREATER          = 'GT';
const NUMBER_GREATER_OR_EQUAL = 'GE';

const NUMBER_TRIG             = 'TRIG';  
const NUMBER_SIN              = 'SIN';   
const NUMBER_COS              = 'COS';   
const NUMBER_TAN              = 'TAN';
const NUMBER_ATAN2            = 'ATAN2';

const CONVERT_ANGLE           = 'CNVANG';


const TEXT_VALUE              = 'TEXT#';
const TEXT                    = 'TEXT';
const TEXT_LENGTH             = 'TLEN';
const TEXT_TRIM               = 'TTRIM';
const TEXT_SUBSTRING          = 'TSUB';
const TEXT_CONTAINS           = 'TCONT';
const TEXT_FIND               = 'TFIND';
const TEXT_CASE               = 'TCASE';
const TEXT_REPLACE            = 'TREPL';
const TEXT_ADD                = 'TADD';
const TEXT_JOIN               = 'TJOIN';
const TEXT_PAD                = 'TPAD';
const TEXT_COMPARE            = 'TCMP';
const TEXT_CHAR               = 'TCHAR';
const TEXT_UNICODE            = 'TUNI';
const INDEX_TO_NAME           = 'INDEX';
const NUMBER_TO_TEXT          = 'N2T';
const COLOR_TO_TEXT           = 'C2T';
const TEXT_TO_NUMBER          = 'T2N';
const TEXT_TO_COLOR           = 'T2C';
const TEXT_SPLIT              = 'TSPLT';
const PARSE_JSON              = 'TJSON';
const PARSE_CSV               = 'TCSV';
const TEXT_FETCH              = 'FETCH';
const TEXT_FILE               = 'TFILE';


const FLOW_TYPES =
[
    NULL_NODE,
    VARIABLE,
    VARIABLE_GROUP,
    ...LIST_TYPES,
    LIST_AS_ITEM,
    EXTRACT,
    SET_PARAM,
    GET_PARAM,
    SUBLIST,
    UNIQUE,
    REORDER_LIST,
    SHIFT_LIST,
    REVERSE_LIST,
    BUCKLE_LIST,
    COLUMN,
    SORT,
    CELL,
    LIST,
    SELECT,
    SELECT_FROM_LIST,
    IF_ELSE,
    FILTER,
    FEEDBACK,
    REPEAT,
    //FOREACH,
    ITERATE,
    PROBABILITY,
    HOLD,
    CACHE,
    FREEZE,
    PARSE_JSON,
    PARSE_CSV,
    TIMER,
    GET_VALUE_NAME,
    SET_VALUE_NAME,
    GET_LIST_VALUE_NAMES,
    SET_LIST_VALUE_NAMES,
    SET_OBJECT_NAME
];


const MATH_TYPES =
[
    NUMBER_MATH,
    NUMBER_SIMPLE_MATH,
    NUMBER_ADD,
    NUMBER_SUBTRACT,
    NUMBER_MULTIPLY,
    NUMBER_DIVIDE,
    NUMBER_MODULO,
    NUMBER_EXPONENT
];


const NUMBER_BOOLEAN_TYPES =
[
    NUMBER_BOOLEAN,
    NUMBER_NOT,
    NUMBER_AND,
    NUMBER_OR,
    NUMBER_XOR
];


const CONDITION_TYPES =
[
    NUMBER_CONDITION,
    NUMBER_EQUAL,
    NUMBER_NOT_EQUAL,
    NUMBER_LESS,
    NUMBER_LESS_OR_EQUAL,
    NUMBER_GREATER,
    NUMBER_GREATER_OR_EQUAL
];


const TRIG_TYPES =
[
    NUMBER_TRIG,
    NUMBER_SIN,
    NUMBER_COS,
    NUMBER_TAN,
    NUMBER_ATAN2
];


const NUMBER_TYPES =
[
    NUMBER_VALUE,
    NUMBER_LIST_VALUE,
    NUMBER,
    BOOLEAN_NUMBER,
    NUMBER_PRECISION,
    NUMBER_SIGN,
    NUMBER_ABSOLUTE,
    NUMBER_NEGATIVE,
    NUMBER_ROUND,
    NUMBER_QUANTIZE,
    NUMBER_SIMPLE_MINMAX,
    NUMBER_MINMAX,
    NUMBER_LIMITS,
    NUMBER_CURVE,
    NUMBER_MAP,
    NUMBER_BIAS,
    NUMBER_NAN,
    NUMBER_CONSTANT,
    NUMBER_DATETIME,
    NUMBER_SEQUENCE,
    NUMBER_RANGE,
    NUMBER_WAVE,
    NUMBER_RANDOM,
    NUMBER_NOISE,
    NUMBER_ACCUMULATE,
    NUMBER_INTERPOLATE,
    NUMBER_SOLVE,
    NUMBER_ANIMATE,
    NUMBER_TO_TEXT,
    TEXT_CHAR,

    ...MATH_TYPES,
    ...NUMBER_BOOLEAN_TYPES,
    ...CONDITION_TYPES,
    ...TRIG_TYPES,

    CONVERT_ANGLE,
    BUCKLE_LIST
];


const TEXT_TYPES =
[
    TEXT_VALUE,
    TEXT_LIST_VALUE,
    TEXT,
    TEXT_LENGTH,
    TEXT_TRIM,
    TEXT_SUBSTRING,
    TEXT_CONTAINS,
    TEXT_FIND,
    TEXT_CASE,
    TEXT_ADD,
    TEXT_JOIN,
    TEXT_PAD,
    TEXT_REPLACE,
    TEXT_COMPARE,
    TEXT_UNICODE,
    INDEX_TO_NAME,
    TEXT_TO_NUMBER,
    TEXT_TO_COLOR,
    TEXT_SPLIT,
    TEXT_FETCH,
    TEXT_FILE
];


const COLOR_VALUE        = 'COL#';  
const COLOR              = 'COL';   
const VALID_COLOR        = 'CVAL';  
const CORRECT_COLOR      = 'CCOR';  
const COLOR_CONVERT_P3   = 'COLP3';
const COLOR_CONTRAST     = 'CCNT';  
const COLORBLIND         = 'BLND';  
const COLOR_SCHEME      = 'CPAL'; 
const COLOR_INTERPOLATE  = 'CLERP'; 
const COLOR_BLEND        = 'CBLND';


const COLOR_TYPES =
[
    COLOR_VALUE,
    COLOR,
    VALID_COLOR,
    CORRECT_COLOR,
    COLOR_CONVERT_P3,
    COLORBLIND,
    COLOR_SCHEME,
    COLOR_INTERPOLATE,
    COLOR_BLEND,
    COLOR_TO_TEXT
];


const FILL_VALUE          = 'FILL#';
const FILL                = 'FILL';
const FILL_TYPES          = [FILL_VALUE, FILL];
  
const STROKE_VALUE        = 'STRK#';
const STROKE              = 'STRK';
const STROKE_TYPES        = [STROKE_VALUE, STROKE];
  
const STROKE_SIDES_VALUE  = 'STRKSD#';
const STROKE_SIDES        = 'STRKSD';
const STROKE_SIDES_TYPES  = [STROKE_SIDES_VALUE, STROKE_SIDES];

const COLOR_STOP_VALUE    = 'CSTOP#';
const COLOR_STOP          = 'CSTOP';
const COLOR_STOP_TYPES    = [COLOR_STOP_VALUE, COLOR_STOP];
  
const GRADIENT_VALUE      = 'GRAD#';
const GRADIENT            = 'GRAD';
const GRADIENT_TYPES      = [GRADIENT_VALUE, GRADIENT];
 

const ROUND_CORNERS_VALUE = 'RCRN#';
const ROUND_CORNERS       = 'RCRN';
const ROUND_CORNERS_TYPES = [ROUND_CORNERS_VALUE, ROUND_CORNERS];

const DROP_SHADOW_VALUE   = 'DRSH#';
const DROP_SHADOW         = 'DRSH';
const DROP_SHADOW_TYPES   = [DROP_SHADOW_VALUE, DROP_SHADOW];
 
const INNER_SHADOW_VALUE  = 'INSH#';
const INNER_SHADOW        = 'INSH';
const INNER_SHADOW_TYPES  = [INNER_SHADOW_VALUE, INNER_SHADOW];
 
const LAYER_BLUR_VALUE    = 'LBLR#';
const LAYER_BLUR          = 'LBLR';
const LAYER_BLUR_TYPES    = [LAYER_BLUR_VALUE, LAYER_BLUR];
 
const BACK_BLUR_VALUE     = 'BBLR#';
const BACK_BLUR           = 'BBLR';
const BACK_BLUR_TYPES     = [BACK_BLUR_VALUE, BACK_BLUR];
 
const LAYER_MASK_VALUE    = 'MASK#';
const LAYER_MASK          = 'MASK';
const LAYER_MASK_TYPES    = [LAYER_MASK_VALUE, LAYER_MASK];
 
const LAYER_BLEND_VALUE   = 'BLEND#';
const LAYER_BLEND         = 'BLEND';
const LAYER_BLEND_TYPES   = [LAYER_BLEND_VALUE, LAYER_BLEND];


const EFFECT_TYPES =
[
    ...STROKE_SIDES_TYPES,
    ...ROUND_CORNERS_TYPES,
    ...DROP_SHADOW_TYPES,
    ...INNER_SHADOW_TYPES,
    ...LAYER_BLUR_TYPES,
    ...BACK_BLUR_TYPES,
    ...LAYER_BLEND_TYPES,
    ...LAYER_MASK_TYPES
];


const STYLE_VALUES =
[
           COLOR_VALUE, 
            FILL_VALUE, 
        GRADIENT_VALUE, 
          STROKE_VALUE,
    STROKE_SIDES_VALUE,
     DROP_SHADOW_VALUE,
    INNER_SHADOW_VALUE,
      LAYER_BLUR_VALUE,
       BACK_BLUR_VALUE,
     LAYER_BLEND_VALUE,
      LAYER_MASK_VALUE
];


const COLOR_STYLE           = 'CSTL';
 
 
const SHAPE_VALUE           = 'SHP#'; // abstract placeholder
 
const RECTANGLE_VALUE       = 'RECT#';
const RECTANGLE             = 'RECT'; 
//const RECTANGLE_EXT         = 'RECTEXT'; 
const RECTANGLE_TYPES       = [RECTANGLE_VALUE, RECTANGLE];//, RECTANGLE_EXT];
 
const LINE_VALUE            = 'LINE#';
const LINE                  = 'LINE'; 
const LINE_TYPES            = [LINE_VALUE, LINE];
   
const ELLIPSE_VALUE         = 'ELPS#';
const ELLIPSE               = 'ELPS'; 
const ELLIPSE_TYPES         = [ELLIPSE_VALUE, ELLIPSE];
 
const TRAPEZE_VALUE         = 'TRPZ#';
const TRAPEZE               = 'TRPZ';
const TRAPEZE_TYPES         = [TRAPEZE_VALUE, TRAPEZE];
 
const POLYGON_VALUE         = 'POLY#';
const POLYGON               = 'POLY'; 
const POLYGON_TYPES         = [POLYGON_VALUE, POLYGON];
   
const STAR_VALUE            = 'STAR#';
const STAR                  = 'STAR'; 
const STAR_TYPES            = [STAR_VALUE, STAR];
   
const TEXT_SHAPE_VALUE      = 'TXTS#';
const TEXT_SHAPE            = 'TXTS'; 
const TEXT_SHAPE_TYPES      = [TEXT_SHAPE_VALUE, TEXT_SHAPE];
  
const POINT_VALUE           = 'PT#';
const POINT                 = 'PT';
const POINT_TYPES           = [POINT_VALUE, POINT];

const POINT_CORNER          = 'PCORN';

const VECTOR_PATH_VALUE     = 'VPATH#';
const VECTOR_PATH           = 'VPATH'; 
const VECTOR_PATH_TYPES     = [VECTOR_PATH_VALUE, VECTOR_PATH];
 
const VECTOR_VERTEX_VALUE   = 'VPT#';
const VECTOR_VERTEX         = 'VPT'; 
const VECTOR_VERTEX_TYPES   = [VECTOR_VERTEX_VALUE, VECTOR_VERTEX];

const VECTOR_EDGE_VALUE     = 'VEDGE#';
const VECTOR_EDGE           = 'VEDGE'; 
const VECTOR_EDGE_TYPES     = [VECTOR_EDGE_VALUE, VECTOR_EDGE];

const VECTOR_REGION_VALUE   = 'VREG#';
const VECTOR_REGION         = 'VREG'; 
const VECTOR_REGION_TYPES   = [VECTOR_REGION_VALUE, VECTOR_REGION];

const VECTOR_NETWORK_VALUE  = 'VNET#';
const VECTOR_NETWORK        = 'VNET'; 
const VECTOR_NETWORK_TYPES  = [VECTOR_NETWORK_VALUE, VECTOR_NETWORK];

const SHAPE_GROUP_VALUE     = 'SGRP#';
const SHAPE_GROUP           = 'SGRP';
const SHAPE_GROUP_TYPES     = [SHAPE_GROUP_VALUE, SHAPE_GROUP];

const FRAME_VALUE           = 'FRM#';
const FRAME                 = 'FRM';
const FRAME_TYPES           = [FRAME_VALUE, FRAME];
 
const ARC_PATH_VALUE        = 'ARC#';
const ARC_PATH              = 'ARC';
const ARC_PATH_TYPES        = [ARC_PATH_VALUE, ARC_PATH];

const WAVE_PATH_VALUE       = 'WAVEP#';
const WAVE_PATH             = 'WAVEP';
const WAVE_PATH_TYPES       = [WAVE_PATH_VALUE, WAVE_PATH];

const MOVE                  = 'MOVE';
const ROTATE                = 'ROT';
const SCALE                 = 'SCALE';
const SKEW                  = 'SKEW';

const SHOW_CENTER           = 'SHOWCNTR';
const SET_CENTER            = 'SCENTR';
const RESET_XFORM           = 'RSTX';

const PLACE                 = 'PLACE';
const SHAPE_APPLY           = 'APPLY';
  
const PATH_LENGTH           = 'PTHLEN';
const JOIN_PATHS            = 'JOINPTH';
const REORIENT_PATHS        = 'REORPTH';
const POINT_ALONG_PATH      = 'PTALPATH';
const CLOSEST_POINT_ON_PATH = 'CPTONPATH';
const MEASURE_VECTOR        = 'MESPT';
const POINT_ANGLE           = 'PTANGLE';
const VECTOR                = 'VECLEN';
const CIRCLE_CENTER         = 'CIRCEN';
const ARC_FROM_POINTS       = 'ARCPT';
const INTERSECT_LINES       = 'INTLIN';
const INTERPOLATE_POINT     = 'PTLERP';
const REVERSE_PATH          = 'REVPTH';
const BLEND_PATH            = 'BLENDPTH';


const PATH_TYPES =
[
    VECTOR_PATH, 
    TRAPEZE,
    ARC_PATH,
    WAVE_PATH
];

const PATH_VALUES =
[
    VECTOR_PATH_VALUE, 
    TRAPEZE_VALUE,
    ARC_PATH_VALUE,
    WAVE_PATH_VALUE
];


const SHAPE_BOOLEAN         = 'SBOOL';
const SHAPE_BOOLEAN_VALUE   = 'SBOOL#';

const BOOL_UNION            = 'SBOOLU';
const BOOL_SUBTRACT         = 'SBOOLS';
const BOOL_INTERSECT        = 'SBOOLI';
const BOOL_EXCLUDE          = 'SBOOLE';


const BOOLEAN_TYPES =
[
    SHAPE_BOOLEAN,
    SHAPE_BOOLEAN_VALUE,
    BOOL_UNION,
    BOOL_SUBTRACT,
    BOOL_INTERSECT,
    BOOL_EXCLUDE
];


const PERSIST              = 'PERSIST';
const EXPORT               = 'EXPORT';


const SHAPE_VALUES =
[
    SHAPE_VALUE,
    SHAPE_LIST_VALUE,
    RECTANGLE_VALUE,
    LINE_VALUE,
    ELLIPSE_VALUE,
    TRAPEZE_VALUE,
    POLYGON_VALUE,
    STAR_VALUE,
    TEXT_SHAPE_VALUE,
    POINT_VALUE,
    VECTOR_PATH_VALUE,
    VECTOR_VERTEX_VALUE,
    VECTOR_EDGE_VALUE,
    VECTOR_REGION_VALUE,
    VECTOR_NETWORK_VALUE,
    ARC_PATH_VALUE,
    WAVE_PATH_VALUE,
    SHAPE_GROUP_VALUE,
    FRAME_VALUE,
    SHAPE_BOOLEAN_VALUE,
    DROP_SHADOW_VALUE,
    INNER_SHADOW_VALUE,
    LAYER_BLUR_VALUE,
    BACK_BLUR_VALUE,
    LAYER_BLEND_VALUE,
    LAYER_MASK_VALUE
];


const AFFINE_TYPES =
[
    ROTATE,
    SCALE,
    SKEW
];


const SHAPE_TYPES =
[
    ...SHAPE_VALUES,

    ...RECTANGLE_TYPES,
    ...LINE_TYPES,
    ...ELLIPSE_TYPES,
    ...TRAPEZE_TYPES,
    ...POLYGON_TYPES,
    ...STAR_TYPES,
    ...TEXT_SHAPE_TYPES,
    ...POINT_TYPES,
       POINT_CORNER,
    ...VECTOR_PATH_TYPES,
    ...VECTOR_VERTEX_TYPES,
    ...VECTOR_EDGE_TYPES,
    ...VECTOR_REGION_TYPES,
    ...VECTOR_NETWORK_TYPES,
    ...ARC_PATH_TYPES,
    ...WAVE_PATH_TYPES,
    ...SHAPE_GROUP_TYPES,
    ...FRAME_TYPES,
    ...BOOLEAN_TYPES,
    
    MOVE,
    ...AFFINE_TYPES,
    SHOW_CENTER,
    SET_CENTER,
    RESET_XFORM,
        
    PLACE,
    SHAPE_APPLY,
    
    PATH_LENGTH,
    JOIN_PATHS,
    REORIENT_PATHS,
    POINT_ALONG_PATH,
    CLOSEST_POINT_ON_PATH,
        
    MEASURE_VECTOR,
    POINT_ANGLE,
    VECTOR,
    CIRCLE_CENTER,
    ARC_PATH,
    WAVE_PATH,
    ARC_FROM_POINTS,
    INTERSECT_LINES,
    INTERPOLATE_POINT,
    REVERSE_PATH,
    BLEND_PATH,

    PERSIST,
    EXPORT
];


const ALL_VALUES =
[
            LIST_VALUE,
     NUMBER_LIST_VALUE,
       TEXT_LIST_VALUE,
      SHAPE_LIST_VALUE,
     
        VARIABLE_VALUE,
        
          NUMBER_VALUE,
            TEXT_VALUE,
           COLOR_VALUE,
 
            FILL_VALUE,
      COLOR_STOP_VALUE,
        GRADIENT_VALUE,
          STROKE_VALUE,
 
      COLOR_STOP_VALUE,
        GRADIENT_VALUE,
 
           SHAPE_VALUE,
       RECTANGLE_VALUE,
            LINE_VALUE,
         ELLIPSE_VALUE,
         TRAPEZE_VALUE,
         POLYGON_VALUE,
            STAR_VALUE,
      TEXT_SHAPE_VALUE,
           POINT_VALUE,
     VECTOR_PATH_VALUE,
   VECTOR_VERTEX_VALUE,
     VECTOR_EDGE_VALUE,
   VECTOR_REGION_VALUE,
  VECTOR_NETWORK_VALUE,
     SHAPE_GROUP_VALUE,
           FRAME_VALUE,

   ROUND_CORNERS_VALUE,
     DROP_SHADOW_VALUE,
    INNER_SHADOW_VALUE,
      LAYER_BLUR_VALUE,
       BACK_BLUR_VALUE,

     LAYER_BLEND_VALUE,
      LAYER_MASK_VALUE
];


const GROUP_NODE    = 'GROUP';
const GROUP_PARAM   = 'GPARAM';


const GROUP_TYPES =
[
    GROUP_NODE,
    GROUP_PARAM
];


const COMMENT       = 'CMNT';
const COMMENT_ARROW = 'CMNTARR';
const PANEL         = 'PANEL';


const ACTIVE        = 'ACT';
const BEFORE_ACTIVE = 'BFACT';
const BEFORE_LIST   = 'BFLST';
const DISABLED      = 'DIS';
const NOCACHE       = 'NOC';
 
const PARAM         = 'PARAM'; // nodeId paramId
 

const LOG           = 'LOG';


const GRAPH         = 'GRAPH';


const MATH_OPS = 
[   // the order is important for logical keyboard value changes
    [NUMBER_MODULO,   '%' ],
    [NUMBER_DIVIDE,   '/' ], //'÷' ],
    [NUMBER_SUBTRACT, '−' ],
    [NUMBER_ADD,      '+' ],
    [NUMBER_MULTIPLY, '×' ],
    [NUMBER_EXPONENT, 'e<sup>x'] 
];


const MATH_OPS_SHORT = 
[   // the order is important for logical keyboard value changes
    [NUMBER_DIVIDE,   '/' ], //'÷' ],
    [NUMBER_SUBTRACT, '−' ],
    [NUMBER_ADD,      '+'],
    [NUMBER_MULTIPLY, '×']
];



const BOOLEAN_NOT = 0;
const BOOLEAN_XOR = 1;
const BOOLEAN_OR  = 2;
const BOOLEAN_AND = 3;


const BOOLEAN_OPS = 
[   
    [BOOLEAN_NOT, 'not'],
    [BOOLEAN_XOR, 'xor'], 
    [BOOLEAN_OR,  'or' ],
    [BOOLEAN_AND, 'and']
];



const CONDITION_LESS             = 0;
const CONDITION_LESS_OR_EQUAL    = 1;
const CONDITION_NOT_EQUAL        = 2;
const CONDITION_EQUAL            = 3;
const CONDITION_GREATER_OR_EQUAL = 4;
const CONDITION_GREATER          = 5;


const CONDITION_OPS = 
[   
    [CONDITION_LESS,             '<'],
    [CONDITION_LESS_OR_EQUAL,    '≤'],
    [CONDITION_NOT_EQUAL,        '≠'],
    [CONDITION_EQUAL,            '='],
    [CONDITION_GREATER_OR_EQUAL, '≥'],
    [CONDITION_GREATER,          '>']
];



const TRIG_SIN  = 0;
const TRIG_COS  = 1;
const TRIG_TAN  = 2;
const TRIG_ASIN = 3;
const TRIG_ACOS = 4;
const TRIG_ATAN = 5;


const TRIG_OPS = 
[   
    [TRIG_SIN,  'sin' ],
    [TRIG_COS,  'cos' ],
    [TRIG_TAN,  'tan' ],
    [TRIG_ASIN, 'asin'],
    [TRIG_ACOS, 'acos'],
    [TRIG_ATAN, 'atan']
];



const EMPTY_ACTION               = 'EMPTY';
const CONNECT_ACTION             = 'CONNECT';
const CREATE_ACTION              = 'CREATE';
const CREATE_INSERT_ACTION       = 'CREATE_INSERT';
const DELETE_ACTION              = 'DELETE';
const DISCONNECT_ACTION          = 'DISCONNECT';
const LINK_STYLE_ACTION          = 'LINK_STYLE';
const LINK_VARIABLE_ACTION       = 'LINK_VARIABLE';
const LINK_VARIABLE_GROUP_ACTION = 'LINK_VARIABLE_GROUP';
const MAKE_ACTIVE_ACTION         = 'MAKE_ACTIVE';
const MAKE_NOT_CONDITION_ACTION  = 'MAKE_NOT_CONDITION';
const MAKE_PASSIVE_ACTION        = 'MAKE_PASSIVE';
const PASTE_ACTION               = 'PASTE';
const RECONNECT_ACTION           = 'RECONNECT';
const REMOVE_ACTION              = 'REMOVE';
const RENAME_ACTION              = 'RENAME';
const REORDER_INPUTS_ACTION      = 'REORDER_INPUTS';
const REORDER_CONNECTIONS_ACTION = 'REORDER_CONNECTIONS';
const SELECT_ACTION              = 'SELECT';
const SELECT_MOVE_ACTION         = 'SELECT_MOVE';
const MOVE_NODES_ACTION          = 'MOVE_NODES';
const SET_PARAM_VALUE_ACTION     = 'SET_PARAM_VALUE';
const SET_MULTIPLE_VALUES_ACTION = 'SET_MULTIPLE_VALUES';
const SET_PARAM_SETTING_ACTION   = 'SET_PARAM_SETTING';
const SET_NODE_RECT_ACTION       = 'SET_NODE_RECT';
const TOGGLE_DISABLE_ACTION      = 'TOGGLE_DISABLE';
const TOGGLE_PARAM_HEADER_ACTION = 'TOGGLE_PARAM_HEADER';
const SET_CURRENT_GRAPH_ACTION   = 'SET_CURRENT_GRAPH';
const CREATE_PAGE_ACTION         = 'CREATE_PAGE';
const DELETE_PAGE_ACTION         = 'DELETE_PAGE';
const GROUP_NODES_ACTION         = 'GROUP_NODES';
const UNGROUP_NODES_ACTION       = 'UNGROUP_NODES';
const HIGHLIGHT_NODES_ACTION     = 'HIGHLIGHT_NODES';
const SCROLL_LIST_NODE_ACTION    = 'SCROLL_LIST_NODE';
const SET_LIST_DIVIDER_ACTION    = 'SET_LIST_DIVIDER';
const SET_NODE_PARAM_ACTION      = 'SET_NODE_PARAM';


const BLEND_NORMAL               = 'BNORM';
const BLEND_DARKEN               = 'BDARK';
const BLEND_MULTIPLY             = 'BMULT';
const BLEND_PLUS_DARKER          = 'BPDRK';
const BLEND_COLOR_BURN           = 'BBURN';
const BLEND_LIGNTEN              = 'BLITE';
const BLEND_SCREEN               = 'BSCRN';
const BLEND_PLUS_LIGHTER         = 'BPLGT';
const BLEND_COLOR_DODGE          = 'BDODG';
const BLEND_OVERLAY              = 'BOVER';
const BLEND_SOFT_LIGHT           = 'BSOFT';
const BLEND_HARD_LIGHT           = 'BHARD';
const BLEND_DIFFERENCE           = 'BDIFF';
const BLEND_EXCLUSION            = 'BEXCL';
const BLEND_HUE                  = 'BHUE';
const BLEND_SATURATION           = 'BSAT';
const BLEND_COLOR                = 'BCOL';
const BLEND_LUMINOSITY           = 'BLUM';

const BLEND_NORMAL_INDEX         =  0;
const BLEND_DARKEN_INDEX         =  1;
const BLEND_MULTIPLY_INDEX       =  2;
const BLEND_PLUS_DARKER_INDEX    =  3;
const BLEND_COLOR_BURN_INDEX     =  4;
const BLEND_LIGHTEN_INDEX        =  5;
const BLEND_SCREEN_INDEX         =  6;
const BLEND_PLUS_LIGHTER_INDEX   =  7;
const BLEND_COLOR_DODGE_INDEX    =  8;
const BLEND_OVERLAY_INDEX        =  9;
const BLEND_SOFT_LIGHT_INDEX     = 10;
const BLEND_HARD_LIGHT_INDEX     = 11;
const BLEND_DIFFERENCE_INDEX     = 12;
const BLEND_EXCLUSION_INDEX      = 13;
const BLEND_HUE_INDEX            = 14;
const BLEND_SATURATION_INDEX     = 15;
const BLEND_COLOR_INDEX          = 16;
const BLEND_LUMINOSITY_INDEX     = 17;


const BlendModes =
[
    [BLEND_NORMAL,       'normal',       'NORMAL'      ],
    [BLEND_DARKEN,       'darken',       'DARKEN'      ],
    [BLEND_MULTIPLY,     'multiply',     'MULTIPLY'    ],
    [BLEND_PLUS_DARKER,  'plus darker',  'LINEAR_BURN' ],
    [BLEND_COLOR_BURN,   'color burn',   'COLOR_BURN'  ],
    [BLEND_LIGNTEN,      'lighten',      'LIGHTEN'     ],
    [BLEND_SCREEN,       'screen',       'SCREEN'      ],
    [BLEND_PLUS_LIGHTER, 'plus lighter', 'LINEAR_DODGE'],
    [BLEND_COLOR_DODGE,  'color dodge',  'COLOR_DODGE' ],
    [BLEND_OVERLAY,      'overlay',      'OVERLAY'     ],
    [BLEND_SOFT_LIGHT,   'soft light',   'SOFT_LIGHT'  ],
    [BLEND_HARD_LIGHT,   'hard light',   'HARD_LIGHT'  ],
    [BLEND_DIFFERENCE,   'difference',   'DIFFERENCE'  ],
    [BLEND_EXCLUSION,    'exclusion',    'EXCLUSION'   ],
    [BLEND_HUE,          'hue',          'HUE'         ],
    [BLEND_SATURATION,   'saturation',   'SATURATION'  ],
    [BLEND_COLOR,        'color',        'COLOR'       ],
    [BLEND_LUMINOSITY,   'luminosity',   'LUMINOSITY'  ]
];



const FONT_WEIGHTS =
[
    ['thin',        100],
    ['extra light', 200],
    ['light',       300],
    ['regular',     400],
    ['medium',      500],
    ['semi bold',   600],
    ['bold',        700],
    ['extra bold',  800],
    ['black',       900]
];



const FO_TYPE           =  0;
const FO_NODE_ID        =  1;

const FO_OBJECT_ID      =  2;   const FO_STYLE_ID     = 2;
const FO_OBJECT_NAME    =  3;   const FO_STYLE_NAME   = 3;

const FO_FEEDBACK       =  4;   const FO_STYLE_PAINTS = 4;
const FO_PERSIST        =  5;


const FO_XP0            =  6;
const FO_XP1            =  7;
const FO_XP2            =  8;

const FO_SCALE          =  9;

const FO_FILLS          = 10;   const FO_VARIABLE_TYPE   = 10;
const FO_STROKES        = 11;   const FO_VARIABLE_VALUE  = 11;

const FO_STROKE_WEIGHT  = 12;
const FO_STROKE_ALIGN   = 13;
const FO_STROKE_JOIN    = 14;                                    
const FO_STROKE_MITER   = 15;
const FO_STROKE_CAP     = 16;
const FO_STROKE_DASHES  = 17;

const FO_EFFECTS        = 18;

const FO_DECO           = 19;
const FO_IS_CENTER      = 20;   

const FO_OPACITY        = 21;
const FO_BLEND          = 22;
const FO_MASK           = 23;

const FO_X              = 24;                                                                         const FO_BOOLEAN_CHILDREN    = 24;                                                                                              const FO_GROUP_CHILDREN = 24;
const FO_Y              = 25;                                                                         const FO_BOOLEAN_OPERATION   = 25;
const FO_WIDTH          = 26;   
const FO_HEIGHT         = 27;                                    

const FO_RECT_ROUND     = 28;   const FO_ELLIPSE_ROUND   = 28;   const FO_VECTOR_NETWORK_DATA = 28;   const FO_VECTOR_PATH_DATA    = 28;   const FO_POLY_ROUND   = 28;   const FO_STAR_ROUND  = 28;   const FO_FIG_WIDTH      = 28;   const FO_FRAME_ROUND    = 28;
                                const FO_ELLIPSE_START   = 29;                                        const FO_VECTOR_PATH_WINDING = 29;   const FO_POLY_CORNERS = 29;   const FO_STAR_POINTS = 29;   const FO_FIG_HEIGHT     = 29;   const FO_FRAME_CLIP     = 29;
                                const FO_ELLIPSE_SWEEP   = 30;                                        const FO_VECTOR_PATH_ROUND   = 30;                                 const FO_STAR_CONVEX = 30;   const FO_TEXT           = 30;   const FO_FRAME_CHILDREN = 30;
                                                                                                                                 
                                const FO_ELLIPSE_INNER   = 31;                                                                                                                                        const FO_FONT           = 31;
                                                                                                                                                                                                      const FO_FONT_SIZE      = 32;
                                                                                                                                                                                                      const FO_FONT_STYLE     = 33;
                                                                                                                                                                                                                                    
                                                                                                                                                                                                      const FO_ALIGN_H        = 34;
                                                                                                                                                                                                      const FO_ALIGN_V        = 35;
                                                                                                                                                                                                                                    
                                                                                                                                                                                                      const FO_LINE_HEIGHT    = 36;
                                                                                                                                                                                                      const FO_LETTER_SPACING = 37;


class FigmaObject
{
    type;
    
    nodeId     = '';


    objectId   = NULL;
    objectName = NULL;

    itemIndex  = -1; // for linking objects to list items

    persist    = 0;
    feedback   = false;


    showCenter = false;
    
    xform;

    xp0   = null; //  xp0 ------- xp1 
    xp1   = null; //   |     
    xp2   = null; //  xp2

    sp0   = null; //  sp0 ------- sp1 
    sp1   = null; //   |
    sp2   = null; //  sp2

    scaleCorners;
    scaleStyle;



    constructor(type, nodeId, objectId, objectName)
    {
        this.type         = type;
        this.nodeId       = nodeId;
        this.objectId     = objectId;
        this.objectName   = objectName;

        this.xform        = clone(identity);

        this.scaleCorners = 1;
        this.scaleStyle   = 1;
    }



    copyBase(base)
    {
        this.itemIndex    = base.itemIndex;
        
        this.feedback     = base.feedback;
        this.persist      = base.persist;

        this.showCenter   = base.showCenter;

        this.xform        = clone(base.xform);

        this.xp0          = clone(base.xp0);
        this.xp1          = clone(base.xp1);
        this.xp2          = clone(base.xp2);

        this.sp0          = clone(base.sp0);
        this.sp1          = clone(base.sp1);
        this.sp2          = clone(base.sp2);

        this.scaleCorners = base.scaleCorners;
        this.scaleStyle   = base.scaleStyle;
    }



    copy()
    {
        consoleError('invalid use of abstract method FigmaObject.copy()');
        return null;
    }



    getCount()
    {
        return 1;
    }



    createDefaultSpace(cx = 0, cy = 0)
    {
        this.sp0 = point(cx,   cy  );
        this.sp1 = point(cx+1, cy  );
        this.sp2 = point(cx,   cy+1);
    }



    resetSpace(bounds, singlePoint = false, cx = 0.5, cy = 0.5, units = 0)
    {
        let _cx; 
        let _cy; 

        if (units == 0)
        {
            _cx = bounds.x + cx * bounds.width;
            _cy = bounds.y + cy * bounds.height;            
        }
        else if (units == 1)
        {
            _cx = bounds.x + cx;
            _cy = bounds.y + cy;
        }
        else // units == 2
        {
            _cx = cx;
            _cy = cy;            
        }


        const ds1 = subv(this.sp1, this.sp0);
        const ds2 = subv(this.sp2, this.sp0);

        this.sp0  = point(_cx, _cy);

        this.sp1  = addv(this.sp0, ds1);
        this.sp2  = addv(this.sp0, ds2);


        if (PATH_TYPES.includes(this.type))
            this.updatePathPoints();
    }



    createDefaultTransform(x, y, a = 0)
    {
        this.xform =
            [[Math.cos(a), -Math.sin(a), x],
             [Math.sin(a),  Math.cos(a), y],
             [0,            0,           1]];
    }



    createDefaultTransformPoints(x, y, w, h)
    {
        this.xp0 = point(x,     y    );
        this.xp1 = point(x + w, y    );
        this.xp2 = point(x,     y + h);
    }



    createSpaceTransform()
    {
        let vr = point(this.sp1.x - this.sp0.x, this.sp1.y - this.sp0.y);
        let vb = point(this.sp2.x - this.sp0.x, this.sp2.y - this.sp0.y);
    
    
        let sx = vr.x;
        let sy = vb.y;
    
        let kx = vr.y;
        let ky = vb.x;
        
        let dx = this.sp0.x;
        let dy = this.sp0.y;
    
    
        let xform = mulm3m3(
            createTransform(dx, dy),
            [[sx, ky, 0],
             [kx, sy, 0],
             [0,  0,  1]]);
    

        return xform;
    }
    
    

    getBounds()
    {
        let bounds = Rect.NaN;

        const dp = subv(this.xp1, this.xp0);

        bounds = expandRect_(bounds, this.xp0);
        bounds = expandRect_(bounds, this.xp1);
        bounds = expandRect_(bounds, this.xp2);
        bounds = expandRect_(bounds, addv(this.xp2, dp));

        return bounds;
    }



    applyTransform(xform, affectSpace)
    {
        const space = this.createSpaceTransform();


        if (this.type == POINT)
        {
            if (affectSpace > 0)
            {
                const p = transformPoint(point(this.x, this.y), xform, space);

                this.x = p.x;
                this.y = p.y;
            }

            if (affectSpace != 1)
                this.applySpaceTransform(xform, space);
        }
        else if (PATH_TYPES.includes(this.type))
        {
            if (affectSpace > 0)
            {
                this.applyObjectTransform(xform, space);

                this.updatePoints(xform, space);
                this.updatePathPoints();
            }

            if (affectSpace != 1)
                this.applySpaceTransform(xform, space);
        }
        else if (this.type == SHAPE_GROUP)
        {
            for (const obj of this.children)
            {
                if (affectSpace > 0)
                {
                    obj.applyObjectTransform(xform, space);

                    if (obj.type == VECTOR_PATH)
                        obj.updatePoints(xform, space);
                }

                if (affectSpace != 1)
                    obj.applySpaceTransform(xform, space);
            }                
        }
        else
        {
            if (affectSpace > 0)
                this.applyObjectTransform(xform, space);

            if (affectSpace != 1)
                this.applySpaceTransform(xform, space);
        }
    }



    applyObjectTransform(xform, space)
    {
        if (   this.xp0.x == this.xp1.x
            && this.xp0.y == this.xp1.y)
            this.xp1.x += 0.0001;

        if (   this.xp0.x == this.xp2.x
            && this.xp0.y == this.xp2.y)
            this.xp2.y += 0.0001;

        this.xp0 = transformPoint(this.xp0, xform, space);
        this.xp1 = transformPoint(this.xp1, xform, space);
        this.xp2 = transformPoint(this.xp2, xform, space);
    }



    applySpaceTransform(xform, space)
    {
        this.sp0 = transformPoint(this.sp0, xform, space);
        this.sp1 = transformPoint(this.sp1, xform, space);
        this.sp2 = transformPoint(this.sp2, xform, space);
    }



    checkFlipped(flipX, flipY)
    {
        if (flipX)
        {
            const d1 = subv(this.xp1, this.xp0);

            this.xp0 = addv(this.xp0, d1);
            this.xp2 = addv(this.xp2, d1);
            this.xp1 = subv(this.xp1, d1);
        }

        
        if (flipY)
        {
            const d2 = subv(this.xp2, this.xp0);

            this.xp0 = addv(this.xp0, d2);
            this.xp1 = addv(this.xp1, d2);
            this.xp2 = subv(this.xp2, d2);
        }
    }



    toJsonObject()
    {
        return {
            type:       this.type,
            nodeId:     this.nodeId,

            objectId:   this.objectId,   // or variable ID
            objectName: this.objectName, // or variable name
            
            feedback:   this.feedback,

            xp0:        this.xp0 ? this.xp0 : null,
            xp1:        this.xp1 ? this.xp1 : null,
            xp2:        this.xp2 ? this.xp2 : null
        };
    }



    toData()
    {
        return [
        /* 0 */ this.type,
        /* 1 */ this.nodeId,

        /* 2 */ this.objectId,
        /* 3 */ this.objectName,
            
        /* 4 */ this.feedback,
        /* 5 */ this.persist,
        
        /* 6 */ this.xp0 ? this.xp0 : null,
        /* 7 */ this.xp1 ? this.xp1 : null,
        /* 8 */ this.xp2 ? this.xp2 : null,

        /* 9 */ 0 // for future use
        ];
    }



    toValue()
    {
        return new NullValue();
    }
}



function transformPoint(p, xform, space)
{
    p = mulv2m3(p, inversem3(space));
    p = mulv2m3(p, xform);
    p = mulv2m3(p, space);

    return p;
}



function copyFigmaObject(obj)
{
    switch (obj.type)
    {
        case RECTANGLE:     return FigmaRectangle .prototype.copy.call(obj);
        case LINE:          return FigmaLine      .prototype.copy.call(obj);
        case ELLIPSE:       return FigmaEllipse   .prototype.copy.call(obj);
        case TRAPEZE:       return FigmaTrapeze   .prototype.copy.call(obj);
        case POLYGON:       return FigmaPolygon   .prototype.copy.call(obj);
        case STAR:          return FigmaStar      .prototype.copy.call(obj);
        case TEXT_SHAPE:    return FigmaText      .prototype.copy.call(obj);
        case POINT:         return FigmaPoint     .prototype.copy.call(obj);
        case VECTOR_PATH:   return FigmaVectorPath.prototype.copy.call(obj);
        case ARC_PATH:      return FigmaArcPath   .prototype.copy.call(obj);
        case WAVE_PATH:     return FigmaWavePath  .prototype.copy.call(obj);
        case SHAPE_BOOLEAN: return FigmaBoolean   .prototype.copy.call(obj);
        case SHAPE_GROUP:   return FigmaShapeGroup.prototype.copy.call(obj);
        case FRAME:         return FigmaFrame     .prototype.copy.call(obj);
    }

    consoleError('invalid Figma object type \'' + obj.type + '\'');
    return null;
}



function getPointBounds(points)
{
    let minX = Number.MAX_SAFE_INTEGER;
    let minY = Number.MAX_SAFE_INTEGER;
    let maxX = Number.MIN_SAFE_INTEGER;
    let maxY = Number.MIN_SAFE_INTEGER;

    for (const p of points)
    {
        minX = Math.min(minX, p.x.value);
        minY = Math.min(minY, p.y.value);
        maxX = Math.max(maxX, p.x.value);
        maxY = Math.max(maxY, p.y.value);
    }

    return new AbsRect(minX, minY, maxX, maxY);
}



function getObjBounds(objects)
{
    let bounds = Rect.NaN;

    for (const obj of objects)
        bounds = expandRect(bounds, obj.getBounds());

    return bounds;
}



function createObjectCenter(node, obj)
{
    const sp0 = point(
        obj.sp0.x /*+ 0.5*/, 
        obj.sp0.y /*+ 0.5*/);

    const sp1 = addv(sp0, mulvs(      subv(obj.sp1, obj.sp0),      settings.objectCenterSize));
    const sp2 = addv(sp0, mulvs(mulvs(subv(obj.sp2, obj.sp0), -1), settings.objectCenterSize));    

    const center = createDecoPoly(
        node.nodeId,
        obj.objectId,
        obj.objectName, 
        sp0, 
        [sp2, sp0, sp1],
        false,
        '',
        [242, 72, 34], 
        CENTER_SUFFIX,
        true);

    return center;
}



function createDecoPoly(nodeId, objectId, objectName, center, points, closed, dashes, color, suffix, isCenter)
{
    const path = new FigmaVectorPath(
        nodeId,
        objectId   + suffix,
        objectName + suffix,
        points.map(p => PointValue.fromPoint(objectId, p)),
        closed ? 1 : 0, 
        0, 
        0, 
        0);


    path.strokes.push([
        'SOLID', 
        color[0], 
        color[1], 
        color[2], 
        100, 
        'NORMAL']);

    path.strokeWeight =  1;
    path.strokeAlign  = 'CENTER';
    path.strokeJoin   = 'MITER';
    path.strokeCap    = 'NONE';
    path.strokeDashes =  dashes;
    path.isDeco       =  true;
    path.isCenter     =  isCenter;


    path.createDefaultTransform(center.x, center.y);
    //path.updatePathData();


    return path;
}



function getValidObjects(value)
{
    return value
        && value.objects
        ? value.objects
              .filter(o => 
                     o.isDeco  === false
                  || o.isXform === true)
              .map(o => o.copy()) 
        : [];
}


function addProp(obj, prop)
{
         if (prop.type ==         COLOR_VALUE)  addColorProp       (obj, prop);
    else if (prop.type ==          FILL_VALUE)  addFillProp        (obj, prop);
    else if (prop.type ==      GRADIENT_VALUE)  addGradientProp    (obj, prop);
    else if (prop.type ==        STROKE_VALUE)  addStrokeProp      (obj, prop);
    else if (prop.type ==  STROKE_SIDES_VALUE)  addStrokeSidesProp (obj, prop);
    else if (prop.type == ROUND_CORNERS_VALUE)  addRoundCornersProp(obj, prop);
    else if (prop.type ==   DROP_SHADOW_VALUE)  addDropShadowProp  (obj, prop);
    else if (prop.type ==  INNER_SHADOW_VALUE)  addInnerShadowProp (obj, prop);
    else if (prop.type ==    LAYER_BLUR_VALUE)  addLayerBlurProp   (obj, prop);
    else if (prop.type ==     BACK_BLUR_VALUE)  addBackBlurProp    (obj, prop);
    else if (prop.type ==   LAYER_BLEND_VALUE)  addLayerBlendProp  (obj, prop);
    else if (prop.type ==    LAYER_MASK_VALUE)  addMaskProp        (obj, prop);
}



function addColorProp(obj, prop)
{
    const rgb = scaleRgb(prop.toRgb());

    if (obj.type == SHAPE_GROUP)
    {
        for (const _obj of obj.children)
            addProp(_obj, prop);
    }
    else
    {
        obj.fills.push([
            'SOLID', 
            rgb[0], 
            rgb[1], 
            rgb[2], 
            255 ]);
    }
}



function addFillProp(obj, prop, target = obj.fills)
{
    if (prop.color.type != COLOR_VALUE)
        return;


    const rgb = scaleRgb(prop.color.toRgb());

    if (obj.type == SHAPE_GROUP)
    {
        for (const _obj of obj.children)
            addProp(_obj, prop);
    }
    else
    {
        target.push([
            'SOLID', 
            rgb[0], 
            rgb[1], 
            rgb[2], 
            prop.opacity.toValue().value,//.toNumber(),
            BlendModes[Math.min(Math.max(0, Math.round(prop.blend.value)), BlendModes.length-1)][2]]);
    }
}



function addGradientProp(obj, prop, target = obj.fills)                
{
    const gradient = 
    [
        '', // type
        [], // transform points
        [], // stops
        '', // blend mode
        0   // flags 0 = flipX
            //       1 = flipY
    ];


    switch(prop.gradType.value)
    {
        case 0: gradient[0] = 'GRADIENT_LINEAR';  break;
        case 1: gradient[0] = 'GRADIENT_RADIAL';  break;
        case 2: gradient[0] = 'GRADIENT_ANGULAR'; break;
        case 3: gradient[0] = 'GRADIENT_DIAMOND'; break;
    }

    
    let   x        =        prop.x     .value / 100;
    let   y        =        prop.y     .value / 100;
    let   s        = nozero(prop.size  .value / 100);
    let   a        =        prop.angle .value / 360*Tau;
    let   asp      = nozero(prop.aspect.value / 100);
    const diag     =        prop.diagAspect;
    let   sk       =        prop.skew  .value / 100;

    
    const pos      = prop.position.value;
    const isLinear = prop.gradType.value == 0;
    
    const bounds   = obj.getBounds();


    if (pos > 0)
    {
        if (   pos == 1
            || pos == 2) 
        {
            x = x / 100 * bounds.width;
            y = y / 100 * bounds.height;
        }
        

        x = x * 100 / nozero(bounds.width );
        y = y * 100 / nozero(bounds.height);


        if (pos == 4)
        {
            x = x - bounds.x / nozero(bounds.width );
            y = y - bounds.y / nozero(bounds.height);
            
            s *= 100 / nozero(bounds.width);
        }
    }


    let   p0 = point(x, y);
    let   p1 = addv(p0, vector(a, diag === true ? s : s * nozero(asp)));
    let   p2 = addv(p0, vector(a + Tau/4, s));

    const a1 = anglev2(p0, p1);
    const a2 = anglev2(p0, p2);

    
    if (diag === true)
    {
        p1 = addv(p1, vector(a1 - Tau/8, (asp-1) * Math.sqrt(sqr(distv(p0, p1))/2)));
        p2 = addv(p2, vector(a2 + Tau/8, (asp-1) * Math.sqrt(sqr(distv(p0, p2))/2)));

        p1 = addv(p1, vector(a2 + Tau/8, s * sk * Math.sqrt(2)/2));
        p2 = addv(p2, vector(a2 + Tau/8, s * sk * Math.sqrt(2)/2));
    }
    else
    {
        p2 = subv(p2, vector(a1, s * sk));
    }


    if (pos > 0)
    {
        if (   pos == 1
            || pos == 3
            || pos == 4)
        {
            const aspect = bounds.width / nozero(bounds.height);
            
            p1.y = p0.y + (p1.y - p0.y) * aspect;
            p2.y = p0.y + (p2.y - p0.y) * aspect;
        }
        else if (pos == 2)
        {
            const aspect = bounds.height / nozero(bounds.width);
            
            p1.x = p0.x + (p1.x - p0.x) * aspect;
            p2.x = p0.x + (p2.x - p0.x) * aspect;
        }
    }


    if (!isLinear)
    {
        const dv = subv(p0, p1);

        p0 = addv(p0, dv);
        p2 = addv(p2, dv);
    }


    // handles outside range

    if (prop.stops.items.some(i => 
               i
            && (   i.position.value < 0 
                || i.position.value > 100)))
    {
        let minPos = Number.MAX_SAFE_INTEGER;
        let maxPos = Number.MIN_SAFE_INTEGER;

        for (const stop of prop.stops.items)
        {
            minPos = Math.min(minPos, stop.position.value);
            maxPos = Math.max(maxPos, stop.position.value);
        }

        if (!isLinear)
            minPos = Math.max(0, minPos);


        const dpos  = Math.min(0, minPos) / 100;
        const dsize = Math.max(100, maxPos - Math.min(minPos, 0)) / 100;

        const dv    = subv(p0, p1);

        p0 = addv(p0, mulvs(dv, Math.max(0, -dpos)));
        p1 = addv(p1, mulvs(dv, Math.max(0, -dpos)));
        p2 = addv(p2, mulvs(dv, Math.max(0, -dpos)));

        if (prop.gradType.value != 2) // not angular
        {
            p1 = subv(p0, mulvs(dv, dsize));
            p2 = addv(p0, mulvs(subv(p2, p0), dsize));
        }


        for (const stop of prop.stops.items)
            stop.position.value = stop.position.value * 100 / maxPos;
    }


    gradient[1] = [p0, p1, p2];    


    const stops = prop.stops.items;

    for (let j = 0; j < stops.length; j++)
    {
        const stop = stops[j];

        if (stop.fill)
        {
            const rgba = stop.fill.toRgba();

            gradient[2].push([
                rgba[0], 
                rgba[1], 
                rgba[2], 
                rgba[3],
                Math.min(Math.max(0, stop.position.value / 100), 1)]);
        }
    }


    gradient[3] = BlendModes[prop.blend.value][2];    


    target.push(gradient);
}



function validateColorStops(_stops)
{
    const stops = [];


    for (let i = 0; i < _stops.length; i++)
    {
        const stop = _stops[i];

        if (stop.type == COLOR_VALUE)
        {
            stops.push(new ColorStopValue(
                FillValue.fromRgb(scaleRgb(stop.toRgb()), 100),
                NumberValue.NaN));
        }

        else if (stop.type == FILL_VALUE)
            stops.push(new ColorStopValue(
                stop,
                NumberValue.NaN));

        else if (stop.type == LIST_VALUE)
            stops.push(...validateColorStops(stop.items));

        else
            stops.push(stop);
    }


    return stops;
}



function setColorStopPositions(stops)
{
    if (    stops.length > 0
        && !stops[0].position.isValid()) 
        stops[0].position = new NumberValue(0);

    if (    stops.length > 1
        && (!stops.at(-1).position.isValid())) 
        stops.at(-1).position = new NumberValue(100);
    

    if (stops.length > 2)
    {
        for (let i = 1; i < stops.length-1; i++)
        {
            const stop = stops[i];

            if (   !stop
                || !stop.position
                || !stop.position.isValid())
            {
                let prevValid = i-1;
                let nextValid = i+1;

                while ( prevValid > 0
                    && !stops[prevValid].position.isValid()) 
                    prevValid--;

                while ( nextValid < stops.length-1
                    && !stops[nextValid].position.isValid()) 
                    nextValid++;
                        
                const pv = stops[prevValid].position.value;//toNumber();
                const nv = stops[nextValid].position.value;//toNumber();

                stop.position = new NumberValue((pv + (nv - pv) * ((i - prevValid) / (nextValid - prevValid)))); 
            }
        }
    }
}



function addStrokeProp(obj, prop)
{
    for (const fill of prop.fills.items)
    {
        if (fill.type ==     FILL_VALUE) addFillProp    (obj, fill, obj.strokes);
        if (fill.type == GRADIENT_VALUE) addGradientProp(obj, fill, obj.strokes);
    }


    if (obj.type == SHAPE_GROUP)
    {
        for (const _obj of obj.children)
            addProp(_obj, prop);
    }
    else
    {
        obj.strokeWeight = prop.weight.toValue().value;//.toNumber();

        switch (prop.fit.toValue().value)
        {
            case 0: obj.strokeAlign = 'INSIDE';  break;
            case 1: obj.strokeAlign = 'CENTER';  break;
            case 2: obj.strokeAlign = 'OUTSIDE'; break;
        }

        switch (prop.join.toValue().value)
        {
            case 0: obj.strokeJoin = 'MITER'; break;
            case 1: obj.strokeJoin = 'BEVEL'; break;
            case 2: obj.strokeJoin = 'ROUND'; break;
        }

        switch (prop.cap.toValue().value)
        {
            case 0: obj.strokeCap = 'NONE';   break;
            case 1: obj.strokeCap = 'SQUARE'; break;
            case 2: obj.strokeCap = 'ROUND';  break;
        }

        obj.strokeDashes     = prop.dashes.toValue().value.trim();
        
        obj.strokeMiterLimit = prop.miter .toValue().value;
    }
}



function addStrokeSidesProp(obj, prop)
{
    if (obj.type == SHAPE_GROUP)
    {
        for (const _obj of obj.children)
            addProp(_obj, prop);
    }
    else
    {
        obj.effects.push([
           'STROKE_SIDES', 
            prop.top   .value,
            prop.left  .value,
            prop.right .value,
            prop.bottom.value,
            prop.visible ]);
    }
}



function addRoundCornersProp(obj, prop)
{
    if (obj.type == SHAPE_GROUP)
    {
        for (const _obj of obj.children)
            addProp(_obj, prop);
    }
    else
    {
        obj.effects.push([
           'ROUND_CORNERS', 
            prop.tl.value,
            prop.tr.value,
            prop.bl.value,
            prop.br.value,
            prop.visible ]);
    }
}



function addDropShadowProp(obj, prop)
{
    const rgba = prop.fill.toRgba();

    obj.effects.push([
        'DROP_SHADOW', 
        rgba[0],
        rgba[1],
        rgba[2],
        rgba[3],
        prop.x     .value, //toNumber(),
        prop.y     .value, //toNumber(),
        prop.blur  .value, //toNumber(),
        prop.spread.value, //toNumber(),
        BlendModes[prop.blend.value][2],
        prop.behind.value > 0,
        prop.visible ]);
}



function addInnerShadowProp(obj, prop)
{
    const rgba = prop.fill.toRgba();

    obj.effects.push([
        'INNER_SHADOW', 
        rgba[0],
        rgba[1],
        rgba[2],
        rgba[3],
        prop.x     .value, //toNumber(),
        prop.y     .value, //toNumber(),
        prop.blur  .value, //toNumber(),
        prop.spread.value, //toNumber(),
        BlendModes[prop.blend.value][2],
        prop.visible ]);
}



function addLayerBlurProp(obj, prop)
{
    obj.effects.push([
        'LAYER_BLUR', 
        prop.radius.value, //toNumber(),
        prop.visible ]);
}



function addBackBlurProp(obj, prop)
{
    obj.effects.push([
        'BACKGROUND_BLUR', 
        prop.radius.value, //toNumber(),
        prop.visible ]);
}



function addLayerBlendProp(obj, prop)
{
    obj.opacity = Math.min(Math.max(0, prop.opacity.value /*toNumber()*/ / 100), 1);
    obj.blend   = BlendModes[prop.blend.value][2];
}



function addMaskProp(obj, mask)
{
    obj.maskType = mask.maskType.value + 1;
}



class FigmaShape
extends FigmaObject
{
    skewX;
    skewY;

    fills   = [];
    strokes = [];

    strokeWeight;
    strokeAlign;
    strokeJoin;
    strokeMiterLimit;
    strokeCap;
    strokeDashes;

    effects = [];

    isDeco;
    isCenter;
    isXform;

    opacity;
    blend;

    maskType = 0;



    constructor(type, nodeId, objectId, objectName, isDeco = false, isXform = false)
    {
        super(type, nodeId, objectId, objectName);

        this.skewX    = 0;
        this.skewY    = 0;

        this.isDeco   = isDeco;
        this.isCenter = false;
        this.isXform  = isXform;

        this.opacity  = 1;
        this.blend    = 'PASS_THROUGH';
    }



    copyBase(base)
    {
        super.copyBase(base);

        this.skewX            = base.skewX;
        this.skewY            = base.skewY;

        this.fills            = clone(base.fills);
        this.strokes          = clone(base.strokes);

        this.strokeWeight     = base.strokeWeight;
        this.strokeAlign      = base.strokeAlign;
        this.strokeJoin       = base.strokeJoin;
        this.strokeMiterLimit = base.strokeMiterLimit;
        this.strokeCap        = base.strokeCap;
        this.strokeDashes     = base.strokeDashes;

        this.effects          = clone(base.effects);

        this.isDeco           = base.isDeco;
        this.isCenter         = base.isCenter;
        this.isXform          = base.isXform;

        this.opacity          = base.opacity;
        this.blend            = base.blend;
        this.maskType         = base.maskType;
    }



    checkFlipped(flipX, flipY)
    {
        super.checkFlipped(flipX, flipY);

        for (const fill   of this.fills  ) flipGradient(fill,   flipX, flipY);
        for (const stroke of this.strokes) flipGradient(stroke, flipX, flipY);

        const foundSides = this.effects.findIndex(e => e[0] == 'STROKE_SIDES');
        if (foundSides > -1) flipStrokeSides(this.effects[foundSides], flipX, flipX);

        const foundCorners = this.effects.findIndex(e => e[0] == 'ROUND_CORNERS');
        if (foundCorners > -1) flipRoundCorners(this.effects[foundCorners], flipX, flipY);
    }



    toData()
    {
        const weight = this.strokeWeight * Math.abs(this.scaleStyle);

        const dashes = 
            this.strokeDashes
            ? this.strokeDashes
                .split(',')
                .map(d => parseFloat(d.trim()) * Math.abs(this.scaleStyle))
                .join(',')
            : '';

        
        return [
            ...super.toData(),
   
            /* 10 */ this.fills,
            /* 11 */ this.strokes,

            /* 12 */ weight,
            /* 13 */ this.strokeAlign,
            /* 14 */ this.strokeJoin,
            /* 15 */ this.strokeMiterLimit,
            /* 16 */ this.strokeCap,
            /* 17 */ dashes,

            /* 18 */ this.effects,

            /* 19 */ this.isDeco,
            /* 20 */ this.isCenter,

            /* 21 */ this.opacity,
            /* 22 */ this.blend,
            /* 23 */ this.maskType
        ];
    }
}



function flipGradient(fill, flipX, flipY)
{
    if (   fill[0] == 'GRADIENT_LINEAR'
        || fill[0] == 'GRADIENT_RADIAL'
        || fill[0] == 'GRADIENT_ANGULAR'
        || fill[0] == 'GRADIENT_DIAMOND')
    {
        const p0 = fill[1][0];
        const p1 = fill[1][1];
        const p2 = fill[1][2];

        if (flipX)
        {
            p0.x = 1 - p0.x;
            p1.x = 1 - p1.x;
            p2.x = 1 - p2.x;
        }

        if (flipY)
        {
            p0.y = 1 - p0.y;
            p1.y = 1 - p1.y;
            p2.y = 1 - p2.y;
        }
    }
}



function flipStrokeSides(sides, flipX, flipY)
{
    if (flipX) [sides[2], sides[3]] = [sides[3], sides[2]];
    if (flipY) [sides[1], sides[4]] = [sides[4], sides[1]];
}



function flipRoundCorners(corners, flipX, flipY)
{
    if (flipX)
    {
        [corners[1], corners[2]] = [corners[2], corners[1]];
        [corners[3], corners[4]] = [corners[4], corners[3]];
    }

    if (flipY)
    {
        [corners[1], corners[3]] = [corners[3], corners[1]];
        [corners[2], corners[4]] = [corners[4], corners[2]];
    }
}


class FigmaRectangle
extends FigmaShape
{
    x;
    y;
    width;
    height;

    round;

    

    constructor(nodeId, objectId, objectName, x, y, width, height, round)
    {
        super(RECTANGLE, nodeId, objectId, objectName);
        
        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;

        this.round  = round;

        this.createDefaultSpace(
            x + width /2, 
            y + height/2);
    }



    copy()
    {
        const copy = new FigmaRectangle(
            this.nodeId,
            this.objectId,
            this.objectName,

            this.x,
            this.y,
            this.width,
            this.height,
            
            this.round);


        copy.copyBase(this);


        return copy;
    }



    toValue()
    {
        return RectangleValue.fromObject(this);
    }



    toData()
    {
        return [
            ...super.toData(),
   
            /* 24 */ this.x,
            /* 25 */ this.y,
            /* 26 */ this.width,
            /* 27 */ this.height,

            /* 28 */ this.round * Math.abs(this.scaleCorners)
        ];
    }
}



class FigmaLine
extends FigmaShape
{
    x;
    y;
    width;



    constructor(nodeId, objectId, objectName, x, y, width)
    {
        super(LINE, nodeId, objectId, objectName);
        
        this.x     = x;
        this.y     = y;
        this.width = width;

        
        this.createDefaultSpace(
            x + width/2, 
            y);
    }



    copy()
    {
        const copy = new FigmaLine(
            this.nodeId,
            this.objectId,
            this.objectName,

            this.x,
            this.y,
            this.width);


        copy.copyBase(this);


        return copy;
    }



    toValue()
    {
        return LineValue.fromObject(this);
    }



    toData()
    {
        return [
            ...super.toData(),
   
            /* 24 */ this.x,
            /* 25 */ this.y,
            /* 26 */ this.width
        ];
    }
}


class FigmaEllipse
extends FigmaShape
{
    x;
    y;
    width;
    height;
    round;

    start;
    sweep;
    inner;

    

    constructor(nodeId, objectId, objectName, x, y, width, height, round, start, sweep, inner)
    {
        super(ELLIPSE, nodeId, objectId, objectName);
        
        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;
        this.round  = round;

        this.start  = start;
        this.sweep  = sweep;
        this.inner  = inner;

        
        this.createDefaultSpace(
            x + width /2, 
            y + height/2);
    }



    copy()
    {
        const copy = new FigmaEllipse(
            this.nodeId,
            this.objectId,
            this.objectName,

            this.x,
            this.y,
            this.width,
            this.height,
            this.round,
            
            this.start,
            this.sweep,
            this.inner);


        copy.copyBase(this);


        return copy;
    }



    toValue()
    {
        return EllipseValue.fromObject(this);
    }



    toData()
    {
        return [
            ...super.toData(),
   
            /* 24 */ this.x,
            /* 25 */ this.y,
            /* 26 */ this.width,
            /* 27 */ this.height,
            /* 28 */ this.round,

            /* 29 */ this.start,
            /* 30 */ this.sweep,
            /* 31 */ this.inner
        ];
    }
}


class FigmaVectorPath
extends FigmaShape
{
    x;
    y;
    width;
    height;
    
    points;

    closed;
    degree;
    winding;


    round;
    
    pathPoints;
    pathData;



    constructor(nodeId, objectId, objectName, points, closed, degree, winding, round)
    {
        super(VECTOR_PATH, nodeId, objectId, objectName);
        
        
        this.points  = points.map(p => p.copy());
   
        this.closed  = closed;
        this.degree  = degree;
        this.winding = winding;

        this.round   = round;
        

        this.updatePathPoints();
    }



    copy()
    {
        const copy = new FigmaVectorPath(
            this.nodeId,
            this.objectId,
            this.objectName,

            this.points,

            this.closed,
            this.degree,
            this.winding,

            this.round);


        copy.x          = this.x;
        copy.y          = this.y;
        copy.width      = this.width;
        copy.height     = this.height;

        copy.pathPoints = [...this.pathPoints];
        copy.pathData   = this.pathData;


        copy.copyBase(this);


        return copy;
    }



    copyBase(base)
    {
        super.copyBase(base);

        if (base.points) this.points = base.points.map(p => p.copy());
    }



    getBounds()
    {
        let bounds = Rect.NaN;


        switch (this.degree)
        {
            case 0:
                for (const p of this.pathPoints)
                    bounds = expandRect_(bounds, p);

                break;

            case 1:
                {
                    let i;
                    for (i = 0; i < this.pathPoints.length-2; i += 2)
                    {
                        bounds = expandRect(
                            bounds, 
                            bounds2(
                                this.pathPoints[i  ], 
                                this.pathPoints[i+1],
                                this.pathPoints[i+2]));
                    }

                    if (   this.closed
                        && i < this.pathPoints.length-1)
                    {
                        bounds = expandRect(
                            bounds, 
                            bounds2(
                                this.pathPoints.at(-2), 
                                this.pathPoints.at(-1),
                                this.pathPoints.at( 0)));
                    }

                    break;
                }
            case 2:
            case 3:
            case 4:
            case 5:
                {
                    let i;
                    for (i = 0; i < this.pathPoints.length-3; i += 3)
                    {
                        const b3 = bounds3(
                            this.pathPoints[i  ], 
                            this.pathPoints[i+1],
                            this.pathPoints[i+2],
                            this.pathPoints[i+3]);

                        bounds = expandRect(
                            bounds, 
                            b3);
                    }

                    if (   this.closed
                        && i < this.pathPoints.length - 2)
                    {
                        const b3 = bounds3(
                            this.pathPoints.at(-3), 
                            this.pathPoints.at(-2), 
                            this.pathPoints.at(-1),
                            this.pathPoints.at( 0));

                        bounds = expandRect(
                            bounds, 
                            b3);
                    }

                    break;
                }
            default:
                console.error('invalid curve degree');
        }


        return bounds;
    }



    updatePoints(xform, space)
    {
        for (let i = 0; i < this.points.length; i++)
        {
            let p      = this.points[i].toPoint();
            let smooth = this.points[i].smooth;

            p = transformPoint(p, xform, space);

            this.points[i]        = PointValue.fromPoint(this.nodeId, p);
            this.points[i].smooth = smooth;
        }
    }



    updatePathPoints()
    {
        switch (this.degree)
        {
        case 0: this.pathPoints = this.points.map(p => p.toPoint());                           break;
        case 1: this.pathPoints = this.points.map(p => p.toPoint());                           break;
        case 2: this.pathPoints = this.points.map(p => p.toPoint());                           break;
        case 3: this.pathPoints = getSmoothPoints(this.points, this.closed, getSmoothSegment); break;
        case 4: this.pathPoints = getSmoothPoints(this.points, this.closed, getSineXSegment ); break;
        case 5: this.pathPoints = getSmoothPoints(this.points, this.closed, getSineYSegment ); break;
        }
    }



    updatePathData()
    {
        if (   this.type == VECTOR_PATH
            || this.type == TRAPEZE)
        {
            const bounds = this.getBounds();

            this.x      = bounds.x;
            this.y      = bounds.y;
            this.width  = bounds.width;
            this.height = bounds.height;

            this.createDefaultTransformPoints(this.x, this.y, this.width, this.height);
        }

        this.pathData = getPathDataFromPoints(this.pathPoints, this.closed, this.degree);
    }



    checkFlipped(flipX, flipY)
    {
        super.checkFlipped(flipX, flipY);


        const bounds = this.getBounds();


        for (const point of this.points)
        {
            if (flipX) point.x.value = bounds.width  - point.x.value;
            if (flipY) point.y.value = bounds.height - point.y.value;
        }

        this.updatePathPoints();

        // for (const point of this.pathPoints)
        // {
        //     if (flipX) point.x = bounds.width  - point.x;
        //     if (flipY) point.y = bounds.height - point.y;
        // }
    }



    toData()
    {
        // this.updatePathPoints();
        this.updatePathData();


        const oldType = this.type;
        this.type = VECTOR_PATH;

        const data = 
        [
            ...super.toData(),
   
            /* 24 */ this.x,
            /* 25 */ this.y,
            /* 26 */ this.width,
            /* 27 */ this.height,

            /* 28 */ this.pathData,
            /* 29 */ this.winding,
            /* 30 */ this.round * Math.abs(this.scaleCorners)
        ];

        this.type = oldType;


        return data;
    }



    toValue()
    {
        return VectorPathValue.fromObject(this);
    }
}



function getPathDataFromPoints(points, closed, degree)
{
    for (const p of points)
        if (   isNaN(p.x)
            || isNaN(p.y))
            return '';

            
    let pathData = '';


    switch (degree)
    {
    case 0: pathData = getLinearPathData   (points);         break; // linear
    case 1: pathData = getQuadraticPathData(points, closed); break; // quadratic
    case 2:                                                         // cubic
    case 3:                                                         // smooth
    case 4:                                                         // sine X
    case 5: pathData = getCubicPathData    (points, closed); break; // sine Y
    }


    const pointsAreValid =
           degree == 0 && points.length > 2
        || degree == 1 && points.length > 2
        || degree == 2 && points.length > 3
        || degree == 3 && points.length > 2
        || degree == 4 && points.length > 2
        || degree == 5 && points.length > 2;


    if (   pointsAreValid
        && (   closed
            || equalv(points[0], points.at(-1))))
        pathData += ' Z';


    return pathData;
}



function getQuadraticPathData(points, closed)
{
    let pathData = '';


    if (points.length < 3)
        return pathData;


    pathData += 'M';
    pathData += ' ' + hardZero(points[0].x);
    pathData += ' ' + hardZero(points[0].y);

    let i;
    for (i = 1; i < points.length-1; i += 2)
    {
        pathData += 
              ' Q'
            + ' ' + hardZero(points[i  ].x)
            + ' ' + hardZero(points[i  ].y)
            + ' ' + hardZero(points[i+1].x)
            + ' ' + hardZero(points[i+1].y);
    }


    if (   points.length - i == 1
        && closed)
    {
        pathData += 
              ' Q'
            + ' ' + hardZero(points.at(-1).x)
            + ' ' + hardZero(points.at(-1).y)
            + ' ' + hardZero(points.at( 0).x)
            + ' ' + hardZero(points.at( 0).y);
    }


    return pathData;
}



function getCubicPathData(points, closed)
{
    let pathData = '';


    if (points.length < 4)
        return pathData;


    pathData += 'M';
    pathData += ' ' + hardZero(points[0].x);
    pathData += ' ' + hardZero(points[0].y);

    let i;
    for (i = 1; i < points.length-2; i += 3)
    {
        pathData += 
              ' C'
            + ' ' + hardZero(points[i  ].x)
            + ' ' + hardZero(points[i  ].y)
            + ' ' + hardZero(points[i+1].x)
            + ' ' + hardZero(points[i+1].y)
            + ' ' + hardZero(points[i+2].x)
            + ' ' + hardZero(points[i+2].y);
    }


    if (   points.length - i == 2
        && closed)
    {
        pathData += 
              ' C'
            + ' ' + hardZero(points.at(-2).x)
            + ' ' + hardZero(points.at(-2).y)
            + ' ' + hardZero(points.at(-1).x)
            + ' ' + hardZero(points.at(-1).y)
            + ' ' + hardZero(points.at( 0).x)
            + ' ' + hardZero(points.at( 0).y);
    }


    return pathData;
}



function getSmoothPoints(points, closed, getSegment)
{
    if (points.length < 2)
        return '';


    const bp = [];


    // first point
    let [pp, p, pn] = getSegment(
        closed ? points.at(-1) : points[0], 
        points[0],
        points[1]);

    bp.push(p);


    let _pp = pn;


    // middle segments
    for (let i = 1; i < points.length; i++)
    {
        [pp, p, pn] = getSegment(
            points[i-1], 
            points[i],
            i == points.length-1 
            ? (closed ? points[0] : points[i])
            : points[i+1]);

        if (points[i].smooth)
            [pp, pn] = getSmoothPoint(points[i], pp, p, pn);
            
        bp.push(_pp, pp, p);
   
        _pp = pn;
    }


    if (bp.length > 3)
    {
        if (closed)
        {
            if (   equal(bp[0].x, bp.at(-1).x, 0.01)
                && equal(bp[0].y, bp.at(-1).y, 0.01))
            {
                // last segment
                [pp, p, pn] = getSegment(
                    points.at(-2), 
                    points.at( 0),
                    points.at( 1));

                if (points[0].smooth)
                    [pp, pn] = getSmoothPoint(points[0], pp, p, pn);

                bp[1]           = pn;
                bp[bp.length-2] = pp;
            }
            else
            {
                // last segment
                [pp, p, pn] = getSegment(
                    points.at(-1), 
                    points.at( 0),
                    points.at( 1));

                if (points[0].smooth)
                    [pp, pn] = getSmoothPoint(points[0], pp, p, pn);

                bp.push(_pp, pp, p);

                bp[1]           = pn;
                bp[bp.length-2] = pp;
            }
        }
        else // open
        {
            bp[1]           = addv(bp[0],     mulvs(unitv(subv(bp[2],     bp[0]    )), distv(bp[3],     bp[0]    )/3));
            bp[bp.length-2] = addv(bp.at(-1), mulvs(unitv(subv(bp.at(-3), bp.at(-1))), distv(bp.at(-4), bp.at(-1))/3));
        }
    }


    return bp;
}



function getSmoothPoint(point, pp, p, pn)
{
    if (point.smooth)
    {
        const smooth = point.smooth.value;
        
        pp = addv(p, mulvs(subv(pp, p), smooth));
        pn = addv(p, mulvs(subv(pn, p), smooth));
    }

    return [pp, pn];
}



function getSmoothSegment(_pointP, _point, _pointN)
{
    const _pp = point(_pointP.x.value, _pointP.y.value);
    let   _p  = point(_point .x.value, _point .y.value);
    const _pn = point(_pointN.x.value, _pointN.y.value);


    const v = subv(_pn, _pp);
    
    
    let a = angleDiff(
        anglev(subv(_p, _pp)), 
        anglev(subv(_pn, _p)));
        

    a = Math.abs(a);
    while (a >= Tau/2) a -= Tau;


    const k     = 4 * (Math.sqrt(2) - 1) / 3;        // or use the value 0.55191502449 from http://spencermortensen.com/articles/bezier-circle/
	const kCorr = 0.9993391093366649465402826439248; // slight improvement (see Bézier Curves p. 13, Gernot Hoffmann);

    let f =
        a > Tau/4
        ? 1/3 + (k*kCorr - 1/3) * Math.sin(a)
        : 1/3 + (k*kCorr - 1/3) * (1 - Math.cos(a));
    

    let pp = addv(_p, mulvs(unitv(v), -lengthv(v)/2 * f));
    let pn = addv(_p, mulvs(unitv(v),  lengthv(v)/2 * f));

    pp = saltv(pp); // add salt to get around Figma's issue 
    _p = saltv(_p); // with straight otrhogonal bezier lines
    pn = saltv(pn);


    return [pp, _p, pn];
}



function getSineXSegment(_pointP, _point, _pointN)
{
    const _pp = point(_pointP.x.value, _pointP.y.value);
    const _p  = point(_point .x.value, _point .y.value);
    const _pn = point(_pointN.x.value, _pointN.y.value);

    const  pp = point(_p.x - (_p.x - _pp.x) * 0.3615, _p.y);
    const  pn = point(_p.x + (_pn.x - _p.x) * 0.3615, _p.y);

    return [pp, _p, pn];
}



function getSineYSegment(_pointP, _point, _pointN)
{
    const _pp = point(_pointP.x.value, _pointP.y.value);
    const _p  = point(_point .x.value, _point .y.value);
    const _pn = point(_pointN.x.value, _pointN.y.value);

    const  pp = point(_p.x, _p.y - (_p.y - _pp.y) * 0.3615);
    const  pn = point(_p.x, _p.y + (_pn.y - _p.y) * 0.3615);

    return [pp, _p, pn];
}


class FigmaVectorNetwork
extends FigmaShape
{
    x;
    y;
    width;
    height;
    
    points;
    edges;
    regions;

    networkData;



    constructor(nodeId, objectId, objectName, points, edges, regions)
    {
        super(VECTOR_NETWORK, nodeId, objectId, objectName);
        
        this.points  = points .map(p => p.copy());
        this.edges   = edges  .map(e => e.copy());
        this.regions = regions.map(r => r.copy());


        this.updateNetworkData();


        let bounds = Rect.NaN;

        for (let i = 0; i < this.edges.length; i++)
        {
            bounds = expandRect(
                bounds, 
                bounds3(
                    this.edges[i].start.toPoint(), 
                    this.edges[i].start.toPoint(),
                    this.edges[i].end  .toPoint(),
                    this.edges[i].end  .toPoint()));
        }

        this.createDefaultSpace(
            bounds.x + bounds.width /2,            
            bounds.y + bounds.height/2            
        );
    }



    copy()
    {
        const copy = new FigmaVectorNetwork(
            this.nodeId,
            this.objectId,
            this.objectName,

            this.points, 
            this.edges, 
            this.regions);


        copy.x      = this.x;
        copy.y      = this.y;
        copy.width  = this.width;
        copy.height = this.height;


        copy.copyBase(this);


        return copy;
    }



    updateNetworkData()
    {
        let minX = Number.MAX_SAFE_INTEGER;
        let minY = Number.MAX_SAFE_INTEGER;
        let maxX = Number.MIN_SAFE_INTEGER;
        let maxY = Number.MIN_SAFE_INTEGER;

        for (const p of this.points)
        {
            minX = Math.min(minX, p.x.value);
            minY = Math.min(minY, p.y.value);
            maxX = Math.max(maxX, p.x.value);
            maxY = Math.max(maxY, p.y.value);
        }


        this.x      = minX;
        this.y      = minY;
        this.width  = maxX - minX;
        this.height = maxY - minY;

        this.createDefaultTransformPoints(this.x, this.y, this.width, this.height);


        this.networkData = getNetworkData(this.points, this.edges, this.regions);
    }



    getBounds()
    {
        let bounds = Rect.NaN;

        for (let i = 0; i < this.edges.length; i++)
        {
            const edge = this.edges[i];

            const s  = edge.start;
            const e  = edge.end;
            let   st = edge.startTangent;
            let   et = edge.endTangent;

            if (!st.isValid()) st = s.copy();
            if (!et.isValid()) et = e.copy();

            bounds = expandRect(
                bounds, 
                bounds3(
                    s .toPoint(), 
                    st.toPoint(),
                    et.toPoint(),
                    e .toPoint()));
        }

        return bounds;
    }



    toValue()
    {
        return FigmaVectorNetwork.fromObject(this);
    }



    toData()
    {
        return [
            ...super.toData(),
   
            /* 21 */ this.x,
            /* 22 */ this.y,
            /* 23 */ this.width,
            /* 24 */ this.height,

            /* 25 */ this.networkData
        ];
    }
}



function getNetworkData(points, edges, _regions)
{
    const vertices = [];
    const segments = [];
    const regions  = [];


    for (const point of points)
    {
        let join;
        let cap;

        switch (point.join.value)
        {
            case 0: join = 'MITER'; break;
            case 1: join = 'BEVEL'; break;
            case 2: join = 'ROUND'; break;
        }
    
        switch (point.cap.value)
        {
            case 0: cap = 'NONE';   break;
            case 1: cap = 'SQUARE'; break;
            case 2: cap = 'ROUND';  break;
        }
    
        vertices.push(
        {
            x:            point.x.value,
            y:            point.y.value,
            strokeJoin:   join,
            strokeCap:    cap,
            cornerRadius: point.round.value
        });
    }


    for (const edge of edges)
    {
        segments.push(
        {
            start: points.findIndex(p => p.uniqueId == edge.start.uniqueId),
            end:   points.findIndex(p => p.uniqueId == edge.end  .uniqueId)
        });
    }


    for (const region of _regions)
    {
        const loops = [];

        for (const _loop of region.loops.items)
        {
            const loop = [];

            for (const _edge of _loop.items)
                loop.push(edges.findIndex(e => e.uniqueId == _edge.uniqueId));

            loops.push(loop);
        }


        regions.push(
        {
            windingRule: region.winding.value == 1 ? 'NONZERO' : 'EVENODD',
            loops:       loops,
            fills:       getObjectFills(region.fills)
        });
    }


    let networkData = 
    {
        vertices: vertices,
        segments: segments,
        regions:  regions
    };


    return networkData;
}


class FigmaTrapeze
extends FigmaVectorPath
{
    width;
    height;

    round;
    bias;



    constructor(nodeId, objectId, objectName, x, y, width, height, round, bias)
    {
        const tw = width * (1 + Math.min(0,  bias/100));
        const bw = width * (1 + Math.min(0, -bias/100));
        
        const tx = x + (width - tw) / 2;
        const bx = x + (width - bw) / 2;

        const points =
        [
            PointValue.create(nodeId, tx,      y         ),
            PointValue.create(nodeId, bx,      y + height),
            PointValue.create(nodeId, bx + bw, y + height),
            PointValue.create(nodeId, tx + tw, y         )
        ];

    
        super(
            nodeId, 
            objectId,
            objectName, 
            points,
            1, // closed
            0, // linear
            0, // even-odd winding
            round);

        this.type   = TRAPEZE;

        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;

        this.round  = round;
        this.bias   = bias;

        
        this.createDefaultSpace(
            x + width /2, 
            y + height/2);
    }



    copy()
    {
        const copy = new FigmaTrapeze(
            this.nodeId,
            this.objectId,
            this.objectName,

            this.x,
            this.y,
            this.width,
            this.height,
            
            this.round,
            this.bias);

            
        copy.pathPoints = [...this.pathPoints];
        copy.pathData   = this.pathData;
    
        copy.copyBase(this);

        //copy.updatePathPoints();


        return copy;
    }



    toValue()
    {
        return TrapezeValue.fromObject(this);
    }
}



class FigmaPolygon
extends FigmaShape
{
    x;
    y;
    width;
    height;
    round;
    corners;



    constructor(nodeId, objectId, objectName, x, y, width, height, round, corners)
    {
        super(POLYGON, nodeId, objectId, objectName);
        
        this.x       = x;
        this.y       = y;
        this.width   = width;
        this.height  = height;

        this.round   = round;
        this.corners = corners;

        
        this.createDefaultSpace(
            x + width /2, 
            y + height/2);
    }



    copy()
    {
        const copy = new FigmaPolygon(
            this.nodeId,
            this.objectId,
            this.objectName,

            this.x,
            this.y,
            this.width,
            this.height,
            
            this.round,
            this.corners);


        copy.copyBase(this);


        return copy;
    }



    toValue()
    {
        return PolygonValue.fromObject(this);
    }



    toData()
    {
        return [
            ...super.toData(),
   
            /* 24 */ this.x,
            /* 25 */ this.y,
            /* 26 */ this.width,
            /* 27 */ this.height,

            /* 28 */ this.round * Math.abs(this.scaleCorners),
            /* 29 */ this.corners
        ];
    }
}



class FigmaStar
extends FigmaShape
{
    x;
    y;
    width;
    height;

    round;
    points;
    convex;



    constructor(nodeId, objectId, objectName, x, y, width, height, round, points, convex)
    {
        super(STAR, nodeId, objectId, objectName);
        
        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;

        this.round  = round;
        this.points = points;
        this.convex = convex;

        
        this.createDefaultSpace(
            x + width /2, 
            y + height/2);
    }



    copy()
    {
        const copy = new FigmaStar(
            this.nodeId,
            this.objectId,
            this.objectName,

            this.x,
            this.y,
            this.width,
            this.height,

            this.round,
            this.points,
            this.convex);

        copy.copyBase(this);

        return copy;
    }



    toValue()
    {
        return StarValue.fromObject(this);
    }



    toData()
    {
        return [
            ...super.toData(),
   
            /* 24 */ this.x,
            /* 25 */ this.y,
            /* 26 */ this.width,
            /* 27 */ this.height,

            /* 28 */ this.round * Math.abs(this.scaleCorners),
            /* 29 */ this.points,
            /* 20 */ this.convex
        ];
    }
}



class FigmaText
extends FigmaShape
{
    text;
    
    x;
    y;
    width;
    height;
    
    figWidth;
    figHeight;
    
    font;
    size;
    style;
    
    alignX;
    alignY;
    
    lineHeight;
    letterSpacing;



    constructor(nodeId, objectId, objectName, text, x, y, width, height, font, size, style, alignX, alignY, lineHeight, letterSpacing)
    {
        super(TEXT_SHAPE, nodeId, objectId, objectName);
        
        this.text          = text;
    
        this.x             = x;
        this.y             = y;
        this.width         = width;
        this.height        = height;
    
        this.figWidth      = width;
        this.figHeight     = height;
    
        this.font          = font;
        this.size          = size;
        this.style         = style;
    
        this.alignX        = alignX;
        this.alignY        = alignY;
    
        this.lineHeight    = lineHeight;
        this.letterSpacing = letterSpacing;

        
        this.createDefaultSpace(
            x + width /2, 
            y + height/2);
    }



    copy()
    {
        const copy = new FigmaText(
            this.nodeId,
            this.objectId,
            this.objectName,
    
            this.text,
    
            this.x,
            this.y,
            this.width,
            this.height,
    
            this.font,
            this.size,
            this.style,
    
            this.alignX,
            this.alignY,
    
            this.lineHeight,
            this.letterSpacing);


        copy.figWidth  = this.figWidth;
        copy.figHeight = this.figHeight;


        copy.copyBase(this);


        return copy;
    }



    toValue()
    {
        return TextShapeValue.fromObject(this);
    }



    toJsonObject()
    {
        return {
            ...super.toJsonObject(),
   
            x:             this.x,
            y:             this.y,
            width:         this.width,
            height:        this.height,

            figWidth:      this.figWidth,
            figHeight:     this.figHeight,

            text:          this.text,

            font:          this.font,
            size:          this.size,
            style:         this.style,

            alignX:        this.alignX,
            alignY:        this.alignY,
            
            lineHeight:    this.lineHeight,
            letterSpacing: this.letterSpacing
        };
    }



    toData()
    {
        return [
            ...super.toData(),
   
            /* 24 */ this.x,
            /* 25 */ this.y,
            /* 26 */ this.width,
            /* 27 */ this.height,
            
            /* 28 */ this.figWidth,
            /* 29 */ this.figHeight,
            
            /* 30 */ this.text,

            /* 31 */ this.font,
            /* 32 */ this.size,
            /* 33 */ this.style,
            
            /* 34 */ this.alignX,
            /* 35 */ this.alignY,
            
            /* 36 */ this.lineHeight,
            /* 37 */ this.letterSpacing
        ];
    }
}



class FigmaPoint
extends FigmaShape
{
    x;
    y;
    smooth;



    constructor(nodeId, objectId, objectName, x, y, smooth = 1, isDeco = false, isCenter = false, isXform = false)
    {
        super(POINT, nodeId, objectId, objectName, isDeco, isXform);
        
        this.x        = x;
        this.y        = y;
        this.smooth   = smooth;
        this.isCenter = isCenter;

        
        this.createDefaultSpace(x, y);

        this.createDefaultTransform(x, y);
    }



    copy()
    {
        const copy = new FigmaPoint(
            this.nodeId,
            this.objectId,
            this.objectName, 
            this.x,
            this.y,
            this.smooth,
            this.isDeco,
            this.isCenter);

        copy.copyBase(this);

        return copy;
    }



    getBounds()
    {
        return new Rect(
            this.x - 0.005, 
            this.y - 0.005, 
            0.01, 
            0.01);
    }



    checkFlipped(flipX, flipY)
    {

    }



    toPoint()
    {
        return point(this.x, this.y);
    }



    toValue()
    {
        return PointValue.fromObject(this);
    }



    toData()
    {
        return [
            ...super.toData(),
   
            /* 24 */ this.x,
            /* 25 */ this.y
        ];
    }
}



class FigmaBoolean
extends FigmaShape
{
    operation;

    children;



    constructor(nodeId, objectId, objectName, operation, children = [])
    {
        super(SHAPE_BOOLEAN, nodeId, objectId, objectName);
        
        this.operation = operation;
        
        this.children  = children.map(c => c.copy());
    }



    copy()
    {
        const copy = new FigmaBoolean(
            this.nodeId,
            this.objectId,
            this.objectName,

            this.operation,
            this.children);

        copy.copyBase(this);
        
        return copy;
    }



    getBounds()
    {
        return getObjBounds(this.children);
    }



    applyTransform(xform, affectSpace)
    {
        for (const obj of this.children)
            obj.applyTransform(xform, affectSpace);
    }



    toJsonObject()
    {
        return {
            ...super.toJsonObject(),
   
            operation: this.operation,
            children:  this.children
        };
    }



    toData()
    {
        return [
            ...super.toData(),
   
            /* 24 */ this.children.map(o => o.toData()),
            /* 25 */ this.operation
        ];
    }
}


class FigmaArcPath
extends FigmaVectorPath
{
    position;
    // _x;
    // _y;
    // _width;
    // _height;

    start;
    sweep;

    

    constructor(nodeId, objectId, objectName, pos, x, y, width, height, start, sweep)
    {
        let points = makeArc_(
            point(
                x + width /2, 
                y + height/2), 
            width/2,  
            start, 
            start + sweep);
            
        points = points.map(p => PointValue.fromPoint(nodeId, p));


        points.forEach(p => 
        {
            p.y.value = 
                pos > 0
                ? p.y.value * height/nozero(width)
                : height/2 + (p.y.value - height/2) * height/nozero(width);

            if (   pos == 0
                && width < 0) 
                p.x.value += width;
        });

        if (width  < 0) width  *= -1;
        if (height < 0) height *= -1;


        super(
            nodeId, 
            objectId,
            objectName,
            points,
            0,  // open
            2,  // cubic
            0,  // even-odd winding
            0); // no round
        

        this.position = pos;
        this.x       = x;
        this.y       = y;
        this.width   = width;
        this.height  = height;

        this.start    = start;
        this.sweep    = sweep;


        this.createDefaultSpace(
            x + width /2,
            y + height/2);
    }



    copy()
    {
        const copy = new FigmaArcPath(
            this.nodeId,
            this.objectId,
            this.objectName,

            this.position,
            this.x,
            this.y,
            this.width,
            this.height,
            
            this.start,
            this.sweep);


        copy.pathPoints = [...this.pathPoints];
        copy.pathData   = this.pathData;

        copy.copyBase(this);


        return copy;
    }
}


class FigmaWavePath
extends FigmaVectorPath
{
    shape;
    _x;
    _y;
    _width;
    amplitude;
    frequency;
    offset;
    alignX;
    alignY;

    

    constructor(nodeId, objectId, objectName, shape, x, y, width, amplitude, frequency, offset, alignX, alignY)
    {
        let points = makeWave(
            shape, 
            x,
            y,
            width, 
            amplitude, 
            frequency,
            offset,
            alignX,
            alignY);

        points = points.map(p => PointValue.fromPoint(nodeId, p));


        super(
            nodeId, 
            objectId,
            objectName,
            points,
            0,                  // open
            shape == 4 ? 2 : 0, // cubic
            0,                  // even-odd winding
            0);                 // no round
        

        this.shape     = shape;
        this._x        = x;
        this._y        = y;
        this._width    = width;
        this.amplitude = amplitude;
        this.frequency = frequency;
        this.offset    = offset;
        this.alignX    = alignX;
        this.alignY    = alignY;


        let height = amplitude;
        
        this.createDefaultSpace(
            x + width /2,
            y + height/2);
    }



    copy()
    {
        const copy = new FigmaWavePath(
            this.nodeId,
            this.objectId,
            this.objectName,

            this.shape,
            this._x,
            this._y,
            this._width,
            this.amplitude,
            this.frequency,
            this.offset,
            this.alignX,
            this.alignY);


        copy.pathPoints = [...this.pathPoints];
        copy.pathData   = this.pathData;

        copy.copyBase(this);


        return copy;
    }
}


class FigmaShapeGroup
extends FigmaShape
{
    children;



    constructor(nodeId, objectId, objectName, children = [])
    {
        super(SHAPE_GROUP, nodeId, objectId, objectName);
        
        this.children = children.map(c => c.copy());
    }



    copy()
    {
        const copy = new FigmaShapeGroup(
            this.nodeId,
            this.objectId,
            this.objectName,

            this.children);

        copy.copyBase(this);

        return copy;
    }



    getCount()
    {
        let nObjects =
            this.children.length > 0
            ? super.getCount()
            : 0;

        for (const obj of this.children)
            nObjects += obj.getCount();

        return nObjects;
    }



    createDefaultSpace(cx = 0, cy = 0)
    {
        super.createDefaultSpace(cx, cy);

        for (const obj of this.children)
            obj.createDefaultSpace(cx, cy);
    }



    resetSpace(bounds, singlePoint = false, cx = 0.5, cy = 0.5, units = 0)
    {
        super.resetSpace(bounds, false, cx, cy, units);

        for (const obj of this.children)
            obj.resetSpace(bounds, false, cx, cy, units);
    }



    getBounds()
    {
        return getObjBounds(this.children);
    }



    applyTransform(xform, affectSpace)
    {
        for (const obj of this.children)
            obj.applyTransform(xform, affectSpace);
    }



    toJsonObject()
    {
        return {
            ...super.toJsonObject(),
   
            children: this.children
        };
    }



    toData()
    {
        return [
            ...super.toData(),
   
            /* 24 */ this.children.map(o => o.toData())
        ];
    }
}


class FigmaFrame
extends FigmaShape
{
    x;
    y;
    width;
    height;

    round;
    
    clip;

    children;



    constructor(nodeId, objectId, objectName, x, y, width, height, round, clip, children = [])
    {
        super(FRAME, nodeId, objectId, objectName);
        
        this.x        = x;
        this.y        = y;
        this.width    = width;
        this.height   = height;
    
        this.round    = round;

        this.clip     = clip;
    
        this.children = children.map(c => c.copy());

        this.createDefaultSpace(
            x + width /2, 
            y + height/2);
    }



    copy()
    {
        const copy = new FigmaFrame(
            this.nodeId,
            this.objectId,
            this.objectName,
    
            this.x,
            this.y,
            this.width,
            this.height,
    
            this.round,
  
            this.clip,
    
            this.children);


        copy.copyBase(this);


        return copy;
    }



    getCount()
    {
        let nObjects = super.getCount();

        for (const obj of this.children)
            nObjects += obj.getCount();

        return nObjects;
    }


    
    checkFlipped(flipX, flipY)
    {
        super.checkFlipped(flipX, flipY);

        for (const obj of this.children)
        {
            obj.checkFlipped(flipX, flipY);

            if (flipX)
            {
                obj.xp0.x = this.width - obj.xp0.x;
                obj.xp1.x = this.width - obj.xp1.x;
                obj.xp2.x = this.width - obj.xp2.x;
            }

            if (flipY)
            {
                obj.xp0.y = this.height - obj.xp0.y;
                obj.xp1.y = this.height - obj.xp1.y;
                obj.xp2.y = this.height - obj.xp2.y;
            }
        }
    }



    toJsonObject()
    {
        return {
            ...super.toJsonObject(),
   
            x:        this.x,
            y:        this.y,
            width:    this.width,
            height:   this.height,
        
            round:    this.round,

            clip:     this.clip,
        
            children: this.children
        };
    }



    toData()
    {
        return [
            ...super.toData(),
   
            /* 24 */ this.x,
            /* 25 */ this.y,
            /* 26 */ this.width,
            /* 27 */ this.height,

            /* 28 */ this.round,

            /* 29 */ this.clip,

            /* 30 */ this.children.map(o => o.toData())
        ];
    }
}






class FigmaVariable
extends FigmaObject
{
    variableType;
    variableValue;

    

    constructor(nodeId, variableId, variableName, variableValue)
    {
        super(VARIABLE, nodeId, variableId, variableName);
        

        if (variableValue)
        {
            switch (variableValue.type)
            {
                case NUMBER_VALUE: 
                    this.variableType = 
                        variableValue.isBoolean 
                        ? 'BOOLEAN' 
                        : 'FLOAT'; 

                    this.variableValue = variableValue.toNumber();
                    
                    break;


                case TEXT_VALUE: 
                    this.variableType  = 'STRING';
                    this.variableValue = variableValue.toString();
                    break;


                case COLOR_VALUE: 
                    this.variableType  = 'COLOR';
                    this.variableValue = variableValue.toRgbObject();
                    break;


                case FILL_VALUE: 
                    this.variableType  = 'COLOR';
                    this.variableValue = variableValue.toRgbaObject();
                    break;
            }
        }
    }



    copy()
    {
        const copy = new FigmaVariable(
            this.nodeId,
            this.variableId,
            this.objectName,
            null);


        copy.variableType  = this.variableType;
        copy.variableValue = this.variableValue;


        copy.copyBase(this);


        return copy;
    }



    toValue()
    {
        return VariableValue.fromObject(this);
    }



    toData()
    {
        return [
            ...super.toData(),
   
            /* 10 */ this.variableType,
            /* 11 */ this.variableValue
        ];
    }
}



class FigmaColorStyle
{
    type;
    
    nodeId = '';

    styleId;
    styleName;

    paints = [];

//    existing;



    constructor(nodeId, styleId, styleName)
    {
        this.type      = COLOR_STYLE;
        this.nodeId    = nodeId;

        this.styleId   = styleId;
        this.styleName = styleName;
    }



    copy()
    {
        const copy = new FigmaColorStyle(this.nodeId, this.styleId, this.styleName);

//        copy.existing = this.existing;

        return copy;
    }



    toData()
    {
        return [
        /* 0 */ this.type,
        /* 1 */ this.nodeId,

        /* 2 */ this.styleId,
        /* 3 */ this.styleName,
        
        /* 4 */ this.paints
        ];
    }
}


class GNode
{
    static nextUniqueId = 0;

    type;


    valid; // has been evaluated

    listId           = -1;
    uniqueId;

    cached           = true;
    unknown          = false;

    loopId           = NULL;

    currentIteration = 0;
    iterated         = false;


    updateValues     = null;



    constructor(type, options) 
    {
        this.type    = type;

        if (options && options.cached ) this.cached  = options.cached;
        if (options && options.unknown) this.unknown = options.unknown;
     
        this.uniqueId = GNode.nextUniqueId++;
    }



    reset()
    {
        //this.listId           = -1;
    
        //this.cached           = true;
        //this.unknown          = false;
    
        //this.loopId           = NULL;
    
        //this.currentIteration = 0;
        //this.iterated         = false;
    
        this.updateValues = null;
    }



    copy()
    {
        consoleError('abstract type GNode cannot be copied');
        return null;
    }



    copyBase(base)
    {
        //this.data     = clone(base.data);
        this.uniqueId = base.uniqueId;
    }



    getConditionNode()
    {
        if (    this.input
            &&  this.input.getConditionNode
            && !this.input.notCondition)
            return this.input.getConditionNode();
        
        return this;
    }

    

    toValue()
    {
        return null;
    }



    toString() 
    { 
        return this.type; 
    }



    toJson()
    {
        return this.toString();
    }



    isValid() // is a valid value
    {
        return false;
    }


    
    validate()
    {
        this.valid = true;
    }



    invalidate()
    {
        this.valid = false;
    }



    pushValueUpdates(parse)
    {

    }



    invalidateInputs(parse, from, force = false)
    {
        if (   this.unknown
            || force)
            this.valid = false;

        return true;
    }



    initLoop(parse, nodeId)
    {

    }



    invalidateLoop(parse, nodeId)
    {

    }



    iterateLoop(parse)
    {

    }



    resetLoop(parse, nodeId)
    {

    }    
}



class GValue
//extends GNode
{
    type;
    valueId;

    customParams = []; // [[name, GValue]]

    objects      = null;



    constructor(type) 
    {
        //super(type, options);

        this.type    = type;

        this.valueId = '';
    }



    reset() {}



    copy()
    {
        consoleError('abstract class GValue cannot be copied');
        return null;
    }



    copyBase(base)
    {
        //super.copyBase(base);
        
        this.valueId  = base.valueId;
        this.uniqueId = base.uniqueId;

        this.copyCustomParams(base);

        if (base.objects)
            this.copyObjects(base.objects);
    }



    copyCustomParams(base)
    {
        for (const param of base.customParams)
            this.customParams.push([param[0], param[1].copy()]);
    }



    copyObjects(objects)
    {
        this.objects = objects.map(o => o.copy());
    }



    // eval()
    // {
    //     return this;
    // }



    hasInitValue()
    {
        return false;
    }



    toValue()
    {
        return this.copy();
    }



    toJson() 
    { 
        return this.toString(); 
    }



    toString() 
    { 
        return this.type; 
    }



    toDisplayString()
    {
        return this.toString();
    }



    toJsCode(gen)
    {
        consoleError('invalid abstract method');
        return '';
    }



    getNaN()
    {
        consoleError('invalid abstract method');
        return null;
    }



    isCached()
    {
        return true;
    }



    pushValueUpdates(parse)              {}
    invalidateInputs(parse, from, force) {}
    iterateLoop     (parse)              {}
}



function parseValueFromType(type, value)
{
    switch (type)
    {
        case            ANY_VALUE: return parseNullValue         (value)[0];

        case           LIST_VALUE: 
        case    NUMBER_LIST_VALUE: 
        case      TEXT_LIST_VALUE: 
        case     SHAPE_LIST_VALUE: return parseListValue         (value)[0];

        case         NUMBER_VALUE: return parseNumberValue       (value)[0];
        case           TEXT_VALUE: return parseTextValue         (value)[0];
        case          COLOR_VALUE: return parseColorValue        (value)[0];

        case           FILL_VALUE: return parseFillValue         (value)[0];
        case     COLOR_STOP_VALUE: return parseColorStopValue    (value)[0];
        case       GRADIENT_VALUE: return parseGradientValue     (value)[0];
        case         STROKE_VALUE: return parseStrokeValue       (value)[0];
        case    DROP_SHADOW_VALUE: return parseDropShadowValue   (value)[0];
        case   INNER_SHADOW_VALUE: return parseInnerShadowValue  (value)[0];
        case     LAYER_BLUR_VALUE: return parseLayerBlurValue    (value)[0];
        case      BACK_BLUR_VALUE: return parseBackBlurValue     (value)[0];
        case    LAYER_BLEND_VALUE: return parseLayerBlendValue   (value)[0];
        case     LAYER_MASK_VALUE: return parseLayerMaskValue    (value)[0];

        case      RECTANGLE_VALUE: return parseRectangleValue    (value)[0];
        case           LINE_VALUE: return parseLineValue         (value)[0];
        case        ELLIPSE_VALUE: return parseEllipseValue      (value)[0];
        case        TRAPEZE_VALUE: return parseTrapezeValue      (value)[0];
        case        POLYGON_VALUE: return parsePolygonValue      (value)[0];
        case           STAR_VALUE: return parseStarValue         (value)[0];
        case     TEXT_SHAPE_VALUE: return parseTextShapeValue    (value)[0];
        case          POINT_VALUE: return parsePointValue        (value)[0];
        case    VECTOR_PATH_VALUE: return parseVectorPathValue   (value)[0];
        case  VECTOR_VERTEX_VALUE: return parseVectorVertexValue (value)[0];
        case    VECTOR_EDGE_VALUE: return parseVectorEdgeValue   (value)[0];
        case  VECTOR_REGION_VALUE: return parseVectorRegionValue (value)[0];
        case VECTOR_NETWORK_VALUE: return parseVectorNetworkValue(value)[0];
        case  SHAPE_BOOLEAN_VALUE: return parseShapeBooleanValue (value)[0];
        case    SHAPE_GROUP_VALUE: return parseShapeGroupValue   (value)[0];
        case       ARC_PATH_VALUE: return parseArcPathValue      (value)[0];
        case      WAVE_PATH_VALUE: return parseWavePathValue     (value)[0];
        case          FRAME_VALUE: return parseFrameValue        (value)[0];

        case       VARIABLE_VALUE: return parseVariableValue     (value)[0];

        case           NULL_VALUE: return null;
        
        default: 
            console.error('cannot parse unknown type \'' + type + '\'');
            return null;
    }
}



function displayValue(type, value)
{
    if (   type == NUMBER_VALUE
        && value.indexOf(',') < 0)
        return value;


    switch (type)
    {
        case            ANY_VALUE: return parseNullValue         (value)[0].toDisplayString();
        case           LIST_VALUE: return parseListValue         (value)[0].toDisplayString();

        case         NUMBER_VALUE: return parseNumberValue       (value)[0].toDisplayString();
        case           TEXT_VALUE: const val = parseTextValue    (value)[0]; return val == '' ? '\'\'' : val.toDisplayString();
        case          COLOR_VALUE: return parseColorValue        (value)[0].toDisplayString();
        case           FILL_VALUE: return parseFillValue         (value)[0].toDisplayString();
        case     COLOR_STOP_VALUE: return parseColorStopValue    (value)[0].toDisplayString();
        case       GRADIENT_VALUE: return parseGradientValue     (value)[0].toDisplayString();
        case         STROKE_VALUE: return parseStrokeValue       (value)[0].toDisplayString();
        case    DROP_SHADOW_VALUE: return parseDropShadowValue   (value)[0].toDisplayString();
        case   INNER_SHADOW_VALUE: return parseInnerShadowValue  (value)[0].toDisplayString();
        case     LAYER_BLUR_VALUE: return parseLayerBlurValue    (value)[0].toDisplayString();
        case      BACK_BLUR_VALUE: return parseBackBlurValue     (value)[0].toDisplayString();
        case    LAYER_BLEND_VALUE: return parseLayerBlendValue   (value)[0].toDisplayString();
        case     LAYER_MASK_VALUE: return parseLayerMaskValue    (value)[0].toDisplayString();

        case      RECTANGLE_VALUE: return parseRectangleValue    (value)[0].toDisplayString();
        case           LINE_VALUE: return parseLineValue         (value)[0].toDisplayString();
        case        ELLIPSE_VALUE: return parseEllipseValue      (value)[0].toDisplayString();
        case        TRAPEZE_VALUE: return parseTrapezeValue      (value)[0].toDisplayString();
        case        POLYGON_VALUE: return parsePolygonValue      (value)[0].toDisplayString();
        case           STAR_VALUE: return parseStarValue         (value)[0].toDisplayString();
        case     TEXT_SHAPE_VALUE: return parseTextShapeValue    (value)[0].toDisplayString();
        case          POINT_VALUE: return parsePointValue        (value)[0].toDisplayString();
        case    VECTOR_PATH_VALUE: return parseVectorPathValue   (value)[0].toDisplayString();
        case  VECTOR_VERTEX_VALUE: return parseVectorVertexValue (value)[0].toDisplayString();
        case    VECTOR_EDGE_VALUE: return parseVectorEdgeValue   (value)[0].toDisplayString();
        case  VECTOR_REGION_VALUE: return parseVectorRegionValue (value)[0].toDisplayString();
        case VECTOR_NETWORK_VALUE: return parseVectorNetworkValue(value)[0].toDisplayString();
        case  SHAPE_BOOLEAN_VALUE: return parseShapeBooleanValue (value)[0].toDisplayString();
        case    SHAPE_GROUP_VALUE: return parseShapeGroupValue   (value)[0].toDisplayString();
        case          FRAME_VALUE: return parseFrameValue        (value)[0].toDisplayString();
        
        case       VARIABLE_VALUE: return parseVariableValue     (value)[0].toDisplayString();

        case           NULL_VALUE: return NULL_VALUE;
    }


    consoleError('cannot display value of type \'' + type + '\'');
}



function nanFromType(type)
{
    switch (type)
    {
        case            LIST_VALUE: return          ListValue.NaN;

        case          NUMBER_VALUE: return        NumberValue.NaN;
        case            TEXT_VALUE: return        new TextValue();
        case           COLOR_VALUE: return         ColorValue.NaN;
        case            FILL_VALUE: return          FillValue.NaN;
        case      COLOR_STOP_VALUE: return     ColorStopValue.NaN;
        case        GRADIENT_VALUE: return      GradientValue.NaN;
        case          STROKE_VALUE: return        StrokeValue.NaN;
        case     DROP_SHADOW_VALUE: return    DropShadowValue.NaN;
        case    INNER_SHADOW_VALUE: return   InnerShadowValue.NaN;
        case      LAYER_BLUR_VALUE: return     LayerBlurValue.NaN;
        case       BACK_BLUR_VALUE: return      BackBlurValue.NaN;
        case     LAYER_BLEND_VALUE: return    LayerBlendValue.NaN;
        case      LAYER_MASK_VALUE: return     LayerMaskValue.NaN;

        case       RECTANGLE_VALUE: return     RectangleValue.NaN;
        case            LINE_VALUE: return          LineValue.NaN;
        case         ELLIPSE_VALUE: return       EllipseValue.NaN;
        case         POLYGON_VALUE: return       PolygonValue.NaN;
        case            STAR_VALUE: return          StarValue.NaN;
        case      TEXT_SHAPE_VALUE: return     TextShapeValue.NaN;
        case           POINT_VALUE: return         PointValue.NaN;
        case     VECTOR_PATH_VALUE: return    VectorPathValue.NaN;
        case   VECTOR_VERTEX_VALUE: return  VectorVertexValue.NaN;
        case     VECTOR_EDGE_VALUE: return    VectorEdgeValue.NaN;
        case   VECTOR_REGION_VALUE: return  VectorRegionValue.NaN;
        case  VECTOR_NETWORK_VALUE: return VectorNetworkValue.NaN;
        case   SHAPE_BOOLEAN_VALUE: return  ShapeBooleanValue.NaN;
        case     SHAPE_GROUP_VALUE: return    ShapeGroupValue.NaN;
        case           FRAME_VALUE: return         FrameValue.NaN;

        case        VARIABLE_VALUE: return      VariableValue.NaN;

        case            NULL_VALUE: return        new NullValue();
    }

    consoleError('cannot determine null value from type \'' + type + '\'');
}


class GOperator
extends GNode
{
    nodeId;
    nodeName;

    topLevel;

    value;
    
    customParams = []; // [[name, GValue]]
    options      = {};
    updateValues = [];

   
    
    constructor(type, nodeId, options)
    {
        super(type, options);

        this.nodeId   = nodeId;
        this.nodeName = options.nodeName;

        this.options  = clone(options);

        this.valid    = false;
        this.topLevel = false;

        this.value    = null;
    }



    reset()
    {
        this.customParams = [];
        this.options      = {};
        this.updateValues = [];
    }



    copyBase(base)
    {
        super.copyBase(base);
        
        this.nodeId   = base.nodeId;
        this.nodeName = base.nodeName;

        this.copyCustomParams(base);

        this.options  = clone(base.options);

        this.valid    = base.valid;
        this.topLevel = base.topLevel;

        if (base.value) this.value = base.value.copy();
    }



    copyCustomParams(base)
    {
        for (const param of base.customParams)
            this.customParams.push([param[0], param[1].copy()]);
    }



    paramFromId(paramId)
    {
        return paramId == 'value'
            ?  this.value
            :  this[paramId];
    }



    isCached()
    {
        return this.options.cached
            && this.valid;
    }



    async eval(parse)
    {
        // calculate and add value update here

        return this;
    }



    async evalObjects(parse)
    {

    }



    copyObjects(value, listId = -1)
    {
        const objects = getValidObjects(value);
        const copies  = [];
                        
        for (let i = 0; i < objects.length; i++)
        {
            const obj = copyFigmaObject(objects[i]);
    
            obj.nodeId   = this.nodeId;
            obj.listId   = listId;
            
            obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;
    
            copies.push(obj);
        }

        return copies;
    }
    
    

    outputType()
    {
        return this.value
            ? new TextValue(
                isListValueType(this.value.type)
                ? finalListTypeFromItems(this.value.items)
                : this.value.type)
            : new TextValue(ANY_VALUE);
    }



    outputListType()
    {
        return this.outputType();
        //return this.value
        //     ? new TextValue(finalListTypeFromItems(this.value.items))
        //     : TextValue.NaN.copy();
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.unknown)
            this.valid = false;

        this.iterated = false;
    }



    initLoop(parse, nodeId)
    {
        this.loopId           = nodeId;
        this.currentIteration = 0;
    }



    invalidateLoop(parse, nodeId)
    {
        this.valid = false;
    }



    iterateLoop(parse)
    {
        const repeatIndex = parse.repeats.findIndex(r => r.repeatId == this.loopId);
        
        // if (this.nodeId == 'sequence')
        // {
        //     console.log('repeatIndex = ', repeatIndex);
        //     console.log('this.iterated = ', this.iterated);
        // }

        if (   (   repeatIndex < 0
                || repeatIndex == parse.repeats.length-1)
            && !this.iterated)
        {
            //console.log('iterating');
            this.currentIteration++;
            this.iterated = true;
        }
    }



    iterateCache(parse, from)
    {

    }



    resetLoop(parse, nodeId)
    {
        this.valid            = false;
        this.currentIteration = 0;
    }    



    setUpdateValues(parse, values, add = false)
    {
        if (    parse.repeats.length == 0
            ||  this.unknown && parse.repeats[0].total == 0
            || !this.unknown
            ||  parse.repeats.at(-1).currentIteration == 0
            ||  parse.repeats.at(-1).currentIteration == parse.repeats.at(-1).total-1)
        {
            if (add) this.updateValues.push(...values);
            else     this.updateValues = [...values];
        }
        else if (!add)
            this.updateValues = [];
    }



    pushValueUpdates(parse)
    {        
        if (!this.updateValues)
            return;

        for (const value of this.updateValues)
            genPushUpdateValue(parse, this.nodeId, value[0], value[1]);

        //if (this.isValid())
        this.updateValues = [];
    }



    updateValueObjects()
    {
        if (   !this.value
            || !this.value.objects)
            return;


        for (let i = 0; i < this.value.objects.length; i++)
        {
            const obj     = this.value.objects[i];

            obj.nodeId    =  this.nodeId;
            obj.objectId +=  OBJECT_SEPARATOR + this.nodeId;
            obj.listId    = -1;
        }
    }



    // updateValueObjectsFromInput(input)
    // {
    //     const inputObjects = this.copyObjects(input);
            
    //     for (const obj of inputObjects)
    //     {
    //         obj.objectId += OBJECT_SEPARATOR + i;
    //         obj.itemIndex = i;
    //     }

    //     this.value.objects.push(...inputObjects);
    // }



    setConditionInput(input)
    {

    }
}



function allInputsAreCondensedLists(inputs)
{
    for (const input of inputs)
    {
        if (   !isValueListOfCondensedLists(input)
            && !isListValueType(input)
            && input.condensed !== true) 
            return false;
    }

    return true;
}



async function evalValue(_value, parse, nan = () => new NullValue())
{
    let value = 
        _value 
        ? (await _value.eval(parse)).toValue() 
        : null;

    if (   (    value 
            && !value.isValid())
        && nan) 
        value = nan();

    return value;
}



async function evalNumberValue(_value, parse) 
{ 
    let value = await evalValue(_value, parse, () => NumberValue.NaN.copy()); 

    if (   value
        && value.type == TEXT_VALUE)
        value = new NumberValue(parseFloat(value.value));

    return value;                
}



async function evalNumberOrListValue(_value, parse) 
{ 
    let value = await evalValue(_value, parse, () => NumberValue.NaN.copy()); 

    if (   value
        && value.type == TEXT_VALUE)
        value = new NumberValue(parseFloat(value.value));

    else if (value
          && value.type == LIST_VALUE
          && finalListTypeFromItems(value.items) == TEXT_LIST_VALUE)
    {
        const condensed = value.condensed;

        value = new ListValue(value.items.map(i => new NumberValue(parseFloat(i.value))));
        value.condensed = condensed;
    }

    return value;                
}



async function evalTextValue(_value, parse) 
{ 
    let value = await evalValue(_value, parse, () => new TextValue());

    if (   value
        && value.type == NUMBER_VALUE)
        value = new TextValue(value.value.toString());

    return value;                
}



async function evalTextOrListValue(_value, parse) 
{ 
    let value = await evalValue(_value, parse, () => new TextValue());

    if (   value
        && value.type == NUMBER_VALUE)
        value = new TextValue(value.value.toString());

    else if (value
          && value.type == LIST_VALUE
          && finalListTypeFromItems(value.items) == NUMBER_LIST_VALUE)
    {
        const condensed = value.condensed;
        
        value = new ListValue(value.items.map(i => new TextValue(i.value.toString())));
        value.condensed = condensed;
    }
    
    return value;                
}



async function evalColorValue(_value, parse)
{ 
    let value = await evalValue(_value, parse, () => ColorValue.NaN.copy()); 

    if (   value
        && value.type == FILL_VALUE)
        value = value.color;

    else if (value
          && value.type == COLOR_STOP_VALUE)
        value = value.fill.color;

    return value;
}



async function evalFillValue(_value, parse)
{ 
    let value = await evalValue(_value, parse, () => FillValue.NaN.copy());
    
    if (   value
        && value.type == COLOR_VALUE)
        value = new FillValue(value);

    if (   value
        && value.type == COLOR_STOP_VALUE)
        value = value.fill;

    return value; 
}



async function evalStrokeValue        (_value, parse) { return await evalValue(_value, parse, () => StrokeValue        .NaN.copy()); }
async function evalColorStopValue     (_value, parse) { return await evalValue(_value, parse, () => ColorStopValue     .NaN.copy()); }
async function evalGradientValue      (_value, parse) { return await evalValue(_value, parse, () => GradientValue      .NaN.copy()); }

async function evalListValue          (_value, parse) { return await evalValue(_value, parse, () => ListValue          .NaN.copy()); }

async function evalRectangleValue     (_value, parse) { return await evalValue(_value, parse, () => RectangleValue     .NaN.copy()); }
async function evalLineValue          (_value, parse) { return await evalValue(_value, parse, () => LineValue          .NaN.copy()); }
async function evalPolygonValue       (_value, parse) { return await evalValue(_value, parse, () => PolygonValue       .NaN.copy()); }
async function evalTextShapeValue     (_value, parse) { return await evalValue(_value, parse, () => TextShapeValue     .NaN.copy()); }

async function evalPointValue         (_value, parse) { return await evalValue(_value, parse, () => PointValue         .NaN.copy()); }
async function evalVectorPathValue    (_value, parse) { return await evalValue(_value, parse, () => VectorPathValue    .NaN.copy()); }
async function evalArcPathValue       (_value, parse) { return await evalValue(_value, parse, () => ArcPathValue       .NaN.copy()); }
async function evalWavePathValue      (_value, parse) { return await evalValue(_value, parse, () => WavePathValue      .NaN.copy()); }
async function evalVectorVertexValue  (_value, parse) { return await evalValue(_value, parse, () => VectorVertexValue  .NaN.copy()); }
async function evalVectorEdgeValue    (_value, parse) { return await evalValue(_value, parse, () => VectorEdgeValue    .NaN.copy()); }
async function evalVectorRegionValue  (_value, parse) { return await evalValue(_value, parse, () => VectorRegionValue  .NaN.copy()); }

async function evalFrameValue         (_value, parse) { return await evalValue(_value, parse, () => FrameValue         .NaN.copy()); }

async function evalInnerShadowValue   (_value, parse) { return await evalValue(_value, parse, () => InnerShadowValue   .NaN.copy()); }
async function evalLayerBlurValue     (_value, parse) { return await evalValue(_value, parse, () => LayerBlurValue     .NaN.copy()); }
async function evalStrokeSidesValue   (_value, parse) { return await evalValue(_value, parse, () => StrokeSidesValue   .NaN.copy()); }
async function evalRoundedCornersValue(_value, parse) { return await evalValue(_value, parse, () => RoundedCornersValue.NaN.copy()); }



class GOperator1
extends GOperator
{
    input = null;



    reset()
    {
        super.reset();

        this.input = null;
    }



    copyBase(base)
    {
        super.copyBase(base);

        if (base.input) this.input = base.input.copy();
    }



    isCached()
    {
        return super.isCached()
            && (  !this.input 
                || this.input.isCached());
    }



    isValid()
    {
        return this.input && this.input.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input) this.input.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.input) this.input.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input) this.input.iterateLoop(parse);
    }



    getConditionNode()
    {
        if (    this.input
            &&  this.input.getConditionNode
            && !this.input.notCondition)
            return this.input.getConditionNode();
        
        return this;
    }



    setConditionInput(input)
    {
        this.input = input;
    }
}


class GOperator2
extends GOperator
{
    input0 = null;
    input1 = null;



    reset()
    {
        super.reset();

        this.input0 = null;
        this.input1 = null;
    }



    copyBase(base)
    {
        super.copyBase(base);

        if (base.input0) this.input0 = base.input0.copy();
        if (base.input1) this.input1 = base.input1.copy();
    }



    isCached()
    {
        return super.isCached()
            && (!this.input0 || this.input0.isCached())
            && (!this.input1 || this.input1.isCached());
    }



    inputNameFromNode(node)
    {
        return this.input0 && this.input0.nodeId == node.nodeId
            || this.input1 && this.input1.nodeId == node.nodeId;
    }



    isValid()
    {
        return this.input0 && this.input0.isValid()
            && this.input1 && this.input1.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input0) this.input0.pushValueUpdates(parse);
        if (this.input1) this.input1.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.input0) this.input0.invalidateInputs(parse, from, force);
        if (this.input1) this.input1.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input0) this.input0.iterateLoop(parse);
        if (this.input1) this.input1.iterateLoop(parse);
    }



    getConditionNode()
    {
        if (    this.input0
            &&  this.input0.getConditionNode
            && !this.input0.notCondition)
            return this.input0.getConditionNode();
        
        else if (this.input1
             &&  this.input1.getConditionNode
             && !this.input1.notCondition)
            return this.input1.getConditionNode();
        
        return this;
    }
}


class GOperator3
extends GOperator
{
    input0 = null;
    input1 = null;
    input2 = null;



    reset()
    {
        super.reset();

        this.input0 = null;
        this.input1 = null;
        this.input2 = null;
    }



    copyBase(base)
    {
        super.copyBase(base);

        if (base.input0) this.input0 = base.input0.copy();
        if (base.input1) this.input1 = base.input1.copy();
        if (base.input2) this.input2 = base.input2.copy();
    }



    isCached()
    {
        return super.isCached()
            && (!this.input0 || this.input0.isCached())
            && (!this.input1 || this.input1.isCached())
            && (!this.input2 || this.input2.isCached());
    }



    inputNameFromNode(node)
    {
        return this.input0 && this.input0.nodeId == node.nodeId
            || this.input1 && this.input1.nodeId == node.nodeId
            || this.input2 && this.input2.nodeId == node.nodeId;
    }



    isValid()
    {
        return this.input0 && this.input0.isValid()
            && this.input1 && this.input1.isValid()
            && this.input2 && this.input2.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input0) this.input0.pushValueUpdates(parse);
        if (this.input1) this.input1.pushValueUpdates(parse);
        if (this.input2) this.input2.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.input0) this.input0.invalidateInputs(parse, from, force);
        if (this.input1) this.input1.invalidateInputs(parse, from, force);
        if (this.input2) this.input2.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input0) this.input0.iterateLoop(parse);
        if (this.input1) this.input1.iterateLoop(parse);
        if (this.input2) this.input2.iterateLoop(parse);
    }



    getConditionNode()
    {
        if (    this.input0
            &&  this.input0.getConditionNode
            && !this.input0.notCondition)
            return this.input0.getConditionNode();
        
        else if (this.input1
             &&  this.input1.getConditionNode
             && !this.input1.notCondition)
            return this.input1.getConditionNode();
        
        else if (this.input2
             &&  this.input2.getConditionNode
             && !this.input2.notCondition)
            return this.input2.getConditionNode();
        
        return this;
    }
}


class GOperator4
extends GOperator
{
    input0 = null;
    input1 = null;
    input2 = null;
    input3 = null;



    reset()
    {
        super.reset();

        this.input0 = null;
        this.input1 = null;
        this.input2 = null;
        this.input3 = null;
    }



    copyBase(base)
    {
        super.copyBase(base);

        if (base.input0) this.input0 = base.input0.copy();
        if (base.input1) this.input1 = base.input1.copy();
        if (base.input2) this.input2 = base.input2.copy();
        if (base.input3) this.input3 = base.input3.copy();
    }



    isCached()
    {
        return super.isCached()
            && (!this.input0 || this.input0.isCached())
            && (!this.input1 || this.input1.isCached())
            && (!this.input2 || this.input2.isCached())
            && (!this.input3 || this.input3.isCached());
    }



    inputNameFromNode(node)
    {
        return this.input0 && this.input0.nodeId == node.nodeId
            || this.input1 && this.input1.nodeId == node.nodeId
            || this.input2 && this.input2.nodeId == node.nodeId
            || this.input3 && this.input3.nodeId == node.nodeId;
    }



    isValid()
    {
        return this.input0 && this.input0.isValid()
            && this.input1 && this.input1.isValid()
            && this.input2 && this.input2.isValid()
            && this.input3 && this.input3.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input0) this.input0.pushValueUpdates(parse);
        if (this.input1) this.input1.pushValueUpdates(parse);
        if (this.input2) this.input2.pushValueUpdates(parse);
        if (this.input3) this.input3.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.input0) this.input0.invalidateInputs(parse, from, force);
        if (this.input1) this.input1.invalidateInputs(parse, from, force);
        if (this.input2) this.input2.invalidateInputs(parse, from, force);
        if (this.input3) this.input3.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input0) this.input0.iterateLoop(parse);
        if (this.input1) this.input1.iterateLoop(parse);
        if (this.input2) this.input2.iterateLoop(parse);
        if (this.input3) this.input3.iterateLoop(parse);
    }



    getConditionNode()
    {
        if (    this.input0
            &&  this.input0.getConditionNode
            && !this.input0.notCondition)
            return this.input0.getConditionNode();
        
        else if (this.input1
             &&  this.input1.getConditionNode
             && !this.input1.notCondition)
            return this.input1.getConditionNode();
        
        else if (this.input2
             &&  this.input2.getConditionNode
             && !this.input2.notCondition)
            return this.input2.getConditionNode();
        
        else if (this.input3
             &&  this.input3.getConditionNode
             && !this.input3.notCondition)
            return this.input3.getConditionNode();
        
        return this;
    }
}


class GParam
extends GOperator
{
    paramId;
    
    node;
    param;
    


    constructor(nodeId, paramId)
    {
        super(PARAM, nodeId, false);

        this.paramId = paramId;
    }



    reset()
    {
        if (this.node)
            this.node.reset();
    }



    copy()
    {
        const copy = new GParam(this.nodeId, this.paramId);

        copy.copyBase(this);

        copy.node = this.node;
    
        return copy;
    }



    getConditionNode()
    {
        return this.node
             ? this.node.getConditionNode()
             : null;
    }



    async eval(parse)
    {
        this.node = parse.parsedNodes.find(v => v.nodeId == this.nodeId);
        consoleAssert(this.node, 'can\'t find parameter node \'' + this.nodeId + '\'');


        if (    this.node.type != LIST
            || !this.node.cachedValue)
            await this.node.eval(parse);


        this.param = this.node.paramFromId(this.paramId);


        if (isValid(this.param))
        {
            if (   this.node.type != FEEDBACK
                && this.paramId != 'from')
                this.value = await evalValue(this.param, parse);
            else
                this.value = new NullValue();

                
            return this.value
                 ? this.value.copy()
                 : null;
        }
        else
            return this.value = new NullValue();
    }



    isCached()
    {
        return super.isCached();
//            && this.node.isCached();
    }



    toValue()
    {
        return this.value.copy();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.node) this.node.pushValueUpdates(parse);
    }
    


    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);
        
        if (this.node) this.node.invalidateInputs(parse, from, force);
    }



    initLoop(parse, nodeId)
    {
        const node = parse.parsedNodes.find(n => n.nodeId == this.nodeId);
        
        node.initLoop(parse, nodeId);
    }



    iterateCache(parse, from)
    {
        const node = parse.parsedNodes.find(n => n.nodeId == this.nodeId);
        //if (this.node.nodeId == 'start') console.log('node =', node);

        node.iterateCache(parse, from);
    }



    invalidateLoop(parse, nodeId)
    {
        const node = parse.parsedNodes.find(n => n.nodeId == this.nodeId);
        
        node.invalidateLoop(parse, nodeId);
    }



    initLoop(parse, nodeId)
    {
        const node = parse.parsedNodes.find(n => n.nodeId == this.nodeId);
        
        node.initLoop(parse, nodeId);
    }



    iterateLoop(parse)
    {
        const node = parse.parsedNodes.find(n => n.nodeId == this.nodeId);
        
        node.iterateLoop(parse);
    }



    resetLoop(parse, nodeId)
    {
        const node = parse.parsedNodes.find(n => n.nodeId == this.nodeId);
        
        node.resetLoop(parse, nodeId);
    }



    // pushValueUpdates(parse)
    // {
    //     super.pushValueUpdates(parse);

    //     //if (this.node) this.node.pushValueUpdates(parse);
    // }


    
    // invalidateInputs(parse, from, force)
    // {
    //     super.invalidateInputs(parse, from, force);

    //     // if (this.node) this.node.invalidateInputs(parse, from, force);
    // }



    // initLoop(parse, nodeId)
    // {
    //     super.initLoop(parse, nodeId);

    //     // const node = parse.parsedNodes.find(n => n.nodeId == this.nodeId);
    //     // node.initLoop(parse, nodeId);
    // }



    // invalidateLoop(parse, nodeId)
    // {
    //     // const node = parse.parsedNodes.find(n => n.nodeId == this.nodeId);
    //     // node.invalidateLoop(parse, nodeId);
    // }



    // iterateLoop(parse)
    // {
    //     super.iterateLoop(parse);

    //     // const node = parse.parsedNodes.find(n => n.nodeId == this.nodeId);
    //     // node.iterateLoop(parse);
    // }



    // resetLoop(parse, nodeId)
    // {
    //     super.resetLoop(parse, nodeId);

    //     // const node = parse.parsedNodes.find(n => n.nodeId == this.nodeId);
    //     // node.resetLoop(parse, nodeId);
    // }
}


class NullValue
extends GValue
{
    value;



    constructor()
    {
        super(ANY_VALUE);

        this.value = null;
    }



    copy()
    {
        const copy = new NullValue();

        copy.copyBase(this);

        return copy;
    }



    equals(_null)
    {
        return _null
            && this.type  == _null.type
            && this.value == _null.value;
    }



    async eval(parse)
    {
        return this;
    }



    hasInitValue()
    {
        return true;
    }



    isValid()
    {
        return false;
    }



    toValue()
    {
        return this.copy();
    }



    toJson() 
    { 
        return this.toString(); 
    }



    toString()
    {
        return 'NULL';
    }



    toPreviewString()
    {
        return 'NULL';
    }



    toDisplayString()
    {
        return 'NULL';
    }



    toJsCode(gen)
    {
        return this.toPreviewString();
    }



    getNaN()
    {
        return this;
    }
}



function parseNullValue(str)
{
    const _null = new NullValue();

    return [_null, 1];
}



class ListValue
extends GValue
{
    items;

    condensed = false;



    constructor(items = [])
    {
        super(LIST_VALUE);

        if (items)
        {
            this.items = [];

            for (const item of items)
            {
                this.items.push(item.copy());

                if (   this.objects
                    && item.objects)
                    this.objects.push(...item.objects.map(o => o.copy()));
            }
        }
    }



    copy()
    {
        const copy = new ListValue(this.items);

        copy.copyBase(this);

        copy.condensed = this.condensed;

        return copy;
    }



    equals(list)
    {
        if (!list)                                  return false;
        if (!(list instanceof ListValue))           return false;
        if (this.items.length != list.items.length) return false;

        for (let i = 0; i < this.items.length; i++)
            if (!this.items[i].equals(list.items[i]))
                return false;

        return true;
    }



    async eval(parse)
    {
        return this.copy();
    }



    toValue()
    {
        return this.copy();
    }



    hasInitValue()
    {
        if (!this.items)
            return false;
            
        for (const item of this.items)
            if (!item.hasInitValue())
                return false;

        return true;
    }



    isValid()
    {
        //console.log('invalid =', this.items.find(i => !i.isValid()));
        return  this.items;
        //    && !this.items.find(i => !i.isValid());
    }



    toJson()
    {
        if (!this.items)
            return '';


        let str = '';
        
        
        str += this.items.length;

        for (let i = 0; i < this.items.length; i++)
        {
            const item = this.items[i];

            str += ' ' + item.type + ' ';
            str += item.toJson();
        }


        return str;
    }



    toString()
    {
        if (!this.items)
            return '';


        let str = '';
        
        
        str += this.items.length;

        for (let i = 0; i < this.items.length; i++)
        {
            const item = this.items[i];

            str += ' ' + item.type + ' ';
            str += item.toString();
        }


        return str;
    }



    toPreviewString()
    {
        if (!this.items)
            return '';


        const nItems = Math.min(this.items.length, 10);


        let str = '';

        for (let i = 0; i < nItems; i++)
        {
            if (i > 0) 
                str += '<br/>';


            const item = this.items[i];

            if (isListValueType(item.type))
                // str += 'list [' + item.items.length + ']';
            {
                for (let j = 0; j < item.items.length; j++)
                {
                    if (j > 0) 
                        str += ', ';
                    
                    str += item.items[j].toPreviewString();
                }
            }
            else
                str += item.toPreviewString();
        }

        if (this.items.length > 10) 
            str += '<br/>. . .';
        
        return str;
    }



    toDisplayString()
    {
        if (!this.items)
            return '';


        let str = '';
        
        
        str += this.items.length;

        for (let i = 0; i < this.items.length; i++)
        {
            const item = this.items[i];

            str += ' ' + item.type + ' ';
            str += item.toDisplayString();
        }


        return str;
    }



    getNaN()
    {
        return ListValue.NaN.copy();
    }



    static NaN = Object.freeze(new ListValue(null));
}



function parseListValue(str, i = -1)
{
    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }
        
    
    const iStart  = i;
    const nInputs = parseInt(str[i++]);
    
    
    const list = new ListValue();


    for (let j = 0; j < nInputs; j++)
    {
        const type = str[i++];

        switch (type)
        {
            case          LIST_VALUE:  
            case   NUMBER_LIST_VALUE:  
            case     TEXT_LIST_VALUE:  
            case    SHAPE_LIST_VALUE: { const _list   = parseListValue        (str, i);  i += _list  [1];  list.items.push(_list  [0]);  break; }
 
            case        NUMBER_VALUE: { const num     = parseNumberValue      (str[i]);  i += num    [1];  list.items.push(num    [0]);  break; }
            case          TEXT_VALUE: { const text    = parseTextValue        (str[i]);  i += text   [1];  list.items.push(text   [0]);  break; }
            case         COLOR_VALUE: { const color   = parseColorValue       (str, i);  i += color  [1];  list.items.push(color  [0]);  break; }

            case          FILL_VALUE: { const fill    = parseFillValue        (str, i);  i += fill   [1];  list.items.push(fill   [0]);  break; }
            case    COLOR_STOP_VALUE: { const stop    = parseColorStopValue   (str, i);  i += stop   [1];  list.items.push(stop   [0]);  break; }
            case      GRADIENT_VALUE: { const grad    = parseGradientValue    (str, i);  i += grad   [1];  list.items.push(grad   [0]);  break; }
            case        STROKE_VALUE: { const stroke  = parseStrokeValue      (str, i);  i += stroke [1];  list.items.push(stroke [0]);  break; }
            case   DROP_SHADOW_VALUE: { const shadow  = parseDropShadowValue  (str, i);  i += shadow [1];  list.items.push(shadow [0]);  break; }
            case  INNER_SHADOW_VALUE: { const shadow  = parseInnerShadowValue (str, i);  i += shadow [1];  list.items.push(shadow [0]);  break; }
            case    LAYER_BLUR_VALUE: { const blur    = parseLayerBlurValue   (str, i);  i += blur   [1];  list.items.push(blur   [0]);  break; }
            case     BACK_BLUR_VALUE: { const blur    = parseBackBlurValue    (str, i);  i += blur   [1];  list.items.push(blur   [0]);  break; }
            case   LAYER_BLEND_VALUE: { const layer   = parseLayerBlendValue  (str, i);  i += layer  [1];  list.items.push(layer  [0]);  break; }
            case    LAYER_MASK_VALUE: { const mask    = parseLayerMaskValue   (str[i]);  i += mask   [1];  list.items.push(mask   [0]);  break; }

            case     RECTANGLE_VALUE: { const rect    = parseRectangleValue   (str, i);  i += rect   [1];  list.items.push(rect   [0]);  break; }
            case          LINE_VALUE: { const line    = parseLineValue        (str, i);  i += line   [1];  list.items.push(line   [0]);  break; }
            case       ELLIPSE_VALUE: { const ellipse = parseEllipseValue     (str, i);  i += ellipse[1];  list.items.push(ellipse[0]);  break; }
            case       TRAPEZE_VALUE: { const trapeze = parseTrapezeValue     (str, i);  i += trapeze[1];  list.items.push(trapeze[0]);  break; }
            case       POLYGON_VALUE: { const poly    = parsePolygonValue     (str, i);  i += poly   [1];  list.items.push(poly   [0]);  break; }
            case          STAR_VALUE: { const star    = parseStarValue        (str, i);  i += star   [1];  list.items.push(star   [0]);  break; }
            case    TEXT_SHAPE_VALUE: { const text    = parseTextShapeValue   (str, i);  i += text   [1];  list.items.push(text   [0]);  break; }
            case         POINT_VALUE: { const point   = parsePointValue       (str, i);  i += point  [1];  list.items.push(point  [0]);  break; }
            case   VECTOR_PATH_VALUE: { const path    = parseVectorPathValue  (str, i);  i += path   [1];  list.items.push(path   [0]);  break; }
            case SHAPE_BOOLEAN_VALUE: { const bool    = parseShapeBooleanValue(str, i);  i += bool   [1];  list.items.push(bool   [0]);  break; }
            case   SHAPE_GROUP_VALUE: { const group   = parseShapeGroupValue  (str, i);  i += group  [1];  list.items.push(group  [0]);  break; }
            case         FRAME_VALUE: { const frame   = parseFrameValue       (str, i);  i += frame  [1];  list.items.push(frame  [0]);  break; }
        }
    }

    
    return [
        list, 
        i - iStart];
}



function getItemTypes(items, debug)
{
    const types = [];

    for (const item of items)
    {
        if (   item.type ==        LIST_VALUE
            || item.type == NUMBER_LIST_VALUE
            || item.type ==   TEXT_LIST_VALUE
            || item.type ==  SHAPE_LIST_VALUE)
            pushUnique(types, finalListTypeFromItems(item.items, debug));

        else
            pushUnique(types, item.type);
    }

    return types;
}



function finalTypeFromItems(items)
{
    return finalTypeFromTypes(getItemTypes(items));
}



function finalListTypeFromItems(items)
{
    return finalListTypeFromTypes(getItemTypes(items));
}



function finalTypeFromTypes(types)
{
    let _type = ANY_VALUE;

    for (const type of types)
    {
        if (_type == ANY_VALUE)
            _type = type;

        else if (    SHAPE_VALUES.includes(_type) 
                 && !SHAPE_VALUES.includes( type))
            return ANY_VALUE;

        else if (   !SHAPE_VALUES.includes(_type) 
                 && _type != type)
            return ANY_VALUE;
    }

    return _type;
}



function finalListTypeFromTypes(types)
{
    let _type = finalTypeFromTypes(types);
    
         if (  _type == NUMBER_VALUE)      return NUMBER_LIST_VALUE;
    else if (  _type ==   TEXT_VALUE)      return   TEXT_LIST_VALUE;
    else if (SHAPE_VALUES.includes(_type)) return  SHAPE_LIST_VALUE;
    else                                   return        LIST_VALUE;
}


class NumberValue
extends GValue
{
    value;
    initValue;
    decimals;

    isBoolean;



    constructor(val = Number.NaN, dec = -1, isBoolean = false)
    {
        super(NUMBER_VALUE);

        if (typeof val !== 'number')
            consoleError('NumberValue(value) is ' + typeof val + ', must be a number');


        this.value     = val;
        this.initValue = val;
        
        this.decimals = 
              !isNaN(this.value) 
            && dec == -1 
            ? decDigits(this.value) 
            : dec;

        this.isBoolean = isBoolean;
    }



    static fromString(str)
    {
             if (str === 'true' ) return new NumberValue(1, 0, true);
        else if (str === 'false') return new NumberValue(0, 0, true);

        else
            return new NumberValue(
                parseFloat(str),
                decCount(str));
    }



    copy()
    {
        const copy = new NumberValue(
            this.value, 
            this.decimals,
            this.isBoolean);

        copy.initValue = this.initValue;

        copy.copyBase(this);

        return copy;
    }



    equals(num)
    {
        return num
            && this.value    == num.value
            && this.decimals == num.decimals;
    }



    async eval(parse)
    {
        return this.copy();
    }



    hasInitValue()
    {
        return this.value == this.initValue;
    }



    isValid()
    {
        return !isNaN(this.value)
            && !isNaN(this.decimals);
    }



    toInteger()
    {
        return new NumberValue(Math.round(this.value));
    }



    toNumber()
    {
        return roundTo(this.value, this.decimals);
    }



    toString()
    {
        if (this.isBoolean)
            return this.value == 1 ? 'true' : 'false';
    
        else
            return printNum(this.value) 
                 + ',' 
                 + printNum(this.decimals);
    }



    toPreviewString()
    {
        if (this.isBoolean)
            return this.value == 1 ? 'true' : 'false';
    
        else
            return this.isValid()
                ? numToString(this.value, this.decimals)
                : NAN_DISPLAY;
    }



    toDisplayString()
    {
        if (this.isBoolean)
            return this.value == 1 ? 'true' : 'false';
    
        else
            return printNum(this.value) 
                + (!isNaN(this.decimals)
                    ? '_' + this.decimals //subscriptNumber(this.decimals)
                    : '');
    }



    toJsCode(gen)
    {
        return this.toPreviewString();
    }



    getNaN()
    {
        return NumberValue.NaN.copy();
    }



    static NaN = Object.freeze(new NumberValue(
        Number.NaN, 
        Number.NaN));
}



function parseNumberValue(str)
{
         if (str === 'true' ) return [new NumberValue(1, 0, true), 1];
    else if (str === 'false') return [new NumberValue(0, 0, true), 1];

    else
    {
        if (str.indexOf(',') < 0)
        {
            consoleError('number value \'' + str + '\' missing \',\'');
            console.trace();
        }


        const parts = str.split(',');

        const num = new NumberValue(
            parseNum(parts[0]),
            parseNum(parts[1]));

        return [num, 1];
    }
}



function parseSimpleNumberValue(str)
{
         if (str === 'true' ) return [new NumberValue(1, 0, true), 1];
    else if (str === 'false') return [new NumberValue(0, 0, true), 1];

    const num = 
        str == NAN_DISPLAY
        ? NumberValue.NaN.copy()
        : NumberValue.fromString(str);

    return [num, 1];
}


class TextValue
extends GValue
{
    value;
    initValue;



    constructor(val = '')
    {
        super(TEXT_VALUE);


        if (   val !== null
            && typeof val !== 'string')
        {
            console.trace();
            consoleError('TextValue('+val+') is ' + typeof val + ', must be a string');
        }

        
        this.value        = val;
        this.initValue    = val;

        // this.updateValues = [];
    }



    copy()
    {
        const copy = new TextValue(this.value);

        copy.initValue = this.initValue;
        
        copy.copyBase(this);

        return copy;
    }



    equals(text)
    {
        return text
            && this.value == text.value;
    }



    async eval(parse)
    {
        return this.copy();
    }



    hasInitValue()
    {
        this.value == this.initValue;
    }



    isValid()
    {
        return this.value !== null;
    }



    toJson()
    {
        return encodeURIComponent(this.value);
    }



    toString()
    {
        return this.value;
    }



    toPreviewString()
    {
        const lines = this.value.split('\n');

        let str = '';

        for (let i = 0; i < Math.min(lines.length, 10); i++)
        {
            if (i > 0)
                str += '\n';

            str += lines[i];
        }

        if (lines.length > 10)
            str += '\n. . .';
        
        return str;
    }



    toDisplayString()
    {
        return '\'' 
             + this.value.replaceAll('\n', '↵')
             + '\'';
    }



    getNaN()
    {
        return TextValue.NaN.copy();
    }



    static NaN = Object.freeze(new TextValue());
}



function parseTextValue(str)
{
    const text = new TextValue(decodeURIComponent(str));

    return [text, 1];
}


class ColorValue
extends GValue
{
    space;
    c1;
    c2;
    c3;



    constructor(space = NumberValue.NaN, 
                c1    = NumberValue.NaN, 
                c2    = NumberValue.NaN, 
                c3    = NumberValue.NaN)
    {
        super(COLOR_VALUE);

        this.space  = space.copy();
        this.c1     = c1   .copy();
        this.c2     = c2   .copy();
        this.c3     = c3   .copy();

        this.valid  = true;
    }



    static create(space, c1, c2, c3)
    {
        consoleAssert(typeof space == 'number', 'ColorValue.create() space must be a number');
        consoleAssert(typeof c1    == 'number', 'ColorValue.create() c1 must be a number');
        consoleAssert(typeof c2    == 'number', 'ColorValue.create() c2 must be a number');
        consoleAssert(typeof c3    == 'number', 'ColorValue.create() c3 must be a number');

        return new ColorValue(
            new NumberValue(space, 0),
            new NumberValue(c1,    0),
            new NumberValue(c2,    0),
            new NumberValue(c3,    0));
    }



    static fromRgb(rgb)
    {
        return ColorValue.create(1, rgb[0], rgb[1], rgb[2]);
    }



    static fromDataColor(_color, spaceIndex = -1)
    {
        if (spaceIndex < 0)
            spaceIndex = colorSpaceIndex (_color[0]);

        const space  = colorSpace(spaceIndex);
        const factor = colorSpaceFactor(space);

        return ColorValue.create(
            spaceIndex,
            _color[1] * factor[0],
            _color[2] * factor[1],
            _color[3] * factor[2]);
    }



    copy()
    {
        const copy = new ColorValue(
            this.space.copy(), 
            this.c1   .copy(), 
            this.c2   .copy(), 
            this.c3   .copy());

        copy.copyBase(this);

        return copy;
    }



    hasInitValue()
    {
        return this.space.hasInitValue()
            && this.c1   .hasInitValue()
            && this.c2   .hasInitValue()
            && this.c3   .hasInitValue();
    }



    isValid()
    {
        return this.space.isValid()
            && this.c1   .isValid()
            && this.c2   .isValid()
            && this.c3   .isValid();
    }



    equals(col)
    {
        return col
            && this.space.equals(col.space)
            && this.c1   .equals(col.c1   )
            && this.c2   .equals(col.c2   )
            && this.c3   .equals(col.c3   );
    }



    async eval(parse)
    {
        return this.copy();
    }



    toDataColor()
    {
        if (!this.isValid())
            return dataColor_NaN;

        const space = this.space.copy();

        space.value = Math.round(Math.min(Math.max(0, space.value), ColorSpaces.length-1));

        return makeDataColor(
            space,
            this.c1,
            this.c2,
            this.c3);
    }



    toRgb()
    {
        return dataColor2rgb(this.toDataColor());
    }



    toRgba()
    {
        return rgb_a(this.toRgb());
    }



    toRgbObject(limit = false)
    {
        const rgb = dataColor2rgb(this.toDataColor());

        if (limit && rgbIsNaN(rgb))
            return {r: 0.5, g: 0.5, b: 0.5};
        
        return limit
            ? { r: Math.min(Math.max(0, rgb[0]), 1),
                g: Math.min(Math.max(0, rgb[1]), 1),
                b: Math.min(Math.max(0, rgb[2]), 1) }
            : { r: rgb[0],
                g: rgb[1],
                b: rgb[2] };
    }



    toString()
    {
        return      this.space.toString()
            + ' ' + this.c1   .toString()
            + ' ' + this.c2   .toString()
            + ' ' + this.c3   .toString();
    }



    toPreviewString()
    {
        return      this.space.toPreviewString()
            + ' ' + this.c1   .toPreviewString()
            + ' ' + this.c2   .toPreviewString()
            + ' ' + this.c3   .toPreviewString();
    }



    toDisplayString()
    {
        return      this.space.toDisplayString()
            + ' ' + this.c1   .toDisplayString()
            + ' ' + this.c2   .toDisplayString()
            + ' ' + this.c3   .toDisplayString();
    }



    toPreviewString()
    {
        if (!this.isValid())
            return UNKNOWN_DISPLAY;

        const rgb = this.toRgb();

        return '#' + rgb2hex(rgb);
    }



    toRgbString()
    {
        if (!this.isValid())
            return UNKNOWN_DISPLAY;

        const rgb = this.toRgb();

        return      rgb[0].toString()
            + ' ' + rgb[1].toString()
            + ' ' + rgb[2].toString();
    }



    getNaN()
    {
        return ColorValue.NaN.copy();
    }



    static NaN = Object.freeze(new ColorValue(
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN));
}



function parseColorValue(str, i = -1)
{
    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }
        

    const iStart = i;

    const space = parseNumberValue(str[i]); i += space[1];
    const c1    = parseNumberValue(str[i]); i += c1   [1];
    const c2    = parseNumberValue(str[i]); i += c2   [1];
    const c3    = parseNumberValue(str[i]); i += c3   [1];


    return [
        new ColorValue(space[0], c1[0], c2[0], c3[0]), 
        i - iStart ];
}


class FillValue
extends GValue
{
    color;
    opacity;
    blend;



    constructor(color   = ColorValue.NaN, 
                opacity = new NumberValue(100),
                blend   = new NumberValue(0))
    {
        super(FILL_VALUE);

        this.color   = color  .copy();
        this.opacity = opacity.copy();
        this.blend   = blend  .copy();

        this.valid   = true;
    }


    
    static create(r, g, b, opacity, blend = 0)
    {
        consoleAssert(
            typeof opacity == 'number',
            'opacity must be a number');

        return new FillValue(
            ColorValue.create(1, r, g, b),
            new NumberValue(opacity),
            new NumberValue(blend));
    }



    static fromRgb(rgb, opacity, blend = 0)
    {
        consoleAssert(
            typeof opacity == 'number',
            'opacity must be a number');

        return new FillValue(
            ColorValue.fromRgb(rgb),
            new NumberValue(opacity),
            new NumberValue(blend));
    }



    copy()
    {
        const copy = new FillValue(
            this.color  .copy(),
            this.opacity.copy(),
            this.blend  .copy());

        copy.copyBase(this);

        return copy;
    }



    equals(fill)
    {
        return this.color  .equals(fill.color  )
            && this.opacity.equals(fill.opacity)
            && this.blend  .equals(fill.blend  );
    }



    async eval(parse)
    {
        return this.copy();
    }



    toRgba()
    {
        return [
            ...this.color.toRgb(),
            this.opacity.value / 100 ];
    }



    toRgbaObject(limit = false)
    {
        const rgba = rgb_a(
            dataColor2rgb(this.color.toDataColor()),
            this.opacity.value / 100);

        if (limit && rgbIsNaN(rgba))
            return {r: 0.5, g: 0.5, b: 0.5};
        
        return limit
            ? { r: Math.min(Math.max(0, rgba[0]), 1),
                g: Math.min(Math.max(0, rgba[1]), 1),
                b: Math.min(Math.max(0, rgba[2]), 1),
                a: Math.min(Math.max(0, rgba[3]), 1) }
            : { r: rgba[0],
                g: rgba[1],
                b: rgba[2],
                a: rgba[3] };
    }



    toString()
    {
        const rgb = scaleRgb(this.color.toRgb());

        return        new NumberValue(rgb[0]).toString()
              + ' ' + new NumberValue(rgb[1]).toString()
              + ' ' + new NumberValue(rgb[2]).toString()
              + ' ' + this.opacity           .toString()
              + ' ' + this.blend             .toString();
    }



    toPreviewString()
    {
        const rgb = scaleRgb(this.color.toRgb());

        return        new NumberValue(rgb[0]).toPreviewString()
              + ' ' + new NumberValue(rgb[1]).toPreviewString()
              + ' ' + new NumberValue(rgb[2]).toPreviewString()
              + ' ' + this.opacity           .toPreviewString()
              + ' ' + this.blend             .toPreviewString();
    }



    toDisplayString()
    {
        const rgb = scaleRgb(this.color.toRgb());

        return        new NumberValue(rgb[0]).toDisplayString()
              + ' ' + new NumberValue(rgb[1]).toDisplayString()
              + ' ' + new NumberValue(rgb[2]).toDisplayString()
              + ' ' + this.opacity           .toDisplayString()
              + ' ' + this.blend             .toDisplayString();
    }



    hasInitValue()
    {
        return this.color  .hasInitValue()
            && this.opacity.hasInitValue()
            && this.blend  .hasInitValue();
    }



    isValid()
    {
        return this.color  .isValid()
            && this.opacity.isValid()
            && this.blend  .isValid();
    }



    getNaN()
    {
        return FillValue.NaN.copy();
    }



    static NaN = Object.freeze(new FillValue(
        ColorValue .NaN,
        NumberValue.NaN,
        NumberValue.NaN));



    static default = Object.freeze(FillValue.create(217, 217, 217, 100));
}



function parseFillValue(str, i = -1)
{
    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const r  = parseNumberValue(str[i]); i += r [1];
    const g  = parseNumberValue(str[i]); i += g [1];
    const b  = parseNumberValue(str[i]); i += b [1];
    const a  = parseNumberValue(str[i]); i += a [1];
    const bl = parseNumberValue(str[i]); i += bl[1];

    const color = new ColorValue(new NumberValue(1), r[0], g[0], b[0]);

    
    return [
        new FillValue(color, a[0], bl[0]),
        i - iStart ];
}






// async function evalFillValue(fillValue, parse)
// {
//     await fillValue.eval(parse);

//          if ( FILL_TYPES.includes(fillValue.type)) return fill;
//     else if (COLOR_TYPES.includes(fillValue.type)) return new FillValue(fill, fillValue.data.opacity);

//     else consoleError('fill must have type');
// }


class ColorStopValue
extends GValue
{
    fill;
    position;



    constructor(fill     = FillValue.NaN, 
                position = new NumberValue(1))
    {
        if (fill.type != FILL_VALUE)
            consoleError('fill.type is ' + fill.type + ', must be FILL_VALUE');


        super(COLOR_STOP_VALUE);

        this.fill     = fill    .copy();
        this.position = position.copy();

        this.valid    = true;
    }


    
    copy()
    {
        const copy = new ColorStopValue(
            this.fill    .copy(),
            this.position.copy());

        copy.copyBase(this);

        return copy;
    }



    isValid()
    {
        return this.fill    .isValid()
            && this.position.isValid();
    }



    equals(stop)
    {
        return stop
            && this.fill    .equals(stop.fill    )
            && this.position.equals(stop.position);
    }



    async eval(parse)
    {
        return this;
    }



    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.fill    .toString()
            + ' ' + this.position.toString();
    }



    toPreviewString()
    {
        return      this.fill    .toPreviewString()
            + ' ' + this.position.toPreviewString();
    }



    toDisplayString()
    {
        return      this.fill    .toDisplayString()
            + ' ' + this.position.toDisplayString();
    }



    getNaN()
    {
        return ColorStopValue.NaN.copy();
    }



    static NaN = Object.freeze(new ColorStopValue(
        FillValue  .NaN,
        NumberValue.NaN));
}



function parseColorStopValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [ColorStopValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const fill     = parseFillValue  (str, i); i += fill    [1];
    const position = parseNumberValue(str[i]); i += position[1];


    return [
        new ColorStopValue(fill[0], position[0]),
        i - iStart ];
}


class GradientValue
extends GValue
{
    stops;
    gradType;
    position;
    x;
    y;
    size;
    angle;
    aspect;
    skew;
    blend;

    diagAspect;



    constructor(stops      = new ListValue(),
                gradType   = new NumberValue(0),
                position   = new NumberValue(0),
                x          = new NumberValue(0),
                y          = new NumberValue(0),
                size       = new NumberValue(0),
                angle      = new NumberValue(0),
                aspect     = new NumberValue(0),
                diagAspect = false,
                skew       = new NumberValue(0),
                blend      = new NumberValue(0))
    {
        super(GRADIENT_VALUE);

        this.stops      = stops   .copy();
        this.gradType   = gradType.copy();
        this.position   = position.copy();
        this.x          = x       .copy();
        this.y          = y       .copy();
        this.size       = size    .copy();
        this.angle      = angle   .copy();
        this.aspect     = aspect  .copy();
        this.diagAspect = diagAspect;
        this.skew       = skew    .copy();
        this.blend      = blend   .copy();

        this.valid      = true;
    }


    
    copy()
    {
        const copy = new GradientValue(
            this.stops,
            this.gradType,
            this.position,
            this.x,
            this.y,
            this.size,
            this.angle,
            this.aspect,
            this.diagAspect,
            this.skew,
            this.blend);

        copy.copyBase(this);

        return copy;
    }



    isValid()
    {
        return this.stops   .isValid()
            && this.gradType.isValid()
            && this.position.isValid()
            && this.x       .isValid()
            && this.y       .isValid()
            && this.size    .isValid()
            && this.angle   .isValid()
            && this.aspect  .isValid()
            && this.skew    .isValid()
            && this.blend   .isValid();
    }



    equals(grad)
    {
        return grad
            && this.stops   .equals(grad.stops   )
            && this.gradType.equals(grad.gradType)
            && this.position.equals(grad.position)
            && this.x       .equals(grad.x       )
            && this.y       .equals(grad.y       )
            && this.size    .equals(grad.size    )
            && this.angle   .equals(grad.angle   )
            && this.aspect  .equals(grad.aspect  )
            && this.diagAspect == grad.diagAspect
            && this.skew    .equals(grad.skew    )
            && this.blend   .equals(grad.blend   );
    }



    async eval(parse)
    {
        return this;
    }



    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.stops   .toString()
            + ' ' + this.gradType.toString()
            + ' ' + this.position.toString()
            + ' ' + this.x       .toString()
            + ' ' + this.y       .toString()
            + ' ' + this.size    .toString()
            + ' ' + this.angle   .toString()
            + ' ' + this.aspect  .toString()
            + ' ' + (this.diagAspect ? '1' : '0')
            + ' ' + this.skew    .toString()
            + ' ' + this.blend   .toString();
    }



    toRgba()
    {
        return this.stops.length > 0
             ? this.stops[0].fill.toRgba()
             : rgba_NaN;
    }


    
    toPreviewString()
    {
        return      this.stops   .toPreviewString()
            + ' ' + this.gradType.toPreviewString()
            + ' ' + this.position.toPreviewString()
            + ' ' + this.x       .toPreviewString()
            + ' ' + this.y       .toPreviewString()
            + ' ' + this.size    .toPreviewString()
            + ' ' + this.angle   .toPreviewString()
            + ' ' + this.aspect  .toPreviewString()
            + ' ' + (this.diagAspect ? '1' : '0')
            + ' ' + this.skew    .toPreviewString()
            + ' ' + this.blend   .toPreviewString();
    }



    toDisplayString()
    {
        return      this.stops   .toDisplayString()
            + ' ' + this.gradType.toDisplayString()
            + ' ' + this.position.toDisplayString()
            + ' ' + this.x       .toDisplayString()
            + ' ' + this.y       .toDisplayString()
            + ' ' + this.size    .toDisplayString()
            + ' ' + this.angle   .toDisplayString()
            + ' ' + this.aspect  .toDisplayString()
            + ' ' + (this.diagAspect ? '1' : '0')
            + ' ' + this.skew    .toDisplayString()
            + ' ' + this.blend   .toDisplayString();
    }



    getNaN()
    {
        return GradientValue.NaN.copy();
    }



    static NaN = Object.freeze(new GradientValue(
        ListValue  .NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        false,
        NumberValue.NaN,
        NumberValue.NaN));
}



function parseGradientValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [GradientValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const stops      = parseListValue  (str, i); i += stops   [1];
    const gradType   = parseNumberValue(str[i]); i += gradType[1];
    const position   = parseNumberValue(str[i]); i += position[1];
    const x          = parseNumberValue(str[i]); i += x       [1];
    const y          = parseNumberValue(str[i]); i += y       [1];
    const size       = parseNumberValue(str[i]); i += size    [1];
    const angle      = parseNumberValue(str[i]); i += angle   [1];
    const aspect     = parseNumberValue(str[i]); i += aspect  [1];
    const diagAspect = parseInt(str[i]) == 1;    i ++;
    const skew       = parseNumberValue(str[i]); i += skew    [1];
    const blend      = parseNumberValue(str[i]); i += blend   [1];


    return [
        new GradientValue(
            stops   [0], 
            gradType[0], 
            position[0],
            x       [0], 
            y       [0], 
            size    [0], 
            angle   [0], 
            aspect  [0], 
            diagAspect,
            skew    [0], 
            blend   [0]),
        i - iStart ];
}


class StrokeValue
extends GValue
{
    fills;
    weight;
    fit;
    join;
    miter;
    cap;
    dashes;



    constructor(fills  = new ListValue(), 
                weight = new NumberValue(1),
                fit    = new NumberValue(0),
                join   = new NumberValue(0),
                miter  = new NumberValue(28.96, 2),
                cap    = new NumberValue(0),
                dashes = new TextValue())
    {
        if (fills.type != LIST_VALUE)
            consoleError('fill.type is ' + fills.type + ', must be LIST_VALUE');


        super(STROKE_VALUE);

        this.fills  = fills .copy();
        this.weight = weight.copy();
        this.fit    = fit   .copy();
        this.join   = join  .copy();
        this.miter  = miter .copy();
        this.cap    = cap   .copy();
        this.dashes = dashes.copy();

        this.valid  = true;
    }


    
    copy()
    {
        const copy = new StrokeValue(
            this.fills .copy(),
            this.weight.copy(),
            this.fit   .copy(),
            this.join  .copy(),
            this.miter .copy(),
            this.cap   .copy(),
            this.dashes.copy());

        copy.copyBase(this);

        return copy;
    }



    hasInitValue()
    {
        return this.fills .hasInitValue()
            && this.weight.hasInitValue()
            && this.fit   .hasInitValue()
            && this.join  .hasInitValue()
            && this.miter .hasInitValue()
            && this.cap   .hasInitValue()
            && this.dashes.hasInitValue();
    }



    isValid()
    {
        return this.fills .isValid()
            && this.weight.isValid()
            && this.fit   .isValid()
            && this.join  .isValid()
            && this.miter .isValid()
            && this.cap   .isValid()
            && this.dashes.isValid();
    }



    equals(stroke)
    {
        return stroke
            && this.fills .equals(stroke.fill  )
            && this.weight.equals(stroke.weight)
            && this.fit   .equals(stroke.fit   )
            && this.join  .equals(stroke.join  )
            && this.miter .equals(stroke.miter )
            && this.cap   .equals(stroke.cap   )
            && this.dashes.equals(stroke.dashes);
    }



    async eval(parse)
    {
        return this.copy();
    }



    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.fills .toString()
            + ' ' + this.weight.toString()
            + ' ' + this.fit   .toString()
            + ' ' + this.join  .toString()
            + ' ' + this.miter .toString()
            + ' ' + this.cap   .toString()
            + ' ' + this.dashes.toString();
    }



    toPreviewString()
    {
        return      this.fills .toPreviewString()
            + ' ' + this.weight.toPreviewString()
            + ' ' + this.fit   .toPreviewString()
            + ' ' + this.join  .toPreviewString()
            + ' ' + this.miter .toPreviewString()
            + ' ' + this.cap   .toPreviewString()
            + ' ' + this.dashes.toPreviewString();
    }



    toDisplayString()
    {
        return      this.fills .toDisplayString()
            + ' ' + this.weight.toDisplayString()
            + ' ' + this.fit   .toDisplayString()
            + ' ' + this.join  .toDisplayString()
            + ' ' + this.miter .toDisplayString()
            + ' ' + this.cap   .toDisplayString()
            + ' ' + this.dashes.toDisplayString();
    }



    getNaN()
    {
        return StrokeValue.NaN.copy();
    }



    static NaN = Object.freeze(new StrokeValue(
        new ListValue(),
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        new TextValue()));



    static default = Object.freeze(new StrokeValue(
        new ListValue(),
        new NumberValue(1),
        new NumberValue(0),
        new NumberValue(0),
        new NumberValue(28.96),
        new NumberValue(0),
        new TextValue()));
}



function parseStrokeValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [StrokeValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const fills  = parseListValue  (str, i); i += fills [1];
    const weight = parseNumberValue(str[i]); i += weight[1];
    const fit    = parseNumberValue(str[i]); i += fit   [1];
    const join   = parseNumberValue(str[i]); i += join  [1];
    const miter  = parseNumberValue(str[i]); i += miter [1];
    const cap    = parseNumberValue(str[i]); i += cap   [1];
    const dashes = parseTextValue  (str[i]); i += dashes[1];

    return [

        new StrokeValue(
            fills [0], 
            weight[0], 
            fit   [0], 
            join  [0], 
            miter [0], 
            cap   [0], 
            dashes[0]),
        
        i - iStart ];
}



class StrokeSidesValue
extends GValue
{
    top;
    left;
    right;
    bottom;
    visible;



    constructor(top     = new NumberValue(0), 
                left    = new NumberValue(0), 
                right   = new NumberValue(0), 
                bottom  = new NumberValue(0), 
                visible = true)
    {
        super(STROKE_SIDES_VALUE);

        this.top     = top;
        this.left    = left;
        this.right   = right;
        this.bottom  = bottom;
        this.visible = visible;
    }


    
    copy()
    {
        const copy = new StrokeSidesValue(
            this.top   .copy(),
            this.left  .copy(),
            this.right .copy(),
            this.bottom.copy(),
            this.visible);

        copy.copyBase(this);

        return copy;
    }



    equals(sides)
    {
        return this.top   .equals(sides.tl)
            && this.left  .equals(sides.tr)
            && this.right .equals(sides.bl)
            && this.bottom.equals(sides.br)
            && this.visible === sides.visible;
    }



    async eval(parse)
    {
        return this;
    }



    toString()
    {
        return      this.top   .toString()
            + ' ' + this.left  .toString()
            + ' ' + this.right .toString()
            + ' ' + this.bottom.toString();
    }



    toPreviewString()
    {
        return      this.top   .toPreviewString()
            + ' ' + this.left  .toPreviewString()
            + ' ' + this.right .toPreviewString()
            + ' ' + this.bottom.toPreviewString();
    }



    toDisplayString()
    {
        return      this.top   .toDisplayString()
            + ' ' + this.left  .toDisplayString()
            + ' ' + this.right .toDisplayString()
            + ' ' + this.bottom.toDisplayString();
    }



    isValid()
    {
        return this.top   .isValid()
            && this.left  .isValid()
            && this.right .isValid()
            && this.bottom.isValid();
    }



    getNaN()
    {
        return StrokeSidesValue.NaN.copy();
    }



    static NaN = Object.freeze(new StrokeSidesValue(
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        false));
}



function parseStrokeSidesValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [StrokeSidesValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const top    = parseNumberValue(str[i]); i += top   [1];
    const left   = parseNumberValue(str[i]); i += left  [1];
    const right  = parseNumberValue(str[i]); i += right [1];
    const bottom = parseNumberValue(str[i]); i += bottom[1];


    const sides = new StrokeSidesValue(
        top   [0],
        left  [0],
        right [0],
        bottom[0]);


    return [sides, i - iStart];
}



class RoundCornersValue
extends GValue
{
    tl;
    tr;
    bl;
    br;
    visible;



    constructor(tl = new NumberValue(0), 
                tr = new NumberValue(0), 
                bl = new NumberValue(0), 
                br = new NumberValue(0), 
                visible = true)
    {
        super(ROUND_CORNERS_VALUE);

        this.tl      = tl;
        this.tr      = tr;
        this.bl      = bl;
        this.br      = br;
        this.visible = visible;
    }


    
    copy()
    {
        const copy = new RoundCornersValue(
            this.tl.copy(),
            this.tr.copy(),
            this.bl.copy(),
            this.br.copy(),
            this.visible);

        copy.copyBase(this);

        return copy;
    }



    equals(corners)
    {
        return this.tl.equals(corners.tl)
            && this.tr.equals(corners.tr)
            && this.bl.equals(corners.bl)
            && this.br.equals(corners.br)
            && this.visible === corners.visible;
    }



    async eval(parse)
    {
        return this;
    }



    toString()
    {
        return      this.tl.toString()
            + ' ' + this.tr.toString()
            + ' ' + this.bl.toString()
            + ' ' + this.br.toString();
    }



    toPreviewString()
    {
        return      this.tl.toPreviewString()
            + ' ' + this.tr.toPreviewString()
            + ' ' + this.bl.toPreviewString()
            + ' ' + this.br.toPreviewString();
    }



    toDisplayString()
    {
        return      this.tl.toDisplayString()
            + ' ' + this.tr.toDisplayString()
            + ' ' + this.bl.toDisplayString()
            + ' ' + this.br.toDisplayString();
    }



    isValid()
    {
        return this.tl.isValid()
            && this.tr.isValid()
            && this.bl.isValid()
            && this.br.isValid();
    }



    getNaN()
    {
        return RoundCornersValue.NaN.copy();
    }



    static NaN = Object.freeze(new RoundCornersValue(
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        false));
}



function parseRoundCornersValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [RoundCornersValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const tl = parseNumberValue(str[i]); i += tl[1];
    const tr = parseNumberValue(str[i]); i += tr[1];
    const bl = parseNumberValue(str[i]); i += bl[1];
    const br = parseNumberValue(str[i]); i += br[1];


    const corners = new RoundCornersValue(
        tl[0],
        tr[0],
        bl[0],
        br[0]);


    return [corners, i - iStart];
}



class DropShadowValue
extends GValue
{
    x;
    y;
    blur;
    spread;
    fill;
    blend;
    behind;
    visible;



    constructor(x       = new NumberValue(0), 
                y       = new NumberValue(0), 
                blur    = new NumberValue(0), 
                spread  = new NumberValue(0), 
                fill    = FillValue.NaN,
                blend   = new NumberValue(0),
                behind  = new NumberValue(0),
                visible = true)
    {
        super(DROP_SHADOW_VALUE);

        this.x       = x;
        this.y       = y;
        this.blur    = blur;
        this.spread  = spread;
        this.fill    = fill;
        this.blend   = blend;
        this.behind  = behind;
        this.visible = visible;
        
        consoleAssert(fill.type == FILL_VALUE, 'fill.type must be FILL_VALUE');
    }


    
    // static create(x, y, blur, spread, fill, blend, behind)
    // {
    //     return new FillValue(
    //         new Number,
    //         new NumberValue(opacity));
    // }



    copy()
    {
        const copy = new DropShadowValue(
            this.x     .copy(),
            this.y     .copy(),
            this.blur  .copy(),
            this.spread.copy(),
            this.fill  .copy(),
            this.blend .copy(),
            this.behind.copy(),
            this.visible);

        copy.copyBase(this);

        return copy;
    }



    equals(shadow)
    {
        return this.x     .equals(shadow.x     )
            && this.y     .equals(shadow.y     )
            && this.blur  .equals(shadow.blur  )
            && this.spread.equals(shadow.spread)
            && this.fill  .equals(shadow.fill  )
            && this.blend .equals(shadow.blend )
            && this.behind.equals(shadow.behind)
            && this.visible === shadow.visible;
    }



    async eval(parse)
    {
        return this;
    }



    toString()
    {
        return      this.x     .toString()
            + ' ' + this.y     .toString()
            + ' ' + this.blur  .toString()
            + ' ' + this.spread.toString()
            + ' ' + this.fill  .toString()
            + ' ' + this.blend .toString()
            + ' ' + this.behind.toString();
    }



    toPreviewString()
    {
        return      this.x     .toPreviewString()
            + ' ' + this.y     .toPreviewString()
            + ' ' + this.blur  .toPreviewString()
            + ' ' + this.spread.toPreviewString()
            + ' ' + this.fill  .toPreviewString()
            + ' ' + this.blend .toPreviewString()
            + ' ' + this.behind.toPreviewString();
    }



    toDisplayString()
    {
        return      this.x     .toDisplayString()
            + ' ' + this.y     .toDisplayString()
            + ' ' + this.blur  .toDisplayString()
            + ' ' + this.spread.toDisplayString()
            + ' ' + this.fill  .toDisplayString()
            + ' ' + this.blend .toDisplayString()
            + ' ' + this.behind.toDisplayString();
    }



    isValid()
    {
        return this.x     .isValid()
            && this.y     .isValid()
            && this.blur  .isValid()
            && this.spread.isValid()
            && this.fill  .isValid()
            && this.blend .isValid()
            && this.behind.isValid();
    }



    getNaN()
    {
        return DropShadowValue.NaN.copy();
    }



    static NaN = Object.freeze(new DropShadowValue(
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        FillValue .NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        false));


    // static default = Object.freeze(DropShadowValue.create(217, 217, 217, 100));
}



function parseDropShadowValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [DropShadowValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x      = parseNumberValue(str[i]); i += x     [1];
    const y      = parseNumberValue(str[i]); i += y     [1];
    const blur   = parseNumberValue(str[i]); i += blur  [1];
    const spread = parseNumberValue(str[i]); i += spread[1];
    const fill   = parseFillValue  (str, i); i += fill  [1];
    const blend  = parseNumberValue(str[i]); i += blend [1];
    const behind = parseNumberValue(str[i]); i += behind[1];


    const shadow = new DropShadowValue(
        x     [0],
        y     [0],
        blur  [0],
        spread[0],
        fill  [0],
        blend [0],
        behind[0]);


    return [shadow, i - iStart];
}



class InnerShadowValue
extends GValue
{
    x;
    y;
    blur;
    spread;
    fill;
    blend;
    visible;



    constructor(x       = new NumberValue(0), 
                y       = new NumberValue(0), 
                blur    = new NumberValue(0), 
                spread  = new NumberValue(0), 
                fill    = FillValue.NaN,
                blend   = new NumberValue(0),
                visible = true)
    {
        super(INNER_SHADOW_VALUE);

        this.x       = x;
        this.y       = y;
        this.blur    = blur;
        this.spread  = spread;
        this.fill    = fill;
        this.blend   = blend;
        this.visible = visible;
    }


    
    // static create(x, y, blur, spread, fill, blend)
    // {
    //     return new FillValue(
    //         new Number,
    //         new NumberValue(opacity));
    // }



    copy()
    {
        const copy = new InnerShadowValue(
            this.x     .copy(),
            this.y     .copy(),
            this.blur  .copy(),
            this.spread.copy(),
            this.fill  .copy(),
            this.blend .copy(),
            this.visible);

        copy.copyBase(this);

        return copy;
    }



    equals(shadow)
    {
        return this.x     .equals(shadow.x     )
            && this.y     .equals(shadow.y     )
            && this.blur  .equals(shadow.blur  )
            && this.spread.equals(shadow.spread)
            && this.fill  .equals(shadow.fill  )
            && this.blend .equals(shadow.blend )
            && this.visible === shadow.visible;
    }



    async eval(parse)
    {
        return this;
    }



    // toRgba()
    // {
    //     return [
    //         ...this.color.toRgb(),
    //         this.opacity.value / 100 ];
    // }



    // toFigma()
    // {
    //     return [['SOLID', this.toString()]];
    // }



    toString()
    {
        return      this.x     .toString()
            + ' ' + this.y     .toString()
            + ' ' + this.blur  .toString()
            + ' ' + this.spread.toString()
            + ' ' + this.fill  .toString()
            + ' ' + this.blend .toString();
    }



    toPreviewString()
    {
        return      this.x     .toPreviewString()
            + ' ' + this.y     .toPreviewString()
            + ' ' + this.blur  .toPreviewString()
            + ' ' + this.spread.toPreviewString()
            + ' ' + this.fill  .toPreviewString()
            + ' ' + this.blend .toPreviewString();
    }



    toDisplayString()
    {
        return      this.x     .toDisplayString()
            + ' ' + this.y     .toDisplayString()
            + ' ' + this.blur  .toDisplayString()
            + ' ' + this.spread.toDisplayString()
            + ' ' + this.fill  .toDisplayString()
            + ' ' + this.blend .toDisplayString();
    }



    isValid()
    {
        return this.x     .isValid()
            && this.y     .isValid()
            && this.blur  .isValid()
            && this.spread.isValid()
            && this.fill  .isValid()
            && this.blend .isValid();
    }



    getNaN()
    {
        return InnerShadowValue.NaN.copy();
    }



    static NaN = Object.freeze(new InnerShadowValue(
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        FillValue .NaN,
        NumberValue.NaN,
        false));



    // static default = Object.freeze(InnerShadowValue.create(217, 217, 217, 100));
}



function parseInnerShadowValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [InnerShadowValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x      = parseNumberValue(str[i]); i += x     [1];
    const y      = parseNumberValue(str[i]); i += y     [1];
    const blur   = parseNumberValue(str[i]); i += blur  [1];
    const spread = parseNumberValue(str[i]); i += spread[1];
    const fill   = parseFillValue  (str, i); i += fill  [1];
    const blend  = parseNumberValue(str[i]); i += blend [1];


    const shadow = new InnerShadowValue(
        x     [0],
        y     [0],
        blur  [0],
        spread[0],
        fill  [0],
        blend [0]);


    return [shadow, i - iStart];
}



class LayerBlurValue
extends GValue
{
    radius;
    visible;



    constructor(radius  = new NumberValue(0), 
                visible = true)
    {
        super(LAYER_BLUR_VALUE);

        this.radius  = radius;
        this.visible = visible;
    }


    
    // static create(x, y, blur, spread, fill, blend)
    // {
    //     return new FillValue(
    //         new Number,
    //         new NumberValue(opacity));
    // }



    copy()
    {
        const copy = new LayerBlurValue(
            this.radius.copy(),
            this.visible);

        copy.copyBase(this);

        return copy;
    }



    equals(blur)
    {
        return this.radius.equals(blur.radius)
            && this.visible === blur.visible;
    }



    async eval(parse)
    {
        return this;
    }



    // toRgba()
    // {
    //     return [
    //         ...this.color.toRgb(),
    //         this.opacity.value / 100 ];
    // }



    // toFigma()
    // {
    //     return [['SOLID', this.toString()]];
    // }



    toString()
    {
        return this.radius.toString();
    }



    toPreviewString()
    {
        return this.radius.toPreviewString();
    }



    toDisplayString()
    {
        return this.radius.toDisplayString();
    }



    isValid()
    {
        return this.radius.isValid();
    }



    getNaN()
    {
        return LayerBlurValue.NaN.copy();
    }



    static NaN = Object.freeze(new LayerBlurValue(
        NumberValue.NaN,
        false));



    // static default = Object.freeze(LayerBlurValue.create(217, 217, 217, 100));
}



function parseLayerBlurValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [LayerBlurValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const radius = parseNumberValue(str[i]); i += radius[1];


    const shadow = new LayerBlurValue(
        radius[0]);


    return [shadow, i - iStart];
}



class BackBlurValue
extends GValue
{
    radius;
    visible;



    constructor(radius  = new NumberValue(0),
                visible = true)
    {
        super(BACK_BLUR_VALUE);

        this.radius  = radius;
        this.visible = visible;
    }


    
    // static create(x, y, blur, spread, fill, blend)
    // {
    //     return new FillValue(
    //         new Number,
    //         new NumberValue(opacity));
    // }



    copy()
    {
        const copy = new BackBlurValue(
            this.radius.copy(),
            this.visible);

        copy.copyBase(this);

        return copy;
    }



    equals(blur)
    {
        return this.radius.equals(blur.radius)
            && this.visible === blur.visible;
    }



    async eval(parse)
    {
        return this;
    }



    // toRgba()
    // {
    //     return [
    //         ...this.color.toRgb(),
    //         this.opacity.value / 100 ];
    // }



    // toFigma()
    // {
    //     return [['SOLID', this.toString()]];
    // }



    toString()
    {
        return this.radius.toString();
    }



    toPreviewString()
    {
        return this.radius.toPreviewString();
    }



    toDisplayString()
    {
        return this.radius.toDisplayString();
    }



    isValid()
    {
        return this.radius.isValid();
    }



    getNaN()
    {
        return BackBlurValue.NaN.copy();
    }



    static NaN = Object.freeze(new BackBlurValue(
        NumberValue.NaN,
        false));



    // static default = Object.freeze(BackBlurValue.create(217, 217, 217, 100));
}



function parseBackBlurValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [BackBlurValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const radius = parseNumberValue(str[i]); i += radius[1];


    const shadow = new BackBlurValue(
        radius[0]);


    return [shadow, i - iStart];
}



class LayerBlendValue
extends GValue
{
    opacity;
    blend;



    constructor(opacity, blend)
    {
        super(LAYER_BLEND_VALUE);

        this.opacity = opacity.copy();
        this.blend   = blend  .copy();
    }


    
    copy()
    {
        const copy = new LayerBlendValue(this.opacity, this.blend);

        copy.copyBase(this);

        return copy;
    }



    equals(layer)
    {
        return this.opacity.equals(layer.opacity)
            && this.blend  .equals(layer.blend  );
    }



    async eval(parse)
    {
        return this;
    }



    toString()
    {
        return      this.opacity.toString()
            + ' ' + this.blend  .toString();
    }



    toPreviewString()
    {
        return      this.opacity.toPreviewString()
            + ' ' + this.blend  .toPreviewString();
    }



    toDisplayString()
    {
        return      this.opacity.toDisplayString()
            + ' ' + this.blend  .toDisplayString();
    }



    hasInitValue()
    {
        return this.opacity.hasInitValue()
            && this.blend  .hasInitValue();
    }



    isValid()
    {
        return this.opacity && this.opacity.isValid()
            && this.blend   && this.blend  .isValid();
    }



    getNaN()
    {
        return LayerBlendValue.NaN.copy();
    }



    static NaN = Object.freeze(new LayerBlendValue(NumberValue.NaN, NumberValue.NaN));
}



function parseLayerBlendValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [LayerBlendValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const opacity = parseNumberValue(str[i]); i += opacity[1];
    const blend   = parseNumberValue(str[i]); i += blend  [1];


    const layer = new LayerBlendValue(
        opacity[0],
        blend  [0]);

        
    return [layer, i - iStart];
}



class LayerMaskValue
extends GValue
{
    visible;
    maskType;



    constructor(maskType, visible = true)
    {
        super(LAYER_MASK_VALUE);

        this.visible  = visible;
        this.maskType = maskType.copy();
    }


    
    copy()
    {
        const copy = new LayerMaskValue(this.maskType, this.visible);

        copy.copyBase(this);

        return copy;
    }



    equals(mask)
    {
        return this.visible === mask.visible
            && this.maskType.equals(mask.maskType);
    }



    async eval(parse)
    {
        return this;
    }



    toString()
    {
        return 'mask';
    }



    toPreviewString()
    {
        return 'mask';
    }



    toDisplayString()
    {
        return 'mask';
    }



    isValid()
    {
        return this.maskType.isValid();
    }



    getNaN()
    {
        return LayerMaskValue.NaN.copy();
    }



    static NaN = Object.freeze(new LayerMaskValue(NumberValue.NaN, false));
}



function parseLayerMaskValue(str)
{
    const mask = 
        str == NAN_DISPLAY
        ? LayerMaskValue.NaN
        : new LayerMaskValue(new NumberValue(parseInt(str)), true);

    return [mask, 1];
}



class VariableValue
extends GValue
{
    nodeId;

    variableId;
    variableName;
    variableValue;



    constructor(nodeId,
                variableId    = NULL, 
                variableName  = '', 
                variableValue = new NullValue())
    {
        super(VARIABLE_VALUE, nodeId);

        this.variableId    = variableId;
        this.variableName  = variableName;
        this.variableValue = variableValue ? variableValue.copy() : new NullValue();
    }



    static fromObject(obj)
    {
        return new VariableValue(
            obj.nodeId,
            obj.objectId, 
            obj.objectName, 
            new NullValue()); //NumberValue(obj.variableValue));
    }



    copy()
    {
        const copy = new VariableValue(
            this.nodeId,
            this.variableId, 
            this.variableName, 
            this.variableValue ? this.variableValue.copy() : new NullValue());

        copy.copyBase(this);

        return copy;
    }



    equals(_var)
    {
        return _var
            && this.variableId   == _var.variableId  
            && this.variableName == _var.variableName
            &&    this.variableValue
               && _var.variableValue
               && this.variableValue.equals(_var.variableValue);
    }



    async eval(parse)
    {
        return this.copy();
    }



    toString()
    {
        return      (this.variableId   != NULL ? this.variableId  : NULL_VALUE)
            + ' ' + (this.variableName != ''   ? encodeURIComponent(this.variableName)  : NULL_VALUE)
            + ' ' + (this.variableValue ? this.variableValue.type : NULL_VALUE)
            + ' ' + (this.variableValue ? this.variableValue.toString() : NULL_VALUE);
    }



    toPreviewString()
    {
        return 'variable';
            // + ' ' + this.variableId   .toPreviewString()
            // + ' ' + this.variableName .toPreviewString()
            // + ' ' + (this.variableValue ? this.variableValue.type : NULL_VALUE)
            // + ' ' + this.variableValue.toPreviewString();
    }



    toDisplayString()
    {
        return      (this.variableId   != NULL ? this.variableId   : NULL_VALUE)
            + ' ' + (this.variableName != ''   ? this.variableName : NULL_VALUE)
            + ' ' + (this.variableValue ? this.variableValue.type : NULL_VALUE)
            + ' ' + (this.variableValue ? this.variableValue.toDisplayString() : NULL_VALUE);
    }



    toValue()
    {
        return this.copy();
    }



    hasInitValue()
    {
        return super.hasInitValue()
            && this.variableValue.hasInitValue();
    }



    isValid()
    {
        return super.isValid()
            && this.variableId   != NULL
            && this.variableName != ''
            && this.variableValue && this.variableValue.isValid();
    }


    
    static NaN = new VariableValue(
        NULL,
        NULL,
        '',
        null);
}



function parseVariableValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [VariableValue.NaN, 1];


    let _str;

    if (i < 0)
    {
       _str = str.split(' ');
        i   = 0;
    }
    else
        _str = str;


    const iStart = i;
    let   length = 0;

    const variableId    = _str[i] != NULL_VALUE ? _str[i] : NULL;               length += _str[i].length + 1;  i++;

    const strName       = decodeURIComponent(_str[i]);
    const variableName  = strName != NULL_VALUE ? strName : NULL;               length += _str[i].length + 1;  i++;

    const variableType  = _str[i] != NULL_VALUE ? _str[i] : NULL;               length += _str[i].length + 1;  i++;
    const variableValue = parseValueFromType(variableType, str.slice(length));                                 i += variableValue ? variableValue[1] : 1;


    const _var = new VariableValue(
        NULL, // set node ID elsewhere
        variableId,
        variableName,
        variableValue);


    return [_var, i - iStart];
}



// This is getting closer to Figma now, so here the format changes,
// and objects hold stroke values directly, which incoming stroke values just set.

class ShapeValue
extends GValue
{
    nodeId;

    props = null;



    constructor(type, nodeId)
    {
        super(type);

        this.nodeId = nodeId; 

        this.objects = [];
    }



    copyBase(base)
    {
        super.copyBase(base);
        
        this.nodeId = base.nodeId;

        if (base.objects) this.objects = base.objects.map(o => o.copy());

        if (base.props  ) this.props   = base.props.copy();
    }



    hasInitValue()
    {
        return !this.props
            ||  this.props.hasInitValue();
    }



    isValid()
    {
        return !this.props
            ||  this.props.isValid();
    }
}



function parseShapeBaseValue(str, i, obj)
{
    const props = parseListValue(str, i); i += props[1];

    obj.props = props[0];

    return i;
}


class RectangleValue
extends ShapeValue
{
    x;
    y;
    width;
    height;
    round;



    constructor(nodeId,
                x      = new NumberValue(0), 
                y      = new NumberValue(0), 
                width  = new NumberValue(0), 
                height = new NumberValue(0), 
                round  = new NumberValue(0))
    {
        super(RECTANGLE_VALUE, nodeId);

        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;
        this.round  = round;
    }



    static fromObject(obj)
    {
        return new RectangleValue(
            obj.nodeId,
            new NumberValue(obj.x     ), 
            new NumberValue(obj.y     ), 
            new NumberValue(obj.width ), 
            new NumberValue(obj.height), 
            new NumberValue(obj.round ));
    }



    copy()
    {
        const copy = new RectangleValue(
            this.nodeId,
            this.x     .copy(), 
            this.y     .copy(), 
            this.width .copy(), 
            this.height.copy(), 
            this.round .copy());

        copy.copyBase(this);

        return copy;
    }



    equals(rect)
    {
        return rect
            && this.x     .equals(rect.x     )
            && this.y     .equals(rect.y     )
            && this.width .equals(rect.width )
            && this.height.equals(rect.height)
            && this.round .equals(rect.round );
    }



    async eval(parse)
    {
        return this.copy();
    }



    toString()
    {
        return      this.x     .toString()
            + ' ' + this.y     .toString()
            + ' ' + this.width .toString()
            + ' ' + this.height.toString()
            + ' ' + this.round .toString()
            + ' ' + super.toString();
    }



    toPreviewString()
    {
        return 'rectangle';
            // + ' ' + this.x     .toPreviewString()
            // + ' ' + this.y     .toPreviewString()
            // + ' ' + this.width .toPreviewString()
            // + ' ' + this.height.toPreviewString()
            // + ' ' + this.round .toPreviewString();
    }



    toDisplayString()
    {
        return      this.x     .toDisplayString()
            + ' ' + this.y     .toDisplayString()
            + ' ' + this.width .toDisplayString()
            + ' ' + this.height.toDisplayString()
            + ' ' + this.round .toDisplayString();
    }



    toValue()
    {
        return this.copy();
    }



    hasInitValue()
    {
        return super.hasInitValue()
            && this.x     .hasInitValue()
            && this.y     .hasInitValue()
            && this.width .hasInitValue()
            && this.height.hasInitValue()
            && this.round .hasInitValue();
    }



    isValid()
    {
        return super.isValid()
            && this.x     .isValid()
            && this.y     .isValid()
            && this.width .isValid()
            && this.height.isValid()
            && this.round .isValid();
    }


    
    static NaN = new RectangleValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseRectangleValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [RectangleValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x      = parseNumberValue(str[i]); i += x     [1];
    const y      = parseNumberValue(str[i]); i += y     [1];
    const width  = parseNumberValue(str[i]); i += width [1];
    const height = parseNumberValue(str[i]); i += height[1];
    const round  = parseNumberValue(str[i]); i += round [1];


    const rect = new RectangleValue(
        '', // set node ID elsewhere
        x     [0],
        y     [0],
        width [0],
        height[0],
        round [0]);


    i = parseShapeBaseValue(str, i, rect);

    
    return [rect, i - iStart];
}



class LineValue
extends ShapeValue
{
    x;
    y;
    width;



    constructor(nodeId,
                x      = new NumberValue(0), 
                y      = new NumberValue(0), 
                width  = new NumberValue(0))
    {
        super(LINE_VALUE, nodeId);

        this.x     = x;
        this.y     = y;
        this.width = width;
    }



    static fromObject(obj)
    {
        return new LineValue(
            obj.nodeId,
            new NumberValue(obj.x    ), 
            new NumberValue(obj.y    ), 
            new NumberValue(obj.width));
    }



    copy()
    {
        const copy = new LineValue(
            this.nodeId,
            this.x    .copy(), 
            this.y    .copy(), 
            this.width.copy());

        copy.copyBase(this);

        return copy;
    }



    equals(line)
    {
        return line
            && this.x    .equals(line.x    )
            && this.y    .equals(line.y    )
            && this.width.equals(line.width);
    }



    async eval(parse)
    {
        return this.copy();
    }



    hasInitValue()
    {
        return super.hasInitValue()
            && this.x     .hasInitValue()
            && this.y     .hasInitValue()
            && this.width .hasInitValue();
    }



    isValid()
    {
        return super.isValid()
            && this.x    .isValid()
            && this.y    .isValid()
            && this.width.isValid();
    }



    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.x    .toString()
            + ' ' + this.y    .toString()
            + ' ' + this.width.toString()
            + ' ' + super.toString();
    }



    toPreviewString()
    {
        return      this.x    .toPreviewString()
            + ' ' + this.y    .toPreviewString()
            + ' ' + this.width.toPreviewString();
    }



    toDisplayString()
    {
        return      this.x    .toDisplayString()
            + ' ' + this.y    .toDisplayString()
            + ' ' + this.width.toDisplayString();
    }



    static NaN = new LineValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseLineValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [LineValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x     = parseNumberValue(str[i]); i += x    [1];
    const y     = parseNumberValue(str[i]); i += y    [1];
    const width = parseNumberValue(str[i]); i += width[1];


    const line = new LineValue(
        '', // set node ID elsewhere
        x    [0],
        y    [0],
        width[0]);


    i = parseShapeBaseValue(str, i, line);

    
    return [line, i - iStart];
}



class EllipseValue
extends ShapeValue
{
    position;
    x;
    y;
    width;
    height;
    round;
    start;
    sweep;
    inner;



    constructor(nodeId,
                position = new NumberValue(0),
                x        = new NumberValue(0), 
                y        = new NumberValue(0), 
                width    = new NumberValue(0), 
                height   = new NumberValue(0), 
                round    = new NumberValue(0), 
                start    = new NumberValue(0),
                sweep    = new NumberValue(0),
                inner    = new NumberValue(0))
    {
        super(ELLIPSE_VALUE, nodeId);

        this.position = position;
        this.x        = x;
        this.y        = y;
        this.width    = width;
        this.height   = height;
        this.round    = round;
        this.start    = start;
        this.sweep    = sweep;
        this.inner    = inner;
    }



    static fromObject(obj)
    {
        return new EllipseValue(
            obj.nodeId,
            new NumberValue(obj.position), 
            new NumberValue(obj.x       ), 
            new NumberValue(obj.y       ), 
            new NumberValue(obj.width   ), 
            new NumberValue(obj.height  ), 
            new NumberValue(obj.round   ),
            new NumberValue(obj.start   ),
            new NumberValue(obj.sweep   ),
            new NumberValue(obj.inner   ));
    }



    copy()
    {
        const copy = new EllipseValue(
            this.nodeId,
            this.position.copy(), 
            this.x       .copy(), 
            this.y       .copy(), 
            this.width   .copy(), 
            this.height  .copy(), 
            this.round   .copy(), 
            this.start   .copy(),
            this.sweep   .copy(),
            this.inner   .copy());

        copy.copyBase(this);

        return copy;
    }



    equals(ellipse)
    {
        return ellipse
            && this.position.equals(ellipse.position)
            && this.x       .equals(ellipse.x       )
            && this.y       .equals(ellipse.y       )
            && this.width   .equals(ellipse.width   )
            && this.height  .equals(ellipse.height  )
            && this.round   .equals(ellipse.round   )
            && this.start   .equals(ellipse.start   )
            && this.sweep   .equals(ellipse.sweep   )
            && this.inner   .equals(ellipse.inner   );
    }



    async eval(parse)
    {
        return this.copy();
    }
    
    
    
    hasInitValue()
    {
        return super.hasInitValue()
            && this.position.hasInitValue()
            && this.x       .hasInitValue()
            && this.y       .hasInitValue()
            && this.width   .hasInitValue()
            && this.height  .hasInitValue()
            && this.round   .hasInitValue()
            && this.start   .hasInitValue()
            && this.sweep   .hasInitValue()
            && this.inner   .hasInitValue();
    }



    isValid()
    {
        return super.isValid()
            && this.position.isValid()
            && this.x       .isValid()
            && this.y       .isValid()
            && this.width   .isValid()
            && this.height  .isValid()
            && this.round   .isValid()
            && this.start   .isValid()
            && this.sweep   .isValid()
            && this.inner   .isValid();
    }



    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.position.toString()
            + ' ' + this.x       .toString()
            + ' ' + this.y       .toString()
            + ' ' + this.width   .toString()
            + ' ' + this.height  .toString()
            + ' ' + this.round   .toString()
            + ' ' + this.start   .toString()
            + ' ' + this.sweep   .toString()
            + ' ' + this.inner   .toString()
            + ' ' + super.toString();
    }



    toPreviewString()
    {
        return 'ellipse';
            // + ' ' + this.position.toPreviewString()
            // + ' ' + this.x       .toPreviewString()
            // + ' ' + this.y       .toPreviewString()
            // + ' ' + this.width   .toPreviewString()
            // + ' ' + this.height  .toPreviewString()
            // + ' ' + this.round   .toPreviewString()
            // + ' ' + this.inner   .toPreviewString() + '%'
            // + ' ' + this.start   .toPreviewString() + '°'
            // + ' ' + this.sweep   .toPreviewString() + '°';
    }



    toDisplayString()
    {
        return      this.position.toDisplayString()
            + ' ' + this.x       .toDisplayString()
            + ' ' + this.y       .toDisplayString()
            + ' ' + this.width   .toDisplayString()
            + ' ' + this.height  .toDisplayString()
            + ' ' + this.round   .toDisplayString()
            + ' ' + this.start   .toDisplayString()
            + ' ' + this.sweep   .toDisplayString()
            + ' ' + this.inner   .toDisplayString();
    }



    static NaN = new EllipseValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseEllipseValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [EllipseValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const pos    = parseNumberValue(str[i]); i += pos   [1];
    const x      = parseNumberValue(str[i]); i += x     [1];
    const y      = parseNumberValue(str[i]); i += y     [1];
    const width  = parseNumberValue(str[i]); i += width [1];
    const height = parseNumberValue(str[i]); i += height[1];
    const round  = parseNumberValue(str[i]); i += round [1];
    const start  = parseNumberValue(str[i]); i += start [1];
    const sweep  = parseNumberValue(str[i]); i += sweep [1];
    const inner  = parseNumberValue(str[i]); i += inner [1];


    const ellipse = new EllipseValue(
        '', // set node ID elsewhere,
        pos   [0],
        x     [0],
        y     [0],
        width [0],
        height[0],
        round [0],
        start [0],
        sweep [0],
        inner [0]);


    i = parseShapeBaseValue(str, i, ellipse);

    
    return [ellipse, i - iStart];
}



class TrapezeValue
extends ShapeValue
{
    x;
    y;
    width;
    height;
    round;
    bias;



    constructor(nodeId,
                x      = new NumberValue(0), 
                y      = new NumberValue(0), 
                width  = new NumberValue(0), 
                height = new NumberValue(0), 
                round  = new NumberValue(0),
                bias   = new NumberValue(0))
    {
        super(TRAPEZE_VALUE, nodeId);

        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;
        this.round  = round;
        this.bias   = bias;
    }



    static fromObject(obj)
    {
        return new TrapezeValue(
            obj.nodeId,
            new NumberValue(obj.x     ), 
            new NumberValue(obj.y     ), 
            new NumberValue(obj.width ), 
            new NumberValue(obj.height), 
            new NumberValue(obj.round ),
            new NumberValue(obj.bias  ));
    }



    copy()
    {
        const copy = new TrapezeValue(
            this.nodeId,
            this.x     .copy(), 
            this.y     .copy(), 
            this.width .copy(), 
            this.height.copy(), 
            this.round .copy(),
            this.bias  .copy());

        copy.copyBase(this);

        return copy;
    }



    equals(rect)
    {
        return rect
            && this.x     .equals(rect.x     )
            && this.y     .equals(rect.y     )
            && this.width .equals(rect.width )
            && this.height.equals(rect.height)
            && this.round .equals(rect.round )
            && this.bias  .equals(rect.bias  );
    }



    async eval(parse)
    {
        return this.copy();
    }



    toString()
    {
        return      this.x     .toString()
            + ' ' + this.y     .toString()
            + ' ' + this.width .toString()
            + ' ' + this.height.toString()
            + ' ' + this.round .toString()
            + ' ' + this.bias  .toString()
            + ' ' + super.toString();
    }



    toPreviewString()
    {
        return 'trapeze';
            //        this.x     .toPreviewString()
            //+ ' ' + this.y     .toPreviewString()
            //+ ' ' + this.width .toPreviewString()
            //+ ' ' + this.height.toPreviewString()
            //+ ' ' + this.round .toPreviewString()
            //+ ' ' + this.bias  .toPreviewString();
    }



    toDisplayString()
    {
        return      this.x     .toDisplayString()
            + ' ' + this.y     .toDisplayString()
            + ' ' + this.width .toDisplayString()
            + ' ' + this.height.toDisplayString()
            + ' ' + this.round .toDisplayString()
            + ' ' + this.bias  .toDisplayString();
    }



    toValue()
    {
        return this.copy();
    }



    hasInitValue()
    {
        return super.hasInitValue()
            && this.x     .hasInitValue()
            && this.y     .hasInitValue()
            && this.width .hasInitValue()
            && this.height.hasInitValue()
            && this.round .hasInitValue()
            && this.bias  .hasInitValue();
    }


    
    isValid()
    {
        return super.isValid()
            && this.x     .isValid()
            && this.y     .isValid()
            && this.width .isValid()
            && this.height.isValid()
            && this.round .isValid()
            && this.bias  .isValid();
    }


    
    static NaN = new TrapezeValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseTrapezeValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [TrapezeValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x      = parseNumberValue(str[i]); i += x     [1];
    const y      = parseNumberValue(str[i]); i += y     [1];
    const width  = parseNumberValue(str[i]); i += width [1];
    const height = parseNumberValue(str[i]); i += height[1];
    const round  = parseNumberValue(str[i]); i += round [1];
    const bias   = parseNumberValue(str[i]); i += bias  [1];


    const rect = new TrapezeValue(
        '', // set node ID elsewhere
        x     [0],
        y     [0],
        width [0],
        height[0],
        round [0],
        bias  [0]);


    i = parseShapeBaseValue(str, i, rect);

    
    return [rect, i - iStart];
}



class PolygonValue
extends ShapeValue
{
    position;
    x;
    y;
    width;
    height;
    round;
    corners;



    constructor(nodeId,
                position = new NumberValue(0),
                x        = new NumberValue(0), 
                y        = new NumberValue(0), 
                width    = new NumberValue(0), 
                height   = new NumberValue(0), 
                round    = new NumberValue(0), 
                corners  = new NumberValue(0))
    {
        super(POLYGON_VALUE, nodeId);

        this.position = position;
        this.x        = x;
        this.y        = y;
        this.width    = width;
        this.height   = height;
        this.round    = round;
        this.corners  = corners;
    }



    static fromObject(obj)
    {
        return new PolygonValue(
            obj.nodeId,
            new NumberValue(obj.position), 
            new NumberValue(obj.x       ), 
            new NumberValue(obj.y       ), 
            new NumberValue(obj.width   ), 
            new NumberValue(obj.height  ), 
            new NumberValue(obj.round   ),
            new NumberValue(obj.corners ));
    }



    copy()
    {
        const copy = new PolygonValue(
            this.nodeId,
            this.position.copy(), 
            this.x       .copy(), 
            this.y       .copy(), 
            this.width   .copy(), 
            this.height  .copy(), 
            this.round   .copy(), 
            this.corners .copy());
    
        copy.copyBase(this);

        return copy;
    }



    equals(poly)
    {
        return poly
            && this.position.equals(poly.position)
            && this.x       .equals(poly.x       )
            && this.y       .equals(poly.y       )
            && this.width   .equals(poly.width   )
            && this.height  .equals(poly.height  )
            && this.round   .equals(poly.round   )
            && this.corners .equals(poly.corners );
    }



    async eval(parse)
    {
        return this.copy();
    }



    hasInitValue()
    {
        return super.hasInitValue()
            && this.position.hasInitValue()
            && this.x       .hasInitValue()
            && this.y       .hasInitValue()
            && this.width   .hasInitValue()
            && this.height  .hasInitValue()
            && this.round   .hasInitValue()
            && this.corners .hasInitValue();
    }



    isValid()
    {
        return super.isValid()
            && this.position.isValid()
            && this.x       .isValid()
            && this.y       .isValid()
            && this.width   .isValid()
            && this.height  .isValid()
            && this.round   .isValid()
            && this.corners .isValid();
    }



    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.position.toString()
            + ' ' + this.x       .toString()
            + ' ' + this.y       .toString()
            + ' ' + this.width   .toString()
            + ' ' + this.height  .toString()
            + ' ' + this.round   .toString()
            + ' ' + this.corners .toString()
            + ' ' + super.toString();
    }



    toPreviewString()
    {
        return      this.position.toPreviewString()
            + ' ' + this.x       .toPreviewString()
            + ' ' + this.y       .toPreviewString()
            + ' ' + this.width   .toPreviewString()
            + ' ' + this.height  .toPreviewString()
            + ' ' + this.round   .toPreviewString()
            + ' ' + this.corners .toPreviewString();
    }



    toDisplayString()
    {
        return      this.position.toDisplayString()
            + ' ' + this.x       .toDisplayString()
            + ' ' + this.y       .toDisplayString()
            + ' ' + this.width   .toDisplayString()
            + ' ' + this.height  .toDisplayString()
            + ' ' + this.round   .toDisplayString()
            + ' ' + this.corners .toDisplayString();
    }



    static NaN = new PolygonValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parsePolygonValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [PolygonValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const pos     = parseNumberValue(str[i]); i += pos    [1];
    const x       = parseNumberValue(str[i]); i += x      [1];
    const y       = parseNumberValue(str[i]); i += y      [1];
    const width   = parseNumberValue(str[i]); i += width  [1];
    const height  = parseNumberValue(str[i]); i += height [1];
    const round   = parseNumberValue(str[i]); i += round  [1];
    const corners = parseNumberValue(str[i]); i += corners[1];


    const poly = new PolygonValue(
        '', // set node ID elsewhere
        pos    [0],
        x      [0],
        y      [0],
        width  [0],
        height [0],
        round  [0],
        corners[0]);


    i = parseShapeBaseValue(str, i, poly);

    
    return [poly, i - iStart];
}



class StarValue
extends ShapeValue
{
    position;
    x;
    y;
    width;
    height;
    round;
    points;
    convex;



    constructor(nodeId,
                position = new NumberValue(0), 
                x        = new NumberValue(0), 
                y        = new NumberValue(0), 
                width    = new NumberValue(0), 
                height   = new NumberValue(0), 
                round    = new NumberValue(0), 
                points   = new NumberValue(0),
                convex   = new NumberValue(0))
    {
        super(STAR_VALUE, nodeId);

        this.position = position;
        this.x        = x;
        this.y        = y;
        this.width    = width;
        this.height   = height;
        this.round    = round;
        this.points   = points;
        this.convex   = convex;
    }



    static fromObject(obj)
    {
        return new StarValue(
            obj.nodeId,
            new NumberValue(obj.position), 
            new NumberValue(obj.x       ), 
            new NumberValue(obj.y       ), 
            new NumberValue(obj.width   ), 
            new NumberValue(obj.height  ), 
            new NumberValue(obj.round   ),
            new NumberValue(obj.points  ),
            new NumberValue(obj.convex  ));
    }



    copy()
    {
        const copy = new StarValue(
            this.nodeId,
            this.position.copy(), 
            this.x       .copy(), 
            this.y       .copy(), 
            this.width   .copy(), 
            this.height  .copy(), 
            this.round   .copy(), 
            this.points  .copy(),
            this.convex  .copy());

        copy.copyBase(this);

        return copy;
    }



    equals(star)
    {
        return star
            && this.position.equals(star.position)
            && this.x       .equals(star.x       )
            && this.y       .equals(star.y       )
            && this.width   .equals(star.width   )
            && this.height  .equals(star.height  )
            && this.round   .equals(star.round   )
            && this.points  .equals(star.points  )
            && this.convex  .equals(star.convex  );
    }



    async eval(parse)
    {
        return this.copy();
    }



    hasInitValue()
    {
        return super.hasInitValue()
            && this.position.hasInitValue()
            && this.x       .hasInitValue()
            && this.y       .hasInitValue()
            && this.width   .hasInitValue()
            && this.height  .hasInitValue()
            && this.round   .hasInitValue()
            && this.points  .hasInitValue()
            && this.convex  .hasInitValue();
    }


    
    isValid()
    {
        return super.isValid()
            && this.position.isValid()
            && this.x       .isValid()
            && this.y       .isValid()
            && this.width   .isValid()
            && this.height  .isValid()
            && this.round   .isValid()
            && this.points  .isValid()
            && this.convex  .isValid();
    }


    
    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.position.toString()
            + ' ' + this.x       .toString()
            + ' ' + this.y       .toString()
            + ' ' + this.width   .toString()
            + ' ' + this.height  .toString()
            + ' ' + this.round   .toString()
            + ' ' + this.points  .toString()
            + ' ' + this.convex  .toString()
            + ' ' + super.toString();
    }



    toPreviewString()
    {
        return      this.position.toPreviewString()
            + ' ' + this.x       .toPreviewString()
            + ' ' + this.y       .toPreviewString()
            + ' ' + this.width   .toPreviewString()
            + ' ' + this.height  .toPreviewString()
            + ' ' + this.round   .toPreviewString()
            + ' ' + this.points  .toPreviewString()
            + ' ' + this.convex  .toPreviewString();
    }



    toDisplayString()
    {
        return      this.position.toDisplayString()
            + ' ' + this.x       .toDisplayString()
            + ' ' + this.y       .toDisplayString()
            + ' ' + this.width   .toDisplayString()
            + ' ' + this.height  .toDisplayString()
            + ' ' + this.round   .toDisplayString()
            + ' ' + this.points  .toDisplayString()
            + ' ' + this.convex  .toDisplayString();
    }



    static NaN = new StarValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseStarValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [StarValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const pos    = parseNumberValue(str[i]); i += pos   [1];
    const x      = parseNumberValue(str[i]); i += x     [1];
    const y      = parseNumberValue(str[i]); i += y     [1];
    const width  = parseNumberValue(str[i]); i += width [1];
    const height = parseNumberValue(str[i]); i += height[1];
    const round  = parseNumberValue(str[i]); i += round [1];
    const points = parseNumberValue(str[i]); i += points[1];
    const convex = parseNumberValue(str[i]); i += convex[1];


    const star = new StarValue(
        '', // set node ID elsewhere
        pos   [0],
        x     [0],
        y     [0],
        width [0],
        height[0],
        round [0],
        points[0],
        convex[0]);


    i = parseShapeBaseValue(str, i, star);

    
    return [star, i - iStart];
}



class TextShapeValue
extends ShapeValue
{
    text;
    x;
    y;
    width;
    height;
    font;
    style;
    size;
    alignX;
    alignY;
    lineHeight;
    letterSpacing;

    

    constructor(nodeId,
                text          = new TextValue(),
                x             = new NumberValue(0), 
                y             = new NumberValue(0), 
                width         = new NumberValue(0), 
                height        = new NumberValue(0), 
                font          = new NumberValue(0),
                style         = new NumberValue(0),
                size          = new NumberValue(0),
                alignX        = new NumberValue(0),
                alignY        = new NumberValue(0),
                lineHeight    = new NumberValue(0),
                letterSpacing = new NumberValue(0))
    {
        super(TEXT_SHAPE_VALUE, nodeId);

        this.text          = text;
        this.x             = x;
        this.y             = y;
        this.width         = width;
        this.height        = height;
        this.font          = font;
        this.style         = style;
        this.size          = size;
        this.alignX        = alignX;
        this.alignY        = alignY;
        this.lineHeight    = lineHeight;
        this.letterSpacing = letterSpacing;

        this.objects       = [];
    }



    static fromObject(obj)
    {
        return new TextShapeValue(
            obj.nodeId,
            new NumberValue(obj.text         ), 
            new NumberValue(obj.x            ), 
            new NumberValue(obj.y            ), 
            new NumberValue(obj.width        ), 
            new NumberValue(obj.height       ), 
            new NumberValue(obj.font         ),
            new NumberValue(obj.style        ),
            new NumberValue(obj.size         ),
            new NumberValue(obj.alignX       ),
            new NumberValue(obj.alignY       ),
            new NumberValue(obj.lineHeight   ),
            new NumberValue(obj.letterSpacing));
    }



    copy()
    {
        const copy = new TextShapeValue(
            this.nodeId,
            this.text         .copy(),
            this.x            .copy(), 
            this.y            .copy(), 
            this.width        .copy(), 
            this.height       .copy(), 
            this.font         .copy(),
            this.style        .copy(),
            this.size         .copy(),
            this.alignX       .copy(),
            this.alignY       .copy(),
            this.lineHeight   .copy(),
            this.letterSpacing.copy()); 

        copy.copyBase(this);

        return copy;
    }



    equals(text)
    {
        return text
            && this.text         .equals(text.text         )
            && this.x            .equals(text.x            )
            && this.y            .equals(text.y            )
            && this.width        .equals(text.width        )
            && this.height       .equals(text.height       )
            && this.font         .equals(text.font         )
            && this.style        .equals(text.style        )
            && this.size         .equals(text.size         )
            && this.alignX       .equals(text.alignX       )
            && this.alignY       .equals(text.alignY       )
            && this.lineHeight   .equals(text.lineHeight   )
            && this.letterSpacing.equals(text.letterSpacing);
    }



    async eval(parse)
    {
        return this.copy();
    }



    hasInitValue()
    {
        return super.hasInitValue()
            && this.text         .hasInitValue()
            && this.x            .hasInitValue()
            && this.y            .hasInitValue()
            && this.width        .hasInitValue()
            && this.height       .hasInitValue()
            && this.font         .hasInitValue()
            && this.style        .hasInitValue()
            && this.size         .hasInitValue()
            && this.alignX       .hasInitValue()
            && this.alignY       .hasInitValue()
            && this.lineHeight   .hasInitValue()
            && this.letterSpacing.hasInitValue();
    }


    
    isValid()
    {
        return super.isValid()
            && this.text         .isValid()
            && this.x            .isValid()
            && this.y            .isValid()
            && this.width        .isValid()
            && this.height       .isValid()
            && this.font         .isValid()
            && this.style        .isValid()
            && this.size         .isValid()
            && this.alignX       .isValid()
            && this.alignY       .isValid()
            && this.lineHeight   .isValid()
            && this.letterSpacing.isValid();
    }


    
    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.text         .toJson() // otherwise the string can't contain another string
            + ' ' + this.x            .toString()
            + ' ' + this.y            .toString()
            + ' ' + this.width        .toString()
            + ' ' + this.height       .toString()
            + ' ' + this.font         .toString()
            + ' ' + this.style        .toString()
            + ' ' + this.size         .toString()
            + ' ' + this.alignX       .toString()
            + ' ' + this.alignY       .toString()
            + ' ' + this.lineHeight   .toString()
            + ' ' + this.letterSpacing.toString()
            + ' ' + super.toString();
        }



    toPreviewString()
    {
        return 'textShape';      
            //this.text         .toJson() // otherwise the string can't contain another string
            //+ ' ' + this.x            .toPreviewString()
            //+ ' ' + this.y            .toPreviewString()
            //+ ' ' + this.width        .toPreviewString()
            //+ ' ' + this.height       .toPreviewString()
            //+ ' ' + this.font         .toPreviewString()
            //+ ' ' + this.style        .toPreviewString()
            //+ ' ' + this.size         .toPreviewString()
            //+ ' ' + this.alignX       .toPreviewString()
            //+ ' ' + this.alignY       .toPreviewString()
            //+ ' ' + this.lineHeight   .toPreviewString()
            //+ ' ' + this.letterSpacing.toPreviewString();
    }



    toDisplayString()
    {
        return      this.text         .toDisplayString()
            + ' ' + this.x            .toDisplayString()
            + ' ' + this.y            .toDisplayString()
            + ' ' + this.width        .toDisplayString()
            + ' ' + this.height       .toDisplayString()
            + ' ' + this.font         .toDisplayString()
            + ' ' + this.style        .toDisplayString()
            + ' ' + this.size         .toDisplayString()
            + ' ' + this.alignX       .toDisplayString()
            + ' ' + this.alignY       .toDisplayString()
            + ' ' + this.lineHeight   .toDisplayString()
            + ' ' + this.letterSpacing.toDisplayString();
    }



    toJson()
    {
        return      this.text         .toJson()
            + ' ' + this.x            .toJson()
            + ' ' + this.y            .toJson()
            + ' ' + this.width        .toJson()
            + ' ' + this.height       .toJson()
            + ' ' + this.font         .toJson()
            + ' ' + this.style        .toJson()
            + ' ' + this.size         .toJson()
            + ' ' + this.alignX       .toJson()
            + ' ' + this.alignY       .toJson()
            + ' ' + this.lineHeight   .toJson()
            + ' ' + this.letterSpacing.toJson();
    }



    static NaN = new TextShapeValue(
        '',
        TextValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseTextShapeValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [TextShapeValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const text          = parseTextValue  (str[i]); i += text         [1];
    const x             = parseNumberValue(str[i]); i += x            [1];
    const y             = parseNumberValue(str[i]); i += y            [1];
    const width         = parseNumberValue(str[i]); i += width        [1];
    const height        = parseNumberValue(str[i]); i += height       [1];
    const font          = parseNumberValue(str[i]); i += font         [1];
    const style         = parseNumberValue(str[i]); i += style        [1];
    const size          = parseNumberValue(str[i]); i += size         [1];
    const alignX        = parseNumberValue(str[i]); i += alignX       [1];
    const alignY        = parseNumberValue(str[i]); i += alignY       [1];
    const lineHeight    = parseNumberValue(str[i]); i += lineHeight   [1];
    const letterSpacing = parseNumberValue(str[i]); i += letterSpacing[1];


    const txts = new TextShapeValue(
        '', // set node ID elsewhere
        text         [0],
        x            [0],
        y            [0],
        width        [0],
        height       [0],
        font         [0],
        style        [0],
        size         [0],
        alignX       [0],
        alignY       [0],
        lineHeight   [0],
        letterSpacing[0]);


    i = parseShapeBaseValue(str, i, txts);

    
    return [txts, i - iStart];
}



class PointValue
extends GValue
{
    nodeId;

    x;
    y;
    smooth;


    sp0 = null; //  sp0 ------- sp1 
    sp1 = null; //   |
    sp2 = null; //  sp2



    constructor(nodeId,
                x = new NumberValue(0), 
                y = new NumberValue(0),
                smooth = null)
    {
        super(POINT_VALUE);

        this.nodeId  = nodeId;

        this.x       = x;
        this.y       = y;
        this.smooth  = smooth;


        this.createDefaultSpace();
    }



    static fromObject(obj)
    {
        return new PointValue(
            obj.nodeId,
            new NumberValue(obj.x     ), 
            new NumberValue(obj.y     ), 
            new NumberValue(obj.smooth));
    }



    copy()
    {
        const copy = new PointValue(
            this.nodeId,
            this.x.copy(), 
            this.y.copy());

        if (this.smooth) copy.smooth = this.smooth.copy();

        copy.copyBase(this);

        copy.sp0 = clone(this.sp0);
        copy.sp1 = clone(this.sp1);
        copy.sp2 = clone(this.sp2);

        return copy;
    }



    equals(p)
    {
        return p
            && this.x.equals(p.x)
            && this.y.equals(p.y);
    }



    createDefaultSpace(cx = 0, cy = 0)
{
        this.sp0 = point(cx,   cy  );
        this.sp1 = point(cx+1, cy  );
        this.sp2 = point(cx,   cy+1);
    }



    applySpaceTransform(xform, space)
    {
        this.sp0 = transformPoint(this.sp0, xform, space);
        this.sp1 = transformPoint(this.sp1, xform, space);
        this.sp2 = transformPoint(this.sp2, xform, space);
    }



    static create(nodeId, x, y)
    {
        return new PointValue(
            nodeId,
            new NumberValue(x),
            new NumberValue(y));
    }



    static fromPoint(nodeId, p)
    {
        return new PointValue(
            nodeId,
            new NumberValue(p.x),
            new NumberValue(p.y));
    }



    async eval(parse)
    {
        return this.copy();
    }



    hasInitValue()
    {
        return this.x.hasInitValue()
            && this.y.hasInitValue()
            && (  !this.smooth
                || this.smooth.hasInitValue());
    }



    isValid()
    {
        return this.x.isValid()
            && this.y.isValid()
            && (  !this.smooth
                || this.smooth.isValid());
    }



    toString()
    {
        return this.x.isValid()
            && this.y.isValid()
            ?         this.x.toString()
              + ' ' + this.y.toString()
            : NAN_DISPLAY;
    }



    toPreviewString()
    {
        return this.x.isValid()
            && this.y.isValid()
            ?   '(' + this.x.toPreviewString()
              + ', ' + this.y.toPreviewString()
              + ')'
            : NAN_DISPLAY;
    }



    toDisplayString()
    {
        return this.x.isValid()
            && this.y.isValid()
            ?         this.x.toDisplayString()
              + ' ' + this.y.toDisplayString()
            : NAN_DISPLAY;
    }



    toValue()
    {
        return this.copy();
    }



    toPoint()
    {
        return point(
            this.x.value,
            this.y.value);
    }



    toJsCode(gen)
    {
        return '';//this.toPreviewString();
    }



    getNaN()
    {
        return PointValue.NaN.copy();
    }



    static NaN = Object.freeze(new PointValue(
        '',
        NumberValue.NaN, 
        NumberValue.NaN));
}



function parsePointValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [PointValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x = parseNumberValue(str[i]); i += x[1];
    const y = parseNumberValue(str[i]); i += y[1];


    const point = new PointValue(
        '', // set node ID elsewhere
        x[0],
        y[0]);


    return [point, i - iStart];
}



class VectorPathValue
extends ShapeValue
{
    points;
    closed;
    degree;
    winding;
    round;



    constructor(nodeId,
                points  = new ListValue(), 
                closed  = new NumberValue(0), 
                degree  = new NumberValue(0), 
                winding = new NumberValue(0), 
                round   = new NumberValue(0))
    {
        super(VECTOR_PATH_VALUE, nodeId);

        this.points  = points ?? new ListValue();
        this.closed  = closed;
        this.degree  = degree;
        this.winding = winding;
        this.round   = round;
    }



    static fromObject(obj)
    {
        return new VectorPathValue(
            obj.nodeId,
            new ListValue(obj.points.map(p => PointValue.fromPoint(obj.nodeId, p))), 
            new NumberValue(obj.closed ), 
            new NumberValue(obj.degree ), 
            new NumberValue(obj.winding), 
            new NumberValue(obj.round  ));
    }



    copy()
    {
        const copy = new VectorPathValue(
            this.nodeId,
            this.points .copy(), 
            this.closed .copy(), 
            this.degree .copy(), 
            this.winding.copy(), 
            this.round  .copy());

        copy.copyBase(this);

        return copy;
    }



    equals(rect)
    {
        return rect
            && this.points .equals(rect.points )
            && this.closed .equals(rect.closed )
            && this.degree .equals(rect.degree )
            && this.winding.equals(rect.winding)
            && this.round  .equals(rect.round  );
    }



    async eval(parse)
    {
        return this.copy();
    }



    toString()
    {
        return      this.points .toString()
            + ' ' + this.closed .toString()
            + ' ' + this.degree .toString()
            + ' ' + this.winding.toString()
            + ' ' + this.round  .toString()
            + ' ' + super.toString();
    }



    toPreviewString()
    {
        return      this.points .toPreviewString()
            + ' ' + this.closed .toPreviewString()
            + ' ' + this.degree .toPreviewString()
            + ' ' + this.winding.toPreviewString()
            + ' ' + this.round  .toPreviewString();
    }



    toDisplayString()
    {
        return      this.points .toDisplayString()
            + ' ' + this.closed .toDisplayString()
            + ' ' + this.degree .toDisplayString()
            + ' ' + this.winding.toDisplayString()
            + ' ' + this.round  .toDisplayString();
    }



    toValue()
    {
        return this.copy();
    }



    hasInitValue()
    {
        return super.hasInitValue()
            && this.points .hasInitValue()
            && this.closed .hasInitValue()
            && this.degree .hasInitValue()
            && this.winding.hasInitValue()
            && this.round  .hasInitValue();
    }


    
    isValid()
    {
        return super.isValid()
            && this.points  && this.points .isValid()
            && this.closed  && this.closed .isValid()
            && this.degree  && this.degree .isValid()
            && this.winding && this.winding.isValid()
            && this.round   && this.round  .isValid();
    }


    
    static NaN = new VectorPathValue(
        '',
        ListValue  .NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseVectorPathValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [VectorPathValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const points  = parseListValue  (str, i); i += points [1];
    const closed  = parseNumberValue(str[i]); i += closed [1];
    const degree  = parseNumberValue(str[i]); i += degree [1];
    const winding = parseNumberValue(str[i]); i += winding[1];
    const round   = parseNumberValue(str[i]); i += round  [1];

    const path = new VectorPathValue(
        '', // set node ID elsewhere
        points [0],
        closed [0],
        degree [0],
        winding[0],
        round  [0]);


    i = parseShapeBaseValue(str, i, path);

    
    return [path, i - iStart];
}



class VectorVertexValue
extends GValue
{
    nodeId;

    x;
    y;
    join;
    cap;
    round;



    constructor(nodeId,
                x     = new NumberValue(0), 
                y     = new NumberValue(0),
                join  = new NumberValue(0),
                cap   = new NumberValue(0),
                round = new NumberValue(0))
    {
        super(VECTOR_VERTEX_VALUE);

        this.nodeId = nodeId;

        this.x      = x    .copy();
        this.y      = y    .copy();
        this.join   = join .copy();
        this.cap    = cap  .copy();
        this.round  = round.copy();
    }



    copy()
    {
        const copy = new VectorVertexValue(
            this.nodeId,
            this.x    .copy(), 
            this.y    .copy(), 
            this.join .copy(), 
            this.cap  .copy(), 
            this.round.copy());

        copy.copyBase(this);

        return copy;
    }



    equals(p)
    {
        return p
            && this.x    .equals(p.x    )
            && this.y    .equals(p.y    )
            && this.join .equals(p.join )
            && this.cap  .equals(p.cap  )
            && this.round.equals(p.round);
    }



    static create(nodeId, x, y)
    {
        return new VectorVertexValue(
            nodeId,
            new NumberValue(x    ),
            new NumberValue(y    ),
            new NumberValue(join ),
            new NumberValue(cap  ),
            new NumberValue(round));
    }



    static fromPoint(nodeId, p)
    {
        return new VectorVertexValue(
            nodeId,
            new NumberValue(p.x),
            new NumberValue(p.y),
            new NumberValue(0),
            new NumberValue(0),
            new NumberValue(0));
    }



    async eval(parse)
    {
        return this;
    }



    hasInitValue()
    {
        return this.x    .hasInitValue()
            && this.y    .hasInitValue()
            && this.join .hasInitValue()
            && this.cap  .hasInitValue()
            && this.round.hasInitValue();
    }



    isValid()
    {
        return this.x    .isValid()
            && this.y    .isValid()
            && this.join .isValid()
            && this.cap  .isValid()
            && this.round.isValid();
    }



    toString()
    {
        return      this.x    .toString()
            + ' ' + this.y    .toString()
            + ' ' + this.join .toString()
            + ' ' + this.cap  .toString()
            + ' ' + this.round.toString();
    }



    toPreviewString()
    {
        return      this.x    .toPreviewString()
            + ' ' + this.y    .toPreviewString()
            + ' ' + this.join .toPreviewString()
            + ' ' + this.cap  .toPreviewString()
            + ' ' + this.round.toPreviewString();
    }



    toDisplayString()
    {
        return      this.x    .toDisplayString()
            + ' ' + this.y    .toDisplayString()
            + ' ' + this.join .toDisplayString()
            + ' ' + this.cap  .toDisplayString()
            + ' ' + this.round.toDisplayString();
    }



    toValue()
    {
        return this.copy();
    }



    toPoint()
    {
        return point(
            this.x.value,
            this.y.value);
    }



    toJsCode(gen)
    {
        return '';//this.toPreviewString();
    }



    getNaN()
    {
        return VectorVertexValue.NaN.copy();
    }



    static NaN = Object.freeze(new VectorVertexValue(
        '',
        NumberValue.NaN, 
        NumberValue.NaN, 
        NumberValue.NaN, 
        NumberValue.NaN, 
        NumberValue.NaN));
}



function parseVectorVertexValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [VectorVertexValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x     = parseNumberValue(str[i]); i += x    [1];
    const y     = parseNumberValue(str[i]); i += y    [1];
    const join  = parseNumberValue(str[i]); i += join [1];
    const cap   = parseNumberValue(str[i]); i += cap  [1];
    const round = parseNumberValue(str[i]); i += round[1];


    const point = new VectorVertexValue(
        '', // set node ID elsewhere
        x    [0],
        y    [0],
        join [0],
        cap  [0],
        round[0]);


    return [point, i - iStart];
}



class VectorEdgeValue
extends GValue
{
    nodeId;

    start;
    end;
    startTangent;
    endTangent;



    constructor(nodeId,
                start, 
                end,
                startTangent = PointValue.create(nodeId, 0, 0),
                endTangent   = PointValue.create(nodeId, 0, 0))
    {
        super(VECTOR_EDGE_VALUE);

        this.nodeId = nodeId;

        this.start        = start       .copy();       
        this.end          = end         .copy();         
        this.startTangent = startTangent.copy();
        this.endTangent   = endTangent  .copy();  
    }



    copy()
    {
        const copy = new VectorEdgeValue(
            this.nodeId,
            this.start       .copy(), 
            this.end         .copy(), 
            this.startTangent.copy(), 
            this.endTangent  .copy());

        copy.copyBase(this);

        return copy;
    }



    equals(edge)
    {
        return edge
            && this.start       .equals(edge.start       )
            && this.end         .equals(edge.end         )
            && this.startTangent.equals(edge.startTangent)
            && this.  endTangent.equals(edge.  endTangent);
    }



    static create(nodeId, start, end, startTangent, endTangent)
    {
        return new VectorEdgeValue(
            nodeId,
            start,
            end,
            PointValue.create(nodeId, startTangent.x, startTangent.y),
            PointValue.create(nodeId,   endTangent.x,   endTangent.y));
    }



    async eval(parse)
    {
        return this;
    }



    hasInitValue()
    {
        return this.start       .hasInitValue()
            && this.end         .hasInitValue()
            && this.startTangent.hasInitValue()
            && this.endTangent  .hasInitValue();
    }



    isValid()
    {
        return this.start       .isValid()
            && this.end         .isValid()
            && this.startTangent.isValid()
            && this.endTangent  .isValid();
    }



    toString()
    {
        return      this.start       .toString()
            + ' ' + this.end         .toString()
            + ' ' + this.startTangent.toString()
            + ' ' + this.endTangent  .toString();
    }



    toPreviewString()
    {
        return      this.start       .toString()
            + ' ' + this.end         .toString()
            + ' ' + this.startTangent.toString()
            + ' ' + this.endTangent  .toString();
    }



    toDisplayString()
    {
        return      this.start       .toDisplayString()
            + ' ' + this.end         .toDisplayString()
            + ' ' + this.startTangent.toDisplayString()
            + ' ' + this.endTangent  .toDisplayString();
    }



    toValue()
    {
        return this.copy();
    }



    toJsCode(gen)
    {
        return '';//this.toPreviewString();
    }



    getNaN()
    {
        return VectorEdgeValue.NaN.copy();
    }



    static NaN = Object.freeze(new VectorEdgeValue(
        '',
        VectorVertexValue.NaN, 
        VectorVertexValue.NaN, 
        PointValue.NaN, 
        PointValue.NaN));
}



function parseVectorEdgeValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [VectorEdgeValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const start        = parseVectorVertexValue(str, i); i += start       [1];
    const end          = parseVectorVertexValue(str, i); i += end         [1];
    const startTangent = parsePointValue       (str, i); i += startTangent[1];
    const endTangent   = parsePointValue       (str, i); i +=   endTangent[1];


    const edge = new VectorEdgeValue(
        '', // set node ID elsewhere
        start       [0],
        end         [0],
        startTangent[0],
          endTangent[0]);


    return [edge, i - iStart];
}



class VectorRegionValue
extends ShapeValue
{
    loops;  
    winding;

    fills = [];



    constructor(nodeId,
                loops   = new ListValue(), 
                winding = new NumberValue(0))
    {
        super(VECTOR_REGION_VALUE, nodeId);

        this.loops   = loops;  
        this.winding = winding;
    }



    static fromObject(obj)
    {
        return new VectorRegionValue(
            obj.nodeId,
            new ListValue(),  //obj.regions.map(r => VectorRegionValue.fromPoint(obj.nodeId, p))), 
            new ListValue()); //obj.regions.map(r => VectorRegionValue.fromPoint(obj.nodeId, p))));
    }



    copy()
    {
        const copy = new VectorRegionValue(
            this.nodeId,
            this.loops  .copy(), 
            this.winding.copy());

        copy.fills = clone(this.fills);
        
        copy.copyBase(this);

        return copy;
    }



    equals(region)
    {
        return region
            && this.loops  .equals(region.loops  )
            && this.winding.equals(region.winding);
    }



    // static create(nodeId, loops, winding, props)
    // {
    //     return new VectorRegionValue(
    //         nodeId,
    //         loops,
    //         new NumberValue(winding));
    // }



    async eval(parse)
    {
        return this;
    }



    hasInitValue()
    {
        return this.loops  .hasInitValue()
            && this.winding.hasInitValue();
    }



    isValid()
    {
        return this.loops  .isValid()
            && this.winding.isValid();
    }



    toString()
    {
        return      this.loops  .toString()
            + ' ' + this.winding.toString();
    }



    toPreviewString()
    {
        return      this.loops  .toPreviewString()
            + ' ' + this.winding.toPreviewString();
    }



    toDisplayString()
    {
        return      this.loops  .toDisplayString()
            + ' ' + this.winding.toDisplayString();
    }



    toValue()
    {
        return this.copy();
    }



    toJsCode(gen)
    {
        return '';//this.toPreviewString();
    }



    getNaN()
    {
        return VectorEdgeValue.NaN.copy();
    }



    static NaN = Object.freeze(new VectorRegionValue(
        '',
        ListValue  .NaN, 
        NumberValue.NaN));
}



function parseVectorRegionValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [VectorRegionValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const loops   = parseListValue  (str, i); i += loops  [1];
    const winding = parseNumberValue(str[i]); i += winding[1];


    const region = new VectorRegionValue(
        '', // set node ID elsewhere
        loops  [0],
        winding[0]);


    i = parseShapeBaseValue(str, i, region);


    return [region, i - iStart];
}



class VectorNetworkValue
extends GValue
{
    nodeId;

    regions;



    constructor(nodeId,
                regions = new ListValue())
    {
        super(VECTOR_NETWORK_VALUE);

        this.nodeId  = nodeId;

        this.regions = regions; 
    }



    static fromObject(obj)
    {
        return new VectorNetworkValue(
            obj.nodeId,
            new ListValue(obj.regions.map(r => VectorRegionValue.fromObject(obj.nodeId, r))));
    }



    copy()
    {
        const copy = new VectorNetworkValue(
            this.nodeId,
            this.regions.copy());

        copy.copyBase(this);

        return copy;
    }



    equals(other)
    {
        return other
            && this.regions.equals(other.regions);
    }



    static create(nodeId, regions)
    {
        return new VectorNetworkValue(
            nodeId,
            regions);
    }



    async eval(parse)
    {
        return this;
    }



    hasInitValue()
    {
        return this.regions.hasInitValue();
    }



    isValid()
    {
        return this.regions.isValid();
    }



    toString()
    {
        return this.regions.toString();
    }



    toPreviewString()
    {
        return this.regions.toPreviewString();
    }



    toDisplayString()
    {
        return this.regions.toDisplayString();
    }



    toValue()
    {
        return this.copy();
    }



    toJsCode(gen)
    {
        return '';//this.toPreviewString();
    }



    getNaN()
    {
        return VectorNetworkValue.NaN.copy();
    }



    static NaN = Object.freeze(new VectorNetworkValue(
        '',
        ListValue.NaN));
}



function parseVectorNetworkValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [VectorNetworkValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const regions = parseListValue(str, i); i += regions[1];


    const net = new VectorNetworkValue(
        '', // set node ID elsewhere
        regions[0]);


    return [net, i - iStart];
}



class ShapeBooleanValue
extends ShapeValue
{
    operation;
    children;



    constructor(nodeId, children, operation)
    {
        super(SHAPE_BOOLEAN_VALUE, nodeId);

        this.children  = children;
        this.operation = operation;

        this.objects = 
            children.objects
            ? children.objects.map(o => o.copy())
            : null;
    }



    copy()
    {
        const copy = new ShapeBooleanValue(
            this.nodeId,
            this.children .copy(),
            this.operation.copy());

        copy.copyBase(this);

        return copy;
    }



    equals(bool)
    {
        return bool
            && this.children .equals(bool.children )
            && this.operation.equals(bool.operation);
    }



    async eval(parse)
    {
        return this;
    }



    toString()
    {
        return      this.children .toString()
            + ' ' + this.operation.toString();
    }



    toPreviewString()
    {
        return      this.children .toPreviewString()
            + ' ' + this.operation.toPreviewString();
    }



    toDisplayString()
    {
        return      this.children .toDisplayString()
            + ' ' + this.operation.toDisplayString();
    }



    toValue()
    {
        return this.copy();
    }



    isValid()
    {
        return super.isValid()
            && this.children .isValid()
            && this.operation.isValid();
    }


    
    static NaN = new ShapeBooleanValue(
        '',
        ListValue  .NaN,
        NumberValue.NaN);
}



function parseShapeBooleanValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [ShapeBooleanValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const children  = parseListValue  (str, i); i += children [1];
    const operation = parseNumberValue(str[i]); i += operation[1];

    const bool = new ShapeBooleanValue(
        '', // set node ID elsewhere
        children [0],
        operation[0]);


    i = parseShapeBaseValue(str, i, bool);

    
    return [bool, i - iStart];
}



class WavePathValue
extends ShapeValue
{
    shape;
    x;
    y;
    width;
    amplitude;
    frequency;
    offset;
    alignX;  
    alignY;  

    degree;



    constructor(nodeId,
                shape     = new NumberValue(0),
                x         = new NumberValue(0), 
                y         = new NumberValue(0), 
                width     = new NumberValue(0), 
                amplitude = new NumberValue(0),
                frequency = new NumberValue(0),
                offset    = new NumberValue(0),
                alignX    = new NumberValue(0),
                alignY    = new NumberValue(0))
    {
        super(WAVE_PATH_VALUE, nodeId);

        this.shape     = shape;
        this.x         = x;
        this.y         = y;
        this.width     = width;
        this.amplitude = amplitude;
        this.frequency = frequency;
        this.offset    = offset;
        this.alignX    = alignX;
        this.alignY    = alignY;

        this.degree   = new NumberValue(2);
    }



    copy()
    {
        const copy = new WavePathValue(
            this.nodeId,
            this.shape    .copy(),
            this.x        .copy(), 
            this.y        .copy(), 
            this.width    .copy(), 
            this.amplitude.copy(),
            this.frequency.copy(),
            this.offset   .copy(),
            this.alignX   .copy(),
            this.alignY   .copy());

        copy.copyBase(this);

        return copy;
    }



    equals(wave)
    {
        return wave
            && this.shape    .equals(wave.shape    )
            && this.x        .equals(wave.x        )
            && this.y        .equals(wave.y        )
            && this.width    .equals(wave.width    )
            && this.amplitude.equals(wave.amplitude)
            && this.frequency.equals(wave.frequency)
            && this.offset   .equals(wave.offset   )
            && this.alignX   .equals(wave.alignX   )
            && this.alignY   .equals(wave.alignY   );
    }



    async eval(parse)
    {
        return this.copy();
    }
    
    
    
    hasInitValue()
    {
        return super.hasInitValue()
            && this.shape    .hasInitValue()
            && this.x        .hasInitValue()
            && this.y        .hasInitValue()
            && this.width    .hasInitValue()
            && this.amplitude.hasInitValue()
            && this.frequency.hasInitValue()
            && this.offset   .hasInitValue()
            && this.alignX   .hasInitValue()
            && this.alignY   .hasInitValue();
    }



    isValid()
    {
        return super.isValid()
            && this.shape    .isValid()
            && this.x        .isValid()
            && this.y        .isValid()
            && this.width    .isValid()
            && this.amplitude.isValid()
            && this.frequency.isValid()
            && this.offset   .isValid()
            && this.alignX   .isValid()
            && this.alignY   .isValid();
    }



    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.shape    .toString()
            + ' ' + this.x        .toString()
            + ' ' + this.y        .toString()
            + ' ' + this.width    .toString()
            + ' ' + this.amplitude.toString()
            + ' ' + this.frequency.toString()
            + ' ' + this.offset   .toString()
            + ' ' + this.alignX   .toString()
            + ' ' + this.alignY   .toString()
            + ' ' + super.toString();
    }



    toPreviewString()
    {
        return 'wave';
            // + ' ' + this.shape    .toPreviewString() + '°'
            // + ' ' + this.x        .toPreviewString()
            // + ' ' + this.y        .toPreviewString()
            // + ' ' + this.width    .toPreviewString()
            // + ' ' + this.amplitude.toPreviewString() + '°'
            // + ' ' + this.frequency.toPreviewString() + '°'
            // + ' ' + this.offset   .toPreviewString() + '°'
            // + ' ' + this.alignX   .toPreviewString()
            // + ' ' + this.alignY   .toPreviewString();
    }



    toDisplayString()
    {
        return      this.shape    .toDisplayString()
            + ' ' + this.x        .toDisplayString()
            + ' ' + this.y        .toDisplayString()
            + ' ' + this.width    .toDisplayString()
            + ' ' + this.amplitude.toDisplayString()
            + ' ' + this.frequency.toDisplayString()
            + ' ' + this.offset   .toDisplayString()
            + ' ' + this.alignX   .toDisplayString()
            + ' ' + this.alignY   .toDisplayString();
    }



    static NaN = new WavePathValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseWavePathValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [WavePathValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const shape     = parseNumberValue(str[i]); i += shape    [1];
    const x         = parseNumberValue(str[i]); i += x        [1];
    const y         = parseNumberValue(str[i]); i += y        [1];
    const width     = parseNumberValue(str[i]); i += width    [1];
    const amplitude = parseNumberValue(str[i]); i += amplitude[1];
    const frequency = parseNumberValue(str[i]); i += frequency[1];
    const offset    = parseNumberValue(str[i]); i += offset   [1];
    const alignX    = parseNumberValue(str[i]); i += alignX   [1];
    const alignY    = parseNumberValue(str[i]); i += alignY   [1];


    const wave = new WavePathValue(
        '', // set node ID elsewhere,
        shape    [0],
        x        [0],
        y        [0],
        width    [0],
        amplitude[0],
        frequency[0],
        offset   [0],
        alignX   [0],
        alignY   [0]);


    i = parseShapeBaseValue(str, i, wave);

    
    return [wave, i - iStart];
}



class ArcPathValue
extends ShapeValue
{
    position;
    x;
    y;
    width;
    height;
    start;
    sweep;

    degree; // for algos that work on curves



    constructor(nodeId,
                position = new NumberValue(0),
                x        = new NumberValue(0), 
                y        = new NumberValue(0), 
                width    = new NumberValue(0), 
                height   = new NumberValue(0), 
                start    = new NumberValue(0),
                sweep    = new NumberValue(0))
    {
        super(ARC_PATH_VALUE, nodeId);

        this.position = position;
        this.x        = x;
        this.y        = y;
        this.width    = width;
        this.height   = height;
        this.start    = start;
        this.sweep    = sweep;

        this.degree   = new NumberValue(2);
    }



    copy()
    {
        const copy = new ArcPathValue(
            this.nodeId,
            this.position.copy(), 
            this.x       .copy(), 
            this.y       .copy(), 
            this.width   .copy(), 
            this.height  .copy(), 
            this.start   .copy(),
            this.sweep   .copy());

        copy.copyBase(this);

        return copy;
    }



    equals(arc)
    {
        return arc
            && this.position.equals(arc.position)
            && this.x       .equals(arc.x       )
            && this.y       .equals(arc.y       )
            && this.width   .equals(arc.width   )
            && this.height  .equals(arc.height  )
            && this.start   .equals(arc.start   )
            && this.sweep   .equals(arc.sweep   );
    }



    async eval(parse)
    {
        return this.copy();
    }
    
    
    
    hasInitValue()
    {
        return super.hasInitValue()
            && this.position.hasInitValue()
            && this.x       .hasInitValue()
            && this.y       .hasInitValue()
            && this.width   .hasInitValue()
            && this.height  .hasInitValue()
            && this.start   .hasInitValue()
            && this.sweep   .hasInitValue();
    }



    isValid()
    {
        return super.isValid()
            && this.position.isValid()
            && this.x       .isValid()
            && this.y       .isValid()
            && this.width   .isValid()
            && this.height  .isValid()
            && this.start   .isValid()
            && this.sweep   .isValid();
    }



    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.position.toString()
            + ' ' + this.x       .toString()
            + ' ' + this.y       .toString()
            + ' ' + this.width   .toString()
            + ' ' + this.height  .toString()
            + ' ' + this.start   .toString()
            + ' ' + this.sweep   .toString()
            + ' ' + super.toString();
    }



    toPreviewString()
    {
        return 'arc';
            // + ' ' + this.position.toPreviewString()
            // + ' ' + this.x       .toPreviewString()
            // + ' ' + this.y       .toPreviewString()
            // + ' ' + this.width   .toPreviewString()
            // + ' ' + this.height  .toPreviewString()
            // + ' ' + this.start   .toPreviewString() + '°'
            // + ' ' + this.sweep   .toPreviewString() + '°';
    }



    toDisplayString()
    {
        return      this.position.toDisplayString()
            + ' ' + this.x       .toDisplayString()
            + ' ' + this.y       .toDisplayString()
            + ' ' + this.width   .toDisplayString()
            + ' ' + this.height  .toDisplayString()
            + ' ' + this.start   .toDisplayString()
            + ' ' + this.sweep   .toDisplayString();
    }



    static NaN = Object.freeze(new ArcPathValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN));
}



function parseArcPathValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [ArcPathValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const pos    = parseNumberValue(str[i]); i += pos   [1];
    const x      = parseNumberValue(str[i]); i += x     [1];
    const y      = parseNumberValue(str[i]); i += y     [1];
    const width  = parseNumberValue(str[i]); i += width [1];
    const height = parseNumberValue(str[i]); i += height[1];
    const start  = parseNumberValue(str[i]); i += start [1];
    const sweep  = parseNumberValue(str[i]); i += sweep [1];


    const arc = new ArcPathValue(
        '', // set node ID elsewhere,
        pos   [0],
        x     [0],
        y     [0],
        width [0],
        height[0],
        start [0],
        sweep [0]);


    i = parseShapeBaseValue(str, i, arc);

    
    return [arc, i - iStart];
}



class ShapeGroupValue
extends GValue
{
    items = [];



    constructor(nodeId, items = [])
    {
        super(SHAPE_GROUP_VALUE, nodeId);

        this.items = items;

        //this.objects = children.objects.map(o => o.copy());
    }



    copy()
    {
        const copy = new ShapeGroupValue(
            this.nodeId,
            this.items.map(i => i.copy()));

        copy.copyBase(this);

        return copy;
    }



    equals(group)
    {
        if (!group)                                  return false;
        if (!(group instanceof ShapeGroupValue))     return false;
        if (this.items.length != group.items.length) return false;
            
        for (let i = 0; i < this.items.length; i++)
            if (!this.items[i].equals(group.items[i]))
                return false;

        return true;
    }



    async eval(parse)
    {
        return this;
    }



    toString()
    {
        if (!this.items)
            return '';


        let str = '';
        
        
        str += this.items.length;

        for (let i = 0; i < this.items.length; i++)
        {
            const item = this.items[i];

            str += ' ' + item.type + ' ';
            str += item.toString();
        }


        return str;
    }



    toPreviewString()
    {
        if (!this.items)
            return '';


        let str = '';
        
        
        str += this.items.length;

        for (let i = 0; i < this.items.length; i++)
        {
            const item = this.items[i];

            str += ' ' + item.type + ' ';
            str += item.toPreviewString();
        }


        return str;
    }



    toDisplayString()
    {
        if (!this.items)
            return '';


        let str = '';
        
        
        str += this.items.length;

        for (let i = 0; i < this.items.length; i++)
        {
            const item = this.items[i];

            str += ' ' + item.type + ' ';
            str += item.toDisplayString();
        }


        return str;
    }



    toValue()
    {
        return this.copy();
    }



    isValid()
    {
        return  this.items
            && !this.items.find(i => !i.isValid());
    }


    
    static NaN = new ShapeGroupValue(
        '',
        ListValue.NaN);
}



function parseShapeGroupValue(str, i = -1)
{
    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }
        

    const iStart = i;

    const group = new ShapeGroupValue();
    

    const nInputs = parseInt(str[i++]);


    for (let j = 0; j < nInputs; j++)
    {
        const type = str[i++];
        
        switch (type)
        {
            case          LIST_VALUE:  
            case    SHAPE_LIST_VALUE: { const _list   = parseListValue        (str, i);  i += _list  [1];  group.items.push(_list  [0]);  break; }
 
            case     RECTANGLE_VALUE: { const rect    = parseRectangleValue   (str, i);  i += rect   [1];  group.items.push(rect   [0]);  break; }
            case          LINE_VALUE: { const line    = parseLineValue        (str, i);  i += line   [1];  group.items.push(line   [0]);  break; }
            case       ELLIPSE_VALUE: { const ellipse = parseEllipseValue     (str, i);  i += ellipse[1];  group.items.push(ellipse[0]);  break; }
            case       TRAPEZE_VALUE: { const ellipse = parseTrapezeValue     (str, i);  i += ellipse[1];  group.items.push(ellipse[0]);  break; }
            case       POLYGON_VALUE: { const poly    = parsePolygonValue     (str, i);  i += poly   [1];  group.items.push(poly   [0]);  break; }
            case          STAR_VALUE: { const star    = parseStarValue        (str, i);  i += star   [1];  group.items.push(star   [0]);  break; }
            case    TEXT_SHAPE_VALUE: { const text    = parseTextShapeValue   (str, i);  i += text   [1];  group.items.push(text   [0]);  break; }
            case         POINT_VALUE: { const point   = parsePointValue       (str, i);  i += point  [1];  group.items.push(point  [0]);  break; }
            case   VECTOR_PATH_VALUE: { const path    = parseVectorPathValue  (str, i);  i += path   [1];  group.items.push(path   [0]);  break; }
            case SHAPE_BOOLEAN_VALUE: { const path    = parseShapeBooleanValue(str, i);  i += path   [1];  group.items.push(path   [0]);  break; }
            case   SHAPE_GROUP_VALUE: { const _group  = parseShapeGroupValue  (str, i);  i += _group [1];  group.items.push(_group [0]);  break; }
            case         FRAME_VALUE: { const frame   = parseFrameValue       (str, i);  i += frame  [1];  group.items.push(frame  [0]);  break; }
        }
    }

    
    return [
        group, 
        i - iStart];
}



class FrameValue
extends ShapeValue
{
    children;
    position;
    x;
    y;
    width;
    height;
    round;
    clip;



    constructor(nodeId, children, position, x, y, width, height, round, clip)
    {
        super(FRAME_VALUE, nodeId);

        this.children = children;
        this.position = position;
        this.x        = x;
        this.y        = y;
        this.width    = width;
        this.height   = height;
        this.round    = round;
        this.clip     = clip;

        this.objects = 
               children
            && children.objects 
            ? children.objects.map(o => o.copy()) 
            : [];
    }



    copy()
    {
        const copy = new FrameValue(
            this.nodeId,
            this.children.copy(),
            this.position.copy(),
            this.x       .copy(),
            this.y       .copy(),
            this.width   .copy(),
            this.height  .copy(),
            this.round   .copy(),
            this.clip    .copy());

        copy.copyBase(this);

        return copy;
    }



    equals(frame)
    {
        return frame
            && this.children.equals(frame.children)
            && this.position.equals(frame.position)
            && this.x       .equals(frame.x       )
            && this.y       .equals(frame.y       )
            && this.width   .equals(frame.width   )
            && this.height  .equals(frame.height  )
            && this.round   .equals(frame.round   )
            && this.clip    .equals(frame.clip    );
    }



    async eval(parse)
    {
        return this;
    }



    toString()
    {
        return       this.children.toString()
             + ' ' + this.position.toString()
             + ' ' + this.x       .toString()
             + ' ' + this.y       .toString()
             + ' ' + this.width   .toString()
             + ' ' + this.height  .toString()
             + ' ' + this.round   .toString()
             + ' ' + this.clip    .toString()
             + ' ' + super.toString();
    }



    toPreviewString()
    {
        return 'frame';
            //   this.children.toPreviewString()
            //  + ' ' + this.position.toPreviewString()
            //  + ' ' + this.x       .toPreviewString()
            //  + ' ' + this.y       .toPreviewString()
            //  + ' ' + this.width   .toPreviewString()
            //  + ' ' + this.height  .toPreviewString()
            //  + ' ' + this.round   .toPreviewString()
            //  + ' ' + this.clip    .toPreviewString();
    }



    toDisplayString()
    {
        return       this.children.toDisplayString()
             + ' ' + this.position.toDisplayString()
             + ' ' + this.x       .toDisplayString()
             + ' ' + this.y       .toDisplayString()
             + ' ' + this.width   .toDisplayString()
             + ' ' + this.height  .toDisplayString()
             + ' ' + this.clip    .toDisplayString()
             + ' ' + this.round   .toDisplayString();
    }



    toValue()
    {
        return this.copy();
    }



    isValid()
    {
        return super.isValid()
            && this.children.isValid()
            && this.position.isValid()
            && this.x       .isValid()
            && this.y       .isValid()
            && this.width   .isValid()
            && this.height  .isValid()
            && this.round   .isValid()
            && this.clip    .isValid();
    }


    
    static NaN = new FrameValue(
        '',
        ListValue  .NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseFrameValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [FrameValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const children = parseListValue  (str, i); i += children[1];
    const position = parseNumberValue(str[i]); i += position[1];
    const x        = parseNumberValue(str[i]); i += x       [1];
    const y        = parseNumberValue(str[i]); i += y       [1];
    const width    = parseNumberValue(str[i]); i += width   [1];
    const height   = parseNumberValue(str[i]); i += height  [1];
    const round    = parseNumberValue(str[i]); i += round   [1];
    const clip     = parseNumberValue(str[i]); i += clip    [1];

    const frame = new FrameValue(
        '', // set node ID elsewhere
        children[0],
        position[0],
        x       [0],
        y       [0],
        width   [0],
        height  [0],
        round   [0],
        clip    [0]);


    i = parseShapeBaseValue(str, i, frame);

    
    return [frame, i - iStart];
}



class GRepeat
extends GOperator1
{
    count            = null;
    iteration        = null;
   _while            = null;
    loop             = null;

    iterationObjects = [];

    isTerminal       = false; // this is a terminal, active or not
    activeAfter      = false; // there are active nodes after this one
    listAfter        = false; // there is a list node after this one



    constructor(nodeId, options)
    {
        super(REPEAT, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this. count      = null;
        this. iteration  = null;
        this._while      = null;
        this. loop       = null;

        this.isTerminal  = false;
        this.activeAfter = false;
        this.listAfter   = false;

        this.iterationObjects = [];
    }



    copy()
    {
        const copy = new GRepeat(this.nodeId, this.options);

        copy.copyBase(this);

        if (this. value    ) copy. value     = this. value    .copy();
        if (this. iteration) copy. iteration = this. iteration.copy();
        if (this. count    ) copy. count     = this. count    .copy();
        if (this._while    ) copy._while     = this._while    .copy();
        if (this. loop     ) copy. loop      = this. loop     .copy();

        copy.isTerminal  = this.isTerminal;
        copy.activeAfter = this.activeAfter;
        copy.listAfter   = this.listAfter;

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;
            

        let   count     = await evalNumberValue(this.count,     parse);
        let   iteration = await evalNumberValue(this.iteration, parse);
        let  _while     = new NumberValue(1);


        let iterations = [];

        if (iteration.isValid())
        {
            if (iteration.type != TEXT_VALUE)
                iteration = new TextValue(iteration.value.toString());

            const _iterations = iteration.value.split(',');
            
            if (_iterations.length > 1)
            {
                for (const iter of _iterations)
                {
                    if (iter.includes('-'))
                    {
                        const iterParts = iter.split('-');

                        if (iterParts.length == 2)
                        {
                            let start = iterParts[0];
                            let end   = iterParts[1];

                            if (   !isNaN(Number(start))
                                && !isNaN(Number(end  )))
                            {
                                for (let i = start; i <= end; i++)
                                    iterations.push(parseInt(i));
                            }
                        }
                    }
                    else
                        iterations.push(parseInt(iter));
                }
            }
            else
                iterations.push(parseInt(iteration.value));
        }


        count = 
            count
            ? new NumberValue(Math.floor(count.value))
            : new NumberValue(0);


        if (   this.loop 
            && this.loop.type != NUMBER_VALUE) 
            assertVolatile(this.loop, this);


        this.value = new ListValue();
        this.value.objects = [];


        if (   count
            && count.value > 0)
            // && (   this.options.active
            //     // || this.isTerminal
            //     || this.activeAfter
            //     || this.listAfter))
        {
            if (this.input)
            {
                const startTime    = Date.now();
                let   showProgress = false;


                const nRepeats = 
                    this.options.enabled 
                    ? count.value 
                    : 0;
                

                let repeat =
                {
                    repeatId:         this.nodeId,
                    currentIteration: 0,
                    total:            nRepeats
                };

                    
                parse.repeats.push(repeat);

                if (parse.repeats.length == 1)
                    parse.totalProgress += nRepeats;


                if (   this.loop
                    && this.loop.initLoop)
                    this.loop.initLoop(parse, this.nodeId);


                if (this.loop)
                {
                    parse.evalAccumulate = false;
                    await this.loop.eval(parse); // it needs to be evaluated at least once, better do it at the end
                    parse.evalAccumulate = true;
                }


                for (let i = 0, o = 0; i < Math.max(1, nRepeats); i++)
                {
                    if (  !showProgress
                        && Date.now() - startTime > 50)
                    {
                        genInitNodeProgress(this.nodeId);
                        showProgress = true;
                    }


                    repeat.currentIteration = i;


                    this.input.invalidateInputs(parse, this, false);

                    
                    const input = await evalValue      (this.input, parse);
                         _while = await evalNumberValue(this._while, parse);


                    if (   input
                        && nRepeats > 0
                        && (  !_while 
                            || _while.value > 0))
                    {
                        // lists are automatically expanded unless explicitly kept as item
                        
                        if (isListValueType(input.type))
                        {
                            if (input.condensed === true)
                                this.value.items.push(input);
                            else
                            {
                                for (const item of input.items)
                                    this.value.items.push(item);
                            }
                        }
                        else
                            this.value.items.push(input);
        

                        if (   this.options.active
                            || this.options.beforeActive
                            || this.options.beforeList)
                        {
                            this.iterationObjects = [];
                        

                            if (input.objects)
                            {
                                for (let j = 0; j < input.objects.length; j++, o++)
                                {
                                    const obj = copyFigmaObject(input.objects[j]);


                                    this.iterationObjects.push(obj.copy());


                                    if (  !iteration.isValid()
                                        || iterations.includes(i))
                                    {
                                        obj.nodeId      = this.nodeId;
                                        obj.listId      = i;

                                        obj.objectId   += OBJECT_SEPARATOR + this.nodeId + ':' + (o+1).toString();
                                        obj.objectName += ' ' + (o+1).toString();

                                        obj.itemIndex   = repeat.currentIteration;

                                        if (this.value.objects)
                                            this.value.objects.push(obj);
                                    }
                                }
                            }
                        }
                    }


                    this.input.iterateLoop(parse);


                    if (   this.loop
                        && this.loop.iterateCache)
                        this.loop.iterateCache(parse, this);

                    
                    if (parse.repeats.length == 1)
                    {
                        parse.currentProgress++;

                        if (await checkStop(parse.requestId))
                        {
                            genEndNodeProgress(this.nodeId);
                            return this;
                        }
                    }
                    

                    if (showProgress)
                        genUpdateNodeProgress(parse, this.nodeId, i / nRepeats);
                }


                if (   this.loop
                    && this.loop.resetLoop)
                    this.loop.resetLoop(parse, this.nodeId);


                if (this.startTimer > -1)
                {
                    clearTimeout(this.startTimer);
                    this.startTimer = -1;
                }


                genEndNodeProgress(this.nodeId);


                consoleAssert(parse.repeats.at(-1) == repeat, 'invalid nested repeat \'' + this.nodeId + '\'');
                parse.repeats.pop();
            }
            else if (this.input)
                await evalValue(this.input, parse);
        }
        else if (this.input)
            await evalValue(this.input, parse);

        
        const type = this.outputListType();

        
        this.setUpdateValues(parse,
        [
            ['type',      type     ],
            ['count',     count    ],
            ['iteration', iteration]
        ]);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value.copy();
    }



    isValid()
    {
        return super.isValid()
            && this. count     && this. count    .isValid()
            && this. iteration && this. iteration.isValid()
            && (!this._while   || this._while    .isValid());
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this. count    ) this. count    .pushValueUpdates(parse);
        if (this. iteration) this. iteration.pushValueUpdates(parse);
        if (this._while    ) this._while    .pushValueUpdates(parse);
        if (this. loop     ) this. loop     .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this. count    ) this. count    .invalidateInputs(parse, from, force);
        if (this. iteration) this. iteration.invalidateInputs(parse, from, force);
        if (this._while    ) this._while    .invalidateInputs(parse, from, force);
        if (this. loop     ) this. loop     .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this. count    ) this. count    .iterateLoop(parse);
        if (this. iteration) this. iteration.iterateLoop(parse);
        if (this._while    ) this._while    .iterateLoop(parse);
        if (this. loop     ) this. loop     .iterateLoop(parse);
    }
}



function assertVolatile(loop, node)
{
    consoleAssert(
           loop.type == ITERATE
        || loop.type == FREEZE
        || loop.type == NUMBER_RANGE
        || loop.type == NUMBER_WAVE
        || loop.type == NUMBER_SEQUENCE
        || loop.type == NUMBER_RANDOM
        || loop.type == NUMBER_NOISE
        || loop.type == PROBABILITY
        || loop.type == COMBINE
        || loop.type == PARAM, // for OpFeedback
        'only volatile types can be repeated');
}


class GFeedback
extends GOperator1
{
    from   = null;

    loopId = NULL;

    

    constructor(nodeId, options)
    {
        super(FEEDBACK, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.from = null;
    }



    copy()
    {
        const copy = new GFeedback(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.value) copy.value = this.value.copy();

        return copy;
    }



    isCached()
    {
        return super.isCached()
            && (  !this.input 
                || this.input.isCached());
    }



    async eval(parse)
    {
        if (    /*this.isCached()
            ||*/ !parse.evalFeedback)
            return this;

        //console.trace();

        const input = await evalValue(this.input, parse);

        // this.value = input ? new ListValue([input]) : new ListValue();//NullValue();


        this.setUpdateValues(parse, 
        [
            ['type', this.outputListType()]
        ]);


        await this.evalObjects(parse, {input});

        
        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        const repeat = parse.repeats.find(r => r.repeatId == this.loopId);


        const feedback = 
               repeat
            && repeat.currentIteration > 0
            && this.from;

        
        this.value = new ListValue();

        if (feedback)
        {
            for (const obj of this.from.iterationObjects)
                this.value.items.push(obj.toValue());

            if (this.from.iterationObjects)
                this.value.objects = this.from.iterationObjects.map(o => o.copy());
        }
        else if (options.input
              && options.input.isValid())
        {
            this.value.items.push(options.input);

            if (options.input.objects)
                this.value.objects = options.input.objects.map(o => o.copy());
        }


        const iter =
            repeat 
            ? NAME_SEPARATOR + repeat.currentIteration 
            : '';

        for (const item of this.value.items)
            item.nodeId = this.nodeId;

        if (this.value.objects)
        {
            for (let i = 0; i < this.value.objects.length; i++)
            {
                const obj = this.value.objects[i];

                obj.nodeId   = this.nodeId;
                obj.objectId = this.nodeId + OBJECT_SEPARATOR + i + iter;
            }
        }


        await super.evalObjects(parse);
    }



    toValue()
    {
        return this.value.copy();
    }



    // invalidateInputs(parse, from, force)
    // {
    //     super.invalidateInputs(parse, from, force);

    // }



    initLoop(parse, nodeId)
    {
        super.initLoop(parse, nodeId);

        this.from = parse.parsedNodes.find(n => n.nodeId == nodeId);
    }



    resetLoop(parse, nodeId)
    {
        super.resetLoop(parse, nodeId);

        this.from = null;
    }
}



class GNull
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(NULL_NODE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GNull(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.value) copy.value = this.value.copy();
        if (this.input) copy.input = this.input.copy();

        return copy;
    }



    async eval(parse)
    {
        // if (this.isCached())
        //     return this;


        this.value = 
            this.input 
            ? (await this.input.eval(parse)).toValue() 
            : new NullValue();


        this.updateValueObjects();


        this.setUpdateValues(parse,
        [
            ['type', this.outputType()]
        ]);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }
}



class GVariable
extends GOperator1
{
    variableId    = NULL;
    variableName  = '';
    variableType  = NULL;

    variableValue = new NullValue();



    constructor(nodeId, options)
    {
        super(VARIABLE, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.variableId    = NULL;
        this.variableName  = '';
        this.variableType  = NULL;
        
        this.variableValue = new NullValue();
    }



    copy()
    {
        const copy = new GVariable(this.nodeId, this.options);

        copy.variableId   = this.variableId;
        copy.variableName = this.variableName;
        copy.variableType = this.variableType;

        if (this.variableValue) copy.variableValue = this.variableValue.copy();
        
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        const input      = await evalValue(this.input,      parse);
        const paramValue = await evalValue(this.paramValue, parse);

        console.log('input =', input);
        console.log('paramValue =', paramValue);

        const varValue = paramValue ?? input;


        this.value = new VariableValue(
            this.nodeId, 
            this.variableId,
            this.variableName,
            varValue);


        this.setUpdateValues(parse,
        [
            ['value', this.value]
        ]);


        await this.evalVariable(parse);


        this.validate();

        return this;
    }



    async evalVariable(parse, options = {})
    {
        if (!this.options.enabled)
            return;
     
        
        this.value.objects = [];


        if (//   this.value.variableId   != NULL
            //&& this.value.variableName != ''
            //&&  
                  this.value.variableValue 
               && this.value.variableValue.isValid())
        {
            const _var = new FigmaVariable(
                this.nodeId,
                this.value.variableId,
                this.value.variableName,
                this.value.variableValue);

            this.value.objects.push(_var);
        }

        
        await super.evalObjects(parse);
    }



    isValid()
    {
        return this.variableValue 
            && this.variableValue != NULL;
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.variableValue) this.variableValue.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.variableValue) this.variableValue.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.variableValue) this.variableValue.iterateLoop(parse);
    }
}


class GVariableGroup
extends GOperator
{
    input = null;



    constructor(nodeId, options)
    {
        super(VARIABLE_GROUP, nodeId, options);
    }



    copy()
    {
        const copy = new GList(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) copy.input = this.input.copy();
        
        for (const key of this.keys())
        {
            if (this[key] instanceof GValue)
                Object.assign(copy, {[key]: this[key]});
        }

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalListValue(this.input, parse);


        this.updateValues = [];

        
        // if (    this.value.isValid()
        //     && !isEmpty(this.value.items))
        // {
        //     for (let i = 0; i < this.value.items.length; i++)
        //     {
        //         const item = this.value.items[i];
                
        //         let valueId = 
        //             item.valueId.trim() != ''
        //             ? item.valueId
        //             : i.toString();

        //         valueId = getNewNumberId(
        //             valueId,
        //             id => this.value.items.filter(i => 
        //                    i != item 
        //                 && i.valueId == id).length);

        //         Object.assign(this, {[valueId]: item});
        //         this.setUpdateValues(parse, [[valueId, item]], true);

        //         item.sortId = i;
        //     }

        //     this.updateValues.sort((a, b) => a.sortId - b.sortId);
        // }
        // else
            this.setUpdateValues(parse, [['', new NullValue()]], true);


        // if (this.value.objects)
        //     for (let j = 0; j < this.value.objects.length; j++)
        //         this.value.objects[j].nodeId = this.nodeId;


        this.validate();

        return this;
    }
    
    

    paramFromId(paramId)
    {
        return this.value
            && this.value.items
            && paramId != 'value'
            ? this.value.items.find(i => i.valueId == paramId) //this[paramId]
            : null;
    }



    toValue()
    {
        return this.value.copy();
    }



    isValid()
    {
        return this.input && this.input.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input) this.input.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.input) this.input.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input) this.input.iterateLoop(parse);
    }
}


class GCache
extends GOperator1
{
    cachedValue = null;



    constructor(nodeId, options)
    {
        super(CACHE, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.cachedValue = null;
    }



    copy()
    {
        const copy = new GCache(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.value) copy.value = this.value.copy();
        // if (this.cachedValue) copy.cachedValue = this.cachedValue.copy();

        return copy;
    }



    async eval(parse)
    {
        if (!this.options.enabled)
            this.cachedValue = null;
            
        if (   this.isCached()
            && this.cachedValue)
            return this;


        if (this.cachedValue)
        {
            this.value = this.cachedValue.copy();
        }
        else
        {
            const input = await evalValue(this.input, parse);

            this.value = input;

            if (   this.options.enabled
                && this.value)
                this.cachedValue = this.value.copy();

            // this.updateValueObjects();//FromInput(input);
        }


        this.updateValueObjects();


        this.setUpdateValues(parse,
        [
            ['type', this.outputType()]
        ]);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    iterateCache(parse, from)
    {
        this.cachedValue = null;

        super.iterateCache(parse, from);
    }
}



class GFreeze
extends GOperator1
{
    frozen = false;

    loopId = NULL;



    constructor(nodeId, options)
    {
        super(FREEZE, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.frozen = false;
    }



    copy()
    {
        const copy = new GFreeze(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.value) copy.value = this.value.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const repeat = parse.repeats.find(r => r.repeatId == this.loopId);


        if (      repeat
               && repeat.currentIteration == 0
            || !this.options.enabled)
            this.frozen = false;


        if (!this.frozen)
        {
            this.value = 
                this.input 
                ? (await this.input.eval(parse)).toValue()
                : new NullValue();

            this.frozen = true;

            this.updateValueObjects();
        }


        this.setUpdateValues(parse,
        [
            ['type', this.outputType()]
        ]);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }
}



class GTimer
extends GOperator1
{
    interval = null;
   _while    = null;
    loop     = null;



    constructor(nodeId, options)
    {
        super(TIMER, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this. interval = null;
        this._while    = null;
        this. loop     = null;
    }



    copy()
    {
        const copy = new GTimer(this.nodeId, this.options);

        copy.copyBase(this);

        if (this. interval) copy. interval = this. interval.copy();
        if (this._while   ) copy._while    = this._while   .copy();
        if (this. loop    ) copy. loop     = this. loop    .copy();

        return copy;
    }



    isCached()
    {
        return super.isCached()
            && (  !this.input 
                || this.input.isCached());
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const  interval = await evalNumberValue(this. interval, parse);
        const _while    = await evalNumberValue(this._while,    parse);
        const  loop     = await evalNumberValue(this. loop,     parse);
            

        if (this.loop.type != NUMBER_VALUE) assertVolatile(this.loop, this);

        if (_while.value == 0)
            return this;


        if (this.input)
        {
            this.input.invalidateInputs(parse, this, true);

            const input = await evalValue(this.input, parse);

            this.value = input ? input : new NullValue();

            if (this.loop.type != NUMBER_VALUE)
                this.loop.iterateLoop(parse);
        }
        else
            this.value = new NullValue();
            

        this.setUpdateValues(parse,
        [
            ['value',    this.value],
            ['interval', interval  ]
        ]);

        
        this.updateValueObjects();


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value.copy();
    }



    isValid()
    {
        return super.isValid()
            && this.interval && this.interval.isValid()
            && this._while   && this._while  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this. interval) this. interval.pushValueUpdates(parse);
        if (this._while   ) this._while   .pushValueUpdates(parse);
        if (this. loop    ) this. loop    .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this. interval) this. interval.invalidateInputs(parse, from, force);
        if (this._while   ) this._while   .invalidateInputs(parse, from, force);
        if (this. loop    ) this. loop    .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this. interval) this. interval.iterateLoop(parse);
        if (this._while   ) this._while   .iterateLoop(parse);
        if (this. loop    ) this. loop    .iterateLoop(parse);
    }
}



class GGetValueName
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(GET_VALUE_NAME, nodeId, options);
    }


    
    copy()
    {
        const copy = new GGetValueName(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.value) copy.value = this.value.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = new TextValue(
            this.input 
            ? (await this.input.eval(parse)).toValue().valueId
            : '');

        
        this.setUpdateValues(parse,
        [
            ['type', this.outputType()]
        ]);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }
}



class GSetValueName
extends GOperator1
{
    name = null;



    constructor(nodeId, options)
    {
        super(SET_VALUE_NAME, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.name = null;
    }



    copy()
    {
        const copy = new GSetValueName(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.value) copy.value = this.value.copy();
        if (this.name ) copy.name  = this.name .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = 
            this.input 
            ? (await this.input.eval(parse)).toValue() 
            : new NullValue();

        
        const name = await evalTextValue(this.name, parse);


        if (   this.options.enabled
            && this.value.isValid())
            this.value.valueId = name.value;


        this.updateValueObjects();


        this.setUpdateValues(parse,
        [
            ['type', this.outputType()],
            ['name', name             ]
        ]);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return super.isValid()
            && this.name && this.name.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.name) this.name.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.name) this.name.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.name) this.name.iterateLoop(parse);
    }



    resetLoop(parse, nodeId)
    {
        super.resetLoop(parse, nodeId);

        if (this.name) this.name.resetLoop(parse, nodeId);
    }
}



class GGetListValueNames
extends GOperator1
{
    // cachedValue = null;



    constructor(nodeId, options)
    {
        super(GET_LIST_VALUE_NAMES, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        // this.cachedValue = null;
    }



    copy()
    {
        const copy = new GGetListValueNames(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (   this.isCached())
            //&& this.cachedValue)
            return this;


        const input = await evalListValue(this.input, parse);


        this.counts = new ListValue();


        // if (this.cachedValue)
        //     this.value = this.cachedValue.copy();

        // else
        // {
            if (   input
                && input.items)
            {
                if (this.options.enabled)
                {
                    this.value = new ListValue();
                    this.value.objects = [];

                    for (let i = 0; i < input.items.length; i++)
                        this.value.items.push(new TextValue(input.items[i].valueId));

                    if (input.objects)
                    {
                        for (let i = 0; i < input.objects.length; i++)
                            this.value.objects.push(input.objects[i]);
                    }
                }
                else
                    this.value = input.copy();
            }
            else
                this.value = ListValue.NaN.copy();


            // this.cachedValue = this.value.copy();
        // }
    

        this.updateValueObjects();


        this.setUpdateValues(parse, 
        [
            ['type',   this.outputListType()                   ],
            ['length', new NumberValue(this.value.items.length)]
        ]); 
               

        if (parse.settings.showListTooltips)
        {
            this.setUpdateValues(parse,
            [
                ['preview', new ListValue(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]
            ],
            true);
        }


        this.validate();

        return this;
    }
}



class GSetListValueNames
extends GOperator2
{
    constructor(nodeId, options)
    {
        super(SET_LIST_VALUE_NAMES, nodeId, options);
    }


    
    copy()
    {
        const copy = new GSetListValueNames(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.value) copy.value = this.value.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input0 = await evalListValue(this.input0, parse);
        const input1 = await evalListValue(this.input1, parse);

        
        if (   this.options.enabled
            && input0
            && input1
            && input0.items
            && input1.items)
        {
            for (let i = 0; i < input0.items.length && i < input1.items.length; i++)
                input0.items[i].valueId = input1.items[i].value;

            this.value = input0;
        }
        else if (input0)
            this.value = input0;
        else
            this.value = new ListValue();


        this.updateValueObjects();


        this.setUpdateValues(parse,
        [
            ['type', this.outputListType()]
        ]);


        this.validate();

        return this;
    }
}



class GSetObjectName
extends GOperator1
{
    name    = null;
  //addLogo = null;



    constructor(nodeId, options)
    {
        super(SET_OBJECT_NAME, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.name    = null;
      //this.addLogo = null;
    }



    copy()
    {
        const copy = new GSetObjectName(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.value  ) copy.value   = this.value  .copy();
        if (this.name   ) copy.name    = this.name   .copy();
      //if (this.addLogo) copy.addLogo = this.addLogo.copy();

        return copy;
    }



    async eval(parse)
    {
        // if (this.isCached())
        //     return this;


        this.value = 
            this.input 
            ? (await this.input.eval(parse)).toValue() 
            : new NullValue();

        
        const name    = await evalTextValue  (this.name, parse);
      //const addLogo = await evalNumberValue(this.addLogo, parse);

        
        if (   this.options.enabled
            && this.value.isValid()
            && this.value.objects)
        {
            for (const obj of this.value.objects)
            {
                obj.nodeId     = this.nodeId;
                obj.objectName = name.value;
             // obj.objectName = (addLogo.value > 0 ? OBJECT_PREFIX : '') + name.value;
            }
        }


        this.updateValueObjects();


        this.setUpdateValues(parse,
        [
            ['type',    this.outputType()],
            ['name',    name             ]//,
          //['addLogo', addLogo          ]
        ]);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return super.isValid()
            && this.name    && this.name   .isValid()
         // && this.addLogo && this.addLogo.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.name   ) this.name   .pushValueUpdates(parse);
     // if (this.addLogo) this.addLogo.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.name   ) this.name   .invalidateInputs(parse, from, force);
     // if (this.addLogo) this.addLogo.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.name   ) this.name   .iterateLoop(parse);
     // if (this.addLogo) this.addLogo.iterateLoop(parse);
    }



    resetLoop(parse, nodeId)
    {
        super.resetLoop(parse, nodeId);

        if (this.name   ) this.name   .resetLoop(parse, nodeId);
     // if (this.addLogo) this.addLogo.resetLoop(parse, nodeId);
    }
}



class GCombine
extends GOperator
{
    inputs = [];

    value;



    constructor(nodeId, options)
    {
        super(COMBINE, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.inputs = [];
    }



    copy()
    {
        const copy = new GCombine(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        if (this.value) copy.value = this.value.copy();

        return copy;
    }



    isCached()
    {
        for (const input of this.inputs)
            if (!input.isCached())
                return false;

        return super.isCached();
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = new ListValue();

        this.value.objects = [];


        for (let i = 0; i < this.inputs.length; i++)
        {
            const input = await evalValue(this.inputs[i], parse);


            if (   input
                && input.isValid()
                && this.options.enabled)
            {
                if (isListValueType(input.type))
                {
                    if (input.condensed === true)
                        this.value.items.push(input);
                    else
                    {
                        for (const item of input.items)
                            this.value.items.push(item);
                    }
                }
                else
                    this.value.items.push(input);
            }


            const inputObjects = this.copyObjects(input, i);
            
            for (const obj of inputObjects)
            {
                obj.objectId += OBJECT_SEPARATOR + i;
                obj.itemIndex = i;
            }

            this.value.objects.push(...inputObjects);
        }


        // reset object space

        const bounds = getObjBounds(this.value.objects);

        const singlePoint =
               this.value.objects.length  == 1 
            && this.value.objects[0].type == POINT;

        for (const obj of this.value.objects)
        {
            const angle1 = anglev_(obj.sp0, obj.sp1);
            const angle2 = anglev_(obj.sp0, obj.sp2);

            obj.createDefaultSpace(obj.sp0.x, obj.sp0.y);
            
            obj.sp1 = addv(obj.sp0, vector(angle1, 1));
            obj.sp2 = addv(obj.sp0, vector(angle2, 1));

            //obj.resetSpace(bounds, singlePoint);
        }
        

        const length = new NumberValue(this.value.items.length);
        const type   = new TextValue(finalListTypeFromItems(this.value.items));


        this.setUpdateValues(parse,
        [
            ['length', length],
            ['type',   type  ]
        ]);


        if (parse.settings.showListTooltips)
        {
            this.setUpdateValues(parse,
            [
                ['preview', new ListValue(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]
            ],
            true);
        }


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value.copy();
    }



    isValid()
    {
        return !this.inputs.find(i => !i.isValid());
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse));
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        this.inputs.forEach(i => i.invalidateInputs(parse, from, force));
    }



    initLoop(parse, loopId)
    {
        this.inputs.forEach(i => i.initLoop(parse, loopId));
    }



    invalidateLoop(parse, nodeId)
    {
        this.inputs.forEach(i => i.invalidateLoop(parse, nodeId));
    }



    iterateLoop(parse)
    {
        this.inputs.forEach(i => i.iterateLoop(parse));
    }



    iterateCache(parse, from)
    {
        for (const input of this.inputs)
        {
            if (   input.type == LIST
                || input.type == COMBINE
                || input.type == CACHE)
                input.iterateCache(parse, from);
        }
    }



    resetLoop(parse, nodeId)
    {
        this.inputs.forEach(i => i.resetLoop(parse, nodeId));
    }
}


class GListAsItem
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(LIST_AS_ITEM, nodeId, options);
    }


    
    reset()
    {
        super.reset();
    }



    copy()
    {
        const copy = new GListAsItem(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = new ListValue();
        this.value.condensed = true;

        let length = 0;


        const input = await evalListValue(this.input, parse);


        if (input)
        {
            length = input.items.length;
            
                
            if (   isListValueType(input.type)
                && this.options.enabled)
            {
                for (const item of input.items)
                {
                    const copy = item.copy();

                    this.value.items.push(copy);
                }
            }
            else
            {
                const copy = input.copy();

                this.value.items  .push(copy);
                this.value.objects.push(...copy.objects);
            }
        }
        else
            this.value = new ListValue();
    

        this.updateValueObjects();
    

        this.setUpdateValues(parse,
        [
            ['length', new NumberValue(length)                                ],
            ['type',   new TextValue(finalListTypeFromItems(this.value.items))]
        ]);
        

        this.validate();

        return this;
    }
}



class GExtract
extends GOperator1
{
    indices     = null;

    // cachedValue = null;


    
    constructor(nodeId, options)
    {
        super(EXTRACT, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.indices = null;
    
        // this.cachedValue = null;
    }



    copy()
    {
        const copy = new GExtract(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.indices) copy.indices = this.indices.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input   = await evalListValue(this.input,   parse);
        const indices = await evalListValue(this.indices, parse);


        this.value = new ListValue();

        let length = 0;
        

        // if (this.cachedValue)
        //     this.value = this.cachedValue.copy();

        // else
        // {
            if (   input
                && indices
                && input.items)
            {
                length = input.items.length;


                if (this.options.enabled)
                {
                    for (let i = 0; i < indices.items.length; i++)
                    {
                        const item = input.items[Math.round(indices.items[i].value)];
                        
                        this.value.items.push(item ? item.copy() : new NullValue());
                        
                        if (   item
                            && item.objects
                            && this.value.objects) 
                            this.value.objects.push(...item.objects);//input.items[i].objects);
                    }
                }
            }
            else
                this.value = ListValue.NaN.copy();


        //     this.cachedValue = this.value.copy();
        // }


        this.updateValueObjects();


        this.setUpdateValues(parse,
        [
            ['type',    this.outputListType()                   ],
            ['length',  new NumberValue(this.value.items.length)], // used to set start and end maxima
            ['indices', indices                                 ]
        ]);
        

        if (parse.settings.showListTooltips)
        {
            this.setUpdateValues(parse,
            [
                ['preview', new ListValue(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]
            ],
            true);
        }


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.indices && this.indices.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.indices) this.indices.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.indices) this.indices.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.indices) this.indices.iterateLoop(parse);
    }
}



class GSetParam
extends GOperator2
{
    name = null;


    
    constructor(nodeId, options)
    {
        super(SET_PARAM, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.name  = null;
    }



    copy()
    {
        const copy = new GSetParam(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.name) copy.name = this.name.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input0 = await evalValue    (this.input0, parse);
        const input1 = await evalValue    (this.input1, parse);
        const name   = await evalTextValue(this.name,   parse);


        if (   input0
            && name)
        {
            let nameValue = name.value.trim();


            if (isListValueType(input0.type))
            {
                this.value = new ListValue();

                if (this.options.enabled)
                {
                    for (let i = 0; i < input0.items.length; i++)
                    {
                        const item = input0.items[i];

                        if (   input1
                            && name.value.trim() != '')
                            item.customParams.push([nameValue, input1]);

                        
                        if (   item
                            && item[nameValue]
                            && item[nameValue].objects 
                            && this.value.objects)
                            this.value.objects.push(...item[nameValue].objects);
                    }
                }
                else
                    this.value = input0;
            }
            else
            {
                this.value = input0;

                if (   input1
                    && nameValue != ''
                    && this.options.enabled)
                    this.value.customParams.push([nameValue, input1]);
            }
        }
        else
        {
            this.value = new NullValue();
        }


        this.updateValueObjects();


        this.setUpdateValues(parse,
        [
            ['type', this.outputType()],
            ['name', name             ]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.name && this.name.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.name) this.name.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.name) this.name.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.name) this.name.iterateLoop(parse);
    }
}



class GGetParam
extends GOperator1
{
    name = null;


    
    constructor(nodeId, options)
    {
        super(GET_PARAM, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.name  = null;
    }



    copy()
    {
        const copy = new GGetParam(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.name) copy.name = this.name.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input = await evalValue    (this.input, parse);
        const name  = await evalTextValue(this.name,  parse);


        if (   input
            && name
            && name.value.trim() != '')
        {
            if (this.options.enabled)
            {
                if (isListValueType(input.type))
                {
                    this.value = new ListValue();

                    for (let i = 0; i < input.items.length; i++)
                        this.value.items.push(getGetParamValue(input.items[i], name));
                }
                else
                    this.value = getGetParamValue(input, name);
            }
            else
                this.value = input.copy();
        }
        else
        {
            this.value = new NullValue();
        }


        this.updateValueObjects();


        const type = this.outputType();
        
        this.setUpdateValues(parse,
        [
            ['value', this.value],
            ['type',  type      ],
            ['name',  name      ]
        ]);
        

        if (type.value == TEXT_VALUE && parse.settings.showTextTooltips)
        {
            this.setUpdateValues(parse,
            [
                ['preview', this.value]
            ],
            true);
        }
        else if (isListValueType(type.value)   && parse.settings.showListTooltips)
        {
            this.setUpdateValues(parse,
            [
                ['preview', new ListValue(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]
            ],
            true);
        }


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.name && this.name.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.name) this.name.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.name) this.name.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.name) this.name.iterateLoop(parse);
    }
}



function getGetParamValue(input, name)
{
    let nameValue = name.value.trim();


    if (    input
        && !input[nameValue])
    {
             if (input[name.value.toUpperCase()]) nameValue = name.value.toUpperCase();
        else if (input[name.value.toLowerCase()]) nameValue = name.value.toLowerCase();
    }


    let value = null;

    if (   input
        && input[nameValue])
    {
        value = input[nameValue];//.copy();
    }
    else
    {
        const customIndex = input.customParams.findIndex(p => p[0] == nameValue);

        value =
            customIndex > -1
            ? input.customParams[customIndex][1]//.copy()
            : new NullValue();
    }


    if (   input
        && input[nameValue]
        && input[nameValue].objects 
        && this.value.objects)
        value.objects.push(...input[nameValue].objects);


    return value;
}


class GSublist
extends GOperator1
{
    start       = null;
    end         = null;

    // cachedValue = null;


    
    constructor(nodeId, options)
    {
        super(SUBLIST, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.start       = null;
        this.end         = null;

        // this.cachedValue = null;
    }



    copy()
    {
        const copy = new GSublist(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.start) copy.start = this.start.copy();
        if (this.end  ) copy.end   = this.end  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (   this.isCached())
            // && this.cachedValue)
            return this;


        const input = await evalListValue  (this.input, parse);
        const start = await evalNumberValue(this.start, parse);
        const end   = await evalNumberValue(this.end,   parse);


        let length = 0;
            

        // if (this.cachedValue)
        //     this.value = this.cachedValue.copy();

        // else
        // {
            this.value = new ListValue();
            this.value.objects = [];


            if (   input
                && start
                && end)
            {
                if (input.items)
                {
                    length = input.items.length;


                    const _end =
                        end.isValid()
                        ? end
                        : new NumberValue(input.items.length);


                    if (this.options.enabled)
                    {
                        const endValue = 
                            _end.value < 0
                            ? length + _end.value
                            : _end.value;

                        if (start.value < endValue)
                        {
                            for (let i = start.value, j = 0; i < endValue; i++, j++)
                            {
                                const item = input.items[i];
                                
                                this.value.items.push(item ? item.copy() : new NullValue());
                                
                                if (   item
                                    && this.value.objects
                                    && item.objects)
                                {
                                    item.objects.forEach(o => o.itemIndex = j);
                                    this.value.objects.push(...item.objects);
                                }
                            }
                        }
                        else
                            this.value = ListValue.NaN.copy();
                    }
                    else
                        this.value = input.copy();
                }
                else
                    this.value = ListValue.NaN.copy();
            }


            // this.cachedValue = this.value.copy();
        //}


        this.updateValueObjects();


        this.setUpdateValues(parse,
        [
            ['type',       this.outputListType()                          ],
            ['length',     new NumberValue(this.value.items.length)       ], // used to set start and end maxima
            ['fullLength', new NumberValue(input ? input.items.length : 0)], // used to set start and end maxima
            ['start',      start                                          ],
            ['end',        end                                            ]
        ]);
        

        if (parse.settings.showListTooltips)
        {
            this.setUpdateValues(parse,
            [
                ['preview', new ListValue(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]
            ],
            true);
        }


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.start && this.start.isValid()
            && this.end   && this.end  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.start) this.start.pushValueUpdates(parse);
        if (this.end  ) this.end  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.start) this.start.invalidateInputs(parse, from, force);
        if (this.end  ) this.end  .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.start) this.start.iterateLoop(parse);
        if (this.end  ) this.end  .iterateLoop(parse);
    }
}



class GUnique
extends GOperator1
{
    counts      = null;
    indices     = null;

    // cachedValue = null;


    
    constructor(nodeId, options)
    {
        super(UNIQUE, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.counts  = null;
        this.indices = null;
        
        // this.cachedValue = null;
    }



    copy()
    {
        const copy = new GUnique(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.counts ) copy.counts  = this.counts .copy();
        if (this.indices) copy.indices = this.indices.copy();

        return copy;
    }



    async eval(parse)
    {
        if (   this.isCached())
            //&& this.cachedValue)
            return this;


        const input = await evalListValue(this.input, parse);


        // if (this.cachedValue)
        //     this.value = this.cachedValue.copy();

        // else
        // {
            this.counts  = new ListValue();
            this.indices = new ListValue();

            
            if (input)
            {
                if (this.options.enabled)
                {
                    this.value = new ListValue();

                    for (let i = 0; i < input.items.length; i++)
                    {
                        const item       = input.items[i];
                        const foundIndex = this.value.items.findIndex(i => i.equals(item));

                        if (foundIndex < 0)
                        {
                            this.value.items.push(item.copy());

                            if (   this.value.objects
                                && item.objects)
                                this.value.objects.push(...item.objects);

                            this.counts .items.push(new NumberValue(1));
                            this.indices.items.push(new ListValue([new NumberValue(i)]));
                        }
                        else
                        {
                            this.counts .items[foundIndex].value++;
                            this.indices.items[foundIndex].items.push(new NumberValue(i));
                        }
                    }
                }
                else
                    this.value = input.copy();
            }
            else
                this.value = new ListValue();


        //     this.cachedValue = this.value.copy();
        // }


        this.updateValueObjects();


        this.setUpdateValues(parse,
        [
            ['type',    this.outputListType()                   ],
            ['length',  new NumberValue(this.value.items.length)],
            ['counts',  this.counts                             ],
            ['indices', this.indices                            ]
        ]);
        

        if (parse.settings.showListTooltips)
        {
            this.setUpdateValues(parse,
            [
                ['preview', new ListValue(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]
            ],
            true);
        }


        this.validate();

        return this;
    }



    // isValid()
    // {
    //     return super.isValid()
    //         && this.counts  && this.counts .isValid()
    //         && this.indices && this.indices.isValid();
    // }



    // pushValueUpdates(parse)
    // {
    //     super.pushValueUpdates(parse);

    //     if (this.counts ) this.counts .pushValueUpdates(parse);
    //     if (this.indices) this.indices.pushValueUpdates(parse);
    // }



    // invalidateInputs(parse, from, force)
    // {
    //     super.invalidateInputs(parse, from, force);

    //     if (this.counts ) this.counts .invalidateInputs(parse, from, force);
    //     if (this.indices) this.indices.invalidateInputs(parse, from, force);
    // }



    // iterateLoop(parse)
    // {
    //     super.iterateLoop(parse);

    //     if (this.counts ) this.counts .iterateLoop(parse);
    //     if (this.indices) this.indices.iterateLoop(parse);
    // }
}



class GReorderList
extends GOperator1
{
    indices = null;


    
    constructor(nodeId, options)
    {
        super(REORDER_LIST, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.indices = null;
    }



    copy()
    {
        const copy = new GReorderList(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.indices) copy.indices = this.indices.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input   = await evalListValue(this.input,   parse);
        const indices = await evalListValue(this.indices, parse);


        this.value         = new ListValue();
        this.value.objects = [];


        if (   input
            && input.items)
        {
            if (   this.options.enabled
                && indices
                && input.items
                && indices.items
                && input.items.length == indices.items.length)
            {
                this.value.items = new Array(input.items.length);

                for (let i = 0; i < input.items.length; i++)
                    this.value.items[i] = input.items[indices.items[i].value];
                

                for (let i = 0; i < this.value.items.length; i++)
                {
                    const item = this.value.items[i];

                    if (   item.objects
                        && this.value.objects)
                    {
                        const objects = ordered.objects.filter(o => o.itemIndex == itemIndex).map(o => o.copy());
                        objects.forEach(o => o.itemIndex = i);

                        this.value.objects.push(...objects);
                    }
                }
            }
            else
                this.value = input.copy();
        }
        else
            this.value = new ListValue();


        this.updateValueObjects();


        this.setUpdateValues(parse,
        [
            ['type',    this.outputListType()],
            ['indices', indices              ]
        ]);
        

        if (parse.settings.showListTooltips)
        {
            this.setUpdateValues(parse,
            [
                ['preview', new ListValue(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]
            ],
            true);
        }


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.indices && this.indices.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.indices) this.indices.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.indices) this.indices.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.indices) this.indices.iterateLoop(parse);
    }
}


class GShiftList
extends GOperator1
{
    offset = null;


    
    constructor(nodeId, options)
    {
        super(SHIFT_LIST, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.offset = null;
    }



    copy()
    {
        const copy = new GShiftList(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.offset) copy.offset = this.offset.copy();

        return copy;
    }



    async eval(parse)
    {
        if (   this.isCached())
            // && this.cachedValue)
            return this;


        const input  = await evalListValue  (this.input,  parse);
        const offset = await evalNumberValue(this.offset, parse);


        let length = 0;
            

        this.value = new ListValue();
        this.value.objects = [];


        if (   input
            && offset)
        {
            if (input.items)
            {
                length = input.items.length;

                if (this.options.enabled)
                {
                    let _offset = offset.value % input.items.length;
                    while (_offset < 0) _offset += input.items.length;

                    let j = 0;
                    for (let i = _offset; i < input.items.length; i++, j++)
                        this.addItem(input, i, j);

                    for (let i = 0; i < _offset; i++, j++)
                        this.addItem(input, i, j);
                }
                else
                    this.value = input.copy();
            }
            else
                this.value = ListValue.NaN.copy();
        }


        this.updateValueObjects();


        this.setUpdateValues(parse,
        [
            ['type',       this.outputListType()                          ],
            ['length',     new NumberValue(this.value.items.length)       ], // used to set start and end maxima
            ['offset',     offset                                         ]
        ]);
        

        if (parse.settings.showListTooltips)
        {
            this.setUpdateValues(parse,
            [
                ['preview', new ListValue(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]
            ],
            true);
        }


        this.validate();

        return this;
    }



    addItem(input, i, j)
    {
        const item = input.items[i];

        this.value.items.push(item ? item.copy() : new NullValue());
        
        if (   item
            && this.value.objects
            && input.objects)
        {
            // const objects = input.objects.filter(o => o.itemIndex == i);
            item.objects.forEach(o => o.itemIndex = j);

            this.value.objects.push(...item.objects);
        }
    }



    isValid()
    {
        return super.isValid()
            && this.offset && this.offset.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.offset) this.offset.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.offset) this.offset.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.offset) this.offset.iterateLoop(parse);
    }
}



class GReverseList
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(REVERSE_LIST, nodeId, options);
    }


    
    reset()
    {
        super.reset();
    }



    copy()
    {
        const copy = new GReverseList(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input = await evalValue(this.input, parse);


        if (input)
        {
            if (this.options.enabled)
            {
                this.value = new ListValue();
                this.value.objects = [];

                for (let i = input.items.length-1; i >= 0; i--)
                    this.value.items.push(input.items[i]);//.copy());

                if (input.objects)
                {
                    for (let i = input.objects.length-1; i >= 0; i--)
                        this.value.objects.push(input.objects[i]);
                }
            }
            else
                this.value = input.copy();//.copy();
        }
        else
            this.value = ListValue.NaN.copy();
    

        this.updateValueObjects();


        this.setUpdateValues(parse, 
        [
            ['type',   this.outputListType()                   ],
            ['length', new NumberValue(this.value.items.length)]
        ]); 
               

        if (parse.settings.showListTooltips)
        {
            this.setUpdateValues(parse,
            [
                ['preview', new ListValue(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]
            ],
            true);
        }


        this.validate();

        return this;
    }
}



class GBuckleList
extends GOperator1
{
    amount;



    constructor(nodeId, options)
    {
        super(BUCKLE_LIST, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.buckle = null;
    }



    copy()
    {
        const copy = new GBuckleList(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.amount) copy.amount = this.amount.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input  = await evalListValue  (this.input,  parse);
        const amount = await evalNumberValue(this.amount, parse);

        amount.value = Math.round(amount.value);
        
        
        if (   input
            && input.isValid())
        {
            const _amount = Math.min(amount.value + 1, Math.floor(input.items.length/2));

            if (this.options.enabled)
            {
                const temp1 = 
                [
                    ...input.items.slice(input.items.length - _amount).map(i => i.value),
                    ...input.items.slice(0, _amount)                  .map(i => i.value).map(i => i - input.items[0].value + input.items.at(-1).value)
                ];

                const temp2 = 
                [
                    ...input.items.slice(input.items.length - _amount).map(i => i.value).map(i => i - input.items.at(-1).value + input.items[0].value),
                    ...input.items.slice(0, _amount)                  .map(i => i.value)
                ];

                consoleAssert(
                    temp1.length == temp2.length,
                    'error building list edge blend');

                
                const temp = [];

                for (let i = 0; i < _amount*2; i++)
                    temp.push(new NumberValue(lerp(temp1[i], temp2[i], i/(_amount*2-1))));


                this.value = new ListValue();

                for (let i = 0; i < _amount; i++)
                    this.value.items.push(temp[_amount + i]);

                for (let i = _amount; i < input.items.length - _amount; i++)
                    this.value.items.push(input.items[i]);

                for (let i = 0; i < _amount; i++)
                    this.value.items.push(temp[i]);
            }
            else
                this.value = input;
        }
        else
            this.value = ListValue.NaN.copy();
    

        this.setUpdateValues(parse, 
        [
            ['length', new NumberValue(this.value.items.length)],
            ['amount', amount                                  ]
        ]); 
               

        if (parse.settings.showListTooltips)
        {
            this.setUpdateValues(parse,
            [
                ['preview', new ListValue(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]
            ],
            true);
        }


        this.validate();

        return this;
    }
}



class GSort
extends GOperator1
{
    condition     = null;
    reverse       = null;
    indices       = null;

    firstSortNode = null;


    //cachedValue   = null;


    
    constructor(nodeId, options)
    {
        super(SORT, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.condition = null;
        this.reverse   = null;
        this.indices   = null;
    }



    copy()
    {
        const copy = new GSort(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.condition) copy.condition = this.condition.copy();
        if (this.reverse  ) copy.reverse   = this.reverse  .copy();
        if (this.indices  ) copy.indices   = this.indices  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input   = await evalListValue  (this.input,   parse);
        const reverse = await evalNumberValue(this.reverse, parse);


        this.value         = new ListValue();
        this.value.objects = [];


        let maxColumns = 0;

        this.indices = new ListValue();


        if (   input
            && reverse)
        {
            if (this.options.enabled)
            {
                if (  !this.condition
                    || this.condition.getConditionNode)
                {
                    if (this.condition)
                        await this.condition.eval(parse);

                    const conditionNode = 
                        this.condition
                        ? this.condition.getConditionNode(parse)
                        : null;


                    if (  !this.condition
                        || conditionNode)
                    {
                        const reverseMultiplier = reverse.value > 0 ? -1 : 1;
                        const unsorted          = [...input.items];


                        [ input       .items, 
                          this.indices.items ] = await asyncSort(
                            parse, 
                            unsorted, 
                            this.condition 
                            ? conditionNode // specified sort
                            : null,         // default sort
                            this,
                            this.condition, 
                            reverseMultiplier);


                        input.items.forEach(i => maxColumns = Math.max(maxColumns, isListValueType(i.type) ? i.items.length : 1));
                        

                        for (let i = 0; i < input.items.length; i++)
                        {
                            const row       = input   .items[i];
                            const itemIndex = unsorted.indexOf(row);

                            this.value.items.push(row.copy());

                            if (   row.objects
                                && this.value.objects)
                            {
                                const objects = input.objects.filter(o => o.itemIndex == itemIndex).map(o => o.copy());
                                objects.forEach(o => o.itemIndex = i);

                                this.value.objects.push(...objects);
                            }
                        }
                    }
                }
                else
                {
                    this.value   = input;
                    this.indices = new ListValue(Array.from(Array(input.items.length).keys()).map(i => new NumberValue(i)));
                }
            }
            else
            {
                this.value   = input;
                this.indices = new ListValue(Array.from(Array(input.items.length).keys()).map(i => new NumberValue(i)));
            }
        }
        else
        {
            this.value   = new ListValue();
            this.indices = new ListValue();
        }


        this.updateValueObjects();


        this.setUpdateValues(parse,
        [
            ['type',    this.outputListType()                   ],
            ['length',  new NumberValue(this.value.items.length)],
            ['reverse', reverse                                 ],
            ['indices', this.indices                            ]
        ]);
        

        if (parse.settings.showListTooltips)
        {
            this.setUpdateValues(parse,
            [
                ['preview', new ListValue(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]
            ],
            true);
        }


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && (!this.condition || this.condition.isValid())
            && this.reverse && this.reverse.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.condition) this.condition.pushValueUpdates(parse);
        if (this.reverse  ) this.reverse  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.condition) this.condition.invalidateInputs(parse, from, force);
        if (this.reverse  ) this.reverse  .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.condition) this.condition.iterateLoop(parse);
        if (this.reverse  ) this.reverse  .iterateLoop(parse);
    }
}



async function asyncSort(parse, unsorted, conditionNode, node, condition, reverseMultiplier)
{
    const oldInput = conditionNode ? conditionNode.input : null;


    const sorted  = [];


    for (let i = 0; i < unsorted.length; i++)
    {
        const item = unsorted[i];

        const cond = await getSortCondition(parse, conditionNode, node, condition, item);
        if (!cond) return [unsorted, [...unsorted.keys()]];
        
        const condValue = cond.toValue();
        //console.log('condValue =', condValue.value);

        if (   condValue.type != NUMBER_VALUE
            && condValue.type != TEXT_VALUE) 
            return [unsorted, [...unsorted.keys()]];

        sorted.push({item, condition: condValue.value, index: i});
    }


    sorted.sort((a, b) =>
    {
        if (   typeof(a.condition) == 'number'
            && typeof(b.condition) == 'number')
        {
            if (a.condition < b.condition) return -1*reverseMultiplier;
            if (a.condition > b.condition) return  1*reverseMultiplier;
        }
        else if (typeof(a.condition) == 'string'
              && typeof(b.condition) == 'string')
        {
            if (a.condition.localeCompare(b.condition) < 0) return -1*reverseMultiplier;
            if (a.condition.localeCompare(b.condition) > 0) return  1*reverseMultiplier;
        }

        return 0;
    });


    if (conditionNode)
        conditionNode.input = oldInput;


    return [ sorted.map(item => item.item), 
             sorted.map(item => new NumberValue(item.index)) ];
}



async function getSortCondition(parse, conditionNode, node, condition, item)
{
    if (!conditionNode)
        return item;
    
    conditionNode.reset();

    conditionNode.input = item.copy();
    condition.invalidateInputs(parse, node, true); 

    return await condition.eval(parse);
}


class GFilter
extends GOperator1
{
    condition = null;
    indices   = null;

    //firstSortNode = null;


    
    constructor(nodeId, options)
    {
        super(FILTER, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.condition = null;
        this.indices   = null;
    }



    copy()
    {
        const copy = new GFilter(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.condition) copy.condition = this.condition.copy();
        if (this.indices  ) copy.indices   = this.indices  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input = await evalListValue(this.input, parse);


        this.value         = new ListValue();
        this.value.objects = [];

        let maxColumns = 0;

        
        this.indices = new ListValue();


        if (input)
        {
            if (this.options.enabled)
            {
                if (  !this.condition
                    || this.condition.getConditionNode)
                {
                    if (this.condition)
                        await this.condition.eval(parse);

                    const conditionNode = 
                        this.condition
                        ? this.condition.getConditionNode(parse)
                        : null;


                    if (  !this.condition
                        || conditionNode)
                    {
                        const unfiltered = [...input.items];


                        [input.items, this.indices.items] = await asyncFilter(
                            parse, 
                            unfiltered, 
                            conditionNode,
                            this,
                            this.condition);


                        input.items.forEach(i => maxColumns = Math.max(maxColumns, isListValueType(i.type) ? i.items.length : 1));
                        

                        for (let i = 0; i < input.items.length; i++)
                        {
                            const row       = input   .items[i];
                            const itemIndex = unfiltered.indexOf(row);

                            this.value.items.push(row.copy());

                            if (   row.objects
                                && this.value.objects)
                            {
                                const objects = input.objects.filter(o => o.itemIndex == itemIndex).map(o => o.copy());
                                objects.forEach(o => o.itemIndex = i);

                                this.value.objects.push(...objects);
                            }
                        }
                    }
                }
                else
                    this.value = await evalListValue(this.input, parse);
            }
            else
                this.value = input.copy();
        }
        else
            this.value = new ListValue();


        this.updateValueObjects();


        this.setUpdateValues(parse,
        [
            ['type',    this.outputListType()                   ],
            ['length',  new NumberValue(this.value.items.length)],
            ['indices', this.indices                            ]
        ]);
        

        if (parse.settings.showListTooltips)
        {
            this.setUpdateValues(parse,
            [
                ['preview', new ListValue(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]
            ],
            true);
        }


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && (!this.condition || this.condition.isValid());
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.condition) this.condition.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.condition) this.condition.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.condition) this.condition.iterateLoop(parse);
    }
}



async function asyncFilter(parse, array, conditionNode, node, condition)
{
    const oldInput = conditionNode ? conditionNode.input : null;

    const filtered = [];
    const indices  = [];

    for (let i = 0; i < array.length; i++)
    {
        const item = array[i];

        const cond = await getFilterCondition(parse, conditionNode, node, condition, item);
        if (!cond) return array;
        
        const condValue = cond.toValue();
        //console.log('cond =', cond)

        if (   condValue.type == NUMBER_VALUE
            && condValue.value > 0)
        {
            filtered.push(item);
            indices .push(new NumberValue(i));
        }
    }

    if (conditionNode)
        conditionNode.input = oldInput;

    return [filtered, indices];
}



async function getFilterCondition(parse, conditionNode, node, condition, item)
{
    if (!conditionNode)
        return item;
    
    conditionNode.reset();

    const value = conditionNode.toValue();
    if (!value) return item;

    if (   value.type == item.type
        || value.type == ANY_VALUE)
    {
        conditionNode.input = item.copy();
        condition.invalidateInputs(parse, node, true); 
    }

    return await condition.eval(parse);
}


class GColumn
extends GOperator1
{
    index       = null;

    // cachedValue = null;


    
    constructor(nodeId, options)
    {
        super(COLUMN, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.index       = null;

        // this.cachedValue = null;
    }



    copy()
    {
        const copy = new GColumn(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.index) copy.index = this.index.copy();

        return copy;
    }



    async eval(parse)
    {
        if (   this.isCached())
            // && this.cachedValue)
            return this;


        const input = await evalListValue  (this.input, parse);
        const index = await evalNumberValue(this.index, parse);

        
        this.value = new ListValue();

        let maxColumns = 0;


        // if (this.cachedValue)
        //     this.value = this.cachedValue.copy();

        // else
        // {
            if (   input
                && index)
            {
                if (isTable(input))
                {
                    input.items.forEach(i => maxColumns = Math.max(maxColumns, i.items.length));

                    if (index.value < maxColumns)
                    {
                        const valueIds = [];

                        for (let i = 0; i < input.items.length; i++)
                        {
                            const row = input.items[i];

                            if (index.value < row.items.length)
                            {
                                const item = row.items[index.value].copy();

                                item.valueId = getNewNumberId(
                                    item.valueId, 
                                    id => valueIds.filter(_id => _id == id).length,
                                    item.valueId,
                                    '',
                                    1,
                                    true);
                               
                                this.value.items.push(item);

                                pushUnique(valueIds, item.valueId);

                                if (   this.value.objects 
                                    && row.items[index.value].objects)
                                    this.value.objects.push(...row.items[index.value].objects);
                            }
                        }
                    }
                }
                else if (isListValueType(input.type))
                {
                    this.value = input.copy();
                    maxColumns = 1;
                }
            }


        //     this.cachedValue = this.value.copy();
        // }


        this.updateValueObjects();

        this.setUpdateValues(parse,
        [
            ['type',    this.outputListType()                   ],
            ['length',  new NumberValue(this.value.items.length)],
            ['columns', new NumberValue(maxColumns, 0)          ],
            ['index',   index                                   ]
        ]);
    

        if (parse.settings.showListTooltips)
        {
            this.setUpdateValues(parse,
            [
                ['preview', new ListValue(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]
            ],
            true);
        }
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.index && this.index.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.index) this.index.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.index) this.index.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.index) this.index.iterateLoop(parse);
    }
}



function isTable(value)
{
    if (!isListValueType(value.type))
        return false;

    for (const item of value.items)
    {
        if (!isListValueType(item.type))
            return false;
    }

    return true;
}


class GCell
extends GOperator1
{
    column;
    row;


    
    constructor(nodeId, options)
    {
        super(CELL, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.column = null;
        this.row    = null;
    }



    copy()
    {
        const copy = new GCell(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.column) copy.column = this.column.copy();
        if (this.row   ) copy.row    = this.row   .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input  = await evalListValue  (this.input,  parse);
        const column = await evalNumberValue(this.column, parse);
        const row    = await evalNumberValue(this.row,    parse);


        let columns = 0;
        let rows    = 0;

        if (   input
            && column
            && row)
        {
            if (isTable(input))
            {
                rows = input.items.length;

                input.items.forEach(i => columns = Math.max(columns, i.items ? i.items.length : null));

                if (row.value < rows)
                {
                    const _row = input.items[row.value];

                    if (column.value < columns)
                        this.value = _row.items[column.value].copy();
                    else
                        this.value = new NullValue();
                }
                else
                    this.value = new NullValue();
            }
            else
                this.value = new NullValue();
        }
        else
            this.value = new NullValue();


        this.setUpdateValues(parse,
        [
            //['preview', this.value                 ],
            ['type',    this.outputType()          ],
            ['columns', new NumberValue(columns, 0)],
            ['rows',    new NumberValue(rows   , 0)]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.column && this.column.isValid()
            && this.row    && this.row   .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.column) this.column.pushValueUpdates(parse);
        if (this.row   ) this.row   .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.column) this.column.invalidateInputs(parse, from, force);
        if (this.row   ) this.row   .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.column) this.column.iterateLoop(parse);
        if (this.row   ) this.row   .iterateLoop(parse);
    }
}


class GList
extends GOperator1
{
    cachedValue = null;



    constructor(nodeId, options)
    {
        super(LIST, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.cachedValue = null;
    }



    copy()
    {
        const copy = new GList(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) copy.input = this.input.copy();
        
        for (const key of this.keys())
        {
            if (this[key] instanceof GValue)
                Object.assign(copy, {[key]: this[key]});
        }

        return copy;
    }



    paramFromId(paramId)
    {
        let param =
               this.value
            && this.value.items
            && paramId != 'value'
            ? this.value.items.find(i => i.valueId == paramId)
            : null;

        if (!param)
            param = this[paramId];

        return param;
    }



    async eval(parse)
    {
        if (   this.isCached()
            && this.cachedValue)
            return this;


        const input = await evalListValue(this.input, parse); 


        if (this.cachedValue)
           this.value = this.cachedValue.copy();

        else
        {
            this.value = input ?? new NullValue();
            this.cachedValue = this.value.copy();
        }


        this.updateValues = [];


        if (    this.value.isValid()
            &&  this.value.items
            && !isEmpty(this.value.items))
        {
            const valueIds = [];

            
            for (let i = 0; i < this.value.items.length; i++)
            {
                const item = this.value.items[i];
                
                let valueId = 
                    item.valueId.trim() != ''
                    ? item.valueId
                    : i.toString();

                valueId = getNewNumberId(
                    valueId,
                    id => valueIds.filter(_id => _id == id).length,
                    valueId,
                    '',
                    1,
                    true);

                valueIds.push(valueId);
            }


            for (let i = 0; i < this.value.items.length; i++)
            {
                let valueId = valueIds[i];

                const item = this.value.items[i];
                
                Object.assign(this, {[valueId]: item});
                this.setUpdateValues(parse, [[valueId, item]], true);

                item.sortId = i;
            }


            this.updateValues.sort((a, b) => a.sortId - b.sortId);


            this.setUpdateValues(parse, [['-type-', this.outputType()]], true);
        }
        else
            this.setUpdateValues(parse, [['-type-', new TextValue(LIST_VALUE)]], true);


        this.updateValueObjects();


        this.validate();

        return this;
    }
    
    

    toValue()
    {
        return this.value.copy();
    }



    iterateCache(parse, from)
    {
        this.cachedValue = null;
    }
}


class GSelect
extends GOperator
{
    inputs = [];

    index = null;


    
    constructor(nodeId, options)
    {
        super(SELECT, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.inputs = [];
        
        this.index = null;
    }


   
    copy()
    {
        const copy = new GSelect(this.nodeId, this.options);

        copy.copyBase(this);
        
        copy.inputs = this.inputs.map(i => i.copy());

        if (this.index) copy.index = this.index.copy();
        if (this.value) copy.value = this.value.copy();

        return copy;
    }



    isCached()
    {
        for (const input of this.inputs)
            if (!input.isCached())
                return false;

        return super.isCached();
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        let index  = await evalNumberValue(this.index, parse);
        let length = 0;


        const inputs = [];

        for (let i = 0; i < this.inputs.length; i++)
            inputs.push(await evalValue(this.inputs[i], parse));


        if (inputs.length > 0)
        {
            length = inputs.length;


            index = 
                   index.isValid()
                && index.value >= -inputs.length
                && index.value <   inputs.length
                ? new NumberValue(Math.round(index.value))
                : new NumberValue(0);
            

            if (   index.isValid()
                && index.value >= -inputs.length
                && index.value <   inputs.length)
            {
                this.value = inputs.at(index.value);

                
                if (this.value.objects)
                {
                    for (let i = 0; i < this.value.objects.length; i++)
                    {
                        const obj = this.value.objects[i];

                        obj.nodeId = this.nodeId;
                        obj.listId = -1;

                        obj.objectId = this.nodeId;
                        
                        if (obj.objectId != NULL) 
                            obj.objectId += '/';

                        obj.objectId += index.value.toString();

                        if (this.value.objects.length > 1)
                        {
                            obj.objectId += '/';
                            obj.objectId += i.toString();
                        }
                    }
                }
            }
            else
            {
                this.value = new NullValue();
            }
        }
        else
        {
            this.value = new NullValue();
        }

        
        const type = this.outputType();

        this.setUpdateValues(parse,
        [
            ['value',      type == COLOR_VALUE 
                        || type == FILL_VALUE 
                        ? this.value 
                        : new NullValue()      ],
            ['type',    type                   ],
            ['length',  new NumberValue(length)],
            ['index',   index                  ]
        ]);


        if (type.value == TEXT_VALUE && parse.settings.showTextTooltips)
        {
            this.setUpdateValues(parse,
            [
                ['preview', this.value]
            ],
            true);
        }
        else if (isListValueType(type.value) && parse.settings.showListTooltips)
        {
            this.setUpdateValues(parse,
            [
                ['preview', new ListValue(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]
            ],
            true);
        }


        this.validate();

        return this;
    }



    isValid()
    {
        return !this.inputs.find(i => !i.isValid())
            &&  this.index && this.index.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse));

        if (this.index) this.index.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        this.inputs.forEach(i => i.invalidateInputs(parse, from, force));

        if (this.index) this.index.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        this.inputs.forEach(i => i.iterateLoop(parse));

        if (this.index) this.index.iterateLoop(parse);
    }
}


class GSelectFromList
extends GOperator1
{
    index = null;



    constructor(nodeId, options)
    {
        super(SELECT_FROM_LIST, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.index = null;
    }



    copy()
    {
        const copy = new GSelectFromList(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) copy.input = this.input.copy();
        if (this.index) copy.index = this.index.copy();
        if (this.value) copy.value = this.value.copy();

        return copy;
    }



    isCached()
    {
        return super.isCached()
            && (  !this.input 
                || this.input.isCached());
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        const input = await evalListValue  (this.input, parse);
        let   index = await evalNumberValue(this.index, parse);
        
        let  length = 0;
        
        
        //console.log('SFL input =', input);
        if (   input
            && input.isValid()
            && isListValueType(input.type)
            && input.items
            && input.items.length > 0)
        {
            length = input.items.length;


            index = 
                   index.isValid()
                && index.value >= -length
                && index.value <   length
                ? new NumberValue(Math.round(index.value))
                : new NumberValue(0);
            

            if (   index.isValid()
                && index.value >= -length
                && index.value <   length)
            {
                this.value = input.items.at(index.value);
                
                if (   input.objects
                    && input.objects.at(index.value))
                    this.value.objects = [input.objects.at(index.value)];


                if (this.value.objects)
                {
                    for (let i = 0; i < this.value.objects.length; i++)
                    {
                        const obj = this.value.objects[i];

                        obj.nodeId = this.nodeId;
                        obj.listId = -1;

                        obj.objectId = this.nodeId;
                        
                        if (obj.objectId != NULL)
                            obj.objectId += '/';

                        obj.objectId += index.value.toString();
                    }
                }
            }
            else
            {
                this.value = new NullValue();
            }
        }
        else 
        {
            this.value = new NullValue();
        }


        const type = this.outputType();

        
        this.setUpdateValues(parse,
        [
            ['value',      type == COLOR_VALUE 
                        || type == FILL_VALUE 
                        ? this.value 
                        : new NullValue()],
            ['type',    type                   ],
            ['length',  new NumberValue(length)],
            ['index',   index                  ]
        ]);


        if (type.value == TEXT_VALUE && parse.settings.showTextTooltips)
        {
            this.setUpdateValues(parse,
            [
                ['preview', this.value]
            ],
            true);
        }
        else if (isListValueType(type.value) && parse.settings.showListTooltips)
        {
            this.setUpdateValues(parse,
            [
                ['preview', new ListValue(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]
            ],
            true);
        }


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.index && this.index.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.index) this.index.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.index) this.index.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.index) this.index.iterateLoop(parse);
    }
}


class GListCount
extends GOperator1
{
    start = null;



    constructor(nodeId, options)
    {
        super(LIST_COUNT, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.start = null;
    }



    copy()
    {
        const copy = new GListCount(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) copy.input = this.input.copy();
        if (this.start) copy.start = this.start.copy();
        
        if (this.count) copy.count = this.count.copy();

        return copy;
    }



    isCached()
    {
        return super.isCached()
            && (  !this.input 
                || this.input.isCached());
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input = await evalListValue  (this.input, parse);
        const start = await evalNumberValue(this.start, parse);

        
        if (input)
        {
            const count = input.items.length;
            this.value = new NumberValue(count - (start.value == 0 ? 1 : 0));
        }
        else
            this.value = NumberValue.NaN.copy();


        this.setUpdateValues(parse,
        [
            ['value', this.value],
            ['start', start     ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.start && this.start.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.start) this.start.pushValueUpdates(parse);
    }    



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.start) this.start.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.start) this.start.iterateLoop(parse);
    }    
}


class GObjectCount
extends GOperator1
{
    start = null;



    constructor(nodeId, options)
    {
        super(LIST_COUNT, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.start = null;
    }



    copy()
    {
        const copy = new GListCount(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) copy.input = this.input.copy();
        if (this.start) copy.start = this.start.copy();
        
        if (this.count) copy.count = this.count.copy();

        return copy;
    }



    isCached()
    {
        return super.isCached()
            && (  !this.input 
                || this.input.isCached());
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input = await evalValue      (this.input, parse);
        const start = await evalNumberValue(this.start, parse);

        
        if (input)
        {
            const count = 
                input.objects
                ? input.objects.length
                : 0;

            this.value = new NumberValue(count - (start.value == 0 ? 1 : 0));
        }
        else
            this.value = NumberValue.NaN.copy();


        this.setUpdateValues(parse,
        [
            ['value', this.value],
            ['start', start     ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.start && this.start.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.start) this.start.pushValueUpdates(parse);
    }    



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.start) this.start.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.start) this.start.iterateLoop(parse);
    }    
}


class GListContains
extends GOperator2
{
    first;
    last;
    all;



    constructor(nodeId, options)
    {
        super(LIST_CONTAINS, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.first = null;
        this.last  = null;
        this.all   = null;
    }



    copy()
    {
        const copy = new GListContains(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.first = null) copy.first = this.first.copy();
        if (this.last  = null) copy.last  = this.last .copy();
        if (this.all   = null) copy.all   = this.all  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input0 = await evalListValue(this.input0, parse);
        const input1 = await evalValue    (this.input1, parse);
    

        if (   input0 && input0.isValid() 
            && input1 && input1.isValid())
        {
            if (isValueListOfLists(input0))
            {
                if (isListValueType(input1.type))
                {
                    let result = false;

                    for (const item of input0.items)
                    {
                        if (item.equals(input1))
                        {
                            result = true;
                            break;
                        }
                    }

                    this.value = new NumberValue(result ? 1 : 0, 0, true);
                }
                else // non-list value
                {
                    this.value = new ListValue();

                    for (const item of input0.items)
                    {
                        this.value.items.push(
                            isListValueType(item.type)
                            ? new NumberValue(item.items.find(i => i.equals(input1)) ? 1 : 0, 0, true)
                            : NumberValue.NaN.copy());
                    }
                }
            }
            else
            {
                this.value = new NumberValue(input0.items.find(i => i.equals(input1)) ? 1 : 0, 0, true);
            }
        }
        else                  
        {
            this.value = NumberValue.NaN.copy();
        }
    

        this.setUpdateValues(parse,
        [
            ['type', this.outputType()]
        ]);


        this.validate();

        return this;
    }
}


class GListFind
extends GOperator2
{
    first;
    last;
    all;



    constructor(nodeId, options)
    {
        super(LIST_FIND, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.first = null;
        this.last  = null;
        this.all   = null;
    }



    copy()
    {
        const copy = new GListFind(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input0 = await evalListValue(this.input0, parse);
        const input1 = await evalValue    (this.input1, parse);
    

        if (   input0 && input0.isValid() 
            && input1 && input1.isValid())
        {
            const indices = [];

            
            if (   input1
                && input1.isValid())
            {
                for (let i = 0; i < input0.items.length; i++)
                {
                    if (input0.items[i].equals(input1))
                        indices.push(i);
                }  


                this.value = new NumberValue(indices.length > 0 ? 1 : 0);

                this.first = indices.length > 0 ? new NumberValue(indices.at( 0)) : NumberValue.NaN.copy();
                this.last  = indices.length > 0 ? new NumberValue(indices.at(-1)) : NumberValue.NaN.copy();

                this.all   = new ListValue();

                for (const index of indices)
                    this.all.items.push(new NumberValue(index));
            }
            else
            {
                this.value = new NumberValue(1);

                this.first = NumberValue.NaN.copy();
                this.last  = NumberValue.NaN.copy();
                this.all   =   ListValue.NaN.copy();
            }
        }
        else                  
        {
            this.value = NumberValue.NaN.copy();
            this.first = NumberValue.NaN.copy();
            this.last  = NumberValue.NaN.copy();
            this.all   =   ListValue.NaN.copy();
        }
    

        this.setUpdateValues(parse,
        [
            ['value', this.value],
            ['first', this.first],
            ['last',  this.last ],
            ['all',   this.all  ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.first && this.first.isValid()
            && this.last  && this.last .isValid()
            && this.all   && this.all  .isValid();
    }
}


class GIfElse
extends GOperator
{
    input0    = null;
    input1    = null;

    condition = null;



    constructor(nodeId, options)
    {
        super(IF_ELSE, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.input0    = null;
        this.input1    = null;

        this.condition = null;
    }



    copy()
    {
        const copy = new GIfElse(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input0   ) copy.input0    = this.input0   .copy();
        if (this.input1   ) copy.input1    = this.input1   .copy();

        if (this.condition) copy.condition = this.condition.copy();

        if (this.value    ) copy.value     = this.value    .copy();

        return copy;
    }



    isCached()
    {
        return super.isCached()
            && (!this.input0 || this.input0.isCached())
            && (!this.input1 || this.input1.isCached());
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        const input0 = await evalValue(this.input0, parse);
        const input1 = await evalValue(this.input1, parse);
        
        const cond   = await evalNumberValue(this.condition, parse);


          if (   input0 
              && input1) this.value = cond.value != 0 ? input0 : input1;
        else if (input0) this.value = cond.value != 0 ? input0 : new NullValue();
        else if (input1) this.value = cond.value == 0 ? input1 : new NullValue();
        else             this.value = new NullValue();


        this.updateValueObjects();


        this.setUpdateValues(parse,
        [
            ['type',      this.outputType()],
            ['condition', cond             ]
        ]);
        
        
        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy() 
             : null;
    }



    isValid()
    {
        return this.input0    && this.input0   .isValid()
            && this.input1    && this.input1   .isValid()
            && this.condition && this.condition.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input0   ) this.input0   .pushValueUpdates(parse);
        if (this.input1   ) this.input1   .pushValueUpdates(parse);
        if (this.condition) this.condition.pushValueUpdates(parse);
    }    



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.input0   ) this.input0   .invalidateInputs(parse, from, force);
        if (this.input1   ) this.input1   .invalidateInputs(parse, from, force);
        if (this.condition) this.condition.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input0   ) this.input0   .iterateLoop(parse);
        if (this.input1   ) this.input1   .iterateLoop(parse);
        if (this.condition) this.condition.iterateLoop(parse);
    }    
}



class GArithmetic
extends GOperator
{
    inputs = [];



    reset()
    {
        super.reset();

        this.inputs = [];
    }



    getConditionNode()
    {
        const conditionNodes = [];

        for (const input of this.inputs)
        {
            const conditionNode = input.getConditionNode();
            if (conditionNode) conditionNodes.push(conditionNode);            
        }

        console.assert(conditionNodes.length < 2, 'Error: sort order requires not more than one order node');

        return conditionNodes.length == 1
             ? conditionNodes[0]
             : null;
    }



    isCached()
    {
        for (const input of this.inputs)
            if (!input.isCached())
                return false;

        return super.isCached();
    }



    isValid()
    {
        return  this.inputs.length > 0
            && !this.inputs.find(i => !i.isValid());
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse));
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        this.inputs.forEach(i => i.invalidateInputs(parse, from, force));
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        this.inputs.forEach(i => i.iterateLoop(parse));
    }
}



class GNumber
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(NUMBER, nodeId, options);
    }



    copy()
    {
        const copy = new GNumber(this.nodeId, this.options);
        
        copy.copyBase(this);

        copy.value = this.value;

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input = await evalNumberValue(this.input, parse);


        if (input)
            this.value = input;
        else if (this.value)
            await this.value.eval(parse);
        else
            this.value = NumberValue.NaN.copy();


        this.setUpdateValues(parse, 
        [
            ['value', this.value]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return !this.input 
             || this.input.isValid();
    }
}


class GBooleanNumber
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(BOOLEAN_NUMBER, nodeId, options);
    }



    copy()
    {
        const copy = new GBooleanNumber(this.nodeId, this.options);
        
        copy.copyBase(this);

        copy.value = this.value;

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input = await evalNumberValue(this.input, parse);


        if (input)
            this.value = input;
        else if (this.value)
            await this.value.eval(parse);
        else
            this.value = NumberValue.NaN.copy();


        // force 0 or 1
        if (this.value.isValid())
        {
            this.value = new NumberValue(
                Math.round(Math.min(Math.max(0, this.value.value), 1)), 
                0,
                true);
        }

        this.setUpdateValues(parse, 
        [
            ['value', this.value]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return !this.input 
             || this.input.isValid();
    }
}


class GSetPrecision
extends GOperator1
{
    decimals;



    constructor(nodeId, options)
    {
        super(NUMBER_PRECISION, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.decimals = null;
    }



    copy()
    {
        const copy = new GSetPrecision(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.decimals) copy.decimals = this.decimals.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = new NumberValue(0);

        
        const input    = await evalNumberOrListValue(this.input,    parse);
        const decimals = await evalNumberValue      (this.decimals, parse);


        if (input)
        {
            if (this.options.enabled)
            {
                if (isListValueType(input.type))
                {
                    this.value = new ListValue();

                    for (let i = 0; i < input.items.length; i++)
                    {
                        const item = input.items[i];

                        this.value.items.push(
                            item.type == NUMBER_VALUE
                            ? getSetPrecisionValue(item, decimals)
                            : NumberValue.NaN.copy());   
                    }
                }
                else
                    this.value = getSetPrecisionValue(input, decimals);
            }
            else
                this.value = input;
        }
        else
            this.value = NumberValue.NaN.copy();


        this.setUpdateValues(parse,
        [
            ['type',     this.outputType()],
            ['value',    this.value       ],
            ['decimals', decimals         ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.decimals && this.decimals.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.decimals) this.decimals.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.decimals) this.decimals.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.decimals) this.decimals.iterateLoop(parse);
    }
}



function getSetPrecisionValue(input, decimals)
{
    consoleAssert(
         input == NUMBER_VALUE, 
        'input must be NUMBER_VALUE');

    return new NumberValue(input.value, decimals.value);
}


class GSign
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(NUMBER_SIGN, nodeId, options);
    }


    
    copy()
    {
        const copy = new GSign(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input = await evalNumberOrListValue(this.input, parse);


        if (input)
        {
            if (isListValueType(input.type))
            {
                this.value = new ListValue();

                for (let i = 0; i < input.items.length; i++)
                {
                    const item = input.items[i];

                    this.value.items.push(
                        item.type == NUMBER_VALUE
                        ? getSignValue(item)
                        : NumberValue.NaN.copy());   
                }
            }
            else
                this.value = getSignValue(input);
}
        else
            this.value = NumberValue.NaN.copy();


        this.setUpdateValues(parse, 
        [
            ['type', this.outputType()]
        ]);


        this.validate();

        return this;
    }
}



function getSignValue(input)
{
    consoleAssert(
         input.type == NUMBER_VALUE, 
        'input.type must be NUMBER_VALUE');

    return new NumberValue(Math.sign(input.value));
}


class GAbsolute
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(NUMBER_ABSOLUTE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GAbsolute(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input = await evalNumberOrListValue(this.input, parse);


        if (input)
        {
            if (isListValueType(input.type))
            {
                this.value = new ListValue();

                for (let i = 0; i < input.items.length; i++)
                {
                    const item = input.items[i];

                    this.value.items.push(
                        item.type == NUMBER_VALUE
                        ? getAbsoluteValue(item, this.options.enabled)
                        : NumberValue.NaN.copy());   
                }
            }
            else
                this.value = getAbsoluteValue(input, this.options.enabled);
        }
        else
            this.value = NumberValue.NaN.copy();


        this.setUpdateValues(parse, 
        [
            ['type', this.outputType()]
        ]);


        this.validate();

        return this;
    }
}



function getAbsoluteValue(input, enabled)
{
    consoleAssert(
         input.type == NUMBER_VALUE, 
        'input.type must be NUMBER_VALUE');

    return enabled
        ? new NumberValue(Math.abs(input.value), input.decimals)
        : input;
}


class GNegative
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(NUMBER_NEGATIVE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GNegative(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input = await evalNumberOrListValue(this.input, parse);

            
        if (input)
        {
            if (isListValueType(input.type))
            {
                this.value = new ListValue();

                for (let i = 0; i < input.items.length; i++)
                {
                    const item = input.items[i];

                    this.value.items.push(
                        item.type == NUMBER_VALUE
                        ? getNegativeValue(item, this.options.enabled)
                        : NumberValue.NaN.copy());   
                }
            }
            else
                this.value = getNegativeValue(input, this.options.enabled);
        }
        else
            this.value = NumberValue.NaN.copy();


        this.setUpdateValues(parse, 
        [
            ['type', this.outputType()]
        ]);


        this.validate();

        return this;
    }
}



function getNegativeValue(input, enabled)
{
    consoleAssert(
         input == NUMBER_VALUE, 
        'input must be NUMBER_VALUE');

    return new NumberValue(
        (enabled ? -1 : 1) * input.value,
        input.decimals);
}


class GRound
extends GOperator1
{
    type;
    decimals;



    constructor(nodeId, options)
    {
        super(NUMBER_ROUND, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.type     = null;
        this.decimals = null;
    }



    copy()
    {
        const copy = new GRound(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.type    ) copy.type     = this.type    .copy();
        if (this.decimals) copy.decimals = this.decimals.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = new NumberValue(0);

        
        const input = await evalNumberOrListValue(this.input,    parse);
        const type  = await evalNumberValue      (this.type,     parse);
        const dec   = await evalNumberValue      (this.decimals, parse);


        if (   input
            && type
            && dec)
        {
            if (isListValueType(input.type))
            {
                this.value = new ListValue();

                for (let i = 0; i < input.items.length; i++)
                {
                    const item = input.items[i];

                    this.value.items.push(
                        item.type == NUMBER_VALUE
                        ? getRoundValue(item, type, dec, this.options.enabled)
                        : NumberValue.NaN.copy());   
                }
            }
            else
                this.value = getRoundValue(input, type, dec, this.options.enabled);
}
        else
            this.value = NumberValue.NaN.copy();


        this.setUpdateValues(parse,
        [
            ['_type',    this.outputType()],
            ['type',     type             ],
            ['decimals', dec              ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.type     && this.type    .isValid()
            && this.decimals && this.decimals.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.type    ) this.type    .pushValueUpdates(parse);
        if (this.decimals) this.decimals.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.type    ) this.type    .invalidateInputs(parse, from, force);
        if (this.decimals) this.decimals.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.type    ) this.type    .iterateLoop(parse);
        if (this.decimals) this.decimals.iterateLoop(parse);
    }
}



function getRoundValue(input, type, dec, enabled)
{
    consoleAssert(
        input.type == NUMBER_VALUE, 
       'input.type must be NUMBER_VALUE');


    if (!enabled)
        return input;

    switch (type.value)
    {
        case 0: return new NumberValue(floorTo(input.value, dec.value), dec.value);
        case 1: return new NumberValue(roundTo(input.value, dec.value), dec.value);
        case 2: return new NumberValue( ceilTo(input.value, dec.value), dec.value);
    }
}


class GQuantize
extends GOperator1
{
    type;
    base;
    step;
    amount;



    constructor(nodeId, options)
    {
        super(NUMBER_QUANTIZE, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.type   = null;
        this.base   = null;
        this.step   = null;
        this.amount = null;
    }



    copy()
    {
        const copy = new GQuantize(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.type  ) copy.type   = this.type  .copy();
        if (this.base  ) copy.base   = this.base  .copy();
        if (this.step  ) copy.step   = this.step  .copy();
        if (this.amount) copy.amount = this.amount.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = new NumberValue(0);

        
        const input  = await evalNumberOrListValue(this.input,  parse);
        const type   = await evalNumberValue      (this.type,   parse);
        const base   = await evalNumberValue      (this.base,   parse);
        const step   = await evalNumberValue      (this.step,   parse);
        const amount = await evalNumberValue      (this.amount, parse);


        if (input)
        {
            if (isListValueType(input.type))
            {
                this.value = new ListValue();

                for (let i = 0; i < input.items.length; i++)
                {
                    const item = input.items[i];

                    this.value.items.push(
                        item.type == NUMBER_VALUE
                        ? getQuantizeValue(item, type, base, step, amount, this.options.enabled)
                        : NumberValue.NaN.copy());   
                }
            }
            else
                this.value = getQuantizeValue(input, type, base, step, amount, this.options.enabled);
}
        else
            this.value = NumberValue.NaN.copy();


        this.setUpdateValues(parse,
        [
            ['_type',  this.outputType()],
            ['type',   type             ],
            ['base',   base             ],
            ['step',   step             ],
            ['amount', amount           ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.type   && this.type  .isValid()
            && this.base   && this.base  .isValid()
            && this.step   && this.step  .isValid()
            && this.amount && this.amount.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.type  ) this.type  .pushValueUpdates(parse);
        if (this.base  ) this.base  .pushValueUpdates(parse);
        if (this.step  ) this.step  .pushValueUpdates(parse);
        if (this.amount) this.amount.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.type  ) this.type  .invalidateInputs(parse, from, force);
        if (this.base  ) this.base  .invalidateInputs(parse, from, force);
        if (this.step  ) this.step  .invalidateInputs(parse, from, force);
        if (this.amount) this.amount.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.type  ) this.type  .iterateLoop(parse);
        if (this.base  ) this.base  .iterateLoop(parse);
        if (this.step  ) this.step  .iterateLoop(parse);
        if (this.amount) this.amount.iterateLoop(parse);
    }
}



function getQuantizeValue(input, type, base, step, amount, enabled)
{
    consoleAssert(
         input.type == NUMBER_VALUE, 
        'input.type must be NUMBER_VALUE');

    
    if (!enabled)
        return input;


    let qval;

    switch (type.value)
    {
        case 0: qval = base.value + step.value * Math.floor((input.value - base.value) / step.value); break;
        case 1: qval = base.value + step.value * Math.round((input.value - base.value) / step.value); break;
        case 2: qval = base.value + step.value * Math. ceil((input.value - base.value) / step.value); break;
    }

    return new NumberValue(
        input.value + (qval - input.value) * amount.value/100,
        Math.max(base.decimals, step.decimals));
}


class GSimpleMinMax
extends GOperator1
{
    operand;
    operation;



    constructor(nodeId, options)
    {
        super(NUMBER_SIMPLE_MINMAX, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.operand   = null;
        this.operation = null;
    }



    copy()
    {
        const copy = new GSimpleMinMax(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.operand  ) copy.operand   = this.operand  .copy();
        if (this.operation) copy.operation = this.operation.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = new NumberValue(0);

        
        const input   = await evalNumberOrListValue(this.input,     parse);
        const operand = await evalNumberValue      (this.operand,   parse);
        const op      = await evalNumberValue      (this.operation, parse);


        if (input)
        {
            if (this.options.enabled)
            {
                if (isListValueType(input.type))
                {
                    this.value = new ListValue();

                    for (let i = 0; i < input.items.length; i++)
                    {
                        const item = input.items[i];

                        this.value.items.push(
                            item.type == NUMBER_VALUE
                            ? getSimpleMinMaxValue(item, operand, op, this.options.enabled)
                            : NumberValue.NaN.copy());   
                    }
                }
                else
                {
                    this.value = getSimpleMinMaxValue(input, operand, op, this.options.enabled);
                }
            }
            else
                this.value = input.copy();
        }
        else
            this.value = NumberValue.NaN.copy();


        this.setUpdateValues(parse,
        [
            ['type',      this.outputType()],
            ['operand',   operand          ],
            ['operation', op               ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.operand   && this.operation.isValid()
            && this.operation && this.operand  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.operand  ) this.operand  .pushValueUpdates(parse);
        if (this.operation) this.operation.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.operand  ) this.operand  .invalidateInputs(parse, from, force);
        if (this.operation) this.operation.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.operand  ) this.operand  .iterateLoop(parse);
        if (this.operation) this.operation.iterateLoop(parse);
    }
}



function getSimpleMinMaxValue(input, operand, op, enabled)
{
    consoleAssert(
        input.type == NUMBER_VALUE, 
        'input.type is ' + input.type + ', must be NUMBER_VALUE');


    if (enabled)
    {
        op.value = Math.min(Math.max(0, Math.floor(op.value)), 1);

        return new NumberValue(op.value == 0
            ? Math.min(input.value, operand.toNumber())
            : Math.max(input.value, operand.toNumber()));
    }
    else
        return input;
}


class GMinMax
extends GArithmetic
{
    operation;



    constructor(nodeId, options)
    {
        super(NUMBER_MINMAX, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.operation = null;
    }



    copy()
    {
        const copy = new GMinMax(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        if (this.operation) copy.operation = this.operation.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const inputs = await Promise.all(this.inputs.map(async i => await evalNumberOrListValue(i, parse)));
        let   op     = await evalNumberValue(this.operation, parse);


        if (op) op = op.toInteger();


        if (this.options.enabled)
            op.value = Math.min(Math.max(0, op.value), MATH_OPS.length-1);
        

        this.value = await evalMinMaxInputs(inputs, op, parse);

        
        this.setUpdateValues(parse,
        [
            ['type',      this.outputType()],
            ['operation', op               ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.operation && this.operation.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.operation) this.operation.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.operation) this.operation.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.operation) this.operation.iterateLoop(parse);
    }
}



async function evalMinMaxInputs(inputs, op, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN.copy();


    const allAreLists = allInputsAreCondensedLists(inputs);

    if (allAreLists) return await evalMinMaxListInputs(inputs, op, parse);
    else             return await evalMinMaxItemInputs(inputs, op, parse);
}



async function evalMinMaxListInputs(inputs, op, parse)
{
    const value = new ListValue();

    
    for (const input of inputs)
    {
        if (!input) continue;

        console.assert(
             isListValueType(input.type), 
            `input is ${input.type}, must be a list`);

        if (allInputsAreCondensedLists(input.items))
            value.items.push(...(await evalMinMaxListInputs(input.items, op, parse)).items);
        else
            value.items.push(await evalMinMaxItemInputs(input.items, op, parse));
    }


    return value;
}



async function evalMinMaxItemInputs(inputs, op, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN.copy();


    let value = new NumberValue(0);


    const input0 = await evalNumberOrListValue(inputs[0], parse);


    if (    isListValueType(input0.type)
        && !isEmpty(input0.items))
    {
        value = input0.items[0].copy();
        
        for (let i = 1; i < input0.items.length; i++)
        {
            const item = input0.items[i];

            if (item.type == NUMBER_VALUE)
            {
                value = new NumberValue( 
                    op.value == 0
                    ? Math.min(value.value, item.value)
                    : Math.max(value.value, item.value));
            }                    
        }
    }
    else
    {
        if (input0.type != NUMBER_VALUE)
            return NumberValue.NaN.copy();

        value = input0;
    }


    for (let i = 1; i < inputs.length; i++)
    {
        const input = await evalNumberOrListValue(inputs[i], parse);


        if (isListValueType(input.type))
        {
            for (const item of input.items)
            {
                if (item.type == NUMBER_VALUE)
                {
                    value = new NumberValue(
                        op.value == 0
                        ? Math.min(value.value, item.value)
                        : Math.max(value.value, item.value));
                }                    
            }
        }
        else
        {
            consoleAssert(
                input.type == NUMBER_VALUE, 
                'val.type must be NUMBER_VALUE');
                
            value = new NumberValue(
                op.value == 0
                ? Math.min(value.value, input.value)
                : Math.max(value.value, input.value));
        }
    }


    return value;
}


class GLimits
extends GOperator1
{
    min = null;
    max = null;


    
    constructor(nodeId, options)
    {
        super(NUMBER_LIMITS, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.min = null;
        this.max = null;
    }



    copy()
    {
        const copy = new GLimits(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.min) copy.min = this.min.copy();
        if (this.max) copy.max = this.max.copy();

        return copy;
    }



    isCached()
    {
        return super.isCached()
            && (!this.min || this.min.isCached())
            && (!this.max || this.max.isCached());
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const input = await evalNumberOrListValue(this.input, parse);
        const min   = await evalNumberValue      (this.min,   parse);
        const max   = await evalNumberValue      (this.max,   parse);


        if (input)
        {
            if (isListValueType(input.type))
            {
                this.value = new ListValue();

                for (let i = 0; i < input.items.length; i++)
                {
                    const item = input.items[i];

                    this.value.items.push(
                        item.type == NUMBER_VALUE
                        ? getLimitsValue(item, min, max, this.options.enabled)
                        : NumberValue.NaN.copy());   
                }
            }
            else
                this.value = getLimitsValue(input, min, max, this.options.enabled);
        }
        else
            this.value = NumberValue.NaN.copy();


        this.setUpdateValues(parse,
        [
            ['type', this.outputType()],
            ['min',  min              ],
            ['max',  max              ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.min && this.min.isValid()
            && this.max && this.max.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input) this.input.pushValueUpdates(parse);
        if (this.min  ) this.min  .pushValueUpdates(parse);
        if (this.max  ) this.max  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.input) this.input.invalidateInputs(parse, from, force);
        if (this.min  ) this.min  .invalidateInputs(parse, from, force);
        if (this.max  ) this.max  .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input) this.input.iterateLoop(parse);
        if (this.min  ) this.min  .iterateLoop(parse);
        if (this.max  ) this.max  .iterateLoop(parse);
    }
}



function getLimitsValue(input, min, max, enabled)
{
    consoleAssert(
         input.type == NUMBER_VALUE, 
        'input.type must be NUMBER_VALUE');

    if (!enabled)
        return input;

    return new NumberValue(
        Math.min(Math.max(
            min.value,
            input.value),
            max.value),
        input.decimals);
}


class GNumberCurve
extends GOperator1
{
    min   = null;
    max   = null;
    power = null;


    
    constructor(nodeId, options)
    {
        super(NUMBER_CURVE, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.min   = null;
        this.max   = null;
        this.power = null;
    }



    copy()
    {
        const copy = new GNumberCurve(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.min  ) copy.min   = this.min  .copy();
        if (this.max  ) copy.max   = this.max  .copy();
        if (this.power) copy.power = this.power.copy();

        return copy;
    }



    isCached()
    {
        return super.isCached()
            && (!this.min   || this.min  .isCached())
            && (!this.max   || this.max  .isCached())
            && (!this.power || this.power.isCached());
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const input = await evalNumberOrListValue(this.input, parse);
        const min   = await evalNumberValue      (this.min,   parse);
        const max   = await evalNumberValue      (this.max,   parse);
        const power = await evalNumberValue      (this.power, parse);


        if (input)
        {
            if (isListValueType(input.type))
            {
                this.value = new ListValue();

                for (let i = 0; i < input.items.length; i++)
                {
                    const item = input.items[i];

                    this.value.items.push(
                        item.type == NUMBER_VALUE
                        ? getNumberCurveValue(item, min, max, power, this.options.enabled)
                        : NumberValue.NaN.copy());   
                }
            }
            else
                this.value = getNumberCurveValue(input, min, max, power, this.options.enabled);
        }
        else
            this.value = NumberValue.NaN.copy();


        this.setUpdateValues(parse,
        [
            ['type',  this.outputType()],
            ['min',   min              ],
            ['max',   max              ],
            ['power', power            ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.min   && this.min  .isValid()
            && this.max   && this.max  .isValid()
            && this.power && this.power.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.min  ) this.min  .pushValueUpdates(parse);
        if (this.max  ) this.max  .pushValueUpdates(parse);
        if (this.power) this.power.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.min  ) this.min  .invalidateInputs(parse, from, force);
        if (this.max  ) this.max  .invalidateInputs(parse, from, force);
        if (this.power) this.power.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.min  ) this.min  .iterateLoop(parse);
        if (this.max  ) this.max  .iterateLoop(parse);
        if (this.power) this.power.iterateLoop(parse);
    }
}



function getNumberCurveValue(input, min, max, power, enabled)
{
    consoleAssert(
        input.type == NUMBER_VALUE, 
       'input.type must be NUMBER_VALUE');


    if (!enabled)
        return input;


    let f = (input.value - min.value) / (max.value - min.value);

    f = Math.pow(f, power.value);
    f = min.value + f * (max.value - min.value);
    
    return new NumberValue(f);
}


class GNumberMap
extends GOperator1
{
    from = null;
    to   = null;


    
    constructor(nodeId, options)
    {
        super(NUMBER_MAP, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.from = null;
        this.to   = null;
    }



    copy()
    {
        const copy = new GNumberMap(this.nodeId, this.options);

        copy.copyBase(this);

        if (from) copy.from = this.from.copy();
        if (to  ) copy.to   = this.to  .copy();

        return copy;
    }



    isCached()
    {
        return super.isCached()
            && (!this.from  || this.from.isCached())
            && (!this.to    || this.to  .isCached());
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const input = await evalNumberOrListValue(this.input, parse);
        const from  = await evalListValue        (this.from,  parse);
        const to    = await evalListValue        (this.to,    parse);

        let nanList = false;


        if (   input 
            && input.isValid())
        {
            if (this.options.enabled)
            {
                if (   from && from.isValid() && from.items.length > 0
                    && to   && to  .isValid() && to  .items.length > 0)
                {
                    if (isListValueType(input.type))
                    {
                        this.value = new ListValue();
        
                        for (let i = 0; i < input.items.length; i++)
                        {
                            const item = input.items[i];
        
                            this.value.items.push(
                                item.type == NUMBER_VALUE
                                ? getNumberMapValue(item, from, to)
                                : NumberValue.NaN.copy());   
                        }
                    }
                    else
                        this.value = getNumberMapValue(input, from, to);
                }
                else
                {
                    if (isListValueType(input.type))
                    {
                        this.value = new ListValue();
                        nanList = true;
                    }
                    else
                        this.value = NumberValue.NaN.copy();
                }
            }
            else
                this.value = input;
        }
        else
            this.value = NumberValue.NaN.copy();


        this.setUpdateValues(parse,
        [
            ['type', nanList ? new TextValue(NUMBER_LIST_VALUE) : this.outputType()],
            ['from', from                                           ],
            ['to',   to                                             ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.from && this.from.isValid()
            && this.to   && this.to  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.from) this.from.pushValueUpdates(parse);
        if (this.to  ) this.to  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.from) this.from.invalidateInputs(parse, from, force);
        if (this.to  ) this.to  .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.from) this.from.iterateLoop(parse);
        if (this.to  ) this.to  .iterateLoop(parse);
    }
}



function getNumberMapValue(input, from, to)
{
    consoleAssert(
        input.type == NUMBER_VALUE, 
       'input.type must be NUMBER_VALUE');


    const maxDec = Math.max(
        from.items.reduce((max, val) => Math.max(max, val.decimals), 0),
        to  .items.reduce((max, val) => Math.max(max, val.decimals), 0));


    if (from.items.length == 1)
        return input;


    // from

    const nFromSegments = Math.floor(from.items.length-1);
    let   fromIndex     = 0;

    while (fromIndex < nFromSegments-1)
    {
        if (   input.value >= from.items[fromIndex  ]
            && input.value <  from.items[fromIndex+1])
            break;

        fromIndex++;
    }
    
    
    const fromLocal = 
            (input.value - from.items[fromIndex].value) 
        / (from.items[fromIndex+1].value - from.items[fromIndex].value);

    const f = fromIndex/nFromSegments + fromLocal * ((fromIndex+1)/nFromSegments - fromIndex/nFromSegments);
    

    // to

    const nToSegments = Math.floor(to.items.length-1);
    const toIndex     = Math.min(Math.max(0, Math.floor((to.items.length-1) * f)), nToSegments-1);


    if (to.items.length == 1)
        return to.items[0];

    else if (to.items.length > 0
            && toIndex < to.items.length-1)
    {
        const toLocal = 
            nToSegments > 1
            ? (f - toIndex/nToSegments) * nToSegments
            : f;


        const val0 = to.items[toIndex  ];
        const val1 = to.items[toIndex+1];

        return new NumberValue(
            lerp(val0.value, val1.value, toLocal),
            maxDec);
    }
}


class GNumberBias
extends GOperator1
{
    min    = null;
    max    = null;
    bias   = null;
    spread = null;


    
    constructor(nodeId, options)
    {
        super(NUMBER_BIAS, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.min    = null;
        this.max    = null;
        this.bias   = null;
        this.spread = null;
    }



    copy()
    {
        const copy = new GNumberBias(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.min   ) copy.min    = this.min   .copy();
        if (this.max   ) copy.max    = this.max   .copy();
        if (this.bias  ) copy.bias   = this.bias  .copy();
        if (this.spread) copy.spread = this.spread.copy();

        return copy;
    }



    isCached()
    {
        return super.isCached()
            && (!this.min    || this.min   .isCached())
            && (!this.max    || this.max   .isCached())
            && (!this.bias   || this.bias  .isCached())
            && (!this.spread || this.spread.isCached());
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const input  = await evalNumberOrListValue(this.input,  parse);
        const min    = await evalNumberValue      (this.min,    parse);
        const max    = await evalNumberValue      (this.max,    parse);
        const bias   = await evalNumberValue      (this.bias,   parse);
        const spread = await evalNumberValue      (this.spread, parse);


        if (input)
        {
            if (isListValueType(input.type))
            {
                this.value = new ListValue();

                for (let i = 0; i < input.items.length; i++)
                {
                    const item = input.items[i];

                    this.value.items.push(
                        item.type == NUMBER_VALUE
                        ? getNumberBiasValue(item, min, max, bias, spread, this.options.enabled)
                        : NumberValue.NaN.copy());   
                }
            }
            else
                this.value = getNumberBiasValue(input, min, max, bias, spread, this.options.enabled);
        }
        else
            this.value = NumberValue.NaN.copy();


        this.setUpdateValues(parse,
        [
            ['type',   this.outputType()],
            ['min',    min              ],
            ['max',    max              ],
            ['bias',   bias             ],
            ['spread', spread           ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.min    && this.min   .isValid()
            && this.max    && this.max   .isValid()
            && this.bias   && this.bias  .isValid()
            && this.spread && this.spread.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.min   ) this.min   .pushValueUpdates(parse);
        if (this.max   ) this.max   .pushValueUpdates(parse);
        if (this.bias  ) this.bias  .pushValueUpdates(parse);
        if (this.spread) this.spread.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.min   ) this.min   .invalidateInputs(parse, from, force);
        if (this.max   ) this.max   .invalidateInputs(parse, from, force);
        if (this.bias  ) this.bias  .invalidateInputs(parse, from, force);
        if (this.spread) this.spread.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.min   ) this.min   .iterateLoop(parse);
        if (this.max   ) this.max   .iterateLoop(parse);
        if (this.bias  ) this.bias  .iterateLoop(parse);
        if (this.spread) this.spread.iterateLoop(parse);
    }
}



function getSpreadBias(f, bias, spread)
{
    const b = bias   / 50;
    const s = spread / 50;


    f = 
        b >= 0
        ? 1 - Math.pow(1-f, 1+b)
        :     Math.pow(  f, 1-b);


         if (s >= 0 && f >= 0.5) f = 1 - Math.pow((1-f)*2, 1+s) / 2;
    else if (s >= 0 && f <  0.5) f = Math.pow(f*2, 1+s) / 2;
    else if (s < 0)              f = lerp3(0, (1-s)/3, (2+s)/3, 1, f);


    return f;
}



function getNumberBiasValue(input, min, max, bias, spread, enabled)
{
    consoleAssert(
        input.type == NUMBER_VALUE, 
       'input.type must be NUMBER_VALUE');


    if (!enabled)
        return input;


    let f = (input.value - min.value) / (max.value - min.value);

    f = getSpreadBias(f, bias.value, spread.value);
    f = min.value + f * (max.value - min.value);

    return new NumberValue(f);
}


class GNaNisNumber
extends GOperator1
{
    _value = null;



    constructor(nodeId, options)
    {
        super(NUMBER_NAN, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this._value = null;
    }



    copy()
    {
        const copy = new GNaNisNumber(this.nodeId, this.options);

        copy.copyBase(this);

        if (this._value) copy._value = this._value.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const  input = await evalNumberOrListValue(this. input, parse);
        const _value = await evalNumberValue      (this._value, parse);


        if (input)
        {
            if (isListValueType(input.type))
            {
                this.value = new ListValue();

                for (let i = 0; i < input.items.length; i++)
                {
                    const item = input.items[i];

                    this.value.items.push(
                        item.type == NUMBER_VALUE
                        ? getNaNisNumberValue(item, _value, this.options.enabled)
                        : TextValue.NaN.copy());   
                }
            }
            else
            {
                this.value = getNaNisNumberValue(input, _value, this.options.enabled);
            }
        }

        else
            this.value = NumberValue.NaN.copy();


        this.setUpdateValues(parse,
        [
            ['type', this.outputType()]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.value && this.value.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.value) this.value.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.value) this.value.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.value) this.value.iterateLoop(parse);
    }
}



function getNaNisNumberValue(input, value, enabled)
{
    if (    enabled
        && !input.isValid())
        return value;
    else
        return input;
}


class GConstant
extends GOperator
{
    constant;



    constructor(nodeId, options)
    {
        super(NUMBER_CONSTANT, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.constant = null;
    }



    copy()
    {
        const copy = new GConstant(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.constant) copy.constant = this.constant.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;
            

        // input not used for evaluation


        const constant = await evalNumberValue(this.constant, parse);

        
        let value;

        switch (Math.min(Math.max(0, constant.toNumber()), 5))
        {
            case 0: value = 1.4142135623; break; // √̅2
            case 1: value = 2.7182818284; break; // e
            case 2: value = 0.6180339887; break; // phi
            case 3: value = 1.6180339887; break; // PHI
            case 4: value = 3.1415926536; break; // pi
            case 5: value = 6.2831853072; break; // tau
        }


        this.value = new NumberValue(value);

        
        this.setUpdateValues(parse,
        [
            ['value',   this.value],
            ['constant', constant ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return this.constant && this.constant.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.constant) this.constant.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.constant) this.constant.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.constant) this.constant.iterateLoop(parse);
    }
}



class GDateTime
extends GOperator
{
    seconds   = null;
    minutes   = null;
    hours     = null;
    dayOfWeek = null;
    date      = null;
    month     = null;
    year      = null;
    
    
    
    constructor(nodeId, options)
    {
        super(NUMBER_LIMITS, nodeId, options);
    }


    
    reset()
    {
        super.reset();
        
        this.seconds   = null;
        this.minutes   = null;
        this.hours     = null;
        this.dayOfWeek = null;
        this.date      = null;
        this.month     = null;
        this.year      = null;
    }



    copy()
    {
        const copy = new GLimits(this.nodeId, this.options);
        
        copy.copyBase(this);
        
        if (this.seconds  ) copy.seconds   = this.seconds  .copy();
        if (this.minutes  ) copy.minutes   = this.minutes  .copy();
        if (this.hours    ) copy.hours     = this.hours    .copy();
        if (this.dayOfWeek) copy.dayOfWeek = this.dayOfWeek.copy();
        if (this.date     ) copy.date      = this.date     .copy();
        if (this.month    ) copy.month     = this.month    .copy();
        if (this.year     ) copy.year      = this.year     .copy();

        return copy;
    }    
    
    
    
    isCached()
    {
        return super.isCached()
            && (!this.year      || this.year     .isCached())
            && (!this.month     || this.month    .isCached())
            && (!this.date      || this.date     .isCached())
            && (!this.dayOfWeek || this.dayOfWeek.isCached())
            && (!this.hours     || this.hours    .isCached())
            && (!this.minutes   || this.minutes  .isCached())
            && (!this.seconds   || this.seconds  .isCached())
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.updateValues = [];

        
        if (this.options.enabled)
        {
            const dateTime = new Date();

            const seconds   = new NumberValue(dateTime.getSeconds() );
            const minutes   = new NumberValue(dateTime.getMinutes() );
            const hours     = new NumberValue(dateTime.getHours()   );
            const dayOfWeek = new NumberValue(dateTime.getDay()     );
            const date      = new NumberValue(dateTime.getDate()    );
            const month     = new NumberValue(dateTime.getMonth()   );
            const year      = new NumberValue(dateTime.getFullYear());


            this.setUpdateValues(parse,
            [
                ['seconds',   seconds  ],
                ['minutes',   minutes  ],
                ['hours',     hours    ],
                ['dayOfWeek', dayOfWeek],
                ['date',      date     ],
                ['month',     month    ],
                ['year',      year     ]
            ]);    
        }    

        
        this.validate();

        return this;
    }    



    isValid()
    {
        return this.year      && this.year     .isValid()
            && this.month     && this.month    .isValid()
            && this.date      && this.date     .isValid()
            && this.dayOfWeek && this.dayOfWeek.isValid()
            && this.hours     && this.hours    .isValid()
            && this.minutes   && this.minutes  .isValid()
            && this.seconds   && this.seconds  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.year     ) this.year     .pushValueUpdates(parse);
        if (this.month    ) this.month    .pushValueUpdates(parse);
        if (this.date     ) this.date     .pushValueUpdates(parse);
        if (this.dayOfWeek) this.dayOfWeek.pushValueUpdates(parse);
        if (this.hours    ) this.hours    .pushValueUpdates(parse);
        if (this.minutes  ) this.minutes  .pushValueUpdates(parse);
        if (this.seconds  ) this.seconds  .pushValueUpdates(parse);
    }    



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.year     ) this.year     .invalidateInputs(parse, from, force);
        if (this.month    ) this.month    .invalidateInputs(parse, from, force);
        if (this.date     ) this.date     .invalidateInputs(parse, from, force);
        if (this.dayOfWeek) this.dayOfWeek.invalidateInputs(parse, from, force);
        if (this.hours    ) this.hours    .invalidateInputs(parse, from, force);
        if (this.minutes  ) this.minutes  .invalidateInputs(parse, from, force);
        if (this.seconds  ) this.seconds  .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.year     ) this.year     .iterateLoop(parse);
        if (this.month    ) this.month    .iterateLoop(parse);
        if (this.date     ) this.date     .iterateLoop(parse);
        if (this.dayOfWeek) this.dayOfWeek.iterateLoop(parse);
        if (this.hours    ) this.hours    .iterateLoop(parse);
        if (this.minutes  ) this.minutes  .iterateLoop(parse);
        if (this.seconds  ) this.seconds  .iterateLoop(parse);
    }    
}



class GIterate
extends GOperator
{
    inputs = [];



    constructor(nodeId, options)
    {
        super(ITERATE, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.input = [];
    }



    copy()
    {
        const copy = new GIterate(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const _values = [];

        for (let i = 0; i < this.inputs.length; i++)
        {
            const input = await evalValue(this.inputs[i], parse);

            if (   input
                && this.options.enabled)            
            {
                if (isListValueType(input.type))
                {
                    if (input.condensed === true)
                        _values.push(input.copy());
                    else
                    {
                        for (const item of input.items)
                            _values.push(item.copy());   
                    }
                }
                else
                    _values.push(input.copy());
            }
        }
            

        this.value = 
            _values.length > 0
            ? _values[this.currentIteration % _values.length]
            : new NullValue();


        if (   this.value 
            && this.value.objects)
        {
            for (let i = 0; i < this.value.objects.length; i++)
            {
                const obj = this.value.objects[i];
    
                obj.nodeId = this.nodeId;
                obj.listId = -1;
    
                obj.objectId = this.nodeId;
                
                if (obj.objectId != NULL) 
                    obj.objectId += '/';
    
                obj.objectId += i.toString();
            }
        }


        this.evalObjects(parse);
        

        this.setUpdateValues(parse,
        [
            ['type', this.outputType()]
        ]);
        

        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return !this.inputs.find(i => !i.isValid());
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse));
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        this.inputs.forEach(i => i.invalidateInputs(parse, from, force));
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        this.inputs.forEach(i => i.iterateLoop(parse));
    }
}



class GSequence
extends GOperator
{
    start    = null;
    multiply = null;
    add      = null;
    end      = null;

    current  = null;
    
    
    
    constructor(nodeId, options)
    {
        super(NUMBER_SEQUENCE, nodeId, options);
    }



    reset()
    {
        super.reset();
        
        this.start    = null;
        this.multiply = null;
        this.add      = null;
        this.end      = null;
    
        this.current  = null;
    }


   
    copy()
    {
        const copy = new GSequence(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.start   ) copy.start    = this.start   .copy();
        if (this.multiply) copy.multiply = this.multiply.copy();
        if (this.add     ) copy.add      = this.add     .copy();
        if (this.end     ) copy.end      = this.end     .copy();

        if (this.current) copy.current = this.current.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;
            

        const start = await evalNumberValue(this.start,    parse);
        const mult  = await evalNumberValue(this.multiply, parse);
        const add   = await evalNumberValue(this.add,      parse);
        const end   = await evalNumberValue(this.end,      parse);
    

        if (   start
            && mult
            && add
            && end)
        {
            const value = start.value + (this.options.enabled ? add.value * this.currentIteration : 0);

            if (!end.isValid())
                this.value = getSequenceValue(start, mult, add, this.currentIteration, this.options.enabled);

            else if (   end.isValid()   
                     && (   add.value == 0
                         || add.value >  0 && start.value < end.value
                                           &&       value < end.value
                         || add.value <  0 && start.value > end.value
                                           &&       value > end.value))
                this.value = getSequenceValue(start, mult, add, this.currentIteration, this.options.enabled);

            else
                this.value = NumberValue.NaN.copy();
        }
        else
            this.value = NumberValue.NaN.copy();


        this.setUpdateValues(parse,
        [
            ['start',    start],
            ['multiply', mult ],
            ['add',      add  ],
            ['end',      end  ]
        ]);
        

        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return this.start    && this.start   .isValid()
            && this.multiply && this.multiply.isValid()
            && this.add      && this.add     .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.start   ) this.start   .pushValueUpdates(parse);
        if (this.multiply) this.multiply.pushValueUpdates(parse);
        if (this.add     ) this.add     .pushValueUpdates(parse);
        if (this.end     ) this.end     .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.start   ) this.start   .invalidateInputs(parse, from, force);
        if (this.multiply) this.multiply.invalidateInputs(parse, from, force);
        if (this.add     ) this.add     .invalidateInputs(parse, from, force);
        if (this.end     ) this.end     .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.start   ) this.start   .iterateLoop(parse);
        if (this.multiply) this.multiply.iterateLoop(parse);
        if (this.add     ) this.add     .iterateLoop(parse);
        if (this.end     ) this.end     .iterateLoop(parse);
    }
}



function getSequenceValue(start, mult, add, iteration, enabled)
{
    let value = start.value;

    if (enabled)
    {
        for (let i = 0; i < iteration; i++)
        {
            value *= mult.value;
            value += add .value;
        }
    }

    return new NumberValue(value);
}


class GRange
extends GOperator
{
    from  = null;
    start = null;
    end   = null;
    
    

    constructor(nodeId, options)
    {
        super(NUMBER_RANGE, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.from  = null;
        this.start = null;
        this.end   = null;
    }



    copy()
    {
        const copy = new GRange(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.from   ) copy.from    = this.from   .copy();
        if (this.start  ) copy.start   = this.start  .copy();
        if (this.end    ) copy.end     = this.end    .copy();

        if (this.current) copy.current = this.current.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const from  = await evalNumberValue(this.from,  parse);
        const start = await evalNumberValue(this.start, parse);
        const end   = await evalNumberValue(this.end,   parse);
    

        const repeat    = parse.repeats.find(r => r.repeatId == this.loopId);
        const iteration = repeat ? repeat.currentIteration : 0;


        if (   from
            && start
            && end)
        {
            let delta = end.value - start.value;

            let step = 
                repeat
                && this.options.enabled
                ? delta / Math.max(1, repeat.total - (from.value == 1 ? 1 : 0))
                : 0;

                
            let startOffset;

                 if (from  .value == 2) startOffset = step;
            else if (from  .value == 1
                && repeat
                && repeat.total == 1) startOffset = delta/2;
            else                        startOffset = 0;


            let f;
            
            if (repeat)
            {
                     if (from.value == 2) f = iteration/repeat.total;
                else if (from.value == 1) f = (repeat.total > 1 ? iteration/(repeat.total-1) : 0);
                else if (from.value == 0) f = iteration/repeat.total;
            }
            else
                f = 0;


            this.value = new NumberValue(
                start.value + startOffset + f * delta,
                Math.max(start.decimals, end.decimals));
        }
        else
            this.value = NumberValue.NaN.copy();


        this.setUpdateValues(parse,
        [
            ['from',  from ],
            ['start', start],
            ['end',   end  ]
        ]);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return this.from  && this.from .isValid()
            && this.start && this.start.isValid()
            && this.end   && this.end  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.from ) this.from .pushValueUpdates(parse);
        if (this.start) this.start.pushValueUpdates(parse);
        if (this.end  ) this.end  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.from ) this.from .invalidateInputs(parse, from, force);
        if (this.start) this.start.invalidateInputs(parse, from, force);
        if (this.end  ) this.end  .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.from ) this.from .iterateLoop(parse);
        if (this.start) this.start.iterateLoop(parse);
        if (this.end  ) this.end  .iterateLoop(parse);
    }
}



class GWave
extends GOperator
{
    shape     = null;
    base      = null;
    amplitude = null;
    frequency = null;
    offset    = null;
    bias      = null;
    
    useWavelength;
    offsetAbsolute;



    constructor(nodeId, options)
    {
        super(NUMBER_WAVE, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.shape     = null;
        this.base      = null;
        this.amplitude = null;
        this.frequency = null;
        this.offset    = null;
        this.bias      = null;
    }



    copy()
    {
        const copy = new GWave(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.shape    ) copy.shape     = this.shape    .copy();
        if (this.base     ) copy.base      = this.base     .copy();
        if (this.amplitude) copy.amplitude = this.amplitude.copy();
        if (this.frequency) copy.frequency = this.frequency.copy();
        if (this.offset   ) copy.offset    = this.offset   .copy();
        if (this.bias     ) copy.bias      = this.bias     .copy();

        if (this.current) copy.current = this.current.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;
            

        const shape  = await evalNumberValue(this.shape,     parse);
        const base   = await evalNumberValue(this.base,      parse);
        const amp    = await evalNumberValue(this.amplitude, parse);
        let   freq   = await evalNumberValue(this.frequency, parse);
        const offset = await evalNumberValue(this.offset,    parse);
        const bias   = await evalNumberValue(this.bias,      parse);
    

        const repeat    = parse.repeats.find(r => r.repeatId == this.loopId);
        const iteration = repeat ? repeat.currentIteration : 0;

 
        if (this.options.enabled)
        {
            let t;
            
            
            if (   repeat
                && shape
                && freq
                && offset)
            {
                const _freq =
                    this.useWavelength
                    ? repeat.total / nozero(freq.value)
                    : freq.value;

                let _offset =
                    this.offsetAbsolute
                    ? offset.value/repeat.total
                    : (offset.value/100)/_freq;

                if (shape.value == 3)
                    _offset -= 0.25;

                t = (iteration/repeat.total - _offset) * _freq;

                while (t < 0) t++;
                while (t > 1) t--;

                switch (shape.value)
                {
                    case 0: t = (t%1) < 0.5 ? 1 : -1;      break; // square
                    case 1: t = (1 - (t%1)*2);             break; // saw
                    case 2: t = ((t%1)*2 - 1);             break; // back saw
                    case 3: t = 1 - 2*Math.abs(2*(t%1)-1); break; // triangle
                    case 4: t = Math.sin(t * Tau);         break; // sine
                }
            }
            else 
                t = 0;

            
            if (bias)
            {
                const b = bias.value / 100;

                if (b >= 0) t = t / (1+b) + b/2;
                else        t = t / (1-b) + b/2;
            }


            if (amp ) t = t * amp .value;
            if (base) t = t + base.value;


            this.value = new NumberValue(t);
        }
        else
            this.value = base;
        

        this.setUpdateValues(parse,
        [
            ['shape',     shape ],
            ['base',      base  ],
            ['amplitude', amp   ],
            ['frequency', freq  ],
            ['offset',    offset],
            ['bias',      bias  ]
        ]);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return this.shape     && this.shape    .isValid()
            && this.base      && this.base     .isValid()
            && this.amplitude && this.amplitude.isValid()
            && this.frequency && this.frequency.isValid()
            && this.offset    && this.offset   .isValid()
            && this.bias      && this.bias     .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.shape    ) this.shape    .pushValueUpdates(parse);
        if (this.base     ) this.base     .pushValueUpdates(parse);
        if (this.amplitude) this.amplitude.pushValueUpdates(parse);
        if (this.frequency) this.frequency.pushValueUpdates(parse);
        if (this.offset   ) this.offset   .pushValueUpdates(parse);
        if (this.bias     ) this.bias     .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.shape    ) this.shape    .invalidateInputs(parse, from, force);
        if (this.base     ) this.base     .invalidateInputs(parse, from, force);
        if (this.amplitude) this.amplitude.invalidateInputs(parse, from, force);
        if (this.frequency) this.frequency.invalidateInputs(parse, from, force);
        if (this.offset   ) this.offset   .invalidateInputs(parse, from, force);
        if (this.bias     ) this.bias     .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.shape    ) this.shape    .iterateLoop(parse);
        if (this.base     ) this.base     .iterateLoop(parse);
        if (this.amplitude) this.amplitude.iterateLoop(parse);
        if (this.frequency) this.frequency.iterateLoop(parse);
        if (this.offset   ) this.offset   .iterateLoop(parse);
        if (this.bias     ) this.bias     .iterateLoop(parse);
    }
}



class GRandom
extends GOperator
{
    seed         = null;
    iteration    = null;
    min          = null;
    max          = null;
    bias         = null;
    spread       = null;
    unique       = null;

    random       = null;
    randomUnique = null;

    lastValue1   = -1;
    lastValue2   = -1;
    uniqueOffset =  0;



    constructor(nodeId, options)
    {
        super(NUMBER_RANDOM, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.seed      = null;
        this.iteration = null;
        this.min       = null;
        this.max       = null;
        this.bias      = null;
        this.spread    = null;
        this.unique    = null;
    }



    copy()
    {
        const copy = new GRandom(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.seed     ) copy.seed      = this.seed     .copy();
        if (this.iteration) copy.iteration = this.iteration.copy();
        if (this.min      ) copy.min       = this.min      .copy();
        if (this.max      ) copy.max       = this.max      .copy();
        if (this.bias     ) copy.bias      = this.bias     .copy();
        if (this.spread   ) copy.spread    = this.spread   .copy();
        if (this.unique   ) copy.unique    = this.unique   .copy();

        if (this.random   ) copy.random    = this.random   .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const seed      = await evalNumberValue(this.seed,      parse);
        const iteration = await evalNumberValue(this.iteration, parse);
        const min       = await evalNumberValue(this.min,       parse);
        const max       = await evalNumberValue(this.max,       parse);
        const bias      = await evalNumberValue(this.bias,      parse);
        const spread    = await evalNumberValue(this.spread,    parse);
        const unique    = await evalNumberValue(this.unique,    parse);
    

        if (   this.options.enabled
            && iteration
            && seed
            && min
            && max
            && bias
            && spread
            && unique)
        {
            if (  !this.random
                || this.random.seed != seed.value)
            {
                this.random       = new Random(seed.value);
                this.randomUnique = new Random(seed.value+1);
            }


            if (iteration.isValid())
                this.currentIteration = Math.round(iteration.value);


            if (this.currentIteration >= 0)
            {
                let f  = this.random.get(this.currentIteration + this.uniqueOffset);

                f = getSpreadBias(f, bias.value, spread.value);
                f = min.value + f * (max.value - min.value);
                
                this.value = new NumberValue(f, Math.max(min.decimals, max.decimals));

                    
                const _unique = unique.value/100;
                

                if (max.value - min.value >= 1)
                {
                    while (this.value.toNumber() == this.lastValue1
                        && this.randomUnique.get(this.currentIteration) < _unique)
                        this.value = new NumberValue(
                            min.value + this.random.get(this.currentIteration + ++this.uniqueOffset) * (max.value - min.value),
                            Math.max(min.decimals, max.decimals));
                }

                if (max.value - min.value >= 2)
                {
                    while ((   this.value.toNumber() == this.lastValue1
                            || this.value.toNumber() == this.lastValue2)
                        && this.randomUnique.get(this.currentIteration) < Math.max(_unique - 1))
                        this.value = new NumberValue(
                            min.value + this.random.get(this.currentIteration + ++this.uniqueOffset) * (max.value - min.value),
                            Math.max(min.decimals, max.decimals));
                }        
            }
            else
                this.value = new NumberValue((min.value + max.value) / 2);
        }
        else
            this.value = NumberValue.NaN.copy();


        if (this.value.isValid())
            this.value.value = this.value.toNumber();

        this.lastValue2 = this.lastValue1;
        this.lastValue1 = this.value.value;


        this.setUpdateValues(parse,
        [
            ['iteration', iteration],
            ['seed',      seed     ],
            ['min',       min      ],
            ['max',       max      ],
            ['bias',      bias     ],
            ['spread',    spread   ],
            ['unique',    unique   ]
        ]);
        

        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return this.seed      && this.seed     .isValid()
            && this.iteration && this.iteration.isValid()
            && this.min       && this.min      .isValid()
            && this.max       && this.max      .isValid()
            && this.bias      && this.bias     .isValid()
            && this.spread    && this.spread   .isValid()
            && this.unique    && this.unique   .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.seed     ) this.seed     .pushValueUpdates(parse);
        if (this.iteration) this.iteration.pushValueUpdates(parse);
        if (this.min      ) this.min      .pushValueUpdates(parse);
        if (this.max      ) this.max      .pushValueUpdates(parse);
        if (this.bias     ) this.bias     .pushValueUpdates(parse);
        if (this.spread   ) this.spread   .pushValueUpdates(parse);
        if (this.unique   ) this.unique   .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.seed     ) this.seed     .invalidateInputs(parse, from, force);
        if (this.iteration) this.iteration.invalidateInputs(parse, from, force);
        if (this.min      ) this.min      .invalidateInputs(parse, from, force);
        if (this.max      ) this.max      .invalidateInputs(parse, from, force);
        if (this.bias     ) this.bias     .invalidateInputs(parse, from, force);
        if (this.spread   ) this.spread   .invalidateInputs(parse, from, force);
        if (this.unique   ) this.unique   .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.seed     ) this.seed     .iterateLoop(parse);
        if (this.iteration) this.iteration.iterateLoop(parse);
        if (this.min      ) this.min      .iterateLoop(parse);
        if (this.max      ) this.max      .iterateLoop(parse);
        if (this.bias     ) this.bias     .iterateLoop(parse);
        if (this.spread   ) this.spread   .iterateLoop(parse);
        if (this.unique   ) this.unique   .iterateLoop(parse);
    }



    initLoop(parse, nodeId)
    {
        super.initLoop(parse, nodeId);

        this.uniqueOffset = 0;
    }



    resetLoop(parse, nodeId)
    {
        super.resetLoop(parse, nodeId);

        this.uniqueOffset = 0;
    }
}



class GNoise
extends GOperator
{
    seed        = null;
    iteration   = null;
    min         = null;
    max         = null;
    scale       = null;
    interpolate = null;
    offset      = null;
    evolve      = null;
    detail      = null;
    
    randoms     = [];
    offsets     = [];
    
    
    
    constructor(nodeId, options)
    {
        super(NUMBER_NOISE, nodeId, options);
    }
    
    
    
    reset()
    {
        super.reset();
        
        this.seed          = null;
        this.iteration     = null;
        this.min           = null;
        this.max           = null;
        this.scale         = null;
        this.interpolate   = null;
        this.offset        = null;
        this.evolve        = null;
        this.detail        = null;
    }



    copy()
    {
        const copy = new GNoise(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.seed       ) copy.seed        = this.seed       .copy();
        if (this.iteration  ) copy.iteration   = this.iteration  .copy();
        if (this.min        ) copy.min         = this.min        .copy();
        if (this.max        ) copy.max         = this.max        .copy();
        if (this.scale      ) copy.scale       = this.scale      .copy();
        if (this.offset     ) copy.offset      = this.offset     .copy();
        if (this.evolve     ) copy.evolve      = this.evolve     .copy();
        if (this.interpolate) copy.interpolate = this.interpolate.copy();
        if (this.detail     ) copy.detail      = this.detail     .copy();

        if (this.randoms    ) copy.randoms     = this.randoms.map(r => r.copy());
        if (this.offsets    ) copy.offsets     = this.offsets.slice();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const seed        = await evalNumberValue(this.seed,        parse);
        const iteration   = await evalNumberValue(this.iteration,   parse);
        const min         = await evalNumberValue(this.min,         parse);
        const max         = await evalNumberValue(this.max,         parse);
        const scale       = await evalNumberValue(this.scale,       parse);
        const offset      = await evalNumberValue(this.offset,      parse);
        const evolve      = await evalNumberValue(this.evolve,      parse);
        const interpolate = await evalNumberValue(this.interpolate, parse);
        const detail      = await evalNumberValue(this.detail,      parse);
    

        if (   this.options.enabled
            && seed
            && iteration
            && min
            && max
            && scale
            && offset
            && evolve
            && interpolate
            && detail)
        {
            const _detail = Math.max(1, Math.ceil(detail.value));


            if (  !this.randoms
                || this.randoms.length < _detail)
            {
                const randoms = new Array(_detail);

                for (let c = 0; c < this.randoms.length; c++)
                    randoms[c] = this.randoms[c];
                

                let _seed = seed.value;

                for (let c = this.randoms.length; c < _detail; c++)
                {
                    randoms[c] = new Random2(_seed);
                    _seed = seed.value;
                }


                this.randoms = randoms;


                this.updateOffsets(this.randoms[0].width * _detail);
            }


            let   size  = 1;
            let   power = 1;
            
            const avg   = (min.value + max.value) / 2;
            let   r;

            
            if (iteration.isValid())
                this.currentIteration = Math.round(iteration.value);
                

            if (   this.options.enabled
                && scale  && scale .isValid()
                && offset && offset.isValid()
                && evolve && evolve.isValid())
            {
                r = avg;
                
                if (this.currentIteration >= 0)
                {
                    for (let c = 0; c < _detail; c++)
                    {
                        const i  = Math.max(0, this.currentIteration / (Math.max(0.000001, scale.value) * size) + offset.value);
                        const i0 = Math.floor(i);
                        const i1 = Math.ceil (i);
                        

                        this.updateOffsets((i1 + 1) * _detail);//this.randoms[0].width * _detail

                        const o0 = this.offsets[i0];
                        const o1 = this.offsets[i1];
                        let   _o;

                        switch (interpolate.value)
                        {
                            case 0: _o = o0;                                                 break;
                            case 1: _o = lerp(o0, o1, i-i0);                                 break;
                            case 2: _o = (o0 + (o1 - o0) * (-Math.cos((i-i0)*Tau/2) + 1)/2); break;
                        }

                        
                        const j   = evolve.value + _o;
                        const j0  = Math.floor(j);
                        const j1  = Math.ceil (j);


                        const r00 = this.randoms[c].get(i0, j0);
                        const r10 = this.randoms[c].get(i1, j0);
                        const r01 = this.randoms[c].get(i0, j1);
                        const r11 = this.randoms[c].get(i1, j1);
            

                        let _r, _r0, _r1;
                        
                        switch (interpolate.value)
                        {
                            case 0: 
                                _r = r00;
                                break;

                            case 1: 
                                _r0 = lerp(r00, r10, i-i0);
                                _r1 = lerp(r01, r11, i-i0);
                                _r  = lerp(_r0, _r1, j-j0);
                                break;

                            case 2: 
                                _r0 = (r00 + (r10 - r00) * (-Math.cos((i-i0)*Tau/2) + 1)/2); 
                                _r1 = (r01 + (r11 - r01) * (-Math.cos((i-i0)*Tau/2) + 1)/2); 
                                _r  = (_r0 + (_r1 - _r0) * (-Math.cos((j-j0)*Tau/2) + 1)/2); 
                                break;
                        }


                        const clamp = 
                            detail.value - c < 1 
                            ? detail.value - c 
                            : 1;

                        r += 
                            - power *      (avg       - min.value) * clamp
                            + power * _r * (max.value - min.value) * clamp;
                        

                        size  /= 2;
                        power /= 2;

                        
                        this.updateOffsets(this.randoms[0].width * _detail);
                    }
                }
            }
            else
            {
                r = min.value;
            }


            this.value = new NumberValue(r, Math.max(min.decimals, max.decimals));
        }
        else
        {
            this.value = NumberValue.NaN.copy();
        }


        this.setUpdateValues(parse,
        [
            ['seed',        seed       ],
            ['iteration',   iteration  ],
            ['min',         min        ],
            ['max',         max        ],
            ['scale',       scale      ],
            ['offset',      offset     ],
            ['evolve',      evolve     ],
            ['interpolate', interpolate],
            ['detail',      detail     ]
        ]);
        

        this.validate();

        return this;
    }



    updateOffsets(newSize)
    {
        if (newSize < this.offsets.length) 
            return;

        this.offsets = new Array(newSize);
        const offsetRandom = new Random(0);

        for (let o = 0; o < newSize; o++)
            this.offsets[o] = offsetRandom.get(o);
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return this.seed        && this.seed       .isValid()
            && this.iteration   && this.iteration  .isValid()
            && this.min         && this.min        .isValid()
            && this.max         && this.max        .isValid()
            && this.scale       && this.scale      .isValid()
            && this.offset      && this.offset     .isValid()
            && this.evolve      && this.evolve     .isValid()
            && this.interpolate && this.interpolate.isValid()
            && this.detail      && this.detail     .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.seed       ) this.seed       .pushValueUpdates(parse);
        if (this.iteration  ) this.iteration  .pushValueUpdates(parse);
        if (this.min        ) this.min        .pushValueUpdates(parse);
        if (this.max        ) this.max        .pushValueUpdates(parse);
        if (this.scale      ) this.scale      .pushValueUpdates(parse);
        if (this.offset     ) this.offset     .pushValueUpdates(parse);
        if (this.evolve     ) this.evolve     .pushValueUpdates(parse);
        if (this.interpolate) this.interpolate.pushValueUpdates(parse);
        if (this.detail     ) this.detail     .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.seed       ) this.seed       .invalidateInputs(parse, from, force);
        if (this.iteration  ) this.iteration  .invalidateInputs(parse, from, force);
        if (this.min        ) this.min        .invalidateInputs(parse, from, force);
        if (this.max        ) this.max        .invalidateInputs(parse, from, force);
        if (this.scale      ) this.scale      .invalidateInputs(parse, from, force);
        if (this.offset     ) this.offset     .invalidateInputs(parse, from, force);
        if (this.evolve     ) this.evolve     .invalidateInputs(parse, from, force);
        if (this.interpolate) this.interpolate.invalidateInputs(parse, from, force);
        if (this.detail     ) this.detail     .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.seed       ) this.seed       .iterateLoop(parse);
        if (this.iteration  ) this.iteration  .iterateLoop(parse);
        if (this.min        ) this.min        .iterateLoop(parse);
        if (this.max        ) this.max        .iterateLoop(parse);
        if (this.scale      ) this.scale      .iterateLoop(parse);
        if (this.offset     ) this.offset     .iterateLoop(parse);
        if (this.evolve     ) this.evolve     .iterateLoop(parse);
        if (this.interpolate) this.interpolate.iterateLoop(parse);
        if (this.detail     ) this.detail     .iterateLoop(parse);
    }
}



class GProbability
extends GOperator2
{
    seed      = null;
    iteration = null;
    chance    = null;
    alternate = null;

    random    = null;



    constructor(nodeId, options)
    {
        super(PROBABILITY, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.seed      = null;
        this.iteration = null;
        this.chance    = null;
        this.alternate = null;
    }



    copy()
    {
        const copy = new GRandom(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.seed     ) copy.seed      = this.seed     .copy();
        if (this.iteration) copy.iteration = this.iteration.copy();
        if (this.chance   ) copy.chance    = this.chance   .copy();
        if (this.alternate) copy.alternate = this.alternate.copy();

        if (this.random) copy.random = this.random.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input0    = await evalValue      (this.input0,    parse);
        const input1    = await evalValue      (this.input1,    parse);
        const seed      = await evalNumberValue(this.seed,      parse);
        const iteration = await evalNumberValue(this.iteration, parse);
        const chance    = await evalNumberValue(this.chance,    parse);
        const alternate = await evalNumberValue(this.alternate, parse);
    

        if (   seed
            && iteration
            && chance
            && alternate)
        {
            if (  !this.random
                || this.random.seed != seed.value)
                this.random = new Random(seed.value);


            if (iteration.isValid())
                this.currentIteration = Math.round(iteration.value);


            if (this.currentIteration >= 0)
            {
                const calt  = this.currentIteration % 2 == 0 ? 0 : 1;

                let   cval  = chance.value/100;
                      cval += alternate.value/100 * (calt - cval);

                const ch    = this.random.get(this.currentIteration) > cval ? 0 : 1;

                
                if (   input0 
                    && input1)
                {
                    if (   input0.isValid()
                        && input1.isValid())
                        this.value = ch < 0.5 ? input0 : input1;
                    else
                        this.value = new NullValue();
                }

                else if (input0)
                    this.value = input0;
                
                else if (input1)
                    this.value = input1;
                
                else
                    this.value = new NumberValue(ch < 0.5 ? 0 : 1);
            }
            else
                this.value = new NullValue();
        }
        else
            this.value = new NullValue();


        this.setUpdateValues(parse,
        [
            ['type',      this.outputType()],
            ['seed',      seed             ],
            ['iteration', iteration        ],
            ['chance',    chance           ],
            ['alternate', alternate        ]
        ]);
        

        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return this.seed      && this.seed     .isValid()
            && this.iteration && this.iteration.isValid()
            && this.chance    && this.chance   .isValid()
            && this.alternate && this.alternate.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.seed     ) this.seed     .pushValueUpdates(parse);
        if (this.iteration) this.iteration.pushValueUpdates(parse);
        if (this.chance   ) this.chance   .pushValueUpdates(parse);
        if (this.alternate) this.alternate.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.seed     ) this.seed     .invalidateInputs(parse, from, force);
        if (this.iteration) this.iteration.invalidateInputs(parse, from, force);
        if (this.chance   ) this.chance   .invalidateInputs(parse, from, force);
        if (this.alternate) this.alternate.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.seed     ) this.seed     .iterateLoop(parse);
        if (this.iteration) this.iteration.iterateLoop(parse);
        if (this.chance   ) this.chance   .iterateLoop(parse);
        if (this.alternate) this.alternate.iterateLoop(parse);
    }
}



class GAccumulate
extends GOperator1
{
    current;
    when;



    constructor(nodeId, options)
    {
        super(NUMBER_ACCUMULATE, nodeId, options);

        this.current = new NumberValue(0);
    }


    
    reset()
    {
        super.reset();

        this.current = null;
        this.when    = null;
    }



    copy()
    {
        const copy = new GAccumulate(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.when   ) copy.when    = this.when   .copy();
        if (this.current) copy.current = this.current.copy();

        return copy;
    }



    async eval(parse)
    {
        if (    this.isCached()
            || !parse.evalAccumulate)
            return this;


        const input = await evalNumberValue(this.input, parse);
        const when  = await evalNumberValue(this.when,  parse);
            

        if (   input
            && when)
        {
            if (this.options.enabled)
            {
                if (when.value > 0)
                    this.value = this.current.copy();

                if (input)
                {
                    this.current.value   += input.value;
                    this.current.decimals = Math.max(this.current.decimals, input.decimals);
                }

                if (when.value == 0)
                    this.value = this.current.copy();
            }
            else
                this.value = input.copy();
        }
        else
            this.value = NumberValue.NaN.copy();


        this.setUpdateValues(parse, 
        [
            ['when', when]
        ]);
        

        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return super.isValid()
            && this.when && this.when.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.when) this.when.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.when) this.when.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.when) this.when.iterateLoop(parse);
    }



    resetLoop(parse, nodeId)
    {
        super.resetLoop(parse, nodeId);

        this.current = new NumberValue(0);
    }
}



class GHold
extends GOperator1
{
    current;
    first;



    constructor(nodeId, options)
    {
        super(HOLD, nodeId, options);

        this.current = null;
    }


    
    reset()
    {
        super.reset();

        this.current = null;
        this.first   = null;
    }



    copy()
    {
        const copy = new GHold(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.first  ) copy.first   = this.first  .copy();
        if (this.current) copy.current = this.current.copy();

        return copy;
    }



    async eval(parse)
    {
        if (    this.isCached()
            || !parse.evalAccumulate)
            return this;


        const input = await evalValue(this.input, parse);
        const first = await evalValue(this.first, parse);
            

        if (   input
            && first)
        {
            if (this.options.enabled)
            {
                this.value   = this.current ? this.current : first;
                this.current = input;
            }
            else
                this.value = input;
        }
        else
            this.value = NumberValue.NaN.copy();


        this.setUpdateValues(parse, 
        [
            ['type', this.outputType()]
        ]);
        

        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return super.isValid()
            && this.first && this.first.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.first) this.first.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.first) this.first.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.first) this.first.iterateLoop(parse);
    }



    resetLoop(parse, nodeId)
    {
        super.resetLoop(parse, nodeId);

        this.current = null;
    }
}



class GInterpolate
extends GOperator2
{
    inputs = [];

    amount;
    degree;



    constructor(nodeId, options)
    {
        super(NUMBER_INTERPOLATE, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.inputs = [];

        this.amount = null;
        this.degree = null;
    }



    copy()
    {
        const copy = new GInterpolate(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        if (this.amount) copy.amount = this.amount.copy();
        if (this.degree) copy.degree = this.degree.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const amount = await evalNumberValue(this.amount, parse);
        const degree = await evalNumberValue(this.degree, parse);


        const values = [];
        
        for (const _input of this.inputs)
        {
            const input = await evalNumberOrListValue(_input, parse);

            if (isListValueType(input.type))
            {
                for (const item of input.items)
                {
                    // if (item.type != NUMBER_VALUE)
                    //     continue;
    
                    const value = await evalNumberValue(item, parse);
                    values.push(value);
                }
            }
            else
            {
                const value = await evalNumberValue(input, parse);
                values.push(value);
            }
        }
        
        
        const maxDec = values.reduce((max, v) => Math.max(max, v.decimals), 0);


        const deg =
            degree.value < 3
            ? Math.min(degree.value, 2) + 1
            : 1;

        const nSegments = Math.floor((values.length-1)/deg);
        const index     = Math.min(Math.floor((values.length-1)/deg * amount.value/100), nSegments-1);


        if (values.length == 1)
            this.value = values[0];

        else if (values.length > 0
              && index < values.length - deg)
        {
            const localAmount = 
                nSegments > 1
                ? (amount.value/100 - index/nSegments) * nSegments
                : amount.value/100;


            if (degree.value == 0) // linear
            {
                const val0 = values[index*deg  ];
                const val1 = values[index*deg+1];

                this.value = new NumberValue(
                    lerp(val0.value, val1.value, localAmount),
                    maxDec);
            }
            else if (degree.value == 1) // quadratic
            {
                const val0 = values[index*deg  ];
                const val1 = values[index*deg+1];
                const val2 = values[index*deg+2];

                this.value = new NumberValue(
                    lerp2(val0.value, val1.value, val2.value, localAmount),
                    maxDec);
            }
            else if (degree.value == 2) // cubic
            {
                const val0 = values[index*deg  ];
                const val1 = values[index*deg+1];
                const val2 = values[index*deg+2];
                const val3 = values[index*deg+3];

                this.value = new NumberValue(
                    lerp3(val0.value, val1.value, val2.value, val3.value, localAmount),
                    maxDec);
            }
            else if (degree.value == 3) // cosine
            {
                const val0 = values[index*deg  ];
                const val1 = values[index*deg+1];

                this.value = new NumberValue(
                    lerpCos(val0.value, val1.value, localAmount),
                    maxDec);
            }
            else
                this.value = NumberValue.NaN.copy();
        }

        else                  
            this.value = NumberValue.NaN.copy();


        this.setUpdateValues(parse,
        [
            ['value',  this.value],
            ['amount', amount    ],
            ['degree', degree    ]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return  super.isValid()
            &&  this.inputs.length > 0
            && !this.inputs.find(i => !i.isValid())
            &&  this.amount && this.amount.isValid()
            &&  this.degree && this.degree.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse));

        if (this.amount) this.amount.pushValueUpdates(parse);
        if (this.degree) this.degree.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        this.inputs.forEach(i => i.invalidateInputs(parse, from, force));

        if (this.amount) this.amount.invalidateInputs(parse, from, force);
        if (this.degree) this.degree.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        this.inputs.forEach(i => i.iterateLoop(parse));

        if (this.amount) this.amount.iterateLoop(parse);
        if (this.degree) this.degree.iterateLoop(parse);
    }
}



class GSolve
extends GOperator1
{
    current = null;
    target  = null;

    temp    = null;


    
    constructor(nodeId, options)
    {
        super(NUMBER_LIMITS, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.current = null;
        this.target  = null;
        this.temp    = null;
    }



    copy()
    {
        const copy = new GSolve(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.current) copy.current = this.current.copy();
        if (this.target ) copy.target  = this.target .copy();

        return copy;
    }



    isCached()
    {
        return super.isCached()
            && this.current.isCached()
            && this.target .isCached();
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        let   input   = await evalNumberValue(this.input,   parse);
        let   current = await evalNumberValue(this.current, parse);
        const target  = await evalNumberValue(this.target,  parse);


        if (   input
            && current.isValid()
            && target .isValid())
        {
            consoleAssert(
                input.type == NUMBER_VALUE, 
                'input.type must be NUMBER_VALUE');


            if (this.options.enabled)
            {
                let   diff      = target.value - current.value;
                let   prevDiff  = 0;


                let   temp      = 0;
                let   step      = Number.MAX_SAFE_INTEGER/65536;


                let   iter      = 0;
                const maxIter   = 1000;
                

                genInitNodeProgress(this.nodeId);


                parse.totalProgress += maxIter;


                while (iter++ < maxIter)
                {
                    temp += step;


                    if (this.input.type == PARAM)
                    {
                        this.input.node[this.input.paramId].value    = temp;
                        this.input.node[this.input.paramId].decimals = decDigits(temp);
                    }

                        
                    this.current.invalidateInputs(parse, this);
                    current = await evalNumberValue(this.current, parse);


                    // if (!current.isValid())
                    //     diff = Number.MAX_SAFE_INTEGER;
                    // else
                    if (current.isValid())
                    {
                        diff = target.value - current.value;
                        //console.log('diff =', diff);

                        if (Math.abs(diff) < 0.0000001)
                            break;
                            

                        if (   Math.abs (diff) >  Math.abs (prevDiff)
                            || Math.sign(diff) != Math.sign(prevDiff))
                            step /= -2;

                        // console.log('step =', step);
                        // console.log('');

                        prevDiff = diff;
                    }
                        

                    parse.currentProgress++;
                    genUpdateNodeProgress(parse, this.nodeId, iter / maxIter);
                }


                if (iter < maxIter)
                {
                    parse.currentProgress += maxIter - iter;

                    input = await evalNumberValue(this.input, parse);
                    this.value = input.copy();
                }
                else
                {
                    this.value = NumberValue.NaN.copy();
                    console.warn('max solve iterations');
                }
            }
            else
                this.value = input.copy();
        }
        else
        {
            if (this.input) 
                await this.input.eval(parse);

            this.value = NumberValue.NaN.copy();
        }

        
        // TODO push good result value to input 

        this.setUpdateValues(parse,
        [
            //['value',   this.value],
            ['current', current   ],
            ['target',  target    ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.current && this.current.isValid()
            && this.target  && this.target .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.current) this.current.pushValueUpdates(parse);
        if (this.target ) this.target .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.current) this.current.invalidateInputs(parse, from, force);
        if (this.target ) this.target .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.current) this.current.iterateLoop(parse);
        if (this.target ) this.target .iterateLoop(parse);
    }
}



class GAnimate
extends GOperator
{
    from   = null;
    to     = null;
    curve  = null;
    repeat = null;
    length = null;
    time   = null;
    
    
    
    constructor(nodeId, options)
    {
        super(NUMBER_ANIMATE, nodeId, options);
    }
    
    
    
    reset()
    {
        super.reset();
        
        this.from   = null;
        this.to     = null;
        this.curve  = null;
        this.repeat = null;
        this.length = null;
        this.time   = null;
    }



    copy()
    {
        const copy = new GAnimate(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.from  ) copy.from   = this.from  .copy();
        if (this.to    ) copy.to     = this.to    .copy();
        if (this.curve ) copy.curve  = this.curve .copy();
        if (this.repeat) copy.repeat = this.repeat.copy();
        if (this.length) copy.length = this.length.copy();
        if (this.time  ) copy.time   = this.time  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const from   = await evalNumberValue(this.from,   parse);
        const to     = await evalNumberValue(this.to,     parse);
        const curve  = await evalNumberValue(this.curve,  parse);
        const repeat = await evalNumberValue(this.repeat, parse);
        const length = await evalNumberValue(this.length, parse);
        const time   = await evalNumberValue(this.time,   parse);
    

        const maxDec = Math.max(from.decimals, to.decimals);

        switch (curve.value)
        {
            case 0: 
            {
                this.value = new NumberValue(
                    time.value < length.value ? from.value : to.value, 
                    maxDec);
    
                break;
            }
            case 1: 
            {
                this.value = new NumberValue(
                    from.value + (to.value - from.value) * time.value / length.value,
                    maxDec);

                break;
            }
            case 2: 
            {
                let f = time.value / length.value;

                f = 1 - sqr(1 - f);

                this.value = new NumberValue(
                    from.value + (to.value - from.value) * f,
                    maxDec);
    
                break;
            }
            case 3: 
            {
                let f = time.value / length.value;

                f = sqr(f);

                this.value = new NumberValue(
                    from.value + (to.value - from.value) * f,
                    maxDec);
    
                break;
            }
            case 4: 
            {
                let f = time.value / length.value;

                f = 6*Math.pow(f, 5) - 15*Math.pow(f, 4) + 10*Math.pow(f, 3);

                this.value = new NumberValue(
                    from.value + (to.value - from.value) * f,
                    maxDec);
    
                break;
            }
        }
        

        this.setUpdateValues(parse,
        [
            ['from',   from  ],
            ['to',     to    ],
            ['curve',  curve ],
            ['repeat', repeat],
            ['length', length],
            ['time',   time  ]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return this.from   && this.from  .isValid()
            && this.to     && this.to    .isValid()
            && this.curve  && this.curve .isValid()
            && this.repeat && this.repeat.isValid()
            && this.length && this.length.isValid()
            && this.time   && this.time  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.from  ) this.from  .pushValueUpdates(parse);
        if (this.to    ) this.to    .pushValueUpdates(parse);
        if (this.curve ) this.curve .pushValueUpdates(parse);
        if (this.repeat) this.repeat.pushValueUpdates(parse);
        if (this.length) this.length.pushValueUpdates(parse);
        if (this.time  ) this.time  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.from  ) this.from  .invalidateInputs(parse, from, force);
        if (this.to    ) this.to    .invalidateInputs(parse, from, force);
        if (this.curve ) this.curve .invalidateInputs(parse, from, force);
        if (this.repeat) this.repeat.invalidateInputs(parse, from, force);
        if (this.length) this.length.invalidateInputs(parse, from, force);
        if (this.time  ) this.time  .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.from  ) this.from  .iterateLoop(parse);
        if (this.to    ) this.to    .iterateLoop(parse);
        if (this.curve ) this.curve .iterateLoop(parse);
        if (this.repeat) this.repeat.iterateLoop(parse);
        if (this.length) this.length.iterateLoop(parse);
        if (this.time  ) this.time  .iterateLoop(parse);
    }
}



class GMath
extends GArithmetic
{
    operation;



    constructor(nodeId, options)
    {
        super(NUMBER_MATH, nodeId, options);
    }


    reset()
    {
        super.reset();

        this.operation = null;
    }



   
    copy()
    {
        const copy = new GMath(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        if (this.operation) copy.operation = this.operation.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const inputs = await Promise.all(this.inputs.map(async i => await evalNumberOrListValue(i, parse)));
        let   op     = await evalNumberValue(this.operation, parse);


        if (op) op = op.toInteger();
        

        if (op.isValid())
        {
            op.value    = Math.min(Math.max(0, Math.round(op.value)), MATH_OPS.length-1);
            op.decimals = 0;
        }


        this.value = await evalMathInputs(inputs, op, parse);


        this.setUpdateValues(parse,
        [
            ['type',      this.outputType()],
            ['operation', op               ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.operation && this.operation.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.operation) this.operation.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.operation) this.operation.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.operation) this.operation.iterateLoop(parse);
    }
}



async function evalMathInputs(inputs, op, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN.copy();


    const allAreLists = allInputsAreCondensedLists(inputs);

    if (allAreLists) return await evalMathListInputs(inputs, op, parse);
    else             return await evalMathItemInputs(inputs, op, parse);
}



async function evalMathListInputs(inputs, op, parse)
{
    const value = new ListValue();

    
    for (const input of inputs)
    {
        if (!input) continue;

        console.assert(
             isListValueType(input.type), 
            `input is ${input.type}, must be a list`);

        if (allInputsAreCondensedLists(input.items))
            value.items.push(...(await evalMathListInputs(input.items, op, parse)).items);
        else
            value.items.push(await evalMathItemInputs(input.items, op, parse));
    }


    return value;
}



async function evalMathItemInputs(inputs, op, parse)
{
    switch (op.value)
    {
        case 0: return await evalModuloInputs  (inputs, parse);
        case 1: return await evalDivideInputs  (inputs, parse);
        case 2: return await evalSubtractInputs(inputs, parse);
        case 3: return await evalAddInputs     (inputs, parse);
        case 4: return await evalMultiplyInputs(inputs, parse);
        case 5: return await evalExponentInputs(inputs, parse);
    }
}



async function evalAddInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN.copy();


    const value = new NumberValue(0);


    for (let i = 0; i < inputs.length; i++)
    {
        const input = await evalNumberOrListValue(inputs[i], parse);
        

        if (   !input
            || !input.isValid())
            return NumberValue.NaN.copy();


        if (isListValueType(input.type))
        {
            if (   isEmpty(input.items)
                || input.items[0].type != NUMBER_VALUE)
                return NumberValue.NaN.copy();

            for (const item of input.items)
            {
                if (item.type == NUMBER_VALUE)
                {
                    value.value   += item.value;
                    value.decimals = Math.max(value.decimals, item.decimals);
                }
            }
        }
        else
        {
            consoleAssert(
                 input.type == NUMBER_VALUE, 
                'input.type must be NUMBER_VALUE');

            value.value   += input.value;
            value.decimals = Math.max(value.decimals, input.decimals);
        }
    }


    return value;
}



async function evalSubtractInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN.copy();


    let value = new NumberValue(0);


    if (!isEmpty(inputs))
    {
        const input0 = await evalNumberOrListValue(inputs[0], parse);

        if (   !input0
            || !input0.isValid())
            return NumberValue.NaN.copy();


        if (     isListValueType(input0.type)
             && !isEmpty(input0.items))
        {
            const item0 = input0.items[0];

            if (   !item0
                || !item0.isValid())
                return NumberValue.NaN.copy();


            value = item0;


            for (let i = 1; i < input0.items.length; i++)
            {
                const item = input0.items[i];

                if (   !item
                    || !item.isValid())
                    return NumberValue.NaN.copy();

                if (item.type == NUMBER_VALUE)
                {
                    value.value   -= item.value;
                    value.decimals = Math.max(value.decimals, item.decimals);
                }                    
            }
        }
        else
        {
            if (input0.type != NUMBER_VALUE)
                return NumberValue.NaN.copy();

            value = input0;
        }


        for (let i = 1; i < inputs.length; i++)
        {
            const input = await evalNumberOrListValue(inputs[i], parse);

            if (   !input
                || !input.isValid())
                return NumberValue.NaN.copy();


            if (isListValueType(input.type))
            {
                for (const item of input.items)
                {
                    if (item.type == NUMBER_VALUE)
                    {
                        value.value   -= item.value;
                        value.decimals = Math.max(value.decimals, item.decimals);
                    }                    
                }
            }
            else
            {
                consoleAssert(
                     input.type == NUMBER_VALUE, 
                    'input.type must be NUMBER_VALUE');
                    
                value.value   -= input.value;
                value.decimals = Math.max(value.decimals, input.decimals);
            }
        }
    }


    return value;
}



async function evalMultiplyInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN.copy();


    const value = new NumberValue(0);


    if (!isEmpty(inputs))
    {
        value.value = 1;

        for (let i = 0; i < inputs.length; i++)
        {
            const input = await evalNumberOrListValue(inputs[i], parse);

            if (   !input
                || !input.isValid())
                return NumberValue.NaN.copy();


            if (isListValueType(input.type))
            {
                if (   isEmpty(input.items)
                    || input.items[0].type != NUMBER_VALUE)
                    return NumberValue.NaN.copy();

                for (const item of input.items)
                {
                    value.value   *= item.value;
                    value.decimals = Math.max(value.decimals, item.decimals);
                }
            }
            else
            {
                consoleAssert(
                     input.type == NUMBER_VALUE, 
                    'input.type must be NUMBER_VALUE');

                value.value   *= input.value;
                value.decimals = Math.max(value.decimals, input.decimals);
            }
        }
    }


    return value;
}



async function evalDivideInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN.copy();

        
    let value = new NumberValue(0);

        
    if (!isEmpty(inputs))
    {
        const input0 = await evalNumberOrListValue(inputs[0], parse);

        if (   !input0
            || !input0.isValid())
            return NumberValue.NaN.copy();


        if (    isListValueType(input0.type)
            && !isEmpty(input0.items))
        {
            const item0 = input0.items[0];

            if (   !item0
                || !item0.isValid())
                return NumberValue.NaN.copy();


            value = item0;


            for (let i = 1; i < input0.items.length; i++)
            {
                const item = input0.items[i];

                if (   !item
                    || !item.isValid())
                    return NumberValue.NaN.copy();

                    
                if (item.type == NUMBER_VALUE)
                {
                    if (item.value == 0) 
                    { 
                        value.value    = Number.NaN; 
                        value.decimals = 0;
                        break; 
                    }

                    value.value    = value.value / item.value;
                    value.decimals = Math.max(value.decimals, item.decimals);
                }                    
            }
        }
        else
        {
            if (input0.type != NUMBER_VALUE)
                return NumberValue.NaN.copy();

            value = input0;
        }

        
        for (let i = 1; i < inputs.length; i++)
        {
            const input = await evalNumberOrListValue(inputs[i], parse);

            if (   !input
                || !input.isValid())
                return NumberValue.NaN.copy();


            if (isListValueType(input.type))
            {
                for (const item of input.items)
                {
                    if (   !item
                        || !item.isValid())
                        return NumberValue.NaN.copy();


                    if (item.type == NUMBER_VALUE)
                    {
                        if (item.value == 0) 
                        { 
                            value.value    = Number.NaN; 
                            value.decimals = 0;
                            break; 
                        }

                        value.value    = value.value / item.value;
                        value.decimals = Math.max(value.decimals, item.decimals);
                    }                    
                }
            }
            else
            {
                consoleAssert(
                     input.type == NUMBER_VALUE, 
                    'input.type must be NUMBER_VALUE');

                if (input.value == 0) 
                { 
                    value.value    = Number.NaN; 
                    value.decimals = 0;
                    break; 
                }
    
                
                value.value    = value.value / input.value;
                value.decimals = Math.max(value.decimals, input.decimals);
            }
        }
    }


    return value;
}



async function evalModuloInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN.copy();

        
    let value = new NumberValue(0);

        
    if (!isEmpty(inputs))
    {
        const input0 = await evalNumberOrListValue(inputs[0], parse);

        if (   !input0
            || !input0.isValid())
            return NumberValue.NaN.copy();


        if (    isListValueType(input0.type)
            && !isEmpty(input0.items))
        {
            const item0 = input0.items[0];

            if (   !item0
                || !item0.isValid())
                return NumberValue.NaN.copy();


            value = item0;

            
            for (let i = 1; i < input0.items.length; i++)
            {
                const item = input0.items[i];
                
                if (   !item
                    || !item.isValid())
                    return NumberValue.NaN.copy();


                if (item.type == NUMBER_VALUE)
                {
                    if (item.value == 0) 
                    { 
                        value.value    = Number.NaN; 
                        value.decimals = 0;
                        break; 
                    }

                    value.decimals = Math.max(value.decimals, item.decimals);
                    value.value    = value.value % item.value;
                }                    
            }
        }
        else
        {
            if (input0.type != NUMBER_VALUE)
                return NumberValue.NaN.copy();

            value = input0;
        }


        for (let i = 1; i < inputs.length; i++)
        {
            const input = await evalNumberOrListValue(inputs[i], parse);

            if (   !input
                || !input.isValid())
                return NumberValue.NaN.copy();


            if (isListValueType(input.type))
            {
                for (const item of input.items)
                {
                    if (   !item
                        || !item.isValid())
                        return NumberValue.NaN.copy();


                    if (item.type == NUMBER_VALUE)
                    {
                        if (item.value == 0) 
                        { 
                            value.value    = Number.NaN; 
                            value.decimals = 0;
                            break; 
                        }

                        value.decimals = Math.max(value.decimals, item.decimals);
                        value.value    = floorTo(value.value % item.value, value.decimals);
                    }                    
                }
            }
            else
            {
                consoleAssert(
                     input.type == NUMBER_VALUE, 
                    'input.type must be NUMBER_VALUE');

                if (input.value == 0) 
                { 
                    value.value    = Number.NaN; 
                    value.decimals = 0;
                    break; 
                }

                value.decimals = Math.max(value.decimals, input.decimals);
                value.value    = floorTo(value.value % input.value, value.decimals);
            }
        }
    }


    return value;
}



async function evalExponentInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN.copy();


    let value = new NumberValue(0);


    if (!isEmpty(inputs))
    {
        const input0 = await evalNumberOrListValue(inputs[0], parse);

        if (   !input0
            || !input0.isValid())
            return NumberValue.NaN.copy();


        if (    isListValueType(input0.type)
            && !isEmpty(input0.items))
        {
            const item0 = input0.items[0];

            if (   !item0
                || !item0.isValid())
                return NumberValue.NaN.copy();


            value = item0;

            
            for (let i = 1; i < input0.items.length; i++)
            {
                const item = input0.items[i];
                
                if (   !item
                    || !item.isValid())
                    return NumberValue.NaN.copy();


                if (item.type == NUMBER_VALUE)
                {
                    value.value    = Math.pow(value.value,    item.value);
                    value.decimals = Math.max(value.decimals, item.decimals);
                }                    
            }
        }
        else
        {
            if (input0.type != NUMBER_VALUE)
                return NumberValue.NaN.copy();

            value = input0;
        }


        for (let i = 1; i < inputs.length; i++)
        {
            const input = await evalNumberOrListValue(inputs[i], parse);

            if (   !input
                || !input.isValid())
                return NumberValue.NaN.copy();


            if (isListValueType(input.type))
            {
                for (const item of input.items)
                {
                    if (   !item
                        || !item.isValid())
                        return NumberValue.NaN.copy();

                    if (item.type == NUMBER_VALUE)
                    {
                        value.value    = Math.pow(value.value,    item.value);
                        value.decimals = Math.max(value.decimals, item.decimals);
                    }                    
                }
            }
            else
            {
                consoleAssert(
                    input.type == NUMBER_VALUE, 
                    'input.type must be NUMBER_VALUE');

                value.value    = Math.pow(value.value,    input.value);
                value.decimals = Math.max(value.decimals, input.decimals);
            }
        }
    }


    return value;
}


class GSimpleMath
extends GOperator1
{
    operation;
    operand;
    invert;



    constructor(nodeId, options)
    {
        super(NUMBER_SIMPLE_MATH, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.operation = null;
        this.operand   = null;
        this.invert    = null;
    }



    copy()
    {
        const copy = new GSimpleMath(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.operation) copy.operation = this.operation.copy();
        if (this.operand  ) copy.operand   = this.operand  .copy();
        if (this.invert   ) copy.invert    = this.invert   .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = new NumberValue(0);


        const input   = await evalNumberOrListValue(this.input,     parse);
        const op      = await evalNumberValue      (this.operation, parse);
        const operand = await evalNumberValue      (this.operand,   parse);
        const invert  = await evalNumberValue      (this.invert,    parse);


        if (op)
        {
            op.value    = Math.min(Math.max(0, Math.round(op.value)), MATH_OPS.length-1);
            op.decimals = 0;
        }


        if (   input
            && op)
        {
            if (this.options.enabled)
            {
                if (isListValueType(input.type))
                {
                    this.value = new ListValue();

                    for (let i = 0; i < input.items.length; i++)
                    {
                        const item = input.items[i];

                        this.value.items.push(
                            item.type == NUMBER_VALUE
                            ? getSimpleMathValue(item, operand, op, invert, this.options.enabled)
                            : NumberValue.NaN.copy());   
                    }
                }
                else
                {
                    this.value = getSimpleMathValue(input, operand, op, invert, this.options.enabled);
                }
            }
            else
                this.value = input.copy();
        }
        else
            this.value = NumberValue.NaN.copy();


        this.setUpdateValues(parse,
        [
            ['type',      this.outputType()],
            ['operation', op               ],
            ['operand',   operand          ],
            ['invert',    invert           ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.operation && this.operation.isValid()
            && this.operand   && this.operand  .isValid()
            && this.invert    && this.invert   .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.operation) this.operation.pushValueUpdates(parse);
        if (this.operand  ) this.operand  .pushValueUpdates(parse);
        if (this.invert   ) this.invert   .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.operation) this.operation.invalidateInputs(parse, from, force);
        if (this.operand  ) this.operand  .invalidateInputs(parse, from, force);
        if (this.invert   ) this.invert   .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.operation) this.operation.iterateLoop(parse);
        if (this.operand  ) this.operand  .iterateLoop(parse);
        if (this.invert   ) this.invert   .iterateLoop(parse);
    }
}



function getSimpleMathValue(input, operand, op, invert, enabled)
{
    consoleAssert(
        input.type == NUMBER_VALUE, 
        'input.type is ' + input.type + ', must be NUMBER_VALUE');


    if (enabled)
    {
        op.value = Math.min(Math.max(0, Math.floor(op.value)), MATH_OPS.length-1);

        const maxDecimals = Math.max(input.decimals, operand.decimals);

        switch (op.value)
        {
            case 0: // % 
                return invert.value == 0
                    ? new NumberValue(input.value % operand.value, maxDecimals)
                    : new NumberValue(operand.value % input.value, maxDecimals);

            case 1: // /
                if (      operand.value == 0
                       && invert .value == 0
                    ||    input  .value == 0
                       && invert .value == 1)
                    return NumberValue.NaN.copy();
                else
                    return invert.value == 0
                        ? new NumberValue(input.value / operand.value, maxDecimals)
                        : new NumberValue(operand.value / input.value, maxDecimals);

            case 2: // -
                return invert.value == 0
                    ? new NumberValue(input.value - operand.value, maxDecimals)
                    : new NumberValue(operand.value - input.value, maxDecimals);

            case 3: // +
                return invert.value == 0
                    ? new NumberValue(input.value + operand.value, maxDecimals)
                    : new NumberValue(operand.value + input.value, maxDecimals);

            case 4: // *
                return invert.value == 0
                    ? new NumberValue(input.value * operand.value, maxDecimals)
                    : new NumberValue(operand.value * input.value, maxDecimals);

            case 5: // eˣ
                return invert.value == 0
                    ? new NumberValue(Math.pow(input.value, operand.value), maxDecimals)
                    : new NumberValue(Math.pow(operand.value, input.value), maxDecimals);
        }


        consoleError('invalid math operation');
        return input;
    }
    else
        return input;
}


class GBoolean
extends GArithmetic
{
    operation;



    constructor(nodeId, options)
    {
        super(NUMBER_BOOLEAN, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.operation = null;
    }


   
    copy()
    {
        const copy = new GBoolean(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs    = this.inputs.map(i => i.copy());

        if (this.operation) copy.operation = this.operation.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        let op = await evalNumberValue(this.operation, parse);

        if (op) op = op.toInteger();


        op.value     = 
        op.initValue = Math.min(Math.max(0, op.value), BOOLEAN_OPS.length-1);

        
        switch (op.value)
        {
            case BOOLEAN_NOT: this.value = await evalNandInputs(this.inputs, parse); break;
            case BOOLEAN_XOR: this.value = await evalXorInputs (this.inputs, parse); break;
            case BOOLEAN_OR:  this.value = await evalOrInputs  (this.inputs, parse); break;
            case BOOLEAN_AND: this.value = await evalAndInputs (this.inputs, parse); break;
        }

        
        this.setUpdateValues(parse,
        [
            //['value',     this.value],
            ['operation', op        ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.operation && this.operation.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.operation) this.operation.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.operation) this.operation.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.operation) this.operation.iterateLoop(parse);
    }
}


class GNot
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_NOT, nodeId, options);
    }


    
    copy()
    {
        const copy = new GNot(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalNandInputs(this.inputs, parse);
        

        this.setUpdateValues(parse, 
        [
            ['', new NullValue()]
            //['value', this.value]
        ]);


        this.validate();

        return this;
    }
}



async function evalNandInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN.copy();


    const value = new NumberValue();


    if (!isEmpty(inputs))
    {
        const val0 = await evalNumberOrListValue(inputs[0], parse);
        if (!val0.isValid()) return NumberValue.NaN.copy();

        if (    isListValueType(val0.type)
            && !isEmpty(val0.items))
        {
            const item0 = val0.items[0];

            value.value = item0.toNumber() != 0 ? 0 : 1;

            for (let i = 1; i < val0.items.length; i++)
            {
                const item = val0.items[i];
                
                if (   item.type == NUMBER_VALUE
                    && item.toNumber() == 0)
                    value.value = 1;
            }
        }
        else
        {
            if (val0.type != NUMBER_VALUE)
                return NumberValue.NaN.copy();

            value.value = val0.toNumber() != 0 ? 0 : 1;
        }


        for (let i = 1; i < inputs.length; i++)
        {
            const val = await evalNumberOrListValue(inputs[i], parse);
            if (!val.isValid()) return NumberValue.NaN.copy();

            if (isListValueType(val.type))
            {
                for (const item of val.items)
                {
                    if (   item.type == NUMBER_VALUE
                        && item.toNumber() == 0)
                        value.value = 1;
                }
            }
            else
            {
                consoleAssert(
                    val.type == NUMBER_VALUE, 
                    'val.type must be NUMBER_VALUE');

                if (val.toNumber() == 0)
                    value.value = 1;
            }
        }
    }


    return value;
}



class GAnd
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_AND, nodeId, options);
    }


    
    copy()
    {
        const copy = new GAnd(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalAndInputs(this.inputs, parse);
        

        this.setUpdateValues(parse, 
        [
            ['', new NullValue()]
            //['value', this.value]
        ]);

        
        this.validate();

        return this;
    }
}



async function evalAndInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN.copy();


    const value = new NumberValue();


    if (!isEmpty(inputs))
    {
        const val0 = await evalNumberOrListValue(inputs[0], parse);
        if (!val0.isValid()) return NumberValue.NaN.copy();


        if (    isListValueType(val0.type)
            && !isEmpty(val0.items))
        {
            const item0 = val0.items[0];

            value.value = item0.toNumber();

            for (let i = 1; i < val0.items.length; i++)
            {
                const item = val0.items[i];
                
                if (item.type == NUMBER_VALUE)
                    value.value = Math.min(value.value, item.toNumber());
            }
        }
        else
        {
            if (val0.type != NUMBER_VALUE)
                return NumberValue.NaN.copy();

            value.value = val0.toNumber();
        }


        for (let i = 1; i < inputs.length; i++)
        {
            const val = await evalNumberOrListValue(inputs[i], parse);
            if (!val.isValid()) return NumberValue.NaN.copy();


            if (isListValueType(val.type))
            {
                for (const item of val.items)
                {
                    if (item.type == NUMBER_VALUE)
                        value.value = Math.min(value.value, item.toNumber());
                }
            }
            else
            {
                consoleAssert(
                    val.type == NUMBER_VALUE, 
                    'val.type must be NUMBER_VALUE');

                value.value = Math.min(value.value, val.toNumber());
            }
        }

        
        if (value.value != 0)
            value.value = 1;
    }


    return value;
}


class GOr
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_OR, nodeId, options);
    }


    
    copy()
    {
        const copy = new GOr(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalOrInputs(this.inputs, parse);
        

        this.setUpdateValues(parse, 
        [
            ['', new NullValue()]
            //['value', this.value]
        ]);


        this.validate();

        return this;
    }
}



async function evalOrInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN.copy();


    const value = new NumberValue();


    if (!isEmpty(inputs))
    {
        const val0 = await evalNumberOrListValue(inputs[0], parse);
        if (!val0.isValid()) return NumberValue.NaN.copy();

        if (    isListValueType(val0.type)
            && !isEmpty(val0.items))
        {
            const item0 = val0.items[0];

            value.value = item0.toNumber();

            for (let i = 1; i < val0.items.length; i++)
            {
                const item = val0.items[i];
                
                if (item.type == NUMBER_VALUE)
                    value.value = Math.max(value.value, item.toNumber());
            }
        }
        else
        {
            if (val0.type != NUMBER_VALUE)
                return NumberValue.NaN.copy();

            value.value = val0.toNumber();
        }


        for (let i = 1; i < inputs.length; i++)
        {
            const val = await evalNumberOrListValue(inputs[i], parse);
            if (!val.isValid()) return NumberValue.NaN.copy();

            if (isListValueType(val.type))
            {
                for (const item of val.items)
                {
                    if (item.type == NUMBER_VALUE)
                        value.value = Math.max(value.value, item.toNumber());
                }
            }
            else
            {
                consoleAssert(
                    val.type == NUMBER_VALUE, 
                    'val.type must be NUMBER_VALUE');
                    
                value.value = Math.max(value.value, val.toNumber());
            }
        }


        if (value.value != 0)
            value.value = 1;
    }


    return value;
}


class GXor
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_XOR, nodeId, options);
    }


    
    copy()
    {
        const copy = new GXor(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalXorInputs(this.inputs, parse);
        

        this.setUpdateValues(parse, 
        [
            ['', new NullValue()]
            //['value', this.value]
        ]);


        this.validate();

        return this;
    }
}



async function evalXorInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN.copy();


    const value = new NumberValue(0);


    let flipped;

    if (!isEmpty(inputs))
    {
        const val0 = await evalNumberOrListValue(inputs[0], parse);
        if (!val0.isValid()) return NumberValue.NaN.copy();

        if (    isListValueType(val0.type)
            && !isEmpty(val0.items))
        {
            const item0 = val0.items[0];

            flipped = item0.toNumber() != 0;

            for (let i = 1; i < val0.items.length; i++)
            {
                const item = val0.items[i];
                
                if (   item.type == NUMBER_VALUE
                    && item.toNumber() != 0)
                    flipped++;
            }
        }
        else
        {
            if (val0.type != NUMBER_VALUE)
                return NumberValue.NaN.copy();

            flipped = val0.toNumber() != 0;
        }


        for (let i = 1; i < inputs.length; i++)
        {
            const val = await evalNumberOrListValue(inputs[i], parse);
            if (!val.isValid()) return NumberValue.NaN.copy();

            if (isListValueType(val.type))
            {
                for (const item of val.items)
                {
                    if (   item.type == NUMBER_VALUE
                        && item.toNumber() != 0)
                        flipped++;
                    }
            }
            else
            {
                consoleAssert(
                    val.type == NUMBER_VALUE, 
                    'val.type must be NUMBER_VALUE');
                    
                if (val.toNumber() != 0)
                    flipped++;
            }
        }


        value.value = flipped == 1 ? 1 : 0;
    }


    return value;
}


class GCompare
extends GOperator1
{
    operation;
    operand;



    constructor(nodeId, options)
    {
        super(NUMBER_CONDITION, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.operation = null;
        this.operand   = null;
    }



    copy()
    {
        const copy = new GCompare(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.operation) copy.operation = this.operation.copy();
        if (this.operand  ) copy.operand   = this.operand  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input   = await evalNumberOrListValue(this.input,     parse);
        const op      = await evalNumberValue      (this.operation, parse);
        const operand = await evalNumberValue      (this.operand,   parse);

        op.value = Math.min(Math.max(0, op.value), CONDITION_OPS.length-1);

        
        if (   input
            && operand
            && op)
        {
            if (isListValueType(input.type))
            {
                this.value = new ListValue();

                for (let i = 0; i < input.items.length; i++)
                {
                    const item = input.items[i];

                    this.value.items.push(
                        item.type == NUMBER_VALUE
                        ? await getCompareValue(item, operand, op)
                        : NumberValue.NaN.copy());
                }
            }
            else
            {
                this.value = await getCompareValue(input, operand, op);
            }
        }
        else
            this.value = NumberValue.NaN.copy();


        this.setUpdateValues(parse,
        [
            ['type',      this.outputType()],
            ['operation', op               ],
            ['operand',   operand          ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.operation && this.operation.isValid()
            && this.operand   && this.operand  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.operation) this.operation.pushValueUpdates(parse);
        if (this.operand  ) this.operand  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.operation) this.operation.invalidateInputs(parse, from, force);
        if (this.operand  ) this.operand  .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.operation) this.operation.iterateLoop(parse);
        if (this.operand  ) this.operand  .iterateLoop(parse);
    }
}



async function getCompareValue(input, operand, op)
{
    switch (op.value)
    {
        case CONDITION_LESS:              return await evalCompareNumberInputs(input, operand, ((a, b) => a <  b));
        case CONDITION_LESS_OR_EQUAL:     return await evalCompareNumberInputs(input, operand, ((a, b) => a <= b));
        case CONDITION_NOT_EQUAL:         return await evalCompareNumberInputs(input, operand, ((a, b) => a != b));
        case CONDITION_EQUAL:             return await evalCompareNumberInputs(input, operand, ((a, b) => a == b));
        case CONDITION_GREATER_OR_EQUAL:  return await evalCompareNumberInputs(input, operand, ((a, b) => a >= b));
        case CONDITION_GREATER:           return await evalCompareNumberInputs(input, operand, ((a, b) => a >  b));
    }
}



async function evalCompareNumberInputs(input, operand, compare) 
{
    if (   input   && input  .isValid() 
        && operand && operand.isValid())
    {
        return new NumberValue(
            compare(input.toNumber(), operand.toNumber()) ? 1 : 0,
            0,
            true);
    }
    else
    {
        return NumberValue.NaN.copy();
    }
}


class GEqual
extends GOperator2
{
    constructor(nodeId, options)
    {
        super(NUMBER_EQUAL, nodeId, options);
    }


    
    copy()
    {
        const copy = new GEqual(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalConditionInputs(
            this.input0, 
            this.input1, 
            (a, b) => a == b, 
            parse);
            

        this.setUpdateValues(parse, 
        [
            ['', new NullValue()]
            //['value', this.value]
        ]);


        this.validate();

        return this;
    }
}



class GNotEqual
extends GOperator2
{
    constructor(nodeId, options)
    {
        super(NUMBER_NOT_EQUAL, nodeId, options);
    }


    
    copy()
    {
        const copy = new GNotEqual(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalConditionInputs(
            this.input0, 
            this.input1, 
            (a, b) => a != b, 
            parse);
        

        this.setUpdateValues(parse, 
        [
            ['', new NullValue()]
            //['value', this.value]
        ]);


        this.validate();

        return this;
    }
}


class GLess
extends GOperator2
{
    constructor(nodeId, options)
    {
        super(NUMBER_LESS, nodeId, options);
    }


    
    copy()
    {
        const copy = new GLess(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalConditionInputs(
            this.input0, 
            this.input1, 
            (a, b) => a < b, 
            parse);
            

        this.setUpdateValues(parse, 
        [
            ['', new NullValue()]
            //['value', this.value]
        ]);


        this.validate();

        return this;
    }
}


class GLessOrEqual
extends GOperator2
{
    constructor(nodeId, options)
    {
        super(NUMBER_LESS_OR_EQUAL, nodeId, options);
    }


    
    copy()
    {
        const copy = new GLessOrEqual(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalConditionInputs(
            this.input0, 
            this.input1, 
            (a, b) => a <= b, 
            parse);
            

        this.setUpdateValues(parse, 
        [
            ['', new NullValue()]
            //['value', this.value]
        ]);


        this.validate();

        return this;
    }
}



class GGreater
extends GOperator2
{
    constructor(nodeId, options)
    {
        super(NUMBER_GREATER, nodeId, options);
    }


    
    copy()
    {
        const copy = new GGreater(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalConditionInputs(
            this.input0, 
            this.input1, 
            (a, b) => a > b, 
            parse);
        

        this.setUpdateValues(parse, 
        [
            ['', new NullValue()]
            //['value', this.value]
        ]);


        this.validate();

        return this;
    }
}


class GGreaterOrEqual
extends GOperator2
{
    constructor(nodeId, options)
    {
        super(NUMBER_GREATER_OR_EQUAL, nodeId, options);
    }


    
    copy()
    {
        const copy = new GGreaterOrEqual(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalConditionInputs(
            this.input0, 
            this.input1, 
            (a, b) => a >= b, 
            parse);
            

        this.setUpdateValues(parse, 
        [
            ['', new NullValue()]
            //['value', this.value]
        ]);


        this.validate();

        return this;
    }
}



class GTrig
extends GOperator1
{
    function;



    constructor(nodeId, options)
    {
        super(NUMBER_TRIG, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.function = null;
    }



    copy()
    {
        const copy = new GTrig(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.function) copy.function = this.function.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input = await evalNumberOrListValue(this.input,    parse);
        const func  = await evalNumberValue      (this.function, parse);

        func.value = Math.min(Math.max(0, func.value), TRIG_OPS.length-1);

        
        if (input)
        {
            if (isListValueType(input.type))
            {
                this.value = new ListValue();

                for (let i = 0; i < input.items.length; i++)
                {
                    const item = input.items[i];

                    this.value.items.push(
                        item.type == NUMBER_VALUE
                        ? await getTrigValue(item, func, this.options.enabled)
                        : NumberValue.NaN.copy());   
                }
            }
            else
                this.value = await getTrigValue(input, func, this.options.enabled);
}
        else
            this.value = NumberValue.NaN.copy();


        this.setUpdateValues(parse,
        [
            ['type',     this.outputType()],
            ['function', func             ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.function && this.function.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.function) this.function.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.function) this.function.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.function) this.function.iterateLoop(parse);
    }
}



async function getTrigValue(input, func, enabled)
{
    consoleAssert(
        input.type == NUMBER_VALUE, 
       'input.type must be NUMBER_VALUE');


    if (!enabled)
        return input;


    switch (func.value)
    {
        case TRIG_SIN:  return await evalSine   (input, false);
        case TRIG_COS:  return await evalCosine (input, false);
        case TRIG_TAN:  return await evalTangent(input, false);
        case TRIG_ASIN: return await evalSine   (input, true );
        case TRIG_ACOS: return await evalCosine (input, true );
        case TRIG_ATAN: return await evalTangent(input, true );
    }
}


class GSine
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(NUMBER_SIN, nodeId, options);
    }


    
    copy()
    {
        const copy = new GSine(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) copy.input = this.input.copy();
        
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalSine(this.input, parse);


        this.setUpdateValues(parse, 
        [
            ['', new NullValue()]
            //['value', this.value]
        ]);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value.copy();
    }
}



async function evalSine(input, arc)
{
    if (!input)
        return NumberValue.NaN.copy();

    const val = 
        !arc 
        ? Math.sin (input.value) 
        : Math.asin(input.value);

    return new NumberValue(val, decDigits(val));
}


class GCosine
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(NUMBER_COS, nodeId, options);
    }


    
    copy()
    {
        const copy = new GCosine(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) copy.input = this.input.copy();
        
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalCosine(this.input, parse);


        this.setUpdateValues(parse, 
        [
            ['', new NullValue()]
            //['value', this.value]
        ]);


        this.validate();

        return this;
    }
}



async function evalCosine(input, arc)
{
    if (!input)
        return NumberValue.NaN.copy();

    const val = 
        !arc 
        ? Math.cos (input.value) 
        : Math.acos(input.value);

   return new NumberValue(val, decDigits(val));
}


class GTangent
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(NUMBER_TAN, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTangent(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) copy.input = this.input.copy();
        
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalTangent(this.input, parse);


        this.setUpdateValues(parse, 
        [
            ['', new NullValue()]
            //['value', this.value]
        ]);


        this.validate();

        return this;
    }
}



async function evalTangent(input, arc)
{
    if (!input)
        return NumberValue.NaN.copy();

    const val = 
        !arc 
        ? Math.tan (input.value) 
        : Math.atan(input.value);
    
    return new NumberValue(val, decDigits(val));
}


class GAtan2
extends GOperator
{
    x;
    y;


    
    constructor(nodeId, options)
    {
        super(NUMBER_ATAN2, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.x = null;
        this.y = null;
    }



    copy()
    {
        const copy = new GAtan2(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.x) copy.x = this.x.copy();
        if (this.y) copy.y = this.y.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const x = await evalNumberValue(this.x, parse);
        const y = await evalNumberValue(this.y, parse);


        this.value = new NumberValue(Math.atan2(y.value, x.value));


        this.setUpdateValues(parse,
        [
            //['value', this.value],
            ['x',     x         ],
            ['y',     y         ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.x && this.x.isValid()
            && this.y && this.y.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.x) this.x.pushValueUpdates(parse);
        if (this.y) this.y.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.x) this.x.invalidateInputs(parse, from, force);
        if (this.y) this.y.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.x) this.x.iterateLoop(parse);
        if (this.y) this.y.iterateLoop(parse);
    }
}



class GConvertAngle
extends GOperator1
{
    from;



    constructor(nodeId, options)
    {
        super(CONVERT_ANGLE, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.from = null;
    }



    copy()
    {
        const copy = new GConvertAngle(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.from) copy.from = this.from.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = new NumberValue(0);

        
        const input = await evalNumberOrListValue(this.input, parse);
        const from  = await evalNumberValue      (this.from,  parse);


        if (input)
        {
            if (isListValueType(input.type))
            {
                this.value = new ListValue();

                for (let i = 0; i < input.items.length; i++)
                {
                    const item = input.items[i];

                    this.value.items.push(
                        item.type == NUMBER_VALUE
                        ? getConvertAngleValue(item, from, this.options.enabled)
                        : NumberValue.NaN.copy());   
                }
            }
            else
                this.value = getConvertAngleValue(input, from, this.options.enabled);
        }
        else
            this.value = NumberValue.NaN.copy();


        this.setUpdateValues(parse,
        [
            ['type',  this.outputType()],
            //['value', this.value       ],
            ['from',  from             ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.from && this.from.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.from) this.from.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.from) this.from.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.from) this.from.iterateLoop(parse);
    }
}



function getConvertAngleValue(input, from, enabled)
{
    consoleAssert(
         input == NUMBER_VALUE, 
        'input must be NUMBER_VALUE');
        

    const value = input;
    
    if (enabled)
    {
        switch (from.value)
        {
            case 0: value.value = value.value/360 * Tau; break;
            case 1: value.value = value.value/Tau * 360; break;
        }

        value.decimals = decDigits(value.value);
    }


    return value;
}


class GText
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(TEXT, nodeId, options);
    }



    copy()
    {
        const copy = new GText(this.nodeId, this.options);
        
        copy.copyBase(this);

        copy.value = this.value;
        
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        if (this.input)
            this.value = await evalTextValue(this.input, parse);
        else if (this.value)
            await this.value.eval(parse);
        else
            this.value = new TextValue();


        this.setUpdateValues(parse,
        [
            ['value', this.value]
        ]);

        
        this.validate();

        return this;
    }



    isValid()
    {
        return   !this.input
               && this.value != NAN_CHAR 
            || this.input.isValid();
    }
}


class GTextLength
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(TEXT_LENGTH, nodeId, options);
    }


    
    reset()
    {
        super.reset();
    }



    copy()
    {
        const copy = new GTextLength(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input = await evalTextOrListValue(this.input, parse);

        if (   input
            && input.isValid())
        {
            if (isListValueType(input.type))
            {
                this.value = new ListValue();

                for (let i = 0; i < input.items.length; i++)
                {
                    const item = input.items[i];

                    this.value.items.push(
                        item.type == TEXT_VALUE
                        ? new NumberValue(item.value.length)
                        : NumberValue.NaN.copy());
                }
            }
            else
                this.value = new NumberValue(input.value.length);
        }
        else
            this.value = NumberValue.NaN.copy();
    

        this.setUpdateValues(parse,
        [
            ['type', this.outputType()]
        ]);


        this.validate();

        return this;
    }
}



class GTextTrim
extends GOperator1
{
    start = null;
    end   = null;


    
    constructor(nodeId, options)
    {
        super(TEXT_TRIM, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.start = null;
        this.end   = null;
    }



    copy()
    {
        const copy = new GTextTrim(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.start) copy.start = this.start.copy();
        if (this.end  ) copy.end   = this.end  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const start = await evalTextValue(this.start, parse);
        const end   = await evalTextValue(this.end,   parse);


        if (this.input)
        {
            const input = await evalTextOrListValue(this.input, parse);
            
            if (isListValueType(input.type))
            {
                this.value = new ListValue();

                for (let i = 0; i < input.items.length; i++)
                {
                    const item = input.items[i];

                    this.value.items.push(
                        item.type == TEXT_VALUE
                        ? getTrimValue(item, start, end, this.options.enabled)
                        : new TextValue());   
                }
            }
            else
            {
                this.value = getTrimValue(input, start, end, this.options.enabled);
            }
        }
        else
            this.value = new TextValue();


        this.setUpdateValues(parse,
        [
            ['type',  this.outputType()],
            ['start', start            ],
            ['end',   end              ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.start && this.start.isValid()
            && this.end   && this.end  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.start) this.start.pushValueUpdates(parse);
        if (this.end  ) this.end  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.start) this.start.invalidateInputs(parse, from, force);
        if (this.end  ) this.end  .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.start) this.start.iterateLoop(parse);
        if (this.end  ) this.end  .iterateLoop(parse);
    }
}



function getTrimValue(input, start, end, enabled)
{
    consoleAssert(input.type == TEXT_VALUE, 'input.type must be TEXT_VALUE');
               
    const value = input.copy();

    if (enabled)
    {
        if (start.value.length > 0) value.value = trimCharFromStart(value.value, unescapeString(start.value));
        if (end  .value.length > 0) value.value = trimCharFromEnd  (value.value, unescapeString(end  .value));
    }

    return value;
}


class GTextSubstring
extends GOperator1
{
    start = null;
    end   = null;


    
    constructor(nodeId, options)
    {
        super(TEXT_SUBSTRING, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.start = null;
        this.end   = null;
    }



    copy()
    {
        const copy = new GTextSubstring(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.start) copy.start = this.start.copy();
        if (this.end  ) copy.end   = this.end  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input = await evalTextOrListValue(this.input, parse);
        const start = await evalNumberValue    (this.start, parse);
        const end   = await evalNumberValue    (this.end,   parse);


        let length     = 0;
        let fullLength = 0;


        if (   input
            && start
            && end)
        {
            if (isListValueType(input.type))
            {
                this.value = new ListValue();

                for (let i = 0; i < input.items.length; i++)
                {
                    const item = input.items[i];

                    const sub =
                        item.type == TEXT_VALUE
                        ? getSubstringValue(item, start, end, this.options.enabled)
                        : new TextValue();

                    length     = Math.max(length,     sub.value.length);
                    fullLength = Math.max(fullLength, sub.value.length);

                    this.value.items.push(sub);
                }

            }
            else
            {
                this.value = getSubstringValue(input, start, end, this.options.enabled);
                
                length     = this .value.length;
                fullLength = input.value.length;
            }
        }
        else
            this.value = new TextValue();


        this.setUpdateValues(parse,
        [
            ['type',       this.outputType()          ],
            ['length',     new NumberValue(length)    ], // used to set start and end limits
            ['fullLength', new NumberValue(fullLength)], // used to set start and end maxima
            ['start',      start                      ],
            ['end',        end                        ]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.start && this.start.isValid()
            && this.end   && this.end  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.start) this.start.pushValueUpdates(parse);
        if (this.end  ) this.end  .pushValueUpdates(parse);
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.start) this.start.pushValueUpdates(parse);
        if (this.end  ) this.end  .pushValueUpdates(parse);
    }



    iterateLoop(parse, from)
    {
        super.iterateLoop(parse, from);

        if (this.start) this.start.iterateLoop(parse, from);
        if (this.end  ) this.end  .iterateLoop(parse, from);
    }
}



function getSubstringValue(input, start, end, enabled)
{
    let value = new TextValue();


    const _end =
        end.isValid()
        ? end
        : new NumberValue(input.value.length);


    if (enabled)
    {
        const endValue = 
            _end.value < 0
            ? input.value.length + _end.value
            : _end.value;

        if (start.value <= endValue)
            value.value = input.value.substring(start.value, endValue);
        else
            value = new TextValue();
    }
    else
        value = input.copy();

    
    return value;
}


class GTextContains
extends GOperator2
{
    first;
    last;
    all;



    constructor(nodeId, options)
    {
        super(TEXT_CONTAINS, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.first = null;
        this.last  = null;
        this.all   = null;
    }



    copy()
    {
        const copy = new GTextContains(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.first = null) copy.first = this.first.copy();
        if (this.last  = null) copy.last  = this.last .copy();
        if (this.all   = null) copy.all   = this.all  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input0 = await evalTextValue(this.input0, parse);
        const input1 = await evalTextValue(this.input1, parse);
    

        if (   input0 && input0.isValid() 
            && input1 && input1.isValid())
        {
            if (isListValueType(input0.type))
            {
                this.value = new ListValue();

                for (let i = 0; i < input0.items.length; i++)
                {
                    const item = input0.items[i];

                    this.value.items.push(
                        item.type == TEXT_VALUE
                        ? new NumberValue(item.value.includes(input1.value) ? 1 : 0, 0, true)
                        : NumberValue.NaN.copy());
                }
            }
            else
            {
                this.value = new NumberValue(input0.value.includes(input1.value) ? 1 : 0, 0, true);
            }
        }
        else                  
        {
            this.value = NumberValue.NaN.copy();
        }
    

        this.setUpdateValues(parse,
        [
            ['type', this.outputType()]
        ]);


        this.validate();

        return this;
    }
}


class GTextFind
extends GOperator2
{
    first;
    last;
    all;



    constructor(nodeId, options)
    {
        super(TEXT_FIND, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.first = null;
        this.last  = null;
        this.all   = null;
    }



    copy()
    {
        const copy = new GTextFind(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input0 = await evalTextValue(this.input0, parse);
        const input1 = await evalTextValue(this.input1, parse);
    

        if (   input0 && input0.isValid() 
            && input1 && input1.isValid())
        {
            const indices = [];
            let   index   = 0;

            if (input1.value != '')
            {
                while (index != -1) 
                {
                    index = input0.value.indexOf(input1.value, index);

                    if (index != -1) 
                    {
                        indices.push(index);
                        index += 1;
                    }
                }

                
                this.value = new NumberValue(indices.length > 0 ? 1 : 0);

                this.first = indices.length > 0 ? new NumberValue(indices.at( 0)) : NumberValue.NaN.copy();
                this.last  = indices.length > 0 ? new NumberValue(indices.at(-1)) : NumberValue.NaN.copy();

                this.all   = new ListValue();

                for (const index of indices)
                    this.all.items.push(new NumberValue(index));
            }
            else
            {
                this.value = new NumberValue(1);

                this.first = NumberValue.NaN.copy();
                this.last  = NumberValue.NaN.copy();
                this.all   =   ListValue.NaN.copy();
            }
        }
        else                  
        {
            this.value = NumberValue.NaN.copy();
            this.first = NumberValue.NaN.copy();
            this.last  = NumberValue.NaN.copy();
            this.all   =   ListValue.NaN.copy();
        }
    

        this.setUpdateValues(parse,
        [
            ['value', this.value],
            ['first', this.first],
            ['last',  this.last ],
            ['all',   this.all  ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.first && this.first.isValid()
            && this.last  && this.last .isValid()
            && this.all   && this.all  .isValid();
    }
}



class GTextCase
extends GOperator1
{
    case;


    
    constructor(nodeId, options)
    {
        super(TEXT_CASE, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.case = null;
    }



    copy()
    {
        const copy = new GTextCase(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.case) copy.case = this.case.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input = await evalTextOrListValue(this.input, parse);
        const _case = await evalNumberValue    (this.case,  parse);


        if (input)
        {
            if (this.options.enabled)
            {
                if (isListValueType(input.type))
                {
                    this.value = new ListValue();

                    for (let i = 0; i < input.items.length; i++)
                    {
                        const item = input.items[i];

                        this.value.items.push(
                            item.type == TEXT_VALUE
                            ? getTextCaseValue(item, _case)
                            : new TextValue());   
                    }
                }
                else
                {
                    this.value = getTextCaseValue(input, _case);
                }
            }
            else
                this.value = input.copy();
        }
        else
            this.value = new TextValue();


        this.setUpdateValues(parse,
        [
            //['value', this.value        ],
            ['type',   this.outputType()],
            ['case',  _case             ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.case && this.case.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.case) this.case.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.case) this.case.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.case) this.case.iterateLoop(parse);
    }
}



function getTextCaseValue(input, _case)
{
    consoleAssert(input.type == TEXT_VALUE, 'input.type must be TEXT_VALUE');

    const val   = input.value;
    const value = new TextValue();
    

    if (_case.value == 0) 
         value.value = val.toLowerCase();

    else if (_case.value == 1)
    {
        if (val.length > 0) value.value += val.substring(0, 1).toUpperCase();
        if (val.length > 1) value.value += val.substring(1)   .toLowerCase();
    }

    else if (_case.value == 2)
    {
        let i = 0;
        while (i < val.length)
        {
            while (i < val.length
                && /\s/.test(val.charAt(i)))
                value.value += val.charAt(i++);

            if (i < val.length)
                value.value += val.charAt(i++).toUpperCase();

            while (i < val.length
                && !/\s/.test(val.charAt(i)))
                value.value += val.charAt(i++).toLowerCase();
        }
    }

    else if (_case.value == 3) 
        value.value = val.toUpperCase();


    return value;
}


class GNumberToText
extends GOperator1
{
    base;
    decimals;
    thousands;


    
    constructor(nodeId, options)
    {
        super(NUMBER_TO_TEXT, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.base      = null;
        this.decimals  = null;
        this.thousands = null;
    }



    copy()
    {
        const copy = new GNumberToText(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.base     ) copy.base      = this.base     .copy();
        if (this.decimals ) copy.decimals  = this.decimals .copy();
        if (this.thousands) copy.thousands = this.thousands.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input     = await evalNumberValue(this.input,     parse);
        const base      = await evalNumberValue(this.base,      parse);
        const decimals  = await evalNumberValue(this.decimals,  parse);
        const thousands = await evalNumberValue(this.thousands, parse);


        if (input)
        {
            if (isListValueType(input.type))
            {
                this.value = new ListValue();

                for (let i = 0; i < input.items.length; i++)
                {
                    const item = input.items[i];

                    this.value.items.push(
                        item.type == NUMBER_VALUE
                        ? getNumberToTextValue(item, base, decimals, thousands)
                        : TextValue.NaN.copy());   
                }
            }
            else
            {
                this.value = getNumberToTextValue(input, base, decimals, thousands);
            }
        }
        else
            this.value = TextValue.NaN.copy();


        this.setUpdateValues(parse,
        [
            //['value',     this.value       ],
            ['type',      this.outputType()],
            ['base',      base             ],
            ['decimals',  decimals         ],
            ['thousands', thousands        ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.base      && this.base     .isValid()
            && this.decimals  && this.decimals .isValid()
            && this.thousands && this.thousands.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.base     ) this.base     .pushValueUpdates(parse);
        if (this.decimals ) this.decimals .pushValueUpdates(parse);
        if (this.thousands) this.thousands.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.base     ) this.base     .invalidateInputs(parse, from, force);
        if (this.decimals ) this.decimals .invalidateInputs(parse, from, force);
        if (this.thousands) this.thousands.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.base     ) this.base     .iterateLoop(parse);
        if (this.decimals ) this.decimals .iterateLoop(parse);
        if (this.thousands) this.thousands.iterateLoop(parse);
    }
}



function getNumberToTextValue(input, base, decimals, thousands)
{
    return input.isValid()
         ? new TextValue(numToString(
               input.value, 
              -input.decimals, 
               base.value == 1, 
               decimals.value, 
               thousands.value))
         : new TextValue('?');
}


class GColorToText
extends GOperator1
{
    format;


    
    constructor(nodeId, options)
    {
        super(COLOR_TO_TEXT, nodeId, options);
    }


    reset()
    {
        super.reset();

        this.format = null;
    }



   
    copy()
    {
        const copy = new GColorToText(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.format) copy.format = this.format.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input  = await evalColorValue (this.input,  parse);
        const format = await evalNumberValue(this.format, parse);


        if (input)
        {
            if (isListValueType(input.type))
            {
                this.value = new ListValue();

                for (let i = 0; i < input.items.length; i++)
                {
                    const item = input.items[i];

                    this.value.items.push(
                        item.type == NUMBER_VALUE
                        ? getColorToTextValue(item, format)
                        : TextValue.NaN.copy());   
                }
            }
            else
            {
                this.value = getColorToTextValue(input, format);
            }
        }

        else
            this.value = TextValue.NaN.copy();


        this.setUpdateValues(parse,
        [
            ['type',   this.outputType()],
            ['format', format           ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.format && this.format.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.format) this.format.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.format) this.format.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.format) this.format.iterateLoop(parse);
    }
}



function getColorToTextValue(input, format)
{
    let str = NAN_CHAR;

    const rgb = input.toRgb();

    switch (format.value)
    {
        case 0: // hex
            str = rgb2hex(rgb);
            break;

        case 1: // rgb 1.0
            str = 
                  numToString(rgb[0], -3) + ', '
                + numToString(rgb[1], -3) + ', '
                + numToString(rgb[2], -3);
            break;

        case 2: // rgb 255
            str = 
                  Math.round(rgb[0] * 255) + ', '
                + Math.round(rgb[1] * 255) + ', '
                + Math.round(rgb[2] * 255);
            break;

        case 3: // name
            str = createColorName(rgb);
            break;
    }

    return new TextValue(str);
}


class GTextToNumber
extends GOperator1
{
    base      = null;
    decimals  = null;
    thousands = null;


    
    constructor(nodeId, options)
    {
        super(TEXT_TO_NUMBER, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.base      = null;
        this.decimals  = null;
        this.thousands = null;
    }



    copy()
    {
        const copy = new GTextToNumber(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.base     ) copy.base      = this.base     .copy();
        if (this.decimals ) copy.decimals  = this.decimals .copy();
        if (this.thousands) copy.thousands = this.thousands.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input     = await evalTextOrListValue(this.input,     parse);
        const base      = await evalNumberValue    (this.base,      parse);
        const decimals  = await evalNumberValue    (this.decimals,  parse);
        const thousands = await evalTextValue      (this.thousands, parse);


        if (   input
            && input.isValid())
        {
            if (isListValueType(input.type))
            {
                this.value = new ListValue();

                for (let i = 0; i < input.items.length; i++)
                {
                    const item = input.items[i];

                    this.value.items.push(
                        item.type == TEXT_VALUE
                        ? getTextToNumberValue(item, base, decimals, thousands)
                        : NumberValue.NaN.copy());   
                }
            }
            else
                this.value = getTextToNumberValue(input, base, decimals, thousands);
        }

        else
            this.value = NumberValue.NaN.copy();


        this.setUpdateValues(parse,
        [
            ['type',      this.outputType()],
            ['base',      base             ],
            ['decimals',  decimals         ],
            ['thousands', thousands        ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.base      && this.base     .isValid()
            && this.decimals  && this.decimals .isValid()
            && this.thousands && this.thousands.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.base     ) this.base     .pushValueUpdates(parse);
        if (this.decimals ) this.decimals .pushValueUpdates(parse);
        if (this.thousands) this.thousands.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.base     ) this.base     .invalidateInputs(parse, from, force);
        if (this.decimals ) this.decimals .invalidateInputs(parse, from, force);
        if (this.thousands) this.thousands.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.base     ) this.base     .iterateLoop(parse);
        if (this.decimals ) this.decimals .iterateLoop(parse);
        if (this.thousands) this.thousands.iterateLoop(parse);
    }
}



function getTextToNumberValue(input, base, decimals, thousands)
{
    let num   = Number.NaN;
    let value = input.value;

    if (thousands)
        value = value.replaceAll(thousands.value, '');

    
    if (base)
    {
        switch (base.value)
        {
            case 0: // dec
            {
                if (value.lastIndexOf(decimals.value) < 0)
                    num = parseInt(value.replace(/[^\d-]/g, ''), 10);
                else
                {
                    value = replaceLast(value, decimals.value, '.');
                    num   = parseFloat(value);
                }
        
                break;
            }
            case 1: // hex
            {
                const decIndex = value.lastIndexOf(decimals.value);

                if (decIndex < -1)
                    num = parseInt(value, 16);
                else
                {
                    const whole = value.slice(0, decIndex);
                    const frac  = value.slice(decIndex + decimals.value.length);

                    num = 
                          parseInt(whole, 16)
                        + frac.split('')
                            .reduce((sum, digit, index) => sum + parseInt(digit, 16) / Math.pow(16, index + 1), 0);
                }

                break;
            }
        }
    }


    return new NumberValue(num, decDigits(num));
}


class GTextToColor
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(TEXT_TO_COLOR, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextToColor(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        if (this.input)
        {
            const input = await evalTextValue(this.input, parse);

            if (isListValueType(input.type))
            {
                this.value = new ListValue();

                for (let i = 0; i < input.items.length; i++)
                {
                    const item = input.items[i];

                    this.value.items.push(
                        item.type == TEXT_VALUE
                        ? getTextToColorValue(item)
                        : NumberValue.NaN.copy());   
                }
            }
            else
            {
                this.value = getTextToColorValue(input);
            }
        }
        else
            this.value = ColorValue.NaN.copy();


        this.setUpdateValues(parse,
        [
            ['value', this.value       ],
            ['type',  this.outputType()]
        ]);


        this.validate();

        return this;
    }
}



function getTextToColorValue(input)
{
    const str = input.value.trim();


    let rgb; 


    if (settings.preferHtmlColorNames)
    {
                   let webColor = htmlColors.find(wc => wc.name.toLowerCase() == str);
        if (!webColor) webColor = htmlColors.find(wc => getEditDistance(wc.name.toLowerCase(), str) <= 1);
        
        if (webColor) 
            rgb = validHex2rgb(webColor.color);
    }
    else
    {
        const hsl = parseColorName(str);

        rgb = 
            hsl 
            ? hsl2rgb(hsl) 
            : validHex2rgb(str);
    }

    
    return ColorValue.fromRgb(scaleRgb(rgb));
}


class GCodeToCharacter
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(TEXT_CHAR, nodeId, options);
    }


    
    copy()
    {
        const copy = new GCodeToCharacter(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input = await evalNumberValue(this.input, parse);


        if (input)
        {
            if (isListValueType(input.type))
            {
                this.value = new ListValue();

                for (let i = 0; i < input.items.length; i++)
                {
                    const item = input.items[i];

                    this.value.items.push(
                        item.type == NUMBER_VALUE
                        ? getCodeToCharacterValue(item)
                        : TextValue.NaN.copy());   
                }
            }
            else
            {
                this.value = getCodeToCharacterValue(input);
            }
        }
        else
            this.value = TextValue.NaN.copy();


        this.setUpdateValues(parse,
        [
            //['value', this.value       ],
            ['type',  this.outputType()]
        ]);


        this.validate();

        return this;
    }
}



function getCodeToCharacterValue(input)
{
    return new TextValue(String.fromCharCode(Math.min(Math.max(0, input.value), 0xffff)));
}


class GCharacterToCode
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(TEXT_UNICODE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GCharacterToCode(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input = await evalTextValue(this.input, parse);


        if (input)
        {
            if (isListValueType(input.type))
            {
                this.value = new ListValue();

                for (let i = 0; i < input.items.length; i++)
                {
                    const item = input.items[i];

                    this.value.items.push(
                        item.type == TEXT_VALUE
                        ? getCharacterToCodeValue(item)
                        : NumberValue.NaN.copy());   
                }
            }
            else
            {
                this.value = getCharacterToCodeValue(input);
            }
        }
        else
            this.value = NumberValue.NaN.copy();


        this.setUpdateValues(parse,
        [
            //['value', this.value       ],
            ['type',  this.outputType()]
        ]);


        this.validate();

        return this;
    }
}



function getCharacterToCodeValue(input)
{
    return input.value.length > 0
         ? new NumberValue(input.value.charCodeAt(0))
         : NumberValue.NaN.copy();
}


class GIndexToName
extends GOperator
{
    name;
    index;


    
    constructor(nodeId, options)
    {
        super(INDEX_TO_NAME, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.index = null;
    }



    copy()
    {
        const copy = new GIndexToName(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.name ) copy.name  = this.name .copy();
        if (this.index) copy.index = this.index.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const name  = await evalTextValue  (this.name,  parse);
        const index = await evalNumberValue(this.index, parse);


        switch (name.value)
        {
            case 0: this.value = new TextValue(
                [
                    'monday', 
                    'tuesday', 
                    'wednesday', 
                    'thursday', 
                    'friday', 
                    'saturday', 
                    'sunday'
                ] 
                [index.value-1]);

                break;

            case 1: this.value = new TextValue(
                [
                    'january', 
                    'february', 
                    'march', 
                    'april', 
                    'may', 
                    'june', 
                    'july',
                    'august',
                    'september',
                    'october',
                    'november',
                    'december'
                ] 
                [index.value-1]);

                break;

            case 2:
                this.value = new TextValue(figUniqueFontNames[index.value]);
                break;

        }


        this.setUpdateValues(parse,
        [
            //['value', this.value],
            ['name',  name      ],
            ['index', index     ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.index && this.index.isValid()
            && this.name  && this.name .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.index) this.index.pushValueUpdates(parse);
        if (this.name ) this.name .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.index) this.index.invalidateInputs(parse, from, force);
        if (this.name ) this.name .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.index) this.index.iterateLoop(parse);
        if (this.name ) this.name .iterateLoop(parse);
    }
}



class GTextReplace
extends GOperator1
{
    what  = null;
    with  = null;
    regex = null;



    constructor(nodeId, options)
    {
        super(TEXT_REPLACE, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.what  = null;
        this.with  = null;
        this.regex = null;
    }



    copy()
    {
        const copy = new GTextReplace(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.what ) copy.what  = this.what .copy();
        if (this.with ) copy.with  = this.with .copy();
        if (this.regex) copy.regex = this.regex.copy();

        if (this.value) copy.value = this.value.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const  input = await evalTextOrListValue(this.input, parse);
        const _what  = await evalTextValue      (this.what,  parse);
        const _with  = await evalTextValue      (this.with,  parse);
        const _regex = await evalNumberValue    (this.regex, parse);


        if (input)
        {
            if (this.options.enabled)
            {
                if (isListValueType(input.type))
                {
                    this.value = new ListValue();

                    for (let i = 0; i < input.items.length; i++)
                    {
                        const item = input.items[i];

                        this.value.items.push(
                            item.type == TEXT_VALUE
                            ? getReplaceValue(item, _what, _with, _regex)
                            : new TextValue());   
                    }
                }
                else
                {
                    this.value = getReplaceValue(input, _what, _with, _regex);
                }
            }
            else
                this.value = input.copy();
        }
        else
            this.value = new TextValue();


        this.setUpdateValues(parse,
        [
            //['value',  this.value       ],
            ['type',   this.outputType()],
            ['what',  _what             ],
            ['with',  _with             ],
            ['regex', _regex            ]
        ]);

        
        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.what  && this.what .isValid()
            && this.with  && this.with .isValid()
            && this.regex && this.regex.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.what ) this.what .pushValueUpdates(parse);
        if (this.with ) this.with .pushValueUpdates(parse);
        if (this.regex) this.regex.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.what ) this.what .invalidateInputs(parse, from, force);
        if (this.with ) this.with .invalidateInputs(parse, from, force);
        if (this.regex) this.regex.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.what ) this.what .iterateLoop(parse);
        if (this.with ) this.with .iterateLoop(parse);
        if (this.regex) this.regex.iterateLoop(parse);
    }
}



function getReplaceValue(input, _what, _with, _regex)
{
    consoleAssert(input.type == TEXT_VALUE, 'input.type must be TEXT_VALUE');

    const value = new TextValue();

    
    if (_regex.value > 0)
    {
        try
        {
            value.value = input.value.replace(
                new RegExp(unescapeRegexPattern(_what.value), 'gu'),
                unescapeRegexReplacement(_with.value));
        }
        catch (e)
        {
            uiNotify(e.message, {error: true});
        }
    }
    else if (input.value)
    {
        value.value = input.value.replaceAll(
            unescapeString(_what.value),
            unescapeString(_with.value));
    }


    return value;
}


class GTextJoin
extends GOperator
{
    inputs = [];

    with = null;


    
    constructor(nodeId, options)
    {
        super(TEXT_JOIN, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.inputs = [];
        
        this.with = null;
    }


   
    copy()
    {
        const copy = new GTextJoin(this.nodeId, this.options);
        copy.copyBase(this);
        
        copy.inputs = this.inputs.map(i => i.copy());
        copy.with   = this.with;

        return copy;
    }



    isCached()
    {
        for (const input of this.inputs)
            if (!input.isCached())
                return false;

        return super.isCached();
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const inputs = await Promise.all(this.inputs.map(async i => await evalTextOrListValue(i, parse)));
        const _with  = await evalTextValue(this.with, parse);


        this.value = await evalJoinInputs(inputs, _with, parse);

        
        this.setUpdateValues(parse,
        [
            ['type', this.outputType()],
            ['with',  _with           ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return !this.inputs.find(i => !i.isValid())
            && this.with && this.with.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse));

        if (this.with) this.with.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        this.inputs.forEach(i => i.invalidateInputs(parse, from, force));

        if (this.with) this.with.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        this.inputs.forEach(i => i.iterateLoop(parse));

        if (this.with) this.with.iterateLoop(parse);
    }
}



async function evalJoinInputs(inputs, _with, parse)
{
    if (isEmpty(inputs))
        return new TextValue();


    const allAreLists = allInputsAreCondensedLists(inputs);
    const w           = unescapeString(_with.value);

    if (allAreLists) return await evalJoinListInputs(inputs, w, parse);
    else             return await evalJoinItemInputs(inputs, w, parse);
}



async function evalJoinListInputs(inputs, _with, parse)
{
    const value = new ListValue();

    
    for (const input of inputs)
    {
        if (!input) continue;

        console.assert(
             isListValueType(input.type), 
            `input is ${input.type}, must be a list`);

        if (allInputsAreCondensedLists(input.items))
            value.items.push(...(await evalJoinListInputs(input.items, _with, parse)).items);
        else
            value.items.push(await evalJoinItemInputs(input.items, _with, parse));
    }


    return value;
}



async function evalJoinItemInputs(inputs, _with, parse)
{
    const value = new TextValue();

        
    for (let i = 0; i < inputs.length; i++)
    {
        const input = await evalTextOrListValue(inputs[i], parse);
        if (!input) continue;


        if (i > 0)
            value.value += _with;


        if (isListValueType(input.type))
        {
            for (let j = 0; j < input.items.length; j++)
            {
                if (j > 0)
                    value.value += _with;


                const item = input.items[j];

                if (item.type == TEXT_VALUE)
                    value.value += item.value;
            }
        }
        else
        {
            consoleAssert(input.type == TEXT_VALUE, 'val.type must be TEXT_VALUE');

            value.value += input.value;
        }
    }


    return value;
}


class GAddText
extends GOperator1
{
    text;
    prefix;



    constructor(nodeId, options)
    {
        super(TEXT_ADD, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.text   = null;
        this.prefix = null;
    }



    copy()
    {
        const copy = new GAddText(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.text  ) copy.text   = this.text  .copy();
        if (this.prefix) copy.prefix = this.prefix.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = new NumberValue(0);


        const input  = await evalTextOrListValue(this.input,  parse);
        const text   = await evalTextValue      (this.text,   parse);
        const prefix = await evalNumberValue    (this.prefix, parse);


        if (input)
        {
            if (this.options.enabled)
            {
                if (isListValueType(input.type))
                {
                    this.value = new ListValue();

                    for (let i = 0; i < input.items.length; i++)
                    {
                        const item = input.items[i];

                        this.value.items.push(evalAddText(item, text, prefix));
                    }
                }
                else
                {
                    this.value.items.push(evalAddText(input, text, prefix));
                }
            }
            else
                this.value = input.copy();
        }
        else
            this.value = new TextValue();


        this.setUpdateValues(parse,
        [
            ['type',   this.outputType()],
            ['text',   text             ],
            ['prefix', prefix           ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.text   && this.text  .isValid()
            && this.prefix && this.prefix.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.text  ) this.text  .pushValueUpdates(parse);
        if (this.prefix) this.prefix.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.text  ) this.text  .invalidateInputs(parse, from, force);
        if (this.prefix) this.prefix.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.text  ) this.text  .iterateLoop(parse);
        if (this.prefix) this.prefix.iterateLoop(parse);
    }
}



function evalAddText(input, text, prefix)
{
    return new TextValue(
        prefix.value > 0
        ? text .value + input.value
        : input.value + text .value);
}


class GTextPad
extends GOperator1
{
    startPad   = null;
    startCount = null;
    endPad     = null;
    endCount   = null;
    
    
    
    constructor(nodeId, options)
    {
        super(TEXT_PAD, nodeId, options);
    }


    
    reset()
    {
        super.reset();
        
        this.startPad   = null;
        this.startCount = null;
        this.endPad     = null;
        this.endCount   = null;
    }



    copy()
    {
        const copy = new GTextPad(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.startPad  ) copy.startPad   = this.startPad  .copy();
        if (this.startCount) copy.startCount = this.startCount.copy();
        if (this.endPad    ) copy.endPad     = this.endPad    .copy();
        if (this.endCount  ) copy.endCount   = this.endCount  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const startPad   = await evalTextValue  (this.startPad,   parse);
        const startCount = await evalNumberValue(this.startCount, parse);
        const endPad     = await evalTextValue  (this.endPad,     parse);
        const endCount   = await evalNumberValue(this.endCount,   parse);


        if (this.input)
        {
            const input = await evalTextOrListValue(this.input, parse);
            console.log('input =', input);
            
            if (isListValueType(input.type))
            {
                this.value = new ListValue();

                for (let i = 0; i < input.items.length; i++)
                {
                    const item = input.items[i];

                    this.value.items.push(
                        item.type == TEXT_VALUE
                        ? getPadValue(
                            item, 
                            startPad, 
                            startCount, 
                            endPad, 
                            endCount, 
                            this.options.enabled)
                        : new TextValue());   
                }
            }
            else
            {
                this.value = getPadValue(
                    input, 
                    startPad, 
                    startCount, 
                    endPad, 
                    endCount, 
                    this.options.enabled);
            }
        }
        else
            this.value = new TextValue();


        this.setUpdateValues(parse,
        [
            ['type',       this.outputType()],
            ['startPad',   startPad         ],
            ['startCount', startCount       ],
            ['endPad',     endPad           ],
            ['endCount',   endCount         ]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.startPad   && this.startPad  .isValid()
            && this.startCount && this.startCount.isValid()
            && this.endPad     && this.endPad    .isValid()
            && this.endCount   && this.endCount  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.startPad  ) this.startPad  .pushValueUpdates(parse);
        if (this.startCount) this.startCount.pushValueUpdates(parse);
        if (this.endPad    ) this.endPad    .pushValueUpdates(parse);
        if (this.endCount  ) this.endCount  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.startPad  ) this.startPad  .invalidateInputs(parse, from, force);
        if (this.startCount) this.startCount.invalidateInputs(parse, from, force);
        if (this.endPad    ) this.endPad    .invalidateInputs(parse, from, force);
        if (this.endCount  ) this.endCount  .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.startPad  ) this.startPad  .iterateLoop(parse);
        if (this.startCount) this.startCount.iterateLoop(parse);
        if (this.endPad    ) this.endPad    .iterateLoop(parse);
        if (this.endCount  ) this.endCount  .iterateLoop(parse);
    }
}



function getPadValue(input, startPad, startCount, endPad, endCount, enabled)
{
    consoleAssert(input.type == TEXT_VALUE, 'input.type must be TEXT_VALUE');

    const value = input.copy();
    
    if (enabled)
        value.value = input.value
            .padStart(startCount.value, unescapeString(startPad.value))
            .padEnd  (  endCount.value, endPad.value != '' ? unescapeString(endPad.value) : unescapeString(startPad.value));

    return value;
}


class GTextSplit
extends GOperator1
{
    separator;



    constructor(nodeId, options)
    {
        super(TEXT_SPLIT, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.separator = null;
    }


   
    copy()
    {
        const copy = new GTextSplit(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.separator) copy.separator = this.separator.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input     = await evalTextOrListValue(this.input,     parse);
        const separator = await evalTextValue      (this.separator, parse);


        this.value = new ListValue();


        if (   input
            && separator)
        {
            if (isListValueType(input.type))
            {
                for (const item of input.items)
                {
                    const itemList = new ListValue(
                        item.value
                            .split(unescapeString(separator.value))
                            .map(s => new TextValue(s)));

                    this.value.items.push(itemList);
                }
            }
            else
            {
                consoleAssert(input.type == TEXT_VALUE, 'input must be TEXT_VALUE');

                this.value.items = input.value
                    .split(unescapeString(separator.value))
                    .map(s => new TextValue(s));
            }
        }


        this.setUpdateValues(parse,
        [
            ['type',      this.outputType()],
            ['separator', separator        ]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.separator && this.separator.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.separator) this.separator.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.separator) this.separator.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.separator) this.separator.iterateLoop(parse);
    }
}



class GTextCompare
extends GOperator2
{
    operation;



    constructor(nodeId, options)
    {
        super(TEXT_COMPARE, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.operation = null;
    }



    copy()
    {
        const copy = new GTextCompare(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.operation) copy.operation = this.operation.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input0 = await evalTextOrListValue(this.input0,    parse);
        const input1 = await evalTextValue      (this.input1,    parse);

        const op     = await evalNumberValue    (this.operation, parse);

        
        if (   input0
            && input1
            && op)
        {
            op.value = Math.min(Math.max(0, op.value), CONDITION_OPS.length-1);

            if (isListValueType(input0.type))
            {
                this.value = new ListValue();

                for (const item of input0.items)
                {
                    this.value.items.push(
                        item.type == TEXT_VALUE
                        ? await evalCompareTextInputs(item, input1, op, parse)
                        : NumberValue.NaN.copy());
                }
            }
            else
            {
                this.value = await evalCompareTextInputs(input0, input1, op, parse);
            }
        }
        else
            this.value = NumberValue.NaN.copy();


        this.setUpdateValues(parse,
        [
            ['type',      this.outputType()],
            ['operation', op               ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.operation && this.operation.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.operation) this.operation.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.operation) this.operation.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.operation) this.operation.iterateLoop(parse);
    }
}



async function evalCompareTextInputs(input0, input1, op, parse) 
{
    let opFunc = null;

    switch (op.value)
    {
        case CONDITION_LESS:              opFunc = (a, b) => a <  b;  break;
        case CONDITION_LESS_OR_EQUAL:     opFunc = (a, b) => a <= b;  break;
        case CONDITION_NOT_EQUAL:         opFunc = (a, b) => a != b;  break;
        case CONDITION_EQUAL:             opFunc = (a, b) => a == b;  break;
        case CONDITION_GREATER_OR_EQUAL:  opFunc = (a, b) => a >= b;  break;
        case CONDITION_GREATER:           opFunc = (a, b) => a >  b;  break;
    }


    if (   input0 && input0.isValid() 
        && input1 && input1.isValid())
        return new NumberValue(opFunc(input0.value, input1.value) ? 1 : 0, 0, true);
    else                  
        return new NullValue();
}


class GParseCSV
extends GOperator1
{
    rowSeparator;
    columnSeparator;



    constructor(nodeId, options)
    {
        super(PARSE_CSV, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.rowSeparator    = null;
        this.columnSeparator = null;
    }



    copy()
    {
        const copy = new GParseCSV(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.rowSeparator   ) copy.rowSeparator    = this.rowSeparator   .copy();
        if (this.columnSeparator) copy.columnSeparator = this.columnSeparator.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const rowSeparator    = await evalTextValue(this.rowSeparator,    parse);
        const columnSeparator = await evalTextValue(this.columnSeparator, parse);


        this.value = new ListValue();


        let maxColumns = 0;

        
        let nRows    = 0;
        let nColumns = 0;


        if (   this.input
            && rowSeparator
            && columnSeparator
            && rowSeparator.value != '')
        {
            const input = await evalTextValue(this.input, parse);
            

            const rows = 
                   input
                && input.value            
                ? input.value.split(unescapeString(rowSeparator.value))
                : [];


            for (const _row of rows)
            {
                const cells = 
                    _row
                    ? _row.split(unescapeString(columnSeparator.value))
                    : [];


                const row = new ListValue();

                for (const cell of cells)
                    row.items.push(new TextValue(cell));

                maxColumns = Math.max(maxColumns, row.items.length);


                this.value.items.push(row);
            }


            nRows    = this.value.items.length;
            nColumns = maxColumns;
        }
    

        this.setUpdateValues(parse,
        [
            ['rowSeparator',    rowSeparator             ],
            ['columnSeparator', columnSeparator          ],
            ['rows',            new NumberValue(nRows   )],
            ['columns',         new NumberValue(nColumns)]
        ]);
        

        if (parse.settings.showListTooltips)
        {
            this.setUpdateValues(parse,
            [
                ['preview', new ListValue(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]
            ],
            true);
        }


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.rowSeparator    && this.rowSeparator   .isValid()
            && this.columnSeparator && this.columnSeparator.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.rowSeparator   ) this.rowSeparator   .pushValueUpdates(parse);
        if (this.columnSeparator) this.columnSeparator.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.rowSeparator   ) this.rowSeparator   .invalidateInputs(parse, from, force);
        if (this.columnSeparator) this.columnSeparator.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.rowSeparator   ) this.rowSeparator   .iterateLoop(parse);
        if (this.columnSeparator) this.columnSeparator.iterateLoop(parse);
    }
}



class GParseJson
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(PARSE_JSON, nodeId, options);
    }


    
    copy()
    {
        const copy = new GParseJson(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = new ListValue();


        if (this.input)
        {
            const input = await evalTextValue(this.input, parse);
            
            try
            {
                const json = JSON.parse(input.value);
                this.value = this.evalItems(json);
            }
            catch (e)
            {
                this.value = new ListValue();
            }
        }
    

        this.setUpdateValues(parse,
        [
            ['length',  new NumberValue(this.value.items.length)]
            //['value',   this.value]
        ]);
        

        if (parse.settings.showTextTooltips)
        {
            this.setUpdateValues(parse,
            [
                ['preview', this.value]
            ],
            true);
        }


        this.validate();

        return this;
    }



    evalItems(json)
    {
        let list = new ListValue();


        for (const key in json)
        {
            if (   typeof json[key] === 'object'
                && json[key] !== null)
            {
                const obj = this.evalItems(json[key]);
                obj.valueId = key;
                list.items.push(obj);
            }
            else
            {
                let value;

                if (   typeof json[key] === 'number'
                    || isValidFloatString(json[key]))
                    value = NumberValue.fromString(json[key].toString());
                else if (typeof json[key] === 'boolean')
                    value = new NumberValue(parseBool(json[key].toString()) ? 1 : 0);
                else
                    value = new TextValue(json[key]);

                    
                value.valueId = 
                    key == 'value'
                    ? '(value)' // reserved param name in Generator
                    : key;

                list.items.push(value);
            }
        }

        
        return list;
    }
}



class GTextFetch
extends GOperator
{
    request;
    cachedValue;



    constructor(nodeId, options)
    {
        super(TEXT_FETCH, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.request     = null;
        this.cachedValue = null;
    }



    copy()
    {
        const copy = new GTextFetch(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.request    ) copy.request     = this.request    .copy();
        if (this.cachedValue) copy.cachedValue = this.cachedValue.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const request     = await evalTextValue(this.request,     parse);
        const cachedValue = await evalTextValue(this.cachedValue, parse);

        
        genInitNodeProgress(this.nodeId);


        if (cachedValue.value == '')
        {
            try 
            {
                const response = await fetch(request.value);
                const content  = await response.text();
                
                this.value = new TextValue(content);
            }
            catch (e)
            {
                this.value = 
                    request.value.trim() == NULL
                    ? new TextValue()
                    : new TextValue('invalid request');
            }
        }
        else
        {
            this.value = this.cachedValue.copy();
        }


        this.setUpdateValues(parse,
        [
            ['value',   this.value],
            ['request', request   ]
        ]);
        
        
        if (parse.settings.showTextTooltips)
        {
            this.setUpdateValues(parse,
            [
                ['preview', this.value]
            ],
            true);
        }


        this.validate();

        return this;
    }



    isValid()
    {
        return this.request && this.request.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.request) this.request.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.request) this.request.invalidateInputs(parse, from, force);

        this.cachedValue = new TextValue();
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.request) this.request.iterateLoop(parse);
    }
}


class GTextFile
extends GOperator
{
    //path;
    
    cachedValue = null;



    constructor(nodeId, options)
    {
        super(TEXT_FILE, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.cachedValue = null;
    }



    copy()
    {
        const copy = new GTextFile(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.cachedValue) copy.cachedValue = this.cachedValue.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const cachedValue = await evalTextValue(this.cachedValue, parse);
      //const path        = await evalTextValue(this.path,        parse);

        
        genInitNodeProgress(this.nodeId);


        this.value = cachedValue ?? new TextValue();


        this.setUpdateValues(parse,
        [
            ['', new NullValue()]
            //['path',    path      ]
        ]);
        
        
        if (parse.settings.showTextTooltips)
        {
            this.setUpdateValues(parse,
            [
                ['preview', this.value]
            ],
            true);
        }


        this.validate();

        return this;
    }



    isValid()
    {
        return false;//return this.path && this.path.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.path) this.path.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.path) this.path.invalidateInputs(parse, from, force);

        //this.cachedValue = new TextValue();
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.path) this.path.iterateLoop(parse);
    }
}


class ColorCorrection
{
    name; // 'H', 'C', or 'L'
    max;
    value;
    
    constructor(name = '', max = 0, value = 0)//, locked = false)
    {
        this.name  = name;
        this.max   = max;
        this.value = value;
    }
}



async function findCorrection(parse,
                              nodeId,
                              color,
                              order, _c1, _c2, _c3,
                              lockedOrder, locked1, locked2, locked3) 
{
    const refOklab = dataColor2array(dataColor2oklab(color));

    
    let closestColor = [...color],
        closestOklab = null, 
        closestOrder = order ? order.value : -1,
        closest1     = -1,
        closest2     = -1,
        closest3     = -1;


    let progress = 0,
        total    = 6 * Math.pow(2, Tau);

        
    let d = 1;
        
    parse.totalProgress += 1024;


    dLoop:
    while (d > 1/1024)
    {
        if (parse.stopGenerate)
            break dLoop;

        let _closestColor = [...closestColor];


        for (let _order = 0; _order < 6; _order++)
        {
            if (parse.stopGenerate)
                break dLoop;

            closestColor = [..._closestColor];

            const [min1, min2, min3] = getMinCorrections(color[0], _order);
            const [max1, max2, max3] = getMaxCorrections(color[0], _order);

            let start1 = lerp(min1, closest1, 1-d),  end1 = lerp(max1, closest1, 1-d),
                start2 = lerp(min2, closest2, 1-d),  end2 = lerp(max2, closest2, 1-d),
                start3 = lerp(min3, closest3, 1-d),  end3 = lerp(max3, closest3, 1-d);
               
            // console.log('min1 =', min1);
            // console.log('max1 =', max1);
            // console.log('closest1 =', closest1);
            // console.log('locked1 =', locked1);
            //console.log('start = %s, %s, %s', start1, start2, start3);
            //console.log('end = %s, %s, %s', end1, end2, end3);
            // console.log('_c1 =', _c1);
            
            if (locked1) { closest1 = _c1.toNumber(); start1 = closest1; end1 = closest1+Epsilon; }
            if (locked2) { closest2 = _c2.toNumber(); start2 = closest2; end2 = closest2+Epsilon; }
            if (locked3) { closest3 = _c3.toNumber(); start3 = closest3; end3 = closest3+Epsilon; }
            // console.log('closest1 =', closest1);
            // console.log('');
            

          [ closestColor,
            closestOklab,
            closestOrder,
            closest1,
            closest2,
            closest3,
            progress ] = await findCorrectionInOrder(
                parse,
                nodeId,
                refOklab,
                _order, 
                lockedOrder, 
                locked1,  locked2,  locked3,
                closest1, closest2, closest3,
                start1,   start2,   start3, 
                end1,     end2,     end3,
                [...closestColor],
                closestOklab, 
                closestOrder,
                progress,
                total);
        }


        if (parse.stopGenerate)
            break;

        
        d /= 2;


        parse.currentProgress++;


        if (await checkStop(parse.requestId))
            break;
    }


    if (!parse.stopGenerate)
    {
        // reduce closest to necessary minimums

        const closestRgb = getCorrectedColor(color, closestOrder, closest1, closest2, closest3)[2];

        let c1 = closest1;
        let c2 = closest2;
        let c3 = closest3;

        while (c1 >= 0 && rgbEqual(getCorrectedColor(color, closestOrder, c1-1, closest2, closest3)[2], closestRgb)) c1--;
        while (c2 >= 0 && rgbEqual(getCorrectedColor(color, closestOrder, closest1, c2-1, closest3)[2], closestRgb)) c2--;
        while (c3 >= 0 && rgbEqual(getCorrectedColor(color, closestOrder, closest1, closest2, c3-1)[2], closestRgb)) c3--;

        closest1 = Math.max(0, c1);
        closest2 = Math.max(0, c2);
        closest3 = Math.max(0, c3);
    }

    
    return [
        closestOrder,
        closest1,
        closest2,
        closest3 ];
}



async function findCorrectionInOrder(parse,
                                     nodeId,
                                     refOklab,
                                     order, 
                                     lockedOrder, 
                                     locked1,  locked2,  locked3,
                                     closest1, closest2, closest3,
                                     start1,   start2,   start3, 
                                     end1,     end2,     end3,
                                     closestColor,
                                     closestOklab,
                                     closestOrder,
                                     progress,
                                     total)
{
    const color = [...closestColor];
    
    let nSteps1 = locked1 ? 1 : 2;
    let nSteps2 = locked2 ? 1 : 2;
    let nSteps3 = locked3 ? 1 : 2;


    cLoop:
    for (let m1 = start1; m1 < end1; m1 += (end1-start1)/nSteps1)
    {
        if (parse.stopGenerate)
            break cLoop;

        for (let m2 = start2; m2 < end2; m2 += (end2-start2)/nSteps2)
        {
            if (parse.stopGenerate)
                break cLoop;

            for (let m3 = start3; m3 < end3; m3 += (end3-start3)/nSteps3)
            {
                if (parse.stopGenerate)
                    break cLoop;

                const [_color, _oklab, _rgb] = getCorrectedColor(color, order, m1, m2, m3);

                if (   rgbIsOk(_rgb)
                    && (  !closestOklab
                        || rgbDistance(refOklab, _oklab) < rgbDistance(refOklab, closestOklab)))
                {
                    closestColor = _color;
                    closestOklab = _oklab;
                    
                    if (!lockedOrder)
                        closestOrder = order;

                    closest1 = m1;
                    closest2 = m2;
                    closest3 = m3;
                }

                progress++;
            }
        }

        
        genUpdateNodeProgress(parse, nodeId, progress / total, false);
    }

    
    return [
        closestColor,
        closestOklab,
        closestOrder,
        closest1,
        closest2,
        closest3,
        progress ];
}



function getCorrectedColor(color, order, m1, m2, m3)
{
    const _color = correctColor(color, order, m1, m2, m3);
    const oklab  = dataColor2array(dataColor2oklab(_color));
    const rgb    = oklab2rgb(oklab);

    return [_color, oklab, rgb];
}



function correctColor(color, order, c1, c2, c3)
{
    if (order < 0)
        return color;


    const [i1, i2, i3] = getCorrectionsInOrder(order);

                               color = correctChannel(color, i1, c1);
    if (!dataColorIsOk(color)) color = correctChannel(color, i2, c2);
    if (!dataColorIsOk(color)) color = correctChannel(color, i3, c3);


    // clip colors that are reasonably valid but stick over the fence
    
    let rgb = dataColor2rgb(color);

    if (rgbIsOk(rgb))
        rgb = invalid2validRgb(rgb);
    
        
    color = convertDataColorToSpace(
        rgb2dataColor(rgb),
        color[0]);

    
    return color;
}



function correctChannel(color, iChan, margin)
{
    const factor = colorSpaceFactor(color[0]);

    margin /= factor[iChan];


    const savedColor = [...color];
    const savedValue = color[iChan+1];

    const d = 0.001;


    let _c  = savedValue,
         c_ = savedValue;

    let _valid  = dataColorIsOk(color);
    let  valid_ = _valid;


    let stackOverflowProtect = 1/d*2;


    while (   !_valid
           && ! valid_
           && stackOverflowProtect-- > 0)
    {
        _c  -= d;  _valid  = isColorOk(_c , iChan, savedColor);
         c_ += d;   valid_ = isColorOk( c_, iChan, savedColor);
    }


    stackOverflowProtect = 1/d*2;
    color = [...savedColor];


    if (_valid) 
    { 
        _valid = dataColorIsOk(color);
        _c     = savedValue;

        while (   !_valid
               && margin > 0
               && stackOverflowProtect-- > 0)
        {
            _c -= d; 
            _valid = isColorOk(_c, iChan, savedColor);
            margin -= Math.sign(margin) * d;
        }

        color[iChan+1] = _c;
    }
    else if (valid_)
    { 
        valid_ = dataColorIsOk(color);
        c_     = savedValue;

        while (   !valid_
               && margin > 0
               && stackOverflowProtect-- > 0)
        {
            c_ += d; 
            valid_ = isColorOk(c_, iChan, savedColor);
            margin -= Math.sign(margin) * d;
        }

        color[iChan+1] = c_;
    }


    return color;
}



function isColorOk(c, iChan, savedColor)
{
    let color = [...savedColor];
    color[iChan+1] = c; 
    return dataColorIsOk(color);
}



function getCorrectionsInOrder(order)
{
    switch (order)
    {
        case 0: return [0, 1, 2];
        case 1: return [1, 0, 2];
        case 2: return [1, 2, 0];
        case 3: return [0, 2, 1];
        case 4: return [2, 0, 1];
        case 5: return [2, 1, 0];
    }

    // should never get here
    consoleError('invalid correction order ' + order);
    return [0, 0, 0];
}



function getMinCorrections(space, order)
{
    const [c1, c2, c3] = getCorrectionsInOrder(order);

    let min;

    switch (space)
    {
        case 'hex':
        case 'rgb':   min = [0, 0, 0]; break;

        case 'hsv': 
        case 'hsl':   min = [0, 0, 0]; break;

        case 'hclok':
        case 'hclab':
        case 'hcluv': min = [0, 0, 0]; break;

        case 'oklab':
        case 'lab':
        case 'luv':   min = [0, -oppFactor[1]/2, -oppFactor[2]/2]; break;
        
        default:
            // should never get here
            consoleError('invalid validation order ' + order);
            return [0, 0, 0];
    }

    return [min[c1], min[c2], min[c3]];
}



function getMaxCorrections(space, order)
{
    const [c1, c2, c3] = getCorrectionsInOrder(order);

    let max;

    switch (space)
    {
        case 'hex':
        case 'rgb':   max = [...rgbFactor]; break;

        case 'hsv': 
        case 'hsl':   max = [hs_Factor[0]/2, hs_Factor[1], hs_Factor[2]]; break;

        case 'hclok':
        case 'hclab':
        case 'hcluv': max = [hclFactor[0]/2, hclFactor[1], hclFactor[2]]; break;

        case 'oklab':
        case 'lab':
        case 'luv':   max = [...oppFactor]; break;
        
        default:
            // should never get here
            consoleError('invalid validation order ' + order);
            return [0, 0, 0];
    }

    return [max[c1], max[c2], max[c3]];
}



function reorderCorrection(closestOrder,
                           closest1, closest2, closest3,
                           locked1,  locked2,  locked3)
{
    let c1 = { closest: closest1, locked: locked1 };
    let c2 = { closest: closest2, locked: locked2 };
    let c3 = { closest: closest3, locked: locked3 };

    if (   c1.closest <  Epsilon
        && c2.closest <  Epsilon
        && c3.closest >= Epsilon)
    {
        switch (closestOrder)
        {
            case 0: closestOrder = 4; break;
            case 1: closestOrder = 5; break;
            case 2: closestOrder = 0; break;
            case 3: closestOrder = 1; break;
            case 4: closestOrder = 2; break;
            case 5: closestOrder = 3; break;
        }

        const tmp = c2;
        c1 = c3;
        c2 = c1;
        c3 = tmp;
    }
    else if (c1.closest >= Epsilon
          && c2.closest <  Epsilon)
    {
        switch (closestOrder)
        {
            case 0: closestOrder = 3; break;
            case 1: closestOrder = 2; break;
            case 2: closestOrder = 1; break;
            case 3: closestOrder = 0; break;
            case 4: closestOrder = 5; break;
            case 5: closestOrder = 4; break;
        }

        const tmp = c2;
        c2 = c3;
        c3 = tmp;
    }
    else if (c1.closest < Epsilon)
    {
        switch (closestOrder)
        {
            case 0: closestOrder = 2; break;
            case 1: closestOrder = 3; break;
            case 2: closestOrder = 4; break;
            case 3: closestOrder = 5; break;
            case 4: closestOrder = 0; break;
            case 5: closestOrder = 1; break;
        }

        const tmp = c1;
        c1 = c2;
        c2 = c3;
        c3 = tmp;
    }


    return [
        closestOrder,
        c1.closest, c2.closest, c3.closest,
        c1.locked,  c2.locked,  c3.locked ];
}



function getColorCorrections(colorSpace)
{
    switch (colorSpace)
    {
    case 'hex':
    case 'rgb':
        return [
            new ColorCorrection('R', rgbFactor[0]),
            new ColorCorrection('G', rgbFactor[1]),
            new ColorCorrection('B', rgbFactor[2]) ];

    case 'hsv':
        return [
            new ColorCorrection('H', hs_Factor[0]/2),
            new ColorCorrection('S', hs_Factor[1]),
            new ColorCorrection('B', hs_Factor[2]) ];

    case 'hsl':
        return [
            new ColorCorrection('H', hs_Factor[0]/2),
            new ColorCorrection('S', hs_Factor[1]),
            new ColorCorrection('L', hs_Factor[2]) ];

    case 'hclok':
    case 'hclab':
    case 'hcluv':
        return [
            new ColorCorrection('H', hclFactor[0]/2),
            new ColorCorrection('C', hclFactor[1]),
            new ColorCorrection('L', hclFactor[2]) ];

    case 'oklab': 
    case 'lab':
        return [
            new ColorCorrection('L', oppFactor[0]),
            new ColorCorrection('a', oppFactor[1]),
            new ColorCorrection('b', oppFactor[2]) ];

    case 'luv':
        return [
            new ColorCorrection('L', oppFactor[0]),
            new ColorCorrection('u', oppFactor[1]),
            new ColorCorrection('v', oppFactor[2]) ];
    }


    consoleError('invalid color space ' + colorSpace);
    return [
        new ColorCorrection(),
        new ColorCorrection(),
        new ColorCorrection() ];
}


class GColor
extends GOperator1
{
    space   = null;
    
   _c1      = null;
   _c2      = null;
   _c3      = null;
    
    c1      = null;
    c2      = null;
    c3      = null;

    convert = null;
    
    hasInputs;



    constructor(nodeId, options)
    {
        super(COLOR, nodeId, options);
    }

    
    
    reset()
    {
        super.reset();
        
        this.space   = null;
        
        this._c1     = null;
        this._c2     = null;
        this._c3     = null;
        
        this.c1      = null;
        this.c2      = null;
        this.c3      = null;
    
        this.convert = null;
    }



    copy()
    {
        const copy = new GColor(this.nodeId, this.options);

        copy.copyBase(this);

        copy.space = this.space.copy();

        if (this._c1) copy._c1 = this._c1.copy();
        if (this._c2) copy._c2 = this._c2.copy();
        if (this._c3) copy._c3 = this._c3.copy();

        if (this. c1) copy. c1 = this. c1.copy();
        if (this. c2) copy. c2 = this. c2.copy();
        if (this. c3) copy. c3 = this. c3.copy();

        if (this.convert) 
            copy.convert = this.convert.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input = await evalColorValue (this.input, parse);
        let   space = await evalNumberValue(this.space, parse); 
        let   c1    = await evalNumberValue(this._c1,   parse);
        let   c2    = await evalNumberValue(this._c2,   parse);
        let   c3    = await evalNumberValue(this._c3,   parse);

        if (space) space = space.toInteger();

        
        if (input)
        {
            if (input.isValid())
            {
                if (this.options.enabled)
                {
                    this.value = input.copy();
                    

                    const fromSpaceIndex = input.space.value;
                    const toSpaceIndex = Math.min(Math.max(
                        0,
                        Math.round(space.value)), // round because a value can come in with decimals
                        ColorSpaces.length-1);


                    if (toSpaceIndex != fromSpaceIndex)
                    {
                        this.convertColor(
                            this.value,
                            colorSpace(fromSpaceIndex), 
                            colorSpace(  toSpaceIndex));

                        this.value.space.value = toSpaceIndex;
                    }

                    
                    if (!c1) c1 = this.value.c1;
                    if (!c2) c2 = this.value.c2;
                    if (!c3) c3 = this.value.c3;
 
                    if (c1) { this.value.c1 = c1; this.c1 = c1; }
                    if (c2) { this.value.c2 = c2; this.c2 = c2; }
                    if (c3) { this.value.c3 = c3; this.c3 = c3; }
                }
                else
                    this.value = input.copy();
            }
            else
                this.value = ColorValue.NaN.copy();

                
            if (!this.convert)
                this.convert = NumberValue.NaN.copy();
        }
        else if (space
              && c1
              && c2
              && c3)
        {
            this.value = new ColorValue(space, c1, c2, c3);


            const toSpaceIndex = Math.min(Math.max(
                0,
                Math.round(this.value.space.value)), // round because a value can come in with decimals
                ColorSpaces.length-1);

            this.value.space.value = toSpaceIndex;


            if (    this.convert
                &&  this.convert.isValid()
                &&  this.convert.value > -1
                &&  this.value.isValid()
                && !this.hasInputs)
            {
                await this.convert.eval(parse);

                this.convertColor(
                    this.value,
                    colorSpace(this.convert.value), 
                    colorSpace(toSpaceIndex));
            }
        }
        else
            this.value = ColorValue.NaN.copy();


        if (!this.value.space.isValid())
            this.value = new ColorValue(
                this.space ? this.space.toValue() : NumberValue.NaN,
                NumberValue.NaN,
                NumberValue.NaN,
                NumberValue.NaN);


        this.setUpdateValues(parse,
        [
            ['convert', this.convert    ],
            ['space',   this.value.space],
            ['c1',      this.value.c1   ],
            ['c2',      this.value.c2   ],
            ['c3',      this.value.c3   ]
        ]);


        // if (!this.c1) this.c1 = this.value.c1.copy();
        // if (!this.c2) this.c2 = this.value.c2.copy();
        // if (!this.c3) this.c3 = this.value.c3.copy();


        this.validate();

        return this;
    }



    convertColor(color, fromSpace, toSpace)
    {
        let col = [
            fromSpace, 
            getNormalColorValue(color.c1.value, fromSpace, 0),
            getNormalColorValue(color.c2.value, fromSpace, 1),
            getNormalColorValue(color.c3.value, fromSpace, 2) ];

        col = getScaledDataColor(convertDataColorToSpace(col, toSpace));

        color.c1.value = col[1];
        color.c2.value = col[2];
        color.c3.value = col[3];
    }



    toValue()
    {
        return this.options.enabled
             ? this.value.copy()
             : ColorValue.NaN.copy();
    }



    isValid()
    {
        return (!this.input || this.input.isValid())
            && this.space && this.space.isValid()
            && this.c1    && this.c1   .isValid()
            && this.c2    && this.c2   .isValid()
            && this.c3    && this.c3   .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.space) this.space.pushValueUpdates(parse);
        if (this._c1  ) this._c1  .pushValueUpdates(parse);
        if (this._c2  ) this._c2  .pushValueUpdates(parse);
        if (this._c3  ) this._c3  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.space) this.space.invalidateInputs(parse, from, force);
        if (this._c1  ) this._c1  .invalidateInputs(parse, from, force);
        if (this._c2  ) this._c2  .invalidateInputs(parse, from, force);
        if (this._c3  ) this._c3  .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.space) this.space.iterateLoop(parse);
        if (this._c1  ) this._c1  .iterateLoop(parse);
        if (this._c2  ) this._c2  .iterateLoop(parse);
        if (this._c3  ) this._c3  .iterateLoop(parse);
    }
}


class GValidColor
extends GOperator1
{
    quality      = null;

    corrections  = [];



    constructor(nodeId, options)
    {
        super(VALID_COLOR, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.quality     = null;
        this.corrections = [];
    }



    copy()
    {
        const copy = new GValidColor(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.value  ) copy.value   = this.value  .copy();
        if (this.quality) copy.quality = this.quality.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input     = await evalColorValue (this.input,   parse);
        const quality   = await evalNumberValue(this.quality, parse);


        if (input)
        {
            if (this.options.enabled)
            {
                if (isListValueType(input.type))
                {
                    this.value = new ListValue();

                    for (let i = 0; i < input.items.length; i++)
                        this.value.items.push(await getValidColorValue(parse, this, input.items[i], quality));
                }
                else
                    this.value = await getValidColorValue(parse, this, input, quality);
            }
            else
                this.value = input.copy();
        }
        else
            this.value = ColorValue.NaN.copy();


        
        this.setUpdateValues(parse,
        [
            ['value',   this.value       ],
            ['type',    this.outputType()],
            ['quality', quality          ]
        ]);

        
        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.quality && this.quality.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.quality) this.quality.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.quality) this.quality.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.quality) this.quality.iterateLoop(parse);
    }
}



async function getValidColorValue(parse, node, input, quality)
{
    let rgb = input.toRgb();

    if (quality.value == 0) // clip sRGB
    {
        rgb[0] = Math.round(Math.min(Math.max(0, rgb[0]), 1) * 0xff);   
        rgb[1] = Math.round(Math.min(Math.max(0, rgb[1]), 1) * 0xff);   
        rgb[2] = Math.round(Math.min(Math.max(0, rgb[2]), 1) * 0xff); 
        
        return ColorValue.fromRgb(rgb);
    }
    else if (quality.value == 1) // clip chroma
    {
        rgb = clipChroma(rgb);

        rgb[0] = Math.round(rgb[0] * 0xff);
        rgb[1] = Math.round(rgb[1] * 0xff);
        rgb[2] = Math.round(rgb[2] * 0xff);

        return ColorValue.fromRgb(rgb);
    }
    else // find corrections
    {
        if (!rgbIsOk(rgb))
            genInitNodeProgress(node.nodeId);
        

        const inputColor = input.toDataColor();


        const
      [ closestOrder,
        closest1,
        closest2,
        closest3 ] = await findCorrection(
            parse,
            node.nodeId,
            inputColor,
            quality, null,  null,  null,
            false,   false, false, false);

            
        if (!parse.stopGenerate)
        {
            if (   closestOrder >= 0
                && closestOrder <  6)
            {
                node._color = correctColor(
                    inputColor,
                    closestOrder,
                    closest1,
                    closest2,
                    closest3);

                return ColorValue.fromDataColor(node._color);
            }
            else
            {
                return ColorValue.NaN.copy();
            }
        }
    }    


    return ColorValue.NaN.copy();
}


class GCorrectColor
extends GOperator1
{
    _order  = null;
    _c1     = null;
    _c2     = null;
    _c3     = null;
    
    order   = null;
    c1      = null;
    c2      = null;
    c3      = null;

    corrections = [];



    constructor(nodeId, options)
    {
        super(CORRECT_COLOR, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this._order  = null;
        this._c1     = null;
        this._c2     = null;
        this._c3     = null;
        
        this.order   = null;
        this.c1      = null;
        this.c2      = null;
        this.c3      = null;
    
        this.corrections = [];
    }



    copy()
    {
        const copy = new GCorrectColor(this.nodeId, this.options);

        copy.copyBase(this);
        
        if (this._order) copy._order = this.order .copy();
        if (this._c1   ) copy._c1    = this._c1   .copy();
        if (this._c2   ) copy._c2    = this._c2   .copy();
        if (this._c3   ) copy._c3    = this._c3   .copy();
        
        if (this. order) copy. order = this.order .copy();
        if (this. c1   ) copy. c1    = this. c1   .copy();
        if (this. c2   ) copy. c2    = this. c2   .copy();
        if (this. c3   ) copy. c3    = this. c3   .copy();
        
        if (this.value ) copy. value = this. value.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input = await evalColorValue (this. input, parse);
        let   order = await evalNumberValue(this._order, parse);
        const c1    = await evalNumberValue(this._c1,    parse);
        const c2    = await evalNumberValue(this._c2,    parse);
        const c3    = await evalNumberValue(this._c3,    parse);

        if (order) 
        {
            order       = order.toInteger();
            order.value = Math.min(Math.max(0, order.value), 5);
        }


        if (input)
        {
            if (this.options.enabled)
            {
                const rgb = input.toRgb();
                
                if (!rgbIsOk(rgb))
                    genInitNodeProgress(this.nodeId);


                const inputColor = input.toDataColor();


                const
              [ closestOrder,
                closest1,
                closest2,
                closest3 ] = await findCorrection(
                    parse,
                    this.nodeId,
                    inputColor, 
                    order, c1, c2, c3, 
                    this.order != null,
                    this.c1    != null, 
                    this.c2    != null, 
                    this.c3    != null); 

                    
                if (   /*!parse.stop()
                    &&*/ !parse.stopGenerate)
                {
                    if (   closestOrder >= 0 
                        && closestOrder <  6)
                    {
                        this._color = correctColor(
                            inputColor,
                            closestOrder,
                            closest1,
                            closest2,
                            closest3);

                            
                        this.order = new NumberValue(closestOrder);
                        this.c1    = new NumberValue(closest1);
                        this.c2    = new NumberValue(closest2);
                        this.c3    = new NumberValue(closest3);
                        

                        this.value = ColorValue.fromDataColor(this._color);

                        this.value.c1.decimals = input.c1.decimals;
                        this.value.c2.decimals = input.c2.decimals;
                        this.value.c3.decimals = input.c3.decimals;


                        this.setUpdateValues(parse,
                        [
                            ['order', new NumberValue(closestOrder, 0)],
                            ['c1',    new NumberValue(closest1,     1)],
                            ['c2',    new NumberValue(closest2,     1)],
                            ['c3',    new NumberValue(closest3,     1)],
                            ['value', this.value                      ]
                        ]);
                    }
                    else
                    {
                        this.order = NumberValue.NaN.copy();
                        this.c1    = NumberValue.NaN.copy();
                        this.c2    = NumberValue.NaN.copy();
                        this.c3    = NumberValue.NaN.copy();
                        this.value = input.copy();
        
                        this.setUpdateValues(parse,
                        [
                            ['order', this.order],
                            ['c1',    this.c1   ],
                            ['c2',    this.c2   ],
                            ['c3',    this.c3   ],
                            ['value', this.value]
                        ]);
                    }
                }
                else
                {
                    this.order = NumberValue.NaN.copy();
                    this.c1    = NumberValue.NaN.copy();
                    this.c2    = NumberValue.NaN.copy();
                    this.c3    = NumberValue.NaN.copy();
                    this.value = input.copy();
    
                    this.setUpdateValues(parse,
                    [
                        ['order', this.order],
                        ['c1',    this.c1   ],
                        ['c2',    this.c2   ],
                        ['c3',    this.c3   ],
                        ['value', this.value]
                    ]);
                }
            }
            else
            {
                this.order = NumberValue.NaN.copy();
                this.c1    = NumberValue.NaN.copy();
                this.c2    = NumberValue.NaN.copy();
                this.c3    = NumberValue.NaN.copy();
                this.value = input.copy();

                this.setUpdateValues(parse,
                [
                    ['order', this.order],
                    ['c1',    this.c1   ],
                    ['c2',    this.c2   ],
                    ['c3',    this.c3   ],
                    ['value', this.value]
                ]);
            }
        }
        else
        {
            this.order = NumberValue.NaN.copy();
            this.c1    = NumberValue.NaN.copy();
            this.c2    = NumberValue.NaN.copy();
            this.c3    = NumberValue.NaN.copy();
            this.value = ColorValue .NaN.copy();

            this.setUpdateValues(parse,
            [
                ['order', NumberValue.NaN],
                ['c1',    NumberValue.NaN],
                ['c2',    NumberValue.NaN],
                ['c3',    NumberValue.NaN],
                ['value', ColorValue .NaN]
            ]);
        }


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.order && this.order.isValid()
            && this.c1    && this.c1   .isValid()
            && this.c2    && this.c2   .isValid()
            && this.c3    && this.c3   .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this._order) this._order.pushValueUpdates(parse);
        if (this._c1   ) this._c1   .pushValueUpdates(parse);
        if (this._c2   ) this._c2   .pushValueUpdates(parse);
        if (this._c3   ) this._c3   .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this._order) this._order.invalidateInputs(parse, from, force);
        if (this._c1   ) this._c1   .invalidateInputs(parse, from, force);
        if (this._c2   ) this._c2   .invalidateInputs(parse, from, force);
        if (this._c3   ) this._c3   .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this._order) this._order.iterateLoop(parse);
        if (this._c1   ) this._c1   .iterateLoop(parse);
        if (this._c2   ) this._c2   .iterateLoop(parse);
        if (this._c3   ) this._c3   .iterateLoop(parse);
    }
}



class GColorContrast
extends GOperator2
{
    standard = null;
    contrast = null;


    constructor(nodeId, options)
    {
        super(COLOR_CONTRAST, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.standard = null;
        this.contrast = null;
    }



    copy()
    {
        const copy = new GColorContrast(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.standard) copy.standard = this.standard.copy();
        if (this.contrast) copy.contrast = this.contrast.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input0    = await evalColorValue (this.input0,   parse);
        const input1    = await evalColorValue (this.input1,   parse);
        const standard  = await evalNumberValue(this.standard, parse);

        
        if (standard.isValid())
            standard.value = Math.min(Math.max(0, standard.value), 1);


        if (   input0 
            && input1)
        {
            if (   input0.isValid()
                && input1.isValid())
            {
                if (   dataColorIsValid(input0.toDataColor())
                    && dataColorIsValid(input1.toDataColor()))
                {
                    if (standard.value == 0)
                    {
                        const value = getContrastRatio2(input0.toRgb(), input1.toRgb());
                        this.contrast = new NumberValue(value, 2);
                    }
                    else
                    {
                        const value = getContrastRatio3(input0.toRgb(), input1.toRgb());
                        this.contrast = new NumberValue(value, 1);
                    }
                }
                else
                    this.contrast = NumberValue.NaN.copy();
            }
            else
                this.contrast = NumberValue.NaN.copy();


            this.value = 
                input0 
                ? input0//.copy() 
                : ColorValue.NaN.copy();


            this.setUpdateValues(parse,
            [
                ['text', input0],
                ['back', input1]
            ]);
        }

        else if (input0) 
        {
            this.setUpdateValues(parse,
            [
                ['text', input0.isValid() ? input0 : ColorValue.NaN],
                ['back', ColorValue.NaN                            ]
            ]);
            
            this.value    = input0;//.copy();
            this.contrast = NumberValue.NaN.copy();
        }

        else if (input1) 
        {
            this.setUpdateValues(parse,
            [
                ['text', ColorValue.NaN                            ],
                ['back', input1.isValid() ? input1 : ColorValue.NaN]
            ]);

            this.value    = ColorValue .NaN.copy();
            this.contrast = NumberValue.NaN.copy();
        }

        else
        {
            this.value    = ColorValue .NaN.copy();
            this.contrast = NumberValue.NaN.copy();

            this.setUpdateValues(parse,
            [
                ['text', ColorValue.NaN],
                ['back', ColorValue.NaN]
            ]);
        }
        


        this.setUpdateValues(parse,
        [
            ['standard', standard     ],
            ['contrast', this.contrast]
        ],
        true);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.standard && this.standard.isValid()
            && (!this.contrast || this.contrast.isValid());
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.standard) this.standard.pushValueUpdates(parse);
        if (this.contrast) this.contrast.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.standard) this.standard.invalidateInputs(parse, from, force);
        if (this.contrast) this.contrast.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.standard) this.standard.iterateLoop(parse);
        if (this.contrast) this.contrast.iterateLoop(parse);
    }
}



class GConvertP3
extends GOperator1
{
    from = null;



    constructor(nodeId, options)
    {
        super(COLOR_CONVERT_P3, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.from = null;
    }



    copy()
    {
        const copy = new GConvertP3(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.value) copy.value = this.value.copy();
        if (this.from ) copy.from  = this.from .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input = await evalColorValue (this.input, parse);
        let   from  = await evalNumberValue(this.from,  parse);

        if (from) from = from.toInteger();
        

        if (input)
        {
            if (this.options.enabled)
            {
                if (isListValueType(input.type))
                {
                    this.value = new ListValue();

                    for (let i = 0; i < input.items.length; i++)
                        this.value.items.push(await getConvertP3Value(input.items[i], from));
                }
                else
                    this.value = await getConvertP3Value(input, from);
            }
            else
                this.value = input.copy();
        }
        else
            this.value = ColorValue.NaN.copy();


        
        this.setUpdateValues(parse,
        [
            ['value',   this.value       ],
            ['type',    this.outputType()],
            ['quality', from             ]
        ]);

        
        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.from && this.from.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.from) this.from.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.from) this.from.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.from) this.from.iterateLoop(parse);
    }
}



function getConvertP3Value(input, from)
{
    return ColorValue.fromRgb(
        from.value == 0
        ? scaleRgb(rgb2p3(input.toRgb()))
        : scaleRgb(p32rgb(input.toRgb())));
}


class GColorBlind
extends GOperator1
{
    l;
    m;
    s;


    constructor(nodeId, options)
    {
        super(COLORBLIND, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.l = null;
        this.m = null;
        this.s = null;
    }



    copy()
    {
        const copy = new GColorBlind(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.l) copy.l = this.l.copy();
        if (this.m) copy.m = this.m.copy();
        if (this.s) copy.s = this.s.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input = await evalColorValue (this.input, parse);
        const l     = await evalNumberValue(this.l,     parse); 
        const m     = await evalNumberValue(this.m,     parse);
        const s     = await evalNumberValue(this.s,     parse);


        if (input)
        {
            if (this.options.enabled)
            {
                if (isListValueType(input.type))
                {
                    this.value = new ListValue();

                    for (let i = 0; i < input.items.length; i++)
                        this.value.items.push(getColorBlindValue(input.items[i], l, m, s));
                }
                else
                    this.value = getColorBlindValue(input, l, m, s);
            }
            else
                this.value = input.copy();
        }
        else
            this.value = ColorValue.NaN.copy();


        this.setUpdateValues(parse,
        [
            ['value',  this.value       ],
            ['type',   this.outputType()],
            ['l',      l                ],
            ['m',      m                ],
            ['s',      s                ]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.l && this.l.isValid()
            && this.m && this.m.isValid()
            && this.s && this.s.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.l) this.l.pushValueUpdates(parse);
        if (this.m) this.m.pushValueUpdates(parse);
        if (this.s) this.s.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.l) this.l.invalidateInputs(parse, from, force);
        if (this.m) this.m.invalidateInputs(parse, from, force);
        if (this.s) this.s.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.l) this.l.iterateLoop(parse);
        if (this.m) this.m.iterateLoop(parse);
        if (this.s) this.s.iterateLoop(parse);
    }
}



function getColorBlindValue(input, l, m, s)
{
    const rgb   = input.toRgb();

    const rgbCb = rgb2colorblind(
        rgb,
        l.value / 2,
        m.value / 2,
        s.value / 2);

    if (   !rgbIsNaN(rgb  )
        && !rgbIsNaN(rgbCb))
    {
        const validRgbCb = rgbCb;
    
        const validCol = convertDataColorToSpace(
            rgb2dataColor(validRgbCb), 
            colorSpace(input.space.value));

        return ColorValue.fromDataColor(validCol);
    }
    else
        return ColorValue.NaN.copy();
}


class GColorScheme
extends GOperator1
{
    schemeType = null;
    space      = null;



    constructor(nodeId, options)
    {
        super(COLOR_SCHEME, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.schemeType = null;
        this.space      = null;
    }



    copy()
    {
        const copy = new GColorScheme(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.value     ) copy.value      = this.value     .copy();
        if (this.schemeType) copy.schemeType = this.schemeType.copy();
        if (this.space     ) copy.space      = this.space     .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input      = await evalColorValue (this.input,      parse);
        const schemeType = await evalNumberValue(this.schemeType, parse);
        const space      = await evalNumberValue(this.space,      parse);


        if (input)
        {
            if (this.options.enabled)
            {
                this.value = new ListValue();


                const rgb = input.toRgb();


                const addHue = 
                    space.value == 0 
                    ? addHueHsl 
                    : addHueHcl;


                switch (schemeType.value)
                {
                    case 0: // similar
                    {
                        this.value.items.push(ColorValue.fromRgb(scaleRgb(addHue(rgb, 11/12, 0, 1))));
                        this.value.items.push(ColorValue.fromRgb(scaleRgb(addHue(rgb,  0,    0, 1))));
                        this.value.items.push(ColorValue.fromRgb(scaleRgb(addHue(rgb,  1/12, 0, 1))));
                        break;
                    }

                    case 1: // similar with accent
                    {
                        this.value.items.push(ColorValue.fromRgb(scaleRgb(addHue(rgb, 11/12, 0, 1))));
                        this.value.items.push(ColorValue.fromRgb(scaleRgb(addHue(rgb,  0,    0, 1))));
                        this.value.items.push(ColorValue.fromRgb(scaleRgb(addHue(rgb,  1/12, 0, 1))));
                        this.value.items.push(ColorValue.fromRgb(scaleRgb(addHue(rgb,  6/12, 0, 1))));
                        break;
                    }

                    case 2: // less similar
                    {
                        this.value.items.push(ColorValue.fromRgb(scaleRgb(addHue(rgb, 10/12, 0, 1))));
                        this.value.items.push(ColorValue.fromRgb(scaleRgb(addHue(rgb,  0,    0, 1))));
                        this.value.items.push(ColorValue.fromRgb(scaleRgb(addHue(rgb,  2/12, 0, 1))));
                        break;
                    }

                    case 3: // opposite
                    {
                        this.value.items.push(ColorValue.fromRgb(scaleRgb(addHue(rgb,  0,    0, 1))));
                        this.value.items.push(ColorValue.fromRgb(scaleRgb(addHue(rgb,  6/12, 0, 1))));
                        break;
                    }

                    case 4: // opposite -
                    {
                        this.value.items.push(ColorValue.fromRgb(scaleRgb(addHue(rgb,  0,    0, 1))));
                        this.value.items.push(ColorValue.fromRgb(scaleRgb(addHue(rgb,  5/12, 0, 1))));
                        break;
                    }

                    case 5: // opposite +
                    {
                        this.value.items.push(ColorValue.fromRgb(scaleRgb(addHue(rgb,  0,    0, 1))));
                        this.value.items.push(ColorValue.fromRgb(scaleRgb(addHue(rgb,  7/12, 0, 1))));
                        break;
                    }

                    case 6: // opposite split
                    {
                        this.value.items.push(ColorValue.fromRgb(scaleRgb(addHue(rgb,  0,    0, 1))));
                        this.value.items.push(ColorValue.fromRgb(scaleRgb(addHue(rgb,  5/12, 0, 1))));
                        this.value.items.push(ColorValue.fromRgb(scaleRgb(addHue(rgb,  7/12, 0, 1))));
                        break;
                    }

                    case 7: // double opposite -
                    {
                        this.value.items.push(ColorValue.fromRgb(scaleRgb(addHue(rgb,   0,    0, 1))));
                        this.value.items.push(ColorValue.fromRgb(scaleRgb(addHue(rgb,  11/12, 0, 1))));
                        this.value.items.push(ColorValue.fromRgb(scaleRgb(addHue(rgb,   5/12, 0, 1))));
                        this.value.items.push(ColorValue.fromRgb(scaleRgb(addHue(rgb,   6/12, 0, 1))));
                        break;
                    }

                    case 8: // double opposite +
                    {
                        this.value.items.push(ColorValue.fromRgb(scaleRgb(addHue(rgb,  0,    0, 1))));
                        this.value.items.push(ColorValue.fromRgb(scaleRgb(addHue(rgb,  1/12, 0, 1))));
                        this.value.items.push(ColorValue.fromRgb(scaleRgb(addHue(rgb,  6/12, 0, 1))));
                        this.value.items.push(ColorValue.fromRgb(scaleRgb(addHue(rgb,  7/12, 0, 1))));
                        break;
                    }

                    case 9: // triangle
                    {
                        this.value.items.push(ColorValue.fromRgb(scaleRgb(addHue(rgb,  0,    0, 1))));
                        this.value.items.push(ColorValue.fromRgb(scaleRgb(addHue(rgb,  4/12, 0, 1))));
                        this.value.items.push(ColorValue.fromRgb(scaleRgb(addHue(rgb,  8/12, 0, 1))));
                        break;
                    }

                    case 10: // rectangle
                    {
                        this.value.items.push(ColorValue.fromRgb(scaleRgb(addHue(rgb,  0,    0, 1))));
                        this.value.items.push(ColorValue.fromRgb(scaleRgb(addHue(rgb,  2/12, 0, 1))));
                        this.value.items.push(ColorValue.fromRgb(scaleRgb(addHue(rgb,  6/12, 0, 1))));
                        this.value.items.push(ColorValue.fromRgb(scaleRgb(addHue(rgb,  8/12, 0, 1))));
                        break;
                    }

                    case 11: // square
                    {
                        this.value.items.push(ColorValue.fromRgb(scaleRgb(addHue(rgb,  0,    0, 1))));
                        this.value.items.push(ColorValue.fromRgb(scaleRgb(addHue(rgb,  3/12, 0, 1))));
                        this.value.items.push(ColorValue.fromRgb(scaleRgb(addHue(rgb,  6/12, 0, 1))));
                        this.value.items.push(ColorValue.fromRgb(scaleRgb(addHue(rgb,  9/12, 0, 1))));
                        break;
                    }

                    case 12: // hexagon
                    {
                        this.value.items.push(ColorValue.fromRgb(scaleRgb(addHue(rgb,  0,    0, 1))));
                        this.value.items.push(ColorValue.fromRgb(scaleRgb(addHue(rgb,  2/12, 0, 1))));
                        this.value.items.push(ColorValue.fromRgb(scaleRgb(addHue(rgb,  4/12, 0, 1))));
                        this.value.items.push(ColorValue.fromRgb(scaleRgb(addHue(rgb,  6/12, 0, 1))));
                        this.value.items.push(ColorValue.fromRgb(scaleRgb(addHue(rgb,  8/12, 0, 1))));
                        this.value.items.push(ColorValue.fromRgb(scaleRgb(addHue(rgb, 10/12, 0, 1))));
                        break;
                    }
                }
            }
            else
                this.value = input.copy();
        }
        else
            this.value = ColorValue.NaN.copy();


        
        this.setUpdateValues(parse,
        [
            ['value',      this.value       ],
            ['type',       this.outputType()],
            ['schemeType', schemeType       ],
            ['space',      space            ]
        ]);

        
        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.schemeType && this.schemeType.isValid()
            && this.space      && this.space     .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.schemeType) this.schemeType.pushValueUpdates(parse);
        if (this.space     ) this.space     .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.schemeType) this.schemeType.invalidateInputs(parse, from, force);
        if (this.space     ) this.space     .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.schemeType) this.schemeType.iterateLoop(parse);
        if (this.space     ) this.space     .iterateLoop(parse);
    }
}



class GColorInterpolate
extends GOperator2
{
    space;
    amount;
    gamma;


    constructor(nodeId, options)
    {
        super(COLOR_INTERPOLATE, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.space  = null;
        this.amount = null;
        this.gamma  = null;
    }



    copy()
    {
        const copy = new GColorInterpolate(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.space ) copy.space  = this.space .copy();
        if (this.amount) copy.amount = this.amount.copy();
        if (this.gamma ) copy.gamma  = this.gamma .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input0 = await evalColorValue (this.input0, parse);
        const input1 = await evalColorValue (this.input1, parse);
        let   space  = await evalNumberValue(this.space,  parse);
        const amount = await evalNumberValue(this.amount, parse);
        const gamma  = await evalNumberValue(this.gamma,  parse);

        if (space) space = space.toInteger();
        

        if (   input0 
            && input1)
        {
            consoleAssert(
                amount.type == NUMBER_VALUE, 
                'this.result.type must be NUMBER_VALUE');

            const f = amount.value / 100;


            const spaceIndex = space.value;//Math.min(Math.max(0, space.value), colorSpaceCount()-1);
            const gammaValue = Math.max(0.0001, gamma.value);

            const _space = colorSpace(spaceIndex);

            const _color = this.interpolate(
                spaceIndex,
                convertDataColorToSpace(input0.toDataColor(), _space),
                convertDataColorToSpace(input1.toDataColor(), _space),
                f,
                gammaValue);


            // allow interpolating invalid colors,
            // so no valid color check here

            this.value = ColorValue.fromDataColor(_color, spaceIndex);
        }

        else if (input0) 
            this.value = input0;

        else if (input1) 
            this.value = input1;
            
        else 
            this.value = ColorValue.NaN.copy();


        this.setUpdateValues(parse,
        [
            ['space',  space     ],
            ['amount', amount    ],
            ['gamma',  gamma     ],
            ['value',  this.value]
        ]);
        

        this.validate();
        
        return this;
    }



    interpolate(space, col0, col1, f, gamma)
    {
        if (   space <= 1
            || space >  6) // hex, rgb, okLab, lab, luv
        {
            gamma = Math.max(0.01, gamma);

            const r0 = Math.sign(col0[1]) * Math.pow(Math.abs(col0[1]), gamma);  
            const g0 = Math.sign(col0[2]) * Math.pow(Math.abs(col0[2]), gamma);  
            const b0 = Math.sign(col0[3]) * Math.pow(Math.abs(col0[3]), gamma);  

            const r1 = Math.sign(col1[1]) * Math.pow(Math.abs(col1[1]), gamma);
            const g1 = Math.sign(col1[2]) * Math.pow(Math.abs(col1[2]), gamma);
            const b1 = Math.sign(col1[3]) * Math.pow(Math.abs(col1[3]), gamma);

            const r = lerp(r0, r1, f);        
            const g = lerp(g0, g1, f);            
            const b = lerp(b0, b1, f);        

            return [
                colorSpace(space),
                Math.sign(r) * Math.pow(Math.abs(r), 1/gamma),
                Math.sign(g) * Math.pow(Math.abs(g), 1/gamma),
                Math.sign(b) * Math.pow(Math.abs(b), 1/gamma) ];
        }
        else // hsv/hsl/hcl
        {
            const h0 = col0[1] * Tau;  const h1 = col1[1] * Tau;
            const c0 = col0[2];        const c1 = col1[2];
            const l0 = col0[3];        const l1 = col1[3];

            return [
                colorSpace(space),
                normalAngle(h0 + angleDiff(h0, h1) * f) / Tau,
                lerp(c0, c1, f),
                lerp(l0, l1, f) ];
        }
    }



    isValid()
    {
        return super.isValid()
            && this.space  && this.space .isValid()
            && this.amount && this.amount.isValid()
            && this.gamma  && this.gamma .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.space ) this.space .pushValueUpdates(parse);
        if (this.amount) this.amount.pushValueUpdates(parse);
        if (this.gamma ) this.gamma .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.space ) this.space .invalidateInputs(parse, from, force);
        if (this.amount) this.amount.invalidateInputs(parse, from, force);
        if (this.gamma ) this.gamma .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.space ) this.space .iterateLoop(parse);
        if (this.amount) this.amount.iterateLoop(parse);
        if (this.gamma ) this.gamma .iterateLoop(parse);
    }
}



class GColorBlend
extends GOperator2
{
    mode   = null;
    amount = null;
    

    constructor(nodeId, options)
    {
        super(COLOR_BLEND, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.mode   = null;
        this.amount = null;
    }



    copy()
    {
        const copy = new GColorBlend(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.mode  ) copy.mode   = this.mode  .copy();
        if (this.amount) copy.amount = this.amount.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input0 = await evalColorValue (this.input0, parse);
        const input1 = await evalColorValue (this.input1, parse);
        let   mode   = await evalNumberValue(this.mode,   parse);
        const amount = await evalNumberValue(this.amount, parse);
        
        if (mode) mode = mode.toInteger();


        if (   input0 
            && input1)
        {
            consoleAssert(
                amount.type == NUMBER_VALUE, 
                'this.result.type must be NUMBER_VALUE');

            const _amount = amount.value / 100;

            const modeIndex = Math.min(Math.max(0, mode.value), BlendModes.length-1);


            const col = this.blend(
                modeIndex,
                input0.toRgb(),
                input1.toRgb(),
                _amount);

            this.value = ColorValue.fromRgb(scaleRgb(col));
        }

        else if (input0) 
            this.value = input0;

        else if (this.input1) 
            this.value = input1;
            
        else 
            this.value = ColorValue.NaN.copy();


        this.setUpdateValues(parse,
        [
            ['value',  this.value],
            ['mode',   mode      ],
            ['amount', amount    ]
        ]);


        this.validate();
        
        return this;
    }



    blend(mode, col0, col1, amount)
    {
        switch (mode)
        {
            case  BLEND_NORMAL_INDEX:       return blendNormal     (col0, col1, amount);

            case  BLEND_DARKEN_INDEX:       return blendDarken     (col0, col1, amount);
            case  BLEND_MULTIPLY_INDEX:     return blendMultiply   (col0, col1, amount);
            case  BLEND_PLUS_DARKER_INDEX:  return blendPlusDarker (col0, col1, amount);
            case  BLEND_COLOR_BURN_INDEX:   return blendColorBurn  (col0, col1, amount);

            case  BLEND_LIGHTEN_INDEX:      return blendLighten    (col0, col1, amount);
            case  BLEND_SCREEN_INDEX:       return blendScreen     (col0, col1, amount);
            case  BLEND_PLUS_LIGHTER_INDEX: return blendPlusLighter(col0, col1, amount);
            case  BLEND_COLOR_DODGE_INDEX:  return blendColorDodge (col0, col1, amount);

            case  BLEND_OVERLAY_INDEX:      return blendOverlay    (col0, col1, amount);
            case  BLEND_SOFT_LIGHT_INDEX:   return blendSoftLight  (col0, col1, amount);
            case  BLEND_HARD_LIGHT_INDEX:   return blendHardLight  (col0, col1, amount);

            case BLEND_DIFFERENCE_INDEX:    return blendDifference (col0, col1);
            case BLEND_EXCLUSION_INDEX:     return blendExclusion  (col0, col1, amount);

            case BLEND_HUE_INDEX:           return blendHue        (col0, col1, amount);
            case BLEND_SATURATION_INDEX:    return blendSaturation (col0, col1, amount);
            case BLEND_COLOR_INDEX:         return blendColor      (col0, col1, amount);
            case BLEND_LUMINOSITY_INDEX:    return blendLuminosity (col0, col1, amount);
        }
    }



    isValid()
    {
        return super.isValid()
            && this.mode   && this.mode  .isValid()
            && this.amount && this.amount.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.mode  ) this.mode  .pushValueUpdates(parse);
        if (this.amount) this.amount.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.mode  ) this.mode  .invalidateInputs(parse, from, force);
        if (this.amount) this.amount.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.mode  ) this.mode  .iterateLoop(parse);
        if (this.amount) this.amount.iterateLoop(parse);
    }
}



function blendNormal(col, back, amount)
{
    return [ col[0] * amount + back[0] * (1 - amount),
             col[1] * amount + back[1] * (1 - amount),
             col[2] * amount + back[2] * (1 - amount) ];
}



function blendDarken(col, back, amount)
{
    return blendNormal(
        [ Math.min(back[0], col[0]),
          Math.min(back[1], col[1]),
          Math.min(back[2], col[2]) ],
        back,
        amount);
}



function chanMultiply(c, b)
{
    return c * b;
}



function blendMultiply(col, back, amount)
{
    return blendNormal(
        [ chanMultiply(col[0], back[0]),
          chanMultiply(col[1], back[1]),
          chanMultiply(col[2], back[2]) ],
        back,
        amount);
}



function blendPlusDarker(col, back, amount)
{
    return blendNormal(
        [ Math.min(back[0] + col[0], back[0], col[0]),
          Math.min(back[1] + col[1], back[1], col[1]),
          Math.min(back[2] + col[2], back[2], col[2]) ],
        back,
        amount);
}



function chanColorBurn(c, b)
{
         if (b == 1) return 1;
    else if (c == 0) return 0;
    else             return Math.min(Math.max(0, 1 - (1 - b) / c), 1);
}



function blendColorBurn(col, back, amount)
{
    return blendNormal(
         [ chanColorBurn(col[0], back[0]),
           chanColorBurn(col[1], back[1]),
           chanColorBurn(col[2], back[2]) ],
        back,
        amount);
}



function blendLighten(col, back, amount)
{
    return blendNormal(
        [ Math.max(back[0], col[0]),
          Math.max(back[1], col[1]),
          Math.max(back[2], col[2]) ],
        back,
        amount);
}



function chanScreen(c, b)
{
    return b + c - b*c;
}



function blendScreen(col, back, amount)
{
    return blendNormal(
        [ chanScreen(col[0], back[0]),
          chanScreen(col[1], back[1]),
          chanScreen(col[2], back[2]) ],
        back,
        amount);
}



function blendPlusLighter(col, back, amount)
{
    return blendNormal(
        [ Math.min(back[0] + col[0], 1),
          Math.min(back[1] + col[1], 1),
          Math.min(back[2] + col[2], 1) ],
        back,
        amount);
}



function chanColorDodge(c, b)
{
         if (b == 0) return 0;
    else if (c == 1) return 1;
    else             return Math.min(b / (1 - c), 1);
}



function blendColorDodge(col, back, amount)
{
    return blendNormal(
        [ chanColorDodge(col[0], back[0]),
          chanColorDodge(col[1], back[1]),
          chanColorDodge(col[2], back[2]) ],
        back,
        amount);
}



function blendOverlay(col, back, amount)
{
    return blendNormal(
        [ chanHardLight(back[0], col[0]),
          chanHardLight(back[1], col[1]),
          chanHardLight(back[2], col[2]) ],
        back,
        amount);
}



function bSL_D(b)
{
    return b <= 0.25
         ? ((16 * b - 12) * b + 4) * b
         : Math.sqrt(b);
}



function chanSoftLight(c, b)
{
    return c <= 0.5
         ? b - (1 - 2*c) * b * (1 - b)
         : b + (2*c - 1) * (bSL_D(b) - b);
}



function blendSoftLight(col, back, amount)
{
    return blendNormal(
        [ chanSoftLight(col[0], back[0]),
          chanSoftLight(col[1], back[1]),
          chanSoftLight(col[2], back[2]) ],
        back,
        amount);
}



function chanHardLight(c, b)
{
    if (c <= 0.5) return chanMultiply(b, 2 * c);
    else          return chanScreen(b, 2 * c - 1);
}



function blendHardLight(col, back, amount)
{
    return blendNormal(
        [ chanHardLight(col[0], back[0]),
          chanHardLight(col[1], back[1]),
          chanHardLight(col[2], back[2]) ],
        back,
        amount);
}



function blendDifference(col, back)
{
    return [ Math.abs(back[0] - col[0]),
             Math.abs(back[1] - col[1]),
             Math.abs(back[2] - col[2]) ];
}



function chanExclusion(c, b)
{
    return b + c - 2*b*c;
}



function blendExclusion(col, back, amount)
{
    return blendNormal(
        [ chanExclusion(col[0], back[0]),
          chanExclusion(col[1], back[1]),
          chanExclusion(col[2], back[2]) ],
        back,
        amount);
}



function bl_lum(col)
{
    return col[0] * 0.30
         + col[1] * 0.59
         + col[2] * 0.11;
}



function bl_setLum(_col, l)
{
    const col = [..._col];

    const d = l - bl_lum(col);

    col[0] += d;
    col[1] += d;
    col[2] += d;

    return bl_clamp(col);
}



function bl_sat(col)
{
    return Math.max(col[0], col[1], col[2]) 
         - Math.min(col[0], col[1], col[2]);
}



function bl_min(col)
{
         if (col[0] <= col[1] 
          && col[0] <= col[2]) return 0;
    else if (col[1] <= col[1] 
          && col[1] <= col[2]) return 1;
    else                       return 2;
}



function bl_mid(col)
{
         if (   col[0] >= col[1] 
             && col[0] <= col[2]
          ||    col[0] <= col[1] 
             && col[0] >= col[2]) return 0;
    else if (   col[1] >= col[0] 
             && col[1] <= col[2]
          ||    col[1] <= col[0] 
             && col[1] >= col[2]) return 1;
    else                          return 2;
}



function bl_max(col)
{
         if (col[0] >= col[1] 
          && col[0] >= col[2]) return 0;
    else if (col[1] >= col[1] 
          && col[1] >= col[2]) return 1;
    else                       return 2;
}



function bl_ndx(col) // get min/mid/max chan indices
{
    if (   col[0] == col[1] 
        && col[0] == col[2])
        return [0, 1, 2];

    else 
        return [
            bl_min(col), 
            bl_mid(col), 
            bl_max(col)];
}



function bl_setSat(_col, s)
{
    const col       = [..._col];
    const [n, d, x] = bl_ndx(col);

    if (col[x] > col[n])
    {
        col[d] = (((col[d] - col[n]) * s) / (col[x] - col[n]));
        col[x] = s;
    }
    else
        col[d] = col[x] = 0;

    col[n] = 0;

    return col;
}



function bl_chanClamp(c, l, n, x)
{
         if (n < 0) return l + (((c - l) * l) / (l - n));
    else if (x > 1) return l + (((c - l) * (1 - l)) / (x - l));
    else            return c;
}



function bl_clamp(col)
{
    const l   = bl_lum(col);

    const n = Math.min(col[0], col[1], col[2]);
    const x = Math.max(col[0], col[1], col[2]);

    return [ bl_chanClamp(col[0], l, n, x),
             bl_chanClamp(col[1], l, n, x),
             bl_chanClamp(col[2], l, n, x) ];
}



function blendHue(col, back, amount)
{
    return blendNormal(
        bl_setLum(bl_setSat(col, bl_sat(back)), bl_lum(back)),
        back,
        amount);
}



function blendSaturation(col, back, amount)
{
    return blendNormal(
        bl_setLum(bl_setSat(back, bl_sat(col)), bl_lum(back)),
        back,
        amount);
}



function blendColor(col, back, amount)
{
    return blendNormal(
        bl_setLum(col, bl_lum(back)),
        back,
        amount);
}



function blendLuminosity(col, back, amount)
{
    return blendNormal(
        bl_setLum(back, bl_lum(col)),
        back,
        amount);
}


class GColorStyle
extends GOperator
{
    id;

    colorStyle;
    genValue;

    //existing;
    linked;



    constructor(nodeId, options, styleId)
    {
        super(COLOR_STYLE, nodeId, options);

        this.id == styleId;
    }



    copy()
    {
        const copy = new GColorStyle(this.nodeId, this.options);

        copy.id = this.id;

        if (this.colorStyle) copy.colorStyle = this.colorStyle.copy();
        if (this.genValue  ) copy.genValue   = this.genValue  .copy();
        
      //copy.existing = this.existing;
        copy.linked   = this.linked;

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        this.value = await evalColorValue(this.genValue, parse);


        if (   this.value.isValid()
            && this.linked)
            // (  !this.existing
            //     || this.linked))
        {
            if (this.value.type == COLOR_VALUE)
                this.value = FillValue.fromRgb(scaleRgb(this.value.toRgb()), 0xff);

            const rgba       = this.value.toRgba();
            const rgbaStripe = rgb_a(getStripeBackColor(rgba), rgba[3]);

            this.evalStyle({rgba: rgbaStripe});
        }
        else
            this.value = FillValue.NaN.copy();


        this.setUpdateValues(parse,
        [
            ['value', this.value]
        ]);


        this.validate();

        return this;
    }



    evalStyle(options = {})
    {
        if (!this.options.enabled)
            return;

            
        const colorStyle = new FigmaColorStyle(this.nodeId, this.id, this.name);

        //colorStyle.existing = this.existing;


        colorStyle.paints = 
        [
            [ 'SOLID', 
                      Math.round(options.rgba[0] * 0xff)
              + ' ' + Math.round(options.rgba[1] * 0xff)
              + ' ' + Math.round(options.rgba[2] * 0xff)
              + ' ' + Math.round(options.rgba[3] * 100 ) ]
        ];


        this.colorStyle = colorStyle;
    }



    isValid()
    {
        return this.genValue && this.genValue.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.genValue) this.genValue.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.genValue) this.genValue.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.genValue) this.genValue.iterateLoop(parse);
    }
}


class GFill
extends GOperator1
{
    color   = null;
    opacity = null;
    blend   = null;



    constructor(nodeId, options)
    {
        super(FILL, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.color   = null;
        this.opacity = null;
        this.blend   = null;
    }



    copy()
    {
        const copy = new GFill(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.color  ) copy.color   = this.color  .copy();
        if (this.opacity) copy.opacity = this.opacity.copy();
        if (this.blend  ) copy.blend   = this.blend  .copy();

        return copy;
    }



    paramFromId(paramId)
    {
        switch (paramId)
        {
            case 'color':   return this.input ? this.value.color   : this.color;
            case 'opacity': return this.input ? this.value.opacity : this.opacity;
            case 'blend':   return this.input ? this.value.blend   : this.blend;
        }

        return null;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input   = await evalFillValue  (this.input,   parse);
        let   color   = await evalColorValue (this.color,   parse);
        let   opacity = await evalNumberValue(this.opacity, parse);
        let   blend   = await evalNumberValue(this.blend,   parse);


        if (input)
        {
            this.value = new FillValue(
                color   ?? input.color,
                opacity ?? input.opacity,
                blend   ?? input.blend);
        }
        else if ((!color   || color  .type == COLOR_VALUE )
              && (!opacity || opacity.type == NUMBER_VALUE)
              && (!blend   || blend  .type == NUMBER_VALUE))
        {
            this.value = new FillValue(
                color, 
                opacity,
                blend);
        }
        else
            this.value = FillValue.NaN.copy();


        this.setUpdateValues(parse,
        [
            ['value',   this.value],
            ['color',   color     ],
            ['opacity', opacity   ],
            ['blend',   blend     ]
        ]);
        

        // if (!this.color  ) this.color   = this.value.color  .copy();
        // if (!this.opacity) this.opacity = this.value.opacity.copy();
        // if (!this.blend  ) this.blend   = this.value.blend  .copy();


        this.validate();

        return this;
    }



    toValue()
    {
        return this.options.enabled
            ? new FillValue(
                this.color   ? this.color  .toValue() : this.input.value.color  .toValue(),
                this.opacity ? this.opacity.toValue() : this.input.value.opacity.toValue(),
                this.blend   ? this.blend  .toValue() : this.input.value.blend  .toValue())
            : FillValue.NaN.copy();
    }



    isValid()
    {
        return (!this.input || this.input.isValid())
            && this.color   && this.color  .isValid()
            && this.opacity && this.opacity.isValid()
            && this.blend   && this.blend  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.color  ) this.color  .pushValueUpdates(parse);
        if (this.opacity) this.opacity.pushValueUpdates(parse);
        if (this.blend  ) this.blend  .pushValueUpdates(parse);
    }
    
    
    
    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.color  ) this.color  .invalidateInputs(parse, from, force);
        if (this.opacity) this.opacity.invalidateInputs(parse, from, force);
        if (this.blend  ) this.blend  .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.color  ) this.color  .iterateLoop(parse);
        if (this.opacity) this.opacity.iterateLoop(parse);
        if (this.blend  ) this.blend  .iterateLoop(parse);
    }
}


class GColorStop
extends GOperator1
{
    fill     = null;
    position = null;



    constructor(nodeId, options)
    {
        super(COLOR_STOP, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.fill     = null;
        this.position = null;
    }



    copy()
    {
        const copy = new GColorStop(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.fill    ) copy.fill     = this.fill    .copy();
        if (this.position) copy.position = this.position.copy();

        return copy;
    }



    paramFromId(paramId)
    {
        switch (paramId)
        {
            case 'fill':      return this.input ? this.value.fill     : this.fill;
            case 'position':  return this.input ? this.value.position : this.position;
        }

        return null;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        
        
        const input    = await evalColorStopValue(this.input,    parse);
        let   fill     = await evalFillValue     (this.fill,     parse);
        const position = await evalNumberValue   (this.position, parse);
        
        fill = this.validateFill(fill);


        if (input)
        {
            this.value = new ColorStopValue(
                   fill 
                && fill.type != FILL_VALUE 
                    ? fill 
                    : input.fill,
                position ?? input.position);
        }
        else
        {
            this.value = new ColorStopValue(
                fill, 
                position);
        }


        this.setUpdateValues(parse, 
        [
            ['value', this.value]
        ]);
        

        if (!this.fill    ) this.fill     = this.value.fill    .copy();
        if (!this.position) this.position = this.value.position.copy();


        this.validate();

        return this;
    }



    validateFill(fill)
    {
        if (!fill)
            return null;


        if (fill.type == COLOR_VALUE)
            return FillValue.fromRgb(scaleRgb(fill.toRgb()), 100);
        else
            return fill;
    }



    toValue()
    {
        return new ColorStopValue(
            this.options.enabled
            ? this.validateFill(this.fill ? this.fill.toValue() : this.input.fill.toValue())
            : FillValue.NaN,
            this.position ? this.position.toValue() : this.input.position.toValue());
    }                 



    isValid()
    {
        return (!this.input || this.input.isValid())
            && this.fill     && this.fill    .isValid()
            && this.position && this.position.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.fill    ) this.fill    .pushValueUpdates(parse);
        if (this.position) this.position.pushValueUpdates(parse);
    }    

    
    
    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.fill    ) this.fill    .invalidateInputs(parse, from, force);
        if (this.position) this.position.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.fill    ) this.fill    .iterateLoop(parse);
        if (this.position) this.position.iterateLoop(parse);
    }
}


class GGradient
extends GOperator
{
    inputs = [];

    gradType = null;
    position = null;
    x        = null;
    y        = null;
    size     = null;
    angle    = null;
    aspect   = null;
    skew     = null;
    blend    = null;
    
    diagAspect;
    

    
    constructor(nodeId, options)
    {
        super(GRADIENT, nodeId, options);
    }
    
    
    
    reset()
    {
        super.reset();
        
        this.inputs = [];
    
        this.gradType = null;
        this.position = null;
        this.x        = null;
        this.y        = null;
        this.size     = null;
        this.angle    = null;
        this.aspect   = null;
        this.skew     = null;
        this.blend    = null;
    }



    copy()
    {
        const copy = new GGradient(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        if (this.gradType) copy.gradType = this.x       .copy();
        if (this.position) copy.position = this.position.copy();
        if (this.x       ) copy.x        = this.x       .copy();
        if (this.y       ) copy.y        = this.y       .copy();
        if (this.size    ) copy.size     = this.size    .copy();
        if (this.angle   ) copy.angle    = this.angle   .copy();
        if (this.aspect  ) copy.aspect   = this.aspect  .copy();
        if (this.skew    ) copy.skew     = this.skew    .copy();
        if (this.blend   ) copy.blend    = this.blend   .copy();

        return copy;
    }



    paramFromId(paramId)
    {
        switch (paramId)
        {
            case 'gradType':  return this.input ? this.value.gradType : this.gradType;
            case 'position':  return this.input ? this.value.position : this.position;
            case 'x':         return this.input ? this.value.x        : this.x;
            case 'y':         return this.input ? this.value.y        : this.y;
            case 'size':      return this.input ? this.value.size     : this.size;
            case 'angle':     return this.input ? this.value.angle    : this.angle;
            case 'aspect':    return this.input ? this.value.aspect   : this.aspect;
            case 'skew':      return this.input ? this.value.skew     : this.skew;
            case 'blend':     return this.input ? this.value.blend    : this.blend;
        }

        return null;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        let gradType = await evalNumberValue(this.gradType, parse);
        let position = await evalNumberValue(this.position, parse);
        let x        = await evalNumberValue(this.x,        parse);
        let y        = await evalNumberValue(this.y,        parse);
        let size     = await evalNumberValue(this.size,     parse);
        let angle    = await evalNumberValue(this.angle,    parse);
        let aspect   = await evalNumberValue(this.aspect,   parse);
        let skew     = await evalNumberValue(this.skew,     parse);
        let blend    = await evalNumberValue(this.blend,    parse);


        if (position) position.value = Math.min(Math.max(0, Math.floor(position.value)), 4);
        if (blend   ) blend   .value = Math.min(Math.max(0, Math.floor(blend   .value)), BlendModes.length-1);


        let stops = new ListValue();


        const inputs = [];
        
        for (const input of this.inputs)
            inputs.push(await evalValue(input, parse));


        if (   inputs.length == 1
            && inputs[0].type == GRADIENT_VALUE)
        {
            this.value        = inputs[0].toValue();
            this.value.nodeId = this.nodeId;
            this.value.copyCustomParams(inputs[0]);

            if (gradType)  this.value.gradType = gradType;  else  gradType = this.value.gradType;      
            if (position)  this.value.position = position;  else  position = this.value.position;      
            if (x       )  this.value.x        = x;         else  x        = this.value.x;      
            if (y       )  this.value.y        = y;         else  y        = this.value.y;      
            if (size    )  this.value.size     = size;      else  size     = this.value.size;      
            if (angle   )  this.value.angle    = angle;     else  angle    = this.value.angle;      
            if (aspect  )  this.value.aspect   = aspect;    else  aspect   = this.value.aspect;      
            if (skew    )  this.value.skew     = skew;      else  skew     = this.value.skew;      
            if (blend   )  this.value.blend    = blend;     else  blend    = this.value.blend;      
        }
        else
        {
            for (let i = 0, o = 0; i < inputs.length; i++)
            {
                const input = inputs[i];

                if (   input
                    && this.options.enabled)
                {
                    if (isListValueType(input.type))
                    {
                        for (const item of input.items)
                            if (item.isValid())
                                stops.items.push(item);
                    }
                    else if (input.type == GRADIENT_VALUE)
                    {
                        for (const item of input.stops.items)
                            stops.items.push(item);
                    }
                    else
                        if (input.isValid())
                            stops.items.push(input);
                }
            }


            stops.items = validateColorStops(stops.items);

            setColorStopPositions(stops.items);


            this.value = new GradientValue(
                stops,
                gradType,
                position,
                x, 
                y, 
                size, 
                angle, 
                aspect,
                this.diagAspect,
                skew,
                blend);
        }

        
        this.setUpdateValues(parse,
        [
            ['value',    this.value],
            ['gradType', gradType  ],
            ['position', position  ],
            ['x',        x         ],
            ['y',        y         ],
            ['size',     size      ],
            ['angle',    angle     ],
            ['aspect',   aspect    ],
            ['skew',     skew      ],
            ['blend',    blend     ]
        ]);
        

        if (   inputs.length == 1
            && inputs[0].type == GRADIENT_VALUE)
        {
            if (!this.gradType) this.gradType = this.value.gradType.copy();
            if (!this.position) this.position = this.value.position.copy();
            if (!this.x       ) this.x        = this.value.x       .copy();
            if (!this.y       ) this.y        = this.value.y       .copy();
            if (!this.size    ) this.size     = this.value.size    .copy();
            if (!this.angle   ) this.angle    = this.value.angle   .copy();
            if (!this.aspect  ) this.aspect   = this.value.aspect  .copy();
            if (!this.skew    ) this.skew     = this.value.skew    .copy();
            if (!this.blend   ) this.blend    = this.value.blend   .copy();
        }


        this.validate();

        return this;
    }

    
    
    toValue()
    {
        return this.value.copy();
    }                 



    isValid()
    {
        return !this.inputs.find(i => !i.isValid())
            && this.gradType && this.gradType.isValid()
            && this.position && this.position.isValid()
            && this.x        && this.x       .isValid()
            && this.y        && this.y       .isValid()
            && this.size     && this.size    .isValid()
            && this.angle    && this.angle   .isValid()
            && this.aspect   && this.aspect  .isValid()
            && this.skew     && this.skew    .isValid()
            && this.blend    && this.blend   .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse));

        if (this.gradType) this.gradType.pushValueUpdates(parse);
        if (this.position) this.position.pushValueUpdates(parse);
        if (this.x       ) this.x       .pushValueUpdates(parse);
        if (this.y       ) this.y       .pushValueUpdates(parse);
        if (this.size    ) this.size    .pushValueUpdates(parse);
        if (this.angle   ) this.angle   .pushValueUpdates(parse);
        if (this.aspect  ) this.aspect  .pushValueUpdates(parse);
        if (this.skew    ) this.skew    .pushValueUpdates(parse);
        if (this.blend   ) this.blend   .pushValueUpdates(parse);
    }    



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        this.inputs.forEach(i => i.invalidateInputs(parse, from, force));
        
        if (this.gradType) this.gradType.invalidateInputs(parse, from, force);
        if (this.position) this.position.invalidateInputs(parse, from, force);
        if (this.x       ) this.x       .invalidateInputs(parse, from, force);
        if (this.y       ) this.y       .invalidateInputs(parse, from, force);
        if (this.size    ) this.size    .invalidateInputs(parse, from, force);
        if (this.angle   ) this.angle   .invalidateInputs(parse, from, force);
        if (this.aspect  ) this.aspect  .invalidateInputs(parse, from, force);
        if (this.skew    ) this.skew    .invalidateInputs(parse, from, force);
        if (this.blend   ) this.blend   .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        this.inputs.forEach(i => i.iterateLoop(parse));

        if (this.gradType) this.gradType.iterateLoop(parse);
        if (this.position) this.position.iterateLoop(parse);
        if (this.x       ) this.x       .iterateLoop(parse);
        if (this.y       ) this.y       .iterateLoop(parse);
        if (this.size    ) this.size    .iterateLoop(parse);
        if (this.angle   ) this.angle   .iterateLoop(parse);
        if (this.aspect  ) this.aspect  .iterateLoop(parse);
        if (this.skew    ) this.skew    .iterateLoop(parse);
        if (this.blend   ) this.blend   .iterateLoop(parse);
    }    
}


class GStroke
extends GOperator1
{
    fills  = null;
   _fills  = null; // actual fills that might need to be converted to a list, in case it's a color or a fill
    weight = null;
    fit    = null;
    join   = null;
    miter  = null;
    cap    = null;
    dashes = null;
    
    

    constructor(nodeId, options)
    {
        super(STROKE, nodeId, options);
    }
    

    
    reset()
    {
        super.reset();
        
        this. fills  = null;
        this._fills  = null; // actual fills that might need to be converted to a list, in case it's a color or a fill
        this. weight = null;
        this. fit    = null;
        this. join   = null;
        this. miter  = null;
        this. cap    = null;
        this. dashes = null;
    }



    copy()
    {
        const copy = new GStroke(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.fills ) copy. fills  = this.fills .copy();
        if (this._fills) copy._fills  = this._fills.copy();
        if (this.weight) copy. weight = this.weight.copy();
        if (this.fit   ) copy. fit    = this.fit   .copy();
        if (this.join  ) copy. join   = this.join  .copy();
        if (this.miter ) copy. miter  = this.miter .copy();
        if (this.cap   ) copy. cap    = this.cap   .copy();
        if (this.dashes) copy. dashes = this.dashes.copy();

        return copy;
    }



    paramFromId(paramId)
    {
        switch (paramId)
        {
            case 'fills ':  return this.input ? this.value.fills  : this.fills;
            case 'weight':  return this.input ? this.value.weight : this.weight;
            case 'fit':     return this.input ? this.value.fit    : this.fit;
            case 'join':    return this.input ? this.value.join   : this.join;
            case 'miter':   return this.input ? this.value.miter  : this.miter;
            case 'cap':     return this.input ? this.value.cap    : this.cap;
            case 'dashes':  return this.input ? this.value.dashes : this.dashes;
        }

        return null;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        const input = await evalStrokeValue(this. input, parse);
        let   fills = await evalListValue  (this._fills, parse);

        fills = this.validateFills(fills);

        if (!isListValueType(this._fills.type))
            this.fills = fills;


        const weight = await evalNumberValue(this.weight, parse);
        const fit    = await evalNumberValue(this.fit,    parse);
        const join   = await evalNumberValue(this.join,   parse);
        const miter  = await evalNumberValue(this.miter,  parse);
        const cap    = await evalNumberValue(this.cap,    parse);
        const dashes = await evalTextValue  (this.dashes, parse);


        if (input)
        {
            this.value = new StrokeValue(
                fills  ?? input.fills,
                weight ?? input.weight,
                fit    ?? input.fit,
                join   ?? input.join,
                miter  ?? input.miter,
                cap    ?? input.cap,
                dashes ?? input.dashes);
        }
        else
        {
            this.value = new StrokeValue(
                fills, 
                weight, 
                fit, 
                join,
                miter,
                cap,
                dashes);
        }


        this.setUpdateValues(parse,
        [
            ['value',  this.value],
            ['fills',  fills     ],
            ['weight', weight    ],
            ['fit',    fit       ],
            ['join',   join      ],
            ['miter',  miter     ],
            ['cap',    cap       ],
            ['dashes', dashes    ]
        ]);


        this.validate();

        return this;
    }



    validateFills(fills)
    {            
        if (!fills)
            return null;

        if (fills.type == COLOR_VALUE)
            return new ListValue([FillValue.fromRgb(scaleRgb(fills.toRgb()), 100)]);

        else if (fills.type ==     FILL_VALUE
              || fills.type == GRADIENT_VALUE)
            return new ListValue([fills]);
        else
        {
            consoleAssert(fills.type == LIST_VALUE, 'stroke.fills must be a LIST_VALUE');

            for (let i = 0; i < fills.items.length; i++)
            {
                if (fills.items[i].type == COLOR_VALUE)
                    fills.items[i] = new FillValue(fills.items[i]);
            }

            return fills;
        }
    }



    toValue()
    {
        return new StrokeValue(
            this.options.enabled
            ? this.validateFills(this.fills ? this.fills.toValue() : this.input.fills.toValue())
            : new ListValue(),
            this.weight ? this.weight.toValue() : this.input.weight.toValue(),
            this.fit    ? this.fit   .toValue() : this.input.fit   .toValue(),
            this.join   ? this.join  .toValue() : this.input.join  .toValue(),
            this.miter  ? this.miter .toValue() : this.input.miter .toValue(),
            this.cap    ? this.cap   .toValue() : this.input.cap   .toValue(),
            this.dashes ? this.dashes.toValue() : this.input.dashes.toValue());
    }                 



    isValid()
    {
        return (!this.input || this.input.isValid())
            && this.fills  && this.fills .isValid()
            && this.weight && this.weight.isValid()
            && this.fit    && this.fit   .isValid()
            && this.join   && this.join  .isValid()
            && this.miter  && this.miter .isValid()
            && this.cap    && this.cap   .isValid()
            && this.dashes && this.dashes.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this._fills) this._fills.pushValueUpdates(parse);
        if (this.weight) this.weight.pushValueUpdates(parse);
        if (this.fit   ) this.fit   .pushValueUpdates(parse);
        if (this.join  ) this.join  .pushValueUpdates(parse);
        if (this.miter ) this.miter .pushValueUpdates(parse);
        if (this.cap   ) this.cap   .pushValueUpdates(parse);
        if (this.dashes) this.dashes.pushValueUpdates(parse);
    }    
    
    

    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this._fills) this._fills.invalidateInputs(parse, from, force);
        if (this.weight) this.weight.invalidateInputs(parse, from, force);
        if (this.fit   ) this.fit   .invalidateInputs(parse, from, force);
        if (this.join  ) this.join  .invalidateInputs(parse, from, force);
        if (this.miter ) this.miter .invalidateInputs(parse, from, force);
        if (this.cap   ) this.cap   .invalidateInputs(parse, from, force);
        if (this.dashes) this.dashes.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this._fills) this._fills.iterateLoop(parse);
        if (this.weight) this.weight.iterateLoop(parse);
        if (this.fit   ) this.fit   .iterateLoop(parse);
        if (this.join  ) this.join  .iterateLoop(parse);
        if (this.miter ) this.miter .iterateLoop(parse);
        if (this.cap   ) this.cap   .iterateLoop(parse);
        if (this.dashes) this.dashes.iterateLoop(parse);
    }    
}


class GStrokeSides
extends GOperator1
{
    top    = null;
    left   = null;
    right  = null;
    bottom = null;
    
    

    constructor(nodeId, options)
    {
        super(STROKE_SIDES, nodeId, options);
    }

    
    
    reset()
    {
        super.reset();
        
        this.top    = null;
        this.left   = null;
        this.right  = null;
        this.bottom = null;
    }



    copy()
    {
        const copy = new GStrokeSides(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.top   ) copy.top    = this.top   .copy();
        if (this.left  ) copy.left   = this.left  .copy();
        if (this.right ) copy.right  = this.right .copy();
        if (this.bottom) copy.bottom = this.bottom.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input  = await evalStrokeSidesValue(this.input,  parse);
        const top    = await evalNumberValue     (this.top,    parse);
        const left   = await evalNumberValue     (this.left,   parse);
        const right  = await evalNumberValue     (this.right,  parse);
        const bottom = await evalNumberValue     (this.bottom, parse);


        if (input)
        {
            this.value = new StrokeSidesValue(
                top    ?? input.top,
                left   ?? input.left,
                right  ?? input.right,
                bottom ?? input.bottom,
                this.options.enabled);
        }
        else
        {
            this.value = new StrokeSidesValue(
                top, 
                left, 
                right, 
                bottom,
                this.options.enabled);
        }


        this.setUpdateValues(parse,
        [
            ['top',    this.value.top   ],
            ['left',   this.value.left  ],
            ['right',  this.value.right ],
            ['bottom', this.value.bottom]
        ]);
        

        if (!this.top   ) this.top    = this.value.top   .copy();
        if (!this.left  ) this.left   = this.value.left  .copy();
        if (!this.right ) this.right  = this.value.right .copy();
        if (!this.bottom) this.bottom = this.value.bottom.copy();


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return super.isValid()
            && this.top    && this.top   .isValid()
            && this.left   && this.left  .isValid()
            && this.right  && this.right .isValid()
            && this.bottom && this.bottom.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.top   ) this.top   .pushValueUpdates(parse);
        if (this.left  ) this.left  .pushValueUpdates(parse);
        if (this.right ) this.right .pushValueUpdates(parse);
        if (this.bottom) this.bottom.pushValueUpdates(parse);
    }
    
    
    
   invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.top   ) this.top   .invalidateInputs(parse, from, force);
        if (this.left  ) this.left  .invalidateInputs(parse, from, force);
        if (this.right ) this.right .invalidateInputs(parse, from, force);
        if (this.bottom) this.bottom.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.top   ) this.top   .iterateLoop(parse);
        if (this.left  ) this.left  .iterateLoop(parse);
        if (this.right ) this.right .iterateLoop(parse);
        if (this.bottom) this.bottom.iterateLoop(parse);
    }
}


class GRoundCorners
extends GOperator1
{
    tl = null;
    tr = null;
    bl = null;
    br = null;
    
    

    constructor(nodeId, options)
    {
        super(ROUND_CORNERS, nodeId, options);
    }

    
    
    reset()
    {
        super.reset();
        
        this.tl = null;
        this.tr = null;
        this.bl = null;
        this.br = null;
    }



    copy()
    {
        const copy = new GRoundCorners(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.tl) copy.tl = this.tl.copy();
        if (this.tr) copy.tr = this.tr.copy();
        if (this.bl) copy.bl = this.bl.copy();
        if (this.br) copy.br = this.br.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input = await evalRoundedCornersValue(this.input, parse);
        const tl    = await evalNumberValue        (this.tl,    parse);
        const tr    = await evalNumberValue        (this.tr,    parse);
        const bl    = await evalNumberValue        (this.bl,    parse);
        const br    = await evalNumberValue        (this.br,    parse);


        if (input)
        {
            this.value = new RoundCornersValue(
                tl ?? input.tl,
                tr ?? input.tr,
                bl ?? input.bl,
                br ?? input.br,
                this.options.enabled);
        }
        else
        {
            this.value = new RoundCornersValue(
                tl, 
                tr, 
                bl, 
                br,
                this.options.enabled);
        }


        this.setUpdateValues(parse,
        [
            ['tl', this.value.tl],
            ['tr', this.value.tr],
            ['bl', this.value.bl],
            ['br', this.value.br]
        ]);
        

        if (!this.tl) this.tl = this.value.tl.copy();
        if (!this.tr) this.tr = this.value.tr.copy();
        if (!this.bl) this.bl = this.value.bl.copy();
        if (!this.br) this.br = this.value.br.copy();


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return super.isValid()
            && this.tl && this.tl.isValid()
            && this.tr && this.tr.isValid()
            && this.bl && this.bl.isValid()
            && this.br && this.br.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.tl) this.tl.pushValueUpdates(parse);
        if (this.tr) this.tr.pushValueUpdates(parse);
        if (this.bl) this.bl.pushValueUpdates(parse);
        if (this.br) this.br.pushValueUpdates(parse);
    }
    
    
    
   invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.tl) this.tl.invalidateInputs(parse, from, force);
        if (this.tr) this.tr.invalidateInputs(parse, from, force);
        if (this.bl) this.bl.invalidateInputs(parse, from, force);
        if (this.br) this.br.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.tl) this.tl.iterateLoop(parse);
        if (this.tr) this.tr.iterateLoop(parse);
        if (this.bl) this.bl.iterateLoop(parse);
        if (this.br) this.br.iterateLoop(parse);
    }
}


class GDropShadow
extends GOperator1
{
    x      = null;
    y      = null;
    blur   = null;
    spread = null;
    fill   = null;
    blend  = null;
    behind = null;
    
    

    constructor(nodeId, options)
    {
        super(DROP_SHADOW, nodeId, options);
    }

    
    
    reset()
    {
        super.reset();
        
        this.x      = null;
        this.y      = null;
        this.blur   = null;
        this.spread = null;
        this.fill   = null;
        this.blend  = null;
        this.behind = null;
    }



    copy()
    {
        const copy = new GDropShadow(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.x     ) copy.x      = this.x     .copy();
        if (this.y     ) copy.y      = this.y     .copy();
        if (this.blur  ) copy.blur   = this.blur  .copy();
        if (this.spread) copy.spread = this.spread.copy();
        if (this.fill  ) copy.fill   = this.fill  .copy();
        if (this.blend ) copy.blend  = this.blend .copy();
        if (this.behind) copy.behind = this.behind.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input  = await evalValue      (this.input,  parse);
        const x      = await evalNumberValue(this.x,      parse);
        const y      = await evalNumberValue(this.y,      parse);
        const blur   = await evalNumberValue(this.blur,   parse);
        const spread = await evalNumberValue(this.spread, parse);
        let   fill   = await evalFillValue  (this.fill,   parse);
        const blend  = await evalNumberValue(this.blend,  parse);
        const behind = await evalNumberValue(this.behind, parse);


        if (   fill
            && fill.type == COLOR_VALUE)
            fill = new FillValue(fill);

        
        if (input)
        {
            this.value = new DropShadowValue(
                x      ?? input.x,
                y      ?? input.y,
                blur   ?? input.blur,
                spread ?? input.spread,
                fill   ?? input.fill,
                blend  ?? input.blend,
                behind ?? input.behind,
                this.options.enabled);
        }
        else
        {
            this.value = new DropShadowValue(
                x, 
                y, 
                blur, 
                spread, 
                fill, 
                blend, 
                behind,
                this.options.enabled);
        }


        this.setUpdateValues(parse,
        [
            ['x',      this.value.x     ],
            ['y',      this.value.y     ],
            ['blur',   this.value.blur  ],
            ['spread', this.value.spread],
            ['fill',   this.value.fill  ],
            ['blend',  this.value.blend ],
            ['behind', this.value.behind]
        ]);
        

        if (!this.x     ) this.x      = this.value.x     .copy();
        if (!this.y     ) this.y      = this.value.y     .copy();
        if (!this.blur  ) this.blur   = this.value.blur  .copy();
        if (!this.spread) this.spread = this.value.spread.copy();
        if (!this.fill  ) this.fill   = this.value.fill  .copy();
        if (!this.blend ) this.blend  = this.value.blend .copy();
        if (!this.behind) this.behind = this.value.behind.copy();


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return super.isValid()
            && this.x      && this.x     .isValid()
            && this.y      && this.y     .isValid()
            && this.blur   && this.blur  .isValid()
            && this.spread && this.spread.isValid()
            && this.fill   && this.fill  .isValid()
            && this.blend  && this.blend .isValid()
            && this.behind && this.behind.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.x     ) this.x     .pushValueUpdates(parse);
        if (this.y     ) this.y     .pushValueUpdates(parse);
        if (this.blur  ) this.blur  .pushValueUpdates(parse);
        if (this.spread) this.spread.pushValueUpdates(parse);
        if (this.fill  ) this.fill  .pushValueUpdates(parse);
        if (this.blend ) this.blend .pushValueUpdates(parse);
        if (this.behind) this.behind.pushValueUpdates(parse);
    }
    
    
    
   invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.x     ) this.x     .invalidateInputs(parse, from, force);
        if (this.y     ) this.y     .invalidateInputs(parse, from, force);
        if (this.blur  ) this.blur  .invalidateInputs(parse, from, force);
        if (this.spread) this.spread.invalidateInputs(parse, from, force);
        if (this.fill  ) this.fill  .invalidateInputs(parse, from, force);
        if (this.blend ) this.blend .invalidateInputs(parse, from, force);
        if (this.behind) this.behind.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.x     ) this.x     .iterateLoop(parse);
        if (this.y     ) this.y     .iterateLoop(parse);
        if (this.blur  ) this.blur  .iterateLoop(parse);
        if (this.spread) this.spread.iterateLoop(parse);
        if (this.fill  ) this.fill  .iterateLoop(parse);
        if (this.blend ) this.blend .iterateLoop(parse);
        if (this.behind) this.behind.iterateLoop(parse);
    }
}


class GInnerShadow
extends GOperator1
{
    x      = null;
    y      = null;
    blur   = null;
    spread = null;
    fill   = null;
    blend  = null;
    
    

    constructor(nodeId, options)
    {
        super(INNER_SHADOW, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.x      = null;
        this.y      = null;
        this.blur   = null;
        this.spread = null;
        this.fill   = null;
        this.blend  = null;
    }



    copy()
    {
        const copy = new GInnerShadow(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.x     ) copy.x      = this.x     .copy();
        if (this.y     ) copy.y      = this.y     .copy();
        if (this.blur  ) copy.blur   = this.blur  .copy();
        if (this.spread) copy.spread = this.spread.copy();
        if (this.fill  ) copy.fill   = this.fill  .copy();
        if (this.blend ) copy.blend  = this.blend .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input  = await evalInnerShadowValue(this.input,  parse);
        const x      = await evalNumberValue     (this.x,      parse);
        const y      = await evalNumberValue     (this.y,      parse);
        const blur   = await evalNumberValue     (this.blur,   parse);
        const spread = await evalNumberValue     (this.spread, parse);
        let   fill   = await evalFillValue       (this.fill,   parse);
        const blend  = await evalNumberValue     (this.blend,  parse);

        
        if (   fill
            && fill.type == COLOR_VALUE)
            fill = new FillValue(fill);


        if (input)
        {
            this.value = new InnerShadowValue(
                x      ?? input.x,
                y      ?? input.y,
                blur   ?? input.blur,
                spread ?? input.spread,
                fill   ?? input.fill,
                blend  ?? input.blend,
                this.options.enabled);
        }
        else
        {
            this.value = new InnerShadowValue(
                x, 
                y, 
                blur, 
                spread, 
                fill, 
                blend,
                this.options.enabled);
        }


        this.setUpdateValues(parse,
        [
            ['x',      this.value.x     ],
            ['y',      this.value.y     ],
            ['blur',   this.value.blur  ],
            ['spread', this.value.spread],
            ['fill',   this.value.fill  ],
            ['blend',  this.value.blend ],
        ]);
        

        if (!this.x     ) this.x      = this.value.x     .copy();
        if (!this.y     ) this.y      = this.value.y     .copy();
        if (!this.blur  ) this.blur   = this.value.blur  .copy();
        if (!this.spread) this.spread = this.value.spread.copy();
        if (!this.fill  ) this.fill   = this.value.fill  .copy();
        if (!this.blend ) this.blend  = this.value.blend .copy();


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return super.isValid()
            && this.x      && this.x     .isValid()
            && this.y      && this.y     .isValid()
            && this.blur   && this.blur  .isValid()
            && this.spread && this.spread.isValid()
            && this.fill   && this.fill  .isValid()
            && this.blend  && this.blend .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.x     ) this.x     .pushValueUpdates(parse);
        if (this.y     ) this.y     .pushValueUpdates(parse);
        if (this.blur  ) this.blur  .pushValueUpdates(parse);
        if (this.spread) this.spread.pushValueUpdates(parse);
        if (this.fill  ) this.fill  .pushValueUpdates(parse);
        if (this.blend ) this.blend .pushValueUpdates(parse);
    }
    
    
    
    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.x     ) this.x     .invalidateInputs(parse, from, force);
        if (this.y     ) this.y     .invalidateInputs(parse, from, force);
        if (this.blur  ) this.blur  .invalidateInputs(parse, from, force);
        if (this.spread) this.spread.invalidateInputs(parse, from, force);
        if (this.fill  ) this.fill  .invalidateInputs(parse, from, force);
        if (this.blend ) this.blend .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.x     ) this.x     .iterateLoop(parse);
        if (this.y     ) this.y     .iterateLoop(parse);
        if (this.blur  ) this.blur  .iterateLoop(parse);
        if (this.spread) this.spread.iterateLoop(parse);
        if (this.fill  ) this.fill  .iterateLoop(parse);
        if (this.blend ) this.blend .iterateLoop(parse);
    }
}


class GLayerBlur
extends GOperator1
{
    radius = null;



    constructor(nodeId, options)
    {
        super(LAYER_BLUR, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.radius = null;
    }



    copy()
    {
        const copy = new GLayerBlur(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.radius) copy.radius = this.radius.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input  = await evalLayerBlurValue(this.input,  parse);
        const radius = await evalNumberValue   (this.radius, parse);

        
        if (input)
        {
            this.value = new LayerBlurValue(
                radius ?? input.radius,
                this.options.enabled);
        }
        else
        {
            this.value = new LayerBlurValue(
                radius,
                this.options.enabled);
        }


        this.setUpdateValues(parse,
        [
            ['radius', this.value.radius]
        ]);
        

        if (!this.radius) this.radius = this.value.radius.copy();


        this.validate();

        return this;
    }



    toValue()
    {
        return new LayerBlurValue(
            this.radius ? this.radius.toValue() : this.input.radius.toValue(),
            this.options.enabled);
    }



    isValid()
    {
        return super.isValid()
            && this.radius && this.radius.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.radius) this.radius.pushValueUpdates(parse);
    }
    
    
    
    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.radius) this.radius.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.radius) this.radius.iterateLoop(parse);
    }
}


class GBackBlur
extends GOperator1
{
    radius = null;



    constructor(nodeId, options)
    {
        super(BACK_BLUR, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.radius = null;
    }



    copy()
    {
        const copy = new GBackBlur(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.radius) copy.radius = this.radius.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input  = await evalValue      (this.input,  parse);
        const radius = await evalNumberValue(this.radius, parse);

        
        if (input)
        {
            this.value = new BackBlurValue(
                radius ?? input.radius,
                this.options.enabled);
        }
        else
        {
            this.value = new BackBlurValue(
                radius,
                this.options.enabled);
        }


        this.setUpdateValues(parse,
        [
            ['radius', this.value.radius]
        ]);
        

        if (!this.radius) this.radius = this.value.radius.copy();


        this.validate();

        return this;
    }



    toValue()
    {
        return new BackBlurValue(
            this.radius ? this.radius.toValue() : this.input.radius.toValue(),
            this.options.enabled);
    }



    isValid()
    {
        return super.isValid()
            && this.radius && this.radius.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.radius) this.radius.pushValueUpdates(parse);
    }
    
    
    
    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.radius) this.radius.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.radius) this.radius.iterateLoop(parse);
    }
}


class GLayerBlend
extends GOperator
{
    opacity;
    blend;



    constructor(nodeId, options)
    {
        super(LAYER_BLEND, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.opacity = null;
        this.blend   = null;
    }



    copy()
    {
        const copy = new GLayerBlend(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.opacity) copy.opacity = this.opacity.copy();
        if (this.blend  ) copy.blend   = this.blend  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const opacity = await evalNumberValue(this.opacity, parse);
        const blend   = await evalNumberValue(this.blend,   parse);


        this.value = 
            this.options.enabled
            ? new LayerBlendValue(opacity, blend)
            : new LayerBlendValue(new NumberValue(100), new NumberValue(0));


        this.setUpdateValues(parse, 
        [
            ['opacity', opacity],
            ['blend',   blend  ]
        ]);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value.copy();
    }



    isValid()
    {
        return this.opacity && this.opacity.isValid()
            && this.blend   && this.blend  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.opacity) this.opacity.pushValueUpdates(parse);
        if (this.blend  ) this.blend  .pushValueUpdates(parse);
    }
    
    
    
    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.opacity) this.opacity.invalidateInputs(parse, from, force);
        if (this.blend  ) this.blend  .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.opacity) this.opacity.iterateLoop(parse);
        if (this.blend  ) this.blend  .iterateLoop(parse);
    }
}


class GLayerMask
extends GOperator
{
    maskType;



    constructor(nodeId, options)
    {
        super(LAYER_MASK, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.maskType = null;
    }



    copy()
    {
        const copy = new GLayerMask(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.maskType) copy.maskType = this.maskType.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const maskType = await evalNumberValue(this.maskType, parse);


        this.value = new LayerMaskValue(maskType, this.options.enabled);


        this.setUpdateValues(parse, 
        [
            ['maskType', maskType]
        ]);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value.copy();
    }



    isValid()
    {
        return this.maskType && this.maskType.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.maskType) this.maskType.pushValueUpdates(parse);
    }
    
    
    
    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.maskType) this.maskType.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.maskType) this.maskType.iterateLoop(parse);
    }
}


class GShapeBase
extends GOperator
{
    x      = null;
    y      = null;
    width  = null;
    height = null;



    constructor(type, nodeId, options)
    {
        super(type, nodeId, options);
    }



    reset()
    {
        super.reset();
        
        this.x      = null;
        this.y      = null;
        this.width  = null;
        this.height = null;
    }



    copyBase(base)
    {
        super.copyBase(base);

        if (base.x     ) this.x      = base.x     .copy();
        if (base.y     ) this.y      = base.y     .copy();
        if (base.width ) this.width  = base.width .copy();
        if (base.height) this.height = base.height.copy();
    }



    async evalBaseParams(parse, evalHeight = true)
    {
        let x      =              await evalNumberValue(this.x,      parse);
        let y      =              await evalNumberValue(this.y,      parse);
        let width  =              await evalNumberValue(this.width,  parse);
        let height = evalHeight ? await evalNumberValue(this.height, parse) : null;

        return [x, y, width, height];
    }



    evalStyle(options = {})
    {
        // for (const style of this.styles)
        //     style.nodeId = this.nodeId;
    }



    isValid()
    {
        return this.x      && this.x     .isValid()
            && this.y      && this.y     .isValid()
            && this.width  && this.width .isValid()
            && this.height && this.height.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.x     ) this.x     .pushValueUpdates(parse);
        if (this.y     ) this.y     .pushValueUpdates(parse);
        if (this.width ) this.width .pushValueUpdates(parse);
        if (this.height) this.height.pushValueUpdates(parse);
    }


    
    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.x     ) this.x     .invalidateInputs(parse, from, force);
        if (this.y     ) this.y     .invalidateInputs(parse, from, force);
        if (this.width ) this.width .invalidateInputs(parse, from, force);
        if (this.height) this.height.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.x     ) this.x     .iterateLoop(parse);
        if (this.y     ) this.y     .iterateLoop(parse);
        if (this.width ) this.width .iterateLoop(parse);
        if (this.height) this.height.iterateLoop(parse);
    }
}



function validateObjectRect(x, y, w, h, a = 0, _a = 0)
{
    if (w < 0)
    {
        x += w * Math.cos(_a);
        y += w * Math.sin(_a);
    }

    if (h < 0)
    {
        y += h * Math.cos(_a);
        x -= h * Math.sin(_a);
    }
  
    
    w = Math.abs(w);
    h = Math.abs(h);


    return [x, y, w, h, a, _a];
}


class GShape
extends GShapeBase
{
    input = null;

    props = null;
   


    constructor(type, nodeId, options)
    {
        super(type, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.input = null;
        this.props = null;
    }



    copyBase(base)
    {
        super.copyBase(base);
        
        if (base.input) this.input = base.input.copy();
        if (base.props) this.props = base.props.copy();
    }



    paramFromId(paramId)
    {
        switch (paramId)
        {
            case 'props':  return this.input ? this.value.props : this.props;
        }

        return null;
    }



    baseIsValid()
    {
        return this.value
            && this.value.props
            && this.value.props.isValid();
    }



    isCached()
    {
        return super.isCached()
            && (  !this.input 
                || this.input.isCached());
    }



    async evalShapeBase(parse)
    {
        let props = await evalListValue(this.props, parse);

        if (   props
            && STYLE_VALUES.includes(props.type))
            props = new ListValue([props]);

        
        if (this.value)
        {
            if (this.input)
            {
                this.value.props = props ?? this.input.toValue().props;
                
                if (props)  this.value.props = props;  else  props = this.value.props;  
            }
            else
                this.value.props = props;

                    
            if (   this.value
                && this.value.isValid()
                && this.value.props != undefined) 
            {
                this.setUpdateValues(parse, 
                [
                    //['props', props]
                ], 
                true);

                
                if (!this.props) this.props = this.value.props.copy();
            }
        }
    }



    async evalObjects(parse)
    {
        if (!this.value)
            return;


        for (const obj of this.value.objects)
        {
            consoleAssert(obj.fills,   'obj.fills   must not be null');
            consoleAssert(obj.strokes, 'obj.strokes must not be null');
            consoleAssert(obj.effects, 'obj.effects must not be null');


            if (this.value.props)
                addProps(obj, this.value.props);
        }
    }



    evalStyle(options = {})
    {

    }



    isValid()
    {
        return super.isValid()
            && (!this.input || this.input.isValid())
            && this.props && this.props.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input) this.input.pushValueUpdates(parse);
        if (this.props) this.props.pushValueUpdates(parse);
    }


    
    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.input) this.input.invalidateInputs(parse, from, force);
        if (this.props) this.props.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input) this.input.iterateLoop(parse);
        if (this.props) this.props.iterateLoop(parse);
    }
}



function addProps(obj, props)
{
    if (isListValueType(props.type))
    {               
        for (let i = 0; i < props.items.length; i++)
            addProp(obj, props.items[i]);
    }
    else
        addProp(obj, props);
}


class GRectangle
extends GShape
{
    round = null;



    constructor(nodeId, options)
    {
        super(RECTANGLE, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.round = null;
    }



    copy()
    {
        const copy = new GRectangle(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.round) copy.round = this.round.copy();

        return copy;
    }



    paramFromId(paramId)
    {
        switch (paramId)
        {
            case 'x':      return this.input ? this.value.x      : this.x;
            case 'y':      return this.input ? this.value.y      : this.y;
            case 'width':  return this.input ? this.value.width  : this.width;
            case 'height': return this.input ? this.value.height : this.height;
            case 'round':  return this.input ? this.value.round  : this.round;
        }

        return super.paramFromId(paramId);
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input = await evalRectangleValue(this.input, parse);
        let   round = await evalNumberValue   (this.round, parse);

        if (round && !round.isValid()) round = NumberValue.NaN.copy();

        
        let [x, y, width, height] = await this.evalBaseParams(parse);


        if (input)
        {
            this.value        = input.toValue();
            this.value.nodeId = this.nodeId;
            
            this.value.copyCustomParams(input);
            
            if (x     )  this.value.x      = x;       else  x      = this.value.x;      
            if (y     )  this.value.y      = y;       else  y      = this.value.y;      
            if (width )  this.value.width  = width;   else  width  = this.value.width;  
            if (height)  this.value.height = height;  else  height = this.value.height; 
            if (round )  this.value.round  = round;   else  round  = this.value.round;  
        }
        else
        {
            this.value = new RectangleValue(
                this.nodeId, 
                x, 
                y, 
                width, 
                height, 
                round);
        }

       
        this.setUpdateValues(parse, 
        [
            ['x',      x     ],
            ['y',      y     ],
            ['width',  width ],
            ['height', height],
            ['round',  round ]
        ]);


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        if (!this.x     ) this.x      = this.value.x     .copy();
        if (!this.y     ) this.y      = this.value.y     .copy();
        if (!this.width ) this.width  = this.value.width .copy();
        if (!this.height) this.height = this.value.height.copy();
        if (!this.round ) this.round  = this.value.round .copy();


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
     
        
        this.value.objects = [];


        if (   super.baseIsValid()   
            && this.value.x     .isValid()
            && this.value.y     .isValid()
            && this.value.width .isValid()
            && this.value.height.isValid()
            && this.value.round .isValid())
        {
            let   x = this.value.x     .value;
            let   y = this.value.y     .value;
            let   w = this.value.width .value;
            let   h = this.value.height.value;
            const r = Math.max(0, this.value.round.value);


            [x, y, w, h, , ] = validateObjectRect(x, y, w, h);


            if (   w != 0 
                && h != 0)
            {
                const rect = new FigmaRectangle(
                    this.nodeId,
                    this.nodeId,
                    this.nodeName,
                    x, y, w, h, r);

                rect.createDefaultTransform(x, y);
                rect.createDefaultTransformPoints(x, y, w, h);

                this.value.objects.push(rect);
            }
        }

        
        await super.evalObjects(parse);
    }



    // toValue()
    // {
    //     const rect = new RectangleValue(
    //         this.nodeId,
    //         this.x     .toValue(),
    //         this.y     .toValue(),
    //         this.width .toValue(),
    //         this.height.toValue(),
    //         this.round .toValue());

    //     rect.copyCustomParams(this.value);

    //     rect.props   = this.props.toValue();
    //     rect.objects = this.value.objects.map(o => o.copy());

    //     return rect;
    // }



    isValid()
    {
        return super.isValid()
            && this.round && this.round.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.round) this.round.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.round) this.round.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.round) this.round.iterateLoop(parse);
    }
}


class GLine
extends GShape
{
    constructor(nodeId, options)
    {
        super(LINE, nodeId, options);
    }



    copy()
    {
        const copy = new GLine(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    paramFromId(paramId)
    {
        switch (paramId)
        {
            case 'x':     return this.input ? this.value.x     : this.x;
            case 'y':     return this.input ? this.value.y     : this.y;
            case 'width': return this.input ? this.value.width : this.width;
        }

        return super.paramFromId(paramId);
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        let input = await evalLineValue(this.input, parse);

        let [x, y, width, ] = await this.evalBaseParams(parse, false);
            

        if (input)
        {
            this.value        = input.toValue();
            this.value.nodeId = this.nodeId;
            this.value.copyCustomParams(input);

            if (x    )  this.value.x     = x;      else  x     = this.value.x;      
            if (y    )  this.value.y     = y;      else  y     = this.value.y;      
            if (width)  this.value.width = width;  else  width = this.value.width;  
        }
        else
        {
            this.value = new LineValue(
                this.nodeId, 
                x, 
                y, 
                width);
        }


        this.setUpdateValues(parse, 
        [
            ['x',      x     ],
            ['y',      y     ],
            ['width',  width ]
        ]);


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        if (!this.x    ) this.x     = this.value.x    .copy();
        if (!this.y    ) this.y     = this.value.y    .copy();
        if (!this.width) this.width = this.value.width.copy();


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            

        this.value.objects = [];


        if (   super.baseIsValid()   
            && this.value.x    .isValid()
            && this.value.y    .isValid()
            && this.value.width.isValid()) 
        {
            let x = this.value.x    .value;
            let y = this.value.y    .value;
            let w = this.value.width.value;


            [x, y, w, , , ] = validateObjectRect(x, y, w, 0);


            if (w != 0)
            {
                const line = new FigmaLine(
                    this.nodeId,
                    this.nodeId,
                    this.nodeName,
                    x, y, w);

                line.createDefaultTransform(x, y);
                line.createDefaultTransformPoints(x, y, w, 0.01);
                
                this.value.objects.push(line);
            }
        }

        
        await super.evalObjects(parse);
    }



    isValid()
    {
        return super.isValid()
            && this.x     && this.x    .isValid()
            && this.y     && this.y    .isValid()
            && this.width && this.width.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);
 
        if (this.x    ) this.x    .pushValueUpdates(parse);
        if (this.y    ) this.y    .pushValueUpdates(parse);
        if (this.width) this.width.pushValueUpdates(parse);
    }

   
        
    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.x    ) this.x    .invalidateInputs(parse, from, force);
        if (this.y    ) this.y    .invalidateInputs(parse, from, force);
        if (this.width) this.width.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);
 
        if (this.x    ) this.x    .iterateLoop(parse);
        if (this.y    ) this.y    .iterateLoop(parse);
        if (this.width) this.width.iterateLoop(parse);
    }
}


class GEllipse
extends GShape
{
    position = null;
    round    = null;
    start    = null;
    sweep    = null;
    inner    = null;

    innerAbsolute;
    startInDegrees;
    sweepInDegrees;



    constructor(nodeId, options)
    {
        super(ELLIPSE, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.position = null;
        this.round    = null;
        this.start    = null;
        this.sweep    = null;
        this.inner    = null;
    }



    copy()
    {
        const copy = new GEllipse(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.position) copy.position = this.position.copy();
        if (this.round   ) copy.round    = this.round   .copy();
        if (this.start   ) copy.start    = this.start   .copy();
        if (this.sweep   ) copy.sweep    = this.sweep   .copy();
        if (this.inner   ) copy.inner    = this.inner   .copy();
        
        return copy;
    }



    paramFromId(paramId)
    {
        switch (paramId)
        {
            case 'position': return this.input ? this.value.position : this.position;
            case 'x':        return this.input ? this.value.x        : this.x;
            case 'y':        return this.input ? this.value.y        : this.y;
            case 'width':    return this.input ? this.value.width    : this.width;
            case 'height':   return this.input ? this.value.height   : this.height;
            case 'round':    return this.input ? this.value.round    : this.round;
            case 'start':    return this.input ? this.value.start    : this.start;
            case 'sweep':    return this.input ? this.value.sweep    : this.sweep;
            case 'inner':    return this.input ? this.value.inner    : this.inner
        }

        return super.paramFromId(paramId);
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        let [x, y, width, height] = await this.evalBaseParams(parse);

        let input = await evalValue      (this.input,    parse);
        let pos   = await evalNumberValue(this.position, parse);
        let round = await evalNumberValue(this.round,    parse);
        let start = await evalNumberValue(this.start,    parse);
        let sweep = await evalNumberValue(this.sweep,    parse);
        let inner = await evalNumberValue(this.inner,    parse);

        // if (pos   && !pos  .isValid()) pos   = NumberValue.NaN.copy();
        // if (round && !round.isValid()) round = NumberValue.NaN.copy();
        // if (start && !start.isValid()) start = NumberValue.NaN.copy();
        // if (sweep && !sweep.isValid()) sweep = NumberValue.NaN.copy();
        // if (inner && !inner.isValid()) inner = NumberValue.NaN.copy();


        if (input)
        {
            this.value        = input.copy();
            this.value.nodeId = this.nodeId;
            this.value.copyCustomParams(input);

            if (pos   )  this.value.position = pos;     else  pos    = this.value.position;
            if (x     )  this.value.x        = x;       else  x      = this.value.x;      
            if (y     )  this.value.y        = y;       else  y      = this.value.y;      
            if (width )  this.value.width    = width;   else  width  = this.value.width;  
            if (height)  this.value.height   = height;  else  height = this.value.height; 
            if (round )  this.value.round    = round;   else  round  = this.value.round;  
            if (start )  this.value.start    = start;   else  start  = this.value.start;
            if (sweep )  this.value.sweep    = sweep;   else  sweep  = this.value.sweep;
            if (inner )  this.value.inner    = inner;   else  inner  = this.value.inner;  
        }
        else
        {
            this.value = new EllipseValue(
                this.nodeId,
                pos,
                x, 
                y, 
                width, 
                height,
                round,
                start,
                sweep,
                inner);
        }


        this.setUpdateValues(parse, 
        [
            ['position', pos   ],
            ['x',        x     ],
            ['y',        y     ],
            ['width',    width ],
            ['height',   height],
            ['round',    round ],
            ['start',    start ],
            ['sweep',    sweep ],
            ['inner',    inner ]
        ]);


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
       if (!this.options.enabled)
           return;
           
           
        this.value.objects = [];


        if (   super.baseIsValid()
            && this.value.x     .isValid()
            && this.value.y     .isValid()
            && this.value.width .isValid()
            && this.value.height.isValid()) 
        {
            const vpos = this.value.position;
            const vx   = this.value.x;
            const vy   = this.value.y;
            const vw   = this.value.width;
            const vh   = this.value.height;

            const _x = vpos.value <= 0 ? vx : new NumberValue(vx.value - vw.value, Math.max(vx.decimals, vw.decimals));
            const _y = vpos.value <= 0 ? vy : new NumberValue(vy.value - vh.value, Math.max(vy.decimals, vh.decimals));
            const _w = vpos.value <= 0 ? vw : new NumberValue(vw.value*2, Math.max(vx.decimals, vw.decimals));
            const _h = vpos.value <= 0 ? vh : new NumberValue(vh.value*2, Math.max(vy.decimals, vh.decimals));            

            let   x  = _x.value;
            let   y  = _y.value;
            let   w  = _w.value;
            let   h  = _h.value;
            let   r  = this.value.round .value;
            let   st = this.value.start .value;
            let   sw = this.value.sweep .value;
            let   i  = this.value.inner .value;


            [x, y, w, h, , ] = validateObjectRect(x, y, w, h);


            if (   w != 0 
                && h != 0)
            {
                if ( this.innerAbsolute ) i  /= Math.max(w, h) / 200;
                if (!this.startInDegrees) st *= 3.6;
                if ( this.sweepInDegrees) sw /= 3.6;

                const ellipse = new FigmaEllipse(
                    this.nodeId,
                    this.nodeId,
                    this.nodeName,
                    x, y, w, h, r, st, sw, i);

                ellipse.createDefaultTransform(x, y);
                ellipse.createDefaultTransformPoints(x, y, w, h);

                this.value.objects.push(ellipse);
            }
        }


        await super.evalObjects(parse);
    }
   
    
        
    isValid()
    {
        return super.isValid()
            && this.position && this.position.isValid()
            && this.round    && this.round   .isValid()
            && this.start    && this.start   .isValid()
            && this.sweep    && this.sweep   .isValid()
            && this.inner    && this.inner   .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);
 
        if (this.position) this.position.pushValueUpdates(parse);
        if (this.round   ) this.round   .pushValueUpdates(parse);
        if (this.start   ) this.start   .pushValueUpdates(parse);
        if (this.sweep   ) this.sweep   .pushValueUpdates(parse);
        if (this.inner   ) this.inner   .pushValueUpdates(parse);
    }

   
        
    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.position) this.position.invalidateInputs(parse, from, force);
        if (this.round   ) this.round   .invalidateInputs(parse, from, force);
        if (this.start   ) this.start   .invalidateInputs(parse, from, force);
        if (this.sweep   ) this.sweep   .invalidateInputs(parse, from, force);
        if (this.inner   ) this.inner   .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);
 
        if (this.position) this.position.iterateLoop(parse);
        if (this.round   ) this.round   .iterateLoop(parse);
        if (this.start   ) this.start   .iterateLoop(parse);
        if (this.sweep   ) this.sweep   .iterateLoop(parse);
        if (this.inner   ) this.inner   .iterateLoop(parse);
    }
}


class GTrapeze
extends GShape
{
    round = null;
    bias  = null;



    constructor(nodeId, options)
    {
        super(TRAPEZE, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.round = null;
        this.bias  = null;
    }



    copy()
    {
        const copy = new GTrapeze(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.round) copy.round = this.round.copy();
        if (this.bias ) copy.bias  = this.bias .copy();

        return copy;
    }



    paramFromId(paramId)
    {
        switch (paramId)
        {
            case 'x':      return this.input ? this.value.x      : this.x;
            case 'y':      return this.input ? this.value.y      : this.y;
            case 'width':  return this.input ? this.value.width  : this.width;
            case 'height': return this.input ? this.value.height : this.height;
            case 'round':  return this.input ? this.value.round  : this.round;
            case 'bias':   return this.input ? this.value.bias   : this.bias;
        }

        return super.paramFromId(paramId);
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input = await evalValue      (this.input, parse);
        let   round = await evalNumberValue(this.round, parse);
        let   bias  = await evalNumberValue(this.bias,  parse);

       
        let [x, y, width, height] = await this.evalBaseParams(parse);


        if (input)
        {
            this.value        = input.toValue();
            this.value.nodeId = this.nodeId;
            this.value.copyCustomParams(input);

            if (x     )  this.value.x      = x;       else  x      = this.value.x;      
            if (y     )  this.value.y      = y;       else  y      = this.value.y;      
            if (width )  this.value.width  = width;   else  width  = this.value.width;  
            if (height)  this.value.height = height;  else  height = this.value.height; 
            if (round )  this.value.round  = round;   else  round  = this.value.round;  
            if (bias  )  this.value.bias   = bias;    else  bias   = this.value.bias;  
        }
        else
        {
            this.value = new TrapezeValue(
                this.nodeId, 
                x, 
                y, 
                width, 
                height, 
                round,
                bias);
        }

       
        this.setUpdateValues(parse, 
        [
            ['x',      x     ],
            ['y',      y     ],
            ['width',  width ],
            ['height', height],
            ['round',  round ],
            ['bias',   bias  ]
        ]);


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        if (!this.x     ) this.x      = this.value.x     .copy();
        if (!this.y     ) this.y      = this.value.y     .copy();
        if (!this.width ) this.width  = this.value.width .copy();
        if (!this.height) this.height = this.value.height.copy();
        if (!this.round ) this.round  = this.value.round .copy();
        if (!this.bias  ) this.bias   = this.value.bias  .copy();


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
     
        
        this.value.objects = [];


        if (   super.baseIsValid()   
            && this.value.x     .isValid()    
            && this.value.y     .isValid()    
            && this.value.width .isValid()
            && this.value.height.isValid()
            && this.value.round .isValid()
            && this.value.bias  .isValid())
        {
            let   x = this.value.x     .value;
            let   y = this.value.y     .value;
            let   w = this.value.width .value;
            let   h = this.value.height.value;
            const r = Math.max(0, this.value.round.value);
            let   b = this.value.bias  .value;


            [x, y, w, h, , ] = validateObjectRect(x, y, w, h);


            if (   w != 0 
                && h != 0)
            {
                const trapeze = new FigmaTrapeze(
                    this.nodeId, 
                    this.nodeId, 
                    this.nodeName, 
                    x, y, w, h, r, b);

                trapeze.createDefaultTransform(x, y);
                trapeze.createDefaultTransformPoints(x, y, w, h);

                this.value.objects.push(trapeze);
            }
        }


        await super.evalObjects(parse);
    }



    isValid()
    {
        return super.isValid()
            && this.round && this.round.isValid()
            && this.bias  && this.bias .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.round) this.round.pushValueUpdates(parse);
        if (this.bias ) this.bias .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.round) this.round.invalidateInputs(parse, from, force);
        if (this.bias ) this.bias .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.round) this.round.iterateLoop(parse);
        if (this.bias ) this.bias .iterateLoop(parse);
    }
}


class GPolygon
extends GShape
{
    position = null;
    round    = null;
    corners  = null;



    constructor(nodeId, options)
    {
        super(POLYGON, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.position = null;
        this.round    = null;
        this.corners  = null;
    }



    copy()
    {
        const copy = new GPolygon(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.position) copy.position = this.position.copy();
        if (this.round   ) copy.round    = this.round   .copy();
        if (this.corners ) copy.corners  = this.corners .copy();

        return copy;
    }



    paramFromId(paramId)
    {
        switch (paramId)
        {
            case 'position': return this.input ? this.value.position : this.position;
            case 'x':        return this.input ? this.value.x        : this.x;
            case 'y':        return this.input ? this.value.y        : this.y;
            case 'width':    return this.input ? this.value.width    : this.width;
            case 'height':   return this.input ? this.value.height   : this.height;
            case 'round':    return this.input ? this.value.round    : this.round;
            case 'corners':  return this.input ? this.value.corners  : this.corners;
        }

        return super.paramFromId(paramId);
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        let [x, y, width, height] = await this.evalBaseParams(parse);

        let input   = await evalPolygonValue(this.input,    parse);
        let pos     = await evalNumberValue (this.position, parse);
        let round   = await evalNumberValue (this.round,    parse);
        let corners = await evalNumberValue (this.corners,  parse);


        if (input)
        {
            this.value        = input.toValue();
            this.value.nodeId = this.nodeId;
            this.value.copyCustomParams(input);

            if (pos    )  this.value.position = pos;      else  pos     = this.value.position;
            if (x      )  this.value.x        = x;        else  x       = this.value.x;      
            if (y      )  this.value.y        = y;        else  y       = this.value.y;      
            if (width  )  this.value.width    = width;    else  width   = this.value.width;  
            if (height )  this.value.height   = height;   else  height  = this.value.height; 
            if (round  )  this.value.round    = round;    else  round   = this.value.round;  
            if (corners)  this.value.corners  = corners;  else  corners = this.value.corners;  
        }
        else
        {
            this.value = new PolygonValue(
                this.nodeId,
                pos,
                x, 
                y, 
                width, 
                height,
                round,
                corners);
        }


        this.setUpdateValues(parse, 
        [
            ['position', pos    ],
            ['x',        x      ],
            ['y',        y      ],
            ['width',    width  ],
            ['height',   height ],
            ['round',    round  ],
            ['corners',  corners]
        ]);


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        if (!this.position) this.position = this.value.position.copy();
        if (!this.x       ) this.x        = this.value.x       .copy();
        if (!this.y       ) this.y        = this.value.y       .copy();
        if (!this.width   ) this.width    = this.value.width   .copy();
        if (!this.height  ) this.height   = this.value.height  .copy();
        if (!this.round   ) this.round    = this.value.round   .copy();
        if (!this.corners ) this.corners  = this.value.corners .copy();


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            
            
        this.value.objects = [];


        if (   super.baseIsValid()   
            && this.value.x      .isValid()
            && this.value.y      .isValid()
            && this.value.width  .isValid()
            && this.value.height .isValid()
            && this.value.round  .isValid()
            && this.value.corners.isValid())
        {
            const vpos = this.value.position;
            const vx   = this.value.x;
            const vy   = this.value.y;
            const vw   = this.value.width;
            const vh   = this.value.height;

            const _x = vpos.value <= 0 ? vx : new NumberValue(vx.value - vw.value, Math.max(vx.decimals, vw.decimals));
            const _y = vpos.value <= 0 ? vy : new NumberValue(vy.value - vh.value, Math.max(vy.decimals, vh.decimals));
            const _w = vpos.value <= 0 ? vw : new NumberValue(vw.value*2, Math.max(vx.decimals, vw.decimals));
            const _h = vpos.value <= 0 ? vh : new NumberValue(vh.value*2, Math.max(vy.decimals, vh.decimals));            

            let   x = _x.value;
            let   y = _y.value;
            let   w = _w.value;
            let   h = _h.value;
            const r = Math.max(0, this.value.round.value);
            const c = Math.max(3, Math.floor(this.value.corners.value));


            [x, y, w, h, , ] = validateObjectRect(x, y, w, h);


            if (   w != 0 
                && h != 0)
            {
                const poly = new FigmaPolygon(
                    this.nodeId,
                    this.nodeId,
                    this.nodeName,
                    x, y, w, h, r, c);

                poly.createDefaultTransform(x, y);
                poly.createDefaultTransformPoints(x, y, w, h);

                this.value.objects.push(poly);
            }
        }

        
        await super.evalObjects(parse);
    }



    // toValue()
    // {
    //     const poly = new PolygonValue(
    //         this.nodeId,
    //         this.position.toValue(),
    //         this.x       .toValue(),
    //         this.y       .toValue(),
    //         this.width   .toValue(),
    //         this.height  .toValue(),
    //         this.round   .toValue(),
    //         this.corners .toValue());

    //     poly.copyCustomParams(this.value);

    //     poly.props   = this.props.toValue();
    //     poly.objects = this.value.objects.map(o => o.copy());

    //     return poly;
    // }



    isValid()
    {
        return super.isValid()
            && this.position && this.position.isValid()
            && this.round    && this.round   .isValid()
            && this.corners  && this.corners .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.position) this.position.pushValueUpdates(parse);
        if (this.round   ) this.round   .pushValueUpdates(parse);
        if (this.corners ) this.corners .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.position) this.position.invalidateInputs(parse, from, force);
        if (this.round   ) this.round   .invalidateInputs(parse, from, force);
        if (this.corners ) this.corners .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.position) this.position.iterateLoop(parse);
        if (this.round   ) this.round   .iterateLoop(parse);
        if (this.corners ) this.corners .iterateLoop(parse);
    }
}



class GStar
extends GShape
{
    position = null;
    round    = null;
    points   = null;
    convex   = null;



    constructor(nodeId, options)
    {
        super(STAR, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.position = null;
        this.round    = null;
        this.points   = null;
        this.convex   = null;
    }



    copy()
    {
        const copy = new GStar(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.position) copy.position = this.position.copy();
        if (this.round   ) copy.round    = this.round   .copy();
        if (this.points  ) copy.points   = this.points  .copy();
        if (this.convex  ) copy.convex   = this.convex  .copy();

        return copy;
    }



    paramFromId(paramId)
    {
        switch (paramId)
        {
            case 'position': return this.input ? this.value.position : this.position;
            case 'x':        return this.input ? this.value.x        : this.x;
            case 'y':        return this.input ? this.value.y        : this.y;
            case 'width':    return this.input ? this.value.width    : this.width;
            case 'height':   return this.input ? this.value.height   : this.height;
            case 'round':    return this.input ? this.value.round    : this.round;
            case 'points':   return this.input ? this.value.points   : this.points;
            case 'convex':   return this.input ? this.value.convex   : this.convex;
        }

        return super.paramFromId(paramId);
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        let [x, y, width, height] = await this.evalBaseParams(parse);

        let input  = await evalValue      (this.input,    parse);
        let pos    = await evalNumberValue(this.position, parse);
        let round  = await evalNumberValue(this.round,    parse);
        let points = await evalNumberValue(this.points,   parse);
        let convex = await evalNumberValue(this.convex,   parse);


        if (input)
        {
            this.value        = input.toValue();
            this.value.nodeId = this.nodeId;
            this.value.copyCustomParams(input);

            if (pos   )  this.value.position = pos;     else  pos    = this.value.position;
            if (x     )  this.value.x        = x;       else  x      = this.value.x;      
            if (y     )  this.value.y        = y;       else  y      = this.value.y;      
            if (width )  this.value.width    = width;   else  width  = this.value.width;  
            if (height)  this.value.height   = height;  else  height = this.value.height; 
            if (round )  this.value.round    = round;   else  round  = this.value.round;  
            if (points)  this.value.points   = points;  else  points = this.value.points;  
            if (convex)  this.value.convex   = convex;  else  convex = this.value.convex; 
        }
        else
        {
            this.value = new StarValue(
                this.nodeId,
                pos,
                x, 
                y, 
                width, 
                height,
                round,
                points,
                convex);
        }


        this.setUpdateValues(parse, 
        [
            ['position', pos   ],
            ['x',        x     ],
            ['y',        y     ],
            ['width',    width ],
            ['height',   height],
            ['round',    round ],
            ['points',   points],
            ['convex',   convex]
        ]);


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        if (!this.position) this.position = this.value.position.copy();
        if (!this.x       ) this.x        = this.value.x       .copy();
        if (!this.y       ) this.y        = this.value.y       .copy();
        if (!this.width   ) this.width    = this.value.width   .copy();
        if (!this.height  ) this.height   = this.value.height  .copy();
        if (!this.round   ) this.round    = this.value.round   .copy();
        if (!this.points  ) this.points   = this.value.points  .copy();
        if (!this.convex  ) this.convex   = this.value.convex  .copy();



        this.validate();

        return this;
   }



   async evalObjects(parse, options = {})
   {
        if (!this.options.enabled)
           return;
           
           
        this.value.objects = [];


        if (   super.baseIsValid()   
            && this.value.x     .isValid()
            && this.value.y     .isValid()
            && this.value.width .isValid()
            && this.value.height.isValid() 
            && this.value.round .isValid()
            && this.value.points.isValid()
            && this.value.convex.isValid())
        {
            const vpos = this.value.position;
            const vx   = this.value.x;
            const vy   = this.value.y;
            const vw   = this.value.width;
            const vh   = this.value.height;

            const _x = vpos.value <= 0 ? vx : new NumberValue(vx.value - vw.value, Math.max(vx.decimals, vw.decimals));
            const _y = vpos.value <= 0 ? vy : new NumberValue(vy.value - vh.value, Math.max(vy.decimals, vh.decimals));
            const _w = vpos.value <= 0 ? vw : new NumberValue(vw.value*2, Math.max(vx.decimals, vw.decimals));
            const _h = vpos.value <= 0 ? vh : new NumberValue(vh.value*2, Math.max(vy.decimals, vh.decimals));            

            let   x = _x.value;
            let   y = _y.value;
            let   w = _w.value;
            let   h = _h.value;
            const r = Math.max(0, this.value.round.value);
            const p = Math.max(3, Math.floor(this.value.points.value));
            const c = this.value.convex.value;


            if (   w != 0
                && h != 0)
            {
                const star = new FigmaStar(
                    this.nodeId,
                    this.nodeId,
                    this.nodeName,
                    x, y, w, h, r, p, c);

                star.createDefaultTransform(x, y);
                star.createDefaultTransformPoints(x, y, w, h);

                this.value.objects.push(star);
            }
        }

       
        await super.evalObjects(parse);
    }



    // toValue()
    // {
    //     const star = new StarValue(
    //         this.nodeId,
    //         this.position.toValue(),
    //         this.x       .toValue(),
    //         this.y       .toValue(),
    //         this.width   .toValue(),
    //         this.height  .toValue(),
    //         this.round   .toValue(),
    //         this.points  .toValue(),
    //         this.convex  .toValue());

    //     star.copyCustomParams(this.value);

    //     star.props   = this.props.toValue();
    //     star.objects = this.value.objects.map(o => o.copy());
 
    //     return star;
    // }



    isValid()
    {
        return super.isValid()
            && this.position && this.position.isValid()
            && this.round    && this.round   .isValid()
            && this.points   && this.points  .isValid()
            && this.convex   && this.convex  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.position) this.position.pushValueUpdates(parse);
        if (this.round   ) this.round   .pushValueUpdates(parse);
        if (this.points  ) this.points  .pushValueUpdates(parse);
        if (this.convex  ) this.convex  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.position) this.position.invalidateInputs(parse, from, force);
        if (this.round   ) this.round   .invalidateInputs(parse, from, force);
        if (this.points  ) this.points  .invalidateInputs(parse, from, force);
        if (this.convex  ) this.convex  .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.position) this.position.iterateLoop(parse);
        if (this.round   ) this.round   .iterateLoop(parse);
        if (this.points  ) this.points  .iterateLoop(parse);
        if (this.convex  ) this.convex  .iterateLoop(parse);
    }
}


class GTextShape
extends GShape
{
    text          = null;
    x             = null;
    y             = null;
    width         = null;
    height        = null;
    font          = null;
    size          = null;
    style         = null;
    alignX        = null;
    alignY        = null;
    lineHeight    = null;
    letterSpacing = null;
    
    

    constructor(nodeId, options)
    {
        super(TEXT_SHAPE, nodeId, options);
    }


    
    reset()
    {
        super.reset();
        
        this.text          = null;
        this.x             = null;
        this.y             = null;
        this.width         = null;
        this.height        = null;
        this.font          = null;
        this.size          = null;
        this.style         = null;
        this.alignX        = null;
        this.alignY        = null;
        this.lineHeight    = null;
        this.letterSpacing = null;
    }



    copy()
    {
        const copy = new GTextShape(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.text         ) copy.text          = this.text         .copy();
        if (this.x            ) copy.x             = this.x            .copy();
        if (this.y            ) copy.y             = this.y            .copy();
        if (this.width        ) copy.width         = this.width        .copy();
        if (this.height       ) copy.height        = this.height       .copy();
        if (this.font         ) copy.font          = this.font         .copy();
        if (this.style        ) copy.style         = this.style        .copy();
        if (this.size         ) copy.size          = this.size         .copy();
        if (this.alignX       ) copy.alignX        = this.alignX       .copy();
        if (this.alignY       ) copy.alignY        = this.alignY       .copy();
        if (this.lineHeight   ) copy.lineHeight    = this.lineHeight   .copy();
        if (this.letterSpacing) copy.letterSpacing = this.letterSpacing.copy();

        return copy;
    }



    paramFromId(paramId)
    {
        switch (paramId)
        {
            case 'text':          return this.input ? this.value.text          : this.text;
            case 'x':             return this.input ? this.value.x             : this.x;
            case 'y':             return this.input ? this.value.y             : this.y;
            case 'width':         return this.input ? this.value.width         : this.width;
            case 'height':        return this.input ? this.value.height        : this.height;
            case 'font':          return this.input ? this.value.font          : this.font;
            case 'style':         return this.input ? this.value.style         : this.style;
            case 'size':          return this.input ? this.value.size          : this.size;
            case 'alignX':        return this.input ? this.value.alignX        : this.alignX;
            case 'alignY':        return this.input ? this.value.alignY        : this.alignY;
            case 'lineHeight':    return this.input ? this.value.lineHeight    : this.lineHeight;
            case 'letterSpacing': return this.input ? this.value.letterSpacing : this.letterSpacing;
        }

        return super.paramFromId(paramId);
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input         = await evalTextShapeValue(this.input,         parse);
        let   text          = await evalTextValue     (this.text,          parse);
        let   x             = await evalNumberValue   (this.x,             parse);
        let   y             = await evalNumberValue   (this.y,             parse);
        let   width         = await evalNumberValue   (this.width,         parse);
        let   height        = await evalNumberValue   (this.height,        parse);
        let   font          = await evalNumberValue   (this.font,          parse);
        let   style         = await evalNumberValue   (this.style,         parse);
        let   size          = await evalNumberValue   (this.size,          parse);
        let   alignX        = await evalNumberValue   (this.alignX,        parse);
        let   alignY        = await evalNumberValue   (this.alignY,        parse);
        let   lineHeight    = await evalNumberValue   (this.lineHeight,    parse);
        let   letterSpacing = await evalNumberValue   (this.letterSpacing, parse);


        if (text          && !text         .isValid()) text          = new TextValue();
        if (x             && !x            .isValid()) x             = NumberValue.NaN.copy();
        if (y             && !y            .isValid()) y             = NumberValue.NaN.copy();
        if (width         && !width        .isValid()) width         = NumberValue.NaN.copy();
        if (height        && !height       .isValid()) height        = NumberValue.NaN.copy();
        if (font          && !font         .isValid()) font          = NumberValue.NaN.copy();
        if (style         && !style        .isValid()) style         = NumberValue.NaN.copy();
        if (size          && !size         .isValid()) size          = NumberValue.NaN.copy();
        if (alignX        && !alignX       .isValid()) alignX        = NumberValue.NaN.copy();
        if (alignY        && !alignY       .isValid()) alignY        = NumberValue.NaN.copy();
        if (lineHeight    && !lineHeight   .isValid()) lineHeight    = NumberValue.NaN.copy();
        if (letterSpacing && !letterSpacing.isValid()) letterSpacing = NumberValue.NaN.copy();


        // for incorrect incoming types
        if (text          && text         .type !=   TEXT_VALUE) text          = new TextValue();
        if (x             && x            .type != NUMBER_VALUE) x             = NumberValue.NaN.copy();
        if (y             && y            .type != NUMBER_VALUE) y             = NumberValue.NaN.copy();
        if (width         && width        .type != NUMBER_VALUE) width         = NumberValue.NaN.copy();
        if (height        && height       .type != NUMBER_VALUE) height        = NumberValue.NaN.copy();
        if (font          && font         .type != NUMBER_VALUE) font          = NumberValue.NaN.copy();
        if (style         && style        .type != NUMBER_VALUE) style         = NumberValue.NaN.copy();
        if (size          && size         .type != NUMBER_VALUE) size          = NumberValue.NaN.copy();
        if (alignX        && alignX       .type != NUMBER_VALUE) alignX        = NumberValue.NaN.copy();
        if (alignY        && alignY       .type != NUMBER_VALUE) alignY        = NumberValue.NaN.copy();
        if (lineHeight    && lineHeight   .type != NUMBER_VALUE) lineHeight    = NumberValue.NaN.copy();
        if (letterSpacing && letterSpacing.type != NUMBER_VALUE) letterSpacing = NumberValue.NaN.copy();

        
        if (input)
        {
            this.value        = input.toValue();
            this.value.nodeId = this.nodeId;
            this.value.copyCustomParams(input);
            
            if (text         )  this.value.text          = text;           else  text          = this.value.text;
            if (x            )  this.value.x             = x;              else  x             = this.value.x;
            if (y            )  this.value.y             = y;              else  y             = this.value.y;
            if (width        )  this.value.width         = width;          else  width         = this.value.width;
            if (height       )  this.value.height        = height;         else  height        = this.value.height;
            if (font         )  this.value.font          = font;           else  font          = this.value.font;
            if (style        )  this.value.style         = style;          else  style         = this.value.style;
            if (size         )  this.value.size          = size;           else  size          = this.value.size;
            if (alignX       )  this.value.alignX        = alignX;         else  alignX        = this.value.alignX;
            if (alignY       )  this.value.alignY        = alignY;         else  alignY        = this.value.alignY;
            if (lineHeight   )  this.value.lineHeight    = lineHeight;     else  lineHeight    = this.value.lineHeight;
            if (letterSpacing)  this.value.letterSpacing = letterSpacing;  else  letterSpacing = this.value.letterSpacing; 
        }
        else
        {
            this.value = new TextShapeValue(
                this.nodeId, 
                text, 
                x, 
                y, 
                width, //this.width .type != NUMBER_VALUE ? width  : new NumberValue(0), 
                height, //this.height.type != NUMBER_VALUE ? height : new NumberValue(0), 
                font, 
                style,
                size,
                alignX,
                alignY,
                lineHeight,
                letterSpacing);
        }

       
        this.setUpdateValues(parse, 
        [
            ['text',          text         ],
            ['x',             x            ],
            ['y',             y            ],
            ['width',         width        ],
            ['height',        height       ],
            ['font',          font         ],
            ['style',         style        ],
            ['size',          size         ],
            ['alignX',        alignX       ],
            ['alignY',        alignY       ],
            ['lineHeight',    lineHeight   ],
            ['letterSpacing', letterSpacing]
        ]);


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        if (!this.text         ) this.text          = this.value.text         .copy();
        if (!this.x            ) this.x             = this.value.x            .copy();
        if (!this.y            ) this.y             = this.value.y            .copy();
        if (!this.width        ) this.width         = this.value.width        .copy();
        if (!this.height       ) this.height        = this.value.height       .copy();
        if (!this.font         ) this.font          = this.value.font         .copy();
        if (!this.style        ) this.style         = this.value.style        .copy();
        if (!this.size         ) this.size          = this.value.size         .copy();
        if (!this.alignX       ) this.alignX        = this.value.alignX       .copy();
        if (!this.alignY       ) this.alignY        = this.value.alignY       .copy();
        if (!this.lineHeight   ) this.lineHeight    = this.value.lineHeight   .copy();
        if (!this.letterSpacing) this.letterSpacing = this.value.letterSpacing.copy();
        

        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;

        
        this.value.objects = [];


        if (   super.baseIsValid()   
            && this.value.text         .isValid()
            && this.value.x            .isValid()
            && this.value.y            .isValid()
            && this.value.width        .isValid()
            && this.value.height       .isValid()
            && this.value.font         .isValid()
            && this.value.style        .isValid()
            && this.value.size         .isValid()
            && this.value.alignX       .isValid()
            && this.value.alignY       .isValid()
            && this.value.lineHeight   .isValid()
            && this.value.letterSpacing.isValid())
        {
            let x = this.value.x     .value;
            let y = this.value.y     .value;
            let w = this.value.width .value;
            let h = this.value.height.value;

            const fontName   = figUniqueFontNames[this.value.font.value];
            const fontStyles = getFontStyles(fontName);

            const text = new FigmaText(
                this.nodeId,
                this.nodeId,
                this.nodeName,
                this.value.text.value,
                x, y, w, h,
                fontName,
                this.value.size         .value,
                fontStyles[Math.min(this.value.style.value, fontStyles.length-1)],
                this.value.alignX       .value,
                this.value.alignY       .value,
                this.value.lineHeight   .value,
                this.value.letterSpacing.value);

                
            text.createDefaultTransform(x, y);
 
            // if (   text.width  == 0
            //     && text.height == 0)
            // {
            //     const {objectId, width, height} = await genGetObjectSizeFromFigma(text.toData());

            //     text.width  = width;
            //     text.height = height;

            //     this.value.width.value  = width;
            //     this.value.height.value = height;

            //     text.createDefaultTransformPoints(x, y, width, height);

            //     this.value.objects.push(text);
            // }
            // else
            // {
                text.createDefaultTransformPoints(x, y, w, h);

                this.value.objects.push(text);
            // }
        }

        
        await super.evalObjects(parse);
    }



    isValid()
    {
        return super.isValid()
            && this.text          && this.text         .isValid()
            && this.x             && this.x            .isValid()
            && this.y             && this.y            .isValid()
            && this.width         && this.width        .isValid()
            && this.height        && this.height       .isValid()
            && this.font          && this.font         .isValid()
            && this.style         && this.style        .isValid()
            && this.size          && this.size         .isValid()
            && this.alignX        && this.alignX       .isValid()
            && this.alignY        && this.alignY       .isValid()
            && this.lineHeight    && this.lineHeight   .isValid()
            && this.letterSpacing && this.letterSpacing.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);
        
        if (this.text         ) this.text         .pushValueUpdates(parse);
        if (this.x            ) this.x            .pushValueUpdates(parse);
        if (this.y            ) this.y            .pushValueUpdates(parse);
        if (this.width        ) this.width        .pushValueUpdates(parse);
        if (this.height       ) this.height       .pushValueUpdates(parse);
        if (this.font         ) this.font         .pushValueUpdates(parse);
        if (this.style        ) this.style        .pushValueUpdates(parse);
        if (this.size         ) this.size         .pushValueUpdates(parse);
        if (this.alignX       ) this.alignX       .pushValueUpdates(parse);
        if (this.alignY       ) this.alignY       .pushValueUpdates(parse);
        if (this.lineHeight   ) this.lineHeight   .pushValueUpdates(parse);
        if (this.letterSpacing) this.letterSpacing.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);
        
        if (this.text         ) this.text         .invalidateInputs(parse, from, force);
        if (this.x            ) this.x            .invalidateInputs(parse, from, force);
        if (this.y            ) this.y            .invalidateInputs(parse, from, force);
        if (this.width        ) this.width        .invalidateInputs(parse, from, force);
        if (this.height       ) this.height       .invalidateInputs(parse, from, force);
        if (this.font         ) this.font         .invalidateInputs(parse, from, force);
        if (this.style        ) this.style        .invalidateInputs(parse, from, force);
        if (this.size         ) this.size         .invalidateInputs(parse, from, force);
        if (this.alignX       ) this.alignX       .invalidateInputs(parse, from, force);
        if (this.alignY       ) this.alignY       .invalidateInputs(parse, from, force);
        if (this.lineHeight   ) this.lineHeight   .invalidateInputs(parse, from, force);
        if (this.letterSpacing) this.letterSpacing.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);
        
        if (this.text         ) this.text         .iterateLoop(parse);
        if (this.x            ) this.x            .iterateLoop(parse);
        if (this.y            ) this.y            .iterateLoop(parse);
        if (this.width        ) this.width        .iterateLoop(parse);
        if (this.height       ) this.height       .iterateLoop(parse);
        if (this.font         ) this.font         .iterateLoop(parse);
        if (this.style        ) this.style        .iterateLoop(parse);
        if (this.size         ) this.size         .iterateLoop(parse);
        if (this.alignX       ) this.alignX       .iterateLoop(parse);
        if (this.alignY       ) this.alignY       .iterateLoop(parse);
        if (this.lineHeight   ) this.lineHeight   .iterateLoop(parse);
        if (this.letterSpacing) this.letterSpacing.iterateLoop(parse);
    }
}


class GPoint
extends GOperator1
{
    x = null;
    y = null;



    constructor(nodeId, options)
    {
        super(POINT, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.x = null;
        this.y = null;
    }



    copy()
    {
        const copy = new GPoint(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.value) copy.value = this.value.copy();
        if (this.x    ) copy.x     = this.x    .copy();
        if (this.y    ) copy.y     = this.y    .copy();

        return copy;
    }



    paramFromId(paramId)
    {
        switch (paramId)
        {
            case 'x': return this.input ? this.value.x : this.x;
            case 'y': return this.input ? this.value.y : this.y;
        }

        return null;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        let input = await evalPointValue (this.input, parse);
        let x     = await evalNumberValue(this.x,     parse);
        let y     = await evalNumberValue(this.y,     parse);


        if (   input
            && input.isValid())
        {
            const _input = input;

            if (input.type == VECTOR_VERTEX_VALUE)
            {
                input = new PointValue(input.nodeId, input.x, input.y);
                input.copyCustomParams(_input);
            }
            
            this.value        = input;
            this.value.nodeId = this.nodeId;
            this.value.copyCustomParams(input);


            if (   this.value.objects
                && this.value.objects.length > 0)
            {
                this.value.x = new NumberValue(this.value.objects[0].x);
                this.value.y = new NumberValue(this.value.objects[0].y);
            }
            
            if (x)  this.value.x = x;  else  x = this.value.x;
            if (y)  this.value.y = y;  else  y = this.value.y;
        }
        else if (x 
              && y)
        {
            this.value = new PointValue(
                this.nodeId, 
                x, 
                y);
        }
        else
            this.value = PointValue.NaN.copy();


        this.value.uniqueId = this.uniqueId;


        await this.evalObjects(parse);


        this.setUpdateValues(parse, 
        [
            ['x', x],
            ['y', y]
        ]);    


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            
            
        if (!this.value.objects)
            this.value.objects = [];


        if (   this.value.x
            && this.value.y   
            && this.value.x.isValid()
            && this.value.y.isValid())
        {
            const x = this.value.x.value;
            const y = this.value.y.value;

            const point = new FigmaPoint(
                this.nodeId,
                this.nodeId,
                this.nodeName,
                x,
                y,
                this.smooth ? this.smooth.value/100 : 1);

            point.createDefaultTransform(x, y);

            this.value.objects = [point];
        }


        await super.evalObjects(parse);
    }



    isValid()
    {
        return super.isValid()
            && this.x && this.x.isValid()
            && this.y && this.y.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.x) this.x.pushValueUpdates(parse);
        if (this.y) this.y.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.x) this.x.invalidateInputs(parse, from, force);
        if (this.y) this.y.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.x) this.x.iterateLoop(parse);
        if (this.y) this.y.iterateLoop(parse);
    }
}


class GPointCorner
extends GOperator1
{
    smooth = null;



    constructor(nodeId, options)
    {
        super(POINT_CORNER, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.smooth = null;
    }



    copy()
    {
        const copy = new GPointCorner(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.value ) copy.value  = this.value .copy();
        if (this.smooth) copy.smooth = this.smooth.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        const input  = await evalPointValue (this.input,  parse);
        const smooth = await evalNumberValue(this.smooth, parse);
        
        if (input)
        {
            this.value        = input;
            this.value.nodeId = this.nodeId;
            this.value.copyCustomParams(input);

            this.value.smooth = smooth;


            if (   this.value.objects
                && this.value.objects.length > 0)
            {
                this.value.x = new NumberValue(this.value.objects[0].x);
                this.value.y = new NumberValue(this.value.objects[0].y);
            }
        }
        else
            this.value = PointValue.NaN.copy();


        await this.evalObjects(parse);


        this.setUpdateValues(parse, 
        [
            ['smooth', smooth]
        ]);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            
            
        this.value.objects = [];


        if (   this.value.x.isValid()
            && this.value.y.isValid())
        {
            const x      = this.value.x.value;
            const y      = this.value.y.value;
            const smooth = this.value.smooth ? this.value.smooth.value/100 : 1;

            const point = new FigmaPoint(
                this.nodeId, 
                this.nodeId, 
                this.nodeName, 
                x, 
                y, 
                smooth);

            point.createDefaultTransform(x, y);

            this.value.objects = [point];
        }


        await super.evalObjects(parse);
    }



    toValue()
    {
        return this.value.copy();
    //     const point = new PointValue(
    //         this.nodeId,
    //         this.x.toValue(),
    //         this.y.toValue());

    //     point.objects = 
    //         this.value.objects
    //         ? this.value.objects.map(o => o.copy())
    //         : [];

    //     return point;
    }



    isValid()
    {
        return super.isValid()
            && this.smooth && this.smooth.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.smooth) this.smooth.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.smooth) this.smooth.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.smooth) this.smooth.iterateLoop(parse);
    }
}


class GVectorPath
extends GShape
{
    points  = null;
    closed  = null;
    degree  = null;
    winding = null;
    round   = null;



    constructor(nodeId, options)
    {
        super(VECTOR_PATH, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.points  = null;
        this.closed  = null;
        this.degree  = null;
        this.winding = null;
        this.round   = null;
    }



    copy()
    {
        const copy = new GVectorPath(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.points ) copy.points  = this.points .copy();
        if (this.closed ) copy.closed  = this.closed .copy();
        if (this.degree ) copy.degree  = this.degree .copy();
        if (this.winding) copy.winding = this.winding.copy();
        if (this.round  ) copy.round   = this.round  .copy();

        return copy;
    }



    paramFromId(paramId)
    {
        switch (paramId)
        {
            case 'points':  return this.input ? this.value.points  : this.points;
            case 'closed':  return this.input ? this.value.closed  : this.closed;
            case 'degree':  return this.input ? this.value.degree  : this.degree;
            case 'winding': return this.input ? this.value.winding : this.winding;
            case 'round':   return this.input ? this.value.round   : this.round;
        }

        return super.paramFromId(paramId);
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input   = await evalVectorPathValue(this.input,   parse);
        let   points  = await evalNumberValue    (this.points,  parse);
        let   closed  = await evalNumberValue    (this.closed,  parse);
        let   degree  = await evalNumberValue    (this.degree,  parse);
        let   winding = await evalNumberValue    (this.winding, parse);
        let   round   = await evalNumberValue    (this.round,   parse);


        await this.evalBaseParams(parse);


        if (input)
        {
            // if (this.nodeId == 'path2')
            //     console.log('input =', input);
            
            if (   input.points
                && input.points.items
                && input.points.objects)
            {
                consoleAssert(
                     input.points.items.length == input.points.objects.length,
                    'Vector path points input item count must match object count');

                for (let i = 0; i < input.points.items.length; i++)
                {
                    const item = input.points.items  [i].copy();
                    const obj  = input.points.objects[i].copy();

                    if (item && obj)
                    {
                        item.x = new NumberValue(obj.x);
                        item.y = new NumberValue(obj.y);
                    }
                }
            }


            this.value = new VectorPathValue(
                this.nodeId,
                   points 
                && points.items.length > 0 
                ? points
                : input.points,
                closed  ?? input.closed,
                degree  ?? input.degree,
                winding ?? input.winding,
                round   ?? input.round);

            this.value.copyCustomParams(input);

            
            if (points )  this.value.points   = points;   else  points  = this.value.points;    
            if (closed )  this.value.closed   = closed;   else  closed  = this.value.closed;    
            if (degree )  this.value.degree   = degree;   else  degree  = this.value.degree;  
            if (winding)  this.value.windingt = winding;  else  winding = this.value.winding; 
            if (round  )  this.value.round    = round;    else  round   = this.value.round;  
        }
        else
        {
            this.value = new VectorPathValue(
                this.nodeId, 
                points, 
                closed, 
                degree, 
                winding, 
                round);
        }

        
        this.setUpdateValues(parse, 
        [
          //['points',  points ],
            ['closed',  closed ],
            ['degree',  degree ],
            ['winding', winding],
            ['round',   round  ]
        ]);


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            

        const points = [];

        if (this.value.points.objects)
        {
            const objPoints = this.value.points.objects.filter(o => o.type == POINT);

            for (const pt of objPoints)
            {
                const p = PointValue.create(this.nodeId, pt.x, pt.y);
                
                if (pt.smooth != null)
                    p.smooth = new NumberValue(pt.smooth);

                points.push(p);
            }
        }


        this.value.objects = [];


        if (   super.baseIsValid()   
            && points.length >= 2
            && this.value.closed .isValid()
            && this.value.degree .isValid()
            && this.value.winding.isValid()
            && this.value.round  .isValid())
        {
            const path = new FigmaVectorPath(
                this.nodeId,
                this.nodeId,
                this.nodeName,
                points,
                this.value.closed .value,
                this.value.degree .value,
                this.value.winding.value,
                this.value.round  .value);

                
            const bounds = getObjBounds([path]);

            path.createDefaultSpace(
                bounds.x + bounds.width /2,            
                bounds.y + bounds.height/2);


            let x = bounds.x;
            let y = bounds.y;
            let w = bounds.w;
            let h = bounds.h;
            
            path.createDefaultTransform(x, y);
            path.createDefaultTransformPoints(x, y, w, h);


            this.value.objects.push(path);
        }


        await super.evalObjects(parse);
    }



    isValid()
    {
        return super.isValid()
            && this.points  && this.points .isValid()
            && this.closed  && this.closed .isValid()
            && this.degree  && this.degree .isValid()
            && this.winding && this.winding.isValid()
            && this.round   && this.round  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.points ) this.points .pushValueUpdates(parse);
        if (this.closed ) this.closed .pushValueUpdates(parse);
        if (this.degree ) this.degree .pushValueUpdates(parse);
        if (this.winding) this.winding.pushValueUpdates(parse);
        if (this.round  ) this.round  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.points ) this.points .invalidateInputs(parse, from, force);
        if (this.closed ) this.closed .invalidateInputs(parse, from, force);
        if (this.degree ) this.degree .invalidateInputs(parse, from, force);
        if (this.winding) this.winding.invalidateInputs(parse, from, force);
        if (this.round  ) this.round  .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.points ) this.points .iterateLoop(parse);
        if (this.closed ) this.closed .iterateLoop(parse);
        if (this.degree ) this.degree .iterateLoop(parse);
        if (this.winding) this.winding.iterateLoop(parse);
        if (this.round  ) this.round  .iterateLoop(parse);
    }
}


class GVectorVertex
extends GOperator1
{
    x     = null;
    y     = null;
    join  = null;
    cap   = null;
    round = null;



    constructor(nodeId, options)
    {
        super(VECTOR_VERTEX, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.x     = null;
        this.y     = null;
        this.join  = null;
        this.cap   = null;
        this.round = null;
    }



    copy()
    {
        const copy = new GVectorVertex(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.x    ) copy.x     = this.x    .copy();
        if (this.y    ) copy.y     = this.y    .copy();
        if (this.join ) copy.join  = this.join .copy();
        if (this.cap  ) copy.cap   = this.cap  .copy();
        if (this.round) copy.round = this.round.copy();

        return copy;
    }



    paramFromId(paramId)
    {
        switch (paramId)
        {
            case 'x':     return this.input ? this.value.x     : this.x;
            case 'y':     return this.input ? this.value.y     : this.y;
            case 'join':  return this.input ? this.value.join  : this.join;
            case 'cap':   return this.input ? this.value.cap   : this.cap;
            case 'round': return this.input ? this.value.round : this.round;
        }

        return null;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        let input = await evalVectorVertexValue(this.input, parse);
        let x     = await evalNumberValue      (this.x,     parse);
        let y     = await evalNumberValue      (this.y,     parse);
        let join  = await evalNumberValue      (this.join,  parse);
        let cap   = await evalNumberValue      (this.cap,   parse);
        let round = await evalNumberValue      (this.round, parse);


        if (input)
        {
            const _input = input;

            if (input.type == POINT_VALUE)
            {
                input = new VectorVertexValue(input.nodeId, input.x, input.y);
                input.copyCustomParams(_input);
            }
            
            this.value        = input.copy();
            this.value.nodeId = this.nodeId;
            this.value.copyCustomParams(input);

            // this.value = new VectorVertexValue(
            //     this.nodeId,
            //     x     ?? input.x,
            //     y     ?? input.y,
            //     join  ?? input.join,
            //     cap   ?? input.cap,
            //     round ?? input.round);
                
            this.value.x     = new NumberValue(this.value.objects[0].x    );
            this.value.y     = new NumberValue(this.value.objects[0].y    );
            this.value.join  = new NumberValue(this.value.objects[0].join );
            this.value.cap   = new NumberValue(this.value.objects[0].cap  );
            this.value.round = new NumberValue(this.value.objects[0].round);

            if (x    )  this.value.x     = x;      else  x     = this.value.x;
            if (y    )  this.value.y     = y;      else  y     = this.value.y;
            if (join )  this.value.join  = join;   else  join  = this.value.join;
            if (cap  )  this.value.cap   = cap;    else  cap   = this.value.cap;
            if (round)  this.value.round = round;  else  round = this.value.round;
        }
        else
        {
            this.value = new VectorVertexValue(
                this.nodeId, 
                x, 
                y, 
                join, 
                cap, 
                round);
        }

       
        this.value.uniqueId = this.uniqueId;


        await this.evalObjects(parse);


        this.setUpdateValues(parse, 
        [
            ['value', this.value]
        ]);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            
            
        this.value.objects = [];


        if (   this.value.x    
            && this.value.y    
            && this.value.join 
            && this.value.cap  
            && this.value.round)
        {
            const x     = this.value.x    .value;
            const y     = this.value.y    .value;
            //const join  = this.value.join .value;
            //const cap   = this.value.cap  .value;
            //const round = this.value.round.value;

            const point = new FigmaPoint(this.nodeId, this.nodeId, this.nodeName, x, y);

            point.createDefaultTransform(x, y);

            this.value.objects = [point];
        }


        await super.evalObjects(parse);
    }



    toValue()
    {
        const point = new VectorVertexValue(
            this.nodeId,
            this.x    .toValue(),
            this.y    .toValue(),
            this.join .toValue(),
            this.cap  .toValue(),
            this.round.toValue());

        point.copyCustomParams(this.value);

        point.objects  = this.value.objects.map(o => o.copy());
        point.uniqueId = this.value.uniqueId;

        return point;
    }



    isValid()
    {
        return super.isValid()
            && this.x    .isValid()
            && this.y    .isValid()
            && this.join .isValid()
            && this.cap  .isValid()
            && this.round.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.x    ) this.x    .pushValueUpdates(parse);
        if (this.y    ) this.y    .pushValueUpdates(parse);
        if (this.join ) this.join .pushValueUpdates(parse);
        if (this.cap  ) this.cap  .pushValueUpdates(parse);
        if (this.round) this.round.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.x    ) this.x    .invalidateInputs(parse, from, force);
        if (this.y    ) this.y    .invalidateInputs(parse, from, force);
        if (this.join ) this.join .invalidateInputs(parse, from, force);
        if (this.cap  ) this.cap  .invalidateInputs(parse, from, force);
        if (this.round) this.round.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.x    ) this.x    .iterateLoop(parse);
        if (this.y    ) this.y    .iterateLoop(parse);
        if (this.join ) this.join .iterateLoop(parse);
        if (this.cap  ) this.cap  .iterateLoop(parse);
        if (this.round) this.round.iterateLoop(parse);
    }
}


class GVectorEdge
extends GOperator2
{
    startTangent = null;
    endTangent   = null;
    
    
    
    constructor(nodeId, options)
    {
        super(VECTOR_EDGE, nodeId, options);
    }



    reset()
    {
        super.reset();
        
        this.startTangent = null;
        this.endTangent   = null;
    }



    copy()
    {
        const copy = new GVectorEdge(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.startTangent) copy.startTangent = this.startTangent.copy();
        if (this.endTangent  ) copy.endTangent   = this.endTangent  .copy();

        return copy;
    }



    paramFromId(paramId)
    {
        switch (paramId)
        {
            case 'startTangent': return this.input ? this.value.startTangent : this.startTangent;
            case 'endTangent':   return this.input ? this.value.endTangent   : this.endTangent;
        }

        return null;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        let input0       = await evalVectorVertexValue(this.input0,       parse);
        let input1       = await evalVectorVertexValue(this.input1,       parse);
        let startTangent = await evalNumberValue      (this.startTangent, parse);
        let   endTangent = await evalNumberValue      (this.  endTangent, parse);

        if (   input0
            && input1
            && startTangent
            && endTangent)
        {
            if (input0.type == POINT_VALUE) input0 = new VectorVertexValue(input0.nodeId, input0.x, input0.y);
            if (input1.type == POINT_VALUE) input1 = new VectorVertexValue(input1.nodeId, input1.x, input1.y);

            if (startTangent.type == VECTOR_VERTEX_VALUE) startTangent = new PointValue(startTangent.nodeId, startTangent.x, startTangent.y);
            if (  endTangent.type == VECTOR_VERTEX_VALUE)   endTangent = new PointValue(  endTangent.nodeId,   endTangent.x,   endTangent.y);


            this.value = new VectorEdgeValue(
                this.nodeId,
                input0,
                input1,
                startTangent,
                endTangent);


            this.value.uniqueId = this.uniqueId;
        }
        else
            this.value = VectorEdgeValue.NaN.copy();
        
        
        await this.evalObjects(parse);


        this.setUpdateValues(parse, 
        [
            ['value', this.value]
        ]);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (   !this.options.enabled
            || !this.value.start.isValid()
            || !this.value.end  .isValid())
            return;
            
            
        this.value.objects = [];


        if (   this.value.start.isValid()
            && this.value.end  .isValid())
        {
            const path = new FigmaVectorPath(
                this.nodeId,
                this.nodeId,
                this.nodeName,
                [ this.value.start,
                  this.value.startTangent.isValid() ? this.value.startTangent : this.value.start,
                  this.value.endTangent  .isValid() ? this.value.  endTangent : this.value.end,
                  this.value.end ],
                0,
                2, // cubic
                0,
                0);

            
            const bounds = getObjBounds([path]);

            let x = bounds.x;
            let y = bounds.y;
            let w = bounds.w;
            let h = bounds.h;


            path.createDefaultTransform(x, y);
            path.createDefaultTransformPoints(x, y, w, h);

            this.value.objects.push(path);
        }


        await super.evalObjects(parse);
    }



    // toValue()
    // {
    //     const edge = new VectorEdgeValue(
    //         this.nodeId,
    //         this.input0 ? this.input0.toValue() : VectorVertexValue.NaN,
    //         this.input1 ? this.input1.toValue() : VectorVertexValue.NaN,
    //         this.startTangent.toValue(),
    //         this.endTangent  .toValue());

    //     edge.copyCustomParams(this.value);

    //     edge.uniqueId = this.value.uniqueId;
    //     edge.objects  = this.value.objects.map(o => o.copy());

    //     return edge;
    // }



    isValid()
    {
        return super.isValid()
            && this.startTangent.isValid()
            && this.endTangent  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.startTangent) this.startTangent.pushValueUpdates(parse);
        if (this.endTangent  ) this.endTangent  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.startTangent) this.startTangent.invalidateInputs(parse, from, force);
        if (this.endTangent  ) this.endTangent  .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.startTangent) this.startTangent.iterateLoop(parse);
        if (this.endTangent  ) this.endTangent  .iterateLoop(parse);
    }
}


class GVectorRegion
extends GShape
{
    inputs  = [];

    loops   = null;
    winding = null;



    constructor(nodeId, options)
    {
        super(VECTOR_REGION, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.inputs  = [];

        this.loops   = null;
        this.winding = null;
    }



    copy()
    {
        const copy = new GVectorRegion(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        if (this.winding) copy.winding = this.winding.copy();

        return copy;
    }



    paramFromId(paramId)
    {
        switch (paramId)
        {
            case 'loops':   return this.input ? this.value.loops   : this.loops;
            case 'winding': return this.input ? this.value.winding : this.winding;
        }

        return super.paramFromId(paramId);
    }



    isCached()
    {
        for (const input of this.inputs)
            if (!input.isCached())
                return false;

        return super.isCached()
            && this.winding.isCached();
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        const winding = await evalNumberValue(this.winding, parse);


        this.loops = new ListValue();


        const loop = new ListValue();

        for (let i = 0; i < this.inputs.length; i++)
        {
            const input = await evalVectorEdgeValue(this.inputs[i], parse);

            if (isListValueType(input.type))
            {
                const _loop = new ListValue();

                for (let j = 0; j < input.items.length; j++)
                {
                    const item = input.items[j];

                    if (item.type == VECTOR_EDGE_VALUE)
                    {
                        const edge = item.copy();

                        if (_loop.items.length > 0)
                        {
                            const prevEdge = _loop.items.at(-1);

                            if (   edge.end.x.equals(prevEdge.end.x)
                                && edge.end.y.equals(prevEdge.end.y))
                            {
                                [edge.start,        edge.end       ] = [edge.end,        edge.start       ];
                                [edge.startTangent, edge.endTangent] = [edge.endTangent, edge.startTangent];
                            }
                        }

                        _loop.items.push(edge);
                    }
                }

                if (!isEmpty(_loop.items))
                    loops.items.push(_loop);
            }
            else
            {
                consoleAssert(
                     input.type == VECTOR_EDGE_VALUE, 
                    'input.type must be VECTOR_EDGE_VALUE');

                const edge = input.copy();

                if (loop.items.length > 0)
                {
                    const prevEdge = loop.items.at(-1);

                    if (   edge.end.x.equals(prevEdge.end.x)
                        && edge.end.y.equals(prevEdge.end.y))
                    {
                        [edge.start,        edge.end       ] = [edge.end,        edge.start       ];
                        [edge.startTangent, edge.endTangent] = [edge.endTangent, edge.startTangent];
                    }
                }

                loop.items.push(edge);
            }
        }


        if (!isEmpty(loop.items))
            this.loops.items.push(loop);


        this.value = new VectorRegionValue(
            this.nodeId,
            this.loops, 
            winding);


        this.value.uniqueId = this.uniqueId;


        this.setUpdateValues(parse,
        [
            ['value',   this.value],
            ['winding', winding   ]
        ]);


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (   !this.options.enabled
            || !this.value.isValid())
            return;
            
            
        this.value.objects = [];

        
        if (   this.loops  .isValid()
            && this.winding.isValid())
        {
            const regions = [];


            for (let i = 0; i < this.loops.items.length; i++)
            {
                const loop = this.loops.items[i];


                const points = [];
    
                for (let j = 0; j < loop.items.length; j++)
                {
                    const edge = loop.items[j];
                    const next = loop.items[j == loop.items.length-1 ? 0 : j+1];

                    points.push(
                           edge.start.uniqueId == next.start.uniqueId
                        || edge.start.uniqueId == next.end  .uniqueId
                        ? edge.end  
                        : edge.start);
                }


                regions.push(new FigmaVectorPath(
                    this.nodeId,
                    this.nodeId + '/' + i,
                    this.nodeName,
                    points,
                    1,
                    0, // linear
                    this.winding.value,
                    0));
            }
            

            let bounds = getObjBounds(regions);

            let x = bounds.x;
            let y = bounds.y;
            let w = bounds.w;
            let h = bounds.h;


            for (const region of regions)
            {
                region.createDefaultTransform(x, y);
                region.createDefaultTransformPoints(x, y, w, h);

                this.value.objects.push(region);
            }
        }


        await super.evalObjects(parse);
    }



    // toValue()
    // {
    //     const region = new VectorRegionValue(
    //         this.nodeId,
    //         this.loops  .toValue(),
    //         this.winding.toValue(),
    //         this.props  .toValue());

    //     region.copyCustomParams(this.value);

    //     region.uniqueId = this.value.uniqueId;
    //     region.objects  = this.value.objects.map(o => o.copy());

    //     return region;
    // }



    isValid()
    {
        if (!super.isValid())
            return false;
            
        for (const input of this.inputs)
            if (!input.isCached())
                return false;
        
        return this.winding.isValid()
            && this.props  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse));

        if (this.winding) this.winding.pushValueUpdates(parse);
        if (this.props  ) this.props  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        this.inputs.forEach(i => i.invalidateInputs(parse, from, force));

        if (this.winding) this.winding.invalidateInputs(parse, from, force);
        if (this.props  ) this.props  .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        this.inputs.forEach(i => i.iterateLoop(parse));

        if (this.winding) this.winding.iterateLoop(parse);
        if (this.props  ) this.props  .iterateLoop(parse);
    }
}


class GVectorNetwork
extends GShape
{
    inputs = [];



    constructor(nodeId, options)
    {
        super(VECTOR_NETWORK, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.inputs = [];
    }



    copy()
    {
        const copy = new GVectorNetwork(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        return copy;
    }



    isCached()
    {
        for (const input of this.inputs)
            if (!input.isCached())
                return false;

        return super.isCached();
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        const regions = new ListValue();

        for (let i = 0; i < this.inputs.length; i++)
        {
            const input = await evalVectorRegionValue(this.inputs[i], parse);

            consoleAssert(
                 input.type == VECTOR_REGION_VALUE, 
                'input.type must be VECTOR_REGION_VALUE');

            regions.items.push(input);
        }


        this.value = new VectorNetworkValue(
            this.nodeId,
            regions);


        this.setUpdateValues(parse, 
        [
            ['value', this.value]
        ]);


        await this.evalShapeBase(parse);

        
        await this.evalObjects(parse);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (   !this.options.enabled
            || !this.value.isValid())
            return;
            
            
        this.value.objects = [];


        if (!isEmpty(this.value.regions.items))
        {
            let points  = [];
            let edges   = [];
            let regions = [];


            for (const region of this.value.regions.items)
            {
                if (!isEmpty(region.objects))
                    region.fills = region.objects[0].fills;


                if (region.loops)
                {
                    for (const loop of region.loops.items)
                    {
                        for (const edge of loop.items)
                        {
                            pushUniqueBy(points, edge.start, p => p.uniqueId == edge.start.uniqueId);
                            pushUniqueBy(points, edge.end,   p => p.uniqueId == edge.end  .uniqueId);

                            pushUniqueBy(edges, edge, e => e.uniqueId == edge.uniqueId);
                        }
                    }

                    pushUniqueBy(regions, region, r => r.uniqueId == region.uniqueId);
                }
            }

            
            const network = new FigmaVectorNetwork(
                this.nodeId,
                this.nodeId,
                this.nodeName,
                points,
                edges,
                regions);

            
            const bounds = getObjBounds([network]);

            let x = bounds.x;
            let y = bounds.y;
            let w = bounds.w;
            let h = bounds.h;


            network.createDefaultTransform(x, y);
            network.createDefaultTransformPoints(x, y, w, h);

            this.value.objects.push(network);
        }


        await super.evalObjects(parse);
    }



    // toValue()
    // {
    //     const network = new VectorNetworkValue(
    //         this.nodeId,
    //         this.regions.toValue());

    //     network.copyCustomParams(this.value);

    //     network.uniqueId = this.value.uniqueId;
    //     network.objects  = this.value.objects.map(o => o.copy());

    //     return network;
    // }



    isValid()
    {
        return super.isValid()
            && this.regions.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse));
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        this.inputs.forEach(i => i.pushValueUpdates(parse));
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        this.inputs.forEach(i => i.iterateLoop(parse));
    }
}


class GArcPath
extends GShape
{
    position = null;
    start    = null;
    sweep    = null;

    startInDegrees;
    sweepInDegrees;



    constructor(nodeId, options)
    {
        super(ARC_PATH, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.position = null;
        this.start    = null;
        this.sweep    = null;
    }



    copy()
    {
        const copy = new GArcPath(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.position) copy.position = this.position.copy();
        if (this.start   ) copy.start    = this.start   .copy();
        if (this.sweep   ) copy.sweep    = this.sweep   .copy();
        
        return copy;
    }



    paramFromId(paramId)
    {
        switch (paramId)
        {
            case 'position': return this.input ? this.value.position : this.position;
            case 'x':        return this.input ? this.value.x        : this.x;
            case 'y':        return this.input ? this.value.y        : this.y;
            case 'width':    return this.input ? this.value.width    : this.width;
            case 'height':   return this.input ? this.value.height   : this.height;
            case 'start':    return this.input ? this.value.start    : this.start;
            case 'sweep':    return this.input ? this.value.sweep    : this.sweep;
        }

        return super.paramFromId(paramId);
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        let [x, y, width, height] = await this.evalBaseParams(parse);

        let input = await evalArcPathValue(this.input,    parse);
        let pos   = await evalNumberValue (this.position, parse);
        let start = await evalNumberValue (this.start,    parse);
        let sweep = await evalNumberValue (this.sweep,    parse);


        if (input)
        {
            this.value        = input.copy();
            this.value.nodeId = this.nodeId;
            this.value.copyCustomParams(input);

            if (pos   )  this.value.position = pos;     else  pos    = this.value.position;
            if (x     )  this.value.x        = x;       else  x      = this.value.x;      
            if (y     )  this.value.y        = y;       else  y      = this.value.y;      
            if (width )  this.value.width    = width;   else  width  = this.value.width;  
            if (height)  this.value.height   = height;  else  height = this.value.height; 
            if (start )  this.value.start    = start;   else  start  = this.value.start;
            if (sweep )  this.value.sweep    = sweep;   else  sweep  = this.value.sweep;
        }
        else
        {
            this.value = new ArcPathValue(
                this.nodeId,
                pos,
                x, 
                y, 
                width, 
                height,
                start,
                sweep);
        }


        this.setUpdateValues(parse, 
        [
            ['position', pos   ],
            ['x',        x     ],
            ['y',        y     ],
            ['width',    width ],
            ['height',   height],
            ['start',    start ],
            ['sweep',    sweep ]
        ]);


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
       if (!this.options.enabled)
           return;
           
           
        this.value.objects = [];


        if (   super.baseIsValid()
            && this.value.x     .isValid()
            && this.value.y     .isValid()
            && this.value.width .isValid()
            && this.value.height.isValid()) 
        {
            const vpos = this.value.position;
            const vx   = this.value.x;
            const vy   = this.value.y;
            const vw   = this.value.width;
            const vh   = this.value.height;

            const _x   = vpos.value <= 0 ? vx : new NumberValue(vx.value - vw.value, Math.max(vx.decimals, vw.decimals));
            const _y   = vpos.value <= 0 ? vy : new NumberValue(vy.value - vh.value, Math.max(vy.decimals, vh.decimals));
            const _w   = vpos.value <= 0 ? vw : new NumberValue(vw.value*2, Math.max(vx.decimals, vw.decimals));
            const _h   = vpos.value <= 0 ? vh : new NumberValue(vh.value*2, Math.max(vy.decimals, vh.decimals));            

            let   x    = _x.value;
            let   y    = _y.value;
            let   w    = _w.value;
            let   h    = _h.value;
            let   st   = this.value.start.value/360 * Tau;
            let   sw   = this.value.sweep.value/100 * Tau;


            [x, , w, , , ] = validateObjectRect(x, y, w, h);


            // if (   w != 0 
            //     && h != 0)
            // {
                if (!this.startInDegrees) st *= 3.6;
                if ( this.sweepInDegrees) sw /= 3.6;

                const arc = new FigmaArcPath(
                    this.nodeId,
                    this.nodeId,
                    this.nodeName,
                    vpos.value,
                    x, y, w, h, st, sw);


                const bounds = getObjBounds([arc]);
        
                arc.createDefaultSpace(x + w/2, y + h/2);
                arc.createDefaultTransform(bounds.x, bounds.y);
                arc.createDefaultTransformPoints(bounds.x, bounds.y, bounds.w, bounds.h);


                this.value.objects.push(arc);
            // }
        }


        await super.evalObjects(parse);
    }
   
    
        
    isValid()
    {
        return super.isValid()
            && this.position && this.position.isValid()
            && this.start    && this.start   .isValid()
            && this.sweep    && this.sweep   .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);
 
        if (this.position) this.position.pushValueUpdates(parse);
        if (this.start   ) this.start   .pushValueUpdates(parse);
        if (this.sweep   ) this.sweep   .pushValueUpdates(parse);
    }

   
        
    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.position) this.position.invalidateInputs(parse, from, force);
        if (this.start   ) this.start   .invalidateInputs(parse, from, force);
        if (this.sweep   ) this.sweep   .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);
 
        if (this.position) this.position.iterateLoop(parse);
        if (this.start   ) this.start   .iterateLoop(parse);
        if (this.sweep   ) this.sweep   .iterateLoop(parse);
    }
}


class GWavePath
extends GShape
{
    shape     = null;
    amplitude = null;
    frequency = null;
    offset    = null;
    alignX    = null;
    alignY    = null;

    useWavelength;
    offsetAbsolute;



    constructor(nodeId, options)
    {
        super(WAVE_PATH, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.shape     = null;
        this.amplitude = null;
        this.frequency = null;
        this.offset    = null;
        this.alignX    = null;
        this.alignY    = null;
    }



    copy()
    {
        const copy = new GWavePath(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.shape    ) copy.shape     = this.shape    .copy();
        if (this.amplitude) copy.amplitude = this.amplitude.copy();
        if (this.frequency) copy.frequency = this.frequency.copy();
        if (this.offset   ) copy.offset    = this.offset   .copy();
        if (this.alignX   ) copy.alignX    = this.alignX   .copy();
        if (this.alignY   ) copy.alignY    = this.alignY   .copy();
        
        return copy;
    }



    paramFromId(paramId)
    {
        switch (paramId)
        {
            case 'shape':     return this.input ? this.value.shape     : this.shape;
            case 'x':         return this.input ? this.value.x         : this.x;
            case 'y':         return this.input ? this.value.y         : this.y;
            case 'width':     return this.input ? this.value.width     : this.width;
            case 'amplitude': return this.input ? this.value.amplitude : this.amplitude;
            case 'frequency': return this.input ? this.value.frequency : this.frequency;
            case 'offset':    return this.input ? this.value.offset    : this.offset;
            case 'alignX':    return this.input ? this.value.alignX    : this.alignX;
            case 'alignY':    return this.input ? this.value.alignY    : this.alignY;
        }

        return super.paramFromId(paramId);
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        let [x, y, width, ] = await this.evalBaseParams(parse);


        let input     = await evalWavePathValue(this.input,     parse);
        let shape     = await evalNumberValue  (this.shape,     parse);
        let amplitude = await evalNumberValue  (this.amplitude, parse);
        let frequency = await evalNumberValue  (this.frequency, parse);
        let offset    = await evalNumberValue  (this.offset,    parse);
        let alignX    = await evalNumberValue  (this.alignX,    parse);
        let alignY    = await evalNumberValue  (this.alignY,    parse);


        if (input)
        {
            this.value        = input.copy();
            this.value.nodeId = this.nodeId;
            this.value.copyCustomParams(input);

            if (shape    )  this.value.shape     = shape;      else  shape      = this.value.shape;
            if (x        )  this.value.x         = x;          else  x          = this.value.x;      
            if (y        )  this.value.y         = y;          else  y          = this.value.y;      
            if (width    )  this.value.width     = width;      else  width      = this.value.width;  
            if (amplitude)  this.value.amplitude = amplitude;  else  amplitude  = this.value.amplitude;
            if (frequency)  this.value.frequency = frequency;  else  frequency  = this.value.frequency;
            if (offset   )  this.value.offset    = offset;     else  offset     = this.value.offset;
            if (alignX   )  this.value.alignX    = alignX;     else  alignX     = this.value.alignX;
            if (alignY   )  this.value.alignY    = alignY;     else  alignY     = this.value.alignY;
        }
        else
        {
            this.value = new WavePathValue(
                this.nodeId,
                shape,
                x, 
                y, 
                width, 
                amplitude,
                frequency,
                offset,
                alignX,
                alignY);
        }


        this.setUpdateValues(parse, 
        [
            ['shape',     shape    ],
            ['x',         x        ],
            ['y',         y        ],
            ['width',     width    ],
            ['amplitude', amplitude],
            ['frequency', frequency],
            ['offset',    offset   ],
            ['alignX',    alignX   ],
            ['alignY',    alignY   ]
        ]);


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
       if (!this.options.enabled)
           return;
           
           
        this.value.objects = [];


        if (   super.baseIsValid()
            && this.value.shape    .isValid()
            && this.value.x        .isValid()
            && this.value.y        .isValid()
            && this.value.width    .isValid()
            && this.value.amplitude.isValid()
            && this.value.frequency.isValid()
            && this.value.offset   .isValid()
            && this.value.alignX   .isValid()
            && this.value.alignY   .isValid())
        {
            const sh     = this.value.shape    .value;
            let   x      = this.value.x        .value;
            let   y      = this.value.y        .value;
            let   w      = this.value.width    .value;
            const amp    = this.value.amplitude.value;
            let   freq   = this.value.frequency.value;
            const off    = this.value.offset   .value;
            const alignX = this.value.alignX   .value;
            const alignY = this.value.alignY   .value;


            [x, y, w, , ] = validateObjectRect(x, y, w, 0);


            const _freq = this.useWavelength ? w/nozero(freq) : freq;
            const wl    = this.useWavelength ? freq : w/nozero(freq);

            const so    = this.shape.value >= 3 ? 0.25 : 0;

            const _off =
                this.offsetAbsolute
                ? off - so*wl
                : (off/100 - so) * wl;


            // if (   w   != 0 
            //     && amp != 0)
            // {
                const wave = new FigmaWavePath(
                    this.nodeId,
                    this.nodeId,
                    this.nodeName,
                    sh, 
                    x, y, w,
                    amp,
                    _freq,
                    _off,
                    alignX,
                    alignY);


                const bounds = getObjBounds([wave]);

                wave.createDefaultSpace(
                    bounds.x + bounds.width /2,            
                    bounds.y + bounds.height/2            
                );

                wave.createDefaultTransform(bounds.x, bounds.y);
                wave.createDefaultTransformPoints(bounds.x, bounds.y, bounds.w, bounds.h);


                this.value.objects.push(wave);
            //}
        }


        await super.evalObjects(parse);
    }
   
    
        
    isValid()
    {
        return super.isValid()
            && this.shape     && this.shape    .isValid()
            && this.amplitude && this.amplitude.isValid()
            && this.frequency && this.frequency.isValid()
            && this.offset    && this.offset   .isValid()
            && this.alignX    && this.alignX   .isValid()
            && this.alignY    && this.alignY   .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);
 
        if (this.shape    ) this.shape    .pushValueUpdates(parse);
        if (this.amplitude) this.amplitude.pushValueUpdates(parse);
        if (this.frequency) this.frequency.pushValueUpdates(parse);
        if (this.offset   ) this.offset   .pushValueUpdates(parse);
        if (this.alignX   ) this.alignX   .pushValueUpdates(parse);
        if (this.alignY   ) this.alignY   .pushValueUpdates(parse);
    }

   
        
    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.shape    ) this.shape    .invalidateInputs(parse, from, force);
        if (this.amplitude) this.amplitude.invalidateInputs(parse, from, force);
        if (this.frequency) this.frequency.invalidateInputs(parse, from, force);
        if (this.offset   ) this.offset   .invalidateInputs(parse, from, force);
        if (this.alignX   ) this.alignX   .invalidateInputs(parse, from, force);
        if (this.alignY   ) this.alignY   .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);
 
        if (this.shape    ) this.shape    .iterateLoop(parse);
        if (this.amplitude) this.amplitude.iterateLoop(parse);
        if (this.frequency) this.frequency.iterateLoop(parse);
        if (this.offset   ) this.offset   .iterateLoop(parse);
        if (this.alignX   ) this.alignX   .iterateLoop(parse);
        if (this.alignY   ) this.alignY   .iterateLoop(parse);
    }
}


class GShapeGroup
extends GShapeBase
{
    inputs = [];



    constructor(nodeId, options)
    {
        super(SHAPE_GROUP, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.inputs = [];
    }



    copy()
    {
        const copy = new GShapeGroup(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = new ShapeGroupValue(this.nodeId);

        this.value.objects = [];

       
        const inputs = [];
        
        if (this.options.enabled)
        {
            for (let i = 0; i < this.inputs.length; i++)
            {
                const input = await evalValue(this.inputs[i], parse);

                if (input)            
                {
                    inputs.push(input);

                    if (   input.type == SHAPE_LIST_VALUE
                        || input.type == LIST_VALUE)
                    {
                        for (const item of input.items)
                        {
                            if (!SHAPE_VALUES.includes(item.type))
                                continue;

                            this.value.items.push(item);
                            //this.value.objects.push(...item.objects.map(o => this.copyObject(o, i)));
                        }
                    }
                    else
                    {
                        this.value.items.push(input);//.copy());
                        //this.value.objects.push(...input.objects.map(o => this.copyObject(o, i)));
                    }
                }
            }
        }


        this.setUpdateValues(parse, 
        [
            ['value', this.value]
        ]);


        //await this.evalShapeBase(parse);


        await this.evalObjects(parse, {inputs: inputs});


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            

        if (this.value.items)
        {
            const group = new FigmaShapeGroup(
                this.nodeId,
                this.nodeId,
                this.nodeName);


            for (let i = 0; i < options.inputs.length; i++)
            {
                const input = options.inputs[i];

                if (input.objects)
                {
                    for (let j = 0; j < input.objects.length; j++)
                        this.addChildObject(group.children, input.objects[j], i, j);
                }
            }


            // reset object space
    
            const bounds = getObjBounds(group.children);

            const singlePoint =
                   group.children.length  == 1 
                && group.children[0].type == POINT;

            for (const obj of group.children)
            {
                // const angle1 = anglev_(obj.sp0, obj.sp1);
                // const angle2 = anglev_(obj.sp0, obj.sp2);
    
                obj.createDefaultSpace(obj.sp0.x, obj.sp0.y);
                
                // obj.sp1 = addv(obj.sp0, vector(angle1, 1));
                // obj.sp2 = addv(obj.sp0, vector(angle2, 1));

                obj.resetSpace(bounds, singlePoint);
            }


            group.x      = bounds.x;
            group.y      = bounds.y;
            group.width  = bounds.width;
            group.height = bounds.height;

            
            group.createDefaultSpace();
            group.resetSpace(bounds);

            group.createDefaultTransform(bounds.x, bounds.y);
            group.createDefaultTransformPoints(bounds.x, bounds.y, bounds.width, bounds.height);


            this.value.objects = [group];
        }
        else
        {
            this.value.objects = [];
        }


        await super.evalObjects(parse);
    }



    addChildObject(objects, _obj, inputIndex, objIndex)
    {
        const obj = copyFigmaObject(_obj);

        obj.nodeId    = this.nodeId;
        obj.objectId += OBJECT_SEPARATOR + inputIndex;// + OBJECT_SEPARATOR + objIndex;//OBJECT_SEPARATOR + this.nodeId + OBJECT_SEPARATOR + inputIndex;
        obj.listId    = -1;

        objects.push(obj);
    }



    toValue()
    {
        return this.value.copy();
    }



    isValid()
    {
        if (!super.isValid()) 
            return false;

        for (const input of this.inputs)
            if (!input.isValid())
                return false;

        return true;
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse));
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        this.inputs.forEach(i => i.invalidateInputs(parse, from, force));
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        this.inputs.forEach(i => i.iterateLoop(parse));
    }
}


class GFrame
extends GShape
{
    children = null;
    position = null;
    round    = null;
    clip     = null;



    constructor(nodeId, options)
    {
        super(FRAME, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.children = null;
        this.position = null;
        this.round    = null;
        this.clip     = null;
    }



    copy()
    {
        const copy = new GFrame(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.children) copy.children = this.children.copy();
        if (this.position) copy.position = this.position.copy();
        if (this.round   ) copy.round    = this.round   .copy();
        if (this.clip    ) copy.clip     = this.clip    .copy();

        return copy;
    }



    paramFromId(paramId)
    {
        switch (paramId)
        {
            case 'children': return this.input ? this.value.children : this.children;
            case 'position': return this.input ? this.value.position : this.position;
            case 'x':        return this.input ? this.value.x        : this.x;
            case 'y':        return this.input ? this.value.y        : this.y;
            case 'width':    return this.input ? this.value.width    : this.width;
            case 'height':   return this.input ? this.value.height   : this.height;
            case 'round':    return this.input ? this.value.round    : this.round;
            case 'clip':     return this.input ? this.value.clip     : this.clip;
        }

        return super.paramFromId(paramId);
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const [x, y, width, height] = await this.evalBaseParams(parse);

        let children = await evalListValue  (this.children, parse);
        let position = await evalNumberValue(this.position, parse);
        let round    = await evalNumberValue(this.round,    parse);
        let clip     = await evalNumberValue(this.clip,     parse);


        if (   children
            && SHAPE_VALUES.includes(children.type)
            && children.type != SHAPE_LIST_VALUE)
        {
            const objects    = children.objects;
            children         = new ListValue([children]);
            children.objects = objects;
        }


        let input = null;

        if (this.input)
        {
            input = await evalFrameValue(this.input, parse);

            this.value = new FrameValue(
                this.nodeId,
                children ?? input.children,
                position ?? input.position,
                x        ?? input.x,
                y        ?? input.y,
                width    ?? input.width,
                height   ?? input.height,
                round    ?? input.round,
                clip     ?? input.clip);
        }
        else
        {
            this.value = new FrameValue(
                this.nodeId, 
                children,
                position,
                x, 
                y, 
                width,
                height, 
                round,
                clip);
        }


        const childType = new TextValue(finalListTypeFromItems(children.items));

        this.setUpdateValues(parse, 
        [
            ['childType', childType],
            ['position',  position ],
            ['x',         x        ],
            ['y',         y        ],
            ['width',     width    ],
            ['height',    height   ],
            ['round',     round    ],
            ['clip',      clip     ]
        ]);


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        if (!this.children) this.children = this.value.children.copy();
        if (!this.position) this.position = this.value.position.copy();
        if (!this.x       ) this.x        = this.value.x       .copy();
        if (!this.y       ) this.y        = this.value.y       .copy();
        if (!this.width   ) this.width    = this.value.width   .copy();
        if (!this.height  ) this.height   = this.value.height  .copy();
        if (!this.round   ) this.round    = this.value.round   .copy();
        if (!this.clip    ) this.clip     = this.value.clip    .copy();


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            

        if (   this.value.position
            && this.value.x
            && this.value.y
            && this.value.width
            && this.value.height
            && this.value.round
            && this.value.clip)
        {
            let   pos = this.value.position.value;
            let   x   = this.value.x       .value;
            let   y   = this.value.y       .value;
            let   w   = this.value.width   .value;
            let   h   = this.value.height  .value;
            const r   = Math.max(0, this.value.round.value);
            const c   = this.value.clip    .value;


            const frame = new FigmaFrame(
                this.nodeId,
                this.nodeId,
                this.nodeName,
                x, y, w, h, r, c);


            const bounds = getObjBounds(this.value.objects);

            const singlePoint =
                   this.value.objects.length  == 1 
                && this.value.objects[0].type == POINT;

                
            const xoff = createTransform(-x, -y);

            for (let i = 0; i < this.value.objects.length; i++)
            {
                const obj = this.value.objects[i];

                // const angle1 = anglev_(obj.sp0, obj.sp1);
                // const angle2 = anglev_(obj.sp0, obj.sp2);

                obj.createDefaultSpace();
                
                // obj.sp1 = addv(obj.sp0, vector(angle1, 1));
                // obj.sp2 = addv(obj.sp0, vector(angle2, 1));

                obj.resetSpace(bounds, singlePoint);

                if (pos > 0)
                    obj.applyTransform(xoff, 2);

                this.addChildObject(frame.children, obj);
            }


            frame.createDefaultTransform(x, y);
            frame.createDefaultTransformPoints(x, y, w, h);
        
            this.value.objects = [frame];

            
            this.setUpdateValues(parse, 
            [
                ['nChildren', new NumberValue(frame.children.length)]
            ], 
            true);
        }


        await super.evalObjects(parse);
    }



    addChildObject(objects, _obj)
    {
        const obj = copyFigmaObject(_obj);
                    
        obj.nodeId   = this.nodeId;
        obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;
        obj.listId   = -1;
        
        objects.push(obj);
    }



    toValue()
    {
        return this.value.copy();
    }



    isValid()
    {
        return super.isValid()
            && this.children && this.children.isValid()
            && this.position && this.position.isValid()
            && this.round    && this.round   .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.children) this.children.pushValueUpdates(parse);
        if (this.position) this.position.pushValueUpdates(parse);
        if (this.round   ) this.round   .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.children) this.children.invalidateInputs(parse, from, force);
        if (this.position) this.position.invalidateInputs(parse, from, force);
        if (this.round   ) this.round   .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.children) this.children.iterateLoop(parse);
        if (this.position) this.position.iterateLoop(parse);
        if (this.round   ) this.round   .iterateLoop(parse);
    }
}


class GApply
extends GOperator1//Shape
{
    props   = null;
    replace = null;



    constructor(nodeId, options)
    {
        super(SHAPE_APPLY, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.props   = null;
        this.replace = null;
    }



    copy()
    {
        const copy = new GApply(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.props  ) copy.props   = this.props  .copy();
        if (this.replace) copy.replace = this.replace.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        const input   = await evalValue    (this.input,   parse);
        const props   = await evalListValue(this.props,   parse);
        const replace = await evalValue    (this.replace, parse);



        if (input)
        {
            this.value         = input;
            this.value.props   = props;
            this.value.replace = replace;
        }
        else
        {
            this.value = new NullValue();
        }

       
        await this.evalObjects(parse);


        this.setUpdateValues(parse, 
        [
            ['type',    this.outputType()],
            //['value',   this.value       ],
            ['props',   props            ],
            ['replace', replace          ]
        ]);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (this.value.isValid())
        {
            this.value.objects = 
                   this.input 
                && this.input.value
                ? this.input.value.objects.map(o => o.copy()) 
                : [];
        }


        if (this.value.objects)
        {
            for (const obj of this.value.objects)
            {
                obj.nodeId   = this.nodeId;
                obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;
            }

            this.applyProps(this.value.objects, this.value.props, this.value.replace.value);
        }

        
        await super.evalObjects(parse);
    }



    applyProps(objects, props, replace)
    {
        for (const obj of objects)
        {
            if (this.options.enabled)
            {
                // if (obj.type == SHAPE_GROUP)
                //     this.applyProps(obj.children, props, replace);

                // else

                // apply doesn't work on groups because there's no clear way
                // to determine how deep it should go in case of nested groups
                
                //if (!obj.type == SHAPE_GROUP)
                {
                    if (replace == 1)
                    {
                        obj.fills    = [];
                        obj.strokes  = [];
                        obj.effects  = [];
                        obj.maskType = 0;
                    }


                    if (isListValueType(props.type))
                    {               
                        for (let i = props.items.length-1; i >= 0; i--)
                            addProp(obj, props.items[i]);
                    }
                    else
                        addProp(obj, props);
                }
            }
        }
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }


    
    isValid()
    {
        return super.isValid()
            && this.props   && this.props  .isValid()
            && this.replace && this.replace.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.props  ) this.props  .pushValueUpdates(parse);
        if (this.replace) this.replace.pushValueUpdates(parse);
    }



   invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.props  ) this.props  .invalidateInputs(parse, from, force);
        if (this.replace) this.replace.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.props  ) this.props  .iterateLoop(parse);
        if (this.replace) this.replace.iterateLoop(parse);
    }
}


class GShapeBoolean
extends GShape
{
    children  = null;
    operation = null;



    constructor(nodeId, options)
    {
        super(SHAPE_BOOLEAN, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.children  = null;
        this.operation = null;
    }



    copy()
    {
        const copy = new GShapeBoolean(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.children ) copy.children  = this.children .copy();
        if (this.operation) copy.operation = this.operation.copy();

        return copy;
    }



    paramFromId(paramId)
    {
        switch (paramId)
        {
            case 'children':  return this.input ? this.value.children  : this.children;
            case 'operation': return this.input ? this.value.operation : this.operation;
        }

        return super.paramFromId(paramId);
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        await this.evalBaseParams(parse);

        let   children  = await evalListValue  (this.children,  parse);
        const operation = await evalNumberValue(this.operation, parse);


        if (   children
            && SHAPE_VALUES.includes(children.type)
            && children.type != SHAPE_LIST_VALUE)
        {
            const objects    = children.objects;
            children         = new ListValue([children]);
            children.objects = objects;
        }


        let input = null;

        if (this.input)
        {
            input = await evalValue(this.input, parse);

            this.value = new ShapeBooleanValue(
                this.nodeId,
                children  ?? input.children,
                operation ?? input.operation);
        }
        else
        {
            this.value = new ShapeBooleanValue(
                this.nodeId, 
                children,
                operation);
        }


        this.setUpdateValues(parse,
        [
            ['operation', operation]
        ]);


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        if (!this.children ) this.children  = this.value.children .copy();
        if (!this.operation) this.operation = this.value.operation.copy();


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            

        if (   this.value.objects
            && this.value.operation)
        {
            let typeSuffix = '';

            switch (this.operation.value)
            {
                case 0: typeSuffix = '+'; break;
                case 1: typeSuffix = '-'; break;
                case 2: typeSuffix = '*'; break;
                case 3: typeSuffix = '/'; break;
            }


            const bool = new FigmaBoolean(
                this.nodeId,
                this.nodeId + OBJECT_SEPARATOR + typeSuffix,
                this.nodeName,
                this.operation.value);


            const bounds = getObjBounds(this.value.objects);

            for (let i = 0; i < this.value.objects.length; i++)
            {
                const obj = this.value.objects[i];

                // const angle1 = anglev_(obj.sp0, obj.sp1);
                // const angle2 = anglev_(obj.sp0, obj.sp2);

                obj.createDefaultSpace();
                
                // obj.sp1 = addv(obj.sp0, vector(angle1, 1));
                // obj.sp2 = addv(obj.sp0, vector(angle2, 1));

                obj.resetSpace(bounds, false);

                this.addChildObject(bool.children, obj);
            }


            // console.log('bounds =', bounds);
            bool.x      = bounds.x;
            bool.y      = bounds.y;
            bool.width  = bounds.width;
            bool.height = bounds.height;

            
            bool.createDefaultSpace();
            bool.resetSpace(bounds);

            bool.createDefaultTransform(bounds.x, bounds.y);
            bool.createDefaultTransformPoints(bounds.x, bounds.y, bounds.width, bounds.height);
        
            this.value.objects = [bool];


            const nChildren = new NumberValue(
                this.children.objects 
                ? this.children.objects.length
                : 0);


            this.setUpdateValues(parse,
            [
                ['nChildren', nChildren]
            ],
            true);
        }
        else
        {
            this.value.objects = [];
            
            this.setUpdateValues(parse,
            [
                ['nChildren', new NumberValue(0)]
            ],
            true);
        }

        
        await super.evalObjects(parse);
    }



    addChildObject(objects, _obj)
    {
        const obj = copyFigmaObject(_obj);

        obj.nodeId   = this.nodeId;
        obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;
        obj.listId   = -1;

        objects.push(obj);
    }


    toValue()
    {
        return this.value.copy();
    }



    isValid()
    {
        return super.isValid()
            && this.children  && this.children .isValid()
            && this.operation && this.operation.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input    ) this.input    .pushValueUpdates(parse);
        if (this.children ) this.children .pushValueUpdates(parse);
        if (this.operation) this.operation.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.input    ) this.input    .invalidateInputs(parse, from, force);
        if (this.children ) this.children .invalidateInputs(parse, from, force);
        if (this.operation) this.operation.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input    ) this.input    .iterateLoop(parse);
        if (this.children ) this.children .iterateLoop(parse);
        if (this.operation) this.operation.iterateLoop(parse);
    }
}














class GPersist
extends GShapeBase
{
    inputs  = [];

    persist = null;

    finalize;



    constructor(nodeId, options)
    {
        super(PERSIST, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.inputs  = [];
        this.persist = null;
    }



    copy()
    {
        const copy = new GPersist(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        const persist  = await evalNumberValue(this.persist, parse);
        const finalize = this.finalize.value > 0;


        this.value = new ListValue();

        this.value.objects = [];


        for (let i = 0, o = 0; i < this.inputs.length; i++)
        {
            await this.inputs[i].eval(parse);

            const objects = getValidObjects(this.inputs[i].value);
        
            
            if (   this.options.enabled
                && (   finalize
                    || persist.value == 1))
            {
                for (let j = 0; j < objects.length; j++, o++)
                {
                    let obj = objects[j];

                    //obj = copyFigmaObject(obj);

                    obj.nodeId   = this.nodeId;
                    obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;
                    obj.listId   = -1;

                    if (  (   !isEmpty(obj.fills  )
                           || !isEmpty(obj.strokes))
                        && !obj.isDeco)
                            obj.persist = finalize ? 2 : 1;
                            
                    this.value.objects.push(obj);
                }
            }
        }


        this.setUpdateValues(parse, [['', new NullValue()]]);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return super.isValid()
            && !this.inputs.find(i => !i.isValid())
            && this.persist && this.persist.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse));

        if (this.persist) this.persist.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        this.inputs.forEach(i => i.invalidateInputs(parse, from, force));

        if (this.persist) this.persist.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        this.inputs.forEach(i => i.iterateLoop(parse));

        if (this.persist) this.persist.iterateLoop(parse);
    }
}


class GExport
extends GShapeBase
{
    inputs = [];

    scale;
    format;
 // contents;
 // crop;
    suffix;
 // profile;



    constructor(nodeId, options)
    {
        super(EXPORT, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.inputs = [];
        
        this.scale    = null;
        this.format   = null;
     // this.contents = null;
     // this.crop     = null;
        this.suffix   = null;
     // this.profile  = null;
    }



    copy()
    {
        const copy = new GExport(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        if (this.scale   ) copy.scale    = this.scale   .copy();
        if (this.format  ) copy.format   = this.format  .copy();
     // if (this.contents) copy.contents = this.contents.copy();
     // if (this.crop    ) copy.crop     = this.crop    .copy();
        if (this.suffix  ) copy.suffix   = this.suffix  .copy();
     // if (this.profile ) copy.profile  = this.profile .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const scale      = await evalNumberValue(this.scale,    parse);
        const format     = await evalNumberValue(this.format,   parse);
     // const contents   = await evalNumberValue(this.contents, parse);
     // const crop       = await evalNumberValue(this.crop,     parse);
        const suffix     = await evalTextValue  (this.suffix,   parse);
     // const profile    = await evalNumberValue(this.profile,  parse);


        this.value = new ListValue();

        this.value.objects = [];


        for (let i = 0, o = 0; i < this.inputs.length; i++)
        {
            await this.inputs[i].eval(parse);

            const objects = getValidObjects(this.inputs[i].value);
        
            
            for (let j = 0; j < objects.length; j++, o++)
            {
                let obj = objects[j];

                //obj = copyFigmaObject(obj);

                obj.nodeId   = this.nodeId;
                obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;
                obj.listId   = -1;

                this.value.objects.push(obj);
            }
        }


        this.setUpdateValues(parse, 
        [
            ['objectIds', new ListValue(this.value.objects.map(o => new TextValue(o.objectId)))]
        ]);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return super.isValid()
            && !this.inputs.find(i => !i.isValid())
            && this.scale    && this.scale   .isValid()
            && this.format   && this.format  .isValid()
         // && this.contents && this.contents.isValid()
         // && this.crop     && this.crop    .isValid()
            && this.suffix   && this.suffix  .isValid();
         // && this.profile  && this.profile .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse));

        if (this.scale   ) this.scale   .pushValueUpdates(parse);
        if (this.format  ) this.format  .pushValueUpdates(parse);
     // if (this.contents) this.contents.pushValueUpdates(parse);
     // if (this.crop    ) this.crop    .pushValueUpdates(parse);
        if (this.suffix  ) this.suffix  .pushValueUpdates(parse);
     // if (this.profile ) this.profile .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        this.inputs.forEach(i => i.invalidateInputs(parse, from, force));

        if (this.scale   ) this.scale   .invalidateInputs(parse, from, force);
        if (this.format  ) this.format  .invalidateInputs(parse, from, force);
     // if (this.contents) this.contents.invalidateInputs(parse, from, force);
     // if (this.crop    ) this.crop    .invalidateInputs(parse, from, force);
        if (this.suffix  ) this.suffix  .invalidateInputs(parse, from, force);
     // if (this.profile ) this.profile .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        this.inputs.forEach(i => i.iterateLoop(parse));

        if (this.scale   ) this.scale   .iterateLoop(parse);
        if (this.format  ) this.format  .iterateLoop(parse);
     // if (this.contents) this.contents.iterateLoop(parse);
     // if (this.crop    ) this.crop    .iterateLoop(parse);
        if (this.suffix  ) this.suffix  .iterateLoop(parse);
     // if (this.profile ) this.profile .iterateLoop(parse);
    }
}


class GMove
extends GOperator1
{
    moveType    = null;
    x           = null;
    y           = null;
    affectSpace = null;
    
    _a          = 0;



    constructor(nodeId, options)
    {
        super(MOVE, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.moveType    = null;
        this.x           = null;
        this.y           = null;
        this.affectSpace = null;

        this._a          = 0;
    }



    copy()
    {
        const copy = new GMove(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.moveType   ) copy.moveType    = this.moveType   .copy();
        if (this.x          ) copy.x           = this.x          .copy();
        if (this.y          ) copy.y           = this.y          .copy();
        if (this.affectSpace) copy.affectSpace = this.affectSpace.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const input       = await evalValue      (this.input,       parse);
        const moveType    = await evalNumberValue(this.moveType,    parse);
        const x           = await evalNumberValue(this.x,           parse);
        const y           = await evalNumberValue(this.y,           parse);
        const affectSpace = await evalNumberValue(this.affectSpace, parse);


        if (input)
        {
            this.value = input.copy();

            if (this.value)
                this.value.nodeId = this.nodeId;
        }
        else
        {
            this.value = new NullValue();
        }


        await this.evalObjects(
            parse, 
            {
                moveType:    moveType,
                x:           x, 
                y:           y,
                affectSpace: affectSpace
            });


        this.setUpdateValues(parse,
        [
            ['type',        this.outputType()],
            ['moveType',    moveType         ],
            ['x',           x                ],
            ['y',           y                ],
            ['affectSpace', affectSpace      ]
        ]);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (   this.value
            && this.value.isValid()
            && options.moveType
            && options.x
            && options.y
            && options.affectSpace)
        {
            this.value.objects = getValidObjects(this.input.value);


            if (isListValueType(this.value.type))
            {
                for (let i = 0; i < this.value.items.length; i++)
                    this.value.items[i].objects = this.value.objects.filter(o => o.itemIndex == i);
            }
   
            
            const moveType    = options.moveType   .value;
            const x           = options.x          .value;
            const y           = options.y          .value;
            const affectSpace = options.affectSpace.value;


            let _a = y/360*Tau;

            while (_a <  0  ) _a += Tau;
            while (_a >= Tau) _a -= Tau;    


            const _v = vector(_a, x);
            
            const _x = moveType == 0 ? x : _v.x;
            const _y = moveType == 0 ? y : _v.y;


            const xform = 
                moveType == 0
                ? createTransform(_x, _y)
                : mulm3m3(
                    createTransform(_x, _y),
                    createRotateTransform(-_a)); // for vector movement

                    
            for (const obj of this.value.objects)
            {
                obj.nodeId    = this.nodeId;
                obj.objectId += OBJECT_SEPARATOR + this.nodeId;

                if (this.options.enabled)
                    obj.applyTransform(xform, affectSpace);
            }


            if (   this.value.type == VECTOR_PATH_VALUE
                && this.value.objects
                && this.value.objects.length > 0
                && this.value.points.objects)
            {
                for (let i = 0; i < this.value.objects[0].points.length; i++)
                {
                    const p = this.value.objects[0].points[i].toPoint();
    
                    this.value.points.objects[i].x = p.x;
                    this.value.points.objects[i].y = p.y;
                }
            }
        }
        
        
        await super.evalObjects(parse);
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }
    
    
    
    isValid()
    {
        return super.isValid()
            && this.moveType    && this.moveType   .isValid()
            && this.x           && this.x          .isValid()
            && this.y           && this.y          .isValid()
            && this.affectSpace && this.affectSpace.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.moveType   ) this.moveType   .pushValueUpdates(parse);
        if (this.x          ) this.x          .pushValueUpdates(parse);
        if (this.y          ) this.y          .pushValueUpdates(parse);
        if (this.affectSpace) this.affectSpace.pushValueUpdates(parse);
    }



   invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.moveType   ) this.moveType   .invalidateInputs(parse, from, force);
        if (this.x          ) this.x          .invalidateInputs(parse, from, force);
        if (this.y          ) this.y          .invalidateInputs(parse, from, force);
        if (this.affectSpace) this.affectSpace.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.moveType   ) this.moveType   .iterateLoop(parse);
        if (this.x          ) this.x          .iterateLoop(parse);
        if (this.y          ) this.y          .iterateLoop(parse);
        if (this.affectSpace) this.affectSpace.iterateLoop(parse);
    }
}


class GAffine
extends GOperator1
{
    affectSpace = null;



    constructor(type, nodeId, options)
    {
        super(type, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.affectSpace = null;
    }



    copyBase(base)
    {
        super.copyBase(base);

        if (base.affectSpace) this.affectSpace = base.affectSpace.copy();
    }



    async evalBaseParams(parse)
    {
        const affectSpace = await evalNumberValue(this.affectSpace, parse);

        return [affectSpace];
    }



    async evalAffineObjects(parse, options, scaleCorners, scaleStyle, getXform)
    {
        if (   !this.value
            || !this.value.isValid()
            || !this.input)
            return Rect.NaN;


        this.value.objects = getValidObjects(this.input.value);
        
        if (isListValueType(this.value.type))
        {
            for (let i = 0; i < this.value.items.length; i++)
                this.value.items[i].objects = this.value.objects.filter(o => o.itemIndex == i);
        }


        const bounds = getObjBounds(this.value.objects);
        const xform  = getXform();


        for (const obj of this.value.objects)
        {
            obj.nodeId   = this.nodeId;
            obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;


            if (this.options.enabled)
            {
                obj.applyTransform(
                    xform, 
                    options.affectSpace ? options.affectSpace.value : 2);

                obj.checkFlipped(
                    options.flipX === true && xform[0][0] < 0, 
                    options.flipY === true && xform[1][1] < 0);
                    
                obj.scaleCorners *= Math.abs(scaleCorners);
                obj.scaleStyle   *= Math.abs(scaleStyle  );
                
                if (obj.type == TEXT_SHAPE)
                {
                    const sx = Math.sqrt(sqr(xform[0][0]) + sqr(xform[0][1]));
                    const sy = Math.sqrt(sqr(xform[1][0]) + sqr(xform[1][1]));

                    obj.size *= Math.min(sx, sy);
                }
            }
        }


        if (   this.value.type == VECTOR_PATH_VALUE
            && this.value.objects
            && this.value.objects.length > 0
            && this.value.points.objects)
        {
            for (let i = 0; i < this.value.objects[0].points.length; i++)
            {
                const p = this.value.objects[0].points[i].toPoint();

                this.value.points.objects[i].x = p.x;
                this.value.points.objects[i].y = p.y;
            }
        }


        return bounds;
    }



    isValid()
    {
        return super.isValid()
            && this.affectSpace && this.affectSpace.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.affectSpace) this.affectSpace.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.affectSpace) this.affectSpace.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.affectSpace) this.affectSpace.iterateLoop(parse);
    }
}


class GRotate
extends GAffine
{
    angle = null;



    constructor(nodeId, options)
    {
        super(ROTATE, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.angle = null;
    }



    copy()
    {
        const copy = new GRotate(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.angle) copy.angle = this.angle.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input = await evalValue      (this.input, parse);
        const angle = await evalNumberValue(this.angle, parse);


        const [affectSpace] = await this.evalBaseParams(parse);


        if (input)
        {
            this.value = input.copy();
            
            if (this.value)
                this.value.nodeId = this.nodeId;
        }
        else
        {
            this.value = new NullValue();
        }

       
        const _bounds = await this.evalObjects(
            parse, 
            {
                angle:       angle, 
                affectSpace: affectSpace
            });

        
        const bounds = new RectangleValue(
            this.nodeId,
            new NumberValue(_bounds.x     ), 
            new NumberValue(_bounds.y     ), 
            new NumberValue(_bounds.width ),
            new NumberValue(_bounds.height),
            new NumberValue(0));


        this.setUpdateValues(parse,
        [
            ['type',        this.outputType()],
            ['angle',       angle            ],
            ['affectSpace', affectSpace      ],
            ['bounds',      bounds           ]
        ]);


        this.validate();

        return this;
    }



    async evalObjects(parse, options)
    {
        const a     = options.angle ? options.angle.value/360*Tau : 0;
        const xform = createRotateTransform(a);

        options.flipX = false;
        options.flipY = false;

        return await this.evalAffineObjects(
            parse,
            options, 
            1, 
            1,
            () => xform);
    }



    toValue()
    {
        return this.value
        ? this.value.copy()
        : null;
    }
    
    
    
    isValid()
    {
        return super.isValid()
            && this.angle && this.angle.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.angle) this.angle.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.angle) this.angle.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.angle) this.angle.iterateLoop(parse);
    }
}


class GScale
extends GAffine
{
    scaleX        = null;
    scaleY        = null;
    affectCorners = null;
    affectStyle   = null;

    

    constructor(nodeId, options)
    {
        super(SCALE, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.scaleX        = null;
        this.scaleY        = null;
        this.affectCorners = null;
        this.affectStyle   = null;
    }



    copy()
    {
        const copy = new GScale(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.scaleX       ) copy.scaleX        = this.scaleX       .copy();
        if (this.scaleY       ) copy.scaleY        = this.scaleY       .copy();
        if (this.affectCorners) copy.affectCorners = this.affectCorners.copy();
        if (this.affectStyle  ) copy.affectStyle   = this.affectStyle  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input         = await evalValue      (this.input,         parse);
        let   scaleX        = await evalNumberValue(this.scaleX,        parse);
        let   scaleY        = await evalNumberValue(this.scaleY,        parse);
        let   affectCorners = await evalNumberValue(this.affectCorners, parse);
        let   affectStyle   = await evalNumberValue(this.affectStyle,   parse);


        const [affectSpace] = await this.evalBaseParams(parse);


        if (input)
        {
            this.value = input.copy();
            
            if (this.value)
                this.value.nodeId = this.nodeId;
        }
        else
        {
            this.value = new NullValue();
        }

       
        const _bounds = await this.evalObjects(
            parse, 
            {
                scaleX:        scaleX, 
                scaleY:        scaleY, 
                affectSpace:   affectSpace,
                affectCorners: affectCorners,
                affectStyle:   affectStyle
            });


        const bounds = new RectangleValue(
            this.nodeId,
            new NumberValue(_bounds.x     ), 
            new NumberValue(_bounds.y     ), 
            new NumberValue(_bounds.width ),
            new NumberValue(_bounds.height),
            new NumberValue(0));


        this.setUpdateValues(parse,
        [
            ['type',          this.outputType()],
            ['scaleX',        scaleX           ],
            ['scaleY',        scaleY           ],
            ['affectSpace',   affectSpace      ],
            ['affectCorners', affectCorners    ],
            ['affectStyle',   affectStyle      ],
            ['bounds',        bounds           ]
        ]);
        

        this.validate();

        return this;
    }



    async evalObjects(parse, options)
    {
        let sx = hardZero(options.scaleX.value / 100);
        let sy = hardZero(options.scaleY.value / 100);

        options.flipX = sx < 0;
        options.flipY = sy < 0;
        
        const scale = Math.min(sx, sy);

        return await this.evalAffineObjects(
            parse,
            options, 
            this.affectCorners.value > 0 ? scale : 1,
            this.affectStyle  .value > 0 ? scale : 1,
            () => [[sx, 0,  0],
                   [0,  sy, 0],
                   [0,  0,  1]]);
    }



    isValid()
    {
        return super.isValid()
            && this.scaleX        && this.scaleX       .isValid()
            && this.scaleY        && this.scaleY       .isValid()
            && this.affectCorners && this.affectCorners.isValid()
            && this.affectStyle   && this.affectStyle  .isValid();
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.scaleX       ) this.scaleX       .pushValueUpdates(parse);
        if (this.scaleY       ) this.scaleY       .pushValueUpdates(parse);
        if (this.affectCorners) this.affectCorners.pushValueUpdates(parse);
        if (this.affectStyle  ) this.affectStyle  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.scaleX       ) this.scaleX       .invalidateInputs(parse, from, force);
        if (this.scaleY       ) this.scaleY       .invalidateInputs(parse, from, force);
        if (this.affectCorners) this.affectCorners.invalidateInputs(parse, from, force);
        if (this.affectStyle  ) this.affectStyle  .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.scaleX       ) this.scaleX       .iterateLoop(parse);
        if (this.scaleY       ) this.scaleY       .iterateLoop(parse);
        if (this.affectCorners) this.affectCorners.iterateLoop(parse);
        if (this.affectStyle  ) this.affectStyle  .iterateLoop(parse);
    }
}


class GSkew
extends GAffine
{
    skewX = null;
    skewY = null;



    constructor(nodeId, options)
    {
        super(SKEW, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.skewX = null;
        this.skewY = null;
    }



    copy()
    {
        const copy = new GSkew(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.skewX) copy.skewX = this.skewX.copy();
        if (this.skewY) copy.skewY = this.skewY.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const input = await evalValue      (this.input, parse);
        let   skewX = await evalNumberValue(this.skewX, parse);
        let   skewY = await evalNumberValue(this.skewY, parse);


        const [affectSpace] = await this.evalBaseParams(parse);


        if (input)
        {
            this.value = input;

            if (this.value)
                this.value.nodeId = this.nodeId;
        }
        else
        {
            this.value = new NullValue();
        }

        
        const _bounds = await this.evalObjects(
            parse, 
            {
                skewX:       skewX, 
                skewY:       skewY, 
                affectSpace: affectSpace
            });


        const bounds = new RectangleValue(
            this.nodeId,
            new NumberValue(_bounds.x     ), 
            new NumberValue(_bounds.y     ), 
            new NumberValue(_bounds.width ),
            new NumberValue(_bounds.height),
            new NumberValue(0));


        this.setUpdateValues(parse,
        [
            ['type',        this.outputType()],
            ['skewX',       skewX            ],
            ['skewY',       skewY            ],
            ['affectSpace', affectSpace      ],
            ['bounds',      bounds           ]
        ]);


        this.validate();

        return this;
    }



    async evalObjects(parse, options)
    {
        const sx = -options.skewX.value / 100;
        const sy = -options.skewY.value / 100;

        options.flipX = false;
        options.flipY = false;

        return await this.evalAffineObjects(
            parse,
            options, 
            1, 1,
            () => [[1,  sx, 0],
                   [sy, 1,  0],
                   [0,  0,  1]]);
    }



    isValid()
    {
        return super.isValid()
            && this.skewX && this.skewX.isValid()
            && this.skewY && this.skewY.isValid();
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.skewX) this.skewX.pushValueUpdates(parse);
        if (this.skewY) this.skewY.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.skewX) this.skewX.invalidateInputs(parse, from, force);
        if (this.skewY) this.skewY.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.skewX) this.skewX.iterateLoop(parse);
        if (this.skewY) this.skewY.iterateLoop(parse);
    }
}


class GShowCenter
extends GOperator1
{
    show = null;



    constructor(nodeId, options)
    {
        super(SHOW_CENTER, nodeId, options);
    }



    copy()
    {
        const copy = new GShowCenter(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.show) copy.show = this.show.copy();
        
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input = await evalValue      (this.input, parse);
        const show  = await evalNumberValue(this.show,  parse);


        if (   input
            && show)
        {
            this.value = input;

            this.value.nodeId = this.nodeId;
        }
        else
            this.value = new NullValue();

        
        await this.evalObjects(parse, {show: show && show.value > 0});


        const type = this.outputType();

        this.setUpdateValues(parse,
        [
            ['type', type],
            ['show', show]
        ]);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (   this.value
            && this.value.isValid())
        {
            this.value.objects = getValidObjects(this.input.value);


            for (const obj of this.value.objects)
            {
                obj.nodeId   = this.nodeId;
                obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;
                
                if (   this.options.enabled
                    && options.show)
                    obj.showCenter = options.show;
            }
        }
        
        
        await super.evalObjects(parse);
    }



    toValue()
    {
        return this.value
        ? this.value.copy()
        : null;
    }



    isValid()
    {
        return super.isValid()
            && this.show && this.show.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.show) this.show.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.show) this.show.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.show) this.show.iterateLoop(parse);
    }
}


class GSetCenter
extends GOperator1
{
    centerX = null;
    centerY = null;
    units   = null;



    constructor(nodeId, options)
    {
        super(SET_CENTER, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.centerX = null;
        this.centerY = null;
        this.units   = null;
    }



    copy()
    {
        const copy = new GSetCenter(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.centerX) copy.centerX = this.centerX.copy();
        if (this.centerY) copy.centerY = this.centerY.copy();
        if (this.units  ) copy.units   = this.units  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const input   = await evalValue      (this.input,   parse);
        const centerX = await evalNumberValue(this.centerX, parse);
        const centerY = await evalNumberValue(this.centerY, parse);
        const units   = await evalNumberValue(this.units,   parse);


        if (this.input)
        {
            this.value = input.copy();

            if (this.value)
                this.value.nodeId = this.nodeId;
        }
        else
        {
            this.value = new NullValue();
        }

        
        await this.evalObjects(
            parse, 
            {
                centerX:    centerX, 
                centerY:    centerY,
                units:      units
            });


        const type = this.outputType();

        this.setUpdateValues(parse,
        [
            ['type',    type   ],
            ['centerX', centerX],
            ['centerY', centerY],
            ['units',   units  ]
        ]);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (   this.value
            && this.value.isValid())
        {
            this.value.objects = getValidObjects(this.input.value);

            
            const centerX = options.centerX    ? options.centerX   .value : 0;
            const centerY = options.centerY    ? options.centerY   .value : 0;
            const units   = options.units      ? options.units     .value : 0;
     
            const cx      = units == 0 ? centerX/100 : centerX;
            const cy      = units == 0 ? centerY/100 : centerY;


            const bounds  = getObjBounds(this.value.objects);


            const singlePoint =  
                   this.value.objects.length  == 1 
                && this.value.objects[0].type == POINT;


            for (const obj of this.value.objects)
            {
                obj.nodeId   = this.nodeId;
                obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;

                if (this.options.enabled)
                    obj.resetSpace(bounds, singlePoint, cx, cy, units);
            }
        }
        
        
        await super.evalObjects(parse);
    }



    toValue()
    {
        return this.value
            ? this.value.copy()
            : null;
    }
    
    
    
    isValid()
    {
        return super.isValid()
            && this.centerX && this.centerX.isValid()
            && this.centerY && this.centerY.isValid()
            && this.units   && this.units  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.centerX) this.centerX.pushValueUpdates(parse);
        if (this.centerY) this.centerY.pushValueUpdates(parse);
        if (this.units  ) this.units  .pushValueUpdates(parse);
    }



   invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.centerX) this.centerX.invalidateInputs(parse, from, force);
        if (this.centerY) this.centerY.invalidateInputs(parse, from, force);
        if (this.units  ) this.units  .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.centerX) this.centerX.iterateLoop(parse);
        if (this.centerY) this.centerY.iterateLoop(parse);
        if (this.units  ) this.units  .iterateLoop(parse);
    }
}


class GResetTransform
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(RESET_XFORM, nodeId, options);
    }



    copy()
    {
        const copy = new GResetTransform(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input = await evalValue(this.input, parse);


        if (input)
        {
            this.value = input;

            this.value.nodeId = this.nodeId;
        }
        else
            this.value = new NullValue();

        
        await this.evalObjects(parse);


        const type = this.outputType();

        this.setUpdateValues(parse,
        [
            ['type', type]
        ]);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (   this.value
            && this.value.isValid())
        {
            this.value.objects = getValidObjects(this.input.value);


            const bounds = getObjBounds(this.value.objects);

            const singlePoint =
                   this.value.objects.length  == 1 
                && this.value.objects[0].type == POINT;


            for (const obj of this.value.objects)
            {
                obj.nodeId    = this.nodeId;
                obj.objectId += OBJECT_SEPARATOR + this.nodeId;

                if (this.options.enabled)
                {
                    obj.createDefaultSpace();
                    obj.resetSpace(bounds, singlePoint);
                }
            }
        }
        
        
        await super.evalObjects(parse);
    }



    toValue()
    {
        return this.value
        ? this.value.copy()
        : null;
    }
}


class GJoinPaths
extends GShape
{
    inputs  = [];

    closed  = null;
    degree  = null;
    winding = null;
    round   = null;



    constructor(nodeId, options)
    {
        super(JOIN_PATHS, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.inputs  = [];

        this.closed  = null;
        this.degree  = null;
        this.winding = null;
        this.round   = null;
    }



    copy()
    {
        const copy = new GJoinPaths(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        if (this.closed ) copy.closed  = this.closed .copy();
        if (this.degree ) copy.degree  = this.degree .copy();
        if (this.winding) copy.winding = this.winding.copy();
        if (this.round  ) copy.round   = this.round  .copy();

        return copy;
    }



    paramFromId(paramId)
    {
        switch (paramId)
        {
            case 'closed':  return this.input ? this.value.closed  : this.closed;
            case 'degree':  return this.input ? this.value.degree  : this.degree;
            case 'winding': return this.input ? this.value.winding : this.winding;
            case 'round':   return this.input ? this.value.round   : this.round;
        }

        return super.paramFromId(paramId);
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const closed  = await evalNumberValue(this.closed,  parse);
        const degree  = await evalNumberValue(this.degree,  parse);
        const winding = await evalNumberValue(this.winding, parse);
        const round   = await evalNumberValue(this.round,   parse);


        if (this.inputs.length > 0)
        {
            const paths  = [];
            const points = new ListValue();

            for (const _input of this.inputs)
            {
                const input = await evalVectorPathValue(_input, parse);

                if (isListValueType(input.type)) paths.push(...input.items);
                else                             paths.push(input);
            }


            // convert each path to cubic and 
            // add the points to the list of points

            for (let i = 0; i < paths.length; i++)
            {
                const path = paths[i];
                
                if (   !path
                    || !path.objects
                    ||  path.objects.length == 0)
                    continue;


                let _degree;

                     if (path.type == VECTOR_PATH_VALUE) _degree = path.degree.value;
                else if (path.type == ARC_PATH_VALUE   ) _degree = 2;
                else if (path.type == WAVE_PATH_VALUE  ) _degree = path.shape.value == 4 ? 2 : 0;


                const pathPoints = path.objects[0].pathPoints;
                const pathDegree = Math.min(_degree, 2) + 1;

                
                if (pathPoints.length == 0) continue;


                const segment = this.makeCubic(pathPoints, pathDegree);

                if (   i > 0
                    && points.items.length > 1
                    && segment.length > 1)
                    this.joinSegment(points, segment, degree);

                points.items.push(...segment.map(p => PointValue.fromPoint(this.nodeId, p)));
            }


            if (   closed.value > 0
                && points.items.length > 1)
            {
                const segment = [ points.items[0].toPoint(),
                                  points.items[1].toPoint() ];

                this.joinSegment(points, segment, degree);

                points.items.push(points.items[0].copy());
            }


            this.value = new VectorPathValue(
                this.nodeId, 
                points, 
                closed, 
                new NumberValue(2),
                winding, 
                round);


            this.value.points.objects = this.value.points.items.map(p =>
            {
                return new FigmaPoint(
                    this.nodeId,
                    this.nodeId,
                    this.nodeName,
                    p.x.value,
                    p.y.value,
                    p.smooth ? p.smooth.value/100 : 1);
            });
        }
        else
        {
            this.value = new VectorPathValue(
                this.nodeId, 
                new ListValue(), 
                closed, 
                new NumberValue(2),
                winding, 
                round);
        }


        this.setUpdateValues(parse, 
        [
            ['closed',  closed ],
            ['degree',  degree ],
            ['winding', winding],
            ['round',   round  ]
        ]);


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        this.validate();

        return this;
    }



    joinSegment(points, segment, degree)
    {
        const p_2 = points.items.at(-2).toPoint();
        const p_1 = points.items.at(-1).toPoint();

        const p0  = segment[0];
        const p1  = segment[1];

        if (!equalv(p_1, p0))
            points.items.push(...this.getJoinPoints(p_2, p_1, p0, p1, degree).map(p => PointValue.fromPoint(this.nodeId, p)));
        else
            points.items.pop();
    }



    getJoinPoints(p_2, p_1, p0, p1, degree)
    {
        const points = [];


        switch (degree.value)
        { 
            case 0: // linear
                points.push(lerpv(p_1, p0, 1/3));
                points.push(lerpv(p_1, p0, 2/3));
                break;

            case 1: // cubic
            {
                const c = intersectLines(p_2, p_1, p1, p0, false);
                points.push(addv(p_1, mulvs(unitv(subv(c, p_1)), Math.min(distv(p_2, p_1), distv(p_1, c) * 2/3))));
                points.push(addv(p0,  mulvs(unitv(subv(c, p0 )), Math.min(distv(p1,  p0),  distv(p0,  c) * 2/3))));
                break;
            }
            case 2: // smooth
                points.push(addv(p_2, mulvs(subv(p_1, p_2), 2)));
                points.push(addv(p1,  mulvs(subv(p0,  p1),  2)));
                break;

            case 3: // sin X
                points.push(point(lerp(p_1.x, p0.x, 0.3615), p_1.y));
                points.push(point(lerp(p0.x, p_1.x, 0.3615), p0 .y));
                break;

            case 4: // sin Y
                points.push(point(p_1.x, lerp(p_1.y, p0.y, 0.3615)));
                points.push(point(p0 .x, lerp(p0.y, p_1.y, 0.3615)));
                break;
        }

        
        return points;
    }



    makeCubic(pathPoints, pathDegree)
    {
        const points = [pathPoints[0]];


        for (let i = 0; i < pathPoints.length-pathDegree; i += pathDegree)
        {
            let segPoints;

            switch (pathDegree)
            {
                case 1: segPoints = linear2cubic(pathPoints.slice(i, i+2)); break;
                case 2: segPoints =   quad2cubic(pathPoints.slice(i, i+3)); break;
                case 3: segPoints =              pathPoints.slice(i, i+4);  break;
            }

            points.push(...segPoints.slice(1)); 
        }

       
        return points;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            

        const points = [];

        for (const pt of this.value.points.items)
        {
            const p = PointValue.create(this.nodeId, pt.x.value, pt.y.value);
            
            if (pt.smooth != null)
                p.smooth = new NumberValue(pt.smooth);

            points.push(p);
        }


        this.value.objects = [];


        if (   super.baseIsValid()   
            && points.length >= 2
            && this.value.closed .isValid()
            && this.value.degree .isValid()
            && this.value.winding.isValid()
            && this.value.round  .isValid())
        {
            const path = new FigmaVectorPath(
                this.nodeId,
                this.nodeId,
                this.nodeName,
                points,
                this.value.closed .value,
                this.value.degree .value,
                this.value.winding.value,
                this.value.round  .value);

                
            const bounds = getObjBounds([path]);

            let x = bounds.x;
            let y = bounds.y;
            let w = bounds.w;
            let h = bounds.h;

            
            path.createDefaultSpace(x + w/2, y + h/2);
            path.createDefaultTransform(x, y);
            path.createDefaultTransformPoints(x, y, w, h);

            this.value.objects.push(path);
        }


        await super.evalObjects(parse);
    }



    isValid()
    {
        if (!super.isValid()) 
            return false;

        for (const input of this.inputs)
            if (!input.isValid())
                return false;

        return this.closed  && this.closed .isValid()
            && this.degree  && this.degree .isValid()
            && this.winding && this.winding.isValid()
            && this.round   && this.round  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse));

        if (this.closed ) this.closed .pushValueUpdates(parse);
        if (this.degree ) this.degree .pushValueUpdates(parse);
        if (this.winding) this.winding.pushValueUpdates(parse);
        if (this.round  ) this.round  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        this.inputs.forEach(i => i.invalidateInputs(parse, from, force));

        if (this.closed ) this.closed .invalidateInputs(parse, from, force);
        if (this.degree ) this.degree .invalidateInputs(parse, from, force);
        if (this.winding) this.winding.invalidateInputs(parse, from, force);
        if (this.round  ) this.round  .invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        this.inputs.forEach(i => i.iterateLoop(parse));

        if (this.closed ) this.closed .iterateLoop(parse);
        if (this.degree ) this.degree .iterateLoop(parse);
        if (this.winding) this.winding.iterateLoop(parse);
        if (this.round  ) this.round  .iterateLoop(parse);
    }
}


class GReorientPaths
extends GShape
{
    inputs  = [];

    reverse = null;



    constructor(nodeId, options)
    {
        super(JOIN_PATHS, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.inputs  = [];

        this.reverse = null;
    }



    copy()
    {
        const copy = new GReorientPaths(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        if (this.reverse) copy.reverse = this.reverse.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const reverse = await evalNumberValue(this.reverse, parse);


        if (this.inputs.length > 0)
        {
            const paths = [];

            for (const _input of this.inputs)
            {
                const input = await evalVectorPathValue(_input, parse);

                if (isListValueType(input.type)) paths.push(...input.items);
                else                             paths.push(input);
            }


            this.value = new ListValue();


            const reorientedPaths = 
                this.options.enabled
                ? reorientPaths(paths, reverse.value > 0)
                : paths
                      .filter(path => path.objects && path.objects.length > 0)
                      .map   (path => path.objects[0].pathPoints);
        ;

            consoleAssert(paths.length == reorientedPaths.length, 'original path count must match reoriented path count');
            
            
            for (let i = 0; i < reorientedPaths.length; i++)
            {
                const points = 
                    reorientedPaths[i]
                    ? reorientedPaths[i].map(p => PointValue.fromPoint(this.nodeId, p))
                    :    paths[i]
                    && paths[i].points
                    ? paths[i].points.items
                    : [];

                if (points.length == 0)
                    continue;
                
                const path = new VectorPathValue(
                    this.nodeId,
                    new ListValue(points),
                    paths[i].closed,
                    paths[i].degree,
                    paths[i].winding,
                    paths[i].round);
                    
                path.copyBase(paths[i]);
                
                this.value.items.push(path);
            }
        }
        else
        {
            this.value = new ListValue();
        }


        this.setUpdateValues(parse, 
        [
            ['reverse', reverse]
        ]);


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        this.value.objects = [];


        for (let i = 0; i < this.value.items.length; i++)
        {
            const _path = this.value.items[i];
            if (!_path) continue;


            if (   _path.points.items.length >= 2
                && _path.closed .isValid()
                && _path.degree .isValid()
                && _path.winding.isValid()
                && _path.round  .isValid())
            {
                const path = new FigmaVectorPath(
                     this.nodeId,
                     this.nodeId + OBJECT_SEPARATOR + i,
                     this.nodeName,
                    _path.points.items,
                    _path.closed .value,
                    _path.degree .value,
                    _path.winding.value,
                    _path.round  .value);


                if (_path.props)
                    addProps(path, _path.props);

                    
                _path.objects = [path];

                this.value.objects.push(path);
            }
        }


        const bounds = getObjBounds(this.value.objects);

        for (const path of this.value.objects)
        {
            path.createDefaultSpace(
                bounds.x + bounds.width /2,            
                bounds.y + bounds.height/2            
            );


            let x = bounds.x;
            let y = bounds.y;
            let w = bounds.w;
            let h = bounds.h;
            
            path.createDefaultTransform(x, y);
            path.createDefaultTransformPoints(x, y, w, h);
        }


        await super.evalObjects(parse);
    }



    isValid()
    {
        if (!super.isValid()) 
            return false;

        for (const input of this.inputs)
            if (!input.isValid())
                return false;

        return this.reverse && this.reverse.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse));

        if (this.reverse) this.reverse.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        this.inputs.forEach(i => i.invalidateInputs(parse, from, force));
    
        if (this.reverse) this.reverse.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        this.inputs.forEach(i => i.iterateLoop(parse));

        if (this.reverse) this.reverse.iterateLoop(parse);
    }
}



function reorientPaths(paths, reverse) 
{
    const orderedPaths = [];

    let remainingPaths = paths
        .filter(path => path.objects && path.objects.length > 0)
        .map   (path => path.objects[0].pathPoints);


    orderedPaths.push(remainingPaths.shift());


    while (remainingPaths.length > 0) 
    {
        const currentPath = orderedPaths.at(-1);
        
        const { closestPathIndex, shouldReverse } = findNextPath(currentPath, remainingPaths);

        if (closestPathIndex == -1) 
            break; // no more close curves found

        let nextPath = remainingPaths.splice(closestPathIndex, 1)[0];
        
        if (shouldReverse)
            nextPath.reverse();

        orderedPaths.push(nextPath);
    }


    return reverse
         ? orderedPaths.reverse().map(path => path.slice().reverse())
         : orderedPaths;
}



function findNextPath(currentPath, remainingPaths)
{
    let minDistance      = Infinity;
    let closestPathIndex = -1;
    let shouldReverse    = false;


    const currentEndPoint = currentPath.at(-1);

    remainingPaths.forEach((path, index) => 
    {
        const distanceToStart = distv(currentEndPoint, path.at( 0));
        const distanceToEnd   = distv(currentEndPoint, path.at(-1));

        if (distanceToStart < minDistance) 
        {
            minDistance      = distanceToStart;
            closestPathIndex = index;
            shouldReverse    = false;
        }

        if (distanceToEnd < minDistance) 
        {
            minDistance      = distanceToEnd;
            closestPathIndex = index;
            shouldReverse    = true;
        }
    });


    return { closestPathIndex, shouldReverse };
}


class GMeasureVector
extends GOperator1
{
    length = null;
    angle  = null;


    
    constructor(nodeId, options)
    {
        super(MEASURE_VECTOR, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.length = null;
        this.angle  = null;
    }



    copy()
    {
        const copy = new GMeasureVector(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.length) copy.length = this.length.copy();
        if (this.angle ) copy.angle  = this.angle .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input = await evalPointValue(this.input, parse);


        if (input)
        {
            const v   = input.toPoint();

            const len = lengthv(v);
            let   ang = anglev (v);

            if (ang > Tau/2) ang -= Tau;

            this.length = new NumberValue(len, -2);

            this.angle = 
                len > 0 
                ? new NumberValue(ang/Tau * 360, -2) 
                : NumberValue.NaN.copy();
        }
        else
        {
            this.length = NumberValue.NaN.copy();
            this.angle  = NumberValue.NaN.copy();
        }


        this.setUpdateValues(parse,
        [
            ['length', this.length],
            ['angle',  this.angle ]
        ]);
        

        this.validate();

        return this;
    }
}


class GPointAngle
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(POINT_ANGLE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GPointAngle(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input = await evalPointValue(this.input, parse);


        if (input)
        {
            if (isListValueType(input.type))
            {
                this.value = new ListValue();

                for (let i = 0; i < input.items.length; i++)
                {
                    const item = input.items[i];
                    const obj  = input.objects[i];

                    this.value.items.push(
                        item.type == POINT_VALUE
                        ? new NumberValue(anglev2(obj.sp0, obj.sp1) / Tau * 360)
                        : NumberValue.NaN.copy());   
                }
            }
            else
            {
                if (input.objects)
                {
                    const obj = input.objects[0];
                    this.value = new NumberValue(anglev2(obj.sp0, obj.sp1) / Tau * 360);
                }
            }
        }
        else
            this.value = NumberValue.NaN.copy();


        this.setUpdateValues(parse,
        [
            //['value', this.value       ],
            ['type',  this.outputType()]
        ]);


        this.validate();

        return this;
    }
}



// function getCharacterToCodeValue(input)
// {
//     return input.value.length > 0
//          ? new NumberValue(input.value.charCodeAt(0))
//          : NumberValue.NaN.copy();
// }


class GVector
extends GOperator2
{
    transform = null;



    constructor(nodeId, options)
    {
        super(VECTOR, nodeId, options);
    }


    
    reset()
    {
        super.reset();
        
        this.transform = null;
    }



    copy()
    {
        const copy = new GVector(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.transform) copy.transform = this.transform .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input0    = await evalPointValue (this.input0,    parse);
        const input1    = await evalPointValue (this.input1,    parse);
        const transform = await evalNumberValue(this.transform, parse);


        if (   input0 && input0.objects && input0.objects.length > 0 && input0.objects[0]
            && input1 && input1.objects && input1.objects.length > 0 && input1.objects[0])
        {
            this.value = PointValue.fromPoint(
                this.nodeId,
                subv(input1.objects[0].toPoint(), input0.objects[0].toPoint()));

            await this.evalObjects(
                parse, 
                {
                    transform: transform,
                });
        }
        else
        {
            this.value = PointValue.NaN.copy();
        }


        this.setUpdateValues(parse,
        [
            ['transform', transform]
        ]);
        

        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        // if (!this.options.enabled)
        //     return;
            
            
        if (!this.value.objects)
            this.value.objects = [];


        if (   this.value.x
            && this.value.y   
            && this.value.x.isValid()
            && this.value.y.isValid())
        {
            const x = this.value.x.value;
            const y = this.value.y.value;

            const point = new FigmaPoint(
                this.nodeId,
                this.nodeId,
                this.nodeName,
                x,
                y,
                this.smooth ? this.smooth.value/100 : 1);


            point.createDefaultTransform(x, y);

            
            if (options.transform.value > 0)
            {
                point.applyTransform(
                    getTransformFromAngle(anglev(point.toPoint())),
                    2);
            }
    
    
            this.value.objects = [point];
        }


        await super.evalObjects(parse);
    }



    isValid()
    {
        return super.isValid()
            && this.transform && this.transform.isValid();
}



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.transform) this.transform.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.transform) this.transform.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.transform) this.transform.iterateLoop(parse);
    }
}



function getTransformFromAngle(a) 
{
    const cosa = Math.cos(a);
    const sina = Math.sin(a);

    return [[ cosa, -sina, 0 ], 
            [ sina,  cosa, 0 ], 
            [ 0,     0,    1 ]];
}


class GCircleCenter
extends GOperator3
{
    constructor(nodeId, options)
    {
        super(CIRCLE_CENTER, nodeId, options);
    }


    
    // reset()
    // {
    //     super.reset();
    // }



    copy()
    {
        const copy = new GCircleCenter(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input0 = await evalPointValue(this.input0, parse);
        const input1 = await evalPointValue(this.input1, parse);
        const input2 = await evalPointValue(this.input2, parse);


        if (   input0 && input0.isValid()
            && input1 && input1.isValid()
            && input2 && input2.isValid())
        {
            const pc = circleCenter(
                input0.toPoint(),
                input1.toPoint(),
                input2.toPoint());

            this.value = PointValue.fromPoint(this.nodeId, pc);
        }
        else
        {
            this.value = PointValue.NaN.copy();
        }


        await this.evalObjects(parse);


        this.setUpdateValues(parse, 
        [
            ['', new NullValue()]
            //['value', this.value]
        ]);
        

        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            
            
        this.value.objects = [];


        if (   this.value.x.isValid()
            && this.value.y.isValid())
        {
            const x = this.value.x.value;
            const y = this.value.y.value;

            const point = new FigmaPoint(this.nodeId, this.nodeId, this.nodeName, x, y);

            point.createDefaultTransform(x, y);

            this.value.objects = [point];
        }


        await super.evalObjects(parse);
    }
}


class GArcFromPoints
extends GShape
{
    input0  = null;
    input1  = null;
    input2  = null;

    

    constructor(nodeId, options)
    {
        super(ARC_FROM_POINTS, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.input0  = null;
        this.input1  = null;
        this.input2  = null;
    }



    copy()
    {
        const copy = new GArcFromPoints(this.nodeId, this.options);

        copy.copyBase(this);

        if (base.input0 ) this.input0  = base.input0 .copy();
        if (base.input1 ) this.input1  = base.input1 .copy();
        if (base.input2 ) this.input2  = base.input2 .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input0 = await evalPointValue(this.input0, parse);
        const input1 = await evalPointValue(this.input1, parse);
        const input2 = await evalPointValue(this.input2, parse);


        if (   input0 && input0.isValid()
            && input1 && input1.isValid()
            && input2 && input2.isValid())
        {
            // const objPoints = this.value.points.objects.filter(o => o.type == POINT);

            const p0 = input0.objects[0].toPoint();
            const p1 = input1.objects[0].toPoint();
            const p2 = input2.objects[0].toPoint();

            const points = makeArc(p0, p1, p2);

            this.value = new VectorPathValue(
                this.nodeId,
                new ListValue(points.map(p => PointValue.fromPoint(this.nodeId, p))),
                new NumberValue(0),
                new NumberValue(2),
                new NumberValue(0),
                new NumberValue(0));
        }
        else
        {
            this.value = VectorPathValue.NaN.copy();
        }


        this.setUpdateValues(parse, 
        [
            ['', new NullValue()]
        ]);


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            
            
        const points = [];

        if (this.value.points)
        {
            for (const pt of this.value.points.items)
            {
                const p = PointValue.create(this.nodeId, pt.x.value, pt.y.value);
                
                if (pt.smooth != null)
                    p.smooth = new NumberValue(pt.smooth);

                points.push(p);
            }
        }


        this.value.objects = [];


        if (   points.length >= 2
            && this.value
            && this.value.closed .isValid()
            && this.value.degree .isValid()
            && this.value.winding.isValid()
            && this.value.round  .isValid())
        {
            const path = new FigmaVectorPath(
                this.nodeId,
                this.nodeId,
                this.nodeName,
                points,
                this.value.closed .value,
                this.value.degree .value,
                this.value.winding.value,
                this.value.round  .value);

            
            const bounds = getObjBounds([path]);

            let x = bounds.x;
            let y = bounds.y;
            let w = bounds.w;
            let h = bounds.h;

            
            path.createDefaultSpace(x + w/2, y + h/2);
            path.createDefaultTransform(x, y);
            path.createDefaultTransformPoints(x, y, w, h);

            this.value.objects.push(path);
        }


        await super.evalObjects(parse);
    }



    isValid()
    {
        return super.isValid()
            && this.input0 && this.input0.isValid()
            && this.input1 && this.input1.isValid()
            && this.input2 && this.input2.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input0) this.input0.pushValueUpdates(parse);
        if (this.input1) this.input1.pushValueUpdates(parse);
        if (this.input2) this.input2.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.input0) this.input0.invalidateInputs(parse, from, force);
        if (this.input1) this.input1.invalidateInputs(parse, from, force);
        if (this.input2) this.input2.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input0) this.input0.iterateLoop(parse);
        if (this.input1) this.input1.iterateLoop(parse);
        if (this.input2) this.input2.iterateLoop(parse);
    }
}


class GPathLength
extends GOperator1
{
    length;



    constructor(nodeId, options)
    {
        super(PATH_LENGTH, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.length = null;
    }



    copy()
    {
        const copy = new GPathLength(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.length) copy.length = this.length.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input = await evalVectorPathValue(this.input, parse);


        if (   input
            && input.objects.length > 0)
        {
            consoleAssert(input.type == VECTOR_PATH_VALUE, 'input must be VECTOR_PATH_VALUE');

            const degree = Math.min(input.degree.value, 2) + 1;

            const points = createCcompleteCurve(
                degree, 
                input.objects[0].pathPoints, 
                input.closed.value > 0);


            let length = curveLength(degree, points);


            if (input.closed.value > 0)
            {
                const endPoints = points.slice(points.length - degree);
                length += curveLength(degree, [...endPoints, points[0]]);
            }

            this.length = new NumberValue(length, -2);
        }
        else
            this.length = NumberValue.NaN.copy();
    

        this.setUpdateValues(parse,
        [
            ['length', this.length]
        ]);


        this.validate();

        return this;
    }
}



class GPointAlongPath
extends GOperator1
{
    position  = null;
    distance  = null;
    offset    = null;
    transform = null;
    
    
    
    constructor(nodeId, options)
    {
        super(POINT_ALONG_PATH, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.position  = null;
        this.distance  = null;
        this.offset    = null;
        this.transform = null;
    }



    copy()
    {
        const copy = new GPointAlongPath(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.position ) copy.position  = this.position .copy();
        if (this.distance ) copy.distance  = this.distance .copy();
        if (this.offset   ) copy.offset    = this.offset   .copy();
        if (this.transform) copy.transform = this.transform.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input     = await evalVectorPathValue(this.input,     parse);
        const position  = await evalNumberValue    (this.position,  parse);
        const distance  = await evalNumberValue    (this.distance,  parse);
        const offset    = await evalNumberValue    (this.offset,    parse);
        const transform = await evalNumberValue    (this.transform, parse);


        let pt;
        let tangent = point_NaN;


        if (   input
            && input.objects.length > 0)
        {
            const degree = Math.min(input.degree.value, 2) + 1;

            const points = createCompleteCurve(
                degree, 
                input.objects[0].pathPoints, 
                input.closed.value > 0);


            let length = curveLength(degree, points);

            
            const dist = 
                position.value > 0 
                ? distance.value                                         // absolute
                : Math.min(Math.max(0, distance.value/100), 1) * length; // relative


            if (   dist >= 0 
                && dist <= length
                && points.length >= degree-1)
            {
                pt      =   pointAlongCurve(degree, points, dist);
                tangent = tangentAlongCurve(degree, points, dist);

                this.value = PointValue.fromPoint(this.nodeId, pt);
            }
            else
                this.value = PointValue.NaN.copy();
        }
        else
            this.value = PointValue.NaN.copy();


        this.setUpdateValues(parse,
        [
            ['position',  position ],
            ['distance',  distance ],
            ['offset',    offset   ],
            ['transform', transform]
        ]);
        

        await this.evalObjects(parse,
        {
            transform:  transform,
            tangent:    tangent,
            offset:     offset.value
        });


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            
            
        if (!this.value.objects)
            this.value.objects = [];


        if (   this.value.x
            && this.value.y   
            && this.value.x.isValid()
            && this.value.y.isValid())
        {
            const x = this.value.x.value;
            const y = this.value.y.value;

            const point = new FigmaPoint(
                this.nodeId,
                this.nodeId,
                this.nodeName,
                x,
                y,
                this.smooth ? this.smooth.value/100 : 1);

            point.createDefaultTransform(x, y);


            if (   options.transform.value > 0
                && options.tangent)
            {
                const a     = -anglev(options.tangent);
                let   xform = createTransform();

                xform = mulm3m3(xform, createRotateTransform(a));

                if (options.offset)
                    xform = mulm3m3(xform, createTransform(0, options.offset));

                point.applyTransform(xform, options.transform.value > 0 ? 2 : 0);
            }


            this.value.objects = [point];
        }


        await super.evalObjects(parse);
    }



    isValid()
    {
        return super.isValid()
            && this.position  && this.position .isValid()
            && this.distance  && this.distance .isValid()
            && this.offset    && this.offset   .isValid()
            && this.transform && this.transform.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.position ) this.position .pushValueUpdates(parse);
        if (this.distance ) this.distance .pushValueUpdates(parse);
        if (this.offset   ) this.offset   .pushValueUpdates(parse);
        if (this.transform) this.transform.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.position ) this.position .invalidateInputs(parse, from, force);
        if (this.distance ) this.distance .invalidateInputs(parse, from, force);
        if (this.offset   ) this.offset   .invalidateInputs(parse, from, force);
        if (this.transform) this.transform.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.position ) this.position .iterateLoop(parse);
        if (this.distance ) this.distance .iterateLoop(parse);
        if (this.offset   ) this.offset   .iterateLoop(parse);
        if (this.transform) this.transform.iterateLoop(parse);
    }
}


class GClosestPointOnPath
extends GOperator2
{
    constrain = null;
    transform = null;
    
    
    
    constructor(nodeId, options)
    {
        super(CLOSEST_POINT_ON_PATH, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.constrain = null;
        this.transform = null;
    }



    copy()
    {
        const copy = new GClosestPointOnPath(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.constrain) copy.constrain  = this.constrain.copy();
        if (this.transform) copy.transform  = this.transform.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input0    = await evalVectorPathValue(this.input0,     parse);
        const input1    = await evalPointValue     (this.input1,     parse);

        const constrain = await evalNumberValue    (this.constrain,  parse);
        const transform = await evalNumberValue    (this.transform,  parse);


        let tangent = point_NaN;


        if (   input0
            && input1
            && input0.objects.length > 0
            && input1.objects.length > 0)
        {
            const degree = Math.min(input0.degree.value, 2) + 1;

            const points = createCompleteCurve(
                degree, 
                input0.objects[0].pathPoints, 
                input0.closed.value > 0);

            let closest;
            [closest, tangent] = closestTangentOnCurve(
                degree, 
                points, 
                input1.objects[0].toPoint(),
                constrain.value);
                
            this.value = PointValue.fromPoint(this.nodeId, closest);
        }
        else
            this.value = PointValue.NaN.copy();


        this.setUpdateValues(parse,
        [
            ['constrain',  constrain ],
            ['transform',  transform ]
        ]);
        

        await this.evalObjects(parse,
        {
            transform: transform,
            tangent:   tangent
        });


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            
            
        if (!this.value.objects)
            this.value.objects = [];


        if (   this.value.x
            && this.value.y   
            && this.value.x.isValid()
            && this.value.y.isValid())
        {
            const x = this.value.x.value;
            const y = this.value.y.value;

            const point = new FigmaPoint(
                this.nodeId,
                this.nodeId,
                this.nodeName,
                x,
                y,
                this.smooth ? this.smooth.value/100 : 1);

            point.createDefaultTransform(x, y);


            if (   options.transform.value > 0
                && options.tangent)
            {
                const a     = -anglev(options.tangent);
                const xform =  createRotateTransform(a);

                point.applyTransform(xform, options.transform.value > 0 ? 2 : 0);
            }
            
            
            this.value.objects = [point];
        }


        await super.evalObjects(parse);
    }



    isValid()
    {
        return super.isValid()
            && this.transform && this.transform.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.transform) this.transform.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.transform) this.transform.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.transform) this.transform.iterateLoop(parse);
    }
}


class GIntersectLines
extends GOperator4
{
    segment = null;



    constructor(nodeId, options)
    {
        super(INTERSECT_LINES, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        if (this.segment) this.segment.reset();
    }



    copy()
    {
        const copy = new GIntersectLines(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.segment) copy.segment = this.segment.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input0  = await evalPointValue (this.input0,  parse);
        const input1  = await evalPointValue (this.input1,  parse);
        const input2  = await evalPointValue (this.input2,  parse);
        const input3  = await evalPointValue (this.input3,  parse);
        const segment = await evalNumberValue(this.segment, parse);


        if (   input0
            && input1
            && input2
            && input3)
        {
            const p = intersectLines(
                input0.toPoint(),
                input1.toPoint(),
                input2.toPoint(),
                input3.toPoint(),
                segment.value > 0);

            this.value = PointValue.fromPoint(this.nodeId, p);
        }
        else
        {
            this.value = PointValue.NaN.copy();
        }


        await this.evalObjects(parse);


        this.setUpdateValues(parse, 
        [
            ['value',   this.value],
            ['segment', segment   ]
        ]);
        

        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            
            
        this.value.objects = [];


        if (   this.value.x.isValid()
            && this.value.y.isValid())
        {
            const x = this.value.x.value;
            const y = this.value.y.value;

            const point = new FigmaPoint(this.nodeId, this.nodeId, this.nodeName, x, y);

            point.createDefaultTransform(x, y);

            this.value.objects = [point];
        }


        await super.evalObjects(parse);
    }



    isValid()
    {
        return super.isValid()
            && this.segment && this.segment.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.segment) this.segment.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.segment) this.segment.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.segment) this.segment.iterateLoop(parse);
    }
}


class GInterpolatePoint
extends GOperator2
{
    amount    = null;
    transform = null;


    
    constructor(nodeId, options)
    {
        super(INTERPOLATE_POINT, nodeId, options);
    }


    
    reset()
    {
        super.reset();

        this.amount    = null;
        this.transform = null;
    }



    copy()
    {
        const copy = new GInterpolatePoint(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.amount   ) copy.amount    = this.amount   .copy();
        if (this.transform) copy.transform = this.transform.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input0    = await evalPointValue (this.input0,    parse);
        const input1    = await evalPointValue (this.input1,    parse);
        const amount    = await evalNumberValue(this.amount,    parse);
        const transform = await evalNumberValue(this.transform, parse);


        if (   input0 && input0.isValid() && input0.objects  && input0.objects.length > 0
            && input1 && input1.isValid() && input1.objects  && input1.objects.length > 0)
        {
            const p0  = point(input0.objects[0].x, input0.objects[0].y);
            const p1  = point(input1.objects[0].x, input1.objects[0].y);
            const amt = amount.value / 100;

            const p   = lerpv(p0, p1, amt);

                
            let sp0 = lerpv(input0.objects[0].sp0, input1.objects[0].sp0, amt);
            let sp1 = lerpv(input0.objects[0].sp1, input1.objects[0].sp1, amt);
            let sp2 = lerpv(input0.objects[0].sp2, input1.objects[0].sp2, amt);

            if (transform.value > 0)
            {
                const l1 = distv(sp0, sp1);
                const l2 = distv(sp0, sp2);

                sp0 = clone(p);
                sp1 = addv(sp0, mulvs(unitv(subv(p1, p0)), l1));
                sp2 = addv(sp0, crossv(mulvs(unitv(subv(p1, p0)), l2)));
            }


            this.value = new PointValue(this.nodeId, new NumberValue(p.x), new NumberValue(p.y));

            const pt = new FigmaPoint(this.nodeId, this.nodeId, this.nodeName, p.x, p.y);
            pt.createDefaultTransform(p.x, p.y);
            this.value.objects = [pt];

            this.value.objects[0].sp0 = sp0;
            this.value.objects[0].sp1 = sp1;
            this.value.objects[0].sp2 = sp2;
        }
        else
            this.value = PointValue.NaN.copy();


        this.setUpdateValues(parse,
        [
            ['amount',    amount   ],
            ['transform', transform]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.amount    && this.amount   .isValid()
            && this.transform && this.transform.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.amount   ) this.amount   .pushValueUpdates(parse);
        if (this.transform) this.transform.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.amount   ) this.amount   .invalidateInputs(parse, from, force);
        if (this.transform) this.transform.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.amount   ) this.amount   .iterateLoop(parse);
        if (this.transform) this.transform.iterateLoop(parse);
    }
}


class GReversePath
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(REVERSE_PATH, nodeId, options);
    }



    copy()
    {
        const copy = new GReversePath(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const input = await evalVectorPathValue(this.input, parse);


        if (   input
            && input.objects.length > 0
            && input.objects[0].pathPoints)
        {
            this.value        = input.copy();
            this.value.nodeId = this.nodeId;
        }
        else
        {
            this.value = new NullValue();
        }


        await this.evalObjects(parse);


        this.setUpdateValues(parse,
        [
            ['type', this.outputType()]
        ]);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (   this.value
            && this.value.isValid())
        {
            this.value.objects = getValidObjects(this.input.value);


            for (const obj of this.value.objects)
            {
                obj.nodeId   = this.nodeId;
                obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;

                if (   this.options.enabled
                    && PATH_TYPES.includes(obj.type))
                    obj.pathPoints.reverse();
            }
        }
        
        
        await super.evalObjects(parse);
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }
}


class GBlendPath
extends GShape
{
    inputs = [];

    amount;
    degree;



    constructor(nodeId, options)
    {
        super(BLEND_PATH, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.inputs = [];

        this.amount = null;
        this.degree = null;
    }



    copy()
    {
        const copy = new GBlendPath(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        if (this.amount) copy.amount = this.amount.copy();
        if (this.degree) copy.degree = this.degree.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const amount = await evalNumberValue(this.amount, parse);
        const degree = await evalNumberValue(this.degree, parse);


        const paths = [];
        
        for (const _input of this.inputs)
        {
            const input = await evalVectorPathValue(_input, parse);

            if (isListValueType(input.type))
            {
                for (const item of input.items)
                {
                    const path = await evalVectorPathValue(item, parse);
                    paths.push(path);
                }
            }
            else
            {
                const path = await evalVectorPathValue(input, parse);
                paths.push(path);
            }
        }
        
        
        if (paths.length == 1)
            this.value = paths[0];

        else if (paths.length > 0)
        {
            // convert all paths to cubic

            // find the index and localAmount for maxSegments

            

            // const index = Math.min(Math.floor((values.length-1)/deg * amount.value/100), nSegments-1);

            // const localAmount = 
            //     nSegments > 1
            //     ? (amount.value/100 - index/nSegments) * nSegments
            //     : amount.value/100;


            // if (degree.value == 0) // linear
            // {
            //     const val0 = paths[index*deg  ];
            //     const val1 = paths[index*deg+1];

            //     this.value = new NumberValue(
            //         lerp(val0.value, val1.value, localAmount),
            //         maxDec);
            // }
            // else if (degree.value == 1) // smooth
            // {
            //     const val0 = paths[index*deg  ];
            //     const val1 = paths[index*deg+1];

            //     this.value = new NumberValue(
            //         lerpCos(val0.value, val1.value, localAmount),
            //         maxDec);
            // }
            // else
                this.value = VectorPathValue.NaN.copy();
        }

        else                  
            this.value = VectorPathValue.NaN.copy();


        await this.evalObjects(parse);


        this.setUpdateValues(parse,
        [
            ['type',   this.outputType()],
            ['amount', amount           ],
            ['degree', degree           ]
        ]);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (   this.value
            && this.value.isValid())
        {
            this.value.objects = getValidObjects(this.input.value);


            for (const obj of this.value.objects)
            {
                obj.nodeId   = this.nodeId;
                obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;

                // if (PATH_TYPES.includes(obj.type))
                //     obj.pathPoints.reverse();
            }
        }
        
        
        await super.evalObjects(parse);
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return  super.isValid()
            &&  this.inputs.length > 0
            && !this.inputs.find(i => !i.isValid())
            &&  this.amount && this.amount.isValid()
            &&  this.degree && this.degree.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse));

        if (this.amount) this.amount.pushValueUpdates(parse);
        if (this.degree) this.degree.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        this.inputs.forEach(i => i.invalidateInputs(parse, from, force));

        if (this.amount) this.amount.invalidateInputs(parse, from, force);
        if (this.degree) this.degree.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        this.inputs.forEach(i => i.iterateLoop(parse));

        if (this.amount) this.amount.iterateLoop(parse);
        if (this.degree) this.degree.iterateLoop(parse);
    }
}


class GPlace
extends GOperator1
{
    position  = null;
    transform = null;
    
    

    constructor(nodeId, options)
    {
        super(PLACE, nodeId, options);
    }



    reset()
    {
        super.reset();
        
        this.position  = null;
        this.transform = null;
    }



    copy()
    {
        const copy = new GPlace(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.position ) copy.position  = this.position .copy();
        if (this.transform) copy.transform = this.transform.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const input     = await evalValue      (this.input,     parse);
        const position  = await evalPointValue (this.position,  parse);
        const transform = await evalNumberValue(this.transform, parse);

        if (   input
            && position)
        {
            this.value = input.copy();

            if (this.value)
                this.value.nodeId = this.nodeId;
        }
        else
            this.value = new NullValue();


        if (   position
            && position.isValid()
            && position.objects
            && position.objects.length > 0)
        {
            const p0 = point(
                position.objects[0].x, 
                position.objects[0].y);

            const p1 = addv(p0, subv(position.objects[0].sp1, position.objects[0].sp0));
            const p2 = addv(p0, subv(position.objects[0].sp2, position.objects[0].sp0));

            await this.evalObjects(
                parse, 
                {
                    transform:  transform,
                    sp0:        p0,
                    sp1:        p1,
                    sp2:        p2
                });
        }

        
        this.setUpdateValues(parse,
        [
            ['position',  position ],
            ['transform', transform]
        ]);


        this.validate();

        return this;
    }



    async evalObjects(parse, options)
    {
        if (   this.value
            && this.value.isValid())
        {
            this.value.objects = getValidObjects(this.input.value);


            const place = createTransform(
                options.sp0 ? options.sp0.x : 0,
                options.sp0 ? options.sp0.y : 0);


            for (const obj of this.value.objects)
            {
                obj.nodeId   = this.nodeId;
                obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;


                if (this.options.enabled)
                {
                    let xform = mulm3m3(
                        createTransform(
                            -obj.sp0.x, 
                            -obj.sp0.y),
                        place);


                    if (   options.transform.value > 0
                        && options.sp0
                        && options.sp1
                        && options.sp2)
                    {
                        const sp = getTransformFromPoints(
                            options.sp0, 
                            options.sp1, 
                            options.sp2);

                        xform = mulm3m3(xform, sp);

                        obj.sp1 = addv(obj.sp0, point(1, 0));
                        obj.sp2 = addv(obj.sp0, point(0, 1));
                    }


                    obj.applyTransform(xform, true);
                }
            }
        }
        
        
        await super.evalObjects(parse);
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }
    
    
    
    isValid()
    {
        return super.isValid()
            && this.position  && this.position .isValid()
            && this.transform && this.transform.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.position ) this.position .pushValueUpdates(parse);
        if (this.transform) this.transform.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.position ) this.position .invalidateInputs(parse, from, force);
        if (this.transform) this.transform.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.position ) this.position .iterateLoop(parse);
        if (this.transform) this.transform.iterateLoop(parse);
    }
}



function getTransformFromPoints(p0, p1, p2) 
{
    const dx   = p1.x - p0.x;
    const dy   = p1.y - p0.y;

    const a    = Math.atan2(dy, dx);
  
    const cosa = Math.cos(a);
    const sina = Math.sin(a);


    // const sx   = ((p1.y - p0.y) / nozero(p1.x - p0.x));
    // const sy   = ((p2.x - p0.x) / nozero(p2.y - p0.y));

    // TODO add skew 

    return [[ cosa,         -sina /** sy*/, 0 ], 
            [ sina /** sx*/, cosa,          0 ], 
            [ 0,             0,             1 ]];
}


class GGroupNode
extends GOperator
{
    paramIds = [];
    params   = [];



    constructor(nodeId, options)
    {
        super(GROUP_NODE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GGroupNode(this.nodeId, this.options);

        copy.copyBase(this);

        copy.params = this.params.map(p => p.copy());

        return copy;
    }



    paramFromId(paramId)
    {
        return this.params[this.paramIds.findIndex(id => id == paramId)];
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.updateValues = [];


        if (!isEmpty(this.params))
        {
            for (let i = 0; i < this.params.length; i++)
            {
                const param = await this.params[i].eval(parse);
                this.setUpdateValues(parse, [[this.paramIds[i], param.toValue()]], true);
            }
        }
        else
            this.setUpdateValues(parse, [['', new NullValue()]], true);
                
        
        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy() 
             : null;
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse));
        this.params.forEach(p => p.pushValueUpdates(parse));
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        this.inputs.forEach(i => i.invalidateInputs(parse, from, force));
        this.params.forEach(p => p.invalidateInputs(parse, from, force));
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        this.inputs.forEach(i => i.iterateLoop(parse));
        this.params.forEach(p => p.iterateLoop(parse));
    }
}



class GGroupParam
extends GOperator
{
    input    = null;
    
    dataType = NULL;



    constructor(nodeId, options)
    {
        super(GROUP_PARAM, nodeId, options);
    }



    reset()
    {
        super.reset();

        this.input    = null;
        this.dataType = null;
    }



    copy()
    {
        const copy = new GGroupParam(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) copy.input = this.input.copy();
        
        copy.dataType = this.dataType;
      
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        if (this.input)
        {
            if (!this.input.value)
                await this.input.eval(parse);

            this.value = this.input.toValue();
        }

        else if (this.dataType != NULL)
            this.value = nanFromType(this.dataType);
        
        else
            this.value = new NullValue();


        this.setUpdateValues(parse,
        [
            ['value', this.value]
        ]);


        this.validate();

        return this;
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input) this.input.pushValueUpdates(parse);
    }



    toValue()
    {
        return this.value.copy();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input) this.input.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from, force)
    {
        super.invalidateInputs(parse, from, force);

        if (this.input) this.input.invalidateInputs(parse, from, force);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input) this.input.iterateLoop(parse);
    }
}


class GComment
extends GOperator
{
    constructor(nodeId, options)
    {
        super(COMMENT, nodeId, options);
    }


    
    copy()
    {
        const copy = new GComment(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = new NullValue();


        this.setUpdateValues(parse, [['', new NullValue()]]);
        
        
        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy() 
             : null;
    }
}



class GCommentArrow
extends GOperator
{
    constructor(nodeId, options)
    {
        super(COMMENT_ARROW, nodeId, options);
    }


    
    copy()
    {
        const copy = new GCommentArrow(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = new NullValue();


        this.setUpdateValues(parse, [['', new NullValue()]]);
        
        
        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy() 
             : null;
    }
}



class GPanel
extends GOperator
{
    constructor(nodeId, options)
    {
        super(PANEL, nodeId, options);
    }


    
    copy()
    {
        const copy = new GPanel(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = new NullValue();


        this.setUpdateValues(parse, [['', new NullValue()]]);
        
        
        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy() 
             : null;
    }
}



var genFigMessagePosted = false;

var uiMessages          = [];


var figFonts            = [];
var figUniqueFontNames  = [];



// --> from UI
///////////////////////////////////////////////////////////////////////////////////////////////////

var lastMessage = null;


onmessage = function(e)
{
    const msg = JSON.parse(e.data);


    if (msg.cmd == 'returnUiGetValueForGenerator') // ignore this message in the queue
        return;
    

    if (msg.cmd == 'genRequest')
    {
        if (   lastMessage
            && lastMessage.cmd == 'genRequest')
            return;


        genRequest(msg.request, msg.save);         
    }
    else
    {
        switch (msg.cmd)
        {
            case 'initFonts':        initFonts(msg.fonts, msg.uniqueFontNames); break;
        
            case 'genEndUiMessage':  genEndUiMessage (msg.msgCmd);              break;
            case 'genEndFigMessage': genEndFigMessage();                        break;
        }

        lastMessage = null;
    }


    genPostMessageToUi(
    {
        cmd:   'uiEndGenMessage',
        msgCmd: msg.cmd
    });
};

///////////////////////////////////////////////////////////////////////////////////////////////////



// <-- to UI
///////////////////////////////////////////////////////////////////////////////////////////////////

function genPostMessageToUi(msg)
{
    if (msg == undefined)
    {
        consoleError('undefined message');
        console.trace();
    }

    postMessage(JSON.stringify(msg));
}



function genQueueMessageToUi(msg)
{
    uiMessages.push(msg);
    genPostNextMessageToUi();
}



function genPostNextMessageToUi(msg)
{
    if (!isEmpty(uiMessages))
    //    && !genFigMessagePosted)
    {
        //console.log('yes');
        let msg = uiMessages.shift();

        // while (   !isEmpty(uiMessages)
        //        &&  uiMessages[0].cmd     == 'uiUpdateValuesAndObjects'
        //        &&  uiMessages[0].chunkId == 0)
        // {
        //     const nextFirst = uiMessages.find(m => 
        //            m.cmd     == msg.cmd 
        //         && m.chunkId == 0);

        //     if (nextFirst)
        //     {
        //         while (!isEmpty(uiMessages)
        //             &&  uiMessages[0].cmd           == msg.cmd
        //             &&  uiMessages[0].updateNodeId  == msg.updateNodeId
        //             &&  uiMessages[0].updateParamId == msg.updateParamId
        //             &&  uiMessages[0].cmd.chunkId   >  0)
        //             msg = uiMessages.shift();

        //         msg = uiMessages.shift();
        //     }
        // }

        genPostMessageToUi(msg);
    }
}



function genEndUiMessage(msgCmd)
{
    //console.log('next UI message');
    genPostNextMessageToUi();
}



function genEndFigMessage()
{
    genFigMessagePosted = false;
    
    if (   !isEmpty(lastUpdateValues )
        || !isEmpty(lastUpdateObjects)
        || !isEmpty(lastUpdateStyles ))
    {
        genUpdateValuesAndObjects(
            lastRequestId,
            false,
            -1, 
            Number.MAX_SAFE_INTEGER, 
            lastUpdateNodeId, 
            lastUpdateParamId, 
            [], 
            [],
            [],
            false);
    }

    genPostNextMessageToUi();
}

///////////////////////////////////////////////////////////////////////////////////////////////////


var lastRequestId     = -1;
var lastUpdateNodeId  =  NULL;
var lastUpdateParamId =  NULL;
var lastUpdateValues  =  [];
var lastUpdateObjects =  [];
var lastUpdateStyles  =  [];



onerror = (event, source, line, pos, error) =>
{
    postMessage({
        type:    'error',
        message:  event.message,
        filename: event.filename,
        lineno:   event.lineno,
        colno:    event.colno
    });

    return true;
};


addEventListener('unhandledrejection', event => 
{
    postMessage(
    {
        type:  'unhandledrejection',
        reason: event.reason
    });
});



function initFonts(fonts, uniqueFontNames)
{
    figFonts           = fonts;
    figUniqueFontNames = uniqueFontNames;
}



function genRequest(request, save)
{
    const requestId       = parseInt(request[0]);
    const actionId        = parseInt(request[1]);
    const set             = parseInt(request[2]);
    const objectBatchSize = parseInt(request[3]);


    const settings =
    {
        showAllColorSpaces:  ((set >> 0) & 1) != 0,
        logRequests:         ((set >> 1) & 1) != 0,
        showTransformPoints: ((set >> 2) & 1) != 0,
        loadingNodes:        ((set >> 3) & 1) != 0,
        showTextTooltips:    ((set >> 4) & 1) != 0,
        showListTooltips:    ((set >> 5) & 1) != 0
    };


    const updateNodeId  = request[4];
    const updateParamId = request[5];

    const viewportZoom  = request[6];


    const parse = new Parse(
        request, 
        7,
        requestId,
        updateNodeId, 
        updateParamId, 
        viewportZoom,
        settings,
        save);


    const stackOverflowProtect = 100;

    while (   parse.pos < parse.request.length
           && parse.so  < stackOverflowProtect)
        genParse(parse);


    if (settings.logRequests)
        logRequest(parse);


    const paramNodes = parse.paramNodeIds
        .map(id => parse.parsedNodes.find(n => n.nodeId == id));
        //.filter(n => n !== undefined);


    const topLevelNodes = parse.parsedNodes
        .filter(n => 
                n.topLevel 
            && !paramNodes.find(_n => _n.nodeId == n.nodeId));

    const otherNodes = parse.parsedNodes.filter(n =>
               !paramNodes   .find(_n => _n.nodeId == n.nodeId)
            && !topLevelNodes.find(_n => _n.nodeId == n.nodeId));


    (async () =>
    {
        let stop = false;


        for (const nodes of [paramNodes, topLevelNodes])//, otherNodes])
        {
            for (const node of nodes)
            {
                if (await checkStop(parse.requestId)) { stop = true; break; }
                await node.eval(parse);
            }
        }


        if (    stop
            && !settings.loadingNodes)
            return;


        genQueueMessageToUi({cmd: 'uiEndGlobalProgress'});

       
        for (const nodes of [topLevelNodes, otherNodes])
            for (const node of nodes) 
                node.pushValueUpdates(parse);
        
        
        for (const node of parse.parsedNodes)
        {
            if (node.options.active === true)
            {
                if (   node.value
                    && node.value.objects)
                    node.value.objects.forEach(o => genPushUpdateObject(parse, o));

                if (node.colorStyle) 
                    genPushUpdateColorStyle(parse, node.colorStyle);
            }
        }


        for (const node of parse.parsedNodes)
        {
            if (   node.options.active === true
                && node.value
                && node.value.objects)
            {
                for (const obj of node.value.objects)
                {
                    if (obj.showCenter)
                    {
                        genPushUpdateObject(
                            parse, 
                            createObjectCenter(node, obj));
                    }


                    if (    parse.settings.showTransformPoints
                        && !obj.isDeco
                        &&  obj.xp0
                        &&  obj.xp1
                        &&  obj.xp2)
                    {
                        const xp0 = clone(obj.xp0);
                        const xp1 = clone(obj.xp1);
                        const xp2 = clone(obj.xp2);
                        const xp3 = addv(xp2, subv(xp1, xp0));

                        genPushUpdateObject(
                            parse, 
                            createDecoPoly(
                                node.nodeId,
                                obj.objectId,
                                obj.objectName,
                                obj.sp0,
                                [xp0, xp2, xp3, xp1],
                                true,
                                '1, 2',
                                [12, 140, 233],
                                XFORM_SUFFIX,
                                false));
                    }
                }
            }
        }

        //console.log('parse.parsedNodes =', parse.parsedNodes);

        await genUpdateValuesAndObjects(
            parse.requestId,
            settings.loadingNodes,
            actionId,
            objectBatchSize,
            parse.updateNodeId,
            parse.updateParamId,
            parse.updateValues,
            parse.updateObjects,
            parse.updateStyles,
            save);
    })();
}



async function checkStop(requestId)
{
    const uiCurRequestId = await genGetValueFromUi('curRequestId');

    if (uiCurRequestId.value > requestId) 
    { 
        genQueueMessageToUi({cmd: 'uiEndGlobalProgress'});
        return true; 
    }

    return false
}



function genPushUpdateValue(parse, nodeId, paramId, value)
{
    if (!value)
        return;
    

    removeFromArrayWhere(parse.updateValues, v =>
           v.nodeId     == nodeId
        && v.paramId    == paramId
        && v.value.type == value.type);

    
    parse.updateValues.push(
    {
        nodeId:  nodeId,
        paramId: paramId,
        type:    value.type, // needed to correctly parse NAN_DISPLAY
        value:   value.toJson()
    });
}



function genPushUpdateObject(parse, object)
{
    pushUniqueExcept(
        parse.updateObjects,
        object,
        o =>    o.nodeId   == object.nodeId
             && o.objectId == object.objectId);
}



function genPushUpdateColorStyle(parse, style)
{
    pushUniqueExcept(
        parse.updateStyles,
        style,
        o => o.nodeId == style.nodeId);
}



function clearLastUpdate()
{
    lastUpdateNodeId  =  NULL;
    lastUpdateParamId =  NULL;

    lastUpdateValues  =  [];
    lastUpdateObjects =  [];
    lastUpdateStyles  =  [];
}



async function genUpdateValuesAndObjects(requestId, loadingNodes, actionId, objectBatchSize, updateNodeId, updateParamId, updateValues, updateObjects, updateStyles, save)
{
    if (   isEmpty(updateValues )
        && isEmpty(updateObjects)
        && isEmpty(updateStyles ))
    {
        updateNodeId  = lastUpdateNodeId;
        updateParamId = lastUpdateParamId;
        
        updateValues  = lastUpdateValues;
        updateObjects = lastUpdateObjects;
        updateStyles  = lastUpdateStyles;

        clearLastUpdate();
    }
    else if (genFigMessagePosted)
    {
        lastRequestId     = requestId;
        lastUpdateNodeId  = updateNodeId;
        lastUpdateParamId = updateParamId;

        lastUpdateValues  = updateValues;
        lastUpdateObjects = updateObjects;
        lastUpdateStyles  = updateStyles;

        return;
    }


    const nodeIds = filterUnique(updateValues.map(v => v.nodeId));
    const counts  = nodeIds.map(id => updateValues.filter(v => v.nodeId == id).length);


    // send updates in chunks

    const approxNodeChunkSize = 1000000;
    const objChunkSize        = 1000000;
    const styleChunkSize      = 1000000;

    
    let n  = 0; // node
    let o  = 0; // object
    let s  = 0; // style

    let nc = 0; // node chunk count
    let oc = 0; // object chunk count
    let sc = 0; // style chunk count


    let nodeValChunk   = [],
        objChunk       = [],
        styleChunk     = [];

    let nodeValChunkId = 0;

    let isFirstChunk   = true;
        

    genQueueMessageToUi(
    {
        cmd:      'uiInitGlobalProgress',
        requestId: requestId
    });


    let totalObjects = 0;
    updateObjects.forEach(o => totalObjects += o.getCount());

    
    while (   n < nodeIds      .length
           || o < updateObjects.length
           || s < updateStyles .length)
    {
        if (n < nodeIds.length)
        {
            nodeValChunk.push(nodeIds[n], counts[n]);

            const values = updateValues.filter(v => v.nodeId == nodeIds[n]);
            //values.sort((a, b) => a.paramId - b.paramId);

            for (const v of values)
                nodeValChunk.push(v.paramId, v.type, v.value);

            n++, nc++;
        }


        if (o < updateObjects.length)
        {
            objChunk.push(updateObjects[o].toData());
            o++, oc++;
        }


        if (s < updateStyles.length)
        {
            styleChunk.push(updateStyles[s].toData());
            s++, sc++;
        }


        const chunkNotEmpty =
               nc >= approxNodeChunkSize
            || oc == objChunkSize
            || sc == styleChunkSize;


        if (chunkNotEmpty)
        {
            const isLastChunk =    
                   n >= nodeIds      .length
                && o >= updateObjects.length
                && s >= updateStyles .length
                && (   !isEmpty(nodeValChunk)
                    || !isEmpty(objChunk    )
                    || !isEmpty(styleChunk  ));

            genQueueChunk(
                requestId,
                actionId,
                updateNodeId,
                updateParamId,
                objectBatchSize,
                totalObjects,
                nodeValChunkId++,
                nodeValChunk,
                objChunk,
                styleChunk,
                n,
                nodeIds.length,
                isFirstChunk,
                isLastChunk,
                save);

            nodeValChunk = [];  nc = 0;
            objChunk     = [];  oc = 0;
            styleChunk   = [];  sc = 0;

            isFirstChunk = false;
        }


        if (await checkStop(requestId)) 
            break;
    }


    const lastChunkNotEmpty =
           !isEmpty(nodeValChunk)
        || !isEmpty(objChunk    )
        || !isEmpty(styleChunk  );


    if (   lastChunkNotEmpty
        || loadingNodes
        ||    isEmpty(updateValues) 
           && isEmpty(updateObjects)
           && isEmpty(updateStyles))
    {
        genQueueChunk(
            requestId,
            actionId,
            updateNodeId,
            updateParamId,
            objectBatchSize,
            totalObjects,
            nodeValChunkId++,
            nodeValChunk,
            objChunk,
            styleChunk,
            nodeIds.length,
            nodeIds.length,
            false,
            true,
            save);
    }


    genQueueMessageToUi({
        cmd: 'uiForwardToFigma',
        msg: {cmd: 'figCommitUndo'}
    })
}



function genQueueChunk(requestId, actionId, updateNodeId, updateParamId, objectBatchSize, totalObjects, nodeValChunkId, nodeValChunk, objChunk, styleChunk, updatedNodes, totalNodes, isFirstChunk, isLastChunk, save)
{
    genQueueMessageToUi({
        cmd:            'uiUpdateValuesAndObjects',
        requestId:       requestId,
        actionId:        actionId,
        updateNodeId:    updateNodeId,
        updateParamId:   updateParamId,
        objectBatchSize: objectBatchSize,
        totalObjects:    totalObjects,
        chunkId:         nodeValChunkId,
        values:          [...nodeValChunk].map(v => v.toString()),
        objects:         [...objChunk    ],
        styles:          [...styleChunk  ],
        updatedNodes:    updatedNodes,
        totalNodes:      totalNodes,
        isFirstChunk:    isFirstChunk,
        isLastChunk:     isLastChunk,
        save:            save
    });


    if (   !isEmpty(objChunk  )
        || !isEmpty(styleChunk))
        genFigMessagePosted = true;
}



function genInitNodeProgress(nodeId)
{
    genQueueMessageToUi(
    {
        cmd:   'uiInitNodeProgress',
        nodeId: nodeId
    });
}



function genUpdateNodeProgress(parse, nodeId, progress, updateGlobal = true)
{
    genQueueMessageToUi(
    {
        cmd:           'uiUpdateNodeProgress',
        nodeId:         nodeId,
        progress:       progress,
        globalProgress: parse.currentProgress / parse.totalProgress,
        updateGlobal:   updateGlobal
    });
}



function genEndNodeProgress(nodeId, endGlobal)
{
    genQueueMessageToUi(
    {
        cmd:      'uiEndNodeProgress',
        nodeId:    nodeId,
        endGlobal: endGlobal
    });
}



async function genGetObjectSizeFromFigma(obj) 
{
    return new Promise((resolve, reject) => 
    {
        const timeout = 1000;

        genPostMessageToUi(
        {
            cmd: 'uiForwardToFigma',
            msg:  
            {
                cmd:   'figGetObjectSize',
                object: obj
            }
        });

        const timeoutId = setTimeout(() => 
            reject(new Error('Timeout: Result not received within the specified time')),
            timeout);

        function handleMessage(event) 
        {
            const msg = JSON.parse(event.data);

            if (msg.cmd === 'returnFigGetObjectSize') 
            {
                clearTimeout(timeoutId);
                
                const { objectId, width, height } = msg;
                resolve({ objectId, width, height });

                self.removeEventListener('message', handleMessage);
            }
        }

        self.addEventListener('message', handleMessage);
    });
}



async function genGetValueFromUi(key) 
{
    return new Promise((resolve, reject) => 
    {
        const timeout = 60000;

        genPostMessageToUi(
        {
            cmd: 'uiGetValueForGenerator',
            key:  key 
        });

        const timeoutId = setTimeout(() => 
            reject(new Error('Timeout: Result not received by Generator within the specified time')),
            timeout);

        function handleMessage(event) 
        {
            const msg = JSON.parse(event.data);

            if (msg.cmd === 'returnUiGetValueForGenerator') 
            {
                clearTimeout(timeoutId);

                resolve(
                { 
                    key:   msg.key, 
                    value: msg.value 
                });

                self.removeEventListener('message', handleMessage);
            }
        }

        self.addEventListener('message', handleMessage);
    });
}


function genParseColorValue(parse)
{
    parse.pos++; // COLOR_VALUE

    const col = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(COLOR_VALUE, col, parse);

    return parseColorValue(col)[0];
}



function genParseColor(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const col = new GColor(nodeId, options);

    col.hasInputs = options.hasInputs;
    
  
    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(col, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, col);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    
    let paramIds;

    if (nInputs == 1)
    {
        col.input = genParse(parse);
        paramIds = parse.move().split(',');
    }
    else
        paramIds = ['space', 'convert', 'c1', 'c2', 'c3'];


    parse.inParam = false;
    
    for (const id of paramIds)
    {
        switch (id)
        {
        case 'space':   col.space        = genParse(parse);  break;
        case 'convert': col.convert      = genParse(parse);  break;
        case 'c1':      col._c1 = col.c1 = genParse(parse);  break;
        case 'c2':      col._c2 = col.c2 = genParse(parse);  break;
        case 'c3':      col._c3 = col.c3 = genParse(parse);  break;
        }
    }
    

    parse.nTab--;


    genParseNodeEnd(parse, col);
    return col;
}



function genParseValidColor(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const valid = new GValidColor(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(valid, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, valid);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        valid.input = genParse(parse);


    valid.quality = genParse(parse);
    valid.value   = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, valid);
    return valid;
}



function genParseCorrectColor(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const corr = new GCorrectColor(nodeId, options);

    corr.hasInputs = options.hasInputs;


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(corr, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, corr);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    let paramIds;

    if (nInputs == 1)
        corr.input = genParse(parse);


    paramIds = parse.move().split(',');

    parse.inParam = false;
    
    for (const id of paramIds)
    {
        switch (id)
        {
        case 'order':  corr._order = corr.order = genParse(parse);  break;
        case 'c1':     corr._c1    = corr.c1    = genParse(parse);  break;
        case 'c2':     corr._c2    = corr.c2    = genParse(parse);  break;
        case 'c3':     corr._c3    = corr.c3    = genParse(parse);  break;
        case 'value':  corr.value               = genParse(parse);  break;
        }
    }
                

    parse.nTab--;


    genParseNodeEnd(parse, corr);
    return corr;
}



function genParseColorContrast(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const cnt = new GColorContrast(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }


    const valueIndex = 
        nInputs == 1
        ? parseInt(parse.move())
        : -1;

    
    if (parse.settings.logRequests) 
        logReqColorContrast(cnt, nInputs, valueIndex, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, cnt);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 2)
    {
        cnt.input0   = genParse(parse);
        cnt.input1   = genParse(parse);
    }
    else if (nInputs == 1)
    {
             if (valueIndex == 0) cnt.input0 = genParse(parse); 
        else if (valueIndex == 1) cnt.input1 = genParse(parse); 
    }
  

    cnt.standard = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, cnt);
    return cnt;
}



function genParseColorConvertP3(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const convert = new GConvertP3(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(convert, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, convert);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        convert.input = genParse(parse);


    convert.from = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, convert);
    return convert;
}



function genParseColorBlind(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const cb = new GColorBlind(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(cb, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, cb);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        cb.input = genParse(parse);

    cb.l = genParse(parse);
    cb.m = genParse(parse);
    cb.s = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, cb);
    return cb;
}



function genParseColorScheme(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const scheme = new GColorScheme(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(scheme, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, scheme);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        scheme.input = genParse(parse);


    scheme.schemeType = genParse(parse);
    scheme.space      = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, scheme);
    return scheme;
}



function genParseColorInterpolate(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const lerp = new GColorInterpolate(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }

    
    if (parse.settings.logRequests) 
        logReq(lerp, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, lerp);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 2)
    {
        lerp.input0 = genParse(parse);
        lerp.input1 = genParse(parse);
    }

    else if (nInputs == 1)
        lerp.input0 = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same

    else if (nInputs != 0)
        consoleError('nInputs must be [0, 2]');


    lerp.space  = genParse(parse);
    lerp.amount = genParse(parse);
    lerp.gamma  = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, lerp);
    return lerp;
}



function genParseColorBlend(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const blend = new GColorBlend(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }

    
    if (parse.settings.logRequests) 
        logReq(blend, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, blend);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 2)
    {
        blend.input0 = genParse(parse);
        blend.input1 = genParse(parse);
    }

    else if (nInputs == 1)
        blend.input0 = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same

    else if (nInputs != 0)
        consoleError('nInputs must be [0, 2]');


    blend.mode   = genParse(parse);
    blend.amount = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, blend);
    return blend;
}



function genParseGradientValue(parse)
{
    parse.pos++; // GRADIENT_VALUE

    const grad = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(GRADIENT_VALUE, grad, parse);

    return parseGradientValue(grad)[0];
}



function genParseGradient(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const grad = new GGradient(nodeId, options);

    grad.hasInputs = options.hasInputs;


    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(grad, parse, ignore, nInputs);


    if (ignore)
    {
        genParseNodeEnd(parse, grad);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    for (let i = 0; i < nInputs; i++)
        grad.inputs.push(genParse(parse));


    const nParamIds = genParseParamCount(parse);


    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {
        case 'gradType': grad.gradType = genParse(parse); break;
        case 'position': grad.position = genParse(parse); break;
        case 'x':        grad.x        = genParse(parse); break;
        case 'y':        grad.y        = genParse(parse); break;
        case 'size':     grad.size     = genParse(parse); break;
        case 'angle':    grad.angle    = genParse(parse); break;
        case 'aspect':   grad.aspect   = genParse(parse); break;
        case 'skew':     grad.skew     = genParse(parse); break;
        case 'blend':    grad.blend    = genParse(parse); break;
        }
    }

    // grad.gradType   = genParse(parse); 
    // grad.position   = genParse(parse); 
    // grad.x          = genParse(parse); 
    // grad.y          = genParse(parse); 
    // grad.size       = genParse(parse); 
    // grad.angle      = genParse(parse); 
    // grad.aspect     = genParse(parse); 
    // grad.skew       = genParse(parse); 
    // grad.blend      = genParse(parse);

    
    grad.diagAspect = parseInt(parse.move()) > 0;


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, grad);
    return grad;
}



// function genParseGradientParam(parse)
// {
//     const grd = genParse(parse); 

//     if (COLOR_TYPES.includes(grd.type))
//         grd.options.opacity = genParse(parse);

//     return grd;
// }



function genParseColorStopValue(parse)
{
    parse.pos++; // COLOR_STOP_VALUE

    const stop = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(COLOR_STOP_VALUE, stop, parse);

    return parseColorStopValue(stop)[0];
}



function genParseColorStop(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const stop = new GColorStop(nodeId, options);

    stop.hasInputs = options.hasInputs;


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(stop, parse, ignore, nInputs);


    if (ignore)
    {
        genParseNodeEnd(parse, stop);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    let paramIds;

    if (nInputs == 1)
    {
        stop.input = genParse(parse);
        paramIds = parse.move().split(',');
    }
    else
        paramIds = ['fill', 'position'];


    parse.inParam = false;

    for (const id of paramIds)
    {
        switch (id)
        {
        case 'fill':     stop.fill     = genParse(parse); break;
        case 'position': stop.position = genParse(parse); break;
        }
    }
    
    
    parse.nTab--;


    genParseNodeEnd(parse, stop);
    return stop;
}


function genParseNull(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const _null = new GNull(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(_null, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, _null);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        _null.input = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, _null);
    return _null;
}



function genParseVariable(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const variable = new GVariable(nodeId, options);


    //variable.existing = options.existing;


    let nInputs = -1;
    

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(variable, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, variable);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;
    parse.inParam = false;


    if (nInputs == 1)
        variable.input = genParse(parse);

    
    variable.variableId   = parse.move();
    variable.variableName = parse.move();
    variable.variableType = parse.move();
    //variable.linkedVariableTemp = parseInt(parse.move()) == 1;

    if (parse.settings.logRequests) 
    {
        logReqString(variable.variableId   != NULL ? variable.variableId   : 'NULL', parse);
        logReqString(variable.variableName != ''   ? variable.variableName : '\'\'', parse);
        logReqString(variable.variableType != NULL ? variable.variableType : 'NULL', parse);
    }


    const nParams = parseInt(parse.move());

    if (nParams == 1)
        variable.variableValue = genParse(parse);

    
    parse.nTab--;

    
    //variable.linked = variable.id != NULL;


    genParseNodeEnd(parse, variable);
    return variable;
}



function genParseVariableGroup(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const group = new GVariableGroup(nodeId, options);

    
    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(group, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, group);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        group.input = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, group);
    return group;
}



function genParseListValue(parse)
{
    parse.pos++; // LIST_VALUE

    const list = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(LIST_VALUE, list, parse);

    return parseListValue(list)[0];
}



function genParseCombine(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const cmb = new GCombine(nodeId, options);

    
    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(cmb, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, cmb);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    
    for (let i = 0; i < nInputs; i++)
        cmb.inputs.push(genParse(parse));


    parse.nTab--;

        
    genParseNodeEnd(parse, cmb);
    return cmb;
}



function genParseListAsItem(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const listAsItem = new GListAsItem(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(listAsItem, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, listAsItem);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        listAsItem.input = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, listAsItem);
    return listAsItem;
}



function genParseExtract(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const extr = new GExtract(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(extr, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, extr);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        extr.input = genParse(parse);

    extr.indices = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, extr);
    return extr;
}



function genParseSetParam(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const set = new GSetParam(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(set, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, set);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 2)
    {
        set.input0 = genParse(parse);
        set.input1 = genParse(parse);
        set.name   = genParse(parse);
    }
    else if (nInputs == 1)
    {
        set.input0 = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same
        set.name   = genParse(parse);
    }
    else if (nInputs == 0)
    {
        set.name   = genParse(parse);
    }

    
    parse.nTab--;


    genParseNodeEnd(parse, set);
    return set;
}



function genParseGetParam(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const extr = new GGetParam(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(extr, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, extr);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        extr.input = genParse(parse);

    extr.name = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, extr);
    return extr;
}



function genParseSublist(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const sub = new GSublist(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(sub, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, sub);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        sub.input = genParse(parse);

    sub.start = genParse(parse);
    sub.end   = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, sub);
    return sub;
}



function genParseUnique(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const unique = new GUnique(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(unique, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, unique);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        unique.input = genParse(parse);
  
    
    parse.nTab--;


    genParseNodeEnd(parse, unique);
    return unique;
}



function genParseShiftList(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const shift = new GShiftList(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(shift, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, shift);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        shift.input = genParse(parse);

    shift.offset = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, shift);
    return shift;
}



function genParseReverseList(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const reverse = new GReverseList(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(reverse, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, reverse);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        reverse.input = genParse(parse);
  
    
    parse.nTab--;


    genParseNodeEnd(parse, reverse);
    return reverse;
}



function genParseBuckleList(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const buckle = new GBuckleList(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(buckle, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, buckle);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        buckle.input = genParse(parse);
  

    buckle.amount = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, buckle);
    return buckle;
}



function genParseReorderList(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const reorder = new GReorderList(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(reorder, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, reorder);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        reorder.input = genParse(parse);


    reorder.indices = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, reorder);
    return reorder;
}



function genParseSort(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const sort = new GSort(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(sort, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, sort);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        sort.input = genParse(parse);


    const nConditions = parseInt(parse.move());

    if (nConditions == 1)
        sort.condition = genParse(parse);

        
    sort.reverse   = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, sort);
    return sort;
}



function genParseFilter(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const filter = new GFilter(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(filter, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, filter);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        filter.input = genParse(parse);

    filter.condition = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, filter);
    return filter;
}



function genParseColumn(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const column = new GColumn(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(column, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, column);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        column.input = genParse(parse);

    column.index = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, column);
    return column;
}



function genParseCell(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const cell = new GCell(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(cell, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, cell);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        cell.input = genParse(parse);

    cell.column = genParse(parse);
    cell.row    = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, cell);
    return cell;
}



function genParseList(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const list = new GList(nodeId, options);

    
    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(list, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, list);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        list.input = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, list);
    return list;
}



function genParseSelect(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const sel = new GSelect(nodeId, options);

    
    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(sel, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, sel);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    
    for (let i = 0; i < nInputs; i++)
        sel.inputs.push(genParse(parse));

    sel.index = genParse(parse);


    parse.nTab--;

        
    genParseNodeEnd(parse, sel);
    return sel;
}



function genParseSelectFromList(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const sel = new GSelectFromList(nodeId, options);
    

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(sel, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, sel);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        sel.input = genParse(parse);

    sel.index = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, sel);
    return sel;
}



function genParseListCount(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const count = new GListCount(nodeId, options);

    
    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(count, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, count);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        count.input = genParse(parse);

    count.start = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, count);
    return count;
}



function genParseObjectCount(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const count = new GObjectCount(nodeId, options);

    
    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(count, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, count);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        count.input = genParse(parse);

    count.start = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, count);
    return count;
}



function genParseListContains(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const cont = new GListContains(nodeId, options);
   

    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }

    
    if (parse.settings.logRequests) 
        logReq(cont, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, cont);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 2)
    {
        cont.input0 = genParse(parse);
        cont.input1 = genParse(parse);
    }
    else if (nInputs == 1)
    {
        cont.input0 = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same
    }
  
    
    parse.nTab--;


    genParseNodeEnd(parse, cont);
    return cont;
}



function genParseListFind(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const find = new GListFind(nodeId, options);
   

    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }

    
    if (parse.settings.logRequests) 
        logReq(find, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, find);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 2)
    {
        find.input0 = genParse(parse);
        find.input1 = genParse(parse);
    }
    else if (nInputs == 1)
    {
        find.input0 = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same
    }
  
    
    parse.nTab--;


    genParseNodeEnd(parse, find);
    return find;
}



function genParseIfElse(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const ifElse = new GIfElse(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }


    const valueIndex = 
        nInputs == 1
        ? parseInt(parse.move())
        : -1;


    if (parse.settings.logRequests) 
        logReq(ifElse, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, ifElse);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    if (nInputs == 2)
    {
        ifElse.input0    = genParse(parse);
        ifElse.input1    = genParse(parse);
        ifElse.condition = genParse(parse);
    }
    else if (nInputs == 1)
    {
             if (valueIndex == 0) ifElse.input0 = genParse(parse); 
        else if (valueIndex == 1) ifElse.input1 = genParse(parse); 

        ifElse.condition = genParse(parse);
    }
    else if (nInputs == 0)
    {
        ifElse.condition = genParse(parse);
    }

    parse.nTab--;


    genParseNodeEnd(parse, ifElse);
    return ifElse;
}



function genParseFeedback(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const feedback = new GFeedback(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(feedback, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, feedback);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        feedback.input = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, feedback);
    return feedback;
}



function genParseRepeat(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const repeat = new GRepeat(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(repeat, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, repeat);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    repeat.isTerminal  = parseInt(parse.move()) > 0;
    repeat.activeAfter = parseInt(parse.move()) > 0;
    repeat.listAfter   = parseInt(parse.move()) > 0;


    parse.nTab++;


    if (nInputs == 1)
        repeat.input = genParse(parse);

    repeat. count     = genParse(parse);
    repeat .iteration = genParse(parse);
    repeat._while     = genParse(parse);
  //repeat. iterate   = genParse(parse);  // don't set target here
    repeat. loop      = genParse(parse);  // don't set target here


    parse.nTab--;


    genParseNodeEnd(parse, repeat);
    return repeat;
}



function genParseCache(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const cache = new GCache(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(cache, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, cache);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        cache.input = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, cache);
    return cache;
}



function genParseFreeze(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const freeze = new GFreeze(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(freeze, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, freeze);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        freeze.input = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, freeze);
    return freeze;
}



function genParseTimer(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const timer = new GTimer(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(timer, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, timer);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        timer.input = genParse(parse);


    timer.interval = genParse(parse);
    timer._while   = genParse(parse);
    timer. loop    = genParse(parse);  // don't set target here


    parse.nTab--;


    genParseNodeEnd(parse, timer);
    return timer;
}



function genParseGetValueName(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const name = new GGetValueName(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(name, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, name);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        name.input = genParse(parse);

    name.name = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, name);
    return name;
}



function genParseSetValueName(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const name = new GSetValueName(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(name, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, name);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        name.input = genParse(parse);

    name.name = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, name);
    return name;
}



function genParseGetListValueNames(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const names = new GGetListValueNames(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(names, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, names);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        names.input = genParse(parse);
  
    
    parse.nTab--;


    genParseNodeEnd(parse, names);
    return names;
}



function genParseSetListValueNames(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const names = new GSetListValueNames(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }


    const valueIndex = 
        nInputs == 1
        ? parseInt(parse.move())
        : -1;


    if (parse.settings.logRequests) 
        logReq(names, parse, ignore, nInputs);


    if (ignore)
    {
        genParseNodeEnd(parse, names);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    if (nInputs == 2)
    {
        names.input0 = genParse(parse);
        names.input1 = genParse(parse);
    }
    else if (nInputs == 1)
    {
             if (valueIndex == 0) names.input0 = genParse(parse); 
        else if (valueIndex == 1) names.input1 = genParse(parse); 
    }

    parse.nTab--;


    genParseNodeEnd(parse, names);
    return names;
}



function genParseSetObjectName(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const name = new GSetObjectName(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(name, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, name);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        name.input = genParse(parse);

    name.name    = genParse(parse);
 // name.addLogo = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, name);
    return name;
}



function genParseComment(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const cmnt = new GComment(nodeId, options);

    
    if (parse.settings.logRequests) 
        logReq(cmnt, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, cmnt);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    genParseNodeEnd(parse, cmnt);
    return cmnt;
}



function genParseCommentArrow(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const cmnt = new GCommentArrow(nodeId, options);

    
    if (parse.settings.logRequests) 
        logReq(cmnt, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, cmnt);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    genParseNodeEnd(parse, cmnt);
    return cmnt;
}



function genParsePanel(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const panel = new GPanel(nodeId, options);

    
    if (parse.settings.logRequests) 
        logReq(panel, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, panel);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    genParseNodeEnd(parse, panel);
    return panel;
}


function genParseGroupNode(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const group = new GGroupNode(nodeId, options);


    let nParams = -1;
    
    if (!ignore)
    {
        nParams = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(group, parse, ignore);//, nParams);


    if (ignore)
    {
        genParseNodeEnd(parse, group);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    //const nParams = parseInt(parse.move());

    for (let i = 0; i < nParams; i++)
    {
        group.paramIds.push(parse.move());
        group.params  .push(genParse(parse));
    }


    parse.nTab--;


    genParseNodeEnd(parse, group);
    return group;
}



function genParseGroupParam(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const param = new GGroupParam(nodeId, options);


    let nInputs  = -1;
    let nOutputs = -1;
    
    if (!ignore)
    {
        nInputs  = parseInt(parse.move());
        nOutputs = parseInt(parse.move());

        consoleAssert(nInputs  == 0 || nInputs  == 1,  'nInputs must be [0, 1]');
        consoleAssert(nOutputs == 0 || nOutputs == 1, 'nOutputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(param, parse, ignore);//, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, param);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
    {
        param.input    = genParse(parse);
        param.dataType = parse.move();
    }
    else if (nOutputs == 1)
        param.dataType = parse.move();


    parse.nTab--;


    genParseNodeEnd(parse, param);
    return param;
}



function genParseFillValue(parse)
{
    parse.pos++; // FILL_VALUE

    const fill = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(FILL_VALUE, fill, parse);

    return parseFillValue(fill)[0];
}



function genParseFill(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const fill = new GFill(nodeId, options);

    fill.hasInputs = options.hasInputs;


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(fill, parse, ignore, nInputs);


    if (ignore)
    {
        genParseNodeEnd(parse, fill);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    let paramIds;

    if (nInputs == 1)
    {
        fill.input = genParse(parse);
        paramIds = parse.move().split(',');
    }
    else
        paramIds = ['color', 'opacity', 'blend'];


    parse.inParam = false;

    for (const id of paramIds)
    {
        switch (id)
        {
        case 'color':   fill.color   = genParse(parse); break;
        case 'opacity': fill.opacity = genParse(parse); break;
        case 'blend':   fill.blend   = genParse(parse); break;
        }
    }

    
    parse.nTab--;


    genParseNodeEnd(parse, fill);
    return fill;
}



function genParseFillParam(parse)
{
    const fill = genParse(parse); 

    if (COLOR_TYPES.includes(fill.type))
        fill.options.opacity = genParse(parse);

    return fill;
}



function genParseStrokeValue(parse)
{
    parse.pos++; // STROKE_VALUE

    const stroke = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(STROKE_VALUE, stroke, parse);

    return parseStrokeValue(stroke)[0];
}



function genParseStroke(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const stroke = new GStroke(nodeId, options);

    stroke.hasInputs = options.hasInputs;


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(stroke, parse, ignore, nInputs);


    if (ignore)
    {
        genParseNodeEnd(parse, stroke);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    let paramIds;

    if (nInputs == 1)
    {
        stroke.input = genParse(parse);
        paramIds = parse.move().split(',');
    }
    else
        paramIds = ['fill', 'weight', 'fit', 'join', 'miter', 'cap', 'dashes'];


    parse.inParam = false;

    for (const id of paramIds)
    {
        switch (id)
        {
        case 'fill':   stroke._fills = genParse(parse); stroke.fills = stroke._fills; break;
        case 'weight': stroke.weight = genParse(parse); break;
        case 'fit':    stroke.fit    = genParse(parse); break;
        case 'join':   stroke.join   = genParse(parse); break;
        case 'miter':  stroke.miter  = genParse(parse); break;
        case 'cap':    stroke.cap    = genParse(parse); break;
        case 'dashes': stroke.dashes = genParse(parse); break;
        }
    }
    
    
    parse.nTab--;


    genParseNodeEnd(parse, stroke);
    return stroke;
}



function genParseStrokeParam(parse)
{
    const stroke = genParse(parse); 

    if (    FILL_TYPES.includes(stroke.type)
        || COLOR_TYPES.includes(stroke.type))
        stroke.data.weight = genParse(parse);

    return stroke;
}



function genParseStrokeSidesValue(parse)
{
    parse.pos++; // STROKE_SIDES_VALUE

    const sides = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(STROKE_SIDES_VALUE, sides, parse);

    return parseStrokeSidesValue(sides)[0];
}



function genParseStrokeSides(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const sides = new GStrokeSides(nodeId, options);

    sides.hasInputs = options.hasInputs;


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(sides, parse, ignore, nInputs);


    if (ignore)
    {
        genParseNodeEnd(parse, sides);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    let paramIds;

    if (nInputs == 1)
    {
        sides.input = genParse(parse);
        paramIds = parse.move().split(',');
    }
    else
        paramIds = ['top', 'left', 'right', 'bottom'];


    parse.inParam = false;

    for (const id of paramIds)
    {
        switch (id)
        {
        case 'top':    sides.top    = genParse(parse); break;
        case 'left':   sides.left   = genParse(parse); break;
        case 'right':  sides.right  = genParse(parse); break;
        case 'bottom': sides.bottom = genParse(parse); break;
        }
    }
    
    
    parse.nTab--;


    genParseNodeEnd(parse, sides);
    return sides;
}



function genParseRoundCornersValue(parse)
{
    parse.pos++; // ROUND_CORNERS_VALUE

    const corners = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(ROUND_CORNERS_VALUE, corners, parse);

    return parseRoundCornersValue(corners)[0];
}



function genParseRoundCorners(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const corners = new GRoundCorners(nodeId, options);

    corners.hasInputs = options.hasInputs;


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(corners, parse, ignore, nInputs);


    if (ignore)
    {
        genParseNodeEnd(parse, corners);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    let paramIds;

    if (nInputs == 1)
    {
        corners.input = genParse(parse);
        paramIds = parse.move().split(',');
    }
    else
        paramIds = ['tl', 'tr', 'bl', 'br'];


    parse.inParam = false;

    for (const id of paramIds)
    {
        switch (id)
        {
        case 'tl': corners.tl = genParse(parse); break;
        case 'tr': corners.tr = genParse(parse); break;
        case 'bl': corners.bl = genParse(parse); break;
        case 'br': corners.br = genParse(parse); break;
        }
    }
    
    
    parse.nTab--;


    genParseNodeEnd(parse, corners);
    return corners;
}



function genParseDropShadowValue(parse)
{
    parse.pos++; // DROP_SHADOW_VALUE

    const shadow = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(DROP_SHADOW_VALUE, shadow, parse);

    return parseDropShadowValue(shadow)[0];
}



function genParseDropShadow(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const shadow = new GDropShadow(nodeId, options);

    shadow.hasInputs = options.hasInputs;


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(shadow, parse, ignore, nInputs);


    if (ignore)
    {
        genParseNodeEnd(parse, shadow);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    let paramIds;

    if (nInputs == 1)
    {
        shadow.input = genParse(parse);
        paramIds = parse.move().split(',');
    }
    else
        paramIds = ['x', 'y', 'blur', 'spread', 'fill', 'blend', 'behind'];


    parse.inParam = false;

    for (const id of paramIds)
    {
        switch (id)
        {
        case 'x':      shadow.x      = genParse(parse); break;
        case 'y':      shadow.y      = genParse(parse); break;
        case 'blur':   shadow.blur   = genParse(parse); break;
        case 'spread': shadow.spread = genParse(parse); break;
        case 'fill':   shadow.fill   = genParse(parse); break;
        case 'blend':  shadow.blend  = genParse(parse); break;
        case 'behind': shadow.behind = genParse(parse); break;
        }
    }
    
    
    parse.nTab--;


    genParseNodeEnd(parse, shadow);
    return shadow;
}



function genParseInnerShadowValue(parse)
{
    parse.pos++; // INNER_SHADOW_VALUE

    const shadow = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(INNER_SHADOW_VALUE, shadow, parse);

    return parseInnerShadowValue(shadow)[0];
}



function genParseInnerShadow(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const shadow = new GInnerShadow(nodeId, options);

    shadow.hasInputs = options.hasInputs;


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(shadow, parse, ignore, nInputs);


    if (ignore)
    {
        genParseNodeEnd(parse, shadow);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    let paramIds;

    if (nInputs == 1)
    {
        shadow.input = genParse(parse);
        paramIds = parse.move().split(',');
    }
    else
        paramIds = ['x', 'y', 'blur', 'spread', 'fill', 'blend'];


    parse.inParam = false;

    for (const id of paramIds)
    {
        switch (id)
        {
        case 'x':      shadow.x      = genParse(parse); break;
        case 'y':      shadow.y      = genParse(parse); break;
        case 'blur':   shadow.blur   = genParse(parse); break;
        case 'spread': shadow.spread = genParse(parse); break;
        case 'fill':   shadow.fill   = genParse(parse); break;
        case 'blend':  shadow.blend  = genParse(parse); break;
        }
    }
    
    
    parse.nTab--;


    genParseNodeEnd(parse, shadow);
    return shadow;
}



function genParseLayerBlurValue(parse)
{
    parse.pos++; // LAYER_BLUR_VALUE

    const blur = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(LAYER_BLUR_VALUE, blur, parse);

    return parseLayerBlurValue(blur)[0];
}



function genParseLayerBlur(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const blur = new GLayerBlur(nodeId, options);

    blur.hasInputs = options.hasInputs;


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(blur, parse, ignore, nInputs);


    if (ignore)
    {
        genParseNodeEnd(parse, blur);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    let paramIds;

    if (nInputs == 1)
    {
        blur.input = genParse(parse);
        paramIds = parse.move().split(',');
    }
    else
        paramIds = ['radius'];


    parse.inParam = false;

    for (const id of paramIds)
    {
        switch (id)
        {
        case 'radius': blur.radius = genParse(parse); break;
        }
    }
    
    
    parse.nTab--;


    genParseNodeEnd(parse, blur);
    return blur;
}



function genParseBackBlurValue(parse)
{
    parse.pos++; // BACK_BLUR_VALUE

    const blur = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(BACK_BLUR_VALUE, blur, parse);

    return parseBackBlurValue(blur)[0];
}



function genParseBackBlur(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const blur = new GBackBlur(nodeId, options);

    blur.hasInputs = options.hasInputs;


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(blur, parse, ignore, nInputs);


    if (ignore)
    {
        genParseNodeEnd(parse, blur);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    let paramIds;

    if (nInputs == 1)
    {
        blur.input = genParse(parse);
        paramIds = parse.move().split(',');
    }
    else
        paramIds = ['radius'];


    parse.inParam = false;

    for (const id of paramIds)
    {
        switch (id)
        {
        case 'radius': blur.radius = genParse(parse); break;
        }
    }
    
    
    parse.nTab--;


    genParseNodeEnd(parse, blur);
    return blur;
}



function genParseLayerBlendValue(parse)
{
    parse.pos++; // LAYER_BLEND_VALUE

    const layer = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(LAYER_BLEND_VALUE, layer, parse);

    return parseLayerBlendValue(layer)[0];
}



function genParseLayerBlend(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const layer = new GLayerBlend(nodeId, options);


    if (parse.settings.logRequests) 
        logReq(layer, parse, ignore);


    if (ignore)
    {
        genParseNodeEnd(parse, layer);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    layer.opacity = genParse(parse);
    layer.blend   = genParse(parse);
    
    
    genParseNodeEnd(parse, layer);
    return layer;
}



function genParseLayerMaskValue(parse)
{
    parse.pos++; // LAYER_MASK_VALUE

    const mask = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(LAYER_MASK_VALUE, mask, parse);

    return parseLayerMaskValue(mask)[0];
}



function genParseLayerMask(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const mask = new GLayerMask(nodeId, options);


    if (parse.settings.logRequests) 
        logReq(mask, parse, ignore);


    if (ignore)
    {
        genParseNodeEnd(parse, mask);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    mask.maskType = genParse(parse);
    
    
    genParseNodeEnd(parse, mask);
    return mask;
}


function genParseNumValue(parse)
{
    parse.pos++; // N

    const val = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(NUMBER_VALUE, val, parse);

    return val.indexOf(',') >= 0
         ? parseNumberValue      (val)[0]
         : parseSimpleNumberValue(val)[0];
}



function genParseNumber(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const num = new GNumber(nodeId, options);

    
    if (parse.settings.logRequests) 
        logReq(num, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, num);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;
    parse.inParam = false;


    if (parse.next == NUMBER_VALUE) num.value = genParse(parse);
    else                            num.input = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, num);
    return num;
}



function genParseBooleanNumber(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const bool = new GBooleanNumber(nodeId, options);

    
    if (parse.settings.logRequests) 
        logReq(bool, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, bool);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;
    parse.inParam = false;


    if (parse.next == NUMBER_VALUE) bool.value = genParse(parse);
    else                            bool.input = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, bool);
    return bool;
}



function genParseSetPrecision(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const prec = new GSetPrecision(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(prec, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, prec);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        prec.input = genParse(parse);

    prec.decimals = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, prec);
    return prec;
}



function genParseConstant(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const _const = new GConstant(nodeId, options);


    if (parse.settings.logRequests) 
        logReq(_const, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, _const);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    _const.constant = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, _const);
    return _const;
}



function genParseDateTime(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const dateTime = new GDateTime(nodeId, options);


    if (parse.settings.logRequests) 
        logReq(dateTime, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, dateTime);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    dateTime.seconds   = genParse(parse);
    dateTime.minutes   = genParse(parse);
    dateTime.hours     = genParse(parse);
    dateTime.dayOfWeek = genParse(parse);
    dateTime.date      = genParse(parse);
    dateTime.month     = genParse(parse);
    dateTime.year      = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, dateTime);
    return dateTime;
}



function genParseSign(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const sign = new GSign(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(sign, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, sign);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        sign.input = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, sign);
    return sign;
}



function genParseAbsolute(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const abs = new GAbsolute(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(abs, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, abs);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        abs.input = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, abs);
    return abs;
}



function genParseNegative(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const neg = new GNegative(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(neg, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, neg);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        neg.input = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, neg);
    return neg;
}



function genParseRound(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const round = new GRound(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(round, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, round);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        round.input = genParse(parse);

    round.type     = genParse(parse);
    round.decimals = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, round);
    return round;
}



function genParseQuantize(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const quant = new GQuantize(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(quant, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, quant);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        quant.input = genParse(parse);

    quant.type   = genParse(parse);
    quant.base   = genParse(parse);
    quant.step   = genParse(parse);
    quant.amount = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, quant);
    return quant;
}



function genParseSimpleMinMax(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const sminmax = new GSimpleMinMax(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(sminmax, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, sminmax);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        sminmax.input = genParse(parse);

    sminmax.operand   = genParse(parse);
    sminmax.operation = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, sminmax);
    return sminmax;
}



function genParseMinMax(parse)
{
    const [type, nodeId, options, ignore] = genParseNodeStart(parse);


    const minmax = new GMinMax(nodeId, options);

    
    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(minmax, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, minmax);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    for (let i = 0; i < nInputs; i++)
        minmax.inputs.push(genParse(parse));


    minmax.operation = genParse(parse);


    parse.nTab--;

        
    genParseNodeEnd(parse, minmax);
    return minmax;
}



function genParseLimits(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const limits = new GLimits(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(limits, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, limits);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        limits.input = genParse(parse);

    limits.min = genParse(parse);
    limits.max = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, limits);
    return limits;
}



function genParseNumberCurve(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const curve = new GNumberCurve(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(curve, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, curve);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        curve.input = genParse(parse);

    curve.min    = genParse(parse);
    curve.max    = genParse(parse);
    curve.power  = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, curve);
    return curve;
}



function genParseNumberMap(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const map = new GNumberMap(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(map, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, map);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        map.input = genParse(parse);

    map.from = genParse(parse);
    map.to   = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, map);
    return map;
}



function genParseNumberBias(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const bias = new GNumberBias(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(bias, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, bias);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        bias.input = genParse(parse);

    bias.min    = genParse(parse);
    bias.max    = genParse(parse);
    bias.bias   = genParse(parse);
    bias.spread = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, bias);
    return bias;
}



function genParseNaNisNumber(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const nanIsNum = new GNaNisNumber(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(nanIsNum, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, nanIsNum);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        nanIsNum.input = genParse(parse);

    nanIsNum._value = genParse(parse);

    parse.nTab--;


    genParseNodeEnd(parse, nanIsNum);
    return nanIsNum;
}



function genParseMath(parse, newNode)
{
    const [type, nodeId, options, ignore] = genParseNodeStart(parse);


    const math = newNode(nodeId, options);

    
    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(math, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, math);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    for (let i = 0; i < nInputs; i++)
        math.inputs.push(genParse(parse));


    math.operation = genParse(parse);


    parse.nTab--;

        
    genParseNodeEnd(parse, math);
    return math;
}



function genParseSimpleMath(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const smath = new GSimpleMath(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(smath, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, smath);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        smath.input = genParse(parse);

    smath.operation = genParse(parse);
    smath.operand   = genParse(parse);
    smath.invert    = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, smath);
    return smath;
}



function genParseArithmetic(parse, newNode)
{
    const [type, nodeId, options, ignore] = genParseNodeStart(parse);


    const arith = newNode(nodeId, options);


    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(arith, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, arith);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    for (let i = 0; i < nInputs; i++)
        arith.inputs.push(genParse(parse));

    parse.nTab--;

        
    genParseNodeEnd(parse, arith);
    return arith;
}



function genParseConvertAngle(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const convert = new GConvertAngle(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(convert, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, convert);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        convert.input = genParse(parse);

    convert.from = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, convert);
    return convert;
}



function genParseIterate(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const define = new GIterate(nodeId, options);


    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(define, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, define);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    
    for (let i = 0; i < nInputs; i++)
        define.inputs.push(genParse(parse));


    parse.nTab--;


    genParseNodeEnd(parse, define);
    return define;
}



function genParseRange(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const dist = new GRange(nodeId, options);


    if (parse.settings.logRequests) 
        logReq(dist, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, dist);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    dist.from   = genParse(parse);
    dist.start  = genParse(parse);
    dist.end    = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, dist);
    return dist;
}



function genParseWave(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const wave = new GWave(nodeId, options);


    if (parse.settings.logRequests) 
        logReq(wave, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, wave);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    wave.shape     = genParse(parse);
    wave.base      = genParse(parse);
    wave.amplitude = genParse(parse);
    wave.frequency = genParse(parse);
    wave.offset    = genParse(parse);
    wave.bias      = genParse(parse);


    wave.useWavelength  = parseInt(parse.move()) > 0;
    wave.offsetAbsolute = parseInt(parse.move()) > 0;


    parse.nTab--;


    genParseNodeEnd(parse, wave);
    return wave;
}



function genParseSequence(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const seq = new GSequence(nodeId, options);


    if (parse.settings.logRequests) 
        logReq(seq, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, seq);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    seq.start    = genParse(parse);
    seq.multiply = genParse(parse);
    seq.add      = genParse(parse);
    seq.end      = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, seq);
    return seq;
}



function genParseRandom(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const rnd = new GRandom(nodeId, options);


    if (parse.settings.logRequests) 
        logReq(rnd, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, rnd);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    rnd.seed      = genParse(parse);
    rnd.iteration = genParse(parse);
    rnd.min       = genParse(parse);
    rnd.max       = genParse(parse);
    rnd.bias      = genParse(parse);
    rnd.spread    = genParse(parse);
    rnd.unique    = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, rnd);
    return rnd;
}



function genParseNoise(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const noise = new GNoise(nodeId, options);


    if (parse.settings.logRequests) 
        logReq(noise, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, noise);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    noise.seed        = genParse(parse);
    noise.iteration   = genParse(parse);
    noise.min         = genParse(parse);
    noise.max         = genParse(parse);
    noise.scale       = genParse(parse);
    noise.offset      = genParse(parse);
    noise.evolve      = genParse(parse);
    noise.interpolate = genParse(parse);
    noise.detail      = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, noise);
    return noise;
}



function genParseProbability(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const prob = new GProbability(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }


    const valueIndex = 
        nInputs == 1
        ? parseInt(parse.move())
        : -1;


    if (parse.settings.logRequests) 
        logReq(prob, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, prob);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 2)
    {
        prob.input0   = genParse(parse);
        prob.input1   = genParse(parse);
    }
    else if (nInputs == 1)
    {
             if (valueIndex == 0) prob.input0 = genParse(parse); 
        else if (valueIndex == 1) prob.input1 = genParse(parse); 
    }


    prob.seed      = genParse(parse);
    prob.iteration = genParse(parse);
    prob.chance    = genParse(parse);
    prob.alternate = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, prob);
    return prob;
}



function genParseAccumulate(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const accum = new GAccumulate(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(accum, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, accum);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        accum.input = genParse(parse);

    accum.when = genParse(parse);

        
    parse.nTab--;


    genParseNodeEnd(parse, accum);
    return accum;
}



function genParseHold(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const hold = new GHold(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(hold, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, hold);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        hold.input = genParse(parse);

    hold.first = genParse(parse);

        
    parse.nTab--;


    genParseNodeEnd(parse, hold);
    return hold;
}



function genParseInterpolate(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const lerp = new GInterpolate(nodeId, options);


    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(lerp, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, lerp);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    for (let i = 0; i < nInputs; i++)
        lerp.inputs.push(genParse(parse));


    lerp.amount = genParse(parse);
    lerp.degree = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, lerp);
    return lerp;
}



function genParseBoolean(parse)
{
    const [type, nodeId, options, ignore] = genParseNodeStart(parse);


    const bool = new GBoolean(nodeId, options);

    
    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(bool, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, bool);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    for (let i = 0; i < nInputs; i++)
        bool.inputs.push(genParse(parse));


    bool.operation = genParse(parse);


    parse.nTab--;

        
    genParseNodeEnd(parse, bool);
    return bool;
}



function genParseCondition(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const cond = new GCompare(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(cond, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, cond);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        cond.input = genParse(parse);
  
    
    cond.operation = genParse(parse);
    cond.operand   = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, cond);
    return cond;
}



function genParseConditionBase(parse, newNode)
{
    const [type, nodeId, options, ignore] = genParseNodeStart(parse);


    const cond = newNode(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }

    
    if (parse.settings.logRequests)
        logReq(cond, parse, ignore, nInputs); 


    if (ignore) 
    {
        genParseNodeEnd(parse, cond);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    if (nInputs == 2)
    {
        cond.input0 = genParse(parse);
        cond.input1 = genParse(parse);
    }
    else if (nInputs == 1)
    {
        cond.input0 = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same
    }

    parse.nTab--;


    genParseNodeEnd(parse, cond);
    return cond;
}



function genParseTrigonometric(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const trig = new GTrig(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(trig, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, trig);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        trig.input = genParse(parse);

    trig.function = genParse(parse);

    parse.nTab--;


    genParseNodeEnd(parse, trig);
    return trig;
}



function genParseTrigBase(parse, newNode)
{
    const [type, nodeId, options, ignore] = genParseNodeStart(parse);


    const trig = newNode(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests)
        logReq(trig, parse, ignore, nInputs); 


    if (ignore) 
    {
        genParseNodeEnd(parse, trig);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        trig.input = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, trig);
    return trig;
}



function genParseAtan2(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const atan2 = new GAtan2(nodeId, options);
   
    
    if (parse.settings.logRequests) 
        logReq(atan2, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, atan2);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    atan2.x = genParse(parse);
    atan2.y = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, atan2);
    return atan2;
}



function genParseSolve(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const solve = new GSolve(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(solve, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, solve);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        solve.input = genParse(parse);

    solve.current = genParse(parse);
    solve.target  = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, solve);
    return solve;
}



function genParseAnimate(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const anim = new GAnimate(nodeId, options);


    if (parse.settings.logRequests) 
        logReq(anim, parse);


    if (ignore) 
    {
        genParseNodeEnd(parse, anim);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    anim.from   = genParse(parse);
    anim.to     = genParse(parse);
    anim.curve  = genParse(parse);
    anim.repeat = genParse(parse);
    anim.length = genParse(parse);
    anim.time   = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, anim);
    return anim;
}



function genParseRectangle(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const rect = new GRectangle(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(rect, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, rect);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        rect.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {
        case 'x':      rect.x      = genParse(parse); break;
        case 'y':      rect.y      = genParse(parse); break;
        case 'width':  rect.width  = genParse(parse); break;
        case 'height': rect.height = genParse(parse); break;
        case 'round':  rect.round  = genParse(parse); break;
        case 'props':  rect.props  = genParse(parse); break;
        }
    }


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, rect);
    return rect;
}



// function genParseRectangleExt(parse)
// {
//     const [, nodeId, options, ignore] = genParseNodeStart(parse);


//     const rect = new GRectangleExt(nodeId, options);


//     let nInputs = -1;

//     if (!ignore)
//     {
//         nInputs = parseInt(parse.move());
//         consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
//     }


//     if (parse.settings.logRequests) 
//         logReq(rect, parse, ignore);


//     if (ignore) 
//     {
//         genParseNodeEnd(parse, rect);
//         return parse.parsedNodes.find(n => n.nodeId == nodeId);
//     }


//     parse.nTab++;


//     if (nInputs == 1)
//         rect.input = genParse(parse);


//     const nParamIds = genParseParamCount(parse);

//     for (let i = 0; i < nParamIds; i++)
//     {
//         const paramId = genParseParamId(parse);

//         parse.inParam = true;

//         switch (paramId)
//         {
//         case 'top':    rect.top    = genParse(parse); break;
//         case 'left':   rect.left   = genParse(parse); break;
//         case 'right':  rect.right  = genParse(parse); break;
//         case 'bottom': rect.bottom = genParse(parse); break;
//         case 'round':  rect.round  = genParse(parse); break;
//         case 'props':  rect.props  = genParse(parse); break;
//         }
//     }


//     parse.inParam = false;
//     parse.nTab--;


//     genParseNodeEnd(parse, rect);
//     return rect;
// }



function genParseLine(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);

  
    const line = new GLine(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(line, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, line);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        line.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {
        case 'x':     line.x     = genParse(parse); break;
        case 'y':     line.y     = genParse(parse); break;
        case 'width': line.width = genParse(parse); break;
        case 'props': line.props = genParse(parse); break;
        }
    }


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, line);
    return line;
}



function genParseEllipse(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const ellipse = new GEllipse(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(ellipse, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, ellipse);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        ellipse.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {
        case 'position': ellipse.position = genParse(parse); break;
        case 'x':        ellipse.x        = genParse(parse); break;
        case 'y':        ellipse.y        = genParse(parse); break;
        case 'width':    ellipse.width    = genParse(parse); break;
        case 'height':   ellipse.height   = genParse(parse); break;
        case 'round':    ellipse.round    = genParse(parse); break;
        case 'start':    ellipse.start    = genParse(parse); break;
        case 'sweep':    ellipse.sweep    = genParse(parse); break;
        case 'inner':    ellipse.inner    = genParse(parse); break;
        case 'props':    ellipse.props    = genParse(parse); break;
        }
    }
    
    
    ellipse.innerAbsolute  = parseInt(parse.move()) > 0;
    ellipse.startInDegrees = parseInt(parse.move()) > 0;
    ellipse.sweepInDegrees = parseInt(parse.move()) > 0;


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, ellipse);
    return ellipse;
}



function genParseTrapeze(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const trapeze = new GTrapeze(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(trapeze, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, trapeze);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        trapeze.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {
        case 'x':      trapeze.x      = genParse(parse); break;
        case 'y':      trapeze.y      = genParse(parse); break;
        case 'width':  trapeze.width  = genParse(parse); break;
        case 'height': trapeze.height = genParse(parse); break;
        case 'round':  trapeze.round  = genParse(parse); break;
        case 'bias':   trapeze.bias   = genParse(parse); break;
        case 'props':  trapeze.props  = genParse(parse); break;
        }
    }
    
    
    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, trapeze);
    return trapeze;
}



function genParsePolygon(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const poly = new GPolygon(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(poly, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, poly);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        poly.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {
        case 'position': poly.position = genParse(parse); break;
        case 'x':        poly.x        = genParse(parse); break;
        case 'y':        poly.y        = genParse(parse); break;
        case 'width':    poly.width    = genParse(parse); break;
        case 'height':   poly.height   = genParse(parse); break;
        case 'round':    poly.round    = genParse(parse); break;
        case 'corners':  poly.corners  = genParse(parse); break;
        case 'props':    poly.props    = genParse(parse); break;
        }
    }
    
    
    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, poly);
    return poly;
}



function genParseStar(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const star = new GStar(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(star, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, star);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        star.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {
        case 'position': star.position = genParse(parse); break;
        case 'x':        star.x        = genParse(parse); break;
        case 'y':        star.y        = genParse(parse); break;
        case 'width':    star.width    = genParse(parse); break;
        case 'height':   star.height   = genParse(parse); break;
        case 'round':    star.round    = genParse(parse); break;
        case 'points':   star.points   = genParse(parse); break;
        case 'convex':   star.convex   = genParse(parse); break;
        case 'props':    star.props    = genParse(parse); break;
        }
    }
    
    
    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, star);
    return star;
}



function genParseTextShape(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const text = new GTextShape(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(text, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, text);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        text.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {       
        case 'text':          text.text          = genParse(parse); break;
        case 'x':             text.x             = genParse(parse); break;
        case 'y':             text.y             = genParse(parse); break;
        case 'width':         text.width         = genParse(parse); break;
        case 'height':        text.height        = genParse(parse); break;
        case 'font':          text.font          = genParse(parse); break;
        case 'size':          text.size          = genParse(parse); break;
        case 'style':         text.style         = genParse(parse); break;
        case 'props':         text.props         = genParse(parse); break;
        case 'alignX':        text.alignX        = genParse(parse); break;
        case 'alignY':        text.alignY        = genParse(parse); break;
        case 'lineHeight':    text.lineHeight    = genParse(parse); break;
        case 'letterSpacing': text.letterSpacing = genParse(parse); break;
        }
    }


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, text);
    return text;
}



function genParsePointValue(parse)
{
    parse.pos++; // POINT_VALUE

    const point = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(POINT_VALUE, point, parse);

    return parsePointValue(point)[0];
}



function genParsePoint(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const point = new GPoint(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(point, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, point);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        point.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {
        case 'x': point.x = genParse(parse); break;
        case 'y': point.y = genParse(parse); break;
        }
    }


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, point);
    return point;
}



function genParsePointCorner(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const corner = new GPointCorner(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(corner, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, corner);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        corner.input = genParse(parse);

    corner.smooth = genParse(parse);


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, corner);
    return corner;
}



function genParseVectorPathValue(parse)
{
    parse.pos++; // VECTOR_PATH_VALUE

    const path = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(VECTOR_PATH_VALUE, path, parse);

    return parseVectorPathValue(path)[0];
}



function genParseVectorPath(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const path = new GVectorPath(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(path, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, path);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        path.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {       
        case 'points':  path.points  = genParse(parse); break;
        case 'closed':  path.closed  = genParse(parse); break;
        case 'degree':  path.degree  = genParse(parse); break;
        case 'winding': path.winding = genParse(parse); break;
        case 'round':   path.round   = genParse(parse); break;
        case 'props':   path.props   = genParse(parse); break;
        }
    }


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, path);
    return path;
}



function genParsePathLength(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const len = new GPathLength(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(len, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, len);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        len.input = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, len);
    return len;
}



function genParseJoinPaths(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const join = new GJoinPaths(nodeId, options);


    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(join, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, join);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    for (let i = 0; i < nInputs; i++)
        join.inputs.push(genParse(parse));


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {       
        case 'closed':  join.closed  = genParse(parse); break;
        case 'degree':  join.degree  = genParse(parse); break;
        case 'winding': join.winding = genParse(parse); break;
        case 'round':   join.round   = genParse(parse); break;
        case 'props':   join.props   = genParse(parse); break;
        }
    }


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, join);
    return join;
}



function genParseReorientPaths(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const reorient = new GReorientPaths(nodeId, options);


    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(reorient, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, reorient);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    for (let i = 0; i < nInputs; i++)
        reorient.inputs.push(genParse(parse));


    reorient.reverse = genParse(parse);
    
        
    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, reorient);
    return reorient;
}



function genParseVectorVertexValue(parse)
{
    parse.pos++; // VECTOR_POINT_VALUE

    const point = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(VECTOR_VERTEX_VALUE, point, parse);

    return parseVectorVertexValue(point)[0];
}



function genParseVectorVertex(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const point = new GVectorVertex(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(point, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, point);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        point.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {
        case 'x':     point.x     = genParse(parse); break;
        case 'y':     point.y     = genParse(parse); break;
        case 'join':  point.join  = genParse(parse); break;
        case 'cap':   point.cap   = genParse(parse); break;
        case 'round': point.round = genParse(parse); break;
        }
    }


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, point);
    return point;
}



function genParseVectorEdgeValue(parse)
{
    parse.pos++; // VECTOR_EDGE_VALUE

    const edge = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(VECTOR_EDGE_VALUE, edge, parse);

    return parseVectorEdgeValue(edge)[0];
}



function genParseVectorEdge(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const edge = new GVectorEdge(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }

    
    if (parse.settings.logRequests) 
        logReq(edge, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, edge);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 2)
    {
        edge.input0 = genParse(parse);
        edge.input1 = genParse(parse);
    }
    else if (nInputs == 1)
    {
        edge.input0 = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same
    }


    edge.startTangent = genParse(parse);
    edge.  endTangent = genParse(parse);


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, edge);
    return edge;
}



function genParseVectorRegionValue(parse)
{
    parse.pos++; // VECTOR_REGION_VALUE

    const region = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(VECTOR_REGION_VALUE, region, parse);

    return parseVectorRegionValue(region)[0];
}



function genParseVectorRegion(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const region = new GVectorRegion(nodeId, options);


    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(region, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, region);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    for (let i = 0; i < nInputs; i++)
        region.inputs.push(genParse(parse));


    region.winding = genParse(parse);
    region.props   = genParse(parse);


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, region);
    return region;
}



function genParseVectorNetworkValue(parse)
{
    parse.pos++; // VECTOR_NETWORKO_VALUE

    const region = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(VECTOR_NETWORK_VALUE, region, parse);

    return parseVectorNetworkValue(region)[0];
}



function genParseVectorNetwork(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const network = new GVectorNetwork(nodeId, options);


    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(network, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, network);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    for (let i = 0; i < nInputs; i++)
        network.inputs.push(genParse(parse));

    network.props = genParse(parse);


    parse.nTab--;



    genParseNodeEnd(parse, network);
    return network;
}



function genParseShapeBoolean(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const bool = new GShapeBoolean(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(bool, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, bool);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        bool.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {
        case 'children':  bool.children  = genParse(parse); break;
        case 'operation': bool.operation = genParse(parse); break;
        case 'props':     bool.props     = genParse(parse); break;
        }
    }


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, bool);
    return bool;
}



function genParseArcPath(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const arc = new GArcPath(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(arc, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, arc);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        arc.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {
        case 'position': arc.position = genParse(parse); break;
        case 'x':        arc.x        = genParse(parse); break;
        case 'y':        arc.y        = genParse(parse); break;
        case 'width':    arc.width    = genParse(parse); break;
        case 'height':   arc.height   = genParse(parse); break;
        case 'start':    arc.start    = genParse(parse); break;
        case 'sweep':    arc.sweep    = genParse(parse); break;
        case 'props':    arc.props    = genParse(parse); break;
        }
    }
    
    
    arc.startInDegrees = parseInt(parse.move()) > 0;
    arc.sweepInDegrees = parseInt(parse.move()) > 0;


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, arc);
    return arc;
}



function genParseWavePath(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const wave = new GWavePath(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(wave, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, wave);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        wave.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {
        case 'shape':     wave.shape     = genParse(parse); break;
        case 'x':         wave.x         = genParse(parse); break;
        case 'y':         wave.y         = genParse(parse); break;
        case 'width':     wave.width     = genParse(parse); break;
        case 'amplitude': wave.amplitude = genParse(parse); break;
        case 'frequency': wave.frequency = genParse(parse); break;
        case 'offset':    wave.offset    = genParse(parse); break;
        case 'alignX':    wave.alignX    = genParse(parse); break;
        case 'alignY':    wave.alignY    = genParse(parse); break;
        case 'props':     wave.props     = genParse(parse); break;
        }
    }
    
    
    wave.useWavelength  = parseInt(parse.move()) > 0;
    wave.offsetAbsolute = parseInt(parse.move()) > 0;


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, wave);
    return wave;
}



function genParseShapeGroup(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const group = new GShapeGroup(nodeId, options);


    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(group, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, group);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    for (let i = 0; i < nInputs; i++)
        group.inputs.push(genParse(parse));


    parse.nTab--;


    genParseNodeEnd(parse, group);
    return group;
}



function genParseFrame(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const frame = new GFrame(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(frame, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, frame);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        frame.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {
        case 'children': frame.children = genParse(parse); break;
        case 'position': frame.position = genParse(parse); break;
        case 'x':        frame.x        = genParse(parse); break;
        case 'y':        frame.y        = genParse(parse); break;
        case 'width':    frame.width    = genParse(parse); break;
        case 'height':   frame.height   = genParse(parse); break;
        case 'round':    frame.round    = genParse(parse); break;
        case 'clip':     frame.clip     = genParse(parse); break;
        case 'props':    frame.props    = genParse(parse); break;
        }
    }


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, frame);
    return frame;
}



function genParseMove(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const move = new GMove(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(move, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, move);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        move.input = genParse(parse);

    move.moveType    = genParse(parse);
    move.x           = genParse(parse);
    move.y           = genParse(parse);
    move.affectSpace = genParse(parse);


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, move);
    return move;
}



function genParseRotate(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const rotate = new GRotate(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(rotate, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, rotate);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        rotate.input = genParse(parse);

    rotate.angle       = genParse(parse);
    rotate.affectSpace = genParse(parse);

    
    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, rotate);
    return rotate;
}



function genParseScale(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const scale = new GScale(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(scale, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, scale);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        scale.input = genParse(parse);

    scale.scaleX        = genParse(parse);
    scale.scaleY        = genParse(parse);
    scale.affectCorners = genParse(parse);
    scale.affectStyle   = genParse(parse);
    scale.affectSpace   = genParse(parse);

    
    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, scale);
    return scale;
}



function genParseSkew(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const skew = new GSkew(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(skew, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, skew);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        skew.input = genParse(parse);

    skew.skewX       = genParse(parse);
    skew.skewY       = genParse(parse);
    skew.affectSpace = genParse(parse);


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, skew);
    return skew;
}



function genParseShowCenter(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const showCenter = new GShowCenter(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(showCenter, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, showCenter);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        showCenter.input = genParse(parse);

    showCenter.show = genParse(parse);


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, showCenter);
    return showCenter;
}



function genParseCenter(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const center = new GSetCenter(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(center, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, center);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        center.input = genParse(parse);

    center.centerX    = genParse(parse);
    center.centerY    = genParse(parse);
    center.units      = genParse(parse);


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, center);
    return center;
}



function genParseResetTransform(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const reset = new GResetTransform(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(reset, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, reset);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        reset.input = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, reset);
    return reset;
}



function genParseMeasureVector(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const measure = new GMeasureVector(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(measure, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, measure);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    
    if (nInputs == 1)
        measure.input = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same


        
    parse.nTab--;


    genParseNodeEnd(parse, measure);
    return measure;
}



function genParsePointAngle(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const angle = new GPointAngle(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(angle, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, angle);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        angle.input = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, angle);
    return angle;
}



function genParseVector(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const vector = new GVector(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }

    
    if (parse.settings.logRequests) 
        logReq(vector, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, vector);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    
    if (nInputs == 2)
    {
        vector.input0 = genParse(parse);
        vector.input1 = genParse(parse);
    }
    else if (nInputs == 1)
    {
        vector.input0 = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same
    }


    vector.transform  = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, vector);
    return vector;
}



function genParseCircleCenter(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const center = new GCircleCenter(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 3, 'nInputs must be [0, 3]');
    }

    
    if (parse.settings.logRequests) 
        logReq(center, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, center);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    
    if (nInputs == 3)
    {
        center.input0 = genParse(parse);
        center.input1 = genParse(parse);
        center.input2 = genParse(parse);
    }
    else if (nInputs == 2)
    {
        center.input0 = genParse(parse);
        center.input1 = genParse(parse);
    }
    else if (nInputs == 1)
    {
        center.input0 = genParse(parse);
    }


    parse.nTab--;


    genParseNodeEnd(parse, center);
    return center;
}



function genParseArcFromPoints(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const arc = new GArcFromPoints(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 3, 'nInputs must be [0, 3]');
    }

    
    if (parse.settings.logRequests) 
        logReq(arc, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, arc);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    
    if (nInputs == 3)
    {
        arc.input0 = genParse(parse);
        arc.input1 = genParse(parse);
        arc.input2 = genParse(parse);
    }
    else if (nInputs == 2)
    {
        arc.input0 = genParse(parse);
        arc.input1 = genParse(parse);
    }
    else if (nInputs == 1)
    {
        arc.input0 = genParse(parse);
    }


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {       
        case 'props':   arc.props   = genParse(parse); break;
        }
    }


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, arc);
    return arc;
}



function genParseIntersectLines(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const inter = new GIntersectLines(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 4, 'nInputs must be [0, 4]');
    }

    
    if (parse.settings.logRequests) 
        logReq(inter, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, inter);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    
    if (nInputs == 4)
    {
        inter.input0 = genParse(parse);
        inter.input1 = genParse(parse);
        inter.input2 = genParse(parse);
        inter.input3 = genParse(parse);
    }
    else if (nInputs == 3)
    {
        inter.input0 = genParse(parse);
        inter.input1 = genParse(parse);
        inter.input2 = genParse(parse);
    }
    else if (nInputs == 2)
    {
        inter.input0 = genParse(parse);
        inter.input1 = genParse(parse);
    }
    else if (nInputs == 1)
    {
        inter.input0 = genParse(parse);
    }


    inter.segment = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, inter);
    return inter;
}



function genParseInterpolatePoint(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const lerp = new GInterpolatePoint(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }

    
    if (parse.settings.logRequests) 
        logReq(lerp, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, lerp);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 2)
    {
        lerp.input0 = genParse(parse);
        lerp.input1 = genParse(parse);
    }
    else if (nInputs == 1)
    {
        lerp.input0 = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same
    }


    lerp.amount     = genParse(parse);
    lerp.transform  = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, lerp);
    return lerp;
}



function genParsePointAlongPath(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const pap = new GPointAlongPath(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(pap, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, pap);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        pap.input = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same


    pap.position   = genParse(parse);
    pap.distance   = genParse(parse);
    pap.offset     = genParse(parse);
    pap.transform  = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, pap);
    return pap;
}



function genParseClosestPointOnPath(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const cpop = new GClosestPointOnPath(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }

    
    if (parse.settings.logRequests) 
        logReq(cpop, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, cpop);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 2)
    {
        cpop.input0 = genParse(parse);
        cpop.input1 = genParse(parse);
    }
    else if (nInputs == 1)
    {
        cpop.input0 = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same
    }


    cpop.constrain  = genParse(parse);
    cpop.transform  = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, cpop);
    return cpop;
}



function genParseReversePath(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const reverse = new GReversePath(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(reverse, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, reverse);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        reverse.input = genParse(parse);
  
    
    parse.nTab--;


    genParseNodeEnd(parse, reverse);
    return reverse;
}



function genParseBlendPath(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const blend = new GBlendPath(nodeId, options);
   

    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(blend, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, blend);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    
    for (let i = 0; i < nInputs; i++)
        blend.inputs.push(genParse(parse));


    blend.amount = genParse(parse);
    blend.degree = genParse(parse);
  
    
    parse.nTab--;


    genParseNodeEnd(parse, blend);
    return blend;
}



function genParsePlace(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const place = new GPlace(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(place, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, place);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        place.input = genParse(parse);

    place.position   = genParse(parse);
    place.transform  = genParse(parse);


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, place);
    return place;
}



function genParseShapeApply(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const apply = new GApply(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(apply, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, apply);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        apply.input = genParse(parse);

    apply.props   = genParse(parse);
    apply.replace = genParse(parse);


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, apply);
    return apply;
}



function genParsePersist(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const persist = new GPersist(nodeId, options);


    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(persist, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, persist);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    for (let i = 0; i < nInputs; i++)
        persist.inputs.push(genParse(parse));

    persist.persist  = genParse(parse);
    persist.finalize = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, persist);
    return persist;
}



function genParseExport(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const _export = new GExport(nodeId, options);


    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(_export, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, _export);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    for (let i = 0; i < nInputs; i++)
        _export.inputs.push(genParse(parse));

    _export.scale    = genParse(parse);
    _export.format   = genParse(parse);
 // _export.contents = genParse(parse);
 // _export.crop     = genParse(parse);
    _export.suffix   = genParse(parse);
    _export.profile  = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, _export);
    return _export;
}


// function genParseColorStyleValue(parse)
// {
//     parse.pos++; // COLOR_STYLE_VALUE

//     const style = parse.move();

//     if (parse.settings.logRequests) 
//         logReqStyleValue(style, parse);

//     return parseColorStyleValue(style)[0];
// }



function genParseColorStyle(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const style = new GColorStyle(nodeId, options);

    style.existing = options.existing;


    if (parse.settings.logRequests) 
        logReq(style, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, style);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;
    parse.inParam = false;


    style.id       = parse.move();
    style.name     = options.nodeName;
    
    style.genValue = genParse(parse);

    
    parse.nTab--;

    
    style.linked = style.id != NULL;


    genParseNodeEnd(parse, style);
    return style;
}



//function genParseStyleParam(parse)
//{
    // const style = genParse(parse); 

    // if (STYLE_TYPES.includes(style.type))
    //     style.options.opacity = genParse(parse);

    // return style;
//}




function genParseTextValue(parse)
{
    parse.pos++; // tag

    const val = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(TEXT_VALUE, val, parse);

    return parseTextValue(val)[0];
}



function genParseText(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const text = new GText(nodeId, options);

    
    if (parse.settings.logRequests) 
        logReq(text, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, text);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;
    parse.inParam = false;


    if (parse.next == TEXT_VALUE) text.value = genParse(parse);
    else                          text.input = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, text);
    return text;
}



function genParseTextLength(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const len = new GTextLength(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(len, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, len);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        len.input = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, len);
    return len;
}



function genParseTextTrim(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const trim = new GTextTrim(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(trim, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, trim);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        trim.input = genParse(parse);

    trim.start = genParse(parse);
    trim.end   = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, trim);
    return trim;
}



function genParseTextSubstring(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const sub = new GTextSubstring(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(sub, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, sub);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        sub.input = genParse(parse);

    sub.start = genParse(parse);
    sub.end   = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, sub);
    return sub;
}



function genParseTextContains(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const cont = new GTextContains(nodeId, options);
   

    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }

    
    if (parse.settings.logRequests) 
        logReq(cont, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, cont);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 2)
    {
        cont.input0 = genParse(parse);
        cont.input1 = genParse(parse);
    }
    else if (nInputs == 1)
    {
        cont.input0 = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same
    }
  
    
    parse.nTab--;


    genParseNodeEnd(parse, cont);
    return cont;
}



function genParseTextFind(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const find = new GTextFind(nodeId, options);
   

    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }

    
    if (parse.settings.logRequests) 
        logReq(find, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, find);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 2)
    {
        find.input0 = genParse(parse);
        find.input1 = genParse(parse);
    }
    else if (nInputs == 1)
    {
        find.input0 = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same
    }
  
    
    parse.nTab--;


    genParseNodeEnd(parse, find);
    return find;
}



function genParseTextCase(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const _case = new GTextCase(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(_case, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, _case);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        _case.input = genParse(parse);

    _case.case = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, _case);
    return _case;
}



function genParseTextReplace(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const replace = new GTextReplace(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(replace, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, replace);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        replace.input = genParse(parse);

    replace.what  = genParse(parse);
    replace.with  = genParse(parse);
    replace.regex = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, replace);
    return replace;
}




// function genParseTextRegex(parse)
// {
//     const [, nodeId, options, ignore] = genParseNodeStart(parse);


//     const regex = new GTextRegex(nodeId, options);
   

//     let nInputs = -1;
    
//     if (!ignore)
//     {
//         nInputs = parseInt(parse.move());
//         consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
//     }

    
//     if (parse.settings.logRequests) 
//         logReq(regex, parse, ignore, nInputs);


//     if (ignore) 
//     {
//         genParseNodeEnd(parse, regex);
//         return parse.parsedNodes.find(n => n.nodeId == nodeId);
//     }


//     parse.nTab++;


//     if (nInputs == 1)
//         regex.input = genParse(parse);

//     regex.pattern = genParse(parse);
//     regex.what    = genParse(parse);
//     regex.with    = genParse(parse);

    
//     parse.nTab--;


//     genParseNodeEnd(parse, regex);
//     return regex;
// }




function genParseAddText(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const addText = new GAddText(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(addText, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, addText);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        addText.input = genParse(parse);

    addText.text   = genParse(parse);
    addText.prefix = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, addText);
    return addText;
}



function genParseTextJoin(parse, newNode)
{
    const [type, nodeId, options, ignore] = genParseNodeStart(parse);


    const join = new GTextJoin(nodeId, options);


    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(join, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, join);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    for (let i = 0; i < nInputs; i++)
        join.inputs.push(genParse(parse));


    join.with = genParse(parse);

    
    parse.nTab--;

        
    genParseNodeEnd(parse, join);
    return join;
}



function genParseTextPad(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const pad = new GTextPad(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(pad, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, pad);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        pad.input = genParse(parse);

    pad.startPad   = genParse(parse);
    pad.startCount = genParse(parse);
    pad.endPad     = genParse(parse);
    pad.endCount   = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, pad);
    return pad;
}



function genParseTextCompare(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const cmp = new GTextCompare(nodeId, options);
   

    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }

    
    if (parse.settings.logRequests) 
        logReq(cmp, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, cmp);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 2)
    {
        cmp.input0 = genParse(parse);
        cmp.input1 = genParse(parse);
    }
    else if (nInputs == 1)
    {
        cmp.input0 = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same
    }
  
    
    cmp.operation = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, cmp);
    return cmp;
}



function genParseCodeToCharacter(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const code2char = new GCodeToCharacter(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(code2char, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, code2char);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        code2char.input = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, code2char);
    return code2char;
}



function genParseCharacterToCode(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const char2code = new GCharacterToCode(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(char2code, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, char2code);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        char2code.input = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, char2code);
    return char2code;
}



function genParseIndexToName(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const index = new GIndexToName(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(index, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, index);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    index.name  = genParse(parse);
    index.index = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, index);
    return index;
}



function genParseNumberToText(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const num2text = new GNumberToText(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(num2text, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, num2text);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        num2text.input = genParse(parse);

    num2text.base      = genParse(parse);
    num2text.decimals  = genParse(parse);
    num2text.thousands = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, num2text);
    return num2text;
}



function genParseColorToText(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const col2text = new GColorToText(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(col2text, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, col2text);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        col2text.input = genParse(parse);

    col2text.format = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, col2text);
    return col2text;
}



function genParseTextToNumber(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const text2num = new GTextToNumber(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(text2num, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, text2num);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        text2num.input = genParse(parse);

    text2num.base      = genParse(parse);
    text2num.decimals  = genParse(parse);
    text2num.thousands = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, text2num);
    return text2num;
}



function genParseTextToColor(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const text2col = new GTextToColor(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(text2col, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, text2col);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        text2col.input = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, text2col);
    return text2col;
}



function genParseTextSplit(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const split = new GTextSplit(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(split, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, split);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        split.input = genParse(parse);

    split.separator = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, split);
    return split;
}



function genParseParseCSV(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const csv = new GParseCSV(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(csv, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, csv);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        csv.input = genParse(parse);

    csv.rowSeparator    = genParse(parse);
    csv.columnSeparator = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, csv);
    return csv;
}



function genParseParseJson(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const json = new GParseJson(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(json, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, json);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        json.input = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, json);
    return json;
}



function genParseTextFetch(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const fetch = new GTextFetch(nodeId, options);
   

    if (parse.settings.logRequests) 
        logReq(fetch, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, fetch);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    fetch.request     = genParse(parse);
    fetch.cachedValue = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, fetch);
    return fetch;
}



function genParseTextFile(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const file = new GTextFile(nodeId, options);
   

    if (parse.settings.logRequests) 
        logReq(file, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, file);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    file.cachedValue = genParse(parse);
    //file.path        = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, file);
    return file;
}


class Parse
{
    request;
    requestId;
    
    pos; 
    so;

    settings = {};

    save;


    log  = '';
    
    nTab = 0;

    get tab() { return this.inParam ? ' ' : (NL + HTAB.repeat(Math.max(0, this.nTab))); }

    
    inParam = false;


    evalAccumulate = true;
    evalFeedback   = true;

    
    updateNodeId;
    updateParamId;

    viewportZoom;

    currentProgress = 0;
    totalProgress   = 0;

    scope           = []; // current parse stack
    parsedNodes     = []; // must be evaluated to create the value updates
  
  
    repeats         = [];
  
    stopGenerate    = false;
  
  
    paramNodeIds    = [];
  
    updateParams    = [];
    updateValues    = [];
    updateObjects   = [];
    updateStyles    = [];

    

    get next() { return this.request[this.pos]; }

    get afterNext() 
    { 
        return this.pos+1 < this.request.length 
             ? this.request[this.pos+1]
             : null;
    }



    constructor(request, firstPos, requestId, updateNodeId, updateParamId, viewportZoom, settings, save)
    {
        this.request       = request;
        this.requestId     = requestId;
          
        this.pos           = firstPos; 
        this.so            = 0;
        
        this.updateNodeId  = updateNodeId; 
        this.updateParamId = updateParamId;
   
        this.viewportZoom  = viewportZoom;

        this.settings      = settings;

        this.save          = save;
    }



    move()
    {
        //return this.request[this.pos++];

        const token = this.request[this.pos++];
        //console.log('token =', token);
        return token;
    }



    isLastRepeat() 
    {
        return isEmpty(this.repeats)
            ||    this.repeats.length == 1
               && this.repeats[0].currentIteration == this.repeats[0].total-1;
    }

}



function genParse(parse, inParam = true)
{
    //console.log('parse.next', parse.next);

    if (!inParam)
        parse.inParam = false;


    let result = null;


         if (parse.next == PARAM                  ) result = genParseParam             (parse);
        
    else if (parse.next ==        LIST_VALUE             
          || parse.next == NUMBER_LIST_VALUE             
          || parse.next ==   TEXT_LIST_VALUE             
          || parse.next ==  SHAPE_LIST_VALUE      ) result = genParseListValue         (parse);
 
    else if (parse.next == NULL_NODE              ) result = genParseNull              (parse);
    else if (parse.next == VARIABLE               ) result = genParseVariable          (parse);
    else if (parse.next == VARIABLE_GROUP         ) result = genParseVariableGroup     (parse);
    else if (parse.next == IF_ELSE                ) result = genParseIfElse            (parse);
    else if (parse.next == FEEDBACK               ) result = genParseFeedback          (parse);
    else if (parse.next == REPEAT                 ) result = genParseRepeat            (parse);
    else if (parse.next == CACHE                  ) result = genParseCache             (parse);
    else if (parse.next == ITERATE                ) result = genParseIterate           (parse);
    else if (parse.next == FREEZE                 ) result = genParseFreeze            (parse);
    else if (parse.next == TIMER                  ) result = genParseTimer             (parse);
    else if (parse.next == GET_VALUE_NAME         ) result = genParseGetValueName      (parse);
    else if (parse.next == SET_VALUE_NAME         ) result = genParseSetValueName      (parse);
    else if (parse.next == GET_LIST_VALUE_NAMES   ) result = genParseGetListValueNames (parse);
    else if (parse.next == SET_LIST_VALUE_NAMES   ) result = genParseSetListValueNames (parse);
    else if (parse.next == SET_OBJECT_NAME        ) result = genParseSetObjectName     (parse);

    else if (parse.next == COMBINE                ) result = genParseCombine           (parse);
    else if (parse.next == LIST_AS_ITEM           ) result = genParseListAsItem        (parse);
    else if (parse.next == EXTRACT                ) result = genParseExtract           (parse);
    else if (parse.next == SET_PARAM              ) result = genParseSetParam          (parse);
    else if (parse.next == GET_PARAM              ) result = genParseGetParam          (parse);
    else if (parse.next == SUBLIST                ) result = genParseSublist           (parse);
    else if (parse.next == UNIQUE                 ) result = genParseUnique            (parse);
    else if (parse.next == REORDER_LIST           ) result = genParseReorderList       (parse);
    else if (parse.next == SHIFT_LIST             ) result = genParseShiftList         (parse);
    else if (parse.next == REVERSE_LIST           ) result = genParseReverseList       (parse);
    else if (parse.next == BUCKLE_LIST            ) result = genParseBuckleList        (parse);
    else if (parse.next == SORT                   ) result = genParseSort              (parse);
    else if (parse.next == FILTER                 ) result = genParseFilter            (parse);
    else if (parse.next == COLUMN                 ) result = genParseColumn            (parse);
    else if (parse.next == CELL                   ) result = genParseCell              (parse);
    else if (parse.next == LIST                   ) result = genParseList              (parse);
    else if (parse.next == SELECT                 ) result = genParseSelect            (parse);
    else if (parse.next == SELECT_FROM_LIST       ) result = genParseSelectFromList    (parse);
    else if (parse.next == LIST_COUNT             ) result = genParseListCount         (parse);
    else if (parse.next == OBJECT_COUNT           ) result = genParseObjectCount       (parse);
    else if (parse.next == LIST_CONTAINS          ) result = genParseListContains      (parse);
    else if (parse.next == LIST_FIND              ) result = genParseListFind          (parse);
     
    else if (parse.next == NUMBER_VALUE           ) result = genParseNumValue          (parse);
    else if (parse.next == NUMBER                 ) result = genParseNumber            (parse);
    else if (parse.next == BOOLEAN_NUMBER         ) result = genParseBooleanNumber     (parse);
    else if (parse.next == NUMBER_PRECISION       ) result = genParseSetPrecision      (parse);
    else if (parse.next == NUMBER_SIGN            ) result = genParseSign              (parse);
    else if (parse.next == NUMBER_ABSOLUTE        ) result = genParseAbsolute          (parse);
    else if (parse.next == NUMBER_NEGATIVE        ) result = genParseNegative          (parse);
    else if (parse.next == NUMBER_ROUND           ) result = genParseRound             (parse);
    else if (parse.next == NUMBER_QUANTIZE        ) result = genParseQuantize          (parse);
    else if (parse.next == NUMBER_MINMAX          ) result = genParseMinMax            (parse);
    else if (parse.next == NUMBER_SIMPLE_MINMAX   ) result = genParseSimpleMinMax      (parse);
    else if (parse.next == NUMBER_LIMITS          ) result = genParseLimits            (parse);
    else if (parse.next == NUMBER_CURVE           ) result = genParseNumberCurve       (parse);
    else if (parse.next == NUMBER_MAP             ) result = genParseNumberMap         (parse);
    else if (parse.next == NUMBER_BIAS            ) result = genParseNumberBias        (parse);
    else if (parse.next == NUMBER_NAN             ) result = genParseNaNisNumber       (parse);
    else if (parse.next == NUMBER_CONSTANT        ) result = genParseConstant          (parse);
    else if (parse.next == NUMBER_DATETIME        ) result = genParseDateTime          (parse);
    else if (parse.next == NUMBER_SEQUENCE        ) result = genParseSequence          (parse);
    else if (parse.next == NUMBER_RANGE           ) result = genParseRange             (parse);
    else if (parse.next == NUMBER_WAVE            ) result = genParseWave              (parse);
    else if (parse.next == NUMBER_RANDOM          ) result = genParseRandom            (parse);
    else if (parse.next == NUMBER_NOISE           ) result = genParseNoise             (parse);
    else if (parse.next == PROBABILITY            ) result = genParseProbability       (parse);
    else if (parse.next == NUMBER_ACCUMULATE      ) result = genParseAccumulate        (parse);
    else if (parse.next == HOLD                   ) result = genParseHold              (parse);
    else if (parse.next == NUMBER_INTERPOLATE     ) result = genParseInterpolate       (parse);
    else if (parse.next == NUMBER_SOLVE           ) result = genParseSolve             (parse);
    else if (parse.next == NUMBER_ANIMATE         ) result = genParseAnimate           (parse);
    
    else if (parse.next == NUMBER_MATH            ) result = genParseMath              (parse, (nodeId, options) => new GMath          (nodeId, options));
    else if (parse.next == NUMBER_SIMPLE_MATH     ) result = genParseSimpleMath        (parse, (nodeId, options) => new GMath          (nodeId, options));
    else if (parse.next == NUMBER_ADD             ) result = genParseArithmetic        (parse, (nodeId, options) => new GAdd           (nodeId, options));
    else if (parse.next == NUMBER_SUBTRACT        ) result = genParseArithmetic        (parse, (nodeId, options) => new GSubtract      (nodeId, options));
    else if (parse.next == NUMBER_MULTIPLY        ) result = genParseArithmetic        (parse, (nodeId, options) => new GMultiply      (nodeId, options));
    else if (parse.next == NUMBER_DIVIDE          ) result = genParseArithmetic        (parse, (nodeId, options) => new GDivide        (nodeId, options));
    else if (parse.next == NUMBER_MODULO          ) result = genParseArithmetic        (parse, (nodeId, options) => new GModulo        (nodeId, options));
    else if (parse.next == NUMBER_EXPONENT        ) result = genParseArithmetic        (parse, (nodeId, options) => new GExponent      (nodeId, options));
     
    else if (parse.next == NUMBER_BOOLEAN         ) result = genParseBoolean           (parse);
    else if (parse.next == NUMBER_NOT             ) result = genParseArithmetic        (parse, (nodeId, options) => new GNot           (nodeId, options));
    else if (parse.next == NUMBER_AND             ) result = genParseArithmetic        (parse, (nodeId, options) => new GAnd           (nodeId, options));
    else if (parse.next == NUMBER_OR              ) result = genParseArithmetic        (parse, (nodeId, options) => new GOr            (nodeId, options));
    else if (parse.next == NUMBER_XOR             ) result = genParseArithmetic        (parse, (nodeId, options) => new GXor           (nodeId, options));
     
    else if (parse.next == NUMBER_CONDITION       ) result = genParseCondition         (parse);
    else if (parse.next == NUMBER_EQUAL           ) result = genParseConditionBase     (parse, (nodeId, options) => new GEqual         (nodeId, options));
    else if (parse.next == NUMBER_NOT_EQUAL       ) result = genParseConditionBase     (parse, (nodeId, options) => new GNotEqual      (nodeId, options));
    else if (parse.next == NUMBER_LESS            ) result = genParseConditionBase     (parse, (nodeId, options) => new GLess          (nodeId, options));
    else if (parse.next == NUMBER_LESS_OR_EQUAL   ) result = genParseConditionBase     (parse, (nodeId, options) => new GLessOrEqual   (nodeId, options));
    else if (parse.next == NUMBER_GREATER         ) result = genParseConditionBase     (parse, (nodeId, options) => new GGreater       (nodeId, options));
    else if (parse.next == NUMBER_GREATER_OR_EQUAL) result = genParseConditionBase     (parse, (nodeId, options) => new GGreaterOrEqual(nodeId, options));
 
    else if (parse.next == NUMBER_TRIG            ) result = genParseTrigonometric     (parse);
    else if (parse.next == NUMBER_SIN             ) result = genParseTrigBase          (parse, (nodeId, options) => new GSine          (nodeId, options));
    else if (parse.next == NUMBER_COS             ) result = genParseTrigBase          (parse, (nodeId, options) => new GCosine        (nodeId, options));
    else if (parse.next == NUMBER_TAN             ) result = genParseTrigBase          (parse, (nodeId, options) => new GTangent       (nodeId, options));
    else if (parse.next == NUMBER_ATAN2           ) result = genParseAtan2             (parse, (nodeId, options) => new GTangent       (nodeId, options));

    else if (parse.next == CONVERT_ANGLE          ) result = genParseConvertAngle      (parse);
 
    else if (parse.next == TEXT_VALUE             ) result = genParseTextValue         (parse);
    else if (parse.next == TEXT                   ) result = genParseText              (parse);
    else if (parse.next == TEXT_LENGTH            ) result = genParseTextLength        (parse);
    else if (parse.next == TEXT_TRIM              ) result = genParseTextTrim          (parse);
    else if (parse.next == TEXT_SUBSTRING         ) result = genParseTextSubstring     (parse);
    else if (parse.next == TEXT_CONTAINS          ) result = genParseTextContains      (parse);
    else if (parse.next == TEXT_FIND              ) result = genParseTextFind          (parse);
    else if (parse.next == TEXT_CASE              ) result = genParseTextCase          (parse);
    else if (parse.next == TEXT_CHAR              ) result = genParseCodeToCharacter   (parse);
    else if (parse.next == TEXT_UNICODE           ) result = genParseCharacterToCode   (parse);
    else if (parse.next == INDEX_TO_NAME          ) result = genParseIndexToName       (parse);
    else if (parse.next == NUMBER_TO_TEXT         ) result = genParseNumberToText      (parse);
    else if (parse.next == COLOR_TO_TEXT          ) result = genParseColorToText       (parse);
    else if (parse.next == TEXT_TO_NUMBER         ) result = genParseTextToNumber      (parse);
    else if (parse.next == TEXT_TO_COLOR          ) result = genParseTextToColor       (parse);
    else if (parse.next == TEXT_REPLACE           ) result = genParseTextReplace       (parse);
    else if (parse.next == TEXT_ADD               ) result = genParseAddText           (parse);
    else if (parse.next == TEXT_JOIN              ) result = genParseTextJoin          (parse);
    else if (parse.next == TEXT_PAD               ) result = genParseTextPad           (parse);
    else if (parse.next == TEXT_COMPARE           ) result = genParseTextCompare       (parse);
    else if (parse.next == TEXT_SPLIT             ) result = genParseTextSplit         (parse);
    else if (parse.next == PARSE_CSV              ) result = genParseParseCSV           (parse);
    else if (parse.next == PARSE_JSON             ) result = genParseParseJson          (parse);
    else if (parse.next == TEXT_FETCH             ) result = genParseTextFetch         (parse);
    else if (parse.next == TEXT_FILE              ) result = genParseTextFile          (parse);
 
    else if (parse.next == COLOR_VALUE            ) result = genParseColorValue        (parse);
    else if (parse.next == COLOR                  ) result = genParseColor             (parse);
    else if (parse.next == VALID_COLOR            ) result = genParseValidColor        (parse);
    else if (parse.next == CORRECT_COLOR          ) result = genParseCorrectColor      (parse);
    else if (parse.next == COLOR_CONTRAST         ) result = genParseColorContrast     (parse);
    else if (parse.next == COLOR_CONVERT_P3       ) result = genParseColorConvertP3    (parse);
    else if (parse.next == COLORBLIND             ) result = genParseColorBlind        (parse);
    else if (parse.next == COLOR_SCHEME           ) result = genParseColorScheme       (parse);
    else if (parse.next == COLOR_INTERPOLATE      ) result = genParseColorInterpolate  (parse);
    else if (parse.next == COLOR_BLEND            ) result = genParseColorBlend        (parse);
      
    else if (parse.next == FILL_VALUE             ) result = genParseFillValue         (parse);
    else if (parse.next == FILL                   ) result = genParseFill              (parse);
      
    else if (parse.next == COLOR_STOP_VALUE       ) result = genParseColorStopValue    (parse);
    else if (parse.next == COLOR_STOP             ) result = genParseColorStop         (parse);
      
    else if (parse.next == GRADIENT_VALUE         ) result = genParseGradientValue     (parse);
    else if (parse.next == GRADIENT               ) result = genParseGradient          (parse);
      
    else if (parse.next == STROKE_VALUE           ) result = genParseStrokeValue       (parse);
    else if (parse.next == STROKE                 ) result = genParseStroke            (parse);
      
    else if (parse.next == STROKE_SIDES_VALUE     ) result = genParseStrokeSidesValue  (parse);
    else if (parse.next == STROKE_SIDES           ) result = genParseStrokeSides       (parse);
      
    else if (parse.next == ROUND_CORNERS_VALUE    ) result = genParseRoundCornersValue (parse);
    else if (parse.next == ROUND_CORNERS          ) result = genParseRoundCorners      (parse);
      
    else if (parse.next == DROP_SHADOW_VALUE      ) result = genParseDropShadowValue   (parse);
    else if (parse.next == DROP_SHADOW            ) result = genParseDropShadow        (parse);
      
    else if (parse.next == INNER_SHADOW_VALUE     ) result = genParseInnerShadowValue  (parse);
    else if (parse.next == INNER_SHADOW           ) result = genParseInnerShadow       (parse);
      
    else if (parse.next == LAYER_BLUR_VALUE       ) result = genParseLayerBlurValue    (parse);
    else if (parse.next == LAYER_BLUR             ) result = genParseLayerBlur         (parse);
      
    else if (parse.next == BACK_BLUR_VALUE        ) result = genParseBackBlurValue     (parse);
    else if (parse.next == BACK_BLUR              ) result = genParseBackBlur          (parse);

    else if (parse.next == LAYER_BLEND_VALUE      ) result = genParseLayerBlendValue   (parse);
    else if (parse.next == LAYER_BLEND            ) result = genParseLayerBlend        (parse);
      
    else if (parse.next == LAYER_MASK_VALUE       ) result = genParseLayerMaskValue    (parse);
    else if (parse.next == LAYER_MASK             ) result = genParseLayerMask         (parse);
      
    else if (parse.next == COLOR_STYLE            ) result = genParseColorStyle        (parse);
      
    else if (parse.next == RECTANGLE              ) result = genParseRectangle         (parse);
    //else if (parse.next == RECTANGLE_EXT          ) result = genParseRectangleExt      (parse);
    else if (parse.next == LINE                   ) result = genParseLine              (parse);
    else if (parse.next == ELLIPSE                ) result = genParseEllipse           (parse);
    else if (parse.next == TRAPEZE                ) result = genParseTrapeze           (parse);
    else if (parse.next == POLYGON                ) result = genParsePolygon           (parse);
    else if (parse.next == STAR                   ) result = genParseStar              (parse);
    else if (parse.next == TEXT_SHAPE             ) result = genParseTextShape         (parse);
 
    else if (parse.next == POINT_VALUE            ) result = genParsePointValue        (parse);
    else if (parse.next == POINT                  ) result = genParsePoint             (parse);
    else if (parse.next == POINT_CORNER           ) result = genParsePointCorner       (parse);
    else if (parse.next == VECTOR_PATH_VALUE      ) result = genParseVectorPathValue   (parse);
    else if (parse.next == VECTOR_PATH            ) result = genParseVectorPath        (parse);
    
    else if (parse.next == VECTOR_VERTEX_VALUE    ) result = genParseVectorVertexValue (parse);
    else if (parse.next == VECTOR_VERTEX          ) result = genParseVectorVertex      (parse);
    else if (parse.next == VECTOR_EDGE_VALUE      ) result = genParseVectorEdgeValue   (parse);
    else if (parse.next == VECTOR_EDGE            ) result = genParseVectorEdge        (parse);
    else if (parse.next == VECTOR_REGION_VALUE    ) result = genParseVectorRegionValue (parse);
    else if (parse.next == VECTOR_REGION          ) result = genParseVectorRegion      (parse);
    else if (parse.next == VECTOR_NETWORK_VALUE   ) result = genParseVectorNetworkValue(parse);
    else if (parse.next == VECTOR_NETWORK         ) result = genParseVectorNetwork     (parse);

    else if (parse.next == SHAPE_BOOLEAN_VALUE    ) result = genParseShapeBooleanValue (parse);
    else if (parse.next == SHAPE_BOOLEAN          ) result = genParseShapeBoolean      (parse);

    else if (parse.next == ARC_PATH_VALUE         ) result = genParseArcPathValue      (parse);
    else if (parse.next == ARC_PATH               ) result = genParseArcPath           (parse);

    else if (parse.next == WAVE_PATH_VALUE        ) result = genParseWavePathValue     (parse);
    else if (parse.next == WAVE_PATH              ) result = genParseWavePath          (parse);

    else if (parse.next == SHAPE_GROUP_VALUE      ) result = genParseShapeGroupValue   (parse);
    else if (parse.next == SHAPE_GROUP            ) result = genParseShapeGroup        (parse);
 
    else if (parse.next == FRAME_VALUE            ) result = genParseFrameValue        (parse);
    else if (parse.next == FRAME                  ) result = genParseFrame             (parse);
 
    else if (parse.next == MOVE                   ) result = genParseMove              (parse);
    else if (parse.next == ROTATE                 ) result = genParseRotate            (parse);
    else if (parse.next == SCALE                  ) result = genParseScale             (parse);
    else if (parse.next == SKEW                   ) result = genParseSkew              (parse);

    else if (parse.next == SHOW_CENTER            ) result = genParseShowCenter        (parse);
    else if (parse.next == SET_CENTER             ) result = genParseCenter            (parse);
    else if (parse.next == RESET_XFORM            ) result = genParseResetTransform    (parse);

    else if (parse.next == PATH_LENGTH            ) result = genParsePathLength        (parse);
    else if (parse.next == JOIN_PATHS             ) result = genParseJoinPaths         (parse);
    else if (parse.next == REORIENT_PATHS         ) result = genParseReorientPaths     (parse);
    else if (parse.next == MEASURE_VECTOR         ) result = genParseMeasureVector     (parse);
    else if (parse.next == POINT_ANGLE            ) result = genParsePointAngle        (parse);
    else if (parse.next == VECTOR                 ) result = genParseVector            (parse);
    else if (parse.next == CIRCLE_CENTER          ) result = genParseCircleCenter      (parse);
    else if (parse.next == ARC_FROM_POINTS        ) result = genParseArcFromPoints     (parse);
    else if (parse.next == INTERSECT_LINES        ) result = genParseIntersectLines    (parse);
    else if (parse.next == INTERPOLATE_POINT      ) result = genParseInterpolatePoint  (parse);
    else if (parse.next == POINT_ALONG_PATH       ) result = genParsePointAlongPath    (parse);
    else if (parse.next == CLOSEST_POINT_ON_PATH  ) result = genParseClosestPointOnPath(parse);
    else if (parse.next == REVERSE_PATH           ) result = genParseReversePath       (parse);
    else if (parse.next == BLEND_PATH             ) result = genParseBlendPath         (parse);

    else if (parse.next == PLACE                  ) result = genParsePlace             (parse);
    else if (parse.next == SHAPE_APPLY            ) result = genParseShapeApply        (parse);
    
    else if (parse.next == PERSIST                 ) result = genParsePersist            (parse);
    else if (parse.next == EXPORT                 ) result = genParseExport            (parse);
 
    else if (parse.next == GROUP_NODE             ) result = genParseGroupNode         (parse);
    else if (parse.next == GROUP_PARAM            ) result = genParseGroupParam        (parse);
 
    else if (parse.next == COMMENT                ) result = genParseComment           (parse);
    else if (parse.next == COMMENT_ARROW          ) result = genParseCommentArrow      (parse);
    else if (parse.next == PANEL                  ) result = genParsePanel             (parse);

    else consoleError('unknown parse token \'' + parse.next + '\' @ ' + parse.pos);


    parse.inParam = false;


    if (result)
        return result;
    else
    {
        parse.so++;
        return null;
    }
}



function genParseNodeStart(parse)
{
    const type     = parse.move();
    const nodeId   = parse.move();
    const nodeName = parse.move();

    
    parse.scope.push(nodeId);


    if (parse.parsedNodes.find(n => n.nodeId == nodeId))
        return [type, nodeId, {nodeName: nodeName}, true];


    const options = genParseNodeOptions(parse);

    options.nodeName = nodeName;


    return [type, nodeId, options, false];
}



function genParseNodeEnd(parse, node = null)
{
    parse.scope.pop();

    if (node)
    {
        if (isEmpty(parse.scope))
            node.topLevel = true;

        pushUnique(parse.parsedNodes, node);
    }
}



function genParseNodeOptions(parse)
{
    const opt = parseInt(parse.move());

    const options = 
    {
        active:       ((opt >>  0) & 1) != 0,
        beforeActive: ((opt >>  1) & 1) != 0,
        beforeList:   ((opt >>  2) & 1) != 0,
        enabled:      ((opt >>  3) & 1) != 0,
        cached:       ((opt >>  4) & 1) != 0,
        unknown:      ((opt >>  5) & 1) != 0,
        notCondition: ((opt >>  6) & 1) != 0,
        hasInputs:    ((opt >> 20) & 1) != 0,
        existing:     ((opt >> 21) & 1) != 0
    };

    return options;
}



function genParseParamCount(parse)
{
    const nParamIds = parseInt(parse.move());

    if (parse.settings.logRequests) 
        parse.log += parse.tab + nParamIds;

    return nParamIds;
}



function genParseParam(parse)
{
    if (parse.next != PARAM) 
        return null;
        
    parse.move(); // PARAM
    const type = parse.move(); // type

    
    const nodeId  = parse.move();
    const paramId = parse.move();
    
    const param   = new GParam(nodeId, paramId);
 

    pushUnique(parse.paramNodeIds, nodeId);


    if (parse.settings.logRequests) 
        logReqParam(param, type, parse);


    return param;
}



function genParseParamId(parse)
{
    const paramId = parse.move();

    if (parse.settings.logRequests)
        parse.log += parse.tab + paramId;

    return paramId;
}


class RequestSettings
{
    request;
    pos;

    so            = 0;
    nTab          = 0;
  
    skipNewLine   = false;

    loggedNodeIds = [];
    


    constructor(request, pos)
    {
        this.request = request;
        this.pos     = pos;
    }


    get tab() 
    { 
        if (this.skipNewLine)
        {
            this.skipNewLine = false;
            return '';
        }
        else 
            return NL + HTAB.repeat(Math.max(0, this.nTab)); 
    }
}



function log(str)
{
    debugInfo.innerHTML = str;
}



function logFunction(funcName, obj = null)
{
    let str = funcName;

    if (obj)
        str = obj.id + '.' + str;

    console.log(
        '%c ' + str + ' ', 
        'background: #fc0; color: #632;');
}



function logString(str, color = 'white', background = 'red')
{
    console.log(
        '%c ' + str + ' ', 
        'background: ' + background + '; color: ' + color + ';');
}



function logValueUpdates(updateNodeId, updateParamId, values)
{
    //console.log('values = ', values);

    let log     = '';
    let newLine = true;

    if (   updateNodeId  != '' 
        || updateParamId != '')
        log = '↓ ' + logReqId(updateNodeId) + '.' + logReqId(updateParamId);
    else
        newLine = false;

          
    let i    = 0;
    let nTab = 0;

    while (i < values.length)
    {
        const nodeId  = values[i++];
        const nInputs = parseInt(values[i++]);

        log += 
              (newLine ? NL : '') + HTAB.repeat(Math.max(0, nTab))
            + nodeId;// + ' ' + nInputs;

        newLine = true;

        nTab++;

        for (let j = 0; j < nInputs; j++)
        {
            const index = values[i++];
            const type  = values[i++];
            const value = values[i++];

            log += 
                  NL + HTAB.repeat(Math.max(0, nTab))
                + index + ' ' + displayValue(type, value);
        }

        nTab--;
    }


    console.log(
        '%c%s', 
        'background: #e70; color: white;', 
        log);
}



function logObjectUpdates(objects)
{
    console.log(
        '%cobjects', 
        'background: #07e; color: white;', 
        objects);
}



function logStyleUpdates(styles)
{
    console.log(
        '%cstyles', 
        'background: #b4d; color: white;', 
        styles);
}



function logSavePages(pageJson)
{
    console.log('%cSAVING PAGES\n' + pageJson, 'color: black; background: #ddeeee;');
}



function logSaveNodes(nodeJson)
{
    console.log('%cSAVING NODES\n' + nodeJson, 'color: black; background: #ddeeff;');
}



function logSaveConnections(conns)
{
    let log = 'SAVING ' + conns.length + ' ' + countString(conns.length, 'CONNECTION');

    for (const conn of conns)
        log += '\n' + conn.toJson();

    console.log(
        '%c' + log, 
        'color: black; background: #ddeeff;');
}



function logUpdateSavedConnections(conns)
{
    let log = 'UPDATING ' + conns.length + ' ' + countString(conns.length, 'SAVED CONNECTION');

    for (const conn of conns)
        log += '\n' + conn.toJson();

    console.log(
        '%c' + log, 
        'color: black; background: #ddeeff;');
}



function logUndoStack()
{
    let log = 
        'UNDO STACK:\n'
        + actionManager.actions.map(a => '    ' + a.name).join('\n');

    console.log(
        '%c%s', 
        'background: #ffd; color: #b80;', 
        log);
}



function logRedoStack()
{
    let log = 
         'REDO STACK:\n'
        + actionManager.redoActions.map(a => '    ' + a.name).join('\n');

    console.log(
        '%c%s', 
        'background: #fff4e8; color: #c64;', 
        log);
}



function logInsertSeparator()
{
    console.log(
        '%c%s', 
        'background: #f44; color: #fff;', 
        Math.random() + '--------------------');
}



// function clog(...args)
// {
//     setTimeout(console.log.bind(console, ...args));
// }


function logRequest(parse)
{
    let log = '';

    if (   parse.updateNodeId  != '' 
        || parse.updateParamId != '')
        log = '↓ ' + logReqId(parse.updateNodeId) + '.' + logReqId(parse.updateParamId);

    log += parse.log;

    console.log(
        '%c%s', 
        'background: #60aa60; color: #fff', 
         log);
}



function logReq(node, parse, ignore, nInputs = -1)
{
    parse.log += parse.tab + node.type;
    parse.log += logReqNodeId(node, ignore);

    if (    nInputs > -1
        && !ignore)
        parse.log += ' ' + nInputs;
}



function logReqNodeId(node, ignore = false)
{
    return ' ' 
         + logReqId(node.nodeId) 
         + ' ' + logReqId(node.nodeName)
         + (!ignore
            ? logReqOptions(node)
            : '');
}



function logReqId(nodeId)
{
    return nodeId == '' ? '\'\'' : nodeId;
}



function logReqOptions(node)
{
    let log = '';

    if ( node.options.active      ) log += ' ' + ACTIVE;
    if ( node.options.beforeActive) log += ' ' + BEFORE_ACTIVE;
    if ( node.options.beforeList  ) log += ' ' + BEFORE_LIST;
    if (!node.options.enabled     ) log += ' ' + DISABLED;

    if (!node.cached              ) log += ' ' + NOCACHE;

    return log;
}



function logReqParam(param, type, parse)
{
    parse.log += 
                parse.tab + PARAM
        + ' ' + type 
        + ' ' + logReqId(param.nodeId) 
        + '.' + logReqId(param.paramId);
}



function logReqNode(node, parse)
{
    parse.log += parse.tab + node.type;
    parse.log += logReqNodeId(node);
}



function logReqColorContrast(lerp, nInputs, valueIndex, parse, ignore)
{
    parse.log += parse.tab + COLOR_CONTRAST;
    parse.log += logReqNodeId(lerp, ignore);

    if (!ignore)
    {
        parse.log += ' ' + nInputs;

        if (nInputs == 1)
            parse.log += ' ' + valueIndex;
    }
}



function logReqValue(type, val, parse)
{
    parse.log += parse.tab + type + ' ' + displayValue(type, val);
}



function logReqString(str, parse)
{
    parse.log += parse.tab + str;
}



// function logReqListValue(list, parse, ignore)
// {
//     parse.log += parse.tab + LIST_VALUE + ' ' + displayValue(LIST_VALUE, list);
// }



// function logReqColorValue(val, parse, ignore)
// {
//     parse.log += parse.tab + COLOR_VALUE + ' ' + displayValue(COLOR_VALUE, val);
// }



// function logReqNumberValue(val, parse, ignore)
// {
//     parse.log += parse.tab + NUMBER_VALUE + ' ' + displayValue(NUMBER_VALUE, val);
// }



// function logReqFillValue(fill, parse, ignore)
// {
//     parse.log += parse.tab + FILL_VALUE + ' ' + displayValue(FILL_VALUE, fill);
// }



// function logReqStrokeValue(stroke, parse, ignore)
// {
//     // parse.log += parse.tab + STROKE_VALUE + ' ' + displayValue(STROKE_VALUE, stroke);
// }



// function logReqColorStopValue(stop, parse, ignore)
// {
//     // parse.log += parse.tab + COLOR_STOP_VALUE + ' ' + displayValue(COLOR_STOP_VALUE, stop);
// }



async function logSavedNode(nodeKey, darkMode)
{
    const log  = formatSavedNodeJson(await figGetPageData(nodeKey, false));

    if (darkMode)
    {
        console.log(
            '%c%s\n%c%s', 
            'background: #fa24; color: white;', 
            noNodeTag(nodeKey), 
            'background: #fa44; color: #edc;',
            log);
    }
    else
    {
        console.log(
            '%c%s\n%c%s', 
            'background: #fdb; color: black;', 
            noNodeTag(nodeKey), 
            'background: #fed; color: black;',
            log);
    }
}



function formatSavedNodeJson(json)
{
    let formJson = json
        .replace('{\n', '')
        .replace('\n}', '')

        .replace('[\n' + HTAB, '')
        .replace('\n' + HTAB + ']', '')

        .split(HTAB + '"params":\n').join('') // have to do .split().join() because there's no .replace() in TS

        .split('": "').join(': ')
        .split('", "').join(': ')

        .split(HTAB + '"').join(HTAB)
        .split(HTAB + HTAB + '["').join(HTAB + HTAB)
        
        .split('",\n').join('\n')
        .split('"\n').join('\n')
        
        .split('"],\n').join('\n');


    if (formJson[formJson.length-1] == '"')
        formJson = formJson.substring(0, formJson.length - 1);

    if (formJson.substring(formJson.length-2) == '"]')    
        formJson = formJson.substring(0, formJson.length - 2);

    return formJson;
}



function formatSavedDataJson(json)
{
    let formJson = json
        .replace('{\n', '')
        .replace('\n}', '')
        .replace('[\n' + HTAB, '')
        .replace('\n' + HTAB + ']', '');

    return formJson;
}



function logSavedConn(conn, darkMode)
{
    const strConn = connToString(conn, true);

    if (darkMode)
    {
        console.log(
            '%c%s', 
            'background: #4f44; color: #ded', 
            strConn); 
    }
    else
    {
        console.log(
            '%c%s', 
            'background: #cfc; color: black;', 
            strConn); 
    }
}


// Observer = 2°

const D50 = [0.96422, 1, 0.82521];
const D65 = [0.95047, 1, 1.08883]; 


function createColorSpace(R, G, B, Y, W, gamma, degamma, regamma, luminance)
{
    return {    
        R:         R,
        G:         G,
        B:         B,

        Y:         Y,

        W:         W,

        lin2xyz:   rgbMatrix(R, G, B, W),
        xyz2lin:   inversem3(rgbMatrix(R, G, B, W)),

        gamma:     gamma,
        
        degamma:   degamma,
        regamma:   regamma,
        
        luminance: luminance
    };
}


function rgbMatrix(R, G, B, W)
{
    const C0 = colorVector(R);
    const C1 = colorVector(G);
    const C2 = colorVector(B);

    const M = [ [ C0[0], C1[0], C2[0] ], 
                [ C0[1], C1[1], C2[1] ], 
                [ C0[2], C1[2], C2[2] ] ];

    const S = mulv3m3(W, inversem3(M));

    return [ [ S[0]*C0[0], S[1]*C1[0], S[2]*C2[0] ],
             [ S[0]*C0[1], S[1]*C1[1], S[2]*C2[1] ],
             [ S[0]*C0[2], S[1]*C1[2], S[2]*C2[2] ] ];
}


function colorVector(c)
{
    const x = c[0],
          y = c[1];

    return [x/y, 1, (1-x-y)/y];
}



const sRGB = createColorSpace
(
    [0.64, 0.33], // R
    [0.3,  0.6 ], // G
    [0.15, 0.06], // B

    [0.212656,
     0.715158,
     0.072186], // Y

    D65,        // W

    2.4,        // gamma


    function(v) // degamma
    {
        return v >= 0.04045
               ? Math.pow((v + 0.055) / 1.055, this.gamma)
               : v / 12.92;
    },
    

    function(v) // regamma
    {
        return v > 0.0031308
               ? 1.055 * Math.pow(v, 1/this.gamma) - 0.055
               : v * 12.92;
    },
    
    
    function(rgb) // luminance
    {
        return  this.Y[0] * this.degamma(rgb[0]) 
              + this.Y[1] * this.degamma(rgb[1]) 
              + this.Y[2] * this.degamma(rgb[2]);
    }
);

const sRGB_D65 = sRGB;


const sRGB_D50 = createColorSpace
(
    [0.64, 0.33], // R
    [0.3,  0.6 ], // G
    [0.15, 0.06], // B

    [0.34567, 
     0.35850, 
     0.29583],  // Y

    D50,        // W

    2.4,        // gamma


    function(v) // degamma
    {
        return v >= 0.04045
               ? Math.pow((v + 0.055) / 1.055, this.gamma)
               : v / 12.92;
    },
    

    function(v) // regamma
    {
        return v > 0.0031308
               ? 1.055 * Math.pow(v, 1/this.gamma) - 0.055
               : v * 12.92;
    },
    
    
    function(rgb) // luminance
    {
        return  this.Y[0] * this.degamma(rgb[0]) 
              + this.Y[1] * this.degamma(rgb[1]) 
              + this.Y[2] * this.degamma(rgb[2]);
    }
);



const Adobe98 = createColorSpace
(
    [0.64, 0.33], // R
    [0.21, 0.71], // G
    [0.15, 0.06], // B

    [0.297361,
     0.627355,
     0.075284], // Y

    D65,        // W

    563/256,    // gamma 


    function(v) // degamma
    {
        return v >= 0.04045
               ? Math.pow((v + 0.055) / 1.055, this.gamma)
               : v / 12.92;
    },


    function(v) // regamma
    {
        return v > 0.0031308
               ? 1.055 * Math.pow(v, 1/this.gamma) - 0.055
               : v * 12.92;
    },


    function(rgb) // luminance
    {
        return  this.Y[0] * this.degamma(rgb[0]) 
              + this.Y[1] * this.degamma(rgb[1]) 
              + this.Y[2] * this.degamma(rgb[2]);
    }
);



function rgb2a98(rgb)
{
    return xyz2rgb(rgb2xyz(rgb), Adobe98);
}



function a982rgb(a98)
{
    return xyz2rgb(rgb2xyz(a98, Adobe98));
}


const ProPhotoRGB = createColorSpace
(
    [0.7347, 0.2653], // R
    [0.1596, 0.8404], // G
    [0.0366, 0.0001], // B

    [0.2880402,
     0.7118741,
     0.0000857], // Y

    D50,         // W

    1.8,         // gamma 


    function(v) // degamma
    {
        return v >= 0.03125
               ? Math.pow(v, this.gamma)
               : v / 16;
    },


    function(v) // regamma
    {
        return v > Math.pow(16 * 0.03125, this.gamma - 1)
               ? Math.pow(v, 1/this.gamma)
               : v * 16;
    },


    function(rgb) // luminance
    {
        return  this.Y[0] * this.degamma(rgb[0]) 
              + this.Y[1] * this.degamma(rgb[1]) 
              + this.Y[2] * this.degamma(rgb[2]);
    }
);



function rgb2pro(rgb)
{
    return xyz2rgb(rgb2xyz(rgb), ProPhotoRGB);
}



function pro2rgb(pro)
{
    return xyz2rgb(rgb2xyz(pro, ProPhotoRGB));
}


const Rec2020 = createColorSpace
(
    [0.708, 0.292], // R
    [0.170, 0.797], // G
    [0.131, 0.046], // B

    [0.2627,
     0.6780,
     0.0593],  // Y

    D65,       // W

    2.4,       // gamma 


    function(v) // degamma
    {
        // Rec. 2020 uses a simple power function with a gamma of 2.4.
        return Math.pow(v, this.gamma);
    },


    function(v) // regamma
    {
        // The inverse of the degamma function
        return Math.pow(v, 1 / this.gamma);
    },

    
    function(rgb) // luminance
    {
        return this.Y[0] * this.degamma(rgb[0]) 
             + this.Y[1] * this.degamma(rgb[1]) 
             + this.Y[2] * this.degamma(rgb[2]);
    }
);



function rgb2r2020(rgb)
{
    return xyz2rgb(rgb2xyz(rgb), Rec2020);
}



function r20202rgb(r2020)
{
    return xyz2rgb(rgb2xyz(r2020, Rec2020));
}


function rgbLightenHsv(rgb, amount)
{
    const hsv = rgb2hsv(rgb);
    hsv[2] *= amount;
    return hsv2rgb(hsv);
}



function rgbSaturateHsv(rgb, amount)
{
    const hsv = rgb2hsv(rgb);
    hsv[1] *= amount;
    return hsv2rgb(hsv);
}



function rgbSaturateHsl(rgb, amount)
{
    const hsl = rgb2hsl(rgb);
    hsl[1] *= amount;
    return hsl2rgb(hsl);
}



function lin2rgb_(r, g, b)
{
    return [
        sRGB.degamma(r), 
        sRGB.degamma(g), 
        sRGB.degamma(b)];
}



function lin2rgb(rgb)
{
    return lin2rgb_(rgb[0], rgb[1], rgb[2]);
}



function rgb2lin_(r, g, b)
{
    return [
        sRGB.regamma(r), 
        sRGB.regamma(g), 
        sRGB.regamma(b)];
}



function rgb2lin(rgb)
{
    return rgb2lin_(rgb[0], rgb[1], rgb[2]);
}



function rgb2p3(rgb)
{
    const p3 = 
        [ [ 0.8225, 0.1774, 0      ],
          [ 0.0332, 0.9669, 0      ],
          [ 0.0171, 0.0724, 0.9108 ] ];

    rgb = degamma(rgb);

    return regamma(dot3(p3, rgb));
}



function p32rgb(rgb) 
{
    const invp3 = 
        [ [ 1.2249, -0.2247, 0      ],
          [-0.0420,  1.0419, 0      ],
          [-0.0197, -0.0786, 1.0979 ] ];
  
    rgb = dot3(invp3, degamma(rgb));
  
    return regamma(rgb);
}


function rgb2hsv_(r, g, b)
{
    let h, s, v;

    let min = Math.min(Math.min(r, g), b),
        max = Math.max(Math.max(r, g), b);

    let delta = max - min;

    v = max;
    s = max == 0 ? 0 : delta / max;
	
    if      (max == r) h = 1/6 * (g - b) / delta + 1;   // between yellow and magenta
    else if (max == g) h = 1/6 * (b - r) / delta + 1/3; // between cyan and yellow
    else if (max == b) h = 1/6 * (r - g) / delta + 2/3; // between between magenta and cyan

	if (h > 1) h -= 1;
	//if (h < 0) h += 1;

    return [h, s, v];
}



function rgb2hsv(rgb)
{
    return rgb2hsv_(rgb[0], rgb[1], rgb[2]);
}



function hsv2rgb_(h, s, v)
{
    while (h < 0) h++;
    h %= 1;

    if (s == 0)
        return [v, v, v]; // achromatic

    h *= 6 - 0.0000001;

    let i = Math.floor(h);
    let f = h - i;
	
    let p = v * (1 - s);
    let q = v * (1 - s * f);
    let t = v * (1 - s * (1 - f));

    switch (i)
    {
        case 0:  return [v, t, p];
        case 1:  return [q, v, p];
        case 2:  return [p, v, t];
        case 3:  return [p, q, v];
        case 4:  return [t, p, v];
        default: return [v, p, q];
    }
}



function hsv2rgb(hsv)
{
	return hsv2rgb_(hsv[0], hsv[1], hsv[2]);
}


function rgb2hsl_(r, g, b)
{
    let h, s, l;

    let min = Math.min(Math.min(r, g), b),
        max = Math.max(Math.max(r, g), b);

    let delta = max - min;

    l = (max + min) / 2;

         if (max == min) h = 0;
    else if (max == r  ) h = 1/6 * (g - b) / delta + 1;
    else if (max == g  ) h = 1/6 * (b - r) / delta + 1/3;
    else if (max == b  ) h = 1/6 * (r - g) / delta + 2/3;

         if (max == min) s = 0;
    else if (l <= 0.5)   s = delta / (2 * l);
    else if (l >  0.5)   s = delta / (2 - 2 * l);

    return [h, s, l];
}



function rgb2hsl(rgb)
{
    return rgb2hsl_(rgb[0], rgb[1], rgb[2]);
}



function hsl2rgb_(h, s, l)
{
    while (h < 0) h++;
    h %= 1;

    let q =
        l < 0.5
        ? l * (1 + s)
        : l + s - l * s;

    let p = 2 * l - q;

    let tr = h + 1/3;
    let tg = h;
    let tb = h - 1/3;

    if (tr < 0) tr += 1; if (tr > 1) tr -= 1;
    if (tg < 0) tg += 1; if (tg > 1) tg -= 1;
    if (tb < 0) tb += 1; if (tb > 1) tb -= 1;

    let r, g, b;

    let qp6 = (q - p) * 6; 

         if (tr <  1/6)				r = p + qp6 * tr;
    else if (tr >= 1/6 && tr < 0.5)	r = q;
    else if (tr >= 0.5 && tr < 2/3)	r = p + qp6 * (2/3 - tr);
    else							r = p;
	
         if (tg <  1/6)				g = p + qp6 * tg;
    else if (tg >= 1/6 && tg < 0.5)	g = q;
    else if (tg >= 0.5 && tg < 2/3) g = p + qp6 * (2/3 - tg);
    else							g = p;

         if (tb <  1/6)				b = p + qp6 * tb;
    else if (tb >= 1/6 && tb < 0.5) b = q;
    else if (tb >= 0.5 && tb < 2/3) b = p + qp6 * (2/3 - tb);
    else							b = p;

    return [r, g, b];
}



function hsl2rgb(hsl)
{
    return hsl2rgb_(hsl[0], hsl[1], hsl[2]);
}


function xyz2lms(xyz)
{
    return mulv3m3(xyz, CAT);//HPE);
}



function lms2xyz(lms)
{
    return mulv3m3(lms, invCAT);//invHPE);
}



function rgb2oklms_(r, g, b, cs = sRGB) 
{
    r = cs.degamma(r);
    g = cs.degamma(g);
    b = cs.degamma(b);

    return [
        0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b,
	    0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b,
	    0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b ];
}        



function oklms2rgb(lms, cs = sRGB) 
{
    const l = cube(lms[0]);
    const m = cube(lms[1]);
    const s = cube(lms[2]);

	const r =  4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s;
	const g = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s;
	const b = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s;

    return [
        cs.regamma(r),
        cs.regamma(g),
        cs.regamma(b) ];
}



function oklms2oklab(lms) 
{
    const l = Math.cbrt(lms[0]);
    const m = Math.cbrt(lms[1]);
    const s = Math.cbrt(lms[2]);

    const l_ = 0.2104542553 * l + 0.7936177850 * m - 0.0040720468 * s;
    const a_ = 1.9779984951 * l - 2.4285922050 * m + 0.4505937099 * s;
    const b_ = 0.0259040371 * l + 0.7827717662 * m - 0.8086757660 * s;

    return [
        l_,
        a_, 
        b_ ];
}



function oklab2oklms(lab)
{
    return oklab2oklms_(lab[0], lab[1], lab[2]);
}



function oklab2oklms_(l, a, b) 
{
    return [
        l + 0.3963377774 * a + 0.2158037573 * b,
        l - 0.1055613458 * a - 0.0638541728 * b,
        l - 0.0894841775 * a - 1.2914855480 * b ];
}


function rgb2xyz(rgb, cs = sRGB)
{ 
    return lin2xyz(degamma(rgb, cs), cs);
}    



function lin2xyz(rgb, cs = sRGB)
{
    return mulv3m3(rgb, cs.lin2xyz);
}        



function xyz2rgb(xyz, cs = sRGB)
{
    return regamma(xyz2lin(xyz, cs), cs);
}



function xyz2lin(xyz, cs = sRGB)
{
    return mulv3m3(xyz, cs.xyz2lin);
}


function rgb2luv(rgb, cs = sRGB)
{
    return xyz2luv(rgb2xyz(rgb, cs), cs.W);
}



function luv2rgb(luv, cs = sRGB)
{
    return xyz2rgb(luv2xyz(luv, cs.W), cs);
}



function xyz2luv(xyz, W = sRGB.W)
{
    const x = xyz[0], 
          y = xyz[1], 
          z = xyz[2];

    const e = cube(6/29);
    const k = cube(29/3);

    const yw = y / W[1];

    let l = 
        yw > e
        ? 116 * Math.cbrt(yw) - 16
        : k * yw;

    const u_ = 4*x / (x + 15*y + 3*z);
    const v_ = 9*y / (x + 15*y + 3*z);
    
    const uw = 4*W[0] / (W[0] + 15*W[1] + 3*W[2]);
    const vw = 9*W[1] / (W[0] + 15*W[1] + 3*W[2]);
    
    const u = 13*l * (u_ - uw);
    const v = 13*l * (v_ - vw);

    return [
        l / 100, 
        u / 100, 
        v / 100];
}



function luv2xyz(luv, W = sRGB.W)
{
    let l = luv[0] * 100, 
        u = luv[1] * 100, 
        v = luv[2] * 100;

    const e = cube(6/29);    
    const k = cube(29/3);

    const uw = 4*W[0] / (W[0] + 15*W[1] + 3*W[2]);
    const vw = 9*W[1] / (W[0] + 15*W[1] + 3*W[2]);
    
    const y = 
        l > e*k
        ? cube((l + 16) / 116)
        : l / k;
    
    const a = (52*l / nozero(u + 13*l*uw) - 1) / 3;
    const b = -5 * y;
    const c = -1/3;
    const d =  y * (39*l / nozero(v + 13*l*vw) - 5);

    const x = (d - b) / nozero(a - c);

    const z = x*a + b;

    return [x, y, z];
}


function rgb2lab(rgb, cs = sRGB)
{
    return xyz2lab(rgb2xyz(rgb, cs), cs.W);
}



function lab2rgb(lab, cs = sRGB)
{
    return xyz2rgb(lab2xyz(lab, cs.W), cs);
}



function xyz2lab(xyz, W = sRGB.W)
{
    const x = xyz[0], 
          y = xyz[1], 
          z = xyz[2];

    const e = 0.008856; //cube(6/29);
    const k = 903.3;    //cube(29/3);

    let xw = x / W[0];
    let yw = y / W[1];
    let zw = z / W[2];

    xw = xw > e ? Math.cbrt(xw) : (k / 100 * xw + 0.16) / 1.16;
    yw = yw > e ? Math.cbrt(yw) : (k / 100 * yw + 0.16) / 1.16;
    zw = zw > e ? Math.cbrt(zw) : (k / 100 * zw + 0.16) / 1.16;


    const l = (1.16 * yw) - 0.16;
    const a = 5 * (xw - yw);
    const b = 2 * (yw - zw);

    return [l, a, b];
}



function lab2xyz(lab, W = sRGB.W)
{
    const l = lab[0], 
          a = lab[1], 
          b = lab[2];

    const e = 0.008856 / 100; //cube(6/29) / 100;
    const k = 903.3    / 100; //cube(29/3) / 100;

    const yw = (l + 0.16)/1.16;
    const xw = a/5 + yw;
    const zw = yw - b/2;

    let x = cube(xw) > e ? cube(xw) : (1.16*xw - 0.16) / k;
    let y = cube(yw) > e ? cube(yw) : (1.16*yw - 0.16) / k;
    let z = cube(zw) > e ? cube(zw) : (1.16*zw - 0.16) / k;

    x *= W[0];
    y *= W[1];
    z *= W[2];
 
    return [x, y, z];
}


function rgb2oklab(rgb, cs = sRGB)
{
    return rgb2oklab_(rgb[0], rgb[1], rgb[2], cs);
}



function rgb2oklab_(r, g, b, cs = sRGB) 
{
    return oklms2oklab(rgb2oklms_(r, g, b, cs));
}







function oklab2rgb(lab, cs = sRGB)
{
    return oklms2rgb(oklab2oklms(lab), cs);
}



function oklab2rgb_(l, a, b, cs = sRGB) 
{
    return oklab2rgb([l, a, b], cs);
}


const hclok_C_scale = 0.89;


function opp2pol(opp) // opponent to polar
{
    // either lab or luv, 
    // the polar transformation is the same

    const l = opp[0], 
          a = opp[1], 
          b = opp[2];

    const h = Math.atan2(b, a);
    const c = Math.sqrt(a*a + b*b);

    return [h, c, l];
}



function pol2opp(pol) // polar to opponent
{
    // either lab or luv, 
    // the polar transformation is the same

    const h = pol[0], 
          c = pol[1], 
          l = pol[2];

    const a = c * Math.cos(h);
    const b = c * Math.sin(h);

    return [l, a, b];
}


function hclok2rgb(hcl, cs = sRGB)
{
    hcl = [...hcl];

    hcl[0] *= Tau;
    hcl[1] *= hcl[2]; 

    return oklab2rgb(pol2opp(hcl), cs);
}    



function hclok2rgb_(h, c, l, cs = sRGB)
{
    return hclok2rgb([h, c, l], cs);
}    
    
    
    
function rgb2hclok(rgb, cs = sRGB)
{
    const hcl = opp2pol(rgb2oklab(rgb, cs));

    hcl[0] /= Tau;
    hcl[1] /= nozero(hcl[2]);

    while (hcl[0] < 0) hcl[0] += 1;
    while (hcl[0] > 1) hcl[0] -= 1;

    return hcl;
}



function rgb2hclok_(r, g, b, cs = sRGB)
{
    return rgb2hclok([r, g, b], cs);
}



function hclab2lab(hcl)
{
    hcl = [...hcl];

    hcl[0] *= Tau;
    hcl[1] *= hcl[2];

    return pol2opp(hcl);
}



function hclab2rgb(hcl, cs = sRGB)
{
    return lab2rgb(hclab2lab(hcl), cs);
}



function lab2hclab(lab)
{
    let hcl = opp2pol(lab);

    hcl[0] /= Tau;
    hcl[1] /= hcl[2];

    while (hcl[0] < 0) hcl[0] += 1;
    while (hcl[0] > 1) hcl[0] -= 1;

    return hcl;
}



function rgb2hclab(rgb, cs = sRGB)
{
    return lab2hclab(rgb2lab(rgb, cs));
}



function hcluv2luv(hcl)
{
    hcl = [...hcl];

    hcl[0] *= Tau;
    hcl[1] *= hcl[2];

    return pol2opp(hcl);
}



function hcluv2rgb(hcl, cs = sRGB)
{
    return luv2rgb(hcluv2luv(hcl), cs);
}



function luv2hcluv(luv)
{
    let hcl = opp2pol(luv);

    hcl[0] /= Tau;
    hcl[1] /= hcl[2];

    while (hcl[0] < 0) hcl[0] += 1;
    while (hcl[0] > 1) hcl[0] -= 1;

    return hcl;
}



function rgb2hcluv(rgb, cs = sRGB)
{
    return luv2hcluv(rgb2luv(rgb, cs));
}


// const SimpleColorSpaces = 
// [
//     ['hex',   'Hex'   ],
//     ['rgb',   'RGB'   ], 
//     ['hsl',   'HSL'   ], 
//     ['hsv',   'HSB'   ], 
//     ['hclok', 'HCL/ok']
// ];


const ColorSpaces = 
[
    ['hex',   'Hex'         ],
    ['rgb',   'RGB'         ], 
    ['lin',   'RGB / linear'  ], 
    ['p3',    'RGB / P3'      ], 
    ['a98',   'RGB / Adobe98' ], 
    ['pro',   'RGB / ProPhoto'], 
    ['r2020', 'RGB / Rec.2020'], 
    ['hsl',   'HSL'         ], 
    ['hsv',   'HSB'         ], 
    ['hclok', 'HCL / ok'      ],
    ['hclab', 'HCL / ab'      ],
    ['hcluv', 'HCL / uv'      ],
    ['oklab', 'okLab'       ],
    ['lab',   'Lab'         ],
    ['luv',   'Luv'         ],
    ['xyz',   'XYZ'         ],
    ['xyz50', 'XYZ/D50'     ],
    ['xyz65', 'XYZ/D65'     ]
];



function colorSpace     (index) { return ColorSpaces[index][0]; }
function colorSpaceIndex(space) { return ColorSpaces.findIndex(s => s[0] == space); }



class ColorSpace
{
    hex   = Object.freeze( 0);
    rgb   = Object.freeze( 1);
    lin   = Object.freeze( 2);
    p3    = Object.freeze( 3);
    a98   = Object.freeze( 4);
    pro   = Object.freeze( 5);
    r2020 = Object.freeze( 6);
    hsl   = Object.freeze( 7);
    hsv   = Object.freeze( 8);
    hclok = Object.freeze( 9);
    hclab = Object.freeze(10);
    hcluv = Object.freeze(11);
    oklab = Object.freeze(12);
    lab   = Object.freeze(13);
    luv   = Object.freeze(14);
    xyz   = Object.freeze(15);
    xyz50 = Object.freeze(16);
    xyz65 = Object.freeze(17);
}



class Color
extends Float32Array
{
    get r() { return this[0]; }
    get g() { return this[1]; }
    get b() { return this[2]; }
    get a() { return this[3]; }
    get s() { return this[4]; }

    set r(r) { this[0] = r; }
    set g(g) { this[1] = g; }
    set b(b) { this[2] = b; }
    set a(a) { this[3] = a; }
    set s(s) { this[4] = s; }



    constructor(c = null)
    {
        super(5); // c1, c2, c3, a, s (space)

        if (c)
        {
            this.r = c.r;
            this.g = c.g;
            this.b = c.b;
            this.a = c.a;
            this.s = c.s;
        }
        else
        {
            this.r = 0;
            this.g = 0;
            this.b = 0;
            this.a = 0;
            this.s = ColorSpace.rgb;
        }
    }
}


const ColorEpsilon = 0.001;



function rgb2dataColor(rgb)
{
    const _space = 'rgb';

    return [
        _space, 
        getNormalColorValue(rgb[0], _space, 0), 
        getNormalColorValue(rgb[1], _space, 1), 
        getNormalColorValue(rgb[2], _space, 2) ]; 
}



function makeDataColor(space, c1, c2, c3)
{
    const _space = colorSpace(space.value);

    return [
        _space, 
        getNormalColorValue(c1.value, _space, 0), 
        getNormalColorValue(c2.value, _space, 1), 
        getNormalColorValue(c3.value, _space, 2) ]; 
}



function dataColorIsNaN(c)
{
    return isNaN(c[1])
        || isNaN(c[2])
        || isNaN(c[3]);
}



function dataColorIsValid(col, lim = ColorEpsilon)
{
    return rgbIsValid(dataColor2rgb(col), lim);
}



function dataColorIsOk(col, lim = ColorEpsilon)
{
    return rgbIsOk(dataColor2rgb(col), lim);
}


const rgb_NaN = [
    Number.NaN,
    Number.NaN,
    Number.NaN ];

const rgba_NaN = [
    Number.NaN,
    Number.NaN,
    Number.NaN,
    Number.NaN ];


const rgbInvalid  = [0xff, 0, 0xff];
const rgbaInvalid = [0xff, 0, 0xff, 0xff];


const dataColor_NaN = Object.freeze([
    'rgb',
    Number.NaN,
    Number.NaN,
    Number.NaN ]);


// Hunt-Pointer-Estevez
// const HPE = [[ 0.4002, 0.7076, -0.0808],
//              [-0.2263, 1.1653,  0.0457],
//              [ 0,      0,       0.9182]];

// const invHPE = inversem3(HPE);


// CIECAM02
const CAT = [[ 0.7328, 0.4296, -0.1624],
             [-0.7036, 1.6975,  0.0061],
             [ 0.0030, 0.0136,  0.9834]];

const invCAT = inversem3(CAT);


const M1 = [[ 0.8189330101, 0.3618667424, -0.1288597137 ],
            [ 0.0329845436, 0.9293118715,  0.0361456387 ],
            [ 0.0482003018, 0.2643662691,  0.6338517070 ]];

const invM1 = inversem3(M1);



function xy2xyz(x, y, Y = 1) 
{
    let X = (x / y) * Y;
    let Z = ((1 - x - y) / y) * Y;
    
    let N = X + Y + Z;

    return [X / N, 
            Y / N, 
            Z / N];
}



function rgbIsNaN(rgb) 
{
    return isNaN(rgb[0])
        || isNaN(rgb[1])
        || isNaN(rgb[2]);
}



function rgbaIsNaN(rgba) 
{
    return isNaN(rgba[0])
        || isNaN(rgba[1])
        || isNaN(rgba[2])
        || isNaN(rgba[3]);
}



function rgbIsValid(rgb, lim = ColorEpsilon)
{
    return rgb[0] > -lim && rgb[0] < 1 + lim 
        && rgb[1] > -lim && rgb[1] < 1 + lim 
        && rgb[2] > -lim && rgb[2] < 1 + lim;
}



function rgbaIsValid(rgba, lim = ColorEpsilon)
{
    return rgba[0] > -lim && rgba[0] < 1 + lim 
        && rgba[1] > -lim && rgba[1] < 1 + lim 
        && rgba[2] > -lim && rgba[2] < 1 + lim
        && rgba[3] > -lim && rgba[3] < 1 + lim;
}



function rgbIsOk(rgb, lim = ColorEpsilon)
{
    return !rgbIsNaN  (rgb)
        &&  rgbIsValid(rgb, lim);
}



function rgbaIsOk(rgba, lim = ColorEpsilon)
{
    return !rgbaIsNaN  (rgba)
        &&  rgbaIsValid(rgba, lim);
}



function invalid2validRgb(rgb)
{
    return [
        Math.min(Math.max(0, rgb[0]), 1),
        Math.min(Math.max(0, rgb[1]), 1),
        Math.min(Math.max(0, rgb[2]), 1) ];
}



function rgbLerp(rgb1, rgb2, t)
{
    return [ lerp(rgb1[0], rgb2[0], t),
             lerp(rgb1[1], rgb2[1], t),
             lerp(rgb1[2], rgb2[2], t) ];
}



function rgbaLerp(rgba1, rgba2, t)
{
    return [ lerp(rgba1[0], rgba2[0], t),
             lerp(rgba1[1], rgba2[1], t),
             lerp(rgba1[2], rgba2[2], t),
             lerp(rgba1[3], rgba2[3], t) ];
}



function rgbAdd(rgb1, rgb2)
{
    return [ rgb1[0] + rgb2[0],
             rgb1[1] + rgb2[1],
             rgb1[2] + rgb2[2] ];
}



function rgbaAdd(rgba1, rgba2)
{
    return [ rgba1[0] + rgba2[0],
             rgba1[1] + rgba2[1],
             rgba1[2] + rgba2[2],
             rgba1[3] + rgba2[3] ];
}



function rgbSub(rgb1, rgb2)
{
    return [ rgb1[0] - rgb2[0],
             rgb1[1] - rgb2[1],
             rgb1[2] - rgb2[2] ];
}



function rgbMuls(rgb, s)
{
    return [ rgb[0] * s,
             rgb[1] * s,
             rgb[2] * s ];
}



function rgbaMuls(rgba, s)
{
    return [ rgba[0] * s,
             rgba[1] * s,
             rgba[2] * s,
             rgba[3] * s ];
}



function rgbAvg(rgb1, rgb2)
{
    return [ (rgb1[0] + rgb2[0]) / 2,
             (rgb1[1] + rgb2[1]) / 2,
             (rgb1[2] + rgb2[2]) / 2 ];
}



function rgbMax(rgb1, rgb2)
{
    return [ Math.max(rgb1[0], rgb2[0]),
             Math.max(rgb1[1], rgb2[1]),
             Math.max(rgb1[2], rgb2[2]) ];
}



function rgbPow(col, p)
{
    return [
        Math.pow(col[0], p), 
        Math.pow(col[1], p), 
        Math.pow(col[2], p) ]
}



function allConesWork(cones)
{
    return cones.l == 1 
        && cones.m == 1 
        && cones.s == 1;
}



function rgbToString(rgb)
{
    return '{' + Math.round(rgb[0] * 255) + ', '
               + Math.round(rgb[1] * 255) + ', '
               + Math.round(rgb[2] * 255) + '}';
}



function colorStyle_(r, g, b, a)
{
    if (a !== undefined)
    {
        return 'rgba('
            + Math.round(r * 0xff) + ', '
            + Math.round(g * 0xff) + ', '
            + Math.round(b * 0xff) + ', '
            + a + ')';
    }
    else
    {
        return 'rgb('
            + Math.round(r * 0xff) + ', '
            + Math.round(g * 0xff) + ', '
            + Math.round(b * 0xff) + ')';
    }
}



function colorStyleRgb_(r, g, b)
{
    return colorStyle_(r, g, b, 1);
}



function rgb2style(rgb)
{
    return colorStyle_(rgb[0], rgb[1], rgb[2], 1);
}



function colorStyleRgba_(r, g, b, a)
{
    return colorStyle_(r, g, b, a);
}



function rgba2style(rgba)
{
    return colorStyle_(rgba[0], rgba[1], rgba[2], rgba[3]);
}



function rgb2style_a(rgb, a = 1)
{
    return colorStyle_(rgb[0], rgb[1], rgb[2], a);
}



function toRgba(rgb_)
{
    return rgb_.length == 3
         ? [...rgb_, 1]
         : rgb_;
}



function rgb_a(rgb, a = 1)
{
    return [rgb[0], rgb[1], rgb[2], a];
}



function isDark(rgb, threshold = 0.71)
{
    return rgb2hclok(rgb)[2] < threshold;
}



function rgbDistance(col1, col2)
{
    const d0 = col2[0] - col1[0];
    const d1 = col2[1] - col1[1];
    const d2 = col2[2] - col1[2];

    return Math.sqrt(d0*d0 + d1*d1 + d2*d2);
}



function rgbaMul(rgba, v)
{
    return [
        rgba[0] * v,
        rgba[1] * v,
        rgba[2] * v,
        rgba[3] * v ];
}



function rgbaDiv(rgba, v)
{
    return [
        rgba[0] / v,
        rgba[1] / v,
        rgba[2] / v,
        rgba[3] / v ];
}



function maxRgbDistance(col1, col2)
{
    return Math.max(Math.max(Math.max(
        Math.abs(col2[0] - col1[0]),
        Math.abs(col2[1] - col1[1])),
        Math.abs(col2[2] - col1[2])));
}



function rgbEqual(rgb1, rgb2)
{
    return Math.abs(rgb1[0] - rgb2[0]) < ColorEpsilon
        && Math.abs(rgb1[1] - rgb2[1]) < ColorEpsilon
        && Math.abs(rgb1[2] - rgb2[2]) < ColorEpsilon;        
}



function style2rgba(style) // SLOW
{
    utilContext.fillStyle = style;
    utilContext.fillRect(0, 0, 1, 1);

    return rgbaDiv(utilContext.getImageData(0, 0, 1, 1).data, 0xFF);
}



function computedStyle2rgba(obj, style) // SLOW
{
    utilContext.fillStyle = getStyleValue(obj, style);
    utilContext.fillRect(0, 0, 1, 1);

    return rgbaDiv(utilContext.getImageData(0, 0, 1, 1).data, 0xFF);
}



function getTextColorFromBackColor(rgb, opacity = 1)
{
    return !rgbIsNaN(rgb)
           ? (opacity >= 0.5
               ? (isDark(rgb) ? [1, 1, 1, 0.75] : [0, 0, 0, 0.75])
               : (darkMode ? [1, 1, 1, 0.75] : [0, 0, 0, 0.75]))
           : (darkMode ? rgbaNoColorTextDark : rgbaNoColorTextLight);
}



function getDefaultWarningRgba(rgb)
{
    return !rgbIsNaN(rgb)
         ? (isDark(rgb)  ? [1, 1, 1, 0.133] : [0, 0, 0, 0.161])  
         : (darkMode ? [1, 1, 1, 0.031] : [0, 0, 0, 0.031]);  
}



function getWarningStyles(colBack)
{
    let warnStyle1, 
        warnStyle2;
    
        
    const colWarning = getDefaultWarningRgba(colBack);

     
    if (!rgbIsNaN(colBack))
    {
        const hclBack = rgb2hclok(colBack);

        const hclBack1 = [...hclBack];
        const hclBack2 = [...hclBack];

        hclBack1[0] += 1/12;  if (hclBack1[0] > 1) hclBack1[0] -= 1;
        hclBack2[0] -= 1/12;  if (hclBack2[0] < 0) hclBack2[0] += 1;


        const altBack1 = rgb_a(clampRgb(hclok2rgb(hclBack1)), 0.35);
        const altBack2 = rgb_a(clampRgb(hclok2rgb(hclBack2)), 0.35);

        const factor   = getWarningFactor(colBack);

        const colWarn1 = rgbaLerp(colWarning, altBack1, factor);
        const colWarn2 = rgbaLerp(colWarning, altBack2, factor);
        
        warnStyle1     = rgba2style(colWarn1);
        warnStyle2     = rgba2style(colWarn2);
    }
    else
    {
        warnStyle1 = rgba2style(colWarning);
        warnStyle2 = rgba2style(colWarning);
    }


    return [warnStyle1, 
            warnStyle2];
}



function getWarningGradient(i, style1, style2)
{
    return 'repeating-linear-gradient('
            + '-45deg, '
            + 'transparent 0 ' + i   + 'px,' 
            +  style1 + ' '    + i   + 'px ' + i*2 +'px,'
            + 'transparent '   + i*2 + 'px ' + i*3 +'px,'
            +  style2 + ' '    + i*3 + 'px ' + i*4 +'px)';
}



function getWarningFactor(colBack)
{
    let dr, dg, db;

    if (colBack[0] < 0) dr = -colBack[0]; else if (colBack[0] > 1) dr = colBack[0] - 1; else dr = 0;
    if (colBack[1] < 0) dg = -colBack[1]; else if (colBack[1] > 1) dg = colBack[1] - 1; else dg = 0;
    if (colBack[2] < 0) db = -colBack[2]; else if (colBack[2] > 1) db = colBack[2] - 1; else db = 0;
    
    const d   = [dr, dg, db].sort()[1];
    const avg = (dr + dg + db) / 3;

    const factor = Math.min((d + avg) / 2, 1);

    // if (this.id == 'color')
    // {
    //     console.log('colBack =', colBack);
    //     console.log('dr     =', dr);
    //     console.log('dg     =', dg);
    //     console.log('db     =', db);
    //     console.log('d      =', d);
    //     console.log('avg    =', avg);
    //     console.log('factor =', factor);
    //     console.log('');
    // }

    return factor;
}



function getStripeBackColor(rgbBack)
{
    let rgbStripeBack = [...rgbBack];
        
    const factor = getWarningFactor(rgbBack);

    if (factor > 0)
    {
        const hcl = rgb2hclok(clampRgb(rgbBack));
        hcl[1] /= 2;
        

        rgbStripeBack = rgbLerp(rgbBack, clipChroma(hclok2rgb(hcl)), factor);
    }

    return rgbStripeBack;
}



function getDefaultWarningStyle(rgba)
{
    return !rgbaIsNaN(rgba)
         ? (isDark(rgba)  ? '#ffffff29' : '#00000022')
         : (darkMode ? '#ffffff08' : '#00000006'); 
}



function clampRgb(_rgb)
{
    const rgb = [..._rgb];

    rgb[0] = Math.min(Math.max(0, rgb[0]), 1);   
    rgb[1] = Math.min(Math.max(0, rgb[1]), 1);   
    rgb[2] = Math.min(Math.max(0, rgb[2]), 1); 

    return rgb;
}



function clampChan(val)
{
    return Math.min(Math.max(0, val), 1);
}



function setChan(_col, chan, val)
{
    const col = [..._col];
    col[chan] = val;
    return col;
}



function clipChroma(rgb)
{
    let hcl = rgb2hclok(rgb);

    let loopProtect = 10000;

    while (!rgbIsValid(hclok2rgb(hcl))
         && hcl[1] > 0.001
         && loopProtect-- > 0)
        hcl[1] -= 0.001;

    rgb = hclok2rgb(hcl);

    rgb[0] = Math.min(Math.max(0, rgb[0]), 1);   
    rgb[1] = Math.min(Math.max(0, rgb[1]), 1);   
    rgb[2] = Math.min(Math.max(0, rgb[2]), 1); 

    return rgb;
}



function noColorStyle(rgba)
{
    if (!rgbaIsNaN(rgba))
        return 'transparent';
    else
    {
        return darkMode
            ? 'rgba(56, 56, 56, 0.95)'
            : 'rgba(255, 255, 255, 0.95)';
    }
}



function addHueHsl(rgb, d, min = 0, max = Tau)
{
    const hsl = rgb2hsl(rgb);

    return hsl2rgb_(
        trimAngle(hsl[0] + d, min, max),
        hsl[1], 
        hsl[2]);
}



function addHueHcl(rgb, d, min = 0, max = Tau)
{
    const hcl = rgb2hclok(rgb);

    return hclok2rgb_(
        trimAngle(hcl[0] + d, min, max),
        hcl[1], 
        hcl[2]);
}


// https://ixora.io/projects/colorblindness/color-blindness-simulation-research/


const lmsW = xyz2lms(lin2xyz([1, 1, 1]));
const lmsB = xyz2lms(lin2xyz([0, 0, 1]));
const lmsR = xyz2lms(lin2xyz([1, 0, 0]));

const lq1 = (lmsW[2]*lmsB[0] - lmsB[2]*lmsW[0]) / (lmsW[2]*lmsB[1] - lmsB[2]*lmsW[1]);
const lq2 = (lmsW[1]*lmsB[0] - lmsB[1]*lmsW[0]) / (lmsW[1]*lmsB[2] - lmsB[1]*lmsW[2]);

const mq1 = (lmsW[2]*lmsB[1] - lmsB[2]*lmsW[1]) / (lmsW[2]*lmsB[0] - lmsB[2]*lmsW[0]);
const mq2 = (lmsW[0]*lmsB[1] - lmsB[0]*lmsW[1]) / (lmsW[0]*lmsB[2] - lmsB[0]*lmsW[2]);

const sq1 = (lmsW[1]*lmsR[2] - lmsR[1]*lmsW[2]) / (lmsW[1]*lmsR[0] - lmsR[1]*lmsW[0]);
const sq2 = (lmsW[0]*lmsR[2] - lmsR[0]*lmsW[2]) / (lmsW[0]*lmsR[1] - lmsR[0]*lmsW[1]);

const bq1 = lmsW[0] / lmsW[2];
const bq2 = lmsW[1] / lmsW[2];


// this is a number I made up following the information here: https://www.color-blindness.com/2007/07/20/monochromacy-complete-color-blindness/
// the simulation itself gives grayscale
// on the site the simulation has color in it, so I decided to leave some color in as well,
// but the amount is completely arbitrary, I just felt that this particular value matches
// the description on that site without being unrealistically exaggerated
const blueMono = 0.88;


function rgb2colorblind(rgb, l, m, s, cs = sRGB)
{
    if (   l == 0
        && m == 0
        && s == 0)
    {
        // achromatopsia is simulated by taking only the luminance

        const a = 
              cs.Y[0] * rgb[0]
            + cs.Y[1] * rgb[1]
            + cs.Y[2] * rgb[2];

        rgb = [a, a, a];
    }
    else
    {
        const xyz = rgb2xyz(rgb, cs);
        const lms = xyz2lms(xyz);

        const a = 
              cs.Y[0] * rgb[0]
            + cs.Y[1] * rgb[1]
            + cs.Y[2] * rgb[2];

        const lm = Math.min(l + m, 1);


        const lms_ = [
            lms[0] + lerp(blueMono * (bq1*lms[2] - lms[0]), (1 - l) * ((lq1*lms[1] + lq2*lms[2]) - lms[0]), lm),
            lms[1] + lerp(blueMono * (bq2*lms[2] - lms[1]), (1 - m) * ((mq1*lms[0] + mq2*lms[2]) - lms[1]), lm),
            lms[2] + lerp(0,                     lerp(s, 1 - s, lm) * ((sq1*lms[0] + sq2*lms[1]) - lms[2]), lm) ];

        const xyz_ = lms2xyz(lms_);
              rgb  = xyz2rgb(xyz_, cs);


        let bm_ = rgb2lab(rgb, cs);
        bm_[0] = lerp(a, bm_[0], lm);
        rgb = lab2rgb(bm_, cs);

        
        rgb = rgbLerp(
            [a, a, a], 
            rgb, 
            Math.min(s + lm, 1));
    }
    

    return rgb;
}


function rgb2hex(rgb)
{
    let hex =
          Math.round(rgb[0] * 0xff).toString(16).padStart(2, '0').toUpperCase()
        + Math.round(rgb[1] * 0xff).toString(16).padStart(2, '0').toUpperCase()
        + Math.round(rgb[2] * 0xff).toString(16).padStart(2, '0').toUpperCase();

    return hex;
}



function rgba2hex(rgba)
{
    let hex =
          Math.round(rgba[0] * 0xff).toString(16).padStart(2, '0').toUpperCase()
        + Math.round(rgba[1] * 0xff).toString(16).padStart(2, '0').toUpperCase()
        + Math.round(rgba[2] * 0xff).toString(16).padStart(2, '0').toUpperCase()
        + Math.round(rgba[3] * 0xff).toString(16).padStart(2, '0').toUpperCase();

    return hex;
}



function validHex2rgb(hex) // can process invalid '-'
{
    return hex.indexOf(NAN_DISPLAY) > -1 
           ? rgb_NaN 
           : hex2rgb(hex);
}



function validHex2rgba(hex) // can process invalid '-'
{
    return hex.indexOf(NAN_DISPLAY) > -1 
           ? rgba_NaN 
           : hex2rgba(hex);
}



function hex2rgb(hex)
{
    if (hex[0] == '#')
        hex = hex.substring(1);

        
    let rgb = [];

    if (hex.length >= 6)
    {
        rgb[0] = parseInt(hex.slice(0, 2), 16); 
        rgb[1] = parseInt(hex.slice(2, 4), 16); 
        rgb[2] = parseInt(hex.slice(4, 6), 16); 
    }
    else if (hex.length >= 3)
    {
        rgb[0] = parseInt(hex[0], 16) * 0x11; 
        rgb[1] = parseInt(hex[1], 16) * 0x11; 
        rgb[2] = parseInt(hex[2], 16) * 0x11; 
    }
    else if (hex.length == 2)
    {
        let v = parseInt(hex, 16);
        
        rgb[0] = v; 
        rgb[1] = v; 
        rgb[2] = v; 
    }
    else if (hex.length == 1)
    {
        let v = parseInt(hex, 16);
        
        rgb[0] = v * 0x11; 
        rgb[1] = v * 0x11; 
        rgb[2] = v * 0x11; 
    }
    else if (hex.length == 0)
    {
        rgb[0] = 0; 
        rgb[1] = 0; 
        rgb[2] = 0;         
    }


    rgb[0] /= 0xff;
    rgb[1] /= 0xff;
    rgb[2] /= 0xff;

    
    return rgb;
}



function hex2rgba(hex)
{
    if (hex[0] == '#')
        hex = hex.substring(1);

        
    let rgba = [];

    if (hex.length >= 8)
    {
        rgba[0] = parseInt(hex.slice(0, 2), 16); 
        rgba[1] = parseInt(hex.slice(2, 4), 16); 
        rgba[2] = parseInt(hex.slice(4, 6), 16); 
        rgba[3] = parseInt(hex.slice(6, 8), 16); 
    }
    else if (hex.length >= 6)
    {
        rgba[0] = parseInt(hex.slice(0, 2), 16); 
        rgba[1] = parseInt(hex.slice(2, 4), 16); 
        rgba[2] = parseInt(hex.slice(4, 6), 16); 
        rgba[3] = 0xff; 
    }
    else if (hex.length >= 4)
    {
        rgba[0] = parseInt(hex[0], 16) * 0x11; 
        rgba[1] = parseInt(hex[1], 16) * 0x11; 
        rgba[2] = parseInt(hex[2], 16) * 0x11; 
        rgba[3] = parseInt(hex[3], 16) * 0x11; 
    }
    else if (hex.length == 3)
    {
        rgba[0] = parseInt(hex[0], 16) * 0x11; 
        rgba[1] = parseInt(hex[1], 16) * 0x11; 
        rgba[2] = parseInt(hex[2], 16) * 0x11; 
        rgba[3] = 0xff; 
    }
    else if (hex.length == 2)
    {
        let v = parseInt(hex, 16);
        
        rgba[0] = v; 
        rgba[1] = v; 
        rgba[2] = v; 
        rgba[3] = 0xff; 
    }
    else if (hex.length == 1)
    {
        let v = parseInt(hex, 16);
        
        rgba[0] = v * 0x11; 
        rgba[1] = v * 0x11; 
        rgba[2] = v * 0x11; 
        rgba[3] = 0xff; 
    }
    else if (hex.length == 0)
    {
        rgba[0] = 0; 
        rgba[1] = 0; 
        rgba[2] = 0;         
        rgba[3] = 0; 
    }


    rgba[0] /= 0xff;
    rgba[1] /= 0xff;
    rgba[2] /= 0xff;
    rgba[3] /= 0xff;


    return rgba;
}


function getContrastRatio2(textColor, backColor)
{
    if (    rgbIsNaN  (textColor)
        || !rgbIsValid(textColor))
        return Number.NaN;

    const txtY = sRGB.luminance(textColor);
    const  bgY = sRGB.luminance(backColor);

    return (
        bgY > txtY
        ? ( bgY + 0.05) / (txtY + 0.05)
        : (txtY + 0.05) / ( bgY + 0.05));
}



function getContrastRating2(ratio)
{
         if (ratio >= 7  ) return 'AAA';
    else if (ratio >= 4.5) return 'AA';
    else if (ratio >= 3  ) return 'AA<sub>L</sub>';
    else                   return '';
}



function getContrastRatio3(textColor, backColor)
{
    if (!rgbIsOk(textColor))
        return Number.NaN;

    return APCAcontrast(
        sRGBtoY(textColor),
        sRGBtoY(backColor));
}



// I copied the code below from https://github.com/Myndex/SAPC-APCA/blob/master/WEBTOOLS/APCA/JS/DEV.0.1.2.G_SAPCsRGB.js
// and refactored it to fit my code style.

const mainTRC     = 2.4; // 2.4 exponent emulates actual monitor perception
       
const sRco        = 0.2126729, 
      sGco        = 0.7151522, 
      sBco        = 0.0721750; // sRGB coefficients
   
const normBG      = 0.56, 
      normTXT     = 0.57,
      revTXT      = 0.62,
      revBG       = 0.65; // G-4g constants for use with 2.4 exponent
   
const blkThrs     = 0.022,
      blkClmp     = 1.414, 
      scaleBoW    = 1.14,
      scaleWoB    = 1.14,
      loBoWthresh = 0.035991,
      loWoBthresh = 0.035991,
      loBoWfactor = 27.7847239587675,
      loWoBfactor = 27.7847239587675,
      loBoWoffset = 0.027,
      loWoBoffset = 0.027,
      loClip      = 0.001,
      deltaYmin   = 0.0005;



function sRGBtoY(rgb) 
{
    // NOTE this is not the actual sRGB luminance as it
    // ignores the straight section. Using actual sRGB
    // luminance gives a slightly different contrast score.

    return sRco * Math.pow(rgb[0], mainTRC) 
         + sGco * Math.pow(rgb[1], mainTRC)
         + sBco * Math.pow(rgb[2], mainTRC);
}



function APCAcontrast(txtY, bgY)
{
    let SAPC           = 0; // For raw SAPC values
    let outputContrast = 0; // For weighted final values

    txtY = 
        txtY > blkThrs 
        ? txtY 
        : txtY + Math.pow(blkThrs - txtY, blkClmp);
        
    bgY = 
        bgY > blkThrs 
        ? bgY 
        : bgY + Math.pow(blkThrs - bgY, blkClmp);

    if (Math.abs(bgY - txtY) < deltaYmin)  
        return 0; 


    if (bgY > txtY) 
    {  
        SAPC = (Math.pow(bgY, normBG) - Math.pow(txtY, normTXT)) * scaleBoW;

        outputContrast = 
            SAPC < loClip 
            ? 0 
            : SAPC < loBoWthresh
              ? SAPC - SAPC * loBoWfactor * loBoWoffset 
              : SAPC - loBoWoffset;
    } 
    else 
    {  
        SAPC = (Math.pow(bgY, revBG) - Math.pow(txtY, revTXT)) * scaleWoB;

        outputContrast = 
            SAPC > -loClip 
            ? 0 
            : SAPC > -loWoBthresh 
              ? SAPC - SAPC * loWoBfactor * loWoBoffset 
              : SAPC + loWoBoffset;
    }


    return outputContrast * 100;
}


const rgbFactor  = [255, 255, 255];
const hs_Factor  = [360, 100, 100];
const hclFactor  = [360, 100, 100];
const oppFactor  = [100, 100, 100];
const xyzFactor  = [100, 100, 100];
  
 
const rgbScale   = [255, 255, 255];
  
const hs_Scale   = [360, 100, 100];
 
const hclokScale = [360, 50,  100];
const hclabScale = [360, 400, 100];
const hcluvScale = [360, 330, 100];
 
const oklabScale = [100,  30,  30];
const labScale   = [100, 100, 100];
const luvScale   = [100, 150, 150];

const xyzScale   = [ 95, 100, 108];
 


function colorFactor(space)
{
    switch (space)
    {
        case 'hex':
        case 'rgb':
        case 'lin':
        case 'p3':
        case 'a98':
        case 'pro':
        case 'r2020':  return rgbFactor;

        case 'hsv':
        case 'hsl':    return hs_Factor;

        case 'hclok':
        case 'hclab':
        case 'hcluv':  return hclFactor;

        case 'oklab':
        case 'lab':
        case 'luv':    return oppFactor;

        case 'xyz':
        case 'xyz50':
        case 'xyz65':  return xyzFactor;
        
        default:       consoleError('invalid color factor from space \''+space+'\''); break;
    }
}



function scaleColor(col, space)
{
    let scale;

    switch (space)
    {
        case 'hex':
        case 'rgb':
        case 'lin':
        case 'p3':
        case 'a98':
        case 'pro':
        case 'r2020': scale = rgbScale;   break;

        case 'hsv':
        case 'hsl':   scale = hs_Scale;   break;

        case 'hclok': scale = hclokScale; break;
        case 'hclab': scale = hclabScale; break;
        case 'hcluv': scale = hcluvScale; break;

        case 'oklab': scale = oklabScale; break;
        case 'lab':   scale = labScale;   break;
        case 'luv':   scale = luvScale;   break;

        case 'xyz':
        case 'xyz50':
        case 'xyz65': scale = xyzScale;   break;
    }

    return [
        col[0] * scale[0],
        col[1] * scale[1],
        col[2] * scale[2] ];
}



function normalizeRgb(rgb)
{
    return [ rgb[0] / 255,
             rgb[1] / 255,
             rgb[2] / 255 ];
}



function scaleRgb(rgb)
{
    return [ Math.round(rgb[0] * 255),
             Math.round(rgb[1] * 255),
             Math.round(rgb[2] * 255) ];
}



function switchToSpace(node, space)
{
    switch (space)
    {
        case 'hex':   switchToHex   (node); break;

        case 'rgb':
        case 'lin':
        case 'p3':
        case 'a98':
        case 'pro':
        case 'r2020': switchToRgb   (node); break;

        case 'hsv':   switchToHsv   (node); break;
        case 'hsl':   switchToHsl   (node); break;

        case 'hclok': switchToHclok (node); break;
        case 'hclab': switchToHclab (node); break;
        case 'hcluv': switchToHcluv (node); break;

        case 'oklab': switchToOklab (node); break;
        case 'lab':   switchToLab   (node); break;
        case 'luv':   switchToLuv   (node); break;

        case 'xyz':    
        case 'xyz50': 
        case 'xyz65': switchToXyz   (node); break;
    }

    node.resetAllControlRanges();
}



function switchToHex  (node) { switchToRgbControls   (node); switchToTextbox(node); }
function switchToRgb  (node) { switchToRgbControls   (node);                        }

function switchToHsv  (node) { switchToHs_Controls   (node, 'B');                   }
function switchToHsl  (node) { switchToHs_Controls   (node, 'L');                   }
             
function switchToHclok(node) { switchToHclOklControls(node);                        }
function switchToHclab(node) { switchToHclLabControls(node);                        }
function switchToHcluv(node) { switchToHclLuvControls(node);                        }
             
function switchToOklab(node) { switchToOklabControls (node, 'a', 'b');              }
function switchToLab  (node) { switchToLabControls   (node, 'a', 'b');              }
function switchToLuv  (node) { switchToLuvControls   (node, 'u', 'v');              }

function switchToXyz  (node) { switchToXyzControls   (node);                        }
   


function switchToRgbControls(node)
{
    switchToControls(node, 
        'R', 0, rgbScale[0], '', false, 
        'G', 0, rgbScale[1], 
        'B', 0, rgbScale[2]);  

    node.param1.controls[0].min = 
    node.param2.controls[0].min = 
    node.param3.controls[0].min = Number.MIN_SAFE_INTEGER; // allow extrapolation

    node.param1.controls[0].max = 
    node.param2.controls[0].max = 
    node.param3.controls[0].max = Number.MAX_SAFE_INTEGER; // allow extrapolation

    showRgbControlHex(node, false);    
}



function switchToHs_Controls(node, v_or_l) 
{ 
    switchToControls(node, 
        'H',    0, hs_Scale[0], '°', true,  
        'S',    0, hs_Scale[1], 
        v_or_l, 0, hs_Scale[2]);  

    node.param1.controls[0].suffixOffsetY = -4;

    node.param2.controls[0].min = 
    node.param3.controls[0].min = Number.MIN_SAFE_INTEGER; // allow extrapolation

    node.param2.controls[0].max = 
    node.param3.controls[0].max = Number.MAX_SAFE_INTEGER; // allow extrapolation

    showRgbControlHex(node, false); 
}



function switchToHclControls(node, scale) 
{ 
    switchToControls(node, 
        'H', 0, scale[0], '°', true,  
        'C', 0, scale[1], 
        'L', 0, scale[2]);  

    node.param1.controls[0].suffixOffsetY = -4;

    node.param2.controls[0].min = 
    node.param3.controls[0].min = Number.MIN_SAFE_INTEGER; // allow extrapolation

    node.param2.controls[0].max = 
    node.param3.controls[0].max = Number.MAX_SAFE_INTEGER; // allow extrapolation

    showRgbControlHex(node, false); 
}



function switchToHclOklControls(node) { switchToHclControls(node, hclokScale); }
function switchToHclLabControls(node) { switchToHclControls(node, hclabScale); }
function switchToHclLuvControls(node) { switchToHclControls(node, hcluvScale); }



function switchToOppControls(node, c2, c3, scale)
{ 
    switchToControls(node, 
        'L', 0,        scale[0], '', false,  
        c2, -scale[1], scale[1], 
        c3, -scale[2], scale[2]);  

    showRgbControlHex(node, false); 
}



function switchToOklabControls(node) { switchToOppControls(node, 'a', 'b', oklabScale); }
function switchToLabControls  (node) { switchToOppControls(node, 'a', 'b', labScale  ); }
function switchToLuvControls  (node) { switchToOppControls(node, 'u', 'v', luvScale  ); }



function switchToXyzControls(node) 
{ 
    switchToControls(node, 
        'X', 0, xyzScale[0],
        'Y', 0, xyzScale[1], 
        'Z', 0, xyzScale[2]);  

        node.param1.controls[0].min = 
        node.param2.controls[0].min = 
        node.param3.controls[0].min = Number.MIN_SAFE_INTEGER; // allow extrapolation
    
        node.param1.controls[0].max = 
        node.param2.controls[0].max = 
        node.param3.controls[0].max = Number.MAX_SAFE_INTEGER; // allow extrapolation
    }



function showRgbControlHex(node, show)
{
    node.param1.controls[0].showHex = show;
    node.param2.controls[0].showHex = show;
    node.param3.controls[0].showHex = show;
}



function switchToControls(node, c1, c1min, c1max, c1suffix, c1wrap, c2, c2min, c2max, c3, c3min, c3max)
{
    switchToSliders(node);

    node.param1.setName(c1, false); 
    node.param2.setName(c2, false); 
    node.param3.setName(c3, false);

    node.param1.controls[0].wrapValue = c1wrap;
    node.param1.controls[0].setSuffix(c1suffix, c1suffix != '');

    node.param1.controls[0].setMin(c1min); 
    node.param2.controls[0].setMin(c2min);
    node.param3.controls[0].setMin(c3min);
    
    node.param1.controls[0].setMax(c1max); 
    node.param2.controls[0].setMax(c2max); 
    node.param3.controls[0].setMax(c3max); 
    
    node.param1.updateControls();
    node.param2.updateControls();
    node.param3.updateControls();

    node.param1.controls[0].suffixOffsetY = 0;
}



function switchToTextbox(node)
{
    removeOpColorParamWires(node);

    removeDivFrom(node.param1.div, node.paramHolder);
    removeDivFrom(node.param2.div, node.paramHolder);
    removeDivFrom(node.param3.div, node.paramHolder);
        
    appendDivTo(node.paramColor.div, node.paramHolder);
}



function removeParamDivs(node)
{
    removeOpColorParamWires(node);

    removeDivFrom(node.param1.div,     node.paramHolder);
    removeDivFrom(node.param2.div,     node.paramHolder);
    removeDivFrom(node.param3.div,     node.paramHolder);
    
    removeDivFrom(node.paramColor.div, node.paramHolder);
}



function removeOpColorParamWires(node)
{
    for (let i = node.inputs.length-1; i >= 2; i--)
        if (node.inputs[i].connected)
            uiDisconnect(node.inputs[i]);

    for (let i = node.outputs.length-1; i >= 2; i--)
        for (const input of node.outputs[i].connectedInputs)
            uiDisconnect(input);
}



function switchToSliders(node)
{
    removeDivFrom(node.paramColor.div, node.paramHolder);

    appendDivTo(node.param1.div, node.paramHolder);
    appendDivTo(node.param2.div, node.paramHolder);
    appendDivTo(node.param3.div, node.paramHolder);
}



function rgb2dataColor(rgb, space = 'rgb')
{
    return [
        space,
        rgb[0],
        rgb[1],
        rgb[2] ];
}



function getNormalColorValue(value, space, chan)
{
    switch (space)
    {
        case 'hex':
        case 'rgb':
        case 'lin':
        case 'p3':
        case 'a98':
        case 'pro':
        case 'r2020': return getNormalValueRgb_(value, chan);

        case 'hsv':
        case 'hsl':   return getNormalValueHs_ (value, chan);

        case 'hclok':
        case 'hclab':
        case 'hcluv': return getNormalValueHcl (value, chan);

        case 'oklab':
        case 'lab':
        case 'luv':   return getNormalValueOpp (value, chan);

        case 'xyz':
        case 'xyz50':
        case 'xyz65': return getNormalValueXyz (value, chan);
    }
}



function getNormalValueRgb_(value, chan)
{
    switch (chan)
    {
        case 0: return value / rgbFactor[0];
        case 1: return value / rgbFactor[1]; 
        case 2: return value / rgbFactor[2];
    }
}



function getNormalValueHs_(value, chan)
{
    switch (chan)
    {
        case 0: return value / hs_Factor[0];
        case 1: return value / hs_Factor[1]; 
        case 2: return value / hs_Factor[2];
    }
}



function getNormalValueOpp(value, chan)
{
    switch (chan)
    {
        case 0: return value / oppFactor[0];
        case 1: return value / oppFactor[1]; 
        case 2: return value / oppFactor[2];
    }
}



function getNormalValueHcl(value, chan)
{
    switch (chan)
    {
        case 0: return value / hclFactor[0];
        case 1: return value / hclFactor[1]; 
        case 2: return value / hclFactor[2];
    }
}



function getNormalValueXyz(value, chan)
{
    switch (chan)
    {
        case 0: return value / xyzFactor[0];
        case 1: return value / xyzFactor[1]; 
        case 2: return value / xyzFactor[2];
    }
}



function getNormalColor(color)
{
    return getNormalColor_(
        color[0], 
        color[1], 
        color[2], 
        color[3])
}



function getNormalColor_(space, c1, c2, c3)
{
    switch (space)
    {
        case 'hex':
        case 'rgb':
        case 'lin':
        case 'p3':
        case 'a98':
        case 'pro':
        case 'r2020': return getNormalColorRgb_(c1, c2, c3);

        case 'hsv':
        case 'hsl':   return getNormalColorHs_(c1, c2, c3);

        case 'hclok':
        case 'hclab':
        case 'hcluv': return getNormalColorHcl(c1, c2, c3);

        case 'oklab':
        case 'lab':
        case 'luv':   return getNormalColorOpp(c1, c2, c3);

        case 'xyz':
        case 'xyz50':
        case 'xyz65': return getNormalColorXyz(c1, c2, c3);
    }
}



function getNormalColorRgb_(c1, c2, c3)
{
    return [
        c1 / rgbFactor[0], 
        c2 / rgbFactor[1], 
        c3 / rgbFactor[2]];
}



function getNormalColorHs_(c1, c2, c3)
{
    return [
        c1 / hs_Factor[0], 
        c2 / hs_Factor[1], 
        c3 / hs_Factor[2]];
}



function getNormalColorHcl(c1, c2, c3)
{
    return [
        c1 / hclFactor[0], 
        c2 / hclFactor[1], 
        c3 / hclFactor[2]];
}



function getNormalColorOpp(c1, c2, c3)
{
    return [
        c1 / oppFactor[0], 
        c2 / oppFactor[1], 
        c3 / oppFactor[2]];
}



function getNormalColorXyz(c1, c2, c3)
{
    return [
        c1 / xyzFactor[0], 
        c2 / xyzFactor[1], 
        c3 / xyzFactor[2]];
}



function getScaledDataColor(color)
{
    switch (color[0])
    {
        case 'hex':
        case 'rgb':   return getScaledDataColorRgb('rgb',    color[1], color[2], color[3])
        case 'lin':   return getScaledDataColorRgb('lin',    color[1], color[2], color[3])
        case 'p3':    return getScaledDataColorRgb('p3',     color[1], color[2], color[3])
        case 'a98':   return getScaledDataColorRgb('a98',    color[1], color[2], color[3])
        case 'pro':   return getScaledDataColorRgb('pro',    color[1], color[2], color[3])
        case 'r2020':  return getScaledDataColorRgb('r2020', color[1], color[2], color[3]);

        case 'hsv':   return getScaledDataColorHs_('hsv',    color[1], color[2], color[3]);
        case 'hsl':   return getScaledDataColorHs_('hsl',    color[1], color[2], color[3]);

        case 'hclok': return getScaledDataColorHcl('hclok',  color[1], color[2], color[3]);
        case 'hclab': return getScaledDataColorHcl('hclab',  color[1], color[2], color[3]);
        case 'hcluv': return getScaledDataColorHcl('hcluv',  color[1], color[2], color[3]);

        case 'oklab': return getScaledDataColorOpp('oklab',  color[1], color[2], color[3]);
        case 'lab':   return getScaledDataColorOpp('lab',    color[1], color[2], color[3]);
        case 'luv':   return getScaledDataColorOpp('luv',    color[1], color[2], color[3]);

        case 'xyz':   return getScaledDataColorXyz('xyz',    color[1], color[2], color[3]);
        case 'xyz50': return getScaledDataColorXyz('xyz50',  color[1], color[2], color[3]);
        case 'xyz65': return getScaledDataColorXyz('xyzd60', color[1], color[2], color[3]);
    }
}



function getScaledDataColorRgb(space, c1, c2, c3)
{
    return [
        space,
        c1 * rgbFactor[0], 
        c2 * rgbFactor[1], 
        c3 * rgbFactor[2] ];
}



function getScaledDataColorHs_(space, c1, c2, c3)
{
    return [
        space,
        c1 * hs_Factor[0], 
        c2 * hs_Factor[1], 
        c3 * hs_Factor[2] ];
}



function getScaledDataColorHcl(space, c1, c2, c3)
{
    return [
        space,
        c1 * hclFactor[0], 
        c2 * hclFactor[1], 
        c3 * hclFactor[2] ];
}



function getScaledDataColorOpp(space, c1, c2, c3)
{
    return [
        space,
        c1 * oppFactor[0], 
        c2 * oppFactor[1], 
        c3 * oppFactor[2] ];
}



function getScaledDataColorXyz(space, c1, c2, c3)
{
    return [
        space,
        c1 * xyzFactor[0], 
        c2 * xyzFactor[1], 
        c3 * xyzFactor[2] ];
}



function setDataColorToCurrentSpace(node, color)
{
    const toSpace = colorSpace(node.paramSpace.value);
    node._color   = convertDataColorToSpace(color, toSpace);

    node.setColorParams(node._color);
}



function colorSpaceFactor(space)
{
    switch (space)
    {
        case 'hex':
        case 'rgb':   
        case 'lin':
        case 'p3':
        case 'a98':
        case 'pro':
        case 'r2020': return rgbFactor;

        case 'hsv':   
        case 'hsl':   return hs_Factor;

        case 'hclok': 
        case 'hclab': 
        case 'hcluv': return hclFactor;

        case 'oklab': 
        case 'lab': 
        case 'luv':   return oppFactor;

        case 'xyz': 
        case 'xyz50': 
        case 'xyz65': return xyzFactor;
    }    
}



function getColorSpaceScale(space)
{
    switch (space)
    {
        case 'hex':
        case 'rgb':   
        case 'lin':
        case 'p3':
        case 'a98':
        case 'pro':
        case 'r2020': return rgbScale;

        case 'hsv':   
        case 'hsl':   return hs_Scale;

        case 'hclok': return hclokScale;
        case 'hclab': return hclabScale;
        case 'hcluv': return hcluvScale;

        case 'oklab': return oklabScale;
        case 'lab':   return labScale;
        case 'luv':   return luvScale;

        case 'xyz':
        case 'xyz50':
        case 'xyz65': return xyzScale;
    }    
}


function dataColor2array(color)
{
    return [
        color[1], 
        color[2], 
        color[3]];
}



function dataColor2rgb(color)
{
    const col = dataColor2array(color);

    switch (color[0])
    {
        case 'hex':
        case 'rgb':   return           col;

        case 'lin':   return lin2rgb  (col);
        case 'p3':    return p32rgb   (col);
        case 'a98':   return a982rgb  (col);
        case 'pro':   return pro2rgb  (col);
        case 'r2020': return r20202rgb(col);

        case 'hsv':   return hsv2rgb  (col);
        case 'hsl':   return hsl2rgb  (col);

        case 'hclok': return hclok2rgb(col);
        case 'hclab': return hclab2rgb(col);
        case 'hcluv': return hcluv2rgb(col);

        case 'oklab': return oklab2rgb(col);
        case 'lab':   return lab2rgb  (col);
        case 'luv':   return luv2rgb  (col);

        case 'xyz':   return xyz2rgb  (col);
        case 'xyz50': return xyz2rgb  (col, sRGB_D50);
        case 'xyz65': return xyz2rgb  (col);
    }
}



function convertDataColorToSpace(color, toSpace)
{
    switch (toSpace)
    {
        case 'hex':    
        case 'rgb':   return convert2rgb    (color);

        case 'lin':   return convert2lin    (color);
        case 'p3':    return convert2p3     (color);
        case 'a98':   return convert2a98    (color);
        case 'pro':   return convert2pro    (color);
        case 'r2020': return convert2r2020  (color);

        case 'hsv':   return convert2hsv    (color);
        case 'hsl':   return convert2hsl    (color);

        case 'hclok': return convert2hclok  (color);
        case 'hclab': return convert2hclab  (color);
        case 'hcluv': return convert2hcluv  (color);

        case 'oklab': return dataColor2oklab(color);
        case 'lab':   return convert2lab    (color);
        case 'luv':   return convert2luv    (color);

        case 'xyz':   return convert2xyz    (color);
        case 'xyz50': return convert2xyz50  (color);
        case 'xyz65': return convert2xyz65  (color);
    }
}



function convert2rgb(fromColor)
{
    const col = dataColor2array(fromColor);

    let rgb;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   rgb =           col ; break;

        case 'lin':   rgb = lin2rgb  (col); break;
        case 'p3':    rgb = p32rgb   (col); break;
        case 'a98':   rgb = a982rgb  (col); break;
        case 'pro':   rgb = pro2rgb  (col); break;
        case 'r2020': rgb = r20202rgb(col); break;

        case 'hsv':   rgb = hsv2rgb  (col); break;
        case 'hsl':   rgb = hsl2rgb  (col); break;

        case 'hclok': rgb = hclok2rgb(col); break;
        case 'hclab': rgb = hclab2rgb(col); break;
        case 'hcluv': rgb = hcluv2rgb(col); break;

        case 'oklab': rgb = oklab2rgb(col); break;
        case 'lab':   rgb = lab2rgb  (col); break;
        case 'luv':   rgb = luv2rgb  (col); break;

        case 'xyz':   rgb = xyz2rgb  (col);           break;
        case 'xyz50': rgb = xyz2rgb  (col, sRGB_D50); break;
        case 'xyz65': rgb = xyz2rgb  (col, sRGB_D65); break;
    }

    return rgb2dataColor(rgb);
}



function convert2lin(fromColor)
{
    const col = dataColor2array(fromColor);

    let lin;

    console.log('convert to lin');
    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   lin = rgb2lin          (col) ; break;

        case 'lin':   lin =                   col  ; break;
        case 'p3':    lin = rgb2lin(p32rgb   (col)); break;
        case 'a98':   lin = rgb2lin(a982rgb  (col)); break;
        case 'pro':   lin = rgb2lin(pro2rgb  (col)); break;
        case 'r2020': lin = rgb2lin(r20202rgb(col)); break;

        case 'hsv':   lin = rgb2lin(hsv2rgb  (col)); break;
        case 'hsl':   lin = rgb2lin(hsl2rgb  (col)); break;

        case 'hclok': lin = rgb2lin(hclok2rgb(col)); break;
        case 'hclab': lin = rgb2lin(hclab2rgb(col)); break;
        case 'hcluv': lin = rgb2lin(hcluv2rgb(col)); break;

        case 'oklab': lin = rgb2lin(oklab2rgb(col)); break;
        case 'lab':   lin = rgb2lin(lab2rgb  (col)); break;
        case 'luv':   lin = rgb2lin(luv2rgb  (col)); break;

        case 'xyz':   lin = xyz2lin          (col);           break;
        case 'xyz50': lin = xyz2lin          (col, sRGB_D50); break;
        case 'xyz65': lin = xyz2lin          (col, sRGB_D65); break;
    }

    return [
       'lin',
        lin[0],
        lin[1],
        lin[2] ];
}



function convert2p3(fromColor)
{
    const col = dataColor2array(fromColor);

    let p3;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   p3 = rgb2p3          (col) ; break;

        case 'lin':   p3 = rgb2p3(lin2rgb  (col)); break;
        case 'p3':    p3 =                  col  ; break;
        case 'a98':   p3 = rgb2p3(a982rgb  (col)); break;
        case 'pro':   p3 = rgb2p3(pro2rgb  (col)); break;
        case 'r2020': p3 = rgb2p3(r20202rgb(col)); break;

        case 'hsv':   p3 = rgb2p3(hsv2rgb  (col)); break;
        case 'hsl':   p3 = rgb2p3(hsl2rgb  (col)); break;

        case 'hclok': p3 = rgb2p3(hclok2rgb(col)); break;
        case 'hclab': p3 = rgb2p3(hclab2rgb(col)); break;
        case 'hcluv': p3 = rgb2p3(hcluv2rgb(col)); break;

        case 'oklab': p3 = rgb2p3(oklab2rgb(col)); break;
        case 'lab':   p3 = rgb2p3(lab2rgb  (col)); break;
        case 'luv':   p3 = rgb2p3(luv2rgb  (col)); break;

        case 'xyz':   p3 = rgb2p3(xyz2rgb  (col));           break;
        case 'xyz50': p3 = rgb2p3(xyz2rgb  (col, sRGB_D50)); break;
        case 'xyz65': p3 = rgb2p3(xyz2rgb  (col, sRGB_D65)); break;
    }

    return [
        'p3',
         p3[0],
         p3[1],
         p3[2] ];
 }



function convert2a98(fromColor)
{
    const col = dataColor2array(fromColor);

    let a98;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   a98 = rgb2a98          (col) ; break;

        case 'lin':   a98 = rgb2a98(lin2rgb  (col)); break;
        case 'p3':    a98 = rgb2a98(p32rgb   (col)); break;
        case 'a98':   a98 =                   col  ; break;
        case 'pro':   a98 = rgb2a98(pro2rgb  (col)); break;
        case 'r2020': a98 = rgb2a98(r20202rgb(col)); break;

        case 'hsv':   a98 = rgb2a98(hsv2rgb  (col)); break;
        case 'hsl':   a98 = rgb2a98(hsl2rgb  (col)); break;

        case 'hclok': a98 = rgb2a98(hclok2rgb(col)); break;
        case 'hclab': a98 = rgb2a98(hclab2rgb(col)); break;
        case 'hcluv': a98 = rgb2a98(hcluv2rgb(col)); break;

        case 'oklab': a98 = rgb2a98(oklab2rgb(col)); break;
        case 'lab':   a98 = rgb2a98(lab2rgb  (col)); break;
        case 'luv':   a98 = rgb2a98(luv2rgb  (col)); break;

        case 'xyz':   a98 = rgb2a98(xyz2rgb  (col));           break;
        case 'xyz50': a98 = rgb2a98(xyz2rgb  (col, sRGB_D50)); break;
        case 'xyz65': a98 = rgb2a98(xyz2rgb  (col, sRGB_D65)); break;
    }

    return [
        'a98',
         a98[0],
         a98[1],
         a98[2] ];
 }



function convert2pro(fromColor)
{
    const col = dataColor2array(fromColor);

    let pro;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   pro = rgb2pro          (col) ; break;

        case 'lin':   pro = rgb2pro(lin2rgb  (col)); break;
        case 'p3':    pro = rgb2pro(p32rgb   (col)); break;
        case 'a98':   pro = rgb2pro(a982rgb  (col)); break;
        case 'pro':   pro =                   col  ; break;
        case 'r2020': pro = rgb2pro(r20202rgb(col)); break;

        case 'hsv':   pro = rgb2pro(hsv2rgb  (col)); break;
        case 'hsl':   pro = rgb2pro(hsl2rgb  (col)); break;

        case 'hclok': pro = rgb2pro(hclok2rgb(col)); break;
        case 'hclab': pro = rgb2pro(hclab2rgb(col)); break;
        case 'hcluv': pro = rgb2pro(hcluv2rgb(col)); break;

        case 'oklab': pro = rgb2pro(oklab2rgb(col)); break;
        case 'lab':   pro = rgb2pro(lab2rgb  (col)); break;
        case 'luv':   pro = rgb2pro(luv2rgb  (col)); break;

        case 'xyz':   pro = rgb2pro(xyz2rgb  (col));           break;
        case 'xyz50': pro = rgb2pro(xyz2rgb  (col, sRGB_D50)); break;
        case 'xyz65': pro = rgb2pro(xyz2rgb  (col, sRGB_D65)); break;
    }

    return [
        'pro',
         pro[0],
         pro[1],
         pro[2] ];
}



function convert2r2020(fromColor)
{
    const col = dataColor2array(fromColor);

    let r2020;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   r2020 = rgb2r2020          (col) ; break;

        case 'lin':   r2020 = rgb2r2020(lin2rgb  (col)); break;
        case 'p3':    r2020 = rgb2r2020(p32rgb   (col)); break;
        case 'a98':   r2020 = rgb2r2020(a982rgb  (col)); break;
        case 'pro':   r2020 = rgb2r2020(r20202rgb(col)); break;
        case 'r2020': r2020 =                     col  ; break;

        case 'hsv':   r2020 = rgb2r2020(hsv2rgb  (col)); break;
        case 'hsl':   r2020 = rgb2r2020(hsl2rgb  (col)); break;

        case 'hclok': r2020 = rgb2r2020(hclok2rgb(col)); break;
        case 'hclab': r2020 = rgb2r2020(hclab2rgb(col)); break;
        case 'hcluv': r2020 = rgb2r2020(hcluv2rgb(col)); break;

        case 'oklab': r2020 = rgb2r2020(oklab2rgb(col)); break;
        case 'lab':   r2020 = rgb2r2020(lab2rgb  (col)); break;
        case 'luv':   r2020 = rgb2r2020(luv2rgb  (col)); break;

        case 'xyz':   r2020 = rgb2r2020(xyz2rgb  (col));           break;
        case 'xyz50': r2020 = rgb2r2020(xyz2rgb  (col, sRGB_D50)); break;
        case 'xyz65': r2020 = rgb2r2020(xyz2rgb  (col, sRGB_D65)); break;
    }

    return [
        'r2020',
         r2020[0],
         r2020[1],
         r2020[2] ];
}



function convert2hsv(fromColor)
{
    const col = dataColor2array(fromColor);
    
    let hsv;
    
    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   hsv = rgb2hsv(          col ); break;

        case 'lin':   hsv = rgb2hsv(lin2rgb  (col)); break;                  col  ; break;
        case 'p3':    hsv = rgb2hsv(p32rgb   (col)); break;
        case 'a98':   hsv = rgb2hsv(a982rgb  (col)); break;
        case 'pro':   hsv = rgb2hsv(pro2rgb  (col)); break;
        case 'r2020': hsv = rgb2hsv(r20202rgb(col)); break;

        case 'hsv':   hsv =                   col;   break;
        case 'hsl':   hsv = rgb2hsv(hsl2rgb  (col)); break;

        case 'hclok': hsv = rgb2hsv(hclok2rgb(col)); break;
        case 'hclab': hsv = rgb2hsv(hclab2rgb(col)); break;
        case 'hcluv': hsv = rgb2hsv(hcluv2rgb(col)); break;

        case 'oklab': hsv = rgb2hsv(oklab2rgb(col)); break;
        case 'lab':   hsv = rgb2hsv(lab2rgb  (col)); break;
        case 'luv':   hsv = rgb2hsv(luv2rgb  (col)); break;

        case 'xyz':   hsv = rgb2hsv(xyz2rgb  (col));           break;
        case 'xyz50': hsv = rgb2hsv(xyz2rgb  (col, sRGB_D50)); break;
        case 'xyz65': hsv = rgb2hsv(xyz2rgb  (col, sRGB_D65)); break;
    }
    
    if (isNaN(hsv[0]))
        hsv[0] = 5/6;
    
    return [
       'hsv',
        hsv[0],
        hsv[1],
        hsv[2] ];
}



function convert2hsl(fromColor)
{
    const col = dataColor2array(fromColor);

    let hsl;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   hsl = rgb2hsl(          col ); break;

        case 'lin':   hsl = rgb2hsl(lin2rgb  (col)); break;                  col  ; break;
        case 'p3':    hsl = rgb2hsl(p32rgb   (col)); break;
        case 'a98':   hsl = rgb2hsl(a982rgb  (col)); break;
        case 'pro':   hsl = rgb2hsl(pro2rgb  (col)); break;
        case 'r2020': hsl = rgb2hsl(r20202rgb(col)); break;

        case 'hsv':   hsl = rgb2hsl(hsv2rgb  (col)); break;
        case 'hsl':   hsl =                   col;   break;

        case 'hclok': hsl = rgb2hsl(hclok2rgb(col)); break;
        case 'hclab': hsl = rgb2hsl(hclab2rgb(col)); break;
        case 'hcluv': hsl = rgb2hsl(hcluv2rgb(col)); break;

        case 'oklab': hsl = rgb2hsl(oklab2rgb(col)); break;
        case 'lab':   hsl = rgb2hsl(lab2rgb  (col)); break;
        case 'luv':   hsl = rgb2hsl(luv2rgb  (col)); break;

        case 'xyz':   hsl = rgb2hsl(xyz2rgb  (col));           break;
        case 'xyz50': hsl = rgb2hsl(xyz2rgb  (col, sRGB_D50)); break;
        case 'xyz65': hsl = rgb2hsl(xyz2rgb  (col, sRGB_D65)); break;
    }

    return [
       'hsl',
        hsl[0],
        hsl[1],
        hsl[2] ];
}



function dataColor2oklab(fromColor)
{
    const col = dataColor2array(fromColor);

    let lab;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   lab = rgb2oklab(          col ); break;

        case 'lin':   lab = rgb2oklab(lin2rgb  (col)); break;                  col  ; break;
        case 'p3':    lab = rgb2oklab(p32rgb   (col)); break;
        case 'a98':   lab = rgb2oklab(a982rgb  (col)); break;
        case 'pro':   lab = rgb2oklab(pro2rgb  (col)); break;
        case 'r2020': lab = rgb2oklab(r20202rgb(col)); break;

        case 'hsv':   lab = rgb2oklab(hsv2rgb  (col)); break;
        case 'hsl':   lab = rgb2oklab(hsl2rgb  (col)); break;

        case 'hclok': lab = rgb2oklab(hclok2rgb(col)); break;
        case 'hclab': lab = rgb2oklab(hclab2rgb(col)); break;
        case 'hcluv': lab = rgb2oklab(hcluv2rgb(col)); break;

        case 'oklab': lab =                     col;   break;
        case 'lab':   lab = rgb2oklab(lab2rgb  (col)); break;
        case 'luv':   lab = rgb2oklab(luv2rgb  (col)); break;

        case 'xyz':   lab = rgb2oklab(xyz2rgb  (col));           break;
        case 'xyz50': lab = rgb2oklab(xyz2rgb  (col, sRGB_D50)); break;
        case 'xyz65': lab = rgb2oklab(xyz2rgb  (col, sRGB_D65)); break;
    }

    return [
       'oklab',
        lab[0],
        lab[1],
        lab[2] ];
}



function convert2lab(fromColor)
{
    const col = dataColor2array(fromColor);

    let lab;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   lab = rgb2lab(          col ); break;

        case 'lin':   lab = rgb2lab(lin2rgb  (col)); break;                  col  ; break;
        case 'p3':    lab = rgb2lab(p32rgb   (col)); break;
        case 'a98':   lab = rgb2lab(a982rgb  (col)); break;
        case 'pro':   lab = rgb2lab(pro2rgb  (col)); break;
        case 'r2020': lab = rgb2lab(r20202rgb(col)); break;
        case 'hsv':   lab = rgb2lab(hsv2rgb  (col)); break;

        case 'hsl':   lab = rgb2lab(hsl2rgb  (col)); break;

        case 'hclok': lab = rgb2lab(hclok2rgb(col)); break;
        case 'hclab': lab =         hclab2lab(col);  break;
        case 'hcluv': lab = rgb2lab(hcluv2rgb(col)); break;

        case 'oklab': lab = rgb2lab(oklab2rgb(col)); break;
        case 'lab':   lab =                   col;   break;
        case 'luv':   lab = rgb2lab(luv2rgb  (col)); break;

        case 'xyz':   lab = xyz2lab          (col, sRGB.W);     break;
        case 'xyz50': lab = xyz2lab          (col, sRGB_D50.W); break;
        case 'xyz65': lab = xyz2lab          (col, sRGB_D65.W); break;
    }

    return [
       'lab',
        lab[0],
        lab[1],
        lab[2] ];
}



function convert2luv(fromColor)
{
    const col = dataColor2array(fromColor);

    let luv;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   luv = rgb2luv(          col ); break;

        case 'lin':   luv = rgb2luv(lin2rgb  (col)); break;                  col  ; break;
        case 'p3':    luv = rgb2luv(p32rgb   (col)); break;
        case 'a98':   luv = rgb2luv(a982rgb  (col)); break;
        case 'pro':   luv = rgb2luv(pro2rgb  (col)); break;
        case 'r2020': luv = rgb2luv(r20202rgb(col)); break;

        case 'hsv':   luv = rgb2luv(hsv2rgb  (col)); break;
        case 'hsl':   luv = rgb2luv(hsl2rgb  (col)); break;

        case 'hclok': luv = rgb2luv(hclok2rgb(col)); break;
        case 'hclab': luv = rgb2luv(hclab2rgb(col)); break;
        case 'hcluv': luv =         hcluv2luv(col);  break;

        case 'oklab': luv = rgb2luv(oklab2rgb(col)); break;
        case 'lab':   luv = rgb2luv(lab2rgb  (col)); break;
        case 'luv':   luv =                   col;   break;

        case 'xyz':   luv = xyz2luv          (col, sRGB.W);     break;
        case 'xyz50': luv = xyz2luv          (col, sRGB_D50.W); break;
        case 'xyz65': luv = xyz2luv          (col, sRGB_D65.W); break;
    }

    return [
       'luv',
        luv[0],
        luv[1],
        luv[2] ];
}



function convert2hclok(fromColor)
{
    const col = dataColor2array(fromColor);

    let hcl;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   hcl = rgb2hclok(          col);  break;

        case 'lin':   hcl = rgb2hclok(lin2rgb  (col)); break;                  col  ; break;
        case 'p3':    hcl = rgb2hclok(p32rgb   (col)); break;
        case 'a98':   hcl = rgb2hclok(a982rgb  (col)); break;
        case 'pro':   hcl = rgb2hclok(pro2rgb  (col)); break;
        case 'r2020': hcl = rgb2hclok(r20202rgb(col)); break;

        case 'hsv':   hcl = rgb2hclok(hsv2rgb  (col)); break;
        case 'hsl':   hcl = rgb2hclok(hsl2rgb  (col)); break;

        case 'hclok': hcl =                     col;   break;
        case 'hclab': hcl = rgb2hclok(hclab2rgb(col)); break;
        case 'hcluv': hcl = rgb2hclok(hcluv2rgb(col)); break;

        case 'oklab': hcl = rgb2hclok(oklab2rgb(col)); break;
        case 'lab':   hcl = rgb2hclok(lab2rgb  (col)); break;
        case 'luv':   hcl = rgb2hclok(luv2rgb  (col)); break;

        case 'xyz':   hcl = rgb2hclok(xyz2rgb  (col));           break;
        case 'xyz50': hcl = rgb2hclok(xyz2rgb  (col, sRGB_D50)); break;
        case 'xyz65': hcl = rgb2hclok(xyz2rgb  (col, sRGB_D65)); break;
    }

    return [
       'hclok',
        hcl[0],
        hcl[1],
        hcl[2] ];
}



function convert2hclab(fromColor)
{
    const col = dataColor2array(fromColor);

    let lab;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   lab = rgb2hclab(          col) ; break;
        
        case 'lin':   lab = rgb2hclab(lin2rgb  (col)); break;                  col  ; break;
        case 'p3':    lab = rgb2hclab(p32rgb   (col)); break;
        case 'a98':   lab = rgb2hclab(a982rgb  (col)); break;
        case 'pro':   lab = rgb2hclab(pro2rgb  (col)); break;
        case 'r2020': lab = rgb2hclab(r20202rgb(col)); break;

        case 'hsv':   lab = rgb2hclab(hsv2rgb  (col)); break;
        case 'hsl':   lab = rgb2hclab(hsl2rgb  (col)); break;
        
        case 'hclok': lab = rgb2hclab(hclok2rgb(col)); break;
        case 'hclab': lab =                     col;   break;
        case 'hcluv': lab = rgb2hclab(hcluv2rgb(col)); break;
        
        case 'oklab': lab = rgb2hclab(oklab2rgb(col)); break;
        case 'lab':   lab = lab2hclab(          col ); break;
        case 'luv':   lab = rgb2hclab(luv2rgb  (col)); break;

        case 'xyz':   lab = rgb2hclab(xyz2rgb  (col));           break;
        case 'xyz50': lab = rgb2hclab(xyz2rgb  (col, sRGB_D50)); break;
        case 'xyz65': lab = rgb2hclab(xyz2rgb  (col, sRGB_D65)); break;
    }

    return [
       'hclab',
        lab[0],
        lab[1],
        lab[2] ];
}



function convert2hcluv(fromColor)
{
    const col = dataColor2array(fromColor);

    let hcl;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   hcl = rgb2hcluv(          col ); break;

        case 'lin':   hcl = rgb2hcluv(lin2rgb  (col)); break;                  col  ; break;
        case 'p3':    hcl = rgb2hcluv(p32rgb   (col)); break;
        case 'a98':   hcl = rgb2hcluv(a982rgb  (col)); break;
        case 'pro':   hcl = rgb2hcluv(pro2rgb  (col)); break;
        case 'r2020': hcl = rgb2hcluv(r20202rgb(col)); break;

        case 'hsv':   hcl = rgb2hcluv(hsv2rgb  (col)); break;
        case 'hsl':   hcl = rgb2hcluv(hsl2rgb  (col)); break;

        case 'hclab': hcl = rgb2hcluv(hclab2rgb(col)); break;
        case 'hcluv': hcl =                     col;   break;
        case 'hclok': hcl = rgb2hcluv(hclok2rgb(col)); break;

        case 'oklab': hcl = rgb2hcluv(oklab2rgb(col)); break;
        case 'lab':   hcl = rgb2hcluv(lab2rgb  (col)); break;
        case 'luv':   hcl = luv2hcluv(          col ); break;

        case 'xyz':   hcl = rgb2hcluv(xyz2rgb  (col));           break;
        case 'xyz50': hcl = rgb2hcluv(xyz2rgb  (col, sRGB_D50)); break;
        case 'xyz65': hcl = rgb2hcluv(xyz2rgb  (col, sRGB_D65)); break;
    }

    return [
       'hcluv',
        hcl[0],
        hcl[1],
        hcl[2] ];
}



function convert2xyz(fromColor)
{
    const col = dataColor2array(fromColor);

    let xyz;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   xyz = rgb2xyz(          col ); break;

        case 'lin':   xyz = rgb2xyz(lin2rgb  (col)); break;                  col  ; break;
        case 'p3':    xyz = rgb2xyz(p32rgb   (col)); break;
        case 'a98':   xyz = rgb2xyz(a982rgb  (col)); break;
        case 'pro':   xyz = rgb2xyz(pro2rgb  (col)); break;
        case 'r2020': xyz = rgb2xyz(r20202rgb(col)); break;

        case 'hsv':   xyz = rgb2xyz(hsv2rgb  (col)); break;
        case 'hsl':   xyz = rgb2xyz(hsl2rgb  (col)); break;

        case 'hclab': xyz = rgb2xyz(hclab2rgb(col)); break;
        case 'hcluv': xyz = rgb2xyz(hclab2rgb(col)); break;
        case 'hclok': xyz = rgb2xyz(hclok2rgb(col)); break;

        case 'oklab': xyz = rgb2xyz(oklab2rgb(col)); break;
        case 'lab':   xyz = lab2xyz(          col, sRGB.W); break;
        case 'luv':   xyz = luv2xyz(          col, sRGB.W); break;

        case 'xyz':   xyz =                   col;             break;
        case 'xyz50': xyz = rgb2xyz(xyz2rgb  (col, sRGB_D50)); break;
        case 'xyz65': xyz = rgb2xyz(xyz2rgb  (col, sRGB_D65)); break;
    }

    return [
       'xyz',
        xyz[0],
        xyz[1],
        xyz[2] ];
}



function convert2xyz50(fromColor)
{
    const col = dataColor2array(fromColor);

    let xyz;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   xyz = rgb2xyz(          col,  sRGB_D50);    break;

        case 'lin':   xyz = rgb2xyz(lin2rgb  (col), sRGB_D50);   break;                  col  ; break;
        case 'p3':    xyz = rgb2xyz(p32rgb   (col), sRGB_D50);   break;
        case 'a98':   xyz = rgb2xyz(a982rgb  (col), sRGB_D50);   break;
        case 'pro':   xyz = rgb2xyz(pro2rgb  (col), sRGB_D50);   break;
        case 'r2020': xyz = rgb2xyz(r20202rgb(col), sRGB_D50);   break;

        case 'hsv':   xyz = rgb2xyz(hsv2rgb  (col), sRGB_D50);   break;
        case 'hsl':   xyz = rgb2xyz(hsl2rgb  (col), sRGB_D50);   break;

        case 'hclab': xyz = rgb2xyz(hclab2rgb(col), sRGB_D50);   break;
        case 'hcluv': xyz = rgb2xyz(hclab2rgb(col), sRGB_D50);   break;
        case 'hclok': xyz = rgb2xyz(hclok2rgb(col), sRGB_D50);   break;

        case 'oklab': xyz = rgb2xyz(oklab2rgb(col), sRGB_D50);   break;
        case 'lab':   xyz = lab2xyz(          col,  sRGB_D50.W); break;
        case 'luv':   xyz = luv2xyz(          col,  sRGB_D50.W); break;

        case 'xyz':   xyz = rgb2xyz(xyz2rgb  (col), sRGB_D50);   break;
        case 'xyz50': xyz =                   col;               break;
        case 'xyz65': xyz = rgb2xyz(xyz2rgb  (col), sRGB_D50);   break;
    }

    return [
       'xyz50',
        xyz[0],
        xyz[1],
        xyz[2] ];
}



function convert2xyz65(fromColor)
{
    const col = dataColor2array(fromColor);

    let xyz;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   xyz = rgb2xyz(          col,  sRGB_D65);    break;

        case 'lin':   xyz = rgb2xyz(lin2rgb  (col), sRGB_D65);   break;                  col  ; break;
        case 'p3':    xyz = rgb2xyz(p32rgb   (col), sRGB_D65);   break;
        case 'a98':   xyz = rgb2xyz(a982rgb  (col), sRGB_D65);   break;
        case 'pro':   xyz = rgb2xyz(pro2rgb  (col), sRGB_D65);   break;
        case 'r2020': xyz = rgb2xyz(r20202rgb(col), sRGB_D65);   break;

        case 'hsv':   xyz = rgb2xyz(hsv2rgb  (col), sRGB_D65);   break;
        case 'hsl':   xyz = rgb2xyz(hsl2rgb  (col), sRGB_D65);   break;

        case 'hclab': xyz = rgb2xyz(hclab2rgb(col), sRGB_D65);   break;
        case 'hcluv': xyz = rgb2xyz(hclab2rgb(col), sRGB_D65);   break;
        case 'hclok': xyz = rgb2xyz(hclok2rgb(col), sRGB_D65);   break;

        case 'oklab': xyz = rgb2xyz(oklab2rgb(col), sRGB_D65);   break;
        case 'lab':   xyz = lab2xyz(          col,  sRGB_D65.W); break;
        case 'luv':   xyz = luv2xyz(          col,  sRGB_D65.W); break;

        case 'xyz':   xyz = rgb2xyz(xyz2rgb  (col), sRGB_D65);   break;
        case 'xyz50': xyz = rgb2xyz(xyz2rgb  (col, sRGB_D50), sRGB_D65);   break;
        case 'xyz65': xyz =                   col;               break;
    }

    return [
       'xyz65',
        xyz[0],
        xyz[1],
        xyz[2] ];
}


</script>