<script id="generatorScript" type="javascript/worker"> 'use strict';  


const generatorVersion = 439;   const g869        = 2147483647;    const NULL             = '';    const x870             = '  ';  const f871              = '    '; const j872               = '\n';    const q873   = '◦ G •'; const p874    = q873 + ' ';  const c875          = 'G_NODE'; const n876          = 'G_CONN'; const w877          = 'G_PAGE'; const z878          = 'G_TEMP';  const minWindowWidth   = 602; const minWindowHeight  =  39;   const identity = Object.freeze(     [[1, 0, 0],      [0, 1, 0],      [0, 0, 1]]);    const Epsilon = 0.0000001; const Tau     = Math.PI * 2;    var enableAsserts = false;    function y879(x, eps = 0.000000001)  {      return Math.abs(x) < eps ? 0 : x; }    function nozero(x, eps = 0.000000001)  {      return x != 0           ? x           : (x < 0 ? -eps : eps); }    function b880(v, eps = 0.000000001)  {      return point(         nozero(v.x, eps),          nozero(v.y, eps));  }    function equal(a, b, eps = 0.000000001) {     return Math.abs(b - a) < eps; }    function sqr (x) { return x*x;   }; function cube(x) { return x*x*x; };    function y881(f) { return Math.floor(f) | 0; }    function m882(x) {     x = y881(x);      x--;      x |= x >>  1;     x |= x >>  2;     x |= x >>  4;     x |= x >>  8;     x |= x >> 16;     x |= x >> 32;      return ++x; }    function gcd(a, b) {     let temp;     while (1)     {         temp = a % b;          if (temp == 0)           return b;          a = b;         b = temp;     } }    function distv(p1, p2) {     const dx = p2.x - p1.x;     const dy = p2.y - p1.y;      return Math.sqrt(dx*dx + dy*dy); }    function p883(v) {     let angle = Math.atan2(v.y, v.x);     if (angle < 0) angle += Tau;      return angle; }    function anglev2(v1, v2) {     return anglev2_(v1.x, v1.y, v2.x, v2.y); }    function anglev2_(x1, y1, x2, y2) {     const dx = x2 - x1;     const dy = y2 - y1;      let angle = Math.atan2(dy, dx);     if (angle < 0) angle += Tau;      return angle; }    function m885(v) {     return Math.sqrt(v.x*v.x + v.y*v.y); }    function lengthv_(x, y) {     return Math.sqrt(x*x + y*y); }    function o886(v) {     return point(         v.x == 0 ? 0 : v.x / m885(v),         v.y == 0 ? 0 : v.y / m885(v)); }    function dotv(v1, v2) {     return v1.x * v2.x + v1.y * v2.y; }    function q887(a1, a2) {     let diff = a2 - a1;      while (diff <= -Tau/2) diff += Tau;     while (diff >   Tau/2) diff -= Tau;      return diff;  }    function e888(v, m) {     let v3 = [v.x, v.y, 1];     let r  = j948(v3, m);      return point(r[0], r[1]); }    function c889(...mm) {     l952(mm.length > 0, 'mulm3m3() must take at least one argument');      let result = clone(mm[0]);      for (let a = 1; a < mm.length; a++)     {         const m1 = result;         const m2 = mm[a];          const m = [[0, 0, 0],                    [0, 0, 0],                    [0, 0, 0]];          for (let i = 0; i < 3; i++)         {             for (let j = 0; j < 3; j++)             {                                  for (let k = 0; k < 3; k++)                     m[i][j] += m1[i][k] * m2[k][j];             }         }          result = m;     }      return result; }    function r890(m, s) {     for (let i = 0; i < 3; i++)         for (let j = 0; j < 3; j++)             m[i][j] /= s;      return m; }    function adjugate(m) {     return cofactor(transpose(m)); }    function transpose(m) {     return [[m[0][0], m[1][0], m[2][0]],             [m[0][1], m[1][1], m[2][1]],             [m[0][2], m[1][2], m[2][2]]]; }    function cofactor(m) {     return [[  m[1][1] * m[2][2] - m[2][1] * m[1][2], -(m[1][0] * m[2][2] - m[2][0] * m[1][2]),  m[1][0] * m[2][1] - m[2][0] * m[1][1] ],             [-(m[0][1] * m[2][2] - m[2][1] * m[0][2]),  m[0][0] * m[2][2] - m[2][0] * m[0][2], -(m[0][0] * m[2][1] - m[2][0] * m[0][1])],             [  m[0][1] * m[1][2] - m[1][1] * m[0][2], -(m[0][0] * m[1][2] - m[1][0] * m[0][2]),  m[0][0] * m[1][1] - m[1][0] * m[0][1] ]];  }    function determinant(m) {     return   m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1])            - m[0][1] * (m[1][0] * m[2][2] - m[2][0] * m[1][2])            + m[0][2] * (m[1][0] * m[2][1] - m[2][0] * m[1][1]); }    function f891(m) {     return r890(adjugate(m), determinant(m)); }    function e892(angle) {     const cosA = y879(Math.cos(angle));     const sinA = y879(Math.sin(angle));      return [[ cosA, sinA, 0],             [-sinA, cosA, 0],             [ 0,    0,    1]]; }    function r893(x = 0, y = 0, scaleX = 1, scaleY = 1, angle = 0, skewX = 0, skewY = 0) {     const cosA = Math.cos(angle);     const sinA = Math.sin(angle);      return [[scaleX*cosA -  skewY*sinA, -skewX*cosA + scaleY*sinA, x],             [ skewY*cosA + scaleX*sinA, scaleY*cosA +  skewX*sinA, y],             [0,                         0,                         1]]; }    function h894(v1, v2) {                               return v1.x * v2.y - v1.y * v2.x; }	    function y895(v1, v2) {     return point(         v1.x + v2.x,         v1.y + v2.y); }	    function sqrv(v) {     return m896(v, v); }    function m896(v1, v2) {     return point(         v1.x * v2.x,         v1.y * v2.y); }	    function x897(v, s) {     return point(         v.x * s,         v.y * s); }	    function r898(v1, v2) {     return point(         v1.x / v2.x,         v1.y / v2.y); }	    function a899(v, s) {     return point(         v.x / s,         v.y / s); }	    function a900(v1, v2) {     return point(         v1.x - v2.x,         v1.y - v2.y); }	    function v901(str)  {     return decodeURI(encodeURIComponent(str)); }    function y902(str)  {     return decodeURIComponent(encodeURI(str)); }    function r903(bytes)  {     let str = '';      for (let i = 0; i < bytes.length; i++)         str += String.fromCharCode(bytes[i]);      return str; }    function j904(str) {     return Array.from(y902(str), c => c.charCodeAt(0)); }    function z905(array, size)  {     const newArray = new Uint8Array(size);     o906(array, newArray);     return newArray; }    function o906(src, dst) {     r907(         src, 0, src.length,         dst, 0, dst.length); }    function r907(src, t908, w909, dst, v910, z911) {     const size = Math.min(w909, z911);      for (let i = 0; i < size; i++)         dst[v910 + i] = src[t908 + i]; }    function g912(n913, h914) {     if (n913.length != h914.length)         return false;      for (let i = 0; i < n913.length; i++)     {         if (n913[i] != h914[i])             return false;     }      return true; }    function s915(j916, f917) {     return j916.findIndex(i => f917.includes(i)) > -1; }    function  m918(list) { return list ? '<==' : '<--'; };  function h919(list) { return list ? '==>' : '-->'; };   function q920(nodeId) { return c875 + ' ' + nodeId; } function a921(name)   { return n876 + ' ' + name;   } function g922(name)   { return w877 + ' ' + name;   }    function r923(str)  {      return str.toLowerCase() == 'true'         || str == '1'; }    function o924(s925, a926 = false) {     return p931(         s925.outputNodeId,         s925.outputId,         s925.outputOrder,         s925.inputNodeId,         s925.inputId,         s925.list,         a926); }    function s927(outputNodeId, outputId, outputOrder, inputNodeId, inputId) {     return a921(           outputNodeId + ' '         + outputId     + ' '         + outputOrder  + ' '         + inputNodeId  + ' '         + inputId); }    function i928(i243) {     return s927(         i243.outputNodeId,         i243.outputId,         i243.outputOrder,         i243.inputNodeId,         i243.inputId); }    function r929(i243) {     return s927(         i243.output.node.id,         i243.output.id,         i243.outputOrder,         i243.input.node.id,         i243.input.id); }    function q930(i243, a926 = false) {     return p931(         i243.output.node.id,         i243.output.id,         i243.outputOrder,         i243.input.node.id,         i243.input.id,         i243.list,         a926); }    function p931(outputNodeId, outputId, outputOrder, inputNodeId, inputId, list, a926 = false) {     const  sp   = a926 ? ' ' : '  ';      const jsp   = a926 ? ''  : ' ';       const arrow =            sp          + f935(typeof outputOrder == 'string' ? parseInt(outputOrder) : outputOrder)          + h919(typeof list == 'string' ? r923(list) : list)          + sp;      const join  = jsp + '.' + jsp;      return  outputNodeId + join + outputId          + arrow          + inputNodeId  + join + inputId;           }    function f932(pageId) {     return g922(pageId); }    function y933(num) {     const str = num.toString();      let sup = '';      for (const c of str)         sup += y934(c);      return sup; }    function y934(c) {     switch (c)     {         case '0': return '⁰';         case '1': return '¹';         case '2': return '²';         case '3': return '³';         case '4': return '⁴';         case '5': return '⁵';         case '6': return '⁶';         case '7': return '⁷';         case '8': return '⁸';         case '9': return '⁹';         case '.': return '·';     } }    function f935(num) {     const str = num.toString();      let sup = '';      for (const c of str)         sup += a936(c);      return sup; }    function a936(c) {     switch (c)     {         case '0': return '₀';         case '1': return '₁';         case '2': return '₂';         case '3': return '₃';         case '4': return '₄';         case '5': return '₅';         case '6': return '₆';         case '7': return '₇';         case '8': return '₈';         case '9': return '₉';         case '.': return ' ';     } }    function u937(bool) {     return bool ? 'true' : 'false'; }    function isValid(val) {     return val != undefined         && val != null; }    function isEmpty(array) {     return array.length == 0; }    function g938(array, item) {     j939(array, array.indexOf(item)); }    function j939(array, index) {     if (   index > -1          && index < array.length)         array.splice(index, 1); }    function x940(array) {     if (isEmpty(array))         return null;      let last = array.at(-1);     array.splice(array.length-1, 1);      return last; }    function x941(array) {     return array[array.length-1]; }    function x942(array, from, to)  {     const item = array[from];     array.splice(from, 1);     array.splice(to, 0, item); }    function h943(array, item) {     const index = array.indexOf(item);          if (index > -1)         array.splice(index, 1); }    function h944(i2796, array) {     for (const item of array)     {         const index = i2796.indexOf(item);                  if (index > -1)             i2796.splice(index, 1);     } }    function s945(array, where) {     const index = array.findIndex(where);          if (index > -1)         array.splice(index, 1); }    function y946(styleId) {     return styleId.split(',')[0] + ','; }    function r947(points) {     let p4032 = '';       if (points.length < 2)         return p4032;       p4032 += 'M';     p4032 += ' ' + y879(points[0].x);     p4032 += ' ' + y879(points[0].y);      for (let i = 1; i < points.length; i++)     {         p4032 +=                ' L'             + ' ' + y879(points[i].x)             + ' ' + y879(points[i].y);     }       return p4032; }    function point(x, y) { return {x: x, y: y}; }    function j948(v, m) {     let r = [0, 0, 0];      for (let i = 0; i < 3; i++)         for (let j = 0; j < 3; j++)             r[i] += v[j] * m[i][j];      return r; }    function clone(val)  {     const type = typeof val;          if (val === null)        return null;      else if (type === 'undefined'            || type === 'number'            || type === 'string'            || type === 'boolean')          return val;      else if (type === 'object')      {         if (val instanceof Array)              return val.map(x => clone(x));          else if (val instanceof Uint8Array)              return new Uint8Array(val);          else          {             let a111 = {};              for (const key in val)                  a111[key] = clone(val[key]);              return a111;         }     }      throw 'unknown'; }    function p949(array, item, equal = null) {     if (equal)     {         if (Array.isArray(item))             item.forEach(i => p949(array, i, equal));         else if (!array.find(i => equal(i, item)))             array.push(item);     }     else     {         if (Array.isArray(item))             item.forEach(i => p949(array, i));         else if (!array.includes(item))             array.push(item);     } }    function o950(array, item, equal) {     if (Array.isArray(item))         item.forEach(i => o950(array, i, equal));     else if (!array.find(equal))         array.push(item); }    function h951(array, item, except) {     if (Array.isArray(item))         item.forEach(i => h951(array, i, except));     else if (!array.find(except))         array.push(item); }    function l952(...args) {               if (enableAsserts)     {         console.assert(...args);              } }    function j953(...args) {               if (enableAsserts)         console.error(...args); }    function k954(str, trim)  {     while (str.length >= trim.length         && str.substring(0, trim.length) == trim)          str = str.substring(trim.length);      return str; }    function a955(str, trim)  {     while (str.length >= trim.length         && str.substring(str.length - trim.length) == trim)          str = str.substring(0, str.length - trim.length);      return str; }    function p956(e4092) {     const fills = [];       for (const fill of e4092)     {         switch (fill[0])         {             case 'SOLID':             {                 const color = {                     r: Math.min(Math.max(0, fill[1] / 0xff), 1),                      g: Math.min(Math.max(0, fill[2] / 0xff), 1),                      b: Math.min(Math.max(0, fill[3] / 0xff), 1) };                  const opacity = Math.min(Math.max(0, fill[4] / 100), 1);                   if (   !isNaN(color.r)                     && !isNaN(color.g)                     && !isNaN(color.b)                     && !isNaN(opacity))                     fills.push(                     {                         type:      fill[0],                          color:     color,                         opacity:   opacity,                         blendMode: fill[5]                     });                   break;             }              case 'GRADIENT_LINEAR':             case 'GRADIENT_RADIAL':             case 'GRADIENT_ANGULAR':             case 'GRADIENT_DIAMOND':             {                 const [p0, p1, p2] = fill[1];                  const k4207 =                      [[0,   1,   0],                      [0.5, 0.5, 1],                      [1,   1,   1]];                  let h4208 = [                     [p0.x, p1.x, p2.x],                     [p0.y, p1.y, p2.y],                     [1,    1,    1   ]];                  h4208 = c889(k4207, f891(h4208));                 h4208 = [h4208[0], h4208[1]];                   const stops = [];                  for (const stop of fill[2])                 {                     stops.push({                         color:                          {                             r: Math.min(Math.max(0, stop[0]), 1),                             g: Math.min(Math.max(0, stop[1]), 1),                             b: Math.min(Math.max(0, stop[2]), 1),                             a: Math.min(Math.max(0, stop[3]), 1)                         },                         position: stop[4]                     });                   }                   fills.push(                 {                     type:              fill[0],                     gradientTransform: h4208,                     gradientStops:     stops,                     blendMode:         fill[3]                 });                   break;             }         }     }       return fills; }    function g957(type) {     return x1089.includes(type); }


function c958(type, active) {     return r959(type, active, o4007); }    function r959(type, active, o4007) {     if (p1166.includes(type))         return active              ? (o4007 ? a2429 : m2419)             : (o4007 ? r2430       : k2420      );      else if (r1167.includes(type))         return active              ? (o4007 ? x2435   : h2425)             : (o4007 ? u2436         : x2426      );      else if (z1296.includes(type)          || e1214.includes(type))         return active              ? (o4007 ? j2433  : x2423)             : (o4007 ? z2434        : a2424      );      else if (f1300.includes(type))         return active              ? (o4007 ? u2431  : n2421)             : (o4007 ? s2432        : y2422      );      else if (d1090.includes(type)           || type == u1087)         return active              ? (o4007 ? t2427   : g2417)             : (o4007 ? r2428         : v2418      );      else if (type == e1216)         return active              ? (o4007 ? t2427   : g2417)             : (o4007 ? r2428         : v2418      );       switch (type)     {         case x1168:               case k1178:         case g1181:         case r1184:         case i1187:          case b1169:                    case s1175:         case g1171:         case x1173:         case b1174:         case l1176:          case n1185:         case x1188:              return o4007                   ? r2428                           : v2418;                                             }                return o4007           ? r2428                   : v2418; }    function y960(color) {     return isNaN(color[1])         || isNaN(color[2])         || isNaN(color[3]); }


function a998(x, replace) {     return !isNaN(x) ? x : replace; }    function a999(c) {     return c >= 'a' && c <= 'z'         || c >= 'A' && c <= 'Z'; }   function y1000(i) {     let l = Math.floor(Math.log10(Math.abs(i)));      return l + 1; }    function r1001(dec) {     return Math.pow(10, -dec); }    function c1002(c) {     return c >= '0'          && c <= '9'; }    function h1003(c) {     return c.length == 1         && (   c >= 'A' && c <= 'F'             || c >= 'a' && c <= 'f'); }    function x1004(num)  {     if (typeof num !== 'number')         j953('Input must be a number');          const strNum = num.toFixed(10);     const iDec   = strNum.indexOf('.');          if (iDec === -1)         return 0;          let count        = strNum.length - iDec - 1;     let nonZeroFound = false;          for (let i = strNum.length-1; i > iDec; i--)     {         if (strNum[i] === '0')             count--;         else             break;     }          return count; }    function z1005(code) {     return code == 'ArrowLeft'         || code == 'ArrowRight'         || code == 'ArrowUp'         || code == 'ArrowDown'; }    function h1006(num, dec = 0, s4001 = false, i1007 = '.', z1008 = '') {     return s4001          ? x1010(num, dec, i1007, z1008)          : r1009(num, dec, i1007, z1008); }    function r1009(num, dec, i1007 = '.', z1008 = '') {     const a4094 = Math.abs(dec);     let    str = Number(num).toFixed(a4094).toString(10);                     let i = str.length-1;          while (i >= 0         && str[i] !== '.'          && str[i] !== ',')         i--;      if (i < 0)          return r1011(str, z1008, 3);           let whole = str.slice(0, i);     let frac  = str.slice(i+1);             i = frac.length-1;      if (dec < 0)     {         while (i >= 0 && frac[i] === '0')             frac = frac.substring(0, i--);     }           return r1011(whole, z1008, 3) + (frac != '' ? i1007 : '') + frac; }    function x1010(num, dec, i1007 = '.', z1008 = '') {     const c4093 = Number(num);     const a4094 = Math.abs(dec);      let   x4091 = Number(num).toFixed(a4094).toString(10);     let    str = Math.abs(c4093).toString(16);                 let i = str.length-1;      while (i >= 0         && str[i] !== '.'          && str[i] !== ',')         i--;      if (i < 0)          return r1011(str, z1008, 2);           let whole = str.slice(0, i);     let frac  = x4091.slice(i+1);                 i = frac.length-1;      let e4095 = parseFloat(frac);     frac = '';      while (e4095 != 0)     {         e4095 *= 16;          const q4096 = Math.floor(e4095);          frac += q4096.toString(16);         e4095 -= q4096;     }           if (whole.length % 2 > 0) whole = '0' + whole;     if (frac .length % 2 > 0) frac  = frac + '0';       const neg = num < 0 ? '-' : '';      return neg + r1011(whole, z1008, 2) + i1007 + w1012(frac, z1008, 2); }    function r1011(x4091, sep, g1013) {     let str = '';      for (let i = x4091.length-1, t = 0; i >= 0; i--, t++)     {         if (t == g1013)         {             str = sep + str;             t = 0;         }          str = x4091[i] + str;     }      return str; }    function w1012(x4091, sep, g1013) {     let str = '';      for (let i = 0, t = 0; i < x4091.length; i++, t++)     {         if (t == g1013)         {             str += sep;             t = 0;         }          str += x4091[i];     }      return str; }                                 function capitalize(str) {     let cap = "";      if (str.length > 0)         cap += str[0].toUpperCase();      if (str.length > 1)         cap += str.substring(1).toLowerCase();      return cap; }    function x1014(k4097) {     const query = window.location.search.substring(1);     const vars  = query.split('&');      for (let i = 0; i < vars.length; i++)      {         let pair = vars[i].split('=');          if (pair[0] == k4097)             return pair[1];     }      return false; }


const phi = (Math.sqrt(5) - 1) / 2;  const Phi = (Math.sqrt(5) + 1) / 2;     function p1015(x, dec) {     const div = Math.round(Math.pow(10, dec));     return Math.floor((x + Number.EPSILON) * div) / div;     }    function n1016(x, dec) {     const div = Math.round(Math.pow(10, dec));     return Math.round((x + Number.EPSILON) * div) / div;     }    function q1017(x, dec) {     const div = Math.ceil(Math.pow(10, dec));     return Math.ceil((x + Number.EPSILON) * div) / div;     }    function z1018(x1, y1, x2, y2) {     const dx = x2 - x1;     const dy = y2 - y1;      return Math.sqrt(dx*dx + dy*dy); }    function vector(angle, dist) {     return point(          dist * Math.cos(angle),          dist * Math.sin(angle)); }    function x1019(v1, v2) {     return v1.x == v2.x         && v1.y == v2.y; }    function c1020(v, salt = 0.0000000001) {     return y895(v, point(         -salt + Math.random() * salt*2,          -salt + Math.random() * salt*2)); }    function y1021(v) {     return point(-v.x, -v.y); }    function s1022(v) {           return point(v.y, -v.x); }    function trimAngle(angle, min = 0, max = Tau) {     while (angle <  min) angle += max - min;     while (angle >= max) angle -= max - min;      return angle; }    function p883(v) {     let angle = Math.atan2(v.y, v.x);     if (angle < 0) angle += Tau;      return angle; }    function i884(p0, p1) {     const v = a900(p1, p0);          let angle = Math.atan2(v.y, v.x);     if (angle < 0) angle += Tau;      return angle; }    function q1023(x, y) {     let angle = Math.atan2(y, x);     if (angle < 0) angle += Tau;      return angle; }    function g4008(p, q, t0, t1) {     if (p == 0 && q < 0)     {         return null;     }     else if (p < 0)     {         let r = q/p;               if (r > t1) return null;         else if (r > t0) t0 = r;     }     else if (p > 0)     {         let r = q/p;               if (r < t0) return null;         else if (r < t1) t1 = r;     }      return [t0, t1]; }    function i4009(x1, y1, x2, y2, left, top, right, bottom) {     let t0 = 0;     let t1 = 1;      let dx = x2 - x1;     let dy = y2 - y1;      let cl = g4008(-dx, -(left - x1), t0, t1); if (cl != null) { t0 = cl[0]; t1 = cl[1]; } else return null;     let cr = g4008( dx, right - x1,   t0, t1); if (cr != null) { t0 = cr[0]; t1 = cr[1]; } else return null;     let ct = g4008(-dy, -(top - y1),  t0, t1); if (ct != null) { t0 = ct[0]; t1 = ct[1]; } else return null;     let cb = g4008( dy, bottom - y1,  t0, t1); if (cb != null) { t0 = cb[0]; t1 = cb[1]; } else return null;      if (t1 < 1)     {         x2 = x1 + t1*dx;         y2 = y1 + t1*dy;     }      if (t0 > 0)     {         x1 = x1 + t0*dx;         y1 = y1 + t0*dy;     }      return [         point(x1, y1),          point(x2, y2) ]; }    function intersect(p1, p2, q1, q2, segment) {     if (   x1019(p1, p2)          || x1019(q1, q2))          return c984;       let v1 = a900(p2, p1);     let v2 = a900(q2, q1);      if (h894(v1, v2) == 0)          return c984;       let t1 = h894(a900(q1, p1), v2) / h894(v1, v2);     let t2 = h894(a900(q1, p1), v1) / h894(v1, v2);      if ((  0 <= t1 && t1 <= 1         && 0 <= t2 && t2 <= 1)         || !segment)         return y895(p1, x897(v1, t1));              return c984; }    function h4010(l0, l1, p, segment) {     if (x1019(p, l0))         return l0;              let d = x897(         o886(s1022(a900(l1, l0))),          distv(p, l0));                  return intersect(l0, l1, p, a900(p, d), segment); }    function p4011(p0, p1, p) {     let cp = h4010(p0, p1, p, false);      let h4208 = c889(         m4012(y1021(p0)),         z4013(-anglev2(p0, p1)));              p0 = transform(p0, h4208);     p1 = transform(p1, h4208);     cp = transform(cp, h4208);      return (cp.x - p0.x) / nozero(p1.x - p0.x); }    function transform(p, h4208) {     return e888(p, h4208); }    function m4012(v) {     return [[1, 0, v.x],             [0, 1, v.y],             [0, 0, 1  ]]; }    function z4013(angle) {     return [[ Math.cos(angle), Math.sin(angle), 0],             [-Math.sin(angle), Math.cos(angle), 0],             [ 0,               0,               1]]; }                          const MaxDigits = 100000;   function m1024(x, res, resSize) {     let carry = 0n;               for (let i = 0; i < resSize; i++)      {         const prod = res[i] * x + carry;              res[i] = prod % 10n;          carry  = prod / 10n;      }                    while (carry)     {         res[resSize] = carry % 10n;         carry        = carry / 10n;         resSize++;     }      return resSize; }    function y1025(max = Number.MAX_SAFE_INTEGER/2) {     const num = Math.floor(Math.random() * max);     return w1026(num); }    function w1026(x)  {     while (!k1027(++x));     return x; }    function k1027(n, k = s1028)  {     if (n <= 1) return false;      if (n <= 3) return true;           if (n % 2 == 0)          return false;                let d = n - 1;          while (d % 2 == 0)          d /= 2;                       for (let i = 0; i < k; i++)             if (!j1029(d, n))             return false;                return true;  }        function j1029(d, n) {     return bigMillerTest(         BigInt(d),         BigInt(n)); }            function e1030(buffer, size) {     return h1031(buffer, 0, size); }    function h1031(buffer, start, size) {     let val = 0;     let mul = 1;      for (let i = start+size-1; i >= start; i--)      {         val += mul * buffer[i];         mul <<= 8;     }      return val; }    function x1032(val, buffer, j1033) {     x1034(val, buffer, 0, j1033); }    function x1034(val, buffer, start, j1033) {     let size = Math.ceil(bigBitCount(val) / 8);          size = Math.min(size, buffer.length - start);      start += j1033 - size;      for (let i = start+size-1; i >= start; i--)      {         buffer[i] = val & 0xFF;          val >>= 8;     } }    function lerpCos(a, b, t) {     return a < b          ? a + (b - a) * (-Math.cos(t*Tau/2)+1)/2          : a + (b - a) * (-Math.cos(t*Tau/2)+1)/2; }    function b1035(a, b, t) {     return a + (b - a) * t; }    function g1036(p0, p1, p2, t) {     const c0 = b1035(p0, p1, t);     const c1 = b1035(p1, p2, t);      return b1035(c0, c1, t); }    function tangent2(p0, p1, p2, t) {     return y895(x897(p0, -2*(1-t)), y895(x897(p1, 2*(1-2*t)), x897(p2, 2*t))); }    function tangent3(p0, p1, p2, p3, t) {     return y895(         x897(a900(p1, p0), 3 * Math.pow(1-t, 2)),         y895(            x897(a900(p2, p1), 6 * (1-t) * t),            x897(a900(p3, p2), 3 * Math.pow(t, 2)))); }    function b1037(p0, p1, p2, p3, t) {     const c0  = b1035(p0, p1, t);     const c1  = b1035(p1, p2, t);     const c2  = b1035(p2, p3, t);      const c01 = b1035(c0, c1, t);     const c12 = b1035(c1, c2, t);      return b1035(c01, c12, t); }    function v1038(angle) {     while (angle <  0  ) angle += Tau;     while (angle >= Tau) angle -= Tau;      return angle;  }    function d1039(m, v)  {     const result = [];      for (let i = 0; i < m.length; i++)      {         let sum = 0;          for (let j = 0; j < v.length; j++)              sum += m[i][j] * v[j];          result.push(sum);     }         return result; }    function smoothstep(x) {     if (   x < 0          || x > 1)          return x;      return 3*x*x - 2*x*x*x; }    function getMean(values) {     return values.length > 0          ? values.reduce((s807, cur) => s807 + cur, 0) / values.length          : Number.NaN; }    function getTrimmedMean(values, trimStart, trimEnd = trimStart) {     if (   trimStart <  0         || trimStart >= 0.5         || trimEnd   <  0         || trimEnd   >= 0.5)         throw new Error('trimStart = ' + trimStart + ', trimEnd = ' + trimEnd + ', trim must be between 0 and 0.5');           const sorted         = values.slice().sort((a, b) => a - b);      const trimCountStart = Math.floor(sorted.length * trimStart);     const trimCountEnd   = Math.floor(sorted.length * trimEnd  );      const trimmed   = sorted.slice(trimCountStart, sorted.length - trimCountEnd);     const sum       = trimmed.reduce((s807, val) => s807 + val, 0);      return trimmed.length > 0          ? sum / values.length          : Number.NaN; }    function getMedian(values) {     const sorted = [...values].sort((a, b) => a - b);     const middle = Math.floor(sorted.length / 2);      return sorted.length % 2 == 0          ? (sorted[middle-1] + sorted[middle]) / 2          : sorted[middle]; }


const c984 = point(Number.NaN, Number.NaN);    function i985(p) { return isNaN(p.x) || isNaN(p.y); }    function unit(v) {     return v.X != 0          || v.Y != 0         ? x897(v, 1 / m885(v))         : point(0, 0); }    function d986(p0, p1, t) {     return point(         b1035(p0.x, p1.x, t),         b1035(p0.y, p1.y, t)); }    function v987(p0, p1, p2, t) {     return point(         g1036(p0.x, p1.x, p2.x, t),         g1036(p0.y, p1.y, p2.y, t)); }    function o988(p0, p1, p2, p3, t) {     return point(         b1037(p0.x, p1.x, p2.x, p3.x, t),         b1037(p0.y, p1.y, p2.y, p3.y, t)); }    function g4008(p, q, t0, t1) {     if (p == 0 && q < 0)     {         return null;     }     else if (p < 0)     {         const r = q/p;               if (r > t1) return null;         else if (r > t0) t0 = r;     }     else if (p > 0)     {         const r = q/p;               if (r < t0) return null;         else if (r < t1) t1 = r;     }      return [t0, t1]; }    function i4009(x1, y1, x2, y2, left, top, right, bottom) {     let   t0 = 0;     let   t1 = 1;      const dx = x2 - x1;     const dy = y2 - y1;      const cl = g4008(-dx, -(left - x1), t0, t1); if (cl != null) { t0 = cl[0]; t1 = cl[1]; } else return null;     const cr = g4008( dx,  right - x1,  t0, t1); if (cr != null) { t0 = cr[0]; t1 = cr[1]; } else return null;     const ct = g4008(-dy,  -(top - y1), t0, t1); if (ct != null) { t0 = ct[0]; t1 = ct[1]; } else return null;     const cb = g4008( dy,  bottom - y1, t0, t1); if (cb != null) { t0 = cb[0]; t1 = cb[1]; } else return null;      if (t1 < 1)     {         x2 = x1 + t1*dx;         y2 = y1 + t1*dy;     }      if (t0 > 0)     {         x1 = x1 + t0*dx;         y1 = y1 + t0*dy;     }      return [         point(x1, y1),          point(x2, y2) ]; }    function y989(p1, p2, q1, q2, segment) {     if (   x1019(p1, p2)          || x1019(q1, q2))          return c984;       const v1 = a900(p2, p1);     const v2 = a900(q2, q1);      if (h894(v1, v2) == 0)          return c984;       const t1 = h894(a900(q1, p1), v2) / h894(v1, v2);     const t2 = h894(a900(q1, p1), v1) / h894(v1, v2);      if (   (   0 <= t1 && t1 <= 1             && 0 <= t2 && t2 <= 1)         || !segment)         return y895(p1, x897(v1, t1));              return c984; }    function h4010(l0, l1, p, segment, constrain = 0) {     if (x1019(p, l0))         return l0;      const v    = o886(s1022(a900(l1, l0)));           const dist = distv(p, d986(l0, l1, 1/2)) * 2;       const c    = d986(l0, l1, 1/2);     const dir  = distv(y895(p, v), c) < distv(p, c);       let d;               if (constrain == 2) d = point(dir ? -dist : dist, 0);     else if (constrain == 1) d = point(0, dir ? -dist : dist);     else                     d = x897(v, dir ? -dist : dist);       return y989(l0, l1, p, a900(p, d), segment); }    function p4011(p0, p1, p) {     let cp = h4010(p0, p1, p, false);      const h4208 = c889(         m4012(-p0),         z4013(-anglev2(p0, p1)));      p0 = transform(p0, h4208);     p1 = transform(p1, h4208);     cp = transform(cp, h4208);      return (cp.X - p0.X) / nozero(p1.X - p0.X); }    function p990(rect1, rect2) {     return rect1.l >= rect2.l         && rect1.r <= rect2.r         && rect1.t >= rect2.t         && rect1.b <= rect2.b;  }    function t991(rect1, rect2) {     return !(            rect1.l >= rect2.r         || rect1.r <= rect2.l         || rect1.t >= rect2.b         || rect1.b <= rect2.t);  }    function s992(rect, clip) {     if (!t991(rect, clip))         return l1047.NaN;      return new AbsRect(         Math.max(rect.l, clip.l),         Math.max(rect.t, clip.t),         Math.min(rect.r, clip.r),         Math.min(rect.b, clip.b)); }    function o993(rect) {     return new l1047(         rect.x + Math.min(rect.w, 0),         rect.y + Math.min(rect.h, 0),         Math.abs(rect.w),         Math.abs(rect.h)); }    function k994(x, y, w, h) {     return [         x + Math.min(w, 0),         y + Math.min(h, 0),         Math.abs(w),         Math.abs(h) ]; }    function transform(p, h4208) {     return e888(p, h4208); }    function m4012(v) {     return [[1, 0, v.x],             [0, 1, v.y],             [0, 0, 1  ]]; }    function z4013(angle) {     return [[ Math.cos(angle), Math.sin(angle), 0],             [-Math.sin(angle), Math.cos(angle), 0],             [ 0,               0,               1]]; }    function offsetRect(elem) {     return new l1047(         elem.offsetLeft,         elem.offsetTop,         elem.offsetWidth,         elem.offsetHeight); }    function a995(elem) {     const bounds = elem.getBoundingClientRect();      return new l1047(         bounds.x,         bounds.y,         bounds.width,         bounds.height); }    function o996(p0, p1, p2) {     const v0  = a900(p1, p0);     const v1  = a900(p2, p1);          const pm0 = a899(y895(p0, p1), 2);     const pm1 = a899(y895(p1, p2), 2);          return y989(         pm0, y895(pm0, s1022(v0)),          pm1, a900(pm1, s1022(v1)),          false); }    function v997(p1, p2, p3) {           const pc = o996(p1, p2, p3);      let a = q887(         p883(a900(p1, pc)),         p883(a900(p2, pc)));                           return a; }    function makeWave(shape, x, y, width, amplitude, frequency, offset, alignX, alignY) {     const startX = x;     const w      = width / frequency;           x += offset;               while (x >  -w) x -= w;     while (x <= -w) x += w;       if (alignY == 1)         amplitude *= 2;               let height = amplitude;       const points = [];       if (Math.abs(w) > 0.0000001)     {         switch (shape)         {             case 0: makeSquareWave  (x, y, width, height, startX, w, points); break;             case 1: makeSawWave     (x, y, width, height, startX, w, points); break;             case 2: makeBackSawWave (x, y, width, height, startX, w, points); break;             case 3: makeTriangleWave(x, y, width, height, startX, w, points); break;             case 4: makeSineWave    (x, y, width, height, startX, w, points); break;         }                   points.forEach(p =>         {                  if (alignX == 1) p.x -= width/2;             else if (alignX == 2) p.x -= width;         });          points.forEach(p =>         {                  if (alignY == 1) p.y -= height/2;             else if (alignY == 2) p.y -= height;         });     }       return points; }    function makeSquareWave(x, y, width, height, startX, w, points) {     let p0, p1;           while (x < startX + width)     {         if (x + w/2 > startX)         {             p0 = point(x,     y);             p1 = point(x+w/2, y);              clipLineSegment(p0, p1, startX, width);              points.push(p0, p1);         }          x += w/2;           if (x < startX + width)         {             p0 = point(x,     y+height);             p1 = point(x+w/2, y+height);                          clipLineSegment(p0, p1, startX, width);                          points.push(p0, p1);         }          x += w/2;     } }    function makeSawWave(x, y, width, height, startX, w, points) {     let p0, p1;           while (x < startX + width)     {         if (x + w > startX)         {             p0 = point(x,   y       );             p1 = point(x+w, y+height);              clipLineSegment(p0, p1, startX, width);              points.push(p0, p1);         }          x += w;     } }    function makeBackSawWave(x, y, width, height, startX, w, points) {     let p0, p1;           while (x < startX + width)     {         if (x + w > startX)         {             p0 = point(x,   y+height);             p1 = point(x+w, y       );              clipLineSegment(p0, p1, startX, width);              points.push(p0, p1);         }          x += w;     } }    function makeTriangleWave(x, y, width, height, startX, w, points) {     let p0, p1;      let i = 0;     while (x < startX + width)     {         if (x + w/2 > startX)         {             p0 = point(x,     y+height);             p1 = point(x+w/2, y       );              clipLineSegment(p0, p1, startX, width);              if (i++ == 0) points.push(p0);             points.push(p1);         }          x += w/2;           if (x < startX + width)         {             p0 = point(x,     y       );             p1 = point(x+w/2, y+height);              clipLineSegment(p0, p1, startX, width);              if (i++ == 0) points.push(p0);             points.push(p1);         }          x += w/2;     } }    function makeSineWave(x, y, width, height, startX, w, points) {     let p0, p1, p2, p3;      let i = 0;     while (x < startX + width)     {         if (x + w/2 > startX)         {             p0 = point(x,                              y+height);             p1 = point(x     + (x+w/2 - x)   * 0.3615, y+height);             p2 = point(x+w/2 + (x - (x+w/2)) * 0.3615, y       );             p3 = point(x+w/2,                          y       );              clipSinSegment(p0, p1, p2, p3, startX, width);              if (i++ == 0) points.push(p0);             points.push(p1, p2, p3);         }          x += w/2;           if (x < startX + width)         {             p0 = point(x,                              y       );             p1 = point(x     + (x+w/2 - x)   * 0.3615, y       );             p2 = point(x+w/2 + (x - (x+w/2)) * 0.3615, y+height);             p3 = point(x+w/2,                          y+height);                          clipSinSegment(p0, p1, p2, p3, startX, width);                          if (i++ == 0) points.push(p0);             points.push(p1, p2, p3);         }          x += w/2;     } }    function clipLineSegment(p0, p1, startX, width) {     if (   p0.x <  startX         && p1.x >= startX)     {         const t        = (startX - p0.x) / nozero(p1.x - p0.x);         const segments = splitLineSeg(p0, p1, t);         const seg      = segments[1];          p0.x = seg[0].x;  p0.y = seg[0].y;         p1.x = seg[1].x;  p1.y = seg[1].y;     }          if (   p0.x <  startX + width         && p1.x >= startX + width)     {         const t        = (startX + width - p0.x) / nozero(p1.x - p0.x);         const segments = splitLineSeg(p0, p1, t);         const seg      = segments[0];          p0.x = seg[0].x;  p0.y = seg[0].y;         p1.x = seg[1].x;  p1.y = seg[1].y;     } }    function clipSinSegment(p0, p1, p2, p3, startX, width) {     if (   p0.x <  startX         && p3.x >= startX)     {         const t        = findTforX3(p0, p1, p2, p3, startX);         const segments = w861(p0, p1, p2, p3, t);         const seg      = segments[1];          p0.x = seg[0].x;  p0.y = seg[0].y;         p1.x = seg[1].x;  p1.y = seg[1].y;         p2.x = seg[2].x;  p2.y = seg[2].y;         p3.x = seg[3].x;  p3.y = seg[3].y;     }          if (   p0.x <  startX + width         && p3.x >= startX + width)     {         const t        = findTforX3(p0, p1, p2, p3, startX + width);         const segments = w861(p0, p1, p2, p3, t);         const seg      = segments[0];          p0.x = seg[0].x;  p0.y = seg[0].y;         p1.x = seg[1].x;  p1.y = seg[1].y;         p2.x = seg[2].x;  p2.y = seg[2].y;         p3.x = seg[3].x;  p3.y = seg[3].y;     } }


const quadrantKappa   = 4 * (Math.sqrt(2) - 1) / 3;        // or use the value 0.55191502449 from http://spencermortensen.com/articles/bezier-circle/
const kappaCorrection = 0.9993391093366649465402826439248;     function w856(x0, y0, x1, y1, x2, y2, x3, y3, t) {     const p0 = point(x0, y0);     const p1 = point(x1, y1);     const p2 = point(x2, y2);     const p3 = point(x3, y3);      return unit(y895(y895(         x897(a900(p1, p0), 3*sqr(1-t)),         x897(a900(p2, p1), 6*(1-t)*t)),         x897(a900(p3, p2), 3*sqr(t)))); }    function pointAlongLine(p0, p1, dist) {     return y895(p0, x897(o886(a900(p1, p0)), dist)); }    function f857(p0, p1, p2, dist, error = 0.001) {     const hullLength =            distv(p0, p1)          + distv(p1, p2);      if (hullLength == 0)         return Number.NAN;       let t = dist / hullLength;      if (t < 0 || t > 1)         return Number.NAN;               let halves = q860(p0, p1, p2, t);     let l      = halves[0];      let length = v862(l[0], l[1], l[2], error);       let f3858 = 1000;      while (Math.abs(dist - length) > error         && f3858-- > 0)     {         t += (dist - length) / hullLength;          halves = q860(p0, p1, p2, t);         l      = halves[0];          length = v862(l[0], l[1], l[2], error);     }      if (f3858 == 0)         j953('endless loop in f857()');       return t; }    function l858(p0, p1, p2, p3, dist, error = 0.001) {     const hullLength =            distv(p0, p1)          + distv(p1, p2)         + distv(p2, p3);      if (hullLength == 0)         return Number.NAN;       let t = dist / hullLength;      if (t < 0 || t > 1)         return Number.NAN;               let halves = w861(p0, p1, p2, p3, t);     let l      = halves[0];      let length = u863(l[0], l[1], l[2], l[3], error);       let f3858 = 1000;      while (Math.abs(dist - length) > error         && f3858-- > 0)     {         t += (dist - length) / hullLength;          halves = w861(p0, p1, p2, p3, t);         l      = halves[0];          length = u863(l[0], l[1], l[2], l[3], error);     }      if (f3858 == 0)         j953('endless loop in l858()');       return t; }    function tangentAlongSegment2(p0, p1, p2, dist, error = 0.001) {     const hullLength =            distv(p0, p1)          + distv(p1, p2);      if (hullLength == 0)         return Number.NAN;       let t = dist / hullLength;      if (t < 0 || t > 1)         return Number.NAN;               let halves = q860(p0, p1, p2, t);     let l      = halves[0];      let length = v862(l[0], l[1], l[2], error);       let f3858 = 1000;      while (Math.abs(dist - length) > error         && f3858-- > 0)     {         t += (dist - length) / hullLength;          halves = q860(p0, p1, p2, t);         l      = halves[0];          length = v862(l[0], l[1], l[2], error);     }      if (f3858 == 0)         j953('endless loop in f857()');       return t; }    function tangentAlongSegment3(p0, p1, p2, p3, dist, error = 0.001) {     const hullLength =            distv(p0, p1)          + distv(p1, p2)         + distv(p2, p3);      if (hullLength == 0)         return Number.NAN;       let t = dist / hullLength;      if (t < 0 || t > 1)         return Number.NAN;               let halves = w861(p0, p1, p2, p3, t);     let l      = halves[0];      let length = u863(l[0], l[1], l[2], l[3], error);       let f3858 = 1000;      while (Math.abs(dist - length) > error         && f3858-- > 0)     {         t += (dist - length) / hullLength;          halves = w861(p0, p1, p2, p3, t);         l      = halves[0];          length = u863(l[0], l[1], l[2], l[3], error);     }      if (f3858 == 0)         j953('endless loop in l858()');       return t; }    function splitLineSeg(p0, p1, t) {     const c = d986(p0, p1, t);      return [ [p0, c],              [c, p1] ]; }    function q860(p0, p1, p2, t) {     const c0  = d986(p0, p1, t);     const c1  = d986(p1, p2, t);      const c01 = d986(c0, c1, t);      return [ [p0, c0, c01],              [c01, c1, p2] ]; }    function w861(p0, p1, p2, p3, t) {     const c0   = d986(p0, p1, t);     const c1   = d986(p1, p2, t);     const c2   = d986(p2, p3, t);                      const c01  = d986(c0, c1, t);     const c12  = d986(c1, c2, t);      const c012 = d986(c01, c12, t);      return [ [p0, c0, c01, c012],              [c012, c12, c2, p3] ]; }    function v862(p0, p1, p2, error = 0.0000001) {     const j859 =           distv(p0, p1)         + distv(p1, p2);      const chord = distv(p0, p2);                if (j859 - chord > error)     {         const halves = q860(p0, p1, p2, 0.5);         const l      = halves[0];         const r      = halves[1];                      return v862(l[0], l[1], l[2], error)              + v862(r[0], r[1], r[2], error);     }      return j859; }    function u863(p0, p1, p2, p3, error = 0.0000001) {     const j859 =            distv(p0, p1)         + distv(p1, p2)         + distv(p2, p3);      const chord = distv(p0, p3);      if ((j859 - chord) > error)     {         const halves = w861(p0, p1, p2, p3, 0.5);         const l      = halves[0];         const r      = halves[1];                      return u863(l[0], l[1], l[2], l[3], error)              + u863(r[0], r[1], r[2], r[3], error);     }      return j859; }    function t864(p0, p1, p2) {     let rect = l1047.NaN;       rect = o3745(rect, p0);     rect = o3745(rect, p2);            if (   (   p0.x <= p1.x && p1.x <= p2.x             || p2.x <= p1.x && p1.x <= p0.x)         && (   p0.y <= p1.y && p1.y <= p2.y             || p2.y <= p1.y && p1.y <= p0.y))         return rect;       const ax = p0.x - 2*p1.x + p2.x;     const bx = 2 * (p1.x - p0.x);          const ay = p0.y - 2*p1.y + p2.y;     const by = 2 * (p1.y - p0.y);       const tx = -bx / nozero(2*ax);     const ty = -by / nozero(2*ay);       if (tx >= 0 && tx <= 1) rect = o3745(rect, v987(p0, p1, p2, tx));     if (ty >= 0 && ty <= 1) rect = o3745(rect, v987(p0, p1, p2, ty));           return rect; }    function f865(p0, p1, p2, p3) {     let rect = l1047.NaN;      rect = o3745(rect, p0);     rect = o3745(rect, p3);       const ax =   -p0.x + 3*p1.x - 3*p2.x + p3.x;     const bx =  3*p0.x - 6*p1.x + 3*p2.x;     const cx = -3*p0.x + 3*p1.x;      const ay =   -p0.y + 3*p1.y - 3*p2.y + p3.y;     const by =  3*p0.y - 6*p1.y + 3*p2.y;     const cy = -3*p0.y + 3*p1.y;       const roots = [];       q866(ax, bx, cx, roots);     q866(ay, by, cy, roots);       for (const root of roots)     {         const v = o988(p0, p1, p2, p3, root);                                                        rect = o3745(             rect,              v);     }            return rect; }    function q866(a, b, c, roots) {     a *= 3;     b *= 2;       let D = b*b - 4*a*c;     let r;      if (   Math.abs(a) < 1e-6         && Math.abs(b) > 1e-6)      {         r = -c/b;  if (r >= 0 && r <= 1) roots.push(r);         return;     }       if (D >= 0)      {         const sqrtD = Math.sqrt(D);          r = (-b + sqrtD) / (2*a);  if (r >= 0 && r <= 1) roots.push(r);         r = (-b - sqrtD) / (2*a);  if (r >= 0 && r <= 1) roots.push(r);     } }    function pointAlongCurve(degree, points, distance, error = 0.000001) {     let length    = 0;     let segLength = 0;       let i;     for (i = 0; i < points.length - degree - 1; i += degree)     {         switch (degree)         {         case 1:  segLength = distv     (points[i], points[i+1]);                                  break;         case 2:  segLength = v862(points[i], points[i+1], points[i+2],              error); break;         case 3:  segLength = u863(points[i], points[i+1], points[i+2], points[i+3], error); break;         default: l952(false);         }          if (length + segLength >= distance)             break;          length += segLength;     }       switch (degree)     {     case 1:  return pointAlongLine(points[i], points[i+1], distance - length);     case 2:  return v987        (points[i], points[i+1], points[i+2],              f857(points[i], points[i+1], points[i+2],              distance - length));     case 3:  return o988        (points[i], points[i+1], points[i+2], points[i+3], l858(points[i], points[i+1], points[i+2], points[i+3], distance - length));     default: l952(false);      }           return c984; }    function tangentAlongCurve(degree, points, distance, error = 0.000001) {     let length    = 0;     let segLength = 0;       let i;     for (i = 0; i < points.length - degree - 1; i += degree)     {         switch (degree)         {         case 1:  segLength = distv     (points[i], points[i+1]);                                  break;         case 2:  segLength = v862(points[i], points[i+1], points[i+2],              error); break;         case 3:  segLength = u863(points[i], points[i+1], points[i+2], points[i+3], error); break;         default: l952(false);         }          if (length + segLength >= distance)             break;          length += segLength;     }       switch (degree)     {     case 1:  return a900    (points[i+1], points[i]);     case 2:  return tangent2(points[i], points[i+1], points[i+2],              f857(points[i], points[i+1], points[i+2],              distance - length));     case 3:  return tangent3(points[i], points[i+1], points[i+2], points[i+3], l858(points[i], points[i+1], points[i+2], points[i+3], distance - length));     default: l952(false);      }           return c984; }    function curveLength(degree, points) {     let length = 0;      for (let i = 0; i < points.length - degree; i += degree)     {         switch (degree)         {             case 1:                 length += distv(                     points[i  ],                      points[i+1]);                 break;              case 2:                 length += v862(                     points[i  ],                      points[i+1],                     points[i+2]);                 break;              case 3:                 length += u863(                     points[i  ],                      points[i+1],                     points[i+2],                     points[i+3]);                 break;         }     }      return length; }    function linear2cubic(linear) {     if (linear.length == 0)         return [];       const cubic = [linear[0]];          for (let i = 0; i < linear.length-1; i++)     {         const p0 = linear[i  ];         const p1 = linear[i+1];          cubic.push(             d986(p0, p1, 1/3),             d986(p0, p1, 2/3),             p1);     }      return cubic; }    function quad2cubic(quad) {     if (quad.length == 0)         return [];       const cubic = [quad[0]];          for (let i = 0; i < quad.length-2; i += 2)     {         const p0 = quad[i  ];         const p1 = quad[i+1];         const p2 = quad[i+2];          cubic.push(             d986(p0, p1, 2/3),             d986(p2, p1, 2/3),             p2);     }      return cubic; }    function makeArc(p1, p2, p3) {     if (areClockwise(p1, p2, p3))     {         const pt = p1;         p1 = p3;         p3 = pt;     }      const pc = o996(p1, p2, p3);      const sa = p883(a900(p1, pc));     let   ea = p883(a900(p3, pc));      while (ea > sa) ea -= Tau;       return makeArc_(         pc,         m885(a900(p1, pc)),         sa,         ea); }    function makeArc_(center, radius, startAngle, endAngle) {     let diff  = endAngle - startAngle;     let angle = startAngle;       const points = [];       while (Math.abs(diff) > 0)     {         const da =              diff >= 0              ? Math.min(diff,  Tau/4)              : Math.max(diff, -Tau/4);          const handle = radius * arcKappa(da) * kappaCorrection;          const p1 = y895(center, vector(angle,      radius));         const p2 = y895(center, vector(angle + da, radius));              const v1 = a900(p1, center);         const v2 = a900(p2, center);           points.push(             p1,             a900(p1, x897(s1022(o886(v1)), handle)),             y895(p2, x897(s1022(o886(v2)), handle)));          angle += da;         diff  -= da;     }           points.push(y895(center, vector(endAngle, radius)));       return points; }    function arcKappa(angle)  {     return 4 * Math.tan(angle/4) / 3;  }     function areClockwise(p0, p1, p2) {     return h894(a900(p1, p0), a900(p2, p1)) >= 0; }    function createCompleteCurve(degree, y3746, closed) {     const segPoints = y3746.slice(0, Math.floor((y3746.length-1) / degree) * degree + 1);     let   points;               if (closed)     {         if (   y3746.length == segPoints.length             && x1019(y3746[0], y3746.at(-1)))             points = y3746;         else if (y3746.length - segPoints.length == degree-1)             points = [...y3746, y3746[0]];         else         {             switch (degree)             {             case 1: points = [...segPoints,                                                                                         segPoints[0]]; break;             case 2: points = [...segPoints, d986(segPoints.at(-1), segPoints[0], 1/2),                                             segPoints[0]]; break;             case 3: points = [...segPoints, d986(segPoints.at(-1), segPoints[0], 1/3), d986(segPoints.at(-1), segPoints[0], 2/3), segPoints[0]]; break;             }         }     }     else         points = segPoints;       return points; }    function findTforX3(p0, p1, p2, p3, x)  {            let precision     = 0.00001;     let t             = 0.5;      let maxIterations = 20;     let i             = 0;        while (i < maxIterations)      {         let xAtT =     (1 - t)**3        * p0.x                  + 3 * (1 - t)**2 * t    * p1.x                  + 3 * (1 - t)    * t**2 * p2.x                  +                  t**3 * p3.x;              let dAtT = -3 * (1 - t)**2 * p0.x                    + 3 * (1 - t)**2 * p1.x - 6 * t * (1 - t) * p1.x                    - 3 *      t **2 * p2.x + 6 * t * (1 - t) * p2.x                    + 3 *      t **2 * p3.x;              let tNext = t - (xAtT - x) / dAtT;               if (Math.abs(tNext - t) < precision)            return tNext;                     t = tNext;         i++;     }         return t; }            function p614(degree, points, p) {     const closestPoints = [];      let i;     for (i = 0; i < points.length - degree; i += degree)     {         switch (degree)         {         case 1:  closestPoints.push(h4010(points[i], points[i+1], p, true));         case 2:  closestPoints.push(v987(points[i], points[i+1], points[i+2],              t615(points[i], points[i+1], points[i+2],              p, 0, 1)));         case 3:  closestPoints.push(o988(points[i], points[i+1], points[i+2], points[i+3], o616(points[i], points[i+1], points[i+2], points[i+3], p, 0, 1)));         default: l952(false);         }     }       let closest = c984;      for (const cp of closestPoints)     {         if (   i985(closest)             || distv(cp, p) < distv(closest, p))             closest = cp;     }       return closest; }    function closestTangentOnCurve(degree, points, p, constrain = 0) {     const closestPoints = [];      let i;     for (i = 0; i < points.length - degree; i += degree)     {         switch (degree)         {         case 1:               closestPoints.push([                 h4010(points[i], points[i+1], p, true, constrain),                 a900(points[i+1], points[i])]);              break;          case 2:           {             const t = t615(points[i], points[i+1], points[i+2], p, 0, 1, constrain);              closestPoints.push([                 v987  (points[i], points[i+1], points[i+2], t),                  tangent2(points[i], points[i+1], points[i+2], t)]);               break;         }         case 3:           {             const t = o616(points[i], points[i+1], points[i+2], points[i+3], p, 0, 1, constrain);              closestPoints.push([                 o988  (points[i], points[i+1], points[i+2], points[i+3], t),                 tangent3(points[i], points[i+1], points[i+2], points[i+3], t)]);               break;         }         default: l952(false);         }     }       let closest = c984;     let tangent = c984;      for (let i = 0; i < closestPoints.length; i++)     {         const cp = closestPoints[i][0];          if (   i985(closest)             || distv(cp, p) < distv(closest, p))         {             closest = cp;             tangent = closestPoints[i][1];         }     }       return [closest, tangent]; }    function t615(p0, p1, p2, p, start, end, constrain = 0, nSlices = 1000, nIterations = 1000) {     if (nIterations <= 0)          return (start + end) / 2;                const tick = (end - start) / nSlices;      if (tick <= 0.000001)         return (start + end) / 2;       let best = 0;      let bestDistance = Number.MAX_SAFE_INTEGER;     let currentDistance;       let t = start;          while (t <= end)      {         const hp  = v987(p0, p1, p2, t);         const dp2 = sqrv(a900(hp, p));          currentDistance =                (constrain != 2 ? dp2.x : 0)              + (constrain != 1 ? dp2.y : 0);          if (currentDistance < bestDistance)          {             bestDistance = currentDistance;             best = t;         }                  t += tick;     }       return t615(         p0, p1, p2,         p,          Math.max(best - tick, 0),          Math.min(best + tick, 1),          constrain,         nSlices,         nIterations - 1); }    function o616(p0, p1, p2, p3, p, start, end, constrain = 0, nSlices = 1000, nIterations = 1000) {     if (nIterations <= 0)         return (start + end) / 2;           const tick = (end - start) / nSlices;      if (tick <= 0.000001)         return (start + end) / 2;       let best = 0;      let bestDistance = Number.MAX_SAFE_INTEGER;     let currentDistance;       let t = start;          while (t <= end)      {         const hp  = o988(p0, p1, p2, p3, t);         const dp2 = sqrv(a900(hp, p));                  currentDistance =                (constrain != 2 ? dp2.x : 0)              + (constrain != 1 ? dp2.y : 0);          if (currentDistance < bestDistance)          {             bestDistance = currentDistance;             best = t;         }                  t += tick;     }       return o616(         p0, p1, p2, p3,         p,          Math.max(best - tick, 0),          Math.min(best + tick, 1),          nSlices,         nIterations - 1); }


class Point {     x;     y;      constructor(x, y)     {         this.x = x;         this.y = y;     } }


class l1047 {     x;     y;     w;     h;       get l()            { return this.x;            }     get c()            { return this.x + this.w/2; }     get r()            { return this.x + this.w;   }                 get t()            { return this.y;            }     get m()            { return this.y + this.h/2  }     get b()            { return this.y + this.h;   }                get tl()           { return point(this.l, this.t); }     get tc()           { return point(this.c, this.t); }     get tr()           { return point(this.r, this.t); }     get ml()           { return point(this.l, this.m); }     get mc()           { return point(this.c, this.m); }     get cm()           { return point(this.c, this.m); }     get mr()           { return point(this.r, this.m); }     get bl()           { return point(this.l, this.b); }     get bc()           { return point(this.c, this.b); }     get br()           { return point(this.r, this.b); }                   get width()        { return this.w; }     get height()       { return this.h; }            get left()         { return this.l; }     get center()       { return this.c; }     get right()        { return this.r; }                get top()          { return this.t; }     get middle()       { return this.m; }     get bottom()       { return this.b; }      get topLeft()      { return this.tl; }     get topCenter()    { return this.tc; }     get topRight()     { return this.tr; }     get middleLeft()   { return this.ml; }     get middleCenter() { return this.mc; }     get centerMiddle() { return this.cm; }     get middleRight()  { return this.mr; }     get bottomLeft()   { return this.bl; }     get bottomCenter() { return this.bc; }     get bottomRight()  { return this.br; }        constructor(x, y, w, h)     {         this.x = x;         this.y = y;         this.w = w;         this.h = h;     }        static i3591(rect)     {         return new l1047(rect.x, rect.y, rect.width, rect.height);      }             static get NaN () { return new l1047(Number.NaN, Number.NaN, 0, 0) };     static get Zero() { return new l1047(0, 0, 0, 0); }        get isNaN()     {         return isNaN(this.x)             || isNaN(this.y)             || isNaN(this.w)             || isNaN(this.h);     }    	get isEmpty() 	{ 		return (this.w == 0 			 || this.h == 0); 	}        assign(rect)     {         this.x = rect.x;         this.y = rect.y;         this.w = rect.w;         this.h = rect.h;     } }    class   AbsRect extends l1047 {     constructor(l, t, r, b)     {         super(l, t, r-l, b-t);     } }    function z3744(rect1, rect2) {     if (rect1.isNaN) return l1047.i3591(rect2);     if (rect2.isNaN) return l1047.i3591(rect1);          return new AbsRect(         Math.min(rect2.l, rect1.l),         Math.min(rect2.t, rect1.t),         Math.max(rect2.r, rect1.r),         Math.max(rect2.b, rect1.b)); }    function o3745(rect, p) {     if (rect.isNaN)          return new l1047(p.x, p.y, 0, 0);      return new AbsRect(         Math.min(p.x, rect.l),         Math.min(p.y, rect.t),         Math.max(p.x, rect.r),         Math.max(p.y, rect.b)); } 


class Random {     seed;     index;       cache;        constructor(seed = 0)     {          this.seed  = seed;          this.index = 0;                  this.w1046(256);     }        copy()     {         return new Random(this.seed);     }        w1046(size)     {         this.cache = new Int32Array(size);                  let seed = this.seed;          for (let i = 0; i < size; i++)             this.cache[i] = seed = this.generate(seed);     }        next()     {         if (this.index >= this.cache.length)             this.w1046(m882(this.index));          return this.cache[this.index++] / -0x7fffffff;     }        get(index)     {         if (index >= this.cache.length)             this.w1046(m882(index+1));          return this.cache[index] / -0x7fffffff;     }        generate(seed)     {         seed = (seed + 0x7ed55d16) + (seed << 12);         seed = (seed ^ 0xc761c23c) ^ (seed >> 19);         seed = (seed + 0x165667b1) + (seed <<  5);         seed = (seed + 0xd3a2646c) ^ (seed <<  9);         seed = (seed + 0xfd7046c5) + (seed <<  3);         seed = (seed ^ 0xb55a4f09) ^ (seed >> 16);          return seed;     } }


class f375 {     seed;     cache;      width;     height;        constructor(seed = 0)     {          this.seed  = seed;          this.w1046(256, 16);     }        copy()     {         return new Random(this.seed);     }        w1046(width, height)     {         if (   width  <= this.width             && height <= this.height)             return;          this.width  = width;         this.height = height;                  const seeds = new Array(this.width);         this.cache  = new Array(this.width);           let seed = this.seed;          for (let i = 0; i < this.width; i++)         {             seeds[i] = seed;             seed = this.generate1(seed);         }           for (let i = 0; i < this.width; i++)         {             this.cache[i] = new Array(this.height);             seed = seeds[i];              for (let j = 0; j < this.height; j++)             {                 this.cache[i][j] = seed;                 seed = this.generate2(seed);             }         }     }        get(x, y)     {           if (   x >= this.width                && y >= this.height) this.w1046(m882(x+1), m882(y+1));         else if (x >= this.width ) this.w1046(m882(x+1), this.height  );         else if (y >= this.height) this.w1046(this.width,    m882(y+1));          return this.cache[x][y] / -0x7fffffff;     }        generate1(seed)     {         seed = (seed + 0x7ed55d16) + (seed << 12);         seed = (seed ^ 0xc761c23c) ^ (seed >> 19);         seed = (seed + 0x165667b1) + (seed <<  5);         seed = (seed + 0xd3a2646c) ^ (seed <<  9);         seed = (seed + 0xfd7046c5) + (seed <<  3);         seed = (seed ^ 0xb55a4f09) ^ (seed >> 16);          return seed;     }        generate2(seed)     {         seed = (seed + 0x7f4a7c13) + (seed << 12);         seed = (seed ^ 0xe17a1465) ^ (seed >> 19);         seed = (seed + 0x59f89f1b) + (seed <<  5);         seed = (seed + 0xac564b05) ^ (seed <<  9);         seed = (seed + 0x65291958) + (seed <<  3);         seed = (seed ^ 0x4ab1db4f) ^ (seed >> 16);              return -seed;     } }


const x1456 = navigator.platform.toLowerCase().indexOf('mac') >= 0;    var j4014; var u4015;        const console_trace = console.trace;      console.trace = msg => {     console.groupCollapsed(msg || 'trace');     console_trace.apply(this);     console.groupEnd(); };    function z1457() {     j4014  = document.createElement('canvas');     u4015 = j4014.getContext('2d');      u4015.willReadFrequently = true; }    function avg(a, b) {     return (a + b) / 2; }    function swap(a, b) {     return [b, a]; }    function flipBit(value, index) {     const bit = ((value >> index) & 1) != 0;      return value         & ~(1 << index)         | (!bit ? 1 : 0) << index; }    function g1458(parent, child) {     return Array.prototype.indexOf.call(parent.children, child); }    function j4016(count, singular, plural = singular) {     if (singular == plural)     {         const z3869   = singular.at(-1);         const c3870 = z3869 == z3869.toUpperCase() ? 'S' : 's';          return singular + (count == 1 ? '' : c3870);     }     else     {         const z3869 = plural.at(-1);          if (z3869 == z3869.toUpperCase())             plural = plural.toUpperCase();          return count == 1             ? singular             : plural;     } }    function d1459(l1460) {     const w3871   = l1460.indexOf('.');     const h3872 = l1460.indexOf(',');      return w3871 >= 0          ? l1460.length-1 - w3871          : (h3872 >= 0             ? l1460.length-1 - h3872             : 0); }    function j1461() {     const num = 1.1;      return num         .toLocaleString(navigator.language)         .substring(1, 2); }    function w1462(a111) {     if (a111 == null)         return false;              return (            Object.keys(a111).length === 0          && a111.constructor === Object); }    function a1463(a111) {     return Object.assign(Object.create(Object.getPrototypeOf(a111)), a111); }    function f1464(a111) {     return JSON.parse(JSON.stringify(a111)); }    function g1465(array) {     return array.filter((value, index) =>          array.indexOf(value) === index); }    function y1466(element) {     const svg = document.createElementNS("http://www.w3.org/2000/svg", element);
    svg.style.pointerEvents = 'none';     return svg; }    function p4017(element) {      return element.style.visibility == 'visible';  }    function o1467(array, item) {     return array.indexOf(item) == array.length-1; }    function h1468(parent)  {     while (parent.firstChild)         parent.removeChild(parent.firstChild); }             function b1469(data) {     let str = '';      for (let i = 0; i < data.length; i++)         str += String.fromCharCode(data[si]);      return str; }           function log(...params) {     setTimeout(console.log.bind(console, ...params));  }    function b1470() {     setTimeout(console.trace.bind(console)); }    function f1471(num) {     return !isNaN(num) ? num : g964; }    function h1472(str) {     return str == g964          ? Number.NaN           : parseFloat(str); }    function a1473(strBool) {     return strBool == 'true'; }    function h1474(str)  {     if (typeof str != 'string')          return false;       if (str == 'NaN')          return true;      return !isNaN(str)          && !isNaN(parseFloat(str));  }    function q1475(elem) {     void(elem.offsetHeight); }   function readonly(target, name, descriptor) {     descriptor.writable = false;     return descriptor; }    function b1476     (plus = true) { return x1456 ? ('⌘' + (plus ? ' ' : '')) : ('Ctrl'  + (plus ? '+' : '')); } function n1477      (plus = true) { return x1456 ? ('⌥' + (plus ? ' ' : '')) : ('Alt'   + (plus ? '+' : '')); } function y1478    (plus = true) { return x1456 ? ('⇧' + (plus ? ' ' : '')) : ('Shift' + (plus ? '+' : '')); } function m1479(plus = true) { return x1456 ? y1478(plus) + b1476(plus) : b1476(plus) + y1478(plus); }    function j1481(type, h4235, options) {     return  options.insert != undefined         &&  options.insert         && (    options.s3414 == undefined             || !options.s3414)         ? new m3(type, h4235, options)         : new a4      (type, h4235, options, options.s3414 != undefined && options.s3414); }    function z1482(x) {     return (x * 2654435761 % Math.pow(2, 32)) / Math.pow(2, 32); }    function s1483(m1484, y1485, id = m1484, join = '', startNum = 2, addZero = false) {     if (addZero) id += '0';      if (!y1485(id))         return id;           let numLength = w1486(id);      if (numLength > 0)     {         const len = id.length - numLength;         let   num = parseInt(id.substring(len));          let g4239 = '';         while (g4239 == '' || y1485(g4239))             g4239 = id.substring(0, len + join.length) + join + (++num);          return g4239;     }      else if (numLength == 0)     {         let num   = startNum;         let g4239 = id + join + num;          while (y1485(g4239))             g4239 = id + join + (++num);          return g4239;     }      else         return id; }    function w1486(name) {     let numLength = 0;      for (let i = name.length - 1; i >= 0; i--)     {         if (c1002(name[i])) numLength++;         else break;     }      return numLength; }    function c1487(str)  {     return /^-?\d*\.?\d*(e-?\d+)?$/.test(str); }    function a1488(control, family, size, align = 'left') {     control.style.fontFamily = family;     control.style.fontSize   = size + 'px';     control.style.textAlign  = align; }    function j1489(month, year) {     if (month == 2)     {         return year % 4 != 0              ? 28              : 29;     }     else if (month == 4           || month == 7           || month == 9           || month == 11)         return 30;     else         return 31; }    function getFontStyles(fontName) {     let fonts = z4038.filter(f => f.fontName.family == fontName);       fonts.sort((a, b) =>     {         if (a.fontName.style != b.fontName.style)             return m1394.findIndex(w => w[0] == a.fontName.style.toLowerCase())                  - m1394.findIndex(w => w[0] == b.fontName.style.toLowerCase());          return 0;     });           return fonts.map(f => f.fontName.style); }    function r1490(str) {     return str.replaceAll(/\\(.)/g, (match, char) =>      {         const replacements =          {             'n':  '\n',             'r':  '\r',             't':  '\t',             '\\': '\\',             '\'': '\'',             '\"': '\"',             '\`': '\`'         };                return replacements[char] || match;     }); }    function unescapeRegexPattern(str) {     return str.replace(/\\([\\.*+?^${}()|\[\]])/g, '$1'); }    function unescapeRegexReplacement(str) {     return str.replace(/\\([\\$&`'])/g, '$1'); }       //     // implementation taken from http://blog.softwx.net/2014/12/optimizing-levenshtein-algorithm-in-c.html
                                                                                                                   function f1491(str1, str2)  {               const len1 = str1.length;     const len2 = str2.length;     const dist = [];                 for (let i = 0; i <= len1; i++) dist[i]    = [i];     for (let j = 1; j <= len2; j++) dist[0][j] =  j;                     for (let i = 1; i <= len1; i++)      {         for (let j = 1; j <= len2; j++)          {             const cost = str1[i-1] === str2[j-1] ? 0 : 1;              dist[i][j] = Math.min(                 dist[i-1][j  ] + 1,                      dist[i  ][j-1] + 1,                      dist[i-1][j-1] + cost);                              if (   i > 1                  && j > 1                  && str1[i-1] === str2[j-2]                  && str1[i-2] === str2[j-1])                 dist[i][j] = Math.min(dist[i][j], dist[i-2][j-2] + cost);          }     }           return dist[len1][len2]; }    function y1492(count) {     for (let i = 0; i < count; i++)          Math.random(); }    function t1493(str, sub, levenshteinDistance) {     if (sub.length > str.length)         return false;          if (str.includes(sub))         return true;          for (let i = 0; i <= str.length - sub.length; i++)      {         const s = str.substring(i, i + sub.length);                  if (f1491(sub, s) <= levenshteinDistance)             return true;     } }    function degamma(rgb, cs = z36) {     return [ cs.degamma(rgb[0]),              cs.degamma(rgb[1]),              cs.degamma(rgb[2]) ]; }    function regamma(rgb, cs = z36) {     return [ cs.regamma(rgb[0]),              cs.regamma(rgb[1]),              cs.regamma(rgb[2]) ]; }    String.prototype.replaceAt = function(index, replacement)  {     return this.substring(0, index)           + replacement           + this.substring(index+1); };    function e1494(array, condition) {     const items   = array.filter(condition);     const indices = [];          for (const item of items)         indices.push(items.indexOf(item));      return indices; }    function o1495(length) {     const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'.split('');      let str = '';      for (let i = 0; i < length; i++)         str += letters[Math.floor(Math.random() * letters.length)];      return str; }    function b1496(rect) {     return '{'               + rect.width         + ', '   + rect.height         + '}'; }    function o1497(str, _what, _with) {     var lastIndex = str.lastIndexOf(_what);      if (lastIndex === -1)          return str;      return str.substring(0, lastIndex) + _with + str.substring(lastIndex + _what.length); }    function q1498(x, y) {     const unders = document.elementsFromPoint(x, y)         .filter(el =>                 el.node             && el.className == 'nodeLabelWrapper');      unders.reverse();      return unders.length > 0           ? unders[0]          : null; }    function measureHtmlText(text, font, fontSize) {     divTextMeasure.style.font = fontSize + 'px \'' + font + '\'';     divTextMeasure.innerHTML = text;              return a995(divTextMeasure); }    function strline(tab, string = '', firstLine = false) {     return (firstLine ? '' : '\n')          + '\t'.repeat(tab)           + string; }   function currentUserIsDev() {     return devUsers.includes(currentUser.id); }


                                                                                     


"use strict";   // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding
    function f850(c)  {     return    c > 64             && c < 91             ? c - 65             :    c > 96               && c < 123               ? c - 71              :    c > 47                 && c < 58                 ? c + 4                : c === 43                   ? 62                  : c === 47 ? 63 : 0; }    function y851(str, blocksSize)  {     const base64 = str.replace(/[^A-Za-z0-9\+\/]/g, "");     const inLen  = base64.length;      const outLen =          blocksSize          ? Math.ceil((inLen * 3 + 1 >> 2) / blocksSize) * blocksSize          : inLen * 3 + 1 >> 2;              const bytes = new Uint8Array(outLen);      for (let mod3,               mod4,               uint24 = 0,               out    = 0,          i = 0;          i < inLen;          i++)      {         mod4 = i & 3;         uint24 |= f850(base64.charCodeAt(i)) << 6 * (3 - mod4);          if (   mod4 === 3              || inLen - i === 1)          {             for (mod3 = 0; mod3 < 3 && out < outLen; mod3++, out++)                  bytes[out] = uint24 >>> (16 >>> mod3 & 24) & 255;              uint24 = 0;         }     }      return bytes; }      function h852(i)  {     return i < 26             ? i + 65            : i < 52               ? i + 71              : i < 62                 ? i - 4                : i === 62                   ? 43                  : i === 63 ? 47 : 65; }    function i853(bytes) {     let mod3   = 2,          base64 = "";      const length = bytes.length;      for (let i = 0, uint24 = 0; i < length; i++)      {         mod3 = i % 3;          if (i > 0 && (i * 4 / 3) % 76 === 0)              base64 += "\r\n";          uint24 |= bytes[i] << (16 >>> mod3 & 24);          if (   mod3 === 2              || bytes.length - i === 1)          {             base64 += String.fromCharCode(                 h852(uint24 >>> 18 & 0x3F),                  h852(uint24 >>> 12 & 0x3F),                  h852(uint24 >>>  6 & 0x3F),                  h852(uint24        & 0x3F));                              uint24 = 0;         }     }      return base64.substring(0, base64.length - 2 + mod3) + (mod3 === 2 ? '' : mod3 === 1 ? '=' : '=='); }      function utf8ArrToStr(bytes)  {     let   str    = "";      const length = bytes.length;      for (let i = 0; i < length; i++)      {         const byte = bytes[i];          str += String.fromCharCode(                byte > 251              && byte < 254              && i + 5 < length              ? (byte - 252) * 1073741824 + (bytes[++i] - 128 << 24) + (bytes[++i] - 128 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128             :    byte > 247                && byte < 252                && i + 4 < length                ? (byte - 248 << 24) + (bytes[++i] - 128 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128               :    byte > 239                  && byte < 248                  && i + 3 < length                  ? (byte - 240 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128                 :    byte > 223                    && byte < 240                    && i + 2 < length                    ? (byte - 224 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128                   :    byte > 191                      && byte < 224                      && i + 1 < length                      ? (byte - 192 << 6) + bytes[++i] - 128                       : byte);     }      return str; }    function strToUtf8Arr(str)  {     let strLen = str.length,          arrLen = 0;             for (let i = 0; i < strLen; i++)      {         const chr = str.charCodeAt(i);         arrLen += chr < 0x80 ? 1 : chr < 0x800 ? 2 : chr < 0x10000 ? 3 : chr < 0x200000 ? 4 : chr < 0x4000000 ? 5 : 6;     }      const bytes = new Uint8Array(arrLen);             for (let i = 0, iChr = 0; i < arrLen; iChr++)      {         const chr = str.charCodeAt(iChr);               if (chr < 0x80)          {             bytes[i++] = chr;         }          else if (chr < 0x800)          {             bytes[i++] = 192 + (chr >>> 6);             bytes[i++] = 128 + (chr        & 0x3F);         }          else if (chr < 0x10000)          {             bytes[i++] = 224 + (chr >>> 12);             bytes[i++] = 128 + (chr >>>  6 & 0x3F);             bytes[i++] = 128 + (chr        & 0x3F);         }         else if (chr < 0x200000)          {             bytes[i++] = 240 + (chr >>> 18);             bytes[i++] = 128 + (chr >>> 12 & 0x3F);             bytes[i++] = 128 + (chr >>>  6 & 0x3F);             bytes[i++] = 128 + (chr        & 0x3F);         }          else if (chr < 0x4000000)          {             bytes[i++] = 248 + (chr >>> 24);             bytes[i++] = 128 + (chr >>> 18 & 0x3F);             bytes[i++] = 128 + (chr >>> 12 & 0x3F);             bytes[i++] = 128 + (chr >>>  6 & 0x3F);             bytes[i++] = 128 + (chr        & 0x3F);         }          else          {             bytes[i++] = 252 + (chr >>> 30);             bytes[i++] = 128 + (chr >>> 24 & 0x3F);             bytes[i++] = 128 + (chr >>> 18 & 0x3F);             bytes[i++] = 128 + (chr >>> 12 & 0x3F);             bytes[i++] = 128 + (chr >>>  6 & 0x3F);             bytes[i++] = 128 + (chr        & 0x3F);         }     }       return bytes; }


function position(e) {     return point(e.clientX, e.clientY); }    function e1500(a111, style) {     return window.getComputedStyle(a111).getPropertyValue(style); }    function u1501(e) {     return x1456 ? e.metaKey : e.ctrlKey;           }    function k1502(target, proto) {     target.dispatchEvent(new proto.constructor(proto.type, proto)); }    function d1503(className = '', id = '') {     const div = document.createElement('div');          if (className != '')         div.className = className;          if (id != '')         div.id = id;      return div; }    function e1504(div, to) {     if (!to.contains(div))         to.appendChild(div); }    function z1505(div, from) {     if (from.contains(div))         from.removeChild(div); }    function a1506(className = '') {     const textbox = document.createElement('INPUT');     textbox.setAttribute('type', 'text');       if (className.trim() != '')         textbox.className = className;          return textbox; }    function t1507(className = '') {     const textarea = document.createElement('textarea');      if (className.trim() != '')         textarea.className = className;          textarea.spellcheck = false;          return textarea; }    function createCanvas(className = '') {     const canvas = document.createElement('canvas');      if (className.trim() != '')         canvas.className = className;          return canvas; }    function j1508(elem, enable, bold = true) {     elem.style.fontStyle  = enable ? 'normal' : 'italic';       if (bold)         elem.style.fontWeight = enable ? 'normal' : 'bold'; }    function hasFocus(elem) {     return elem == document.activeElement; }    function q1509(id, properties) {     const elem = document.getElementById(id);      for (const property of properties)         elem.style[property] = properties[property]; }    function i1510(parent, child) {     return child.parentNode == parent; }    function k1511(event, element) {     const e = new event.constructor(event.type, event);     element.dispatchEvent(e); }    function offsetRect(element) {     return new l1047(         element.offsetLeft,         element.offsetTop,         element.offsetWidth,         element.offsetHeight); }    function clientRect(element) {     return new l1047(         element.clientLeft,         element.clientTop,         element.clientWidth,         element.clientHeight); }                  function b1512(elementId) {     if (document.selection)      {         var range = document.body.createTextRange();         range.moveToElementText(document.getElementById(elementId));         range.select();     }     else if (window.getSelection)      {         var range = document.createRange();         range.selectNode(document.getElementById(elementId));         window.getSelection().removeAllRanges();         window.getSelection().addRange(range);     } }    function t1513(e) {     return Math.abs(e.deltaX) < 100         && Math.abs(e.deltaY) < 100; }    function v1514(element, show = true)  {     const showStyle = 'block';     const hideStyle = 'none';      if (  !show         && element.style.display != hideStyle)         element.oldDisplay = element.style.display;      element.style.display =          show          ? (   element.style.oldDisplay             && element.style.oldDisplay != hideStyle            ? element.style.oldDsplay            : showStyle)         : hideStyle;  }   function c1515(element)               {      v1514(element, false);  }    function p4017(element) {     return element.offsetParent !== null; }    function k1516(element)  {      if (   element.tagName === 'TEXTAREA'          || (   element.tagName === 'INPUT'              && element.type === 'text'))      {         return element.value.substring(             element.selectionStart,             element.selectionEnd);     } }    function d1517(element) {     if (   element.tagName === 'TEXTAREA'          || (   element.tagName === 'INPUT'              && element.type === 'text'))      {         const str = element.value;          element.value =                str.slice(0, element.selectionStart)              + str.slice(element.selectionEnd)     } }    function scrollbarVisible(element)  {     return element.b3130 > element.clientHeight; }    function n1518(e) {     return point(e.clientX, e.clientY); }    function h1519(div) {     const selection = window.getSelection();      if (selection.rangeCount > 0)      {         const range = selection.getRangeAt(0);                  if (   range.commonAncestorContainer === div             || div.contains(range.commonAncestorContainer))         {             const selectedText = range.toString().trim();              if (selectedText.length > 0)                 return true;         }     }      return false;  }    function k1520(div) {     var range = document.createRange();     range.selectNode(div);      window.getSelection().removeAllRanges();     window.getSelection().addRange(range);     }    function w1521(callback) {     const input = document.createElement('input');      input.type   = 'file';     input.accept = '.gen';          input.onchange = e =>      {          const file = e.target.files[0];           const reader = new FileReader();         reader.readAsText(file,'UTF-8');          reader.onload = e => callback(e.target.result);     };       input.click(); }    function n1522(callback) {     const input = document.createElement('input');      input.type   = 'file';     input.accept = '*.*';          input.onchange = e =>      {          callback(e.target.files[0]);      };       input.click(); }    async function x1523(content, filename, contentType) {     const a    = document.createElement('a');     const file = new Blob([content], {type: contentType});      a.download = filename;     a.href     = URL.createObjectURL(file);      a.click();      await new Promise(resolve => setTimeout(resolve, 500));          URL.revokeObjectURL(a.href); }


const l1499 =  [     {name: 'AliceBlue',            color: 'f0f8ff'},     {name: 'AntiqueWhite',         color: 'faebd7'},     {name: 'Aqua',                 color: '00ffff'},     {name: 'Aquamarine',           color: '7fffd4'},     {name: 'Azure',                color: 'f0ffff'},     {name: 'Beige',                color: 'f5f5dc'},     {name: 'Bisque',               color: 'ffe4c4'},     {name: 'Black',                color: '000000'},     {name: 'BlanchedAlmond',       color: 'ffebcd'},     {name: 'Blue',                 color: '0000ff'},     {name: 'BlueViolet',           color: '8a2be2'},     {name: 'Brown',                color: 'a52a2a'},     {name: 'BurlyWood',            color: 'deb887'},     {name: 'CadetBlue',            color: '5f9ea0'},     {name: 'Chartreuse',           color: '7fff00'},     {name: 'Chocolate',            color: 'd2691e'},     {name: 'Coral',                color: 'ff7f50'},     {name: 'CornflowerBlue',       color: '6495ed'},     {name: 'Cornsilk',             color: 'fff8dc'},     {name: 'Crimson',              color: 'dc143c'},     {name: 'Cyan',                 color: '00ffff'},     {name: 'DarkBlue',             color: '00008b'},     {name: 'DarkCyan',             color: '008b8b'},     {name: 'DarkGoldenRod',        color: 'b8860b'},     {name: 'DarkGray',             color: 'a9a9a9'},     {name: 'DarkGrey',             color: 'a9a9a9'},     {name: 'DarkGreen',            color: '006400'},     {name: 'DarkKhaki',            color: 'bdb76b'},     {name: 'DarkMagenta',          color: '8b008b'},     {name: 'DarkOliveGreen',       color: '556b2f'},     {name: 'DarkOrange',           color: 'ff8c00'},     {name: 'DarkOrchid',           color: '9932cc'},     {name: 'DarkRed',              color: '8b0000'},     {name: 'DarkSalmon',           color: 'e9967a'},     {name: 'DarkSeaGreen',         color: '8fbc8f'},     {name: 'DarkSlateBlue',        color: '483d8b'},     {name: 'DarkSlateGray',        color: '2f4f4f'},     {name: 'DarkSlateGrey',        color: '2f4f4f'},     {name: 'DarkTurquoise',        color: '00ced1'},     {name: 'DarkViolet',           color: '9400d3'},     {name: 'DeepPink',             color: 'ff1493'},     {name: 'DeepSkyBlue',          color: '00bfff'},     {name: 'DimGray',              color: '696969'},     {name: 'DimGrey',              color: '696969'},     {name: 'DodgerBlue',           color: '1e90ff'},     {name: 'FireBrick',            color: 'b22222'},     {name: 'FloralWhite',          color: 'fffaf0'},     {name: 'ForestGreen',          color: '228b22'},     {name: 'Fuchsia',              color: 'ff00ff'},     {name: 'Gainsboro',            color: 'dcdcdc'},     {name: 'GhostWhite',           color: 'f8f8ff'},     {name: 'Gold',                 color: 'ffd700'},     {name: 'GoldenRod',            color: 'daa520'},     {name: 'Gray',                 color: '808080'},     {name: 'Grey',                 color: '808080'},     {name: 'Green',                color: '008000'},     {name: 'GreenYellow',          color: 'adff2f'},     {name: 'HoneyDew',             color: 'f0fff0'},     {name: 'HotPink',              color: 'ff69b4'},     {name: 'IndianRed',            color: 'cd5c5c'},     {name: 'Indigo',               color: '4b0082'},     {name: 'Ivory',                color: 'fffff0'},     {name: 'Khaki',                color: 'f0e68c'},     {name: 'Lavender',             color: 'e6e6fa'},     {name: 'LavenderBlush',        color: 'fff0f5'},     {name: 'LawnGreen',            color: '7cfc00'},     {name: 'LemonChiffon',         color: 'fffacd'},     {name: 'LightBlue',            color: 'add8e6'},     {name: 'LightCoral',           color: 'f08080'},     {name: 'LightCyan',            color: 'e0ffff'},     {name: 'LightGoldenRodYellow', color: 'fafad2'},     {name: 'LightGray',            color: 'd3d3d3'},     {name: 'LightGrey',            color: 'd3d3d3'},     {name: 'LightGreen',           color: '90ee90'},     {name: 'LightPink',            color: 'ffb6c1'},     {name: 'LightSalmon',          color: 'ffa07a'},     {name: 'LightSeaGreen',        color: '20b2aa'},     {name: 'LightSkyBlue',         color: '87cefa'},     {name: 'LightSlateGray',       color: '778899'},     {name: 'LightSlateGrey',       color: '778899'},     {name: 'LightSteelBlue',       color: 'b0c4de'},     {name: 'LightYellow',          color: 'ffffe0'},     {name: 'Lime',                 color: '00ff00'},     {name: 'LimeGreen',            color: '32cd32'},     {name: 'Linen',                color: 'faf0e6'},     {name: 'Magenta',              color: 'ff00ff'},     {name: 'Maroon',               color: '800000'},     {name: 'MediumAquaMarine',     color: '66cdaa'},     {name: 'MediumBlue',           color: '0000cd'},     {name: 'MediumOrchid',         color: 'ba55d3'},     {name: 'MediumPurple',         color: '9370db'},     {name: 'MediumSeaGreen',       color: '3cb371'},     {name: 'MediumSlateBlue',      color: '7b68ee'},     {name: 'MediumSpringGreen',    color: '00fa9a'},     {name: 'MediumTurquoise',      color: '48d1cc'},     {name: 'MediumVioletRed',      color: 'c71585'},     {name: 'MidnightBlue',         color: '191970'},     {name: 'MintCream',            color: 'f5fffa'},     {name: 'MistyRose',            color: 'ffe4e1'},     {name: 'Moccasin',             color: 'ffe4b5'},     {name: 'NavajoWhite',          color: 'ffdead'},     {name: 'Navy',                 color: '000080'},     {name: 'OldLace',              color: 'fdf5e6'},     {name: 'Olive',                color: '808000'},     {name: 'OliveDrab',            color: '6b8e23'},     {name: 'Orange',               color: 'ffa500'},     {name: 'OrangeRed',            color: 'ff4500'},     {name: 'Orchid',               color: 'da70d6'},     {name: 'PaleGoldenRod',        color: 'eee8aa'},     {name: 'PaleGreen',            color: '98fb98'},     {name: 'PaleTurquoise',        color: 'afeeee'},     {name: 'PaleVioletRed',        color: 'db7093'},     {name: 'PapayaWhip',           color: 'ffefd5'},     {name: 'PeachPuff',            color: 'ffdab9'},     {name: 'Peru',                 color: 'cd853f'},     {name: 'Pink',                 color: 'ffc0cb'},     {name: 'Plum',                 color: 'dda0dd'},     {name: 'PowderBlue',           color: 'b0e0e6'},     {name: 'Purple',               color: '800080'},     {name: 'RebeccaPurple',        color: '663399'},     {name: 'Red',                  color: 'ff0000'},     {name: 'RosyBrown',            color: 'bc8f8f'},     {name: 'RoyalBlue',            color: '4169e1'},     {name: 'SaddleBrown',          color: '8b4513'},     {name: 'Salmon',               color: 'fa8072'},     {name: 'SandyBrown',           color: 'f4a460'},     {name: 'SeaGreen',             color: '2e8b57'},     {name: 'SeaShell',             color: 'fff5ee'},     {name: 'Sienna',               color: 'a0522d'},     {name: 'Silver',               color: 'c0c0c0'},     {name: 'SkyBlue',              color: '87ceeb'},     {name: 'SlateBlue',            color: '6a5acd'},     {name: 'SlateGray',            color: '708090'},     {name: 'SlateGrey',            color: '708090'},     {name: 'Snow',                 color: 'fffafa'},     {name: 'SpringGreen',          color: '00ff7f'},     {name: 'SteelBlue',            color: '4682b4'},     {name: 'Tan',                  color: 'd2b48c'},     {name: 'Teal',                 color: '008080'},     {name: 'Thistle',              color: 'd8bfd8'},     {name: 'Tomato',               color: 'ff6347'},     {name: 'Turquoise',            color: '40e0d0'},     {name: 'Violet',               color: 'ee82ee'},     {name: 'Wheat',                color: 'f5deb3'},     {name: 'White',                color: 'ffffff'},     {name: 'WhiteSmoke',           color: 'f5f5f5'},     {name: 'Yellow',               color: 'ffff00'},     {name: 'YellowGreen',          color: '9acd32'} ];    const genColorNameLightness = [     {name: 'pale',   value: 0.87},     {name: 'light',  value: 0.76},     {name: 'bright', value: 0.65},     {name: 'deep',   value: 0.35},     {name: 'dim',    value: 0.22},     {name: 'dark',   value: 0.12} ];    const genColorNameSaturation = [     {name: 'calm',  value: 0.72},     {name: 'dull',  value: 0.46},     {name: 'dirty', value: 0.21} ];    const genColorNameHue = [     {name: 'violet',  value: 285},     {name: 'purple',  value: 269},     {name: 'indigo',  value: 252},     {name: 'blue',    value: 241},     {name: 'cobalt',  value: 222},     {name: 'sky',     value: 211},     {name: 'aqua',    value: 193},     {name: 'cyan',    value: 177},     {name: 'jade',    value: 154},     {name: 'green',   value: 112},     {name: 'lime',    value:  74},     {name: 'yellow',  value:  54},     {name: 'mango',   value:  42},     {name: 'orange',  value:  30},     {name: 'amber',   value:  17},     {name: 'salmon',  value:  11},     {name: 'red',     value:   0},     {name: 'rose',    value: 335},     {name: 'magenta', value: 310} ];    function parseColorNameLightness(name)  {     for (const item of genColorNameLightness)      {         if (   name.startsWith(item.name)              ||     f1491(name.slice(0, item.name.length), item.name) <= 1                && !genColorNameHue.find(h => h.name.startsWith(name)))          {             return { value:     item.value,                       remaining: name.slice(item.name.length) };         }     }      return { value:     null,               remaining: name }; }    function parseColorNameSaturation(name)  {     for (const item of genColorNameSaturation)      {         if (   name.startsWith(item.name)              ||     f1491(name.slice(0, item.name.length), item.name) <= 1                && !genColorNameHue.find(h => h.name.startsWith(name)))          {             return { value:     item.value,                       remaining: name.slice(item.name.length) };         }     }      return { value:     null,               remaining: name }; }    function parseColorNameHue(name)  {     for (const item of genColorNameHue)      {         if (   name === item.name              || f1491(name.slice(0, item.name.length), item.name) <= 1)          {             return item.value;         }     }      return null; }    function parseColorName(_colorName)  {     let colorName = _colorName.replace(/\s+/g, '');       if (   colorName === 'black'          || f1491(colorName, 'black') <= 1)         return [0, 0, 0];      if (   colorName === 'white'          || f1491(colorName, 'white') <= 1)         return [0, 0, 1];               const grayVariants = ['gray', 'grey'];      let isGray = false;     let gl     = 0.5;      for (const grayVariant of grayVariants)      {         if (   colorName.endsWith(grayVariant)              || f1491(colorName.slice(-grayVariant.length), grayVariant) <= 1)          {             isGray = true;                      const grayPrefix = colorName.slice(0, -grayVariant.length);                          if (grayPrefix)              {                 const { value } = parseColorNameLightness(grayPrefix);                                  if (value !== null)                      gl = value;             }              break;         }     }       if (isGray)         return [0, 0, gl];       let h = null;     let s = null;     let l = null;                     let result  = parseColorNameLightness(colorName);         l       = result.value;     let remName = result.remaining;          result  = parseColorNameSaturation(remName);         s       = result.value;         remName = result.remaining;          h       = parseColorNameHue(remName);                      if (   h === null          || s === null          || l === null)      {         h = null;         s = null;         l = null;          result  = parseColorNameSaturation(colorName);         s       = result.value;         remName = result.remaining;          result  = parseColorNameLightness(remName);         l       = result.value;         remName = result.remaining;          h       = parseColorNameHue(remName);     }       if (h === null) return null;      if (l === null) l = 0.5;     if (s === null) s = 1.0;           return [h / 360, s, l]; }    function createColorName(rgb) {     if (rgb.length > 3 && rgba[3] == 0)         return 'transparent';       const hsl = t48(rgb);      let   h = hsl[0] * 360;      while (h >= 360) h -= 360;     while (h <    0) h += 360;          const s = hsl[1];     const l = hsl[2];            if (l >= 0.94) return 'white';     else if (l <  0.06) return 'black';       let strH = '';     let strS = '';     let strL = '';            if (l >= 0.81 && l < 0.94) strL = 'pale ';     else if (l >= 0.69 && l < 0.81) strL = 'light ';     else if (l >= 0.56 && l < 0.69) strL = 'bright ';     else if (l >= 0.31 && l < 0.44) strL = 'deep ';     else if (l >= 0.19 && l < 0.31) strL = 'dim ';     else if (l >= 0.06 && l < 0.19) strL = 'dark ';           if (l > 0.25 && l < 0.75)      {              if (s >= 0.62 && s < 0.88) strS = 'calm ';         else if (s >= 0.31 && s < 0.62) strS = 'dull ';         else if (s >= 0.12 && s < 0.31) strS = 'dirty ';     }       if (s >= 0.12)     {              if (h < 293 && h >= 278) strH = 'violet';         else if (h < 278 && h >= 259) strH = 'purple';         else if (h < 259 && h >= 248) strH = 'indigo';         else if (h < 248 && h >= 233) strH = 'blue';         else if (h < 233 && h >= 221) strH = 'cobalt';         else if (h < 221 && h >= 201) strH = 'sky';         else if (h < 201 && h >= 185) strH = 'aqua';         else if (h < 185 && h >= 169) strH = 'cyan';         else if (h < 169 && h >= 139) strH = 'jade';         else if (h < 139 && h >=  86) strH = 'green';         else if (h <  86 && h >=  63) strH = 'lime';         else if (h <  63 && h >=  45) strH = 'yellow';         else if (h <  45 && h >=  40) strH = 'mango';         else if (h <  40 && h >=  21) strH = 'orange';         else if (h <  21 && h >=  13) strH = 'amber';         else if (h <  13 && h >=   8) strH = 'salmon';         else if (h <   8 || h >= 352) strH = 'red';         else if (h < 352 && h >= 328) strH = 'rose';         else if (h < 328 && h >= 293) strH = 'magenta';         else              console.error('error parsing hue name');     }     else          strH = 'gray';       return strL + strS + strH; } 


var _clipboard = '';    function k867(str)  {     if (subscribed())     {         if (   navigator.clipboard              && window.isSecureContext)              return navigator.clipboard.writeText(str);          else          {             const prevActive = document.activeElement;             const textArea   = document.createElement('textarea');              textArea.value = str;              textArea.style.position = 'fixed';             textArea.style.left     = '-999999px';             textArea.style.top      = '-999999px';                          document.body.appendChild(textArea);                          textArea.focus();             textArea.select();                          return new Promise((res, rej) =>              {                 document.execCommand('copy') ? res() : rej();                 textArea.remove();                  prevActive.focus();             });         }     }     else         _clipboard = str; }    function u868()  {     if (subscribed())     {         if (   navigator.clipboard              && window.isSecureContext)              return navigator.clipboard.readText();          else          {             let textArea = document.createElement('textarea');              textArea.style.position = 'fixed';             textArea.style.left     = '-999999px';             textArea.style.top      = '-999999px';                          document.body.appendChild(textArea);                          textArea.focus({preventScroll: true});             textArea.select();                          return new Promise((res, rej) =>              {                 document.execCommand('paste') ? res(textArea.value) : rej();                 textArea.remove();             });         }     }     else         return new Promise((res, rej) => res(_clipboard)); }


function r1048(key, tag)  {     return key.substring(0, tag.length+1) == tag + ' '; }    function v1049(key, tag) {     return key.substring(tag.length+1); }    function n1050(key) { return r1048(key, w877); } function x1051(key) { return r1048(key, c875); } function w1052(key) { return r1048(key, n876); }    function d1053(key) { return v1049(key, w877); } function y1054(key) { return v1049(key, c875); } function a1055(key) { return v1049(key, n876); }


const b963               = '\uFFFD'; const g964            = '?';      const g965           = '?'; const u966        = g965;  const NAME_SEPARATOR         = ' '; const h967       = ' > '; const   o968       = ' / '; const  c969       = ':';  const s970          = ' •'; const  o971          = ' ◇';       const  z972    = '<svg width="13" height="11" viewBox="0 1 13 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.3645 1.82058L10.2676 0.599976L5.1191 8.58091L2.44314 6.06144L0.800003 7.67327L5.54161 12.1958L12.3645 1.82058Z" fill="#2AD400"/></svg>';
const d973    = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="#F43D3D"/></svg>';    
 const  k974     = '<svg width="12" height="11" viewBox="0 0 12 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M11.1 0.998457L9.41674 0L4.20109 8.01592L1.50123 5.4381L0.1 6.77599L4.52397 11L11.1 0.998457Z" fill="#3FF911"/></svg>';
const s975     = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="#FF3E3E"/></svg>';
 const  c976 = '<svg width="11" height="11" viewBox="0 0 11 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.7157 0.893364L9.55198 0.139526L4.15187 8.47598L1.20316 5.59262L0.248535 6.5928L4.41886 10.5815L5.04702 9.60025L10.7157 0.893364Z" fill="black"/></svg>';
const y977 = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.13479 0.1521L0.1521 1.13479L3.51727 4.49997L0.152106 7.86514L1.1348 8.84783L4.49997 5.48266L7.86511 8.8478L8.8478 7.86511L5.48266 4.49997L8.84781 1.13482L7.86511 0.152129L4.49997 3.51727L1.13479 0.1521Z" fill="black"/></svg>';
 const  j978  = '<svg width="12" height="11" viewBox="0 0 12 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M11.1 0.998457L9.41672 0L4.20107 8.01592L1.50121 5.4381L0.0999756 6.77599L4.52395 11L11.1 0.998457Z" fill="white"/></svg>';
const w979  = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="white"/></svg>';
 const  t980     = '<svg width="12" height="11" viewBox="0 0 12 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M11.1 0.998457L9.41675 0L4.2011 8.01592L1.50124 5.4381L0.100006 6.77599L4.52398 11L11.1 0.998457Z" fill="white"/></svg>';
const j981     = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="white"/></svg>';
   function i982(color = true) {     return o4007          ? (color ? k974  : j978 )          : (color ? z972 : c976); }    function s983(color = true) {     return o4007          ? (color ? s975  : w979 )          : (color ? d973 : y977); }


var showDebugInfo = false;  var debugFlag1    = false;    function w961(nodeIds) {     let str = '';      for (let i = 0; i < nodeIds.length; i++)     {         if (i > 0) str += ', ';         str += nodeIds[i];     }      return str; }    function j962(nodes) {     let str = '';      nodes.map(n => n ? n.id : 'undefined').join(', ');                                return str; }    function updateDebugInfo() {     if (showDebugInfo)     {         debugInfoText.style.display = 'inline-block';          debugInfoText.innerHTML =                         'pan = '  + graph.currentPage.pan.x.toFixed(2) + ', ' + graph.currentPage.pan.y.toFixed(2)             + '<br/>' + 'zoom = ' + graph.currentPage.zoom.toFixed(4);     }     else         debugInfoText.style.display = 'none'; }


const b1040   = 0,       v1041 = 1,       w1042 = 2,       w1043  = 3;    class a1044 {     initial;     current;            constructor()     {         this.reset();     }            set(seed)     {         this.initial = seed;         this.current = seed;     }                rotate()     {         this.current = (this.current + 0x7ed55d16) + (this.current << 12);         this.current = (this.current ^ 0xc761c23c) ^ (this.current >> 19);         this.current = (this.current + 0x165667b1) + (this.current <<  5);         this.current = (this.current + 0xd3a2646c) ^ (this.current <<  9);         this.current = (this.current + 0xfd7046c5) + (this.current <<  3);         this.current = (this.current ^ 0xb55a4f09) ^ (this.current >> 16);     }                next()     {         const seed = this.current;         this.rotate();         return seed;     }        reset()     {         this.current = this.initial;     } };    class Noise { 	interpolation = w1043; 	clip = false;  	seed = new a1044();  	v0; 	v1; 	v2; 	v3;  	step = 0;       constructor(seed = 0)     {         this.seed.set(seed);         this.reset();     }       next(scale = 1)     {                  scale = Math.max(1, scale);          let next = this.v1;          if (this.step >= 1)         {                                   this.seed.rotate();              this.v0 = this.v1;                      this.v1 = this.v2;             this.v2 = this.v3;                      this.v3 = y1045(this.seed.current);              this.step -= 1;         }                    switch (this.interpolation)         {             case b1040:             {                 next = this.v1;                 break;             }             case v1041:             {                 next = this.v1 + this.step * (this.v2 - this.v1);                 break;             }             case w1042:             {                 const ft = this.step * Math.PI;                 const f  = (1 - Math.cos(ft)) * 0.5;                                  next = this.v1 + f * (this.v2 - this.v1);                 break;             }             case w1043:             {                 const p = (this.v3 - this.v2) - (this.v0 - this.v1);                 const q = (this.v0 - this.v1) - p;                 const r =  this.v2 - this.v0;                 const s =  this.v1;                  const val =                        p * cube(this.step)                      + q * sqr(this.step)                      + r * this.step                      + s;                  next = this.clip                      ? Math.max(0, Math.min(val, 1))                      : val;                  break;             }         }          this.step += 1 / scale;          return next;     }          reset()     {         this.seed.reset();          this.v0 = y1045(this.seed.current); this.seed.rotate();         this.v1 = y1045(this.seed.current); this.seed.rotate();         this.v2 = y1045(this.seed.current); this.seed.rotate();         this.v3 = y1045(this.seed.current); this.seed.rotate();          this.step = 0;     } }   function y1045(x) {     return x / -0x7fffffff; }


const settings = {     debugMode:                     false,              q2552:         false,     m2553:              0.35,     objectCenterSize:              18,     e4021:               500,     showPages:                     false,     showAllColorSpaces:            false,     showNodeIcons:                 true,     showBoolValues:                true,     separateThousands:             true,     invertSimpleMathParamOrder:    true,     activateDeactiatesOthers:      true,     preferHtmlColorNames:          false,     randomShiftR:                  true,     colorShiftR:                   true,      showSnapshots:                 false,     showRestartInfo:               true,     showColorLegendInMenus:        false,     showClearUndoWarning:          true,     shareUsageMetrics:             true,     showObjectCount:               true,     showDebugMenu:                 false,              showNodeId:                    false,      h2554:           false,     enableAsserts:                 false,      showTooltipLongText:           false,     showTooltipLists:              false,     showTooltipColorInterpolation: true,     showTooltipColorBlindness:     true,     showTooltipColorContrast:      true,     showTooltipColorNames:         true,     showTooltipAscii:              true,      enableBetaFeatures:            false,                  logThreadMessages:             false,     logDataMessages:               false,     logMessages:                   false,      logActions:                    false,                   logLoading:                    false,      logRequests:                   false,      logValueUpdates:               false,      logObjectUpdates:              false,     logStyleUpdates:               false,                  logRawLoadPages:               false,      logRawLoadNodes:               false,      logRawLoadConnections:         false,               logRawSavePages:               false,      logRawSaveNodes:               false,      logRawSaveConnections:         false,               logRawRequests:                false,      logRawValues:                  false,      sessionId:                     '' };    function u3593(c3661, value) {     switch (c3661)     {         case 'debugMode':                     settings.debugMode                     = value;  break;                          case 'enableZoomedOutParams':         settings.q2552         = value;  break;         case 'minZoomForParams':              settings.m2553              = value;  break;         case 'objectCenterSize':              settings.objectCenterSize              = value;  break;         case 'objectBatchSize':               settings.e4021               = value;  break;         case 'showPages':                     settings.showPages                     = value;  break;         case 'showAllColorSpaces':            settings.showAllColorSpaces            = value;  break;         case 'showNodeIcons':                 settings.showNodeIcons                 = value;  break;         case 'showBoolValues':                settings.showBoolValues                = value;  break;         case 'separateThousands':             settings.separateThousands             = value;  break;         case 'invertSimpleMathParamOrder':    settings.invertSimpleMathParamOrder    = value;  break;         case 'activateDeactiatesOthers':      settings.activateDeactiatesOthers      = value;  break;         case 'preferHtmlColorNames':          settings.preferHtmlColorNames          = value;  break;         case 'randomShiftR':                  settings.randomShiftR                  = value;  break;         case 'colorShiftR':                   settings.colorShiftR                   = value;  break;                  case 'showSnapshots':                 settings.showSnapshots                 = value;  break;         case 'showRestartInfo':               settings.showRestartInfo               = value;  break;         case 'showColorLegendInMenus':        settings.showColorLegendInMenus        = value;  break;         case 'showClearUndoWarning':          settings.showClearUndoWarning          = value;  break;         case 'shareUsageMetrics':             settings.shareUsageMetrics             = value;  break;         case 'showObjectCount':               settings.showObjectCount               = value;  break;         case 'showDebugMenu':                 settings.showDebugMenu                 = value;  break;                                  case 'showNodeId':                    settings.showNodeId                    = value;  break;         case 'showTransformPoints':           settings.h2554           = value;  break;         case 'enableAsserts':                 settings.enableAsserts                 = value;  break;          case 'showTooltipLists':              settings.showTooltipLists              = value;  break;         case 'showTooltipLongText':           settings.showTooltipLongText           = value;  break;         case 'showTooltipColorInterpolation': settings.showTooltipColorInterpolation = value;  break;         case 'showTooltipColorBlindness':     settings.showTooltipColorBlindness     = value;  break;         case 'showTooltipColorContrast':      settings.showTooltipColorContrast      = value;  break;         case 'showTooltipColorNames':         settings.showTooltipColorNames         = value;  break;         case 'showTooltipAscii':              settings.showTooltipAscii              = value;  break;          case 'enableBetaFeatures':            settings.enableBetaFeatures            = value;  break;                             case 'logThreadMessages':             settings.logThreadMessages             = value;  break;         case 'logDataMessages':               settings.logDataMessages               = value;  break;         case 'logMessages':                   settings.logMessages                   = value;  break;          case 'logActions':                    settings.logActions                    = value;  break;         case 'logLoading':                    settings.logLoading                    = value;  break;         case 'logRequests':                   settings.logRequests                   = value;  break;         case 'logValueUpdates':               settings.logValueUpdates               = value;  break;         case 'logObjectUpdates':              settings.logObjectUpdates              = value;  break;         case 'logStyleUpdates':               settings.logStyleUpdates               = value;  break;                             case 'logRawLoadPages':               settings.logRawLoadPages               = value;  break;         case 'logRawLoadNodes':               settings.logRawLoadNodes               = value;  break;         case 'logRawLoadConnections':         settings.logRawLoadConnections         = value;  break;                          case 'logRawSavePages':               settings.logRawSavePages               = value;  break;         case 'logRawSaveNodes':               settings.logRawSaveNodes               = value;  break;         case 'logRawSaveConnections':         settings.logRawSaveConnections         = value;  break;                          case 'logRawRequests':                settings.logRawRequests                = value;  break;         case 'logRawValues':                  settings.logRawValues                  = value;  break;          case 'sessionId':                     settings.sessionId                     = value;  break;     }        switch (c3661)     {         case 'objectCenterSize':             c2497(             {                 cmd:             'figUpdateObjectCenterSize',                 objectCenterSize: settings.objectCenterSize             });             break;     } }    function h3517(c3661, valid, value, save = true) {     switch (c3661)     {         case 'debugMode':                     z3660(valid, c3661, value, t722                    ); break;                        case 'enableZoomedOutParams':         z3660(valid, c3661, value, i648        ); break;         case 'showPages':                     z3660(valid, c3661, value, h652                    ); break;         case 'showAllColorSpaces':            z3660(valid, c3661, value, t654           ); break;         case 'showNodeIcons':                 z3660(valid, c3661, value, n655                ); break;         case 'showBoolValues':                z3660(valid, c3661, value, a657               ); break;         case 'separateThousands':             z3660(valid, c3661, value, t658            ); break;         case 'invertSimpleMathParamOrder':    z3660(valid, c3661, value, y659   ); break;         case 'activateDeactiatesOthers':      z3660(valid, c3661, value, menuItemActivateDeactiatesOthers     ); break;         case 'preferHtmlColorNames':          z3660(valid, c3661, value, menuItemPreferHtmlColorNames         ); break;         case 'randomShiftR':                  z3660(valid, c3661, value, menuItemRandomShiftR                 ); break;         case 'colorShiftR':                   z3660(valid, c3661, value, menuItemColorShiftR                  ); break;          case 'showSnapshots':                 z3660(valid, c3661, value, menuItemShowSnapshots                ); break;         case 'showRestartInfo':               z3660(valid, c3661, value, menuItemShowRestartInfo              ); break;         case 'showColorLegendInMenus':        z3660(valid, c3661, value, j656       ); break;         case 'showClearUndoWarning':          z3660(valid, c3661, value, d660         ); break;         case 'shareUsageMetrics':             z3660(valid, c3661, value, h661            ); break;         case 'showObjectCount':               z3660(valid, c3661, value, z663              ); break;         case 'showDebugMenu':                 z3660(valid, c3661, value, z664                ); break;                                case 'showNodeId':                    z3660(valid, c3661, value, p667                   ); break;         case 'showTransformPoints':           z3660(valid, c3661, value, z668          ); break;         case 'enableAsserts':                 z3660(valid, c3661, value, c669                ); enableAsserts = value; break;                  case 'showTooltipLists':              z3660(valid, c3661, value, d643             ); break;         case 'showTooltipLongText':           z3660(valid, c3661, value, m642          ); break;         case 'showTooltipColorInterpolation': z3660(valid, c3661, value, a644); break;         case 'showTooltipColorBlindness':     z3660(valid, c3661, value, l647    ); break;         case 'showTooltipColorContrast':      z3660(valid, c3661, value, n645     ); break;         case 'showTooltipColorNames':         z3660(valid, c3661, value, q646        ); break;         case 'showTooltipAscii':              z3660(valid, c3661, value, l647    ); break;          case 'enableBetaFeatures':            z3660(valid, c3661, value, menuItemEnableBetaFeatures           ); break;                                case 'logThreadMessages':             z3660(valid, c3661, value, k723            ); break;         case 'logDataMessages':               z3660(valid, c3661, value, y724              ); break;         case 'logMessages':                   z3660(valid, c3661, value, t725                  ); break;          case 'logActions':                    z3660(valid, c3661, value, t726                   ); break;         case 'logLoading':                    z3660(valid, c3661, value, p727                   ); break;         case 'logRequests':                   z3660(valid, c3661, value, j728                  ); break;         case 'logValueUpdates':               z3660(valid, c3661, value, z729              ); break;         case 'logObjectUpdates':              z3660(valid, c3661, value, j730             ); break;         case 'logStyleUpdates':               z3660(valid, c3661, value, h731              ); break;                                case 'logRawLoadPages':               z3660(valid, c3661, value, z732              ); break;         case 'logRawLoadNodes':               z3660(valid, c3661, value, n733              ); break;         case 'logRawLoadConnections':         z3660(valid, c3661, value, c734        ); break;                                case 'logRawSavePages':               z3660(valid, c3661, value, n735              ); break;         case 'logRawSaveNodes':               z3660(valid, c3661, value, v736              ); break;         case 'logRawSaveConnections':         z3660(valid, c3661, value, g737        ); break;                                case 'logRawRequests':                z3660(valid, c3661, value, e738               ); break;         case 'logRawValues':                  z3660(valid, c3661, value, u739                 ); break;     }        if (   save         && c3661 != 'showAllColorSpaces')         l2556(c3661, u937(value)); }    function z3660(valid, setting, value, menu) {     if (valid)          settings[setting] = value;         switch (setting)     {         case 'showNodeId':             c2497(             {                 cmd:    'figUpdateShowIds',                 d2800: settings.showNodeId             });             break;     }       if (menu)         menu.f2871(settings[setting]); }    function updateSettingsMenus() {     t722                    .n326(settings.debugMode                    );                      i648        .f2871(settings.q2552        );     h652                    .f2871(settings.showPages                    );     t654           .f2871(settings.showAllColorSpaces           );     n655                .f2871(settings.showNodeIcons                );     a657               .f2871(settings.showBoolValues               );     t658            .f2871(settings.separateThousands            );     y659   .f2871(settings.invertSimpleMathParamOrder   );     menuItemActivateDeactiatesOthers     .f2871(settings.activateDeactiatesOthers     );     menuItemPreferHtmlColorNames         .f2871(settings.preferHtmlColorNames         );     menuItemRandomShiftR                 .f2871(settings.randomShiftR                 );     menuItemColorShiftR                  .f2871(settings. colorShiftR                 );      menuItemShowSnapshots                .f2871(settings.showSnapshots                );     menuItemShowRestartInfo              .f2871(settings.showRestartInfo              );     j656       .f2871(settings.showColorLegendInMenus       );     d660         .f2871(settings.showClearUndoWarning         );     h661            .f2871(settings.shareUsageMetrics            );     z663              .f2871(settings.showObjectCount              );     z664                .f2871(settings.showDebugMenu                );                      p667                   .f2871(settings.showNodeId                   );     z668          .f2871(settings.h2554          );     c669                .f2871(settings.enableAsserts                );      d643             .f2871(settings.showTooltipLists             );     m642          .f2871(settings.showTooltipLongText          );     a644.f2871(settings.showTooltipColorInterpolation);     l647    .f2871(settings.showTooltipColorBlindness    );     n645     .f2871(settings.showTooltipColorContrast     );     q646        .f2871(settings.showTooltipColorNames        );     menuItemShowTooltipAscii             .f2871(settings.showTooltipAscii             );                            k723            .f2871(settings.logThreadMessages            );     y724              .f2871(settings.logDataMessages              );     t725                  .f2871(settings.logMessages                  );      t726                   .f2871(settings.logActions                   );                        p727                   .f2871(settings.logLoading                   );     j728                  .f2871(settings.logRequests                  );     z729              .f2871(settings.logValueUpdates              );     j730             .f2871(settings.logObjectUpdates             );     h731              .f2871(settings.logStyleUpdates              );                        n733              .f2871(settings.logRawLoadPages              );     n733              .f2871(settings.logRawLoadNodes              );     c734        .f2871(settings.logRawLoadConnections        );                          n735              .f2871(settings.logRawSaveNodes              );     v736              .f2871(settings.logRawSaveNodes              );     g737        .f2871(settings.logRawSaveConnections        );                      e738               .f2871(settings.logRawRequests               );     u739                 .f2871(settings.logRawValues                 ); }    function updateMenuItemShowPages() {     o2560('showPages', u937(settings.showPages));     graph.u2088();     u186.update(); }    function updateMenuItemShowSnapshots() {     o2560('showSnapshots', u937(settings.showSnapshots));      snapshotBar.style.display = settings.showSnapshots ? 'block' : 'none';      }    function updateMenuItemShowAllColorSpaces() {     o2560('showAllColorSpaces', u937(settings.showAllColorSpaces));      graph.nodes         .filter(n => j1177.includes(n.type))         .forEach(n => n.y3031()); }    function updateMenuItemShowNodeIcons() {     graph.nodes.forEach(n => n.y3031()); }    function updateMenuItemShowBoolValues() {     graph.nodes         .filter(n => n.params.find(p => p.type == t1091) != null)         .forEach(n => n.y3031()); }    function updateMenuItemSeparateThousands() {     graph.nodes         .filter(n => n.params.find(p => p.type == t1091) != null)         .forEach(n => n.y3031()); }    function updateMenuItemInvertSimpleMathParamOrder() {     graph.nodes         .filter(n => n.type == g1113)         .forEach(n => n.y3031()); }    function updateMenuItemShowColorLegendInMenus() {     for (const menu of b575)         menu.items.forEach(i => i.t3454()); }    function enableFeatures(sub) {     enableMenuItem(menuItemSetValueNames,      true, sub);     enableMenuItem(menuItemEnableBetaFeatures, true, sub);     enableMenuItem(menuItemCopyLLMPrompt,      true, sub, true, currentUserIsDev());       enableMenuItem(menuItemShowRestartInfo,    true, sub);     enableMenuItem(menuItemValueName,          true, sub);     enableMenuItem(menuItemObjectName,         true, sub);     enableMenuItem(p689,           true, sub, true);     enableMenuItem(n692,              true, sub);     enableMenuItem(n694,            true, sub, true);     enableMenuItem(h671,         true, sub);     enableMenuItem(menuItemSaveSelected,       true, sub);     enableMenuItem(q695,              true, sub);     enableMenuItem(a701,           true, sub);     enableMenuItem(g703,              true, sub);     enableMenuItem(u3475,           true, sub);     enableMenuItem(x705,       true, sub);     enableMenuItem(e706,        true, sub);     enableMenuItem(d720,        true, sub);     enableMenuItem(menuItemVectorSep1,         true, sub, true);     enableMenuItem(menuItemVectorVertex,       true, sub, true);     enableMenuItem(menuItemVectorEdge,         true, sub, true);     enableMenuItem(menuItemVectorRegion,       true, sub, true);     enableMenuItem(menuItemVectorNetwork,      true, sub, true);     enableMenuItem(menuItemBooleanShape,       true, sub, true);     enableMenuItem(menuItemSaveTemplate,       true, sub);     enableMenuItem(g721,    true, sub);       updatePanelButton();       graph.nodes.forEach(n => n.k3495(sub)); }    function updatePanelButton() {     if (e567     ) e567     .div.style.display = !(settings.enableBetaFeatures && subscribed()) ? 'inline-block' : 'none';     if (btnDecoration) btnDecoration.div.style.display =  (settings.enableBetaFeatures && subscribed()) ? 'inline-block' : 'none'; }    function enableMenuItem(menuItem, enable, sub, beta = false, show = true) {     if (!menuItem) return;      menuItem.enabled = enable;     menuItem.sub     = sub;      menuItem.n326(            show          && (               !beta             || beta && sub && settings.enableBetaFeatures));      menuItem.update(); }    function updateMenuItemShowDebugMenu() {     updateElementDisplay(x672.div, settings.showDebugMenu);      y576.update(         a995(y576.div).x + 6,         a995(y576.div).y - 4,         true); }     function updateElementDisplay(menuItem, enable) {     menuItem.style.display = enable ? 'block' : 'none'; }    function loadLocalSettings() {     e2555('debugMode'                    );              e2555('enableZoomedOutParams'        );     e2555('minZoomForParams'             );     e2555('objectCenterSize'             );     e2555('objectBatchSize'              );     e2555('showNodeIcons'                );     e2555('showBoolValues'               );     e2555('separateThousands'            );     e2555('invertSimpleMathParamOrder'   );     e2555('activateDeactiatesOthers'     );     e2555('preferHtmlColorNames'         );     e2555('randomShiftR'                 );     e2555('colorShiftR'                  );      e2555('showSnapshots'                );     e2555('showRestartInfo'              );     e2555('showColorLegendInMenus'       );     e2555('showPages'                    );     e2555('showClearUndoWarning'         );     e2555('shareUsageMetrics'            );     e2555('showObjectCount'              );     e2555('showDebugMenu'                );              e2555('showNodeId'                   );     e2555('showTransformPoints'          );     e2555('enableAsserts'                );      e2555('showTooltipLists'             );     e2555('showTooltipLongText'          );     e2555('showTooltipColorInterpolation');     e2555('showTooltipColorBlindness'    );     e2555('showTooltipColorContrast'     );     e2555('showTooltipColorNames'        );     e2555('showTooltipAscii'             );      e2555('enableBetaFeatures'           );                  e2555('logThreadMessages'            );     e2555('logDataMessages'              );     e2555('logMessages'                  );      e2555('logActions'                   );                  e2555('logLoading'                   );     e2555('logRequests'                  );     e2555('logValueUpdates'              );     e2555('logObjectUpdates'             );     e2555('logStyleUpdates'              );                  e2555('logRawLoadPages'              );     e2555('logRawLoadNodes'              );     e2555('logRawLoadConnections'        );              e2555('logRawSavePages'              );     e2555('logRawSaveNodes'              );     e2555('logRawSaveConnections'        );              e2555('logRawRequests'               );     e2555('logRawValues'                 ); }


const y1056           = 'LIST#';  const m1057    = 'NLIST#'; const   u1058    = 'TLIST#'; const  y1059    = 'SLIST#';   const d1060            = 'NULL'; const w1061             = 'VAR'; const p1062       = 'VARGRP'; const p1063             = 'FEEDBK'; const m1064               = 'REPT'; const p1065                = 'CACHE'; const t1066               = 'FRZ'; const n1067                = 'TIMER'; const i1068           = 'VNAME'; const f1352 = 'GVNAMES'; const y1353     = 'VNAMES'; const c1354          = 'ONAME';  const v1069              = 'CMB'; const j1070         = 'LSASIT'; const m1071              = 'EXTR'; const v1072            = 'SETP'; const v1073            = 'GETP'; const w1074              = 'SUBLST'; const g1075               = 'UNIQ'; const q1349         = 'RORD'; const f1350           = 'SHFTLST'; const b1076         = 'REVLST'; const q1351          = 'BUKLST'; const w1077                 = 'SORT'; const p1078               = 'CLMN'; const o1079                 = 'CELL'; const c1080                 = 'LIST'; const k1081           = 'COUNT'; const OBJECT_COUNT         = 'OBJCOUNT'; const t1082             = 'LCONT'; const x1083               = 'SELECT'; const a1360     = 'LSTSEL'; const w1084              = 'IF'; const h1085               = 'LSTFLT';   const u1087            = 'ANY#';   const k1088 = [     y1056,     m1057,     u1058,     y1059,     v1069,     m1071,     v1072,     v1073,     w1074,     c1080,     k1081,     t1082,     m1064 ];   const x1089 = [            y1056,     m1057,       u1058,      y1059 ];   const l1086                 = 'ITER';   const g1108             = 'PROB';   const HOLD                    = 'HOLD';   const t1091            = 'NUM#';   const g1092                  = 'NUM';    const y1355        = 'NPREC';    const w1093             = 'NSIGN';    const z1094         = 'ABS';    const h1356         = 'NEG';    const e1095            = 'ROUND';    const z1357         = 'QUANT';    const f1096    = 'SMINMAX';    const g1097           = 'MINMAX';    const j1098           = 'LIM';    const l1099            = 'NCURVE';    const x1358              = 'NMAP';    const l1359             = 'NBIAS';    const e1100              = 'NANISNUM'; const i1101         = 'CONST';   const d1102         = 'DATE';   const w1103         = 'SEQ';   const l1104            = 'RANGE';   const a1105             = 'WAVE';   const c1106           = 'RAND';   const a1107            = 'NOISE';   const r1109       = 'ACCUM';   const y1110      = 'LERP';  const c1111            = 'SOLVE'; const w1112          = 'NANIM';  const g1113      = 'SMATH';   const w1114             = 'MATH';   const s1115              = 'ADD';    const d1116         = 'SUB';    const s1117         = 'MUL';    const t1118           = 'DIV';    const f1119           = 'MOD';    const e1120         = 'EXP';  const z1121          = 'NBOOL';   const d1122              = 'NOT'; const k1123              = 'AND'; const s1124               = 'OR'; const p1125              = 'XOR';  const g1126        = 'COND'; const y1127            = 'EQ'; const v1128        = 'NE'; const s1129             = 'LT'; const b1130    = 'LE'; const u1131          = 'GT'; const m1132 = 'GE';  const e1133             = 'TRIG';   const j1134              = 'SIN';    const u1135              = 'COS';    const h1136              = 'TAN'; const x1137            = 'ATAN2';  const l1138           = 'CNVANG';   const d1090 = [     d1060,     w1061,     p1062,     ...k1088,     j1070,     m1071,     v1072,     v1073,     w1074,     g1075,     q1349,     f1350,     b1076,     q1351,     p1078,     w1077,     o1079,     c1080,     x1083,     a1360,     w1084,     h1085,     p1063,     m1064,          l1086,     g1108,     HOLD,     p1065,     t1066,     n1067,     i1068,     f1352,     y1353,     c1354 ];   const v1139 = [     w1114,     g1113,     s1115,     d1116,     s1117,     t1118,     f1119,     e1120 ];   const e1140 = [     z1121,     d1122,     k1123,     s1124,     p1125 ];   const l1141 = [     g1126,     y1127,     v1128,     s1129,     b1130,     u1131,     m1132 ];   const n1142 = [     e1133,     j1134,     u1135,     h1136,     x1137 ];   const t1143     = 'TEXT#'; const z1144           = 'TEXT'; const a1145    = 'TLEN'; const x1146      = 'TTRIM'; const z1147 = 'TSUB'; const a1148  = 'TCONT'; const h1149      = 'TCASE'; const a1150   = 'TREPL'; const n1151      = 'TJOIN'; const n1152       = 'TPAD'; const d1153   = 'TCMP'; const h1154      = 'TCHAR'; const f1155   = 'TUNI'; const f1156  = 'INDEX'; const s1157 = 'N2T'; const d1158  = 'C2T'; const w1159 = 'T2N'; const u1160  = 'T2C'; const d1161     = 'TSPLT'; const t3505      = 'TJSON'; const o1163       = 'TCSV'; const q1164     = 'FETCH'; const d1165      = 'TFILE';   const p1166 = [     t1091,     m1057,     g1092,     y1355,     w1093,     z1094,     h1356,     e1095,     z1357,     f1096,     g1097,     j1098,     l1099,     x1358,     l1359,     e1100,     i1101,     d1102,     w1103,     l1104,     a1105,     c1106,     a1107,     r1109,     y1110,     c1111,     w1112,     s1157,     h1154,      ...v1139,     ...e1140,     ...l1141,     ...n1142,      l1138,     q1351 ];   const r1167 = [     t1143,     u1058,     z1144,     a1145,     x1146,     z1147,     a1148,     h1149,     n1151,     n1152,     a1150,     d1153,     f1155,     f1156,     w1159,     u1160,     d1161,     t3505,     o1163,     q1164,     d1165 ];   const x1168        = 'COL#';   const b1169              = 'COL';    const k1170        = 'CVAL';   const g1171      = 'CCOR';   const g1172   = 'COLP3'; const x1173     = 'CCNT';   const b1174         = 'BLND';   const s1175  = 'CLERP';  const l1176        = 'CBLND';   const j1177 = [     x1168,     b1169,     g1171,     g1172,     b1174,     s1175,     l1176,     d1158 ];   const k1178          = 'FILL#'; const r1179                = 'FILL'; const r1180          = [k1178, r1179];    const g1181        = 'STRK#'; const y1182              = 'STRK'; const o1183        = [g1181, y1182];    const p1190  = 'STRKSD#'; const o1191        = 'STRKSD'; const t1192  = [p1190, o1191];  const r1184    = 'CSTOP#'; const n1185          = 'CSTOP'; const h1186    = [r1184, n1185];    const i1187      = 'GRAD#'; const x1188            = 'GRAD'; const d1189      = [i1187, x1188];    const p1193 = 'RCRN#'; const b1194       = 'RCRN'; const a1195 = [p1193, b1194];  const g1196   = 'DRSH#'; const z1197         = 'DRSH'; const c1198   = [g1196, z1197];   const w1199  = 'INSH#'; const k1200        = 'INSH'; const g1201  = [w1199, k1200];   const c1202    = 'LBLR#'; const y1203          = 'LBLR'; const w1204    = [c1202, y1203];   const t1205     = 'BBLR#'; const h1206           = 'BBLR'; const p1207     = [t1205, h1206];   const c1208    = 'MASK#'; const o1209          = 'MASK'; const u1210    = [c1208, o1209];   const v1211   = 'BLEND#'; const h1212         = 'BLEND'; const m1213   = [v1211, h1212];   const e1214 = [     ...t1192,     ...a1195,     ...c1198,     ...g1201,     ...w1204,     ...p1207,     ...m1213,     ...u1210 ];   const o1215 = [            x1168,              k1178,          i1187,            g1181,     p1190,      g1196,     w1199,       c1202,        t1205,      v1211,       c1208 ];   const e1216           = 'CSTL';     const p1217           = 'SHP#';    const w1218       = 'RECT#'; const d1219             = 'RECT';   const v1220       = [w1218, d1219];   const h1221            = 'LINE#'; const t1222                  = 'LINE';  const t1223            = [h1221, t1222];     const m1224         = 'ELPS#'; const w1225               = 'ELPS';  const n1226         = [m1224, w1225];   const r1227         = 'TRPZ#'; const w1228               = 'TRPZ'; const a1229         = [r1227, w1228];   const d1236         = 'POLY#'; const a1237               = 'POLY';  const r1238         = [d1236, a1237];     const x1239            = 'STAR#'; const f1240                  = 'STAR';  const s1241            = [x1239, f1240];     const f1242      = 'TXTS#'; const j1243            = 'TXTS';  const j1244      = [f1242, j1243];    const t1245           = 'PT#'; const g1246                 = 'PT'; const h1247           = [t1245, g1246];  const k1248          = 'PCORN';  const m1249     = 'VPATH#'; const v1250           = 'VPATH';  const r1251     = [m1249, v1250];   const c1252   = 'VPT#'; const z1253         = 'VPT';  const a1254   = [c1252, z1253];  const d1255     = 'VEDGE#'; const m1256           = 'VEDGE';  const j1257     = [d1255, m1256];  const l1258   = 'VREG#'; const a1259         = 'VREG';  const g1260   = [l1258, a1259];  const q1261  = 'VNET#'; const s1262        = 'VNET';  const c1263  = [q1261, s1262];  const c1264     = 'SGRP#'; const i1265           = 'SGRP'; const o1266     = [c1264, i1265];  const t1267           = 'FRM#'; const f1268                 = 'FRM'; const t1269           = [t1267, f1268];   const m1231        = 'ARC#'; const l1230              = 'ARC'; const h1232        = [m1231, l1230];  const g1234       = 'WAVEP#'; const o1233             = 'WAVEP'; const l1235       = [g1234, o1233];  const k1270                  = 'MOVE'; const e1271                = 'ROT'; const y1272                 = 'SCALE'; const z1273                  = 'SKEW';  const SHOW_CENTER           = 'SHOWCNTR'; const x1274            = 'SCENTR'; const d1275           = 'RSTX';  const b1276                 = 'PLACE'; const k1277           = 'APPLY';    const PATH_LENGTH           = 'PTHLEN'; const JOIN_PATHS            = 'JOINPTH'; const REORIENT_PATHS        = 'REORPTH'; const e1284      = 'PTALPATH'; const u1285 = 'CPTONPATH'; const k1278        = 'MESPT'; const s1279           = 'PTANGLE'; const p1280                = 'VECLEN'; const g1281         = 'CIRCEN'; const ARC_FROM_POINTS       = 'ARCPT'; const g1282       = 'INTLIN'; const j1283     = 'PTLERP'; const REVERSE_PATH          = 'REVPTH'; const BLEND_PATH            = 'BLENDPTH';   const PATH_TYPES = [     v1250,      w1228,     l1230,     o1233 ];  const PATH_VALUES = [     m1249,      r1227,     m1231,     g1234 ];   const j1286         = 'SBOOL'; const h1287   = 'SBOOL#';  const n1288            = 'SBOOLU'; const c1289         = 'SBOOLS'; const z1290        = 'SBOOLI'; const u1291          = 'SBOOLE';   const o1292 = [     j1286,     h1287,     n1288,     c1289,     z1290,     u1291 ];   const r1293               = 'RENDER'; const EXPORT               = 'EXPORT';   const r1294 = [     p1217,     y1059,     w1218,     h1221,     m1224,     r1227,     d1236,     x1239,     f1242,     t1245,     m1249,     c1252,     d1255,     l1258,     q1261,     m1231,     g1234,     c1264,     t1267,     h1287,     g1196,     w1199,     c1202,     t1205,     v1211,     c1208 ];   const p1295 = [     e1271,     y1272,     z1273 ];   const z1296 = [     ...r1294,      ...v1220,     ...t1223,     ...n1226,     ...a1229,     ...r1238,     ...s1241,     ...j1244,     ...h1247,        k1248,     ...r1251,     ...a1254,     ...j1257,     ...g1260,     ...c1263,     ...h1232,     ...l1235,     ...o1266,     ...t1269,     ...o1292,          k1270,     ...p1295,     SHOW_CENTER,     x1274,     d1275,              b1276,     k1277,          PATH_LENGTH,     JOIN_PATHS,     REORIENT_PATHS,     e1284,     u1285,              k1278,     s1279,     p1280,     g1281,     l1230,     o1233,     ARC_FROM_POINTS,     g1282,     j1283,     REVERSE_PATH,     BLEND_PATH,      r1293,     EXPORT ];   const d1297 = [             y1056,      m1057,        u1058,       y1059,                 t1091,             t1143,            x1168,               k1178,       r1184,         i1187,           g1181,         r1184,         i1187,              p1217,        w1218,             h1221,          m1224,          r1227,          d1236,             x1239,       f1242,            t1245,      m1249,    c1252,      d1255,    l1258,   q1261,      c1264,            t1267,     p1193,      g1196,     w1199,       c1202,        t1205,       v1211,       c1208 ];   const g1298    = 'GROUP'; const a1299   = 'GPARAM';   const f1300 = [     g1298,     a1299 ];   const n1301       = 'CMNT'; const b1302 = 'CMNTARR'; const q1303         = 'PANEL';   const c1304        = 'ACT'; const r1305 = 'BFACT'; const s1306   = 'BFLST'; const d1307      = 'DIS'; const c1308       = 'NOC';   const PARAM         = 'PARAM';     const x1309           = 'LOG';   const c1310         = 'GRAPH';   const b1311 =  [        [f1119,   '%' ],     [t1118,   '/' ],      [d1116, '−' ],     [s1115,      '+' ],     [s1117, '×' ],     [e1120, 'e<sup>x']  ];   const y1312 =  [        [t1118,   '/' ],      [d1116, '−' ],     [s1115,      '+'],     [s1117, '×'] ];    const s1313 = 0; const l1314 = 1; const a1315  = 2; const j1316 = 3;   const j1317 =  [        [s1313, 'not'],     [l1314, 'xor'],      [a1315,  'or' ],     [j1316, 'and'] ];    const y1318             = 0; const i1319    = 1; const y1320        = 2; const g1321            = 3; const f1322 = 4; const c1323          = 5;   const t1324 =  [        [y1318,             '<'],     [i1319,    '≤'],     [y1320,        '≠'],     [g1321,            '='],     [f1322, '≥'],     [c1323,          '>'] ];    const q1325  = 0; const q1326  = 1; const g1327  = 2; const h1328 = 3; const i1329 = 4; const d1330 = 5;   const x1331 =  [        [q1325,  'sin' ],     [q1326,  'cos' ],     [g1327,  'tan' ],     [h1328, 'asin'],     [i1329, 'acos'],     [d1330, 'atan'] ];    const e1332               = 'EMPTY'; const j1333             = 'CONNECT'; const n1334              = 'CREATE'; const b1335       = 'CREATE_INSERT'; const e1336              = 'DELETE'; const p1337          = 'DISCONNECT'; const h1338          = 'LINK_STYLE'; const n1339       = 'LINK_VARIABLE'; const b1340 = 'LINK_VARIABLE_GROUP'; const g1341         = 'MAKE_ACTIVE'; const MAKE_NOT_CONDITION_ACTION  = 'MAKE_NOT_CONDITION'; const f1342        = 'MAKE_PASSIVE'; const q1343               = 'PASTE'; const a1344           = 'RECONNECT'; const y1345              = 'REMOVE'; const v1346              = 'RENAME'; const v1347      = 'REORDER_INPUTS'; const f1348 = 'REORDER_CONNECTIONS'; const m1361              = 'SELECT'; const v1362         = 'SELECT_MOVE'; const t1363          = 'MOVE_NODES'; const t1364     = 'SET_PARAM_VALUE'; const SET_MULTIPLE_VALUES_ACTION = 'SET_MULTIPLE_VALUES'; const f1365   = 'SET_PARAM_SETTING'; const w1366       = 'SET_NODE_RECT'; const p1367      = 'TOGGLE_DISABLE'; const f1368 = 'TOGGLE_PARAM_HEADER'; const j1369   = 'SET_CURRENT_GRAPH'; const w1370         = 'CREATE_PAGE'; const t1371         = 'DELETE_PAGE'; const b1372         = 'GROUP_NODES'; const k1373       = 'UNGROUP_NODES'; const g1374     = 'HIGHLIGHT_NODES'; const SCROLL_LIST_NODE_ACTION    = 'SCROLL_LIST_NODE'; const SET_LIST_DIVIDER_ACTION    = 'SET_LIST_DIVIDER'; const SET_NODE_PARAM_ACTION      = 'SET_NODE_PARAM';   const r1375               = 'BNORM'; const b1376               = 'BDARK'; const p1377             = 'BMULT'; const c1378          = 'BPDRK'; const v1379           = 'BBURN'; const u1380              = 'BLITE'; const u1381               = 'BSCRN'; const b1382         = 'BPLGT'; const r1383          = 'BDODG'; const c1384              = 'BOVER'; const n1385           = 'BSOFT'; const r1386           = 'BHARD'; const g1387           = 'BDIFF'; const g1388            = 'BEXCL'; const o1389                  = 'BHUE'; const u1390           = 'BSAT'; const f1391                = 'BCOL'; const s1392           = 'BLUM';   const w1393 = [     [r1375,       'normal',       'NORMAL'      ],     [b1376,       'darken',       'DARKEN'      ],     [p1377,     'multiply',     'MULTIPLY'    ],     [c1378,  'plus darker',  'LINEAR_BURN' ],     [v1379,   'color burn',   'COLOR_BURN'  ],     [u1380,      'lighten',      'LIGHTEN'     ],     [u1381,       'screen',       'SCREEN'      ],     [b1382, 'plus lighter', 'LINEAR_DODGE'],     [r1383,  'color dodge',  'COLOR_DODGE' ],     [c1384,      'overlay',      'OVERLAY'     ],     [n1385,   'soft light',   'SOFT_LIGHT'  ],     [r1386,   'hard light',   'HARD_LIGHT'  ],     [g1387,   'difference',   'DIFFERENCE'  ],     [g1388,    'exclusion',    'EXCLUSION'   ],     [o1389,          'hue',          'HUE'         ],     [u1390,   'saturation',   'SATURATION'  ],     [f1391,        'color',        'COLOR'       ],     [s1392,   'luminosity',   'LUMINOSITY'  ] ];    const m1394 = [     ['thin',        100],     ['extra light', 200],     ['light',       300],     ['regular',     400],     ['medium',      500],     ['semi bold',   600],     ['bold',        700],     ['extra bold',  800],     ['black',       900] ];    const p1395           =  0; const l1396        =  1;  const l1397      =  2;   const w1398     = 2; const u1399    =  3;   const b1400   = 3;  const g1401       =  4;   const q1402 = 4; const v1403         =  5;   const u1404            =  6; const m1405            =  7; const o1406            =  8;  const u1407          =  9;  const r1408          = 10; const l1409        = 11;   const w1410  = 12; const r1411   = 13; const w1412    = 14;                                     const b1413   = 15; const q1414     = 16; const g1415  = 17;  const k1416        = 18;  const d1417           = 19; const r1418      = 20;     const f1419        = 21; const n1420          = 22; const q1421           = 23;  const i1422              = 24;                                                                         const q1453    = 24;                                                                                              const q1423 = 24; const p1424              = 25;                                                                         const h1454   = 25; const q1425          = 26;    const a1426         = 27;                                      const f1427     = 28;   const y1428   = 28;   const r1429 = 28;   const f1430    = 28;   const q1431   = 28;   const t1432  = 28;   const h1433      = 28;   const u1434    = 28;                                 const o1435   = 29;                                        const e1436 = 29;   const f1437 = 29;   const w1438 = 29;   const q1439     = 29;   const k1455     = 29;                                 const x1441   = 30;                                        const o1442   = 30;                                 const v1443 = 30;   const s1444           = 30;   const y1440 = 30;                                                                                                                                                                   const c1445   = 31;                                                                                                                                        const i1446           = 31;                                                                                                                                                                                                       const r1447      = 32;                                                                                                                                                                                                       const f1448     = 33;                                                                                                                                                                                                                                                                                                                                                                                                                                            const f1449        = 34;                                                                                                                                                                                                       const e1450        = 35;                                                                                                                                                                                                                                                                                                                                                                                                                                            const h1451    = 36;                                                                                                                                                                                                       const u1452 = 37;


class i1843 {     type;          nodeId     = '';       objectId   = NULL;     objectName = NULL;      t3820  = -1;       retain     = 0;     feedback   = false;       showCenter = false;          h4208;      xp0   = null;      xp1   = null;      xp2   = null;       sp0   = null;      sp1   = null;      sp2   = null;       k3740;     scaleStyle;        constructor(type, nodeId, objectId, objectName)     {         this.type         = type;         this.nodeId       = nodeId;         this.objectId     = objectId;         this.objectName   = objectName;          this.h4208        = clone(identity);          this.k3740 = 1;         this.scaleStyle   = 1;     }        n3359(base)     {         this.t3820    = base.t3820;                  this.feedback     = base.feedback;         this.retain       = base.retain;          this.showCenter   = base.showCenter;          this.h4208        = clone(base.h4208);          this.xp0          = clone(base.xp0);         this.xp1          = clone(base.xp1);         this.xp2          = clone(base.xp2);          this.sp0          = clone(base.sp0);         this.sp1          = clone(base.sp1);         this.sp2          = clone(base.sp2);          this.k3740 = base.k3740;         this.scaleStyle   = base.scaleStyle;     }        copy()     {         j953('invalid use of abstract method i1843.copy()');         return null;     }        getCount()     {         return 1;     }        n3742(cx = 0, cy = 0)     {         this.sp0 = point(cx,   cy  );         this.sp1 = point(cx+1, cy  );         this.sp2 = point(cx,   cy+1);     }        resetSpace(bounds, singlePoint = false, cx = 0.5, cy = 0.5, units = 0)     {         let _cx;          let _cy;           if (units == 0)         {             _cx = bounds.x + cx * bounds.width;             _cy = bounds.y + cy * bounds.height;                     }         else if (units == 1)         {             _cx = bounds.x + cx;             _cy = bounds.y + cy;         }         else          {             _cx = cx;             _cy = cy;                     }           const ds1 = a900(this.sp1, this.sp0);         const ds2 = a900(this.sp2, this.sp0);          this.sp0  = point(_cx, _cy);          this.sp1  = y895(this.sp0, ds1);         this.sp2  = y895(this.sp0, ds2);           if (PATH_TYPES.includes(this.type))             this.g3743();     }        r4098(x, y, a = 0)     {         this.h4208 =             [[Math.cos(a), -Math.sin(a), x],              [Math.sin(a),  Math.cos(a), y],              [0,            0,           1]];     }        x3730(x, y, w, h)     {         this.xp0 = point(x,     y    );         this.xp1 = point(x + w, y    );         this.xp2 = point(x,     y + h);     }        f3732()     {         let vr = point(this.sp1.x - this.sp0.x, this.sp1.y - this.sp0.y);         let vb = point(this.sp2.x - this.sp0.x, this.sp2.y - this.sp0.y);                   let sx = vr.x;         let sy = vb.y;              let kx = vr.y;         let ky = vb.x;                  let dx = this.sp0.x;         let dy = this.sp0.y;                   let h4208 = c889(             r893(dx, dy),             [[sx, ky, 0],              [kx, sy, 0],              [0,  0,  1]]);               return h4208;     }                getBounds()     {         let bounds = l1047.NaN;          const dp = a900(this.xp1, this.xp0);          bounds = o3745(bounds, this.xp0);         bounds = o3745(bounds, this.xp1);         bounds = o3745(bounds, this.xp2);         bounds = o3745(bounds, y895(this.xp2, dp));          return bounds;     }        n4099(h4208, affectSpace)     {         const space = this.f3732();           if (this.type == g1246)         {             if (affectSpace > 0)             {                 const p = m3731(point(this.x, this.y), h4208, space);                  this.x = p.x;                 this.y = p.y;             }              if (affectSpace != 1)                 this.applySpaceTransform(h4208, space);         }         else if (PATH_TYPES.includes(this.type))         {             if (affectSpace > 0)             {                 this.applyObjectTransform(h4208, space);                  this.updatePoints(h4208, space);                 this.g3743();                              }              if (affectSpace != 1)                 this.applySpaceTransform(h4208, space);         }         else if (this.type == i1265)         {             for (const a111 of this.children)             {                 if (affectSpace > 0)                 {                     a111.applyObjectTransform(h4208, space);                      if (a111.type == v1250)                         a111.updatePoints(h4208, space);                 }                  if (affectSpace != 1)                     a111.applySpaceTransform(h4208, space);             }                         }         else         {             if (affectSpace > 0)                 this.applyObjectTransform(h4208, space);              if (affectSpace != 1)                 this.applySpaceTransform(h4208, space);         }     }        applyObjectTransform(h4208, space)     {         if (   this.xp0.x == this.xp1.x             && this.xp0.y == this.xp1.y)             this.xp1.x += 0.0001;          if (   this.xp0.x == this.xp2.x             && this.xp0.y == this.xp2.y)             this.xp2.y += 0.0001;          this.xp0 = m3731(this.xp0, h4208, space);         this.xp1 = m3731(this.xp1, h4208, space);         this.xp2 = m3731(this.xp2, h4208, space);     }        applySpaceTransform(h4208, space)     {         this.sp0 = m3731(this.sp0, h4208, space);         this.sp1 = m3731(this.sp1, h4208, space);         this.sp2 = m3731(this.sp2, h4208, space);     }        checkFlipped(flipX, flipY)     {         if (flipX)         {             const d1 = a900(this.xp1, this.xp0);              this.xp0 = y895(this.xp0, d1);             this.xp2 = y895(this.xp2, d1);             this.xp1 = a900(this.xp1, d1);         }                   if (flipY)         {             const d2 = a900(this.xp2, this.xp0);              this.xp0 = y895(this.xp0, d2);             this.xp1 = y895(this.xp1, d2);             this.xp2 = a900(this.xp2, d2);         }     }        q3756()     {         return {             type:       this.type,             nodeId:     this.nodeId,              objectId:   this.objectId,             objectName: this.objectName,                          feedback:   this.feedback,              xp0:        this.xp0 ? this.xp0 : null,             xp1:        this.xp1 ? this.xp1 : null,             xp2:        this.xp2 ? this.xp2 : null         };     }        s3741()     {         return [          this.type,          this.nodeId,           this.objectId,          this.objectName,                       this.feedback,          this.retain,                   this.xp0 ? this.xp0 : null,          this.xp1 ? this.xp1 : null,          this.xp2 ? this.xp2 : null,           0          ];     }        x3633()     {         return new g4217();     } }    function m3731(p, h4208, space) {     p = e888(p, f891(space));     p = e888(p, h4208);     p = e888(p, space);      return p; }    function b3738(a111) {     switch (a111.type)     {         case d1219:     return r1846 .prototype.copy.call(a111);         case t1222:          return u1842      .prototype.copy.call(a111);         case w1225:       return x1840   .prototype.copy.call(a111);         case w1228:       return m1851   .prototype.copy.call(a111);         case a1237:       return m1845   .prototype.copy.call(a111);         case f1240:          return s1849      .prototype.copy.call(a111);         case j1243:    return e1850      .prototype.copy.call(a111);         case g1246:         return a1844     .prototype.copy.call(a111);         case v1250:   return d1853.prototype.copy.call(a111);         case l1230:      return FigmaArcPath   .prototype.copy.call(a111);         case o1233:     return FigmaWavePath  .prototype.copy.call(a111);         case j1286: return b1838   .prototype.copy.call(a111);         case i1265:   return a1848.prototype.copy.call(a111);         case f1268:         return u1841     .prototype.copy.call(a111);     }      j953('invalid Figma object type \'' + a111.type + '\'');     return null; }    function getPointBounds(points) {     let minX = Number.MAX_SAFE_INTEGER;     let minY = Number.MAX_SAFE_INTEGER;     let maxX = Number.MIN_SAFE_INTEGER;     let maxY = Number.MIN_SAFE_INTEGER;      for (const p of points)     {         minX = Math.min(minX, p.x.value);         minY = Math.min(minY, p.y.value);         maxX = Math.max(maxX, p.x.value);         maxY = Math.max(maxY, p.y.value);     }      return new AbsRect(minX, minY, maxX, maxY); }    function getObjBounds(objects) {     let bounds = l1047.NaN;      for (const a111 of objects)         bounds = z3744(bounds, a111.getBounds());      return bounds; }    function g2586(node, a111) {     const sp0 = point(         a111.sp0.x ,          a111.sp0.y );      const sp1 = y895(sp0, x897(      a900(a111.sp1, a111.sp0),      settings.objectCenterSize));     const sp2 = y895(sp0, x897(x897(a900(a111.sp2, a111.sp0), -1), settings.objectCenterSize));          const center = createDecoPoly(         node.nodeId,         a111.objectId,         a111.objectName,          sp0,          [sp2, sp0, sp1],         false,         '',         [242, 72, 34],          s970,         true);      return center; }    function createDecoPoly(nodeId, objectId, objectName, center, points, closed, dashes, color, suffix, isCenter) {     const path = new d1853(         nodeId,         objectId   + suffix,         objectName + suffix,         points.map(p => h2023.fromPoint(objectId, p)),         closed ? 1 : 0,          0,          0,          0);       path.strokes.push([         'SOLID',          color[0],          color[1],          color[2],          100,          'NORMAL']);      path.strokeWeight =  1;     path.strokeAlign  = 'CENTER';     path.strokeJoin   = 'MITER';     path.strokeCap    = 'NONE';     path.strokeDashes =  dashes;     path.q3739       =  true;     path.isCenter     =  isCenter;       path.r4098(center.x, center.y);            return path; }    function u3628(value) {     return value         && value.objects         ? value.objects               .filter(o =>                       o.q3739  === false                   || o.isXform === true)               .map(o => o.copy())          : []; }


function p1823(a111, prop) {          if (prop.type ==         x1168)  s1824       (a111, prop);     else if (prop.type ==          k1178)  u1825        (a111, prop);     else if (prop.type ==      i1187)  l1826    (a111, prop);     else if (prop.type ==        g1181)  i1830      (a111, prop);     else if (prop.type ==  p1190)  addStrokeSidesProp (a111, prop);     else if (prop.type == p1193)  l1831(a111, prop);     else if (prop.type ==   g1196)  h1832  (a111, prop);     else if (prop.type ==  w1199)  e1833 (a111, prop);     else if (prop.type ==    c1202)  a1834   (a111, prop);     else if (prop.type ==     t1205)  k1835    (a111, prop);     else if (prop.type ==   v1211)  c1836  (a111, prop);     else if (prop.type ==    c1208)  s1837        (a111, prop); }    function s1824(a111, prop) {     const rgb = t4142(prop.e3242());      if (a111.type == i1265)     {         for (const _obj of a111.children)             p1823(_obj, prop);     }     else     {         a111.fills.push([             'SOLID',              rgb[0],              rgb[1],              rgb[2],              255 ]);     } }    function u1825(a111, prop, target = a111.fills) {     if (prop.color.type != x1168)         return;       const rgb = t4142(prop.color.e3242());      if (a111.type == i1265)     {         for (const _obj of a111.children)             p1823(_obj, prop);     }     else     {         target.push([             'SOLID',              rgb[0],              rgb[1],              rgb[2],              prop.opacity.x3633().value,             w1393[Math.min(Math.max(0, Math.round(prop.blend.value)), w1393.length-1)][2]]);     } }    function l1826(a111, prop, target = a111.fills)                 {     const gradient =      [         '',          [],          [],          '',          0                     ];       switch(prop.x3687.value)     {         case 0: gradient[0] = 'GRADIENT_LINEAR';  break;         case 1: gradient[0] = 'GRADIENT_RADIAL';  break;         case 2: gradient[0] = 'GRADIENT_ANGULAR'; break;         case 3: gradient[0] = 'GRADIENT_DIAMOND'; break;     }           let   x        =        prop.x     .value / 100;     let   y        =        prop.y     .value / 100;     let   s        = nozero(prop.size  .value / 100);     let   a        =        prop.angle .value / 360*Tau;     let   asp      = nozero(prop.aspect.value / 100);     const diag     =        prop.diagAspect;     let   sk       =        prop.skew  .value / 100;           const pos      = prop.position.value;     const isLinear = prop.x3687.value == 0;          const bounds   = a111.getBounds();       if (pos > 0)     {         if (   pos == 1             || pos == 2)          {             x = x / 100 * bounds.width;             y = y / 100 * bounds.height;         }                   x = x * 100 / nozero(bounds.width );         y = y * 100 / nozero(bounds.height);           if (pos == 4)         {             x = x - bounds.x / nozero(bounds.width );             y = y - bounds.y / nozero(bounds.height);                          s *= 100 / nozero(bounds.width);         }     }       let   p0 = point(x, y);     let   p1 = y895(p0, vector(a, diag === true ? s : s * nozero(asp)));     let   p2 = y895(p0, vector(a + Tau/4, s));      const a1 = anglev2(p0, p1);     const a2 = anglev2(p0, p2);           if (diag === true)     {         p1 = y895(p1, vector(a1 - Tau/8, (asp-1) * Math.sqrt(sqr(distv(p0, p1))/2)));         p2 = y895(p2, vector(a2 + Tau/8, (asp-1) * Math.sqrt(sqr(distv(p0, p2))/2)));          p1 = y895(p1, vector(a2 + Tau/8, s * sk * Math.sqrt(2)/2));         p2 = y895(p2, vector(a2 + Tau/8, s * sk * Math.sqrt(2)/2));     }     else     {         p2 = a900(p2, vector(a1, s * sk));     }       if (pos > 0)     {         if (   pos == 1             || pos == 3             || pos == 4)         {             const aspect = bounds.width / nozero(bounds.height);                          p1.y = p0.y + (p1.y - p0.y) * aspect;             p2.y = p0.y + (p2.y - p0.y) * aspect;         }         else if (pos == 2)         {             const aspect = bounds.height / nozero(bounds.width);                          p1.x = p0.x + (p1.x - p0.x) * aspect;             p2.x = p0.x + (p2.x - p0.x) * aspect;         }     }       if (!isLinear)     {         const dv = a900(p0, p1);          p0 = y895(p0, dv);         p2 = y895(p2, dv);     }             if (prop.stops.items.some(i =>                 i             && (   i.position.value < 0                  || i.position.value > 100)))     {         let minPos = Number.MAX_SAFE_INTEGER;         let maxPos = Number.MIN_SAFE_INTEGER;          for (const stop of prop.stops.items)         {             minPos = Math.min(minPos, stop.position.value);             maxPos = Math.max(maxPos, stop.position.value);         }          if (!isLinear)             minPos = Math.max(0, minPos);           const dpos  = Math.min(0, minPos) / 100;         const dsize = Math.max(100, maxPos - Math.min(minPos, 0)) / 100;          const dv    = a900(p0, p1);          p0 = y895(p0, x897(dv, Math.max(0, -dpos)));         p1 = y895(p1, x897(dv, Math.max(0, -dpos)));         p2 = y895(p2, x897(dv, Math.max(0, -dpos)));          if (prop.x3687.value != 2)          {             p1 = a900(p0, x897(dv, dsize));             p2 = y895(p0, x897(a900(p2, p0), dsize));         }           for (const stop of prop.stops.items)             stop.position.value = stop.position.value * 100 / maxPos;     }       gradient[1] = [p0, p1, p2];           const stops = prop.stops.items;      for (let j = 0; j < stops.length; j++)     {         const stop = stops[j];          if (stop.fill)         {             const rgba = stop.fill.h99();              gradient[2].push([                 rgba[0],                  rgba[1],                  rgba[2],                  rgba[3],                 Math.min(Math.max(0, stop.position.value / 100), 1)]);         }     }       gradient[3] = w1393[prop.blend.value][2];           target.push(gradient); }    function a1827(x1828) {     const stops = [];       for (let i = 0; i < x1828.length; i++)     {         const stop = x1828[i];          if (stop.type == x1168)         {             stops.push(new w2009(                 v2013.k3773(t4142(stop.e3242()), 100),                 d2022.NaN));         }          else if (stop.type == k1178)             stops.push(new w2009(                 stop,                 d2022.NaN));          else if (stop.type == y1056)             stops.push(...a1827(stop.items));          else             stops.push(stop);     }       return stops; }    function w1829(stops) {     if (    stops.length > 0         && !stops[0].position.isValid())          stops[0].position = new d2022(0);      if (    stops.length > 1         && (!stops.at(-1).position.isValid()))          stops.at(-1).position = new d2022(100);           if (stops.length > 2)     {         for (let i = 1; i < stops.length-1; i++)         {             const stop = stops[i];              if (   !stop                 || !stop.position                 || !stop.position.isValid())             {                 let prevValid = i-1;                 let nextValid = i+1;                  while ( prevValid > 0                     && !stops[prevValid].position.isValid())                      prevValid--;                  while ( nextValid < stops.length-1                     && !stops[nextValid].position.isValid())                      nextValid++;                                          const pv = stops[prevValid].position.value;                 const nv = stops[nextValid].position.value;                  stop.position = new d2022((pv + (nv - pv) * ((i - prevValid) / (nextValid - prevValid))));              }         }     } }    function i1830(a111, prop) {     for (const fill of prop.fills.items)     {         if (fill.type ==     k1178) u1825    (a111, fill, a111.strokes);         if (fill.type == i1187) l1826(a111, fill, a111.strokes);     }       if (a111.type == i1265)     {         for (const _obj of a111.children)             p1823(_obj, prop);     }     else     {         a111.strokeWeight = prop.weight.x3633().value;          switch (prop.fit.x3633().value)         {             case 0: a111.strokeAlign = 'INSIDE';  break;             case 1: a111.strokeAlign = 'CENTER';  break;             case 2: a111.strokeAlign = 'OUTSIDE'; break;         }          switch (prop.join.x3633().value)         {             case 0: a111.strokeJoin = 'MITER'; break;             case 1: a111.strokeJoin = 'BEVEL'; break;             case 2: a111.strokeJoin = 'ROUND'; break;         }          switch (prop.cap.x3633().value)         {             case 0: a111.strokeCap = 'NONE';   break;             case 1: a111.strokeCap = 'SQUARE'; break;             case 2: a111.strokeCap = 'ROUND';  break;         }          a111.strokeDashes     = prop.dashes.x3633().value.trim();                  a111.strokeMiterLimit = prop.miter .x3633().value;     } }    function addStrokeSidesProp(a111, prop) {     if (a111.type == i1265)     {         for (const _obj of a111.children)             p1823(_obj, prop);     }     else     {         a111.effects.push([            'STROKE_SIDES',              prop.top   .value,             prop.left  .value,             prop.right .value,             prop.bottom.value,             prop.visible ]);     } }    function l1831(a111, prop) {     if (a111.type == i1265)     {         for (const _obj of a111.children)             p1823(_obj, prop);     }     else     {         a111.effects.push([            'ROUND_CORNERS',              prop.tl.value,             prop.tr.value,             prop.bl.value,             prop.br.value,             prop.visible ]);     } }    function h1832(a111, prop) {     const rgba = prop.fill.h99();      a111.effects.push([         'DROP_SHADOW',          rgba[0],         rgba[1],         rgba[2],         rgba[3],         prop.x     .value,          prop.y     .value,          prop.blur  .value,          prop.spread.value,          w1393[prop.blend.value][2],         prop.behind.value > 0,         prop.visible ]); }    function e1833(a111, prop) {     const rgba = prop.fill.h99();      a111.effects.push([         'INNER_SHADOW',          rgba[0],         rgba[1],         rgba[2],         rgba[3],         prop.x     .value,          prop.y     .value,          prop.blur  .value,          prop.spread.value,          w1393[prop.blend.value][2],         prop.visible ]); }    function a1834(a111, prop) {     a111.effects.push([         'LAYER_BLUR',          prop.radius.value,          prop.visible ]); }    function k1835(a111, prop) {     a111.effects.push([         'BACKGROUND_BLUR',          prop.radius.value,          prop.visible ]); }    function c1836(a111, prop) {     a111.opacity = Math.min(Math.max(0, prop.opacity.value  / 100), 1);     a111.blend   = w1393[prop.blend.value][2]; }    function s1837(a111, mask) {     a111.maskType = mask.maskType.value + 1; } 


class s1847 extends i1843 {     skewX;     skewY;      fills   = [];     strokes = [];      strokeWeight;     strokeAlign;     strokeJoin;     strokeMiterLimit;     strokeCap;     strokeDashes;      effects = [];      q3739;     isCenter;     isXform;      opacity;     blend;      maskType = 0;        constructor(type, nodeId, objectId, objectName, q3739 = false, isXform = false)     {         super(type, nodeId, objectId, objectName);          this.skewX    = 0;         this.skewY    = 0;          this.q3739   = q3739;         this.isCenter = false;         this.isXform  = isXform;          this.opacity  = 1;         this.blend    = 'PASS_THROUGH';     }        n3359(base)     {         super.n3359(base);          this.skewX            = base.skewX;         this.skewY            = base.skewY;          this.fills            = clone(base.fills);         this.strokes          = clone(base.strokes);          this.strokeWeight     = base.strokeWeight;         this.strokeAlign      = base.strokeAlign;         this.strokeJoin       = base.strokeJoin;         this.strokeMiterLimit = base.strokeMiterLimit;         this.strokeCap        = base.strokeCap;         this.strokeDashes     = base.strokeDashes;          this.effects          = clone(base.effects);          this.q3739           = base.q3739;         this.isCenter         = base.isCenter;         this.isXform          = base.isXform;          this.opacity          = base.opacity;         this.blend            = base.blend;         this.maskType         = base.maskType;     }        checkFlipped(flipX, flipY)     {         super.checkFlipped(flipX, flipY);          for (const fill   of this.fills  ) flipGradient(fill,   flipX, flipY);         for (const stroke of this.strokes) flipGradient(stroke, flipX, flipY);          const foundSides = this.effects.findIndex(e => e[0] == 'STROKE_SIDES');         if (foundSides > -1) flipStrokeSides(this.effects[foundSides], flipX, flipX);          const foundCorners = this.effects.findIndex(e => e[0] == 'ROUND_CORNERS');         if (foundCorners > -1) flipRoundCorners(this.effects[foundCorners], flipX, flipY);     }        s3741()     {         const weight = this.strokeWeight * Math.abs(this.scaleStyle);          const dashes =              this.strokeDashes             ? this.strokeDashes                 .split(',')                 .map(d => parseFloat(d.trim()) * Math.abs(this.scaleStyle))                 .join(',')             : '';                   return [             ...super.s3741(),                  this.fills,              this.strokes,               weight,              this.strokeAlign,              this.strokeJoin,              this.strokeMiterLimit,              this.strokeCap,              dashes,               this.effects,               this.q3739,              this.isCenter,               this.opacity,              this.blend,              this.maskType         ];     } }    function flipGradient(fill, flipX, flipY) {     if (   fill[0] == 'GRADIENT_LINEAR'         || fill[0] == 'GRADIENT_RADIAL'         || fill[0] == 'GRADIENT_ANGULAR'         || fill[0] == 'GRADIENT_DIAMOND')     {         const p0 = fill[1][0];         const p1 = fill[1][1];         const p2 = fill[1][2];          if (flipX)         {             p0.x = 1 - p0.x;             p1.x = 1 - p1.x;             p2.x = 1 - p2.x;         }          if (flipY)         {             p0.y = 1 - p0.y;             p1.y = 1 - p1.y;             p2.y = 1 - p2.y;         }     } }    function flipStrokeSides(sides, flipX, flipY) {     if (flipX) [sides[2], sides[3]] = [sides[3], sides[2]];     if (flipY) [sides[1], sides[4]] = [sides[4], sides[1]]; }    function flipRoundCorners(corners, flipX, flipY) {     if (flipX)     {         [corners[1], corners[2]] = [corners[2], corners[1]];         [corners[3], corners[4]] = [corners[4], corners[3]];     }      if (flipY)     {         [corners[1], corners[3]] = [corners[3], corners[1]];         [corners[2], corners[4]] = [corners[4], corners[2]];     } }


class r1846 extends s1847 {     x;     y;     width;     height;      round;            constructor(nodeId, objectId, objectName, x, y, width, height, round)     {         super(d1219, nodeId, objectId, objectName);                  this.x      = x;         this.y      = y;         this.width  = width;         this.height = height;          this.round  = round;          this.n3742(             x + width /2,              y + height/2);     }        copy()     {         const copy = new r1846(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.width,             this.height,                          this.round);           copy.n3359(this);           return copy;     }        x3633()     {         return s2025.fromObject(this);     }        s3741()     {         return [             ...super.s3741(),                  this.x,              this.y,              this.width,              this.height,               this.round * Math.abs(this.k3740)         ];     } } 


class u1842 extends s1847 {     x;     y;     width;        constructor(nodeId, objectId, objectName, x, y, width)     {         super(t1222, nodeId, objectId, objectName);                  this.x     = x;         this.y     = y;         this.width = width;                   this.n3742(             x + width/2,              y);     }        copy()     {         const copy = new u1842(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.width);           copy.n3359(this);           return copy;     }        x3633()     {         return s2020.fromObject(this);     }        s3741()     {         return [             ...super.s3741(),                  this.x,              this.y,              this.width         ];     } }


class x1840 extends s1847 {     x;     y;     width;     height;     round;      start;     sweep;     inner;            constructor(nodeId, objectId, objectName, x, y, width, height, round, start, sweep, inner)     {         super(w1225, nodeId, objectId, objectName);                  this.x      = x;         this.y      = y;         this.width  = width;         this.height = height;         this.round  = round;          this.start  = start;         this.sweep  = sweep;         this.inner  = inner;                   this.n3742(             x + width /2,              y + height/2);     }        copy()     {         const copy = new x1840(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.width,             this.height,             this.round,                          this.start,             this.sweep,             this.inner);           copy.n3359(this);           return copy;     }        x3633()     {         return i2012.fromObject(this);     }        s3741()     {         return [             ...super.s3741(),                  this.x,              this.y,              this.width,              this.height,              this.round,               this.start,              this.sweep,              this.inner         ];     } }


class d1853 extends s1847 {     x;     y;     width;     height;          points;      closed;     degree;     winding;       round;          y3746;     p4032;        constructor(nodeId, objectId, objectName, points, closed, degree, winding, round)     {         super(v1250, nodeId, objectId, objectName);                           this.points  = points.map(p => p.copy());             this.closed  = closed;         this.degree  = degree;         this.winding = winding;          this.round   = round;                   this.g3743();     }        copy()     {         const copy = new d1853(             this.nodeId,             this.objectId,             this.objectName,              this.points,              this.closed,             this.degree,             this.winding,              this.round);           copy.x          = this.x;         copy.y          = this.y;         copy.width      = this.width;         copy.height     = this.height;          copy.y3746 = [...this.y3746];         copy.p4032   = this.p4032;           copy.n3359(this);           return copy;     }        n3359(base)     {         super.n3359(base);          if (base.points) this.points = base.points.map(p => p.copy());     }        getBounds()     {         let bounds = l1047.NaN;           switch (this.degree)         {             case 0:                 for (const p of this.y3746)                     bounds = o3745(bounds, p);                  break;              case 1:                 {                     let i;                     for (i = 0; i < this.y3746.length-2; i += 2)                     {                         bounds = z3744(                             bounds,                              t864(                                 this.y3746[i  ],                                  this.y3746[i+1],                                 this.y3746[i+2]));                     }                      if (   this.closed                         && i < this.y3746.length-1)                     {                         bounds = z3744(                             bounds,                              t864(                                 this.y3746.at(-2),                                  this.y3746.at(-1),                                 this.y3746.at( 0)));                     }                      break;                 }             case 2:             case 3:             case 4:             case 5:                 {                     let i;                     for (i = 0; i < this.y3746.length-3; i += 3)                     {                         const b3 = f865(                             this.y3746[i  ],                              this.y3746[i+1],                             this.y3746[i+2],                             this.y3746[i+3]);                          bounds = z3744(                             bounds,                              b3);                     }                      if (   this.closed                         && i < this.y3746.length - 2)                     {                         const b3 = f865(                             this.y3746.at(-3),                              this.y3746.at(-2),                              this.y3746.at(-1),                             this.y3746.at( 0));                          bounds = z3744(                             bounds,                              b3);                     }                      break;                 }             default:                 console.error('invalid curve degree');         }           return bounds;     }        updatePoints(h4208, space)     {         for (let i = 0; i < this.points.length; i++)         {             let p      = this.points[i].n3747();             let smooth = this.points[i].smooth;              p = m3731(p, h4208, space);              this.points[i]        = h2023.fromPoint(this.nodeId, p);             this.points[i].smooth = smooth;         }     }        g3743()     {         switch (this.degree)         {         case 0: this.y3746 = this.points.map(p => p.n3747());                           break;         case 1: this.y3746 = this.points.map(p => p.n3747());                           break;         case 2: this.y3746 = this.points.map(p => p.n3747());                           break;         case 3: this.y3746 = v3753(this.points, this.closed, b4244); break;         case 4: this.y3746 = v3753(this.points, this.closed, s4245 ); break;         case 5: this.y3746 = v3753(this.points, this.closed, j4246 ); break;         }     }        c3749()     {         if (this.type == v1250)         {             const bounds = this.getBounds();              this.x      = bounds.x;             this.y      = bounds.y;             this.width  = bounds.width;             this.height = bounds.height;              this.x3730(this.x, this.y, this.width, this.height);         }          this.p4032 = z3748(this.y3746, this.closed, this.degree);     }        checkFlipped(flipX, flipY)     {         super.checkFlipped(flipX, flipY);           const bounds = this.getBounds();           for (const point of this.points)         {             if (flipX) point.x.value = bounds.width  - point.x.value;             if (flipY) point.y.value = bounds.height - point.y.value;         }          this.g3743();                                                   }        s3741()     {                  this.c3749();           const oldType = this.type;         this.type = v1250;          const data =          [             ...super.s3741(),                  this.x,              this.y,              this.width,              this.height,               this.p4032,              this.winding,              this.round * Math.abs(this.k3740)         ];          this.type = oldType;           return data;     }        x3633()     {         return l2037.fromObject(this);     } }    function z3748(points, closed, degree) {     for (const p of points)         if (   isNaN(p.x)             || isNaN(p.y))             return '';                   let p4032 = '';       switch (degree)     {     case 0: p4032 = r947   (points);         break;      case 1: p4032 = w3750(points, closed); break;      case 2:                                                              case 3:                                                              case 4:                                                              case 5: p4032 = c3751    (points, closed); break;      }       const p3752 =            degree == 0 && points.length > 2         || degree == 1 && points.length > 2         || degree == 2 && points.length > 3         || degree == 3 && points.length > 2         || degree == 4 && points.length > 2         || degree == 5 && points.length > 2;       if (   p3752         && (   closed             || x1019(points[0], points.at(-1))))         p4032 += ' Z';       return p4032; }    function w3750(points, closed) {     let p4032 = '';       if (points.length < 3)         return p4032;       p4032 += 'M';     p4032 += ' ' + y879(points[0].x);     p4032 += ' ' + y879(points[0].y);      let i;     for (i = 1; i < points.length-1; i += 2)     {         p4032 +=                ' Q'             + ' ' + y879(points[i  ].x)             + ' ' + y879(points[i  ].y)             + ' ' + y879(points[i+1].x)             + ' ' + y879(points[i+1].y);     }       if (   points.length - i == 1         && closed)     {         p4032 +=                ' Q'             + ' ' + y879(points.at(-1).x)             + ' ' + y879(points.at(-1).y)             + ' ' + y879(points.at( 0).x)             + ' ' + y879(points.at( 0).y);     }       return p4032; }    function c3751(points, closed) {     let p4032 = '';       if (points.length < 4)         return p4032;       p4032 += 'M';     p4032 += ' ' + y879(points[0].x);     p4032 += ' ' + y879(points[0].y);      let i;     for (i = 1; i < points.length-2; i += 3)     {         p4032 +=                ' C'             + ' ' + y879(points[i  ].x)             + ' ' + y879(points[i  ].y)             + ' ' + y879(points[i+1].x)             + ' ' + y879(points[i+1].y)             + ' ' + y879(points[i+2].x)             + ' ' + y879(points[i+2].y);     }       if (   points.length - i == 2         && closed)     {         p4032 +=                ' C'             + ' ' + y879(points.at(-2).x)             + ' ' + y879(points.at(-2).y)             + ' ' + y879(points.at(-1).x)             + ' ' + y879(points.at(-1).y)             + ' ' + y879(points.at( 0).x)             + ' ' + y879(points.at( 0).y);     }       return p4032; }    function v3753(points, closed, i3754) {     if (points.length < 2)         return '';       const bp = [];            let [pp, p, pn] = i3754(         closed ? points.at(-1) : points[0],          points[0],         points[1]);      bp.push(p);       let _pp = pn;            for (let i = 1; i < points.length; i++)     {         [pp, p, pn] = i3754(             points[i-1],              points[i],             i == points.length-1              ? (closed ? points[0] : points[i])             : points[i+1]);          if (points[i].smooth)             [pp, pn] = c3755(points[i], pp, p, pn);                      bp.push(_pp, pp, p);             _pp = pn;     }       if (bp.length > 3)     {         if (closed)         {             if (   equal(bp[0].x, bp.at(-1).x, 0.01)                 && equal(bp[0].y, bp.at(-1).y, 0.01))             {                                  [pp, p, pn] = i3754(                     points.at(-2),                      points.at( 0),                     points.at( 1));                  if (points[0].smooth)                     [pp, pn] = c3755(points[0], pp, p, pn);                  bp[1]           = pn;                 bp[bp.length-2] = pp;             }             else             {                                  [pp, p, pn] = i3754(                     points.at(-1),                      points.at( 0),                     points.at( 1));                  if (points[0].smooth)                     [pp, pn] = c3755(points[0], pp, p, pn);                  bp.push(_pp, pp, p);                  bp[1]           = pn;                 bp[bp.length-2] = pp;             }         }         else          {             bp[1]           = y895(bp[0],     x897(o886(a900(bp[2],     bp[0]    )), distv(bp[3],     bp[0]    )/3));             bp[bp.length-2] = y895(bp.at(-1), x897(o886(a900(bp.at(-3), bp.at(-1))), distv(bp.at(-4), bp.at(-1))/3));         }     }       return bp; }    function c3755(point, pp, p, pn) {     if (point.smooth)     {         const smooth = point.smooth.value;                  pp = y895(p, x897(a900(pp, p), smooth));         pn = y895(p, x897(a900(pn, p), smooth));     }      return [pp, pn]; }    function b4244(_pointP, _point, _pointN) {     const _pp = point(_pointP.x.value, _pointP.y.value);     let   _p  = point(_point .x.value, _point .y.value);     const _pn = point(_pointN.x.value, _pointN.y.value);       const v = a900(_pn, _pp);               let a = q887(         p883(a900(_p, _pp)),          p883(a900(_pn, _p)));               a = Math.abs(a);     while (a >= Tau/2) a -= Tau;       const k     = 4 * (Math.sqrt(2) - 1) / 3;        // or use the value 0.55191502449 from http://spencermortensen.com/articles/bezier-circle/
	const kCorr = 0.9993391093366649465402826439248;       let f =         a > Tau/4         ? 1/3 + (k*kCorr - 1/3) * Math.sin(a)         : 1/3 + (k*kCorr - 1/3) * (1 - Math.cos(a));           let pp = y895(_p, x897(o886(v), -m885(v)/2 * f));     let pn = y895(_p, x897(o886(v),  m885(v)/2 * f));      pp = c1020(pp);      _p = c1020(_p);      pn = c1020(pn);       return [pp, _p, pn]; }    function s4245(_pointP, _point, _pointN) {     const _pp = point(_pointP.x.value, _pointP.y.value);     const _p  = point(_point .x.value, _point .y.value);     const _pn = point(_pointN.x.value, _pointN.y.value);      const  pp = point(_p.x - (_p.x - _pp.x) * 0.3615, _p.y);     const  pn = point(_p.x + (_pn.x - _p.x) * 0.3615, _p.y);      return [pp, _p, pn]; }    function j4246(_pointP, _point, _pointN) {     const _pp = point(_pointP.x.value, _pointP.y.value);     const _p  = point(_point .x.value, _point .y.value);     const _pn = point(_pointN.x.value, _pointN.y.value);      const  pp = point(_p.x, _p.y - (_p.y - _pp.y) * 0.3615);     const  pn = point(_p.x, _p.y + (_pn.y - _p.y) * 0.3615);      return [pp, _p, pn]; }


class o1852 extends s1847 {     x;     y;     width;     height;          points;     edges;     regions;      networkData;        constructor(nodeId, objectId, objectName, points, edges, regions)     {         super(s1262, nodeId, objectId, objectName);                  this.points  = points .map(p => p.copy());         this.edges   = edges  .map(e => e.copy());         this.regions = regions.map(r => r.copy());           this.updateNetworkData();           let bounds = l1047.NaN;          for (let i = 0; i < this.edges.length; i++)         {             bounds = z3744(                 bounds,                  f865(                     this.edges[i].start.n3747(),                      this.edges[i].start.n3747(),                     this.edges[i].end  .n3747(),                     this.edges[i].end  .n3747()));         }          this.n3742(             bounds.x + bounds.width /2,                         bounds.y + bounds.height/2                     );     }        copy()     {         const copy = new o1852(             this.nodeId,             this.objectId,             this.objectName,              this.points,              this.edges,              this.regions);           copy.x      = this.x;         copy.y      = this.y;         copy.width  = this.width;         copy.height = this.height;           copy.n3359(this);           return copy;     }        updateNetworkData()     {         let minX = Number.MAX_SAFE_INTEGER;         let minY = Number.MAX_SAFE_INTEGER;         let maxX = Number.MIN_SAFE_INTEGER;         let maxY = Number.MIN_SAFE_INTEGER;          for (const p of this.points)         {             minX = Math.min(minX, p.x.value);             minY = Math.min(minY, p.y.value);             maxX = Math.max(maxX, p.x.value);             maxY = Math.max(maxY, p.y.value);         }           this.x      = minX;         this.y      = minY;         this.width  = maxX - minX;         this.height = maxY - minY;          this.x3730(this.x, this.y, this.width, this.height);           this.networkData = getNetworkData(this.points, this.edges, this.regions);     }        getBounds()     {         let bounds = l1047.NaN;          for (let i = 0; i < this.edges.length; i++)         {             const edge = this.edges[i];              const s  = edge.start;             const e  = edge.end;             let   st = edge.e3665;             let   et = edge.h3666;              if (!st.isValid()) st = s.copy();             if (!et.isValid()) et = e.copy();              bounds = z3744(                 bounds,                  f865(                     s .n3747(),                      st.n3747(),                     et.n3747(),                     e .n3747()));         }          return bounds;     }        x3633()     {         return o1852.fromObject(this);     }        s3741()     {         return [             ...super.s3741(),                  this.x,              this.y,              this.width,              this.height,               this.networkData         ];     } }    function getNetworkData(points, edges, _regions) {     const vertices = [];     const segments = [];     const regions  = [];       for (const point of points)     {         let join;         let cap;          switch (point.join.value)         {             case 0: join = 'MITER'; break;             case 1: join = 'BEVEL'; break;             case 2: join = 'ROUND'; break;         }              switch (point.cap.value)         {             case 0: cap = 'NONE';   break;             case 1: cap = 'SQUARE'; break;             case 2: cap = 'ROUND';  break;         }              vertices.push(         {             x:            point.x.value,             y:            point.y.value,             strokeJoin:   join,             strokeCap:    cap,             cornerRadius: point.round.value         });     }       for (const edge of edges)     {         segments.push(         {             start: points.findIndex(p => p.x3736 == edge.start.x3736),             end:   points.findIndex(p => p.x3736 == edge.end  .x3736)         });     }       for (const region of _regions)     {         const loops = [];          for (const _loop of region.loops.items)         {             const loop = [];              for (const _edge of _loop.items)                 loop.push(edges.findIndex(e => e.x3736 == _edge.x3736));              loops.push(loop);         }           regions.push(         {             windingRule: region.winding.value == 1 ? 'NONZERO' : 'EVENODD',             loops:       loops,             fills:       p956(region.fills)         });     }       let networkData =      {         vertices: vertices,         segments: segments,         regions:  regions     };       return networkData; }


class m1851 extends d1853 {     width;     height;      round;     bias;        constructor(nodeId, objectId, objectName, x, y, width, height, round, bias)     {         const tw = width * (1 + Math.min(0,  bias/100));         const bw = width * (1 + Math.min(0, -bias/100));                  const tx = x + (width - tw) / 2;         const bx = x + (width - bw) / 2;          const points =         [             h2023.create(nodeId, tx,      y         ),             h2023.create(nodeId, bx,      y + height),             h2023.create(nodeId, bx + bw, y + height),             h2023.create(nodeId, tx + tw, y         )         ];               super(             nodeId,              objectId,             objectName,              points,             1,              0,              0,              round);          this.type   = w1228;          this.x      = x;         this.y      = y;         this.width  = width;         this.height = height;          this.round  = round;         this.bias   = bias;                   this.n3742(             x + width /2,              y + height/2);     }        copy()     {         const copy = new m1851(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.width,             this.height,                          this.round,             this.bias);           copy.n3359(this);          copy.g3743();           return copy;     }        x3633()     {         return f2034.fromObject(this);     } } 


class m1845 extends s1847 {     x;     y;     width;     height;     round;     corners;        constructor(nodeId, objectId, objectName, x, y, width, height, round, corners)     {         super(a1237, nodeId, objectId, objectName);                  this.x       = x;         this.y       = y;         this.width   = width;         this.height  = height;          this.round   = round;         this.corners = corners;                   this.n3742(             x + width /2,              y + height/2);     }        copy()     {         const copy = new m1845(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.width,             this.height,                          this.round,             this.corners);           copy.n3359(this);           return copy;     }        x3633()     {         return t2024.fromObject(this);     }        s3741()     {         return [             ...super.s3741(),                  this.x,              this.y,              this.width,              this.height,               this.round * Math.abs(this.k3740),              this.corners         ];     } } 


class s1849 extends s1847 {     x;     y;     width;     height;      round;     points;     convex;        constructor(nodeId, objectId, objectName, x, y, width, height, round, points, convex)     {         super(f1240, nodeId, objectId, objectName);                  this.x      = x;         this.y      = y;         this.width  = width;         this.height = height;          this.round  = round;         this.points = points;         this.convex = convex;                   this.n3742(             x + width /2,              y + height/2);     }        copy()     {         const copy = new s1849(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.width,             this.height,              this.round,             this.points,             this.convex);          copy.n3359(this);          return copy;     }        x3633()     {         return n2030.fromObject(this);     }        s3741()     {         return [             ...super.s3741(),                  this.x,              this.y,              this.width,              this.height,               this.round * Math.abs(this.k3740),              this.points,              this.convex         ];     } } 


class e1850 extends s1847 {     text;          x;     y;     width;     height;          f3757;     y3758;          font;     size;     style;          alignX;     alignY;          lineHeight;     letterSpacing;        constructor(nodeId, objectId, objectName, text, x, y, width, height, font, size, style, alignX, alignY, lineHeight, letterSpacing)     {         super(j1243, nodeId, objectId, objectName);                  this.text          = text;              this.x             = x;         this.y             = y;         this.width         = width;         this.height        = height;              this.f3757      = width;         this.y3758     = height;              this.font          = font;         this.size          = size;         this.style         = style;              this.alignX        = alignX;         this.alignY        = alignY;              this.lineHeight    = lineHeight;         this.letterSpacing = letterSpacing;                   this.n3742(             x + width /2,              y + height/2);     }        copy()     {         const copy = new e1850(             this.nodeId,             this.objectId,             this.objectName,                  this.text,                  this.x,             this.y,             this.width,             this.height,                  this.font,             this.size,             this.style,                  this.alignX,             this.alignY,                  this.lineHeight,             this.letterSpacing);           copy.f3757  = this.f3757;         copy.y3758 = this.y3758;           copy.n3359(this);           return copy;     }        x3633()     {         return q2032.fromObject(this);     }        q3756()     {         return {             ...super.q3756(),                 x:             this.x,             y:             this.y,             width:         this.width,             height:        this.height,              f3757:      this.f3757,             y3758:     this.y3758,              text:          this.text,              font:          this.font,             size:          this.size,             style:         this.style,              alignX:        this.alignX,             alignY:        this.alignY,                          lineHeight:    this.lineHeight,             letterSpacing: this.letterSpacing         };     }        s3741()     {         return [             ...super.s3741(),                  this.x,              this.y,              this.width,              this.height,                           this.f3757,              this.y3758,                           this.text,               this.font,              this.size,              this.style,                           this.alignX,              this.alignY,                           this.lineHeight,              this.letterSpacing         ];     } } 


class a1844 extends s1847 {     x;     y;     smooth;        constructor(nodeId, objectId, objectName, x, y, smooth = 1, q3739 = false, isCenter = false, isXform = false)     {         super(g1246, nodeId, objectId, objectName, q3739, isXform);                  this.x        = x;         this.y        = y;         this.smooth   = smooth;         this.isCenter = isCenter;                   this.n3742(x, y);          this.r4098(x, y);     }        copy()     {         const copy = new a1844(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.smooth,             this.q3739,             this.isCenter);          copy.n3359(this);          return copy;     }        getBounds()     {         return new l1047(             this.x - 0.005,              this.y - 0.005,              0.01,              0.01);     }        checkFlipped(flipX, flipY)     {      }        n3747()     {         return point(this.x, this.y);     }        x3633()     {         return h2023.fromObject(this);     }        s3741()     {         return [             ...super.s3741(),                  this.x,              this.y         ];     } } 


class b1838 extends s1847 {     operation;      children;        constructor(nodeId, objectId, objectName, operation, children = [])     {         super(j1286, nodeId, objectId, objectName);                  this.operation = operation;                  this.children  = children.map(c => c.copy());     }        copy()     {         const copy = new b1838(             this.nodeId,             this.objectId,             this.objectName,              this.operation,             this.children);          copy.n3359(this);                  return copy;     }        getBounds()     {         return getObjBounds(this.children);     }        n4099(h4208, affectSpace)     {         for (const a111 of this.children)             a111.n4099(h4208, affectSpace);     }        q3756()     {         return {             ...super.q3756(),                 operation: this.operation,             children:  this.children         };     }        s3741()     {         return [             ...super.s3741(),                  this.children.map(o => o.s3741()),              this.operation         ];     } }


class FigmaArcPath extends d1853 {     position;                          start;     sweep;            constructor(nodeId, objectId, objectName, pos, x, y, width, height, start, sweep)     {         let points = makeArc_(             point(                 x + width /2,                  y + height/2),              width/2,               start,              start + sweep);                      points = points.map(p => h2023.fromPoint(nodeId, p));           points.forEach(p =>          {             p.y.value =                  pos > 0                 ? p.y.value * height/nozero(width)                 : height/2 + (p.y.value - height/2) * height/nozero(width);              if (   pos == 0                 && width < 0)                  p.x.value += width;         });          if (width  < 0) width  *= -1;         if (height < 0) height *= -1;           super(             nodeId,              objectId,             objectName,             points,             0,               2,               0,               0);                    this.position = pos;         this.x       = x;         this.y       = y;         this.width   = width;         this.height  = height;          this.start    = start;         this.sweep    = sweep;           this.n3742(             x + width /2,             y + height/2);     }        copy()     {         const copy = new FigmaArcPath(             this.nodeId,             this.objectId,             this.objectName,              this.position,             this.x,             this.y,             this.width,             this.height,                          this.start,             this.sweep);           copy.y3746 = [...this.y3746];         copy.p4032   = this.p4032;          copy.n3359(this);           return copy;     } }


class FigmaWavePath extends d1853 {     shape;     _x;     _y;     b3073;     amplitude;     frequency;     offset;     alignX;     alignY;            constructor(nodeId, objectId, objectName, shape, x, y, width, amplitude, frequency, offset, alignX, alignY)     {         let points = makeWave(             shape,              x,             y,             width,              amplitude,              frequency,             offset,             alignX,             alignY);          points = points.map(p => h2023.fromPoint(nodeId, p));           super(             nodeId,              objectId,             objectName,             points,             0,                               shape == 4 ? 2 : 0,              0,                               0);                                    this.shape     = shape;         this._x        = x;         this._y        = y;         this.b3073    = width;         this.amplitude = amplitude;         this.frequency = frequency;         this.offset    = offset;         this.alignX    = alignX;         this.alignY    = alignY;           let height = amplitude;                  this.n3742(             x + width /2,             y + height/2);     }        copy()     {         const copy = new FigmaWavePath(             this.nodeId,             this.objectId,             this.objectName,              this.shape,             this._x,             this._y,             this.b3073,             this.amplitude,             this.frequency,             this.offset,             this.alignX,             this.alignY);           copy.y3746 = [...this.y3746];         copy.p4032   = this.p4032;          copy.n3359(this);           return copy;     } }


class a1848 extends s1847 {     children;        constructor(nodeId, objectId, objectName, children = [])     {         super(i1265, nodeId, objectId, objectName);                  this.children = children.map(c => c.copy());     }        copy()     {         const copy = new a1848(             this.nodeId,             this.objectId,             this.objectName,              this.children);          copy.n3359(this);          return copy;     }        getCount()     {         let v3334 =             this.children.length > 0             ? super.getCount()             : 0;          for (const a111 of this.children)             v3334 += a111.getCount();          return v3334;     }        n3742(cx = 0, cy = 0)     {         super.n3742(cx, cy);          for (const a111 of this.children)             a111.n3742(cx, cy);     }        resetSpace(bounds, singlePoint = false, cx = 0.5, cy = 0.5, units = 0)     {         super.resetSpace(bounds, false, cx, cy, units);          for (const a111 of this.children)             a111.resetSpace(bounds, false, cx, cy, units);     }        getBounds()     {         return getObjBounds(this.children);     }        n4099(h4208, affectSpace)     {         for (const a111 of this.children)             a111.n4099(h4208, affectSpace);     }        q3756()     {         return {             ...super.q3756(),                 children: this.children         };     }        s3741()     {         return [             ...super.s3741(),                  this.children.map(o => o.s3741())         ];     } }


class u1841 extends s1847 {     x;     y;     width;     height;      round;          clip;      children;        constructor(nodeId, objectId, objectName, x, y, width, height, round, clip, children = [])     {         super(f1268, nodeId, objectId, objectName);                  this.x        = x;         this.y        = y;         this.width    = width;         this.height   = height;              this.round    = round;          this.clip     = clip;              this.children = children.map(c => c.copy());          this.n3742(             x + width /2,              y + height/2);     }        copy()     {         const copy = new u1841(             this.nodeId,             this.objectId,             this.objectName,                  this.x,             this.y,             this.width,             this.height,                  this.round,                this.clip,                  this.children);           copy.n3359(this);           return copy;     }        getCount()     {         let v3334 = super.getCount();          for (const a111 of this.children)             v3334 += a111.getCount();          return v3334;     }            checkFlipped(flipX, flipY)     {         super.checkFlipped(flipX, flipY);          for (const a111 of this.children)         {             a111.checkFlipped(flipX, flipY);              if (flipX)             {                 a111.xp0.x = this.width - a111.xp0.x;                 a111.xp1.x = this.width - a111.xp1.x;                 a111.xp2.x = this.width - a111.xp2.x;             }              if (flipY)             {                 a111.xp0.y = this.height - a111.xp0.y;                 a111.xp1.y = this.height - a111.xp1.y;                 a111.xp2.y = this.height - a111.xp2.y;             }         }     }        q3756()     {         return {             ...super.q3756(),                 x:        this.x,             y:        this.y,             width:    this.width,             height:   this.height,                      round:    this.round,              clip:     this.clip,                      children: this.children         };     }        s3741()     {         return [             ...super.s3741(),                  this.x,              this.y,              this.width,              this.height,               this.round,               this.clip,               this.children.map(o => o.s3741())         ];     } }    


class b1839 {     type;          nodeId = '';      styleId;     styleName;      paints = [];          constructor(nodeId, styleId, styleName)     {         this.type      = e1216;         this.nodeId    = nodeId;          this.styleId   = styleId;         this.styleName = styleName;     }        copy()     {         const copy = new b1839(this.nodeId, this.styleId, this.styleName);            return copy;     }        s3741()     {         return [          this.type,          this.nodeId,           this.styleId,          this.styleName,                   this.paints         ];     } }


class l2042 {     static nextUniqueId = 0;      type;       valid;       listId           = -1;     x3736;      cached           = true;     unknown          = false;      z3821           = NULL;      currentIteration = 0;     iterated         = false;       e3096     = null;        constructor(type, options)      {         this.type    = type;          if (options && options.cached ) this.cached  = options.cached;         if (options && options.unknown) this.unknown = options.unknown;               this.x3736 = l2042.nextUniqueId++;     }        reset()     {                                                                                   this.e3096 = null;     }        copy()     {         j953('abstract type l2042 cannot be copied');         return null;     }        n3359(base)     {                  this.x3736 = base.x3736;     }        t3768()     {         if (    this.input             &&  this.input.t3768             && !this.input.notCondition)             return this.input.t3768();                  return this;     }            x3633()     {         return null;     }        toString()      {          return this.type;      }        n2119()     {         return this.toString();     }        isValid()      {         return false;     }            validate()     {         this.valid = true;     }        invalidate()     {         this.valid = false;     }        r4088(parse)     {      }        o4089(parse, from, force = false)     {         if (   this.unknown             || force)             this.valid = false;          return true;     }        o3629(parse, nodeId)     {      }        j3630(parse, nodeId)     {      }        t4087(parse)     {      }        u3632(parse, nodeId)     {      }     } 


class i2050  {     type;     valueId;      customParams = [];       objects      = null;        constructor(type)      {                   this.type    = type;          this.valueId = '';     }        reset() {}        copy()     {         j953('abstract class i2050 cannot be copied');         return null;     }        n3359(base)     {                           this.valueId  = base.valueId;         this.x3736 = base.x3736;          this.r3626(base);          if (base.objects)             this.d3627(base.objects);     }        r3626(base)     {         for (const param of base.customParams)             this.customParams.push([param[0], param[1].copy()]);     }        d3627(objects)     {         this.objects = objects.map(o => o.copy());     }                               c3712()     {         return false;     }        x3633()     {         return this.copy();     }        n2119()      {          return this.toString();      }        toString()      {          return this.type;      }        h3706()     {         return this.toString();     }        k2847(gen)     {         j953('invalid abstract method');         return '';     }        o3358()     {         j953('invalid abstract method');         return null;     }        isCached()     {         return true;     }        r4088(parse)              {}     o4089(parse, from, force) {}     t4087     (parse)              {} }    function h3837(type, value) {     switch (type)     {         case            u1087: return parseNullValue         (value)[0];          case           y1056:          case    m1057:          case      u1058:          case     y1059: return u3482         (value)[0];          case         t1091: return g2850       (value)[0];         case           t1143: return s2865         (value)[0];         case          x1168: return s2866        (value)[0];          case           k1178: return k3677         (value)[0];         case     r1184: return l2867    (value)[0];         case       i1187: return c3676     (value)[0];         case         g1181: return y3832       (value)[0];         case    g1196: return j3833   (value)[0];         case   w1199: return s3834  (value)[0];         case     c1202: return r3835    (value)[0];         case      t1205: return o3707     (value)[0];         case    v1211: return k3708   (value)[0];         case     c1208: return t3709    (value)[0];          case      w1218: return p3711    (value)[0];         case           h1221: return w3822         (value)[0];         case        m1224: return k3823      (value)[0];         case        r1227: return c3824      (value)[0];         case        d1236: return o3825      (value)[0];         case           x1239: return m3826         (value)[0];         case     f1242: return z3827    (value)[0];         case          t1245: return n3828        (value)[0];         case    m1249: return h3670   (value)[0];         case  c1252: return q3669 (value)[0];         case    d1255: return p3667   (value)[0];         case  l1258: return b3664 (value)[0];         case q1261: return q3663(value)[0];         case  h1287: return h3829 (value)[0];         case    c1264: return y3830   (value)[0];         case       m1231: return parseArcPathValue      (value)[0];         case      g1234: return parseWavePathValue     (value)[0];         case          t1267: return d3831        (value)[0];                  default:              console.error('unknown type \'' + type + '\'');             console.log('value =', value);             return null;     } }    function b4210(type, value) {     if (   type == t1091         && value.indexOf(',') < 0)         return value;       switch (type)     {         case            u1087: return parseNullValue         (value)[0].h3706();         case           y1056: return u3482         (value)[0].h3706();          case         t1091: return g2850       (value)[0].h3706();         case           t1143: const val = s2865    (value)[0]; return val == '' ? '\'\'' : val.h3706();         case          x1168: return s2866        (value)[0].h3706();         case           k1178: return k3677         (value)[0].h3706();         case     r1184: return l2867    (value)[0].h3706();         case       i1187: return c3676     (value)[0].h3706();         case         g1181: return y3832       (value)[0].h3706();         case    g1196: return j3833   (value)[0].h3706();         case   w1199: return s3834  (value)[0].h3706();         case     c1202: return r3835    (value)[0].h3706();         case      t1205: return o3707     (value)[0].h3706();         case    v1211: return k3708   (value)[0].h3706();         case     c1208: return t3709    (value)[0].h3706();          case      w1218: return p3711    (value)[0].h3706();         case           h1221: return w3822         (value)[0].h3706();         case        m1224: return k3823      (value)[0].h3706();         case        r1227: return c3824      (value)[0].h3706();         case        d1236: return o3825      (value)[0].h3706();         case           x1239: return m3826         (value)[0].h3706();         case     f1242: return z3827    (value)[0].h3706();         case          t1245: return n3828        (value)[0].h3706();         case    m1249: return h3670   (value)[0].h3706();         case  c1252: return q3669 (value)[0].h3706();         case    d1255: return p3667   (value)[0].h3706();         case  l1258: return b3664 (value)[0].h3706();         case q1261: return q3663(value)[0].h3706();         case  h1287: return h3829 (value)[0].h3706();         case    c1264: return y3830   (value)[0].h3706();         case          t1267: return d3831        (value)[0].h3706();     }       j953('cannot display value of type \'' + type + '\''); }    function nanFromType(type) {     switch (type)     {         case            y1056: return          x2021.NaN;          case          t1091: return        d2022.NaN;         case            t1143: return        new j2033();         case           x1168: return         s2010.NaN;         case            k1178: return          v2013.NaN;         case      r1184: return     w2009.NaN;         case        i1187: return      a2015.NaN;         case          g1181: return        y2031.NaN;         case     g1196: return    m2011.NaN;         case    w1199: return   c2016.NaN;         case      c1202: return     j2018.NaN;         case       t1205: return      p2008.NaN;         case     v1211: return    f2017.NaN;         case      c1208: return     g2019.NaN;          case       w1218: return     s2025.NaN;         case            h1221: return          s2020.NaN;         case         m1224: return       i2012.NaN;         case         d1236: return       t2024.NaN;         case            x1239: return          n2030.NaN;         case      f1242: return     q2032.NaN;         case           t1245: return         h2023.NaN;         case     m1249: return    l2037.NaN;         case   c1252: return  o2039.NaN;         case     d1255: return    c2035.NaN;         case   l1258: return  c2038.NaN;         case  q1261: return t2036.NaN;         case   h1287: return  k2027.NaN;         case     c1264: return    g2028.NaN;         case           t1267: return         p2014.NaN;     }      j953('cannot determine null value from type \'' + type + '\''); }


class g2043 extends l2042 {     nodeId;     nodeName;      topLevel;      value;          customParams = [];      options      = {};     e3096 = [];               constructor(type, nodeId, options)     {         super(type, options);          this.nodeId   = nodeId;         this.nodeName = options.nodeName;          this.options  = clone(options);          this.valid    = false;         this.topLevel = false;          this.value    = null;     }        reset()     {         this.customParams = [];         this.options      = {};         this.e3096 = [];     }        n3359(base)     {         super.n3359(base);                  this.nodeId   = base.nodeId;         this.nodeName = base.nodeName;          this.r3626(base);          this.options  = clone(base.options);          this.valid    = base.valid;         this.topLevel = base.topLevel;          if (base.value) this.value = base.value.copy();     }        r3626(base)     {         for (const param of base.customParams)             this.customParams.push([param[0], param[1].copy()]);     }        f4242(p2992)     {         return p2992 == 'value'             ?  this.value             :  this[p2992];     }        isCached()     {         return this.options.cached             && this.valid;     }        async eval(parse)     {                   return this;     }        async v4100(parse)     {      }        d3627(value, listId = -1)     {         const objects = u3628(value);         const copies  = [];                                  for (let i = 0; i < objects.length; i++)         {             const a111 = b3738(objects[i]);                  a111.nodeId   = this.nodeId;             a111.listId   = listId;                          a111.objectId = a111.objectId + h967 + this.nodeId;                  copies.push(a111);         }          return copies;     }                outputType()     {         return this.value             ? new j2033(                 g957(this.value.type)                 ? m3479(this.value.items)                 : this.value.type)             : new j2033(u1087);     }        outputListType()     {         return this.outputType();                                }        x3633()     {         return this.value              ? this.value.copy()              : null;     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.unknown)             this.valid = false;          this.iterated = false;     }        o3629(parse, nodeId)     {         this.z3821           = nodeId;         this.currentIteration = 0;     }        j3630(parse, nodeId)     {         this.valid = false;     }        t4087(parse)     {         const e3631 = parse.repeats.findIndex(r => r.repeatId == this.z3821);                                                                if (   (   e3631 < 0                 || e3631 == parse.repeats.length-1)             && !this.iterated)         {                          this.currentIteration++;             this.iterated = true;         }     }        iterateCache(parse, from)     {      }        u3632(parse, nodeId)     {         this.valid            = false;         this.currentIteration = 0;     }            n4101(parse, values, add = false)     {         if (    parse.repeats.length == 0             ||  this.unknown && parse.repeats[0].total == 0             || !this.unknown             ||  parse.repeats.at(-1).currentIteration == 0             ||  parse.repeats.at(-1).currentIteration == parse.repeats.at(-1).total-1)         {             if (add) this.e3096.push(...values);             else     this.e3096 = [...values];         }         else if (!add)             this.e3096 = [];     }        r4088(parse)     {                 if (!this.e3096)             return;          for (const value of this.e3096)             s2062(parse, this.nodeId, value[0], value[1]);                   this.e3096 = [];     }        y4216()     {         if (   !this.value             || !this.value.objects)             return;           for (let i = 0; i < this.value.objects.length; i++)         {             const a111     = this.value.objects[i];              a111.nodeId    = this.nodeId;             a111.objectId += h967 + this.nodeId;             a111.listId    = -1;         }     }                                                                           setConditionInput(input)     {      } }    async function evalValue(_value, parse, nan = () => new g4217()) {     let value =          _value          ? (await _value.eval(parse)).x3633()          : null;      if (    value          && !value.isValid()         && nan)          value = nan();      return value; }    async function evalNumberValue        (_value, parse) { return await evalValue(_value, parse, () => d2022        .NaN.copy()); } async function evalTextValue          (_value, parse) { return await evalValue(_value, parse, () => new j2033());                }  async function evalColorValue         (_value, parse) { return await evalValue(_value, parse, () => s2010         .NaN.copy()); } async function evalFillValue          (_value, parse) { return await evalValue(_value, parse, () => v2013          .NaN.copy()); } async function evalStrokeValue        (_value, parse) { return await evalValue(_value, parse, () => y2031        .NaN.copy()); } async function evalColorStopValue     (_value, parse) { return await evalValue(_value, parse, () => w2009     .NaN.copy()); } async function evalGradientValue      (_value, parse) { return await evalValue(_value, parse, () => a2015      .NaN.copy()); }  async function evalListValue          (_value, parse) { return await evalValue(_value, parse, () => x2021          .NaN.copy()); }  async function evalRectangleValue     (_value, parse) { return await evalValue(_value, parse, () => s2025     .NaN.copy()); } async function evalLineValue          (_value, parse) { return await evalValue(_value, parse, () => s2020          .NaN.copy()); } async function evalPolygonValue       (_value, parse) { return await evalValue(_value, parse, () => t2024       .NaN.copy()); } async function evalTextShapeValue     (_value, parse) { return await evalValue(_value, parse, () => q2032     .NaN.copy()); }  async function evalPointValue         (_value, parse) { return await evalValue(_value, parse, () => h2023         .NaN.copy()); } async function evalVectorPathValue    (_value, parse) { return await evalValue(_value, parse, () => l2037    .NaN.copy()); } async function evalArcPathValue       (_value, parse) { return await evalValue(_value, parse, () => ArcPathValue       .NaN.copy()); } async function evalWavePathValue      (_value, parse) { return await evalValue(_value, parse, () => WavePathValue      .NaN.copy()); } async function evalVectorVertexValue  (_value, parse) { return await evalValue(_value, parse, () => o2039  .NaN.copy()); } async function evalVectorEdgeValue    (_value, parse) { return await evalValue(_value, parse, () => c2035    .NaN.copy()); } async function evalVectorRegionValue  (_value, parse) { return await evalValue(_value, parse, () => c2038  .NaN.copy()); }  async function evalFrameValue         (_value, parse) { return await evalValue(_value, parse, () => p2014         .NaN.copy()); }  async function evalInnerShadowValue   (_value, parse) { return await evalValue(_value, parse, () => c2016   .NaN.copy()); } async function evalLayerBlurValue     (_value, parse) { return await evalValue(_value, parse, () => j2018     .NaN.copy()); } async function evalStrokeSidesValue   (_value, parse) { return await evalValue(_value, parse, () => g4272   .NaN.copy()); } async function evalRoundedCornersValue(_value, parse) { return await evalValue(_value, parse, () => RoundedCornersValue.NaN.copy()); } 


class i2044 extends g2043 {     input = null;        reset()     {         super.reset();          this.input = null;     }        n3359(base)     {         super.n3359(base);          if (base.input) this.input = base.input.copy();     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        isValid()     {         return this.input && this.input.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.input) this.input.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.input) this.input.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.input) this.input.t4087(parse);     }        t3768()     {         if (    this.input             &&  this.input.t3768             && !this.input.notCondition)             return this.input.t3768();                  return this;     }        setConditionInput(input)     {         this.input = input;     } }


class u2045 extends g2043 {     e4083 = null;     j4084 = null;        reset()     {         super.reset();          this.e4083 = null;         this.j4084 = null;     }        n3359(base)     {         super.n3359(base);          if (base.e4083) this.e4083 = base.e4083.copy();         if (base.j4084) this.j4084 = base.j4084.copy();     }        isCached()     {         return super.isCached()             && (!this.e4083 || this.e4083.isCached())             && (!this.j4084 || this.j4084.isCached());     }        p4090(node)     {         return this.e4083 && this.e4083.nodeId == node.nodeId             || this.j4084 && this.j4084.nodeId == node.nodeId;     }        isValid()     {         return this.e4083 && this.e4083.isValid()             && this.j4084 && this.j4084.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.e4083) this.e4083.r4088(parse);         if (this.j4084) this.j4084.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.e4083) this.e4083.o4089(parse, from, force);         if (this.j4084) this.j4084.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.e4083) this.e4083.t4087(parse);         if (this.j4084) this.j4084.t4087(parse);     }        t3768()     {         if (    this.e4083             &&  this.e4083.t3768             && !this.e4083.notCondition)             return this.e4083.t3768();                  else if (this.j4084              &&  this.j4084.t3768              && !this.j4084.notCondition)             return this.j4084.t3768();                  return this;     } }


class q2046 extends g2043 {     e4083 = null;     j4084 = null;     n4085 = null;        reset()     {         super.reset();          this.e4083 = null;         this.j4084 = null;         this.n4085 = null;     }        n3359(base)     {         super.n3359(base);          if (base.e4083) this.e4083 = base.e4083.copy();         if (base.j4084) this.j4084 = base.j4084.copy();         if (base.n4085) this.n4085 = base.n4085.copy();     }        isCached()     {         return super.isCached()             && (!this.e4083 || this.e4083.isCached())             && (!this.j4084 || this.j4084.isCached())             && (!this.n4085 || this.n4085.isCached());     }        p4090(node)     {         return this.e4083 && this.e4083.nodeId == node.nodeId             || this.j4084 && this.j4084.nodeId == node.nodeId             || this.n4085 && this.n4085.nodeId == node.nodeId;     }        isValid()     {         return this.e4083 && this.e4083.isValid()             && this.j4084 && this.j4084.isValid()             && this.n4085 && this.n4085.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.e4083) this.e4083.r4088(parse);         if (this.j4084) this.j4084.r4088(parse);         if (this.n4085) this.n4085.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.e4083) this.e4083.o4089(parse, from, force);         if (this.j4084) this.j4084.o4089(parse, from, force);         if (this.n4085) this.n4085.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.e4083) this.e4083.t4087(parse);         if (this.j4084) this.j4084.t4087(parse);         if (this.n4085) this.n4085.t4087(parse);     }        t3768()     {         if (    this.e4083             &&  this.e4083.t3768             && !this.e4083.notCondition)             return this.e4083.t3768();                  else if (this.j4084              &&  this.j4084.t3768              && !this.j4084.notCondition)             return this.j4084.t3768();                  else if (this.n4085              &&  this.n4085.t3768              && !this.n4085.notCondition)             return this.n4085.t3768();                  return this;     } }


class b2047 extends g2043 {     e4083 = null;     j4084 = null;     n4085 = null;     x4086 = null;        reset()     {         super.reset();          this.e4083 = null;         this.j4084 = null;         this.n4085 = null;         this.x4086 = null;     }        n3359(base)     {         super.n3359(base);          if (base.e4083) this.e4083 = base.e4083.copy();         if (base.j4084) this.j4084 = base.j4084.copy();         if (base.n4085) this.n4085 = base.n4085.copy();         if (base.x4086) this.x4086 = base.x4086.copy();     }        isCached()     {         return super.isCached()             && (!this.e4083 || this.e4083.isCached())             && (!this.j4084 || this.j4084.isCached())             && (!this.n4085 || this.n4085.isCached())             && (!this.x4086 || this.x4086.isCached());     }        p4090(node)     {         return this.e4083 && this.e4083.nodeId == node.nodeId             || this.j4084 && this.j4084.nodeId == node.nodeId             || this.n4085 && this.n4085.nodeId == node.nodeId             || this.x4086 && this.x4086.nodeId == node.nodeId;     }        isValid()     {         return this.e4083 && this.e4083.isValid()             && this.j4084 && this.j4084.isValid()             && this.n4085 && this.n4085.isValid()             && this.x4086 && this.x4086.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.e4083) this.e4083.r4088(parse);         if (this.j4084) this.j4084.r4088(parse);         if (this.n4085) this.n4085.r4088(parse);         if (this.x4086) this.x4086.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.e4083) this.e4083.o4089(parse, from, force);         if (this.j4084) this.j4084.o4089(parse, from, force);         if (this.n4085) this.n4085.o4089(parse, from, force);         if (this.x4086) this.x4086.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.e4083) this.e4083.t4087(parse);         if (this.j4084) this.j4084.t4087(parse);         if (this.n4085) this.n4085.t4087(parse);         if (this.x4086) this.x4086.t4087(parse);     }        t3768()     {         if (    this.e4083             &&  this.e4083.t3768             && !this.e4083.notCondition)             return this.e4083.t3768();                  else if (this.j4084              &&  this.j4084.t3768              && !this.j4084.notCondition)             return this.j4084.t3768();                  else if (this.n4085              &&  this.n4085.t3768              && !this.n4085.notCondition)             return this.n4085.t3768();                  else if (this.x4086              &&  this.x4086.t3768              && !this.x4086.notCondition)             return this.x4086.t3768();                  return this;     } }


class p2049 extends g2043 {     p2992;          node;     param;            constructor(nodeId, p2992)     {         super(PARAM, nodeId, false);          this.p2992 = p2992;     }        reset()     {         if (this.node)             this.node.reset();     }        copy()     {         const copy = new p2049(this.nodeId, this.p2992);          copy.n3359(this);          copy.node = this.node;              return copy;     }        t3768()     {         return this.node              ? this.node.t3768()              : null;     }        async eval(parse)     {         this.node = parse.k4243.find(v => v.nodeId == this.nodeId);         l952(this.node, 'can\'t find parameter node \'' + this.nodeId + '\'');           if (    this.node.type != c1080             || !this.node.p4212)             await this.node.eval(parse);           this.param = this.node.f4242(this.p2992);           if (isValid(this.param))         {             if (   this.node.type != p1063                 && this.p2992 != 'from')                 this.value = await evalValue(this.param, parse);             else                 this.value = new g4217();                               return this.value                  ? this.value.copy()                  : null;         }         else             return this.value = new g4217();     }        isCached()     {         return super.isCached();      }        x3633()     {         return this.value.copy();     }        r4088(parse)     {         super.r4088(parse);          if (this.node) this.node.r4088(parse);     }            o4089(parse, from, force)     {         super.o4089(parse, from, force);                  if (this.node) this.node.o4089(parse, from, force);     }        o3629(parse, nodeId)     {         const node = parse.k4243.find(n => n.nodeId == this.nodeId);                  node.o3629(parse, nodeId);     }        iterateCache(parse, from)     {         const node = parse.k4243.find(n => n.nodeId == this.nodeId);                   node.iterateCache(parse, from);     }        j3630(parse, nodeId)     {         const node = parse.k4243.find(n => n.nodeId == this.nodeId);                  node.j3630(parse, nodeId);     }        o3629(parse, nodeId)     {         const node = parse.k4243.find(n => n.nodeId == this.nodeId);                  node.o3629(parse, nodeId);     }        t4087(parse)     {         const node = parse.k4243.find(n => n.nodeId == this.nodeId);                  node.t4087(parse);     }        u3632(parse, nodeId)     {         const node = parse.k4243.find(n => n.nodeId == this.nodeId);                  node.u3632(parse, nodeId);     }                                                                                                                                                                                                 }


class g4217 extends i2050 {     value;        constructor()     {         super(u1087);          this.value = null;     }        copy()     {         const copy = new g4217();          copy.n3359(this);          return copy;     }        equals(_null)     {         return _null             && this.type  == _null.type             && this.value == _null.value;     }        async eval(parse)     {         return this;     }        c3712()     {         return true;     }        isValid()     {         return false;     }        x3633()     {         return this.copy();     }        n2119()      {          return this.toString();      }        toString()     {         return '';     }        z3705()     {         return 'NULL';     }        h3706()     {         return 'NULL';     }        k2847(gen)     {         return this.z3705();     }        o3358()     {         return this;     } }    function parseNullValue(str) {     const _null = new g4217();      return [_null, 1]; } 


class x2021 extends i2050 {     items;      condensed = false;        constructor(items = [])     {         super(y1056);          if (items)         {             this.items = [];              for (const item of items)             {                 this.items.push(item.copy());                  if (   this.objects                     && item.objects)                     this.objects.push(...item.objects.map(o => o.copy()));             }         }     }        copy()     {         const copy = new x2021(this.items);          copy.n3359(this);          copy.condensed = this.condensed;          return copy;     }        equals(list)     {         if (!list)                                  return false;         if (!(list instanceof x2021))           return false;         if (this.items.length != list.items.length) return false;                      for (let i = 0; i < this.items.length; i++)             if (!this.items[i].equals(list.items[i]))                 return false;          return true;     }        async eval(parse)     {         return this.copy();     }        x3633()     {         return this.copy();     }        c3712()     {         if (!this.items)             return false;                      for (const item of this.items)             if (!item.c3712())                 return false;          return true;     }        isValid()     {                  return  this.items;              }        n2119()     {         if (!this.items)             return '';           let str = '';                           str += this.items.length;          for (let i = 0; i < this.items.length; i++)         {             const item = this.items[i];              str += ' ' + item.type + ' ';             str += item.n2119();         }           return str;     }        toString()     {         if (!this.items)             return '';           let str = '';                           str += this.items.length;          for (let i = 0; i < this.items.length; i++)         {             const item = this.items[i];              str += ' ' + item.type + ' ';             str += item.toString();         }           return str;     }        z3705()     {         if (!this.items)             return '';           const nItems = Math.min(this.items.length, 10);           let str = '';          for (let i = 0; i < nItems; i++)         {             if (i > 0)                  str += '<br/>';               const item = this.items[i];              if (g957(item.type))                              {                 for (let j = 0; j < item.items.length; j++)                 {                     if (j > 0)                          str += ', ';                                          str += item.items[j].z3705();                 }             }             else                 str += item.z3705();         }          if (this.items.length > 10)              str += '<br/>. . .';                  return str;     }        h3706()     {         if (!this.items)             return '';           let str = '';                           str += this.items.length;          for (let i = 0; i < this.items.length; i++)         {             const item = this.items[i];              str += ' ' + item.type + ' ';             str += item.h3706();         }           return str;     }        o3358()     {         return x2021.NaN.copy();     }        static NaN = Object.freeze(new x2021(null)); }    function u3482(str, i = -1) {     if (i < 0)     {         str = str.split(' ');         i   = 0;     }                   const r3769  = i;     const a4209 = parseInt(str[i++]);               const list = new x2021();       for (let j = 0; j < a4209; j++)     {         const type = str[i++];          switch (type)         {             case          y1056:               case   m1057:               case     u1058:               case    y1059: { const _list   = u3482        (str, i);  i += _list  [1];  list.items.push(_list  [0]);  break; }               case        t1091: { const num     = g2850      (str[i]);  i += num    [1];  list.items.push(num    [0]);  break; }             case          t1143: { const text    = s2865        (str[i]);  i += text   [1];  list.items.push(text   [0]);  break; }             case         x1168: { const color   = s2866       (str, i);  i += color  [1];  list.items.push(color  [0]);  break; }              case          k1178: { const fill    = k3677        (str, i);  i += fill   [1];  list.items.push(fill   [0]);  break; }             case    r1184: { const stop    = l2867   (str, i);  i += stop   [1];  list.items.push(stop   [0]);  break; }             case      i1187: { const grad    = c3676    (str, i);  i += grad   [1];  list.items.push(grad   [0]);  break; }             case        g1181: { const stroke  = y3832      (str, i);  i += stroke [1];  list.items.push(stroke [0]);  break; }             case   g1196: { const shadow  = j3833  (str, i);  i += shadow [1];  list.items.push(shadow [0]);  break; }             case  w1199: { const shadow  = s3834 (str, i);  i += shadow [1];  list.items.push(shadow [0]);  break; }             case    c1202: { const blur    = r3835   (str, i);  i += blur   [1];  list.items.push(blur   [0]);  break; }             case     t1205: { const blur    = o3707    (str, i);  i += blur   [1];  list.items.push(blur   [0]);  break; }             case   v1211: { const layer   = k3708  (str, i);  i += layer  [1];  list.items.push(layer  [0]);  break; }             case    c1208: { const mask    = t3709   (str[i]);  i += mask   [1];  list.items.push(mask   [0]);  break; }              case     w1218: { const rect    = p3711   (str, i);  i += rect   [1];  list.items.push(rect   [0]);  break; }             case          h1221: { const line    = w3822        (str, i);  i += line   [1];  list.items.push(line   [0]);  break; }             case       m1224: { const ellipse = k3823     (str, i);  i += ellipse[1];  list.items.push(ellipse[0]);  break; }             case       r1227: { const trapeze = c3824     (str, i);  i += trapeze[1];  list.items.push(trapeze[0]);  break; }             case       d1236: { const poly    = o3825     (str, i);  i += poly   [1];  list.items.push(poly   [0]);  break; }             case          x1239: { const star    = m3826        (str, i);  i += star   [1];  list.items.push(star   [0]);  break; }             case    f1242: { const text    = z3827   (str, i);  i += text   [1];  list.items.push(text   [0]);  break; }             case         t1245: { const point   = n3828       (str, i);  i += point  [1];  list.items.push(point  [0]);  break; }             case   m1249: { const path    = h3670  (str, i);  i += path   [1];  list.items.push(path   [0]);  break; }             case h1287: { const bool    = h3829(str, i);  i += bool   [1];  list.items.push(bool   [0]);  break; }             case   c1264: { const group   = y3830  (str, i);  i += group  [1];  list.items.push(group  [0]);  break; }             case         t1267: { const frame   = d3831       (str, i);  i += frame  [1];  list.items.push(frame  [0]);  break; }         }     }           return [         list,          i - r3769]; }    function getItemTypes(items, debug) {     const types = [];      for (const item of items)     {         if (   item.type ==        y1056             || item.type == m1057             || item.type ==   u1058             || item.type ==  y1059)             p949(types, m3479(item.items, debug));          else             p949(types, item.type);     }      return types; }    function finalTypeFromItems(items) {     return finalTypeFromTypes(getItemTypes(items)); }    function m3479(items) {     return z3036(getItemTypes(items)); }    function finalTypeFromTypes(types) {     let _type = u1087;      for (const type of types)     {         if (_type == u1087)             _type = type;          else if (    r1294.includes(_type)                   && !r1294.includes( type))         {             _type = u1087;             break;          }         else if (   !r1294.includes(_type)                   && _type != type)         {             _type = u1087;             break;          }     }      return _type; }    function z3036(types) {     let _type = finalTypeFromTypes(types);               if (  _type == t1091)      return m1057;     else if (  _type ==   t1143)      return   u1058;     else if (r1294.includes(_type)) return  y1059;     else                                   return        y1056; }


class d2022 extends i2050 {     value;     i3789;     decimals;        constructor(val = Number.NaN, dec = -1)     {         super(t1091);          if (typeof val !== 'number')             j953('NumberValue(value) is ' + typeof val + ', must be a number');           this.value     = val;         this.i3789 = val;                  this.decimals =                !isNaN(this.value)              && dec == -1              ? x1004(this.value)              : dec;     }        static fromString(str)     {         return new d2022(             parseFloat(str),             d1459(str));     }        copy()     {         const copy = new d2022(             this.value,              this.decimals);          copy.i3789 = this.i3789;          copy.n3359(this);          return copy;     }        equals(num)     {         return num             && this.value    == num.value             && this.decimals == num.decimals;     }        async eval(parse)     {         return this.copy();     }        c3712()     {         return this.value == this.i3789;     }        isValid()     {         return !isNaN(this.value)             && !isNaN(this.decimals);     }        q3729()     {         return new d2022(Math.round(this.value));     }        k3703()     {         return n1016(this.value, this.decimals);     }        toString()     {         return f1471(this.value)               + ','               + f1471(this.decimals);     }        z3705()     {         return this.isValid()              ? h1006(this.value, this.decimals)              : g964;     }        h3706()     {         return f1471(this.value)               + (!isNaN(this.decimals)                 ? '_' + this.decimals                  : '');     }        k2847(gen)     {         return this.z3705();     }        o3358()     {         return d2022.NaN.copy();     }        static NaN = Object.freeze(new d2022(         Number.NaN,          Number.NaN)); }    function g2850(str) {     if (str.indexOf(',') < 0)     {         j953('number value \'' + str + '\' missing \',\'');         console.trace();     }           const parts = str.split(',');      const num = new d2022(         h1472(parts[0]),         h1472(parts[1]));      return [num, 1]; }    function y3836(str) {     const num =          str == g964         ? d2022.NaN.copy()         : d2022.fromString(str);      return [num, 1]; }


class j2033 extends i2050 {     value;     i3789;        constructor(val = '')     {         super(t1143);           if (   val !== null             && typeof val !== 'string')         {             console.trace();             j953('TextValue('+val+') is ' + typeof val + ', must be a string');         }                   this.value        = val;         this.i3789    = val;               }        copy()     {         const copy = new j2033(this.value);          copy.i3789 = this.i3789;                  copy.n3359(this);          return copy;     }        equals(text)     {         return text             && this.value == text.value;     }        async eval(parse)     {         return this.copy();     }        c3712()     {         this.value == this.i3789;     }        isValid()     {         return this.value !== null;     }        n2119()     {         return encodeURIComponent(this.value);     }        toString()     {         return this.value;     }        z3705()     {         const lines = this.value.split('\n');          let str = '';          for (let i = 0; i < Math.min(lines.length, 10); i++)         {             if (i > 0)                 str += '\n';              str += lines[i];         }          if (lines.length > 10)             str += '\n. . .';                  return str;     }        h3706()     {         return '\''               + this.value.replaceAll('\n', '↵')              + '\'';     }        o3358()     {         return j2033.NaN.copy();     }        static NaN = Object.freeze(new j2033()); }    function s2865(str) {     const text = new j2033(decodeURIComponent(str));      return [text, 1]; }


class s2010 extends i2050 {     space;     c1;     c2;     c3;        constructor(space = d2022.NaN,                  c1    = d2022.NaN,                  c2    = d2022.NaN,                  c3    = d2022.NaN)     {         super(x1168);          this.space  = space.copy();         this.c1     = c1   .copy();         this.c2     = c2   .copy();         this.c3     = c3   .copy();          this.valid  = true;     }        static create(space, c1, c2, c3)     {         l952(typeof space == 'number', 'ColorValue.create() space must be a number');         l952(typeof c1    == 'number', 'ColorValue.create() c1 must be a number');         l952(typeof c2    == 'number', 'ColorValue.create() c2 must be a number');         l952(typeof c3    == 'number', 'ColorValue.create() c3 must be a number');          return new s2010(             new d2022(space, 0),             new d2022(c1,    0),             new d2022(c2,    0),             new d2022(c3,    0));     }        static k3773(rgb)     {         return s2010.create(1, rgb[0], rgb[1], rgb[2]);     }        static n2806(e3199, spaceIndex = -1)     {         if (spaceIndex < 0)             spaceIndex = x4125 (e3199[0]);          const space  = p133(spaceIndex);         const factor = e4192(space);          return s2010.create(             spaceIndex,             e3199[1] * factor[0],             e3199[2] * factor[1],             e3199[3] * factor[2]);     }        copy()     {         const copy = new s2010(             this.space.copy(),              this.c1   .copy(),              this.c2   .copy(),              this.c3   .copy());          copy.n3359(this);          return copy;     }        c3712()     {         return this.space.c3712()             && this.c1   .c3712()             && this.c2   .c3712()             && this.c3   .c3712();     }        isValid()     {         return this.space.isValid()             && this.c1   .isValid()             && this.c2   .isValid()             && this.c3   .isValid();     }        equals(col)     {         return col             && this.space.equals(col.space)             && this.c1   .equals(col.c1   )             && this.c2   .equals(col.c2   )             && this.c3   .equals(col.c3   );     }        async eval(parse)     {         return this.copy();     }        o3241()     {         if (!this.isValid())             return q3814;          const space = this.space.copy();          space.value = Math.round(Math.min(Math.max(0, space.value), f131.length-1));          return l147(             space,             this.c1,             this.c2,             this.c3);     }        e3242()     {         return g4195(this.o3241());     }        h99()     {         return p100(this.e3242());     }        toRgbObject(limit = false)     {         const rgb = g4195(this.o3241());          if (limit && h73(rgb))             return {r: 0.5, g: 0.5, b: 0.5};                  return limit             ? { r: Math.min(Math.max(0, rgb[0]), 1),                 g: Math.min(Math.max(0, rgb[1]), 1),                 b: Math.min(Math.max(0, rgb[2]), 1) }             : { r: rgb[0],                 g: rgb[1],                 b: rgb[2] };     }        toString()     {         return      this.space.toString()             + ' ' + this.c1   .toString()             + ' ' + this.c2   .toString()             + ' ' + this.c3   .toString();     }        z3705()     {         return      this.space.z3705()             + ' ' + this.c1   .z3705()             + ' ' + this.c2   .z3705()             + ' ' + this.c3   .z3705();     }        h3706()     {         return      this.space.h3706()             + ' ' + this.c1   .h3706()             + ' ' + this.c2   .h3706()             + ' ' + this.c3   .h3706();     }        z3705()     {         if (!this.isValid())             return u966;          const rgb = this.e3242();          return '#' + f151(rgb);     }        toRgbString()     {         if (!this.isValid())             return u966;          const rgb = this.e3242();          return      rgb[0].toString()             + ' ' + rgb[1].toString()             + ' ' + rgb[2].toString();     }        o3358()     {         return s2010.NaN.copy();     }        static NaN = Object.freeze(new s2010(         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN)); }    function s2866(str, i = -1) {     if (i < 0)     {         str = str.split(' ');         i   = 0;     }               const r3769 = i;      const space = g2850(str[i]); i += space[1];     const c1    = g2850(str[i]); i += c1   [1];     const c2    = g2850(str[i]); i += c2   [1];     const c3    = g2850(str[i]); i += c3   [1];       return [         new s2010(space[0], c1[0], c2[0], c3[0]),          i - r3769 ]; }


class v2013 extends i2050 {     color;     opacity;     blend;        constructor(color   = s2010.NaN,                  opacity = new d2022(100),                 blend   = new d2022(0))     {         super(k1178);          this.color   = color  .copy();         this.opacity = opacity.copy();         this.blend   = blend  .copy();          this.valid   = true;     }            static create(r, g, b, opacity, blend = 0)     {         l952(             typeof opacity == 'number',             'opacity must be a number');          return new v2013(             s2010.create(1, r, g, b),             new d2022(opacity),             new d2022(blend));     }        static k3773(rgb, opacity, blend = 0)     {         l952(             typeof opacity == 'number',             'opacity must be a number');          return new v2013(             s2010.k3773(rgb),             new d2022(opacity),             new d2022(blend));     }        copy()     {         const copy = new v2013(             this.color  .copy(),             this.opacity.copy(),             this.blend  .copy());          copy.n3359(this);          return copy;     }        equals(fill)     {         return this.color  .equals(fill.color  )             && this.opacity.equals(fill.opacity)             && this.blend  .equals(fill.blend  );     }        async eval(parse)     {         return this.copy();     }        h99()     {         return [             ...this.color.e3242(),             this.opacity.value / 100 ];     }                               toString()     {         const rgb = t4142(this.color.e3242());          return        new d2022(rgb[0]).toString()               + ' ' + new d2022(rgb[1]).toString()               + ' ' + new d2022(rgb[2]).toString()               + ' ' + this.opacity           .toString()               + ' ' + this.blend             .toString();     }        z3705()     {         const rgb = t4142(this.color.e3242());          return        new d2022(rgb[0]).z3705()               + ' ' + new d2022(rgb[1]).z3705()               + ' ' + new d2022(rgb[2]).z3705()               + ' ' + this.opacity           .z3705()               + ' ' + this.blend             .z3705();     }        h3706()     {         const rgb = t4142(this.color.e3242());          return        new d2022(rgb[0]).h3706()               + ' ' + new d2022(rgb[1]).h3706()               + ' ' + new d2022(rgb[2]).h3706()               + ' ' + this.opacity           .h3706()               + ' ' + this.blend             .h3706();     }        c3712()     {         return this.color  .c3712()             && this.opacity.c3712()             && this.blend  .c3712();     }        isValid()     {         return this.color  .isValid()             && this.opacity.isValid()             && this.blend  .isValid();     }        o3358()     {         return v2013.NaN.copy();     }        static NaN = Object.freeze(new v2013(         s2010 .NaN,         d2022.NaN,         d2022.NaN));        static default = Object.freeze(v2013.create(217, 217, 217, 100)); }    function k3677(str, i = -1) {     if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const r3769 = i;      const r  = g2850(str[i]); i += r [1];     const g  = g2850(str[i]); i += g [1];     const b  = g2850(str[i]); i += b [1];     const a  = g2850(str[i]); i += a [1];     const bl = g2850(str[i]); i += bl[1];      const color = new s2010(new d2022(1), r[0], g[0], b[0]);           return [         new v2013(color, a[0], bl[0]),         i - r3769 ]; }               


class w2009 extends i2050 {     fill;     position;        constructor(fill     = v2013.NaN,                  position = new d2022(1))     {         if (fill.type != k1178)             j953('fill.type is ' + fill.type + ', must be FILL_VALUE');           super(r1184);          this.fill     = fill    .copy();         this.position = position.copy();          this.valid    = true;     }            copy()     {         const copy = new w2009(             this.fill    .copy(),             this.position.copy());          copy.n3359(this);          return copy;     }        isValid()     {         return this.fill    .isValid()             && this.position.isValid();     }        equals(stop)     {         return stop             && this.fill    .equals(stop.fill    )             && this.position.equals(stop.position);     }        async eval(parse)     {         return this;     }        x3633()     {         return this.copy();     }        toString()     {         return      this.fill    .toString()             + ' ' + this.position.toString();     }        z3705()     {         return      this.fill    .z3705()             + ' ' + this.position.z3705();     }        h3706()     {         return      this.fill    .h3706()             + ' ' + this.position.h3706();     }        o3358()     {         return w2009.NaN.copy();     }        static NaN = Object.freeze(new w2009(         v2013  .NaN,         d2022.NaN)); }    function l2867(str, i = -1) {     if (   i <  0 && str    == g964         || i >= 0 && str[i] == g964)         return [w2009.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const r3769 = i;      const fill     = k3677  (str, i); i += fill    [1];     const position = g2850(str[i]); i += position[1];       return [         new w2009(fill[0], position[0]),         i - r3769 ]; }


class a2015 extends i2050 {     stops;     x3687;     position;     x;     y;     size;     angle;     aspect;     skew;     blend;      diagAspect;        constructor(stops      = new x2021(),                 x3687   = new d2022(0),                 position   = new d2022(0),                 x          = new d2022(0),                 y          = new d2022(0),                 size       = new d2022(0),                 angle      = new d2022(0),                 aspect     = new d2022(0),                 diagAspect = false,                 skew       = new d2022(0),                 blend      = new d2022(0))     {         super(i1187);          this.stops      = stops   .copy();         this.x3687   = x3687.copy();         this.position   = position.copy();         this.x          = x       .copy();         this.y          = y       .copy();         this.size       = size    .copy();         this.angle      = angle   .copy();         this.aspect     = aspect  .copy();         this.diagAspect = diagAspect;         this.skew       = skew    .copy();         this.blend      = blend   .copy();          this.valid      = true;     }            copy()     {         const copy = new a2015(             this.stops,             this.x3687,             this.position,             this.x,             this.y,             this.size,             this.angle,             this.aspect,             this.diagAspect,             this.skew,             this.blend);          copy.n3359(this);          return copy;     }        isValid()     {         return this.stops   .isValid()             && this.x3687.isValid()             && this.position.isValid()             && this.x       .isValid()             && this.y       .isValid()             && this.size    .isValid()             && this.angle   .isValid()             && this.aspect  .isValid()             && this.skew    .isValid()             && this.blend   .isValid();     }        equals(grad)     {         return grad             && this.stops   .equals(grad.stops   )             && this.x3687.equals(grad.x3687)             && this.position.equals(grad.position)             && this.x       .equals(grad.x       )             && this.y       .equals(grad.y       )             && this.size    .equals(grad.size    )             && this.angle   .equals(grad.angle   )             && this.aspect  .equals(grad.aspect  )             && this.diagAspect == grad.diagAspect             && this.skew    .equals(grad.skew    )             && this.blend   .equals(grad.blend   );     }        async eval(parse)     {         return this;     }        x3633()     {         return this.copy();     }        toString()     {         return      this.stops   .toString()             + ' ' + this.x3687.toString()             + ' ' + this.position.toString()             + ' ' + this.x       .toString()             + ' ' + this.y       .toString()             + ' ' + this.size    .toString()             + ' ' + this.angle   .toString()             + ' ' + this.aspect  .toString()             + ' ' + (this.diagAspect ? '1' : '0')             + ' ' + this.skew    .toString()             + ' ' + this.blend   .toString();     }        h99()     {         return this.stops.length > 0              ? this.stops[0].fill.h99()              : rgba_NaN;     }            z3705()     {         return      this.stops   .z3705()             + ' ' + this.x3687.z3705()             + ' ' + this.position.z3705()             + ' ' + this.x       .z3705()             + ' ' + this.y       .z3705()             + ' ' + this.size    .z3705()             + ' ' + this.angle   .z3705()             + ' ' + this.aspect  .z3705()             + ' ' + (this.diagAspect ? '1' : '0')             + ' ' + this.skew    .z3705()             + ' ' + this.blend   .z3705();     }        h3706()     {         return      this.stops   .h3706()             + ' ' + this.x3687.h3706()             + ' ' + this.position.h3706()             + ' ' + this.x       .h3706()             + ' ' + this.y       .h3706()             + ' ' + this.size    .h3706()             + ' ' + this.angle   .h3706()             + ' ' + this.aspect  .h3706()             + ' ' + (this.diagAspect ? '1' : '0')             + ' ' + this.skew    .h3706()             + ' ' + this.blend   .h3706();     }        o3358()     {         return a2015.NaN.copy();     }        static NaN = Object.freeze(new a2015(         x2021  .NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN,         false,         d2022.NaN,         d2022.NaN)); }    function c3676(str, i = -1) {     if (   i <  0 && str    == g964         || i >= 0 && str[i] == g964)         return [a2015.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const r3769 = i;      const stops      = u3482  (str, i); i += stops   [1];     const x3687   = g2850(str[i]); i += x3687[1];     const position   = g2850(str[i]); i += position[1];     const x          = g2850(str[i]); i += x       [1];     const y          = g2850(str[i]); i += y       [1];     const size       = g2850(str[i]); i += size    [1];     const angle      = g2850(str[i]); i += angle   [1];     const aspect     = g2850(str[i]); i += aspect  [1];     const diagAspect = parseInt(str[i]) == 1;    i ++;     const skew       = g2850(str[i]); i += skew    [1];     const blend      = g2850(str[i]); i += blend   [1];       return [         new a2015(             stops   [0],              x3687[0],              position[0],             x       [0],              y       [0],              size    [0],              angle   [0],              aspect  [0],              diagAspect,             skew    [0],              blend   [0]),         i - r3769 ]; }


class y2031 extends i2050 {     fills;     weight;     fit;     join;     miter;     cap;     dashes;        constructor(fills  = new x2021(),                  weight = new d2022(1),                 fit    = new d2022(0),                 join   = new d2022(0),                 miter  = new d2022(28.96, 2),                 cap    = new d2022(0),                 dashes = new j2033())     {         if (fills.type != y1056)             j953('fill.type is ' + fills.type + ', must be LIST_VALUE');           super(g1181);          this.fills  = fills .copy();         this.weight = weight.copy();         this.fit    = fit   .copy();         this.join   = join  .copy();         this.miter  = miter .copy();         this.cap    = cap   .copy();         this.dashes = dashes.copy();          this.valid  = true;     }            copy()     {         const copy = new y2031(             this.fills .copy(),             this.weight.copy(),             this.fit   .copy(),             this.join  .copy(),             this.miter .copy(),             this.cap   .copy(),             this.dashes.copy());          copy.n3359(this);          return copy;     }        c3712()     {         return this.fills .c3712()             && this.weight.c3712()             && this.fit   .c3712()             && this.join  .c3712()             && this.miter .c3712()             && this.cap   .c3712()             && this.dashes.c3712();     }        isValid()     {         return this.fills .isValid()             && this.weight.isValid()             && this.fit   .isValid()             && this.join  .isValid()             && this.miter .isValid()             && this.cap   .isValid()             && this.dashes.isValid();     }        equals(stroke)     {         return stroke             && this.fills .equals(stroke.fill  )             && this.weight.equals(stroke.weight)             && this.fit   .equals(stroke.fit   )             && this.join  .equals(stroke.join  )             && this.miter .equals(stroke.miter )             && this.cap   .equals(stroke.cap   )             && this.dashes.equals(stroke.dashes);     }        async eval(parse)     {         return this.copy();     }        x3633()     {         return this.copy();     }        toString()     {         return      this.fills .toString()             + ' ' + this.weight.toString()             + ' ' + this.fit   .toString()             + ' ' + this.join  .toString()             + ' ' + this.miter .toString()             + ' ' + this.cap   .toString()             + ' ' + this.dashes.toString();     }        z3705()     {         return      this.fills .z3705()             + ' ' + this.weight.z3705()             + ' ' + this.fit   .z3705()             + ' ' + this.join  .z3705()             + ' ' + this.miter .z3705()             + ' ' + this.cap   .z3705()             + ' ' + this.dashes.z3705();     }        h3706()     {         return      this.fills .h3706()             + ' ' + this.weight.h3706()             + ' ' + this.fit   .h3706()             + ' ' + this.join  .h3706()             + ' ' + this.miter .h3706()             + ' ' + this.cap   .h3706()             + ' ' + this.dashes.h3706();     }        o3358()     {         return y2031.NaN.copy();     }        static NaN = Object.freeze(new y2031(         new x2021(),         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN,         new j2033()));        static default = Object.freeze(new y2031(         new x2021(),         new d2022(1),         new d2022(0),         new d2022(0),         new d2022(28.96),         new d2022(0),         new j2033())); }    function y3832(str, i = -1) {     if (   i <  0 && str    == g964         || i >= 0 && str[i] == g964)         return [y2031.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const r3769 = i;      const fills  = u3482  (str, i); i += fills [1];     const weight = g2850(str[i]); i += weight[1];     const fit    = g2850(str[i]); i += fit   [1];     const join   = g2850(str[i]); i += join  [1];     const miter  = g2850(str[i]); i += miter [1];     const cap    = g2850(str[i]); i += cap   [1];     const dashes = s2865  (str[i]); i += dashes[1];      return [          new y2031(             fills [0],              weight[0],              fit   [0],              join  [0],              miter [0],              cap   [0],              dashes[0]),                  i - r3769 ]; } 


class g4272 extends i2050 {     top;     left;     right;     bottom;     visible;        constructor(top     = new d2022(0),                  left    = new d2022(0),                  right   = new d2022(0),                  bottom  = new d2022(0),                  visible = true)     {         super(p1190);          this.top     = top;         this.left    = left;         this.right   = right;         this.bottom  = bottom;         this.visible = visible;     }            copy()     {         const copy = new g4272(             this.top   .copy(),             this.left  .copy(),             this.right .copy(),             this.bottom.copy(),             this.visible);          copy.n3359(this);          return copy;     }        equals(sides)     {         return this.top   .equals(sides.tl)             && this.left  .equals(sides.tr)             && this.right .equals(sides.bl)             && this.bottom.equals(sides.br)             && this.visible === sides.visible;     }        async eval(parse)     {         return this;     }        toString()     {         return      this.top   .toString()             + ' ' + this.left  .toString()             + ' ' + this.right .toString()             + ' ' + this.bottom.toString();     }        z3705()     {         return      this.top   .z3705()             + ' ' + this.left  .z3705()             + ' ' + this.right .z3705()             + ' ' + this.bottom.z3705();     }        h3706()     {         return      this.top   .h3706()             + ' ' + this.left  .h3706()             + ' ' + this.right .h3706()             + ' ' + this.bottom.h3706();     }        isValid()     {         return this.top   .isValid()             && this.left  .isValid()             && this.right .isValid()             && this.bottom.isValid();     }        o3358()     {         return g4272.NaN.copy();     }        static NaN = Object.freeze(new g4272(         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN,         false)); }    function parseStrokeSidesValue(str, i = -1) {     if (   i <  0 && str    == g964         || i >= 0 && str[i] == g964)         return [g4272.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const r3769 = i;      const top    = g2850(str[i]); i += top   [1];     const left   = g2850(str[i]); i += left  [1];     const right  = g2850(str[i]); i += right [1];     const bottom = g2850(str[i]); i += bottom[1];       const sides = new g4272(         top   [0],         left  [0],         right [0],         bottom[0]);       return [sides, i - r3769]; } 


class h2026 extends i2050 {     tl;     tr;     bl;     br;     visible;        constructor(tl = new d2022(0),                  tr = new d2022(0),                  bl = new d2022(0),                  br = new d2022(0),                  visible = true)     {         super(p1193);          this.tl      = tl;         this.tr      = tr;         this.bl      = bl;         this.br      = br;         this.visible = visible;     }            copy()     {         const copy = new h2026(             this.tl.copy(),             this.tr.copy(),             this.bl.copy(),             this.br.copy(),             this.visible);          copy.n3359(this);          return copy;     }        equals(corners)     {         return this.tl.equals(corners.tl)             && this.tr.equals(corners.tr)             && this.bl.equals(corners.bl)             && this.br.equals(corners.br)             && this.visible === corners.visible;     }        async eval(parse)     {         return this;     }        toString()     {         return      this.tl.toString()             + ' ' + this.tr.toString()             + ' ' + this.bl.toString()             + ' ' + this.br.toString();     }        z3705()     {         return      this.tl.z3705()             + ' ' + this.tr.z3705()             + ' ' + this.bl.z3705()             + ' ' + this.br.z3705();     }        h3706()     {         return      this.tl.h3706()             + ' ' + this.tr.h3706()             + ' ' + this.bl.h3706()             + ' ' + this.br.h3706();     }        isValid()     {         return this.tl.isValid()             && this.tr.isValid()             && this.bl.isValid()             && this.br.isValid();     }        o3358()     {         return h2026.NaN.copy();     }        static NaN = Object.freeze(new h2026(         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN,         false)); }    function d3838(str, i = -1) {     if (   i <  0 && str    == g964         || i >= 0 && str[i] == g964)         return [h2026.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const r3769 = i;      const tl = g2850(str[i]); i += tl[1];     const tr = g2850(str[i]); i += tr[1];     const bl = g2850(str[i]); i += bl[1];     const br = g2850(str[i]); i += br[1];       const corners = new h2026(         tl[0],         tr[0],         bl[0],         br[0]);       return [corners, i - r3769]; } 


class m2011 extends i2050 {     x;     y;     blur;     spread;     fill;     blend;     behind;     visible;        constructor(x       = new d2022(0),                  y       = new d2022(0),                  blur    = new d2022(0),                  spread  = new d2022(0),                  fill    = v2013.NaN,                 blend   = new d2022(0),                 behind  = new d2022(0),                 visible = true)     {         super(g1196);          this.x       = x;         this.y       = y;         this.blur    = blur;         this.spread  = spread;         this.fill    = fill;         this.blend   = blend;         this.behind  = behind;         this.visible = visible;                  l952(fill.type == k1178, 'fill.type must be FILL_VALUE');     }                                             copy()     {         const copy = new m2011(             this.x     .copy(),             this.y     .copy(),             this.blur  .copy(),             this.spread.copy(),             this.fill  .copy(),             this.blend .copy(),             this.behind.copy(),             this.visible);          copy.n3359(this);          return copy;     }        equals(shadow)     {         return this.x     .equals(shadow.x     )             && this.y     .equals(shadow.y     )             && this.blur  .equals(shadow.blur  )             && this.spread.equals(shadow.spread)             && this.fill  .equals(shadow.fill  )             && this.blend .equals(shadow.blend )             && this.behind.equals(shadow.behind)             && this.visible === shadow.visible;     }        async eval(parse)     {         return this;     }        toString()     {         return      this.x     .toString()             + ' ' + this.y     .toString()             + ' ' + this.blur  .toString()             + ' ' + this.spread.toString()             + ' ' + this.fill  .toString()             + ' ' + this.blend .toString()             + ' ' + this.behind.toString();     }        z3705()     {         return      this.x     .z3705()             + ' ' + this.y     .z3705()             + ' ' + this.blur  .z3705()             + ' ' + this.spread.z3705()             + ' ' + this.fill  .z3705()             + ' ' + this.blend .z3705()             + ' ' + this.behind.z3705();     }        h3706()     {         return      this.x     .h3706()             + ' ' + this.y     .h3706()             + ' ' + this.blur  .h3706()             + ' ' + this.spread.h3706()             + ' ' + this.fill  .h3706()             + ' ' + this.blend .h3706()             + ' ' + this.behind.h3706();     }        isValid()     {         return this.x     .isValid()             && this.y     .isValid()             && this.blur  .isValid()             && this.spread.isValid()             && this.fill  .isValid()             && this.blend .isValid()             && this.behind.isValid();     }        o3358()     {         return m2011.NaN.copy();     }        static NaN = Object.freeze(new m2011(         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN,         v2013 .NaN,         d2022.NaN,         d2022.NaN,         false));        }    function j3833(str, i = -1) {     if (   i <  0 && str    == g964         || i >= 0 && str[i] == g964)         return [m2011.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const r3769 = i;      const x      = g2850(str[i]); i += x     [1];     const y      = g2850(str[i]); i += y     [1];     const blur   = g2850(str[i]); i += blur  [1];     const spread = g2850(str[i]); i += spread[1];     const fill   = k3677  (str, i); i += fill  [1];     const blend  = g2850(str[i]); i += blend [1];     const behind = g2850(str[i]); i += behind[1];       const shadow = new m2011(         x     [0],         y     [0],         blur  [0],         spread[0],         fill  [0],         blend [0],         behind[0]);       return [shadow, i - r3769]; } 


class c2016 extends i2050 {     x;     y;     blur;     spread;     fill;     blend;     visible;        constructor(x       = new d2022(0),                  y       = new d2022(0),                  blur    = new d2022(0),                  spread  = new d2022(0),                  fill    = v2013.NaN,                 blend   = new d2022(0),                 visible = true)     {         super(w1199);          this.x       = x;         this.y       = y;         this.blur    = blur;         this.spread  = spread;         this.fill    = fill;         this.blend   = blend;         this.visible = visible;     }                                             copy()     {         const copy = new c2016(             this.x     .copy(),             this.y     .copy(),             this.blur  .copy(),             this.spread.copy(),             this.fill  .copy(),             this.blend .copy(),             this.visible);          copy.n3359(this);          return copy;     }        equals(shadow)     {         return this.x     .equals(shadow.x     )             && this.y     .equals(shadow.y     )             && this.blur  .equals(shadow.blur  )             && this.spread.equals(shadow.spread)             && this.fill  .equals(shadow.fill  )             && this.blend .equals(shadow.blend )             && this.visible === shadow.visible;     }        async eval(parse)     {         return this;     }                                                                toString()     {         return      this.x     .toString()             + ' ' + this.y     .toString()             + ' ' + this.blur  .toString()             + ' ' + this.spread.toString()             + ' ' + this.fill  .toString()             + ' ' + this.blend .toString();     }        z3705()     {         return      this.x     .z3705()             + ' ' + this.y     .z3705()             + ' ' + this.blur  .z3705()             + ' ' + this.spread.z3705()             + ' ' + this.fill  .z3705()             + ' ' + this.blend .z3705();     }        h3706()     {         return      this.x     .h3706()             + ' ' + this.y     .h3706()             + ' ' + this.blur  .h3706()             + ' ' + this.spread.h3706()             + ' ' + this.fill  .h3706()             + ' ' + this.blend .h3706();     }        isValid()     {         return this.x     .isValid()             && this.y     .isValid()             && this.blur  .isValid()             && this.spread.isValid()             && this.fill  .isValid()             && this.blend .isValid();     }        o3358()     {         return c2016.NaN.copy();     }        static NaN = Object.freeze(new c2016(         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN,         v2013 .NaN,         d2022.NaN,         false));         }    function s3834(str, i = -1) {     if (   i <  0 && str    == g964         || i >= 0 && str[i] == g964)         return [c2016.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const r3769 = i;      const x      = g2850(str[i]); i += x     [1];     const y      = g2850(str[i]); i += y     [1];     const blur   = g2850(str[i]); i += blur  [1];     const spread = g2850(str[i]); i += spread[1];     const fill   = k3677  (str, i); i += fill  [1];     const blend  = g2850(str[i]); i += blend [1];       const shadow = new c2016(         x     [0],         y     [0],         blur  [0],         spread[0],         fill  [0],         blend [0]);       return [shadow, i - r3769]; } 


class j2018 extends i2050 {     radius;     visible;        constructor(radius  = new d2022(0),                  visible = true)     {         super(c1202);          this.radius  = radius;         this.visible = visible;     }                                             copy()     {         const copy = new j2018(             this.radius.copy(),             this.visible);          copy.n3359(this);          return copy;     }        equals(blur)     {         return this.radius.equals(blur.radius)             && this.visible === blur.visible;     }        async eval(parse)     {         return this;     }                                                                toString()     {         return this.radius.toString();     }        z3705()     {         return this.radius.z3705();     }        h3706()     {         return this.radius.h3706();     }        isValid()     {         return this.radius.isValid();     }        o3358()     {         return j2018.NaN.copy();     }        static NaN = Object.freeze(new j2018(         d2022.NaN,         false));         }    function r3835(str, i = -1) {     if (   i <  0 && str    == g964         || i >= 0 && str[i] == g964)         return [j2018.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const r3769 = i;      const radius = g2850(str[i]); i += radius[1];       const shadow = new j2018(         radius[0]);       return [shadow, i - r3769]; } 


class p2008 extends i2050 {     radius;     visible;        constructor(radius  = new d2022(0),                 visible = true)     {         super(t1205);          this.radius  = radius;         this.visible = visible;     }                                             copy()     {         const copy = new p2008(             this.radius.copy(),             this.visible);          copy.n3359(this);          return copy;     }        equals(blur)     {         return this.radius.equals(blur.radius)             && this.visible === blur.visible;     }        async eval(parse)     {         return this;     }                                                                toString()     {         return this.radius.toString();     }        z3705()     {         return this.radius.z3705();     }        h3706()     {         return this.radius.h3706();     }        isValid()     {         return this.radius.isValid();     }        o3358()     {         return p2008.NaN.copy();     }        static NaN = Object.freeze(new p2008(         d2022.NaN,         false));         }    function o3707(str, i = -1) {     if (   i <  0 && str    == g964         || i >= 0 && str[i] == g964)         return [p2008.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const r3769 = i;      const radius = g2850(str[i]); i += radius[1];       const shadow = new p2008(         radius[0]);       return [shadow, i - r3769]; } 


class f2017 extends i2050 {     opacity;     blend;        constructor(opacity, blend)     {         super(v1211);          this.opacity = opacity.copy();         this.blend   = blend  .copy();     }            copy()     {         const copy = new f2017(this.opacity, this.blend);          copy.n3359(this);          return copy;     }        equals(layer)     {         return this.opacity.equals(layer.opacity)             && this.blend  .equals(layer.blend  );     }        async eval(parse)     {         return this;     }        toString()     {         return      this.opacity.toString()             + ' ' + this.blend  .toString();     }        z3705()     {         return      this.opacity.z3705()             + ' ' + this.blend  .z3705();     }        h3706()     {         return      this.opacity.h3706()             + ' ' + this.blend  .h3706();     }        c3712()     {         return this.opacity.c3712()             && this.blend  .c3712();     }        isValid()     {         return this.opacity && this.opacity.isValid()             && this.blend   && this.blend  .isValid();     }        o3358()     {         return f2017.NaN.copy();     }        static NaN = Object.freeze(new f2017(d2022.NaN, d2022.NaN)); }    function k3708(str, i = -1) {     if (   i <  0 && str    == g964         || i >= 0 && str[i] == g964)         return [f2017.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const r3769 = i;      const opacity = g2850(str[i]); i += opacity[1];     const blend   = g2850(str[i]); i += blend  [1];       const layer = new f2017(         opacity[0],         blend  [0]);               return [layer, i - r3769]; } 


class g2019 extends i2050 {     visible;     maskType;        constructor(maskType, visible = true)     {         super(c1208);          this.visible  = visible;         this.maskType = maskType.copy();     }            copy()     {         const copy = new g2019(this.maskType, this.visible);          copy.n3359(this);          return copy;     }        equals(mask)     {         return this.visible === mask.visible             && this.maskType.equals(mask.maskType);     }        async eval(parse)     {         return this;     }        toString()     {         return 'mask';     }        z3705()     {         return 'mask';     }        h3706()     {         return 'mask';     }        isValid()     {         return this.maskType.isValid();     }        o3358()     {         return g2019.NaN.copy();     }        static NaN = Object.freeze(new g2019(d2022.NaN, false)); }    function t3709(str) {     const mask =          str == g964         ? g2019.NaN         : new g2019(new d2022(parseInt(str)), true);      return [mask, 1]; } 


   class k2029 extends i2050 {     nodeId;      props = null;        constructor(type, nodeId)     {         super(type);          this.nodeId = nodeId;           this.objects = [];     }        n3359(base)     {         super.n3359(base);                  this.nodeId = base.nodeId;          if (base.objects) this.objects = base.objects.map(o => o.copy());          if (base.props  ) this.props   = base.props.copy();     }        c3712()     {         return !this.props             ||  this.props.c3712();     }        isValid()     {         return !this.props             ||  this.props.isValid();     } }    function d3710(str, i, a111) {     const props = u3482(str, i); i += props[1];      a111.props = props[0];      return i; }


class s2025 extends k2029 {     x;     y;     width;     height;     round;        constructor(nodeId,                 x      = new d2022(0),                  y      = new d2022(0),                  width  = new d2022(0),                  height = new d2022(0),                  round  = new d2022(0))     {         super(w1218, nodeId);          this.x      = x;         this.y      = y;         this.width  = width;         this.height = height;         this.round  = round;     }        static fromObject(a111)     {         return new s2025(             a111.nodeId,             new d2022(a111.x     ),              new d2022(a111.y     ),              new d2022(a111.width ),              new d2022(a111.height),              new d2022(a111.round ));     }        copy()     {         const copy = new s2025(             this.nodeId,             this.x     .copy(),              this.y     .copy(),              this.width .copy(),              this.height.copy(),              this.round .copy());          copy.n3359(this);          return copy;     }        equals(rect)     {         return rect             && this.x     .equals(rect.x     )             && this.y     .equals(rect.y     )             && this.width .equals(rect.width )             && this.height.equals(rect.height)             && this.round .equals(rect.round );     }        async eval(parse)     {         return this.copy();     }        toString()     {         return      this.x     .toString()             + ' ' + this.y     .toString()             + ' ' + this.width .toString()             + ' ' + this.height.toString()             + ' ' + this.round .toString()             + ' ' + super.toString();     }        z3705()     {         return 'rectangle';                                                                      }        h3706()     {         return      this.x     .h3706()             + ' ' + this.y     .h3706()             + ' ' + this.width .h3706()             + ' ' + this.height.h3706()             + ' ' + this.round .h3706();     }        x3633()     {         return this.copy();     }        c3712()     {         return super.c3712()             && this.x     .c3712()             && this.y     .c3712()             && this.width .c3712()             && this.height.c3712()             && this.round .c3712();     }        isValid()     {         return super.isValid()             && this.x     .isValid()             && this.y     .isValid()             && this.width .isValid()             && this.height.isValid()             && this.round .isValid();     }            static NaN = new s2025(         '',         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN); }    function p3711(str, i = -1) {     if (   i <  0 && str    == g964         || i >= 0 && str[i] == g964)         return [s2025.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const r3769 = i;      const x      = g2850(str[i]); i += x     [1];     const y      = g2850(str[i]); i += y     [1];     const width  = g2850(str[i]); i += width [1];     const height = g2850(str[i]); i += height[1];     const round  = g2850(str[i]); i += round [1];       const rect = new s2025(         '',          x     [0],         y     [0],         width [0],         height[0],         round [0]);       i = d3710(str, i, rect);           return [rect, i - r3769]; } 


class s2020 extends k2029 {     x;     y;     width;        constructor(nodeId,                 x      = new d2022(0),                  y      = new d2022(0),                  width  = new d2022(0))     {         super(h1221, nodeId);          this.x     = x;         this.y     = y;         this.width = width;     }        static fromObject(a111)     {         return new s2020(             a111.nodeId,             new d2022(a111.x    ),              new d2022(a111.y    ),              new d2022(a111.width));     }        copy()     {         const copy = new s2020(             this.nodeId,             this.x    .copy(),              this.y    .copy(),              this.width.copy());          copy.n3359(this);          return copy;     }        equals(line)     {         return line             && this.x    .equals(line.x    )             && this.y    .equals(line.y    )             && this.width.equals(line.width);     }        async eval(parse)     {         return this.copy();     }        c3712()     {         return super.c3712()             && this.x     .c3712()             && this.y     .c3712()             && this.width .c3712();     }        isValid()     {         return super.isValid()             && this.x    .isValid()             && this.y    .isValid()             && this.width.isValid();     }        x3633()     {         return this.copy();     }        toString()     {         return      this.x    .toString()             + ' ' + this.y    .toString()             + ' ' + this.width.toString()             + ' ' + super.toString();     }        z3705()     {         return      this.x    .z3705()             + ' ' + this.y    .z3705()             + ' ' + this.width.z3705();     }        h3706()     {         return      this.x    .h3706()             + ' ' + this.y    .h3706()             + ' ' + this.width.h3706();     }        static NaN = new s2020(         '',         d2022.NaN,         d2022.NaN,         d2022.NaN); }    function w3822(str, i = -1) {     if (   i <  0 && str    == g964         || i >= 0 && str[i] == g964)         return [s2020.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const r3769 = i;      const x     = g2850(str[i]); i += x    [1];     const y     = g2850(str[i]); i += y    [1];     const width = g2850(str[i]); i += width[1];       const line = new s2020(         '',          x    [0],         y    [0],         width[0]);       i = d3710(str, i, line);           return [line, i - r3769]; } 


class i2012 extends k2029 {     position;     x;     y;     width;     height;     round;     start;     sweep;     inner;        constructor(nodeId,                 position = new d2022(0),                 x        = new d2022(0),                  y        = new d2022(0),                  width    = new d2022(0),                  height   = new d2022(0),                  round    = new d2022(0),                  start    = new d2022(0),                 sweep    = new d2022(0),                 inner    = new d2022(0))     {         super(m1224, nodeId);          this.position = position;         this.x        = x;         this.y        = y;         this.width    = width;         this.height   = height;         this.round    = round;         this.start    = start;         this.sweep    = sweep;         this.inner    = inner;     }        static fromObject(a111)     {         return new i2012(             a111.nodeId,             new d2022(a111.position),              new d2022(a111.x       ),              new d2022(a111.y       ),              new d2022(a111.width   ),              new d2022(a111.height  ),              new d2022(a111.round   ),             new d2022(a111.start   ),             new d2022(a111.sweep   ),             new d2022(a111.inner   ));     }        copy()     {         const copy = new i2012(             this.nodeId,             this.position.copy(),              this.x       .copy(),              this.y       .copy(),              this.width   .copy(),              this.height  .copy(),              this.round   .copy(),              this.start   .copy(),             this.sweep   .copy(),             this.inner   .copy());          copy.n3359(this);          return copy;     }        equals(ellipse)     {         return ellipse             && this.position.equals(ellipse.position)             && this.x       .equals(ellipse.x       )             && this.y       .equals(ellipse.y       )             && this.width   .equals(ellipse.width   )             && this.height  .equals(ellipse.height  )             && this.round   .equals(ellipse.round   )             && this.start   .equals(ellipse.start   )             && this.sweep   .equals(ellipse.sweep   )             && this.inner   .equals(ellipse.inner   );     }        async eval(parse)     {         return this.copy();     }                    c3712()     {         return super.c3712()             && this.position.c3712()             && this.x       .c3712()             && this.y       .c3712()             && this.width   .c3712()             && this.height  .c3712()             && this.round   .c3712()             && this.start   .c3712()             && this.sweep   .c3712()             && this.inner   .c3712();     }        isValid()     {         return super.isValid()             && this.position.isValid()             && this.x       .isValid()             && this.y       .isValid()             && this.width   .isValid()             && this.height  .isValid()             && this.round   .isValid()             && this.start   .isValid()             && this.sweep   .isValid()             && this.inner   .isValid();     }        x3633()     {         return this.copy();     }        toString()     {         return      this.position.toString()             + ' ' + this.x       .toString()             + ' ' + this.y       .toString()             + ' ' + this.width   .toString()             + ' ' + this.height  .toString()             + ' ' + this.round   .toString()             + ' ' + this.start   .toString()             + ' ' + this.sweep   .toString()             + ' ' + this.inner   .toString()             + ' ' + super.toString();     }        z3705()     {         return 'ellipse';                                                                                                                          }        h3706()     {         return      this.position.h3706()             + ' ' + this.x       .h3706()             + ' ' + this.y       .h3706()             + ' ' + this.width   .h3706()             + ' ' + this.height  .h3706()             + ' ' + this.round   .h3706()             + ' ' + this.start   .h3706()             + ' ' + this.sweep   .h3706()             + ' ' + this.inner   .h3706();     }        static NaN = new i2012(         '',         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN); }    function k3823(str, i = -1) {     if (   i <  0 && str    == g964         || i >= 0 && str[i] == g964)         return [i2012.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const r3769 = i;      const pos    = g2850(str[i]); i += pos   [1];     const x      = g2850(str[i]); i += x     [1];     const y      = g2850(str[i]); i += y     [1];     const width  = g2850(str[i]); i += width [1];     const height = g2850(str[i]); i += height[1];     const round  = g2850(str[i]); i += round [1];     const start  = g2850(str[i]); i += start [1];     const sweep  = g2850(str[i]); i += sweep [1];     const inner  = g2850(str[i]); i += inner [1];       const ellipse = new i2012(         '',          pos   [0],         x     [0],         y     [0],         width [0],         height[0],         round [0],         start [0],         sweep [0],         inner [0]);       i = d3710(str, i, ellipse);           return [ellipse, i - r3769]; } 


class f2034 extends k2029 {     x;     y;     width;     height;     round;     bias;        constructor(nodeId,                 x      = new d2022(0),                  y      = new d2022(0),                  width  = new d2022(0),                  height = new d2022(0),                  round  = new d2022(0),                 bias   = new d2022(0))     {         super(r1227, nodeId);          this.x      = x;         this.y      = y;         this.width  = width;         this.height = height;         this.round  = round;         this.bias   = bias;     }        static fromObject(a111)     {         return new f2034(             a111.nodeId,             new d2022(a111.x     ),              new d2022(a111.y     ),              new d2022(a111.width ),              new d2022(a111.height),              new d2022(a111.round ),             new d2022(a111.bias  ));     }        copy()     {         const copy = new f2034(             this.nodeId,             this.x     .copy(),              this.y     .copy(),              this.width .copy(),              this.height.copy(),              this.round .copy(),             this.bias  .copy());          copy.n3359(this);          return copy;     }        equals(rect)     {         return rect             && this.x     .equals(rect.x     )             && this.y     .equals(rect.y     )             && this.width .equals(rect.width )             && this.height.equals(rect.height)             && this.round .equals(rect.round )             && this.bias  .equals(rect.bias  );     }        async eval(parse)     {         return this.copy();     }        toString()     {         return      this.x     .toString()             + ' ' + this.y     .toString()             + ' ' + this.width .toString()             + ' ' + this.height.toString()             + ' ' + this.round .toString()             + ' ' + this.bias  .toString()             + ' ' + super.toString();     }        z3705()     {         return 'trapeze';                                                                                   }        h3706()     {         return      this.x     .h3706()             + ' ' + this.y     .h3706()             + ' ' + this.width .h3706()             + ' ' + this.height.h3706()             + ' ' + this.round .h3706()             + ' ' + this.bias  .h3706();     }        x3633()     {         return this.copy();     }        c3712()     {         return super.c3712()             && this.x     .c3712()             && this.y     .c3712()             && this.width .c3712()             && this.height.c3712()             && this.round .c3712()             && this.bias  .c3712();     }            isValid()     {         return super.isValid()             && this.x     .isValid()             && this.y     .isValid()             && this.width .isValid()             && this.height.isValid()             && this.round .isValid()             && this.bias  .isValid();     }            static NaN = new f2034(         '',         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN); }    function c3824(str, i = -1) {     if (   i <  0 && str    == g964         || i >= 0 && str[i] == g964)         return [f2034.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const r3769 = i;      const x      = g2850(str[i]); i += x     [1];     const y      = g2850(str[i]); i += y     [1];     const width  = g2850(str[i]); i += width [1];     const height = g2850(str[i]); i += height[1];     const round  = g2850(str[i]); i += round [1];     const bias   = g2850(str[i]); i += bias  [1];       const rect = new f2034(         '',          x     [0],         y     [0],         width [0],         height[0],         round [0],         bias  [0]);       i = d3710(str, i, rect);           return [rect, i - r3769]; } 


class t2024 extends k2029 {     position;     x;     y;     width;     height;     round;     corners;        constructor(nodeId,                 position = new d2022(0),                 x        = new d2022(0),                  y        = new d2022(0),                  width    = new d2022(0),                  height   = new d2022(0),                  round    = new d2022(0),                  corners  = new d2022(0))     {         super(d1236, nodeId);          this.position = position;         this.x        = x;         this.y        = y;         this.width    = width;         this.height   = height;         this.round    = round;         this.corners  = corners;     }        static fromObject(a111)     {         return new t2024(             a111.nodeId,             new d2022(a111.position),              new d2022(a111.x       ),              new d2022(a111.y       ),              new d2022(a111.width   ),              new d2022(a111.height  ),              new d2022(a111.round   ),             new d2022(a111.corners ));     }        copy()     {         const copy = new t2024(             this.nodeId,             this.position.copy(),              this.x       .copy(),              this.y       .copy(),              this.width   .copy(),              this.height  .copy(),              this.round   .copy(),              this.corners .copy());              copy.n3359(this);          return copy;     }        equals(poly)     {         return poly             && this.position.equals(poly.position)             && this.x       .equals(poly.x       )             && this.y       .equals(poly.y       )             && this.width   .equals(poly.width   )             && this.height  .equals(poly.height  )             && this.round   .equals(poly.round   )             && this.corners .equals(poly.corners );     }        async eval(parse)     {         return this.copy();     }        c3712()     {         return super.c3712()             && this.position.c3712()             && this.x       .c3712()             && this.y       .c3712()             && this.width   .c3712()             && this.height  .c3712()             && this.round   .c3712()             && this.corners .c3712();     }        isValid()     {         return super.isValid()             && this.position.isValid()             && this.x       .isValid()             && this.y       .isValid()             && this.width   .isValid()             && this.height  .isValid()             && this.round   .isValid()             && this.corners .isValid();     }        x3633()     {         return this.copy();     }        toString()     {         return      this.position.toString()             + ' ' + this.x       .toString()             + ' ' + this.y       .toString()             + ' ' + this.width   .toString()             + ' ' + this.height  .toString()             + ' ' + this.round   .toString()             + ' ' + this.corners .toString()             + ' ' + super.toString();     }        z3705()     {         return      this.position.z3705()             + ' ' + this.x       .z3705()             + ' ' + this.y       .z3705()             + ' ' + this.width   .z3705()             + ' ' + this.height  .z3705()             + ' ' + this.round   .z3705()             + ' ' + this.corners .z3705();     }        h3706()     {         return      this.position.h3706()             + ' ' + this.x       .h3706()             + ' ' + this.y       .h3706()             + ' ' + this.width   .h3706()             + ' ' + this.height  .h3706()             + ' ' + this.round   .h3706()             + ' ' + this.corners .h3706();     }        static NaN = new t2024(         '',         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN); }    function o3825(str, i = -1) {     if (   i <  0 && str    == g964         || i >= 0 && str[i] == g964)         return [t2024.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const r3769 = i;      const pos     = g2850(str[i]); i += pos    [1];     const x       = g2850(str[i]); i += x      [1];     const y       = g2850(str[i]); i += y      [1];     const width   = g2850(str[i]); i += width  [1];     const height  = g2850(str[i]); i += height [1];     const round   = g2850(str[i]); i += round  [1];     const corners = g2850(str[i]); i += corners[1];       const poly = new t2024(         '',          pos    [0],         x      [0],         y      [0],         width  [0],         height [0],         round  [0],         corners[0]);       i = d3710(str, i, poly);           return [poly, i - r3769]; } 


class n2030 extends k2029 {     position;     x;     y;     width;     height;     round;     points;     convex;        constructor(nodeId,                 position = new d2022(0),                  x        = new d2022(0),                  y        = new d2022(0),                  width    = new d2022(0),                  height   = new d2022(0),                  round    = new d2022(0),                  points   = new d2022(0),                 convex   = new d2022(0))     {         super(x1239, nodeId);          this.position = position;         this.x        = x;         this.y        = y;         this.width    = width;         this.height   = height;         this.round    = round;         this.points   = points;         this.convex   = convex;     }        static fromObject(a111)     {         return new n2030(             a111.nodeId,             new d2022(a111.position),              new d2022(a111.x       ),              new d2022(a111.y       ),              new d2022(a111.width   ),              new d2022(a111.height  ),              new d2022(a111.round   ),             new d2022(a111.points  ),             new d2022(a111.convex  ));     }        copy()     {         const copy = new n2030(             this.nodeId,             this.position.copy(),              this.x       .copy(),              this.y       .copy(),              this.width   .copy(),              this.height  .copy(),              this.round   .copy(),              this.points  .copy(),             this.convex  .copy());          copy.n3359(this);          return copy;     }        equals(star)     {         return star             && this.position.equals(star.position)             && this.x       .equals(star.x       )             && this.y       .equals(star.y       )             && this.width   .equals(star.width   )             && this.height  .equals(star.height  )             && this.round   .equals(star.round   )             && this.points  .equals(star.points  )             && this.convex  .equals(star.convex  );     }        async eval(parse)     {         return this.copy();     }        c3712()     {         return super.c3712()             && this.position.c3712()             && this.x       .c3712()             && this.y       .c3712()             && this.width   .c3712()             && this.height  .c3712()             && this.round   .c3712()             && this.points  .c3712()             && this.convex  .c3712();     }            isValid()     {         return super.isValid()             && this.position.isValid()             && this.x       .isValid()             && this.y       .isValid()             && this.width   .isValid()             && this.height  .isValid()             && this.round   .isValid()             && this.points  .isValid()             && this.convex  .isValid();     }            x3633()     {         return this.copy();     }        toString()     {         return      this.position.toString()             + ' ' + this.x       .toString()             + ' ' + this.y       .toString()             + ' ' + this.width   .toString()             + ' ' + this.height  .toString()             + ' ' + this.round   .toString()             + ' ' + this.points  .toString()             + ' ' + this.convex  .toString()             + ' ' + super.toString();     }        z3705()     {         return      this.position.z3705()             + ' ' + this.x       .z3705()             + ' ' + this.y       .z3705()             + ' ' + this.width   .z3705()             + ' ' + this.height  .z3705()             + ' ' + this.round   .z3705()             + ' ' + this.points  .z3705()             + ' ' + this.convex  .z3705();     }        h3706()     {         return      this.position.h3706()             + ' ' + this.x       .h3706()             + ' ' + this.y       .h3706()             + ' ' + this.width   .h3706()             + ' ' + this.height  .h3706()             + ' ' + this.round   .h3706()             + ' ' + this.points  .h3706()             + ' ' + this.convex  .h3706();     }        static NaN = new n2030(         '',         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN); }    function m3826(str, i = -1) {     if (   i <  0 && str    == g964         || i >= 0 && str[i] == g964)         return [n2030.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const r3769 = i;      const pos    = g2850(str[i]); i += pos   [1];     const x      = g2850(str[i]); i += x     [1];     const y      = g2850(str[i]); i += y     [1];     const width  = g2850(str[i]); i += width [1];     const height = g2850(str[i]); i += height[1];     const round  = g2850(str[i]); i += round [1];     const points = g2850(str[i]); i += points[1];     const convex = g2850(str[i]); i += convex[1];       const star = new n2030(         '',          pos   [0],         x     [0],         y     [0],         width [0],         height[0],         round [0],         points[0],         convex[0]);       i = d3710(str, i, star);           return [star, i - r3769]; } 


class q2032 extends k2029 {     text;     x;     y;     width;     height;     font;     style;     size;     alignX;     alignY;     lineHeight;     letterSpacing;            constructor(nodeId,                 text          = new j2033(),                 x             = new d2022(0),                  y             = new d2022(0),                  width         = new d2022(0),                  height        = new d2022(0),                  font          = new d2022(0),                 style         = new d2022(0),                 size          = new d2022(0),                 alignX        = new d2022(0),                 alignY        = new d2022(0),                 lineHeight    = new d2022(0),                 letterSpacing = new d2022(0))     {         super(f1242, nodeId);          this.text          = text;         this.x             = x;         this.y             = y;         this.width         = width;         this.height        = height;         this.font          = font;         this.style         = style;         this.size          = size;         this.alignX        = alignX;         this.alignY        = alignY;         this.lineHeight    = lineHeight;         this.letterSpacing = letterSpacing;          this.objects       = [];     }        static fromObject(a111)     {         return new q2032(             a111.nodeId,             new d2022(a111.text         ),              new d2022(a111.x            ),              new d2022(a111.y            ),              new d2022(a111.width        ),              new d2022(a111.height       ),              new d2022(a111.font         ),             new d2022(a111.style        ),             new d2022(a111.size         ),             new d2022(a111.alignX       ),             new d2022(a111.alignY       ),             new d2022(a111.lineHeight   ),             new d2022(a111.letterSpacing));     }        copy()     {         const copy = new q2032(             this.nodeId,             this.text         .copy(),             this.x            .copy(),              this.y            .copy(),              this.width        .copy(),              this.height       .copy(),              this.font         .copy(),             this.style        .copy(),             this.size         .copy(),             this.alignX       .copy(),             this.alignY       .copy(),             this.lineHeight   .copy(),             this.letterSpacing.copy());           copy.n3359(this);          return copy;     }        equals(text)     {         return text             && this.text         .equals(text.text         )             && this.x            .equals(text.x            )             && this.y            .equals(text.y            )             && this.width        .equals(text.width        )             && this.height       .equals(text.height       )             && this.font         .equals(text.font         )             && this.style        .equals(text.style        )             && this.size         .equals(text.size         )             && this.alignX       .equals(text.alignX       )             && this.alignY       .equals(text.alignY       )             && this.lineHeight   .equals(text.lineHeight   )             && this.letterSpacing.equals(text.letterSpacing);     }        async eval(parse)     {         return this.copy();     }        c3712()     {         return super.c3712()             && this.text         .c3712()             && this.x            .c3712()             && this.y            .c3712()             && this.width        .c3712()             && this.height       .c3712()             && this.font         .c3712()             && this.style        .c3712()             && this.size         .c3712()             && this.alignX       .c3712()             && this.alignY       .c3712()             && this.lineHeight   .c3712()             && this.letterSpacing.c3712();     }            isValid()     {         return super.isValid()             && this.text         .isValid()             && this.x            .isValid()             && this.y            .isValid()             && this.width        .isValid()             && this.height       .isValid()             && this.font         .isValid()             && this.style        .isValid()             && this.size         .isValid()             && this.alignX       .isValid()             && this.alignY       .isValid()             && this.lineHeight   .isValid()             && this.letterSpacing.isValid();     }            x3633()     {         return this.copy();     }        toString()     {         return      this.text         .n2119()              + ' ' + this.x            .toString()             + ' ' + this.y            .toString()             + ' ' + this.width        .toString()             + ' ' + this.height       .toString()             + ' ' + this.font         .toString()             + ' ' + this.style        .toString()             + ' ' + this.size         .toString()             + ' ' + this.alignX       .toString()             + ' ' + this.alignY       .toString()             + ' ' + this.lineHeight   .toString()             + ' ' + this.letterSpacing.toString()             + ' ' + super.toString();         }        z3705()     {         return 'textShape';                                                                                                                                                                       }        h3706()     {         return      this.text         .h3706()             + ' ' + this.x            .h3706()             + ' ' + this.y            .h3706()             + ' ' + this.width        .h3706()             + ' ' + this.height       .h3706()             + ' ' + this.font         .h3706()             + ' ' + this.style        .h3706()             + ' ' + this.size         .h3706()             + ' ' + this.alignX       .h3706()             + ' ' + this.alignY       .h3706()             + ' ' + this.lineHeight   .h3706()             + ' ' + this.letterSpacing.h3706();     }        n2119()     {         return      this.text         .n2119()             + ' ' + this.x            .n2119()             + ' ' + this.y            .n2119()             + ' ' + this.width        .n2119()             + ' ' + this.height       .n2119()             + ' ' + this.font         .n2119()             + ' ' + this.style        .n2119()             + ' ' + this.size         .n2119()             + ' ' + this.alignX       .n2119()             + ' ' + this.alignY       .n2119()             + ' ' + this.lineHeight   .n2119()             + ' ' + this.letterSpacing.n2119();     }        static NaN = new q2032(         '',         j2033.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN); }    function z3827(str, i = -1) {     if (   i <  0 && str    == g964         || i >= 0 && str[i] == g964)         return [q2032.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const r3769 = i;      const text          = s2865  (str[i]); i += text         [1];     const x             = g2850(str[i]); i += x            [1];     const y             = g2850(str[i]); i += y            [1];     const width         = g2850(str[i]); i += width        [1];     const height        = g2850(str[i]); i += height       [1];     const font          = g2850(str[i]); i += font         [1];     const style         = g2850(str[i]); i += style        [1];     const size          = g2850(str[i]); i += size         [1];     const alignX        = g2850(str[i]); i += alignX       [1];     const alignY        = g2850(str[i]); i += alignY       [1];     const lineHeight    = g2850(str[i]); i += lineHeight   [1];     const letterSpacing = g2850(str[i]); i += letterSpacing[1];       const txts = new q2032(         '',          text         [0],         x            [0],         y            [0],         width        [0],         height       [0],         font         [0],         style        [0],         size         [0],         alignX       [0],         alignY       [0],         lineHeight   [0],         letterSpacing[0]);       i = d3710(str, i, txts);           return [txts, i - r3769]; } 


class h2023 extends i2050 {     nodeId;      x;     y;     smooth;       sp0 = null;      sp1 = null;      sp2 = null;         constructor(nodeId,                 x = new d2022(0),                  y = new d2022(0),                 smooth = null)     {         super(t1245);          this.nodeId  = nodeId;          this.x       = x;         this.y       = y;         this.smooth  = smooth;           this.n3742();     }        static fromObject(a111)     {         return new h2023(             a111.nodeId,             new d2022(a111.x     ),              new d2022(a111.y     ),              new d2022(a111.smooth));     }        copy()     {         const copy = new h2023(             this.nodeId,             this.x.copy(),              this.y.copy());          if (this.smooth) copy.smooth = this.smooth.copy();          copy.n3359(this);          copy.sp0 = clone(this.sp0);         copy.sp1 = clone(this.sp1);         copy.sp2 = clone(this.sp2);          return copy;     }        equals(p)     {         return p             && this.x.equals(p.x)             && this.y.equals(p.y);     }        n3742(cx = 0, cy = 0) {         this.sp0 = point(cx,   cy  );         this.sp1 = point(cx+1, cy  );         this.sp2 = point(cx,   cy+1);     }        applySpaceTransform(h4208, space)     {         this.sp0 = m3731(this.sp0, h4208, space);         this.sp1 = m3731(this.sp1, h4208, space);         this.sp2 = m3731(this.sp2, h4208, space);     }        static create(nodeId, x, y)     {         return new h2023(             nodeId,             new d2022(x),             new d2022(y));     }        static fromPoint(nodeId, p)     {         return new h2023(             nodeId,             new d2022(p.x),             new d2022(p.y));     }        async eval(parse)     {         return this.copy();     }        c3712()     {         return this.x.c3712()             && this.y.c3712()             && (  !this.smooth                 || this.smooth.c3712());     }        isValid()     {         return this.x.isValid()             && this.y.isValid()             && (  !this.smooth                 || this.smooth.isValid());     }        toString()     {         return this.x.isValid()             && this.y.isValid()             ?         this.x.toString()               + ' ' + this.y.toString()             : g964;     }        z3705()     {         return this.x.isValid()             && this.y.isValid()             ?   '(' + this.x.z3705()               + ', ' + this.y.z3705()               + ')'             : g964;     }        h3706()     {         return this.x.isValid()             && this.y.isValid()             ?         this.x.h3706()               + ' ' + this.y.h3706()             : g964;     }        x3633()     {         return this.copy();     }        n3747()     {         return point(             this.x.value,             this.y.value);     }        k2847(gen)     {         return '';     }        o3358()     {         return h2023.NaN.copy();     }        static NaN = Object.freeze(new h2023(         '',         d2022.NaN,          d2022.NaN)); }    function n3828(str, i = -1) {     if (   i <  0 && str    == g964         || i >= 0 && str[i] == g964)         return [h2023.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const r3769 = i;      const x = g2850(str[i]); i += x[1];     const y = g2850(str[i]); i += y[1];       const point = new h2023(         '',          x[0],         y[0]);       return [point, i - r3769]; } 


class l2037 extends k2029 {     points;     closed;     degree;     winding;     round;        constructor(nodeId,                 points  = new x2021(),                  closed  = new d2022(0),                  degree  = new d2022(0),                  winding = new d2022(0),                  round   = new d2022(0))     {         super(m1249, nodeId);          this.points  = points ?? new x2021();         this.closed  = closed;         this.degree  = degree;         this.winding = winding;         this.round   = round;     }        static fromObject(a111)     {         return new l2037(             a111.nodeId,             new x2021(a111.points.map(p => h2023.fromPoint(a111.nodeId, p))),              new d2022(a111.closed ),              new d2022(a111.degree ),              new d2022(a111.winding),              new d2022(a111.round  ));     }        copy()     {         const copy = new l2037(             this.nodeId,             this.points .copy(),              this.closed .copy(),              this.degree .copy(),              this.winding.copy(),              this.round  .copy());          copy.n3359(this);          return copy;     }        equals(rect)     {         return rect             && this.points .equals(rect.points )             && this.closed .equals(rect.closed )             && this.degree .equals(rect.degree )             && this.winding.equals(rect.winding)             && this.round  .equals(rect.round  );     }        async eval(parse)     {         return this.copy();     }        toString()     {         return      this.points .toString()             + ' ' + this.closed .toString()             + ' ' + this.degree .toString()             + ' ' + this.winding.toString()             + ' ' + this.round  .toString()             + ' ' + super.toString();     }        z3705()     {         return      this.points .z3705()             + ' ' + this.closed .z3705()             + ' ' + this.degree .z3705()             + ' ' + this.winding.z3705()             + ' ' + this.round  .z3705();     }        h3706()     {         return      this.points .h3706()             + ' ' + this.closed .h3706()             + ' ' + this.degree .h3706()             + ' ' + this.winding.h3706()             + ' ' + this.round  .h3706();     }        x3633()     {         return this.copy();     }        c3712()     {         return super.c3712()             && this.points .c3712()             && this.closed .c3712()             && this.degree .c3712()             && this.winding.c3712()             && this.round  .c3712();     }            isValid()     {         return super.isValid()             && this.points  && this.points .isValid()             && this.closed  && this.closed .isValid()             && this.degree  && this.degree .isValid()             && this.winding && this.winding.isValid()             && this.round   && this.round  .isValid();     }            static NaN = new l2037(         '',         x2021  .NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN); }    function h3670(str, i = -1) {     if (   i <  0 && str    == g964         || i >= 0 && str[i] == g964)         return [l2037.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const r3769 = i;      const points  = u3482  (str, i); i += points [1];     const closed  = g2850(str[i]); i += closed [1];     const degree  = g2850(str[i]); i += degree [1];     const winding = g2850(str[i]); i += winding[1];     const round   = g2850(str[i]); i += round  [1];      const path = new l2037(         '',          points [0],         closed [0],         degree [0],         winding[0],         round  [0]);       i = d3710(str, i, path);           return [path, i - r3769]; } 


class o2039 extends i2050 {     nodeId;      x;     y;     join;     cap;     round;        constructor(nodeId,                 x     = new d2022(0),                  y     = new d2022(0),                 join  = new d2022(0),                 cap   = new d2022(0),                 round = new d2022(0))     {         super(c1252);          this.nodeId = nodeId;          this.x      = x    .copy();         this.y      = y    .copy();         this.join   = join .copy();         this.cap    = cap  .copy();         this.round  = round.copy();     }        copy()     {         const copy = new o2039(             this.nodeId,             this.x    .copy(),              this.y    .copy(),              this.join .copy(),              this.cap  .copy(),              this.round.copy());          copy.n3359(this);          return copy;     }        equals(p)     {         return p             && this.x    .equals(p.x    )             && this.y    .equals(p.y    )             && this.join .equals(p.join )             && this.cap  .equals(p.cap  )             && this.round.equals(p.round);     }        static create(nodeId, x, y)     {         return new o2039(             nodeId,             new d2022(x    ),             new d2022(y    ),             new d2022(join ),             new d2022(cap  ),             new d2022(round));     }        static fromPoint(nodeId, p)     {         return new o2039(             nodeId,             new d2022(p.x),             new d2022(p.y),             new d2022(0),             new d2022(0),             new d2022(0));     }        async eval(parse)     {         return this;     }        c3712()     {         return this.x    .c3712()             && this.y    .c3712()             && this.join .c3712()             && this.cap  .c3712()             && this.round.c3712();     }        isValid()     {         return this.x    .isValid()             && this.y    .isValid()             && this.join .isValid()             && this.cap  .isValid()             && this.round.isValid();     }        toString()     {         return      this.x    .toString()             + ' ' + this.y    .toString()             + ' ' + this.join .toString()             + ' ' + this.cap  .toString()             + ' ' + this.round.toString();     }        z3705()     {         return      this.x    .z3705()             + ' ' + this.y    .z3705()             + ' ' + this.join .z3705()             + ' ' + this.cap  .z3705()             + ' ' + this.round.z3705();     }        h3706()     {         return      this.x    .h3706()             + ' ' + this.y    .h3706()             + ' ' + this.join .h3706()             + ' ' + this.cap  .h3706()             + ' ' + this.round.h3706();     }        x3633()     {         return this.copy();     }        n3747()     {         return point(             this.x.value,             this.y.value);     }        k2847(gen)     {         return '';     }        o3358()     {         return o2039.NaN.copy();     }        static NaN = Object.freeze(new o2039(         '',         d2022.NaN,          d2022.NaN,          d2022.NaN,          d2022.NaN,          d2022.NaN)); }    function q3669(str, i = -1) {     if (   i <  0 && str    == g964         || i >= 0 && str[i] == g964)         return [o2039.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const r3769 = i;      const x     = g2850(str[i]); i += x    [1];     const y     = g2850(str[i]); i += y    [1];     const join  = g2850(str[i]); i += join [1];     const cap   = g2850(str[i]); i += cap  [1];     const round = g2850(str[i]); i += round[1];       const point = new o2039(         '',          x    [0],         y    [0],         join [0],         cap  [0],         round[0]);       return [point, i - r3769]; } 


class c2035 extends i2050 {     nodeId;      start;     end;     e3665;     h3666;        constructor(nodeId,                 start,                  end,                 e3665 = h2023.create(nodeId, 0, 0),                 h3666   = h2023.create(nodeId, 0, 0))     {         super(d1255);          this.nodeId = nodeId;          this.start        = start       .copy();                this.end          = end         .copy();                  this.e3665 = e3665.copy();         this.h3666   = h3666  .copy();       }        copy()     {         const copy = new c2035(             this.nodeId,             this.start       .copy(),              this.end         .copy(),              this.e3665.copy(),              this.h3666  .copy());          copy.n3359(this);          return copy;     }        equals(edge)     {         return edge             && this.start       .equals(edge.start       )             && this.end         .equals(edge.end         )             && this.e3665.equals(edge.e3665)             && this.  h3666.equals(edge.  h3666);     }        static create(nodeId, start, end, e3665, h3666)     {         return new c2035(             nodeId,             start,             end,             h2023.create(nodeId, e3665.x, e3665.y),             h2023.create(nodeId,   h3666.x,   h3666.y));     }        async eval(parse)     {         return this;     }        c3712()     {         return this.start       .c3712()             && this.end         .c3712()             && this.e3665.c3712()             && this.h3666  .c3712();     }        isValid()     {         return this.start       .isValid()             && this.end         .isValid()             && this.e3665.isValid()             && this.h3666  .isValid();     }        toString()     {         return      this.start       .toString()             + ' ' + this.end         .toString()             + ' ' + this.e3665.toString()             + ' ' + this.h3666  .toString();     }        z3705()     {         return      this.start       .toString()             + ' ' + this.end         .toString()             + ' ' + this.e3665.toString()             + ' ' + this.h3666  .toString();     }        h3706()     {         return      this.start       .h3706()             + ' ' + this.end         .h3706()             + ' ' + this.e3665.h3706()             + ' ' + this.h3666  .h3706();     }        x3633()     {         return this.copy();     }        k2847(gen)     {         return '';     }        o3358()     {         return c2035.NaN.copy();     }        static NaN = Object.freeze(new c2035(         '',         o2039.NaN,          o2039.NaN,          h2023.NaN,          h2023.NaN)); }    function p3667(str, i = -1) {     if (   i <  0 && str    == g964         || i >= 0 && str[i] == g964)         return [c2035.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const r3769 = i;      const start        = q3669(str, i); i += start       [1];     const end          = q3669(str, i); i += end         [1];     const e3665 = n3828       (str, i); i += e3665[1];     const h3666   = n3828       (str, i); i +=   h3666[1];       const edge = new c2035(         '',          start       [0],         end         [0],         e3665[0],           h3666[0]);       return [edge, i - r3769]; } 


class c2038 extends k2029 {     loops;       winding;      fills = [];        constructor(nodeId,                 loops   = new x2021(),                  winding = new d2022(0))     {         super(l1258, nodeId);          this.loops   = loops;           this.winding = winding;     }        static fromObject(a111)     {         return new c2038(             a111.nodeId,             new x2021(),               new x2021());      }        copy()     {         const copy = new c2038(             this.nodeId,             this.loops  .copy(),              this.winding.copy());          copy.fills = clone(this.fills);                  copy.n3359(this);          return copy;     }        equals(region)     {         return region             && this.loops  .equals(region.loops  )             && this.winding.equals(region.winding);     }                                              async eval(parse)     {         return this;     }        c3712()     {         return this.loops  .c3712()             && this.winding.c3712();     }        isValid()     {         return this.loops  .isValid()             && this.winding.isValid();     }        toString()     {         return      this.loops  .toString()             + ' ' + this.winding.toString();     }        z3705()     {         return      this.loops  .z3705()             + ' ' + this.winding.z3705();     }        h3706()     {         return      this.loops  .h3706()             + ' ' + this.winding.h3706();     }        x3633()     {         return this.copy();     }        k2847(gen)     {         return '';     }        o3358()     {         return c2035.NaN.copy();     }        static NaN = Object.freeze(new c2038(         '',         x2021  .NaN,          d2022.NaN)); }    function b3664(str, i = -1) {     if (   i <  0 && str    == g964         || i >= 0 && str[i] == g964)         return [c2038.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const r3769 = i;      const loops   = u3482  (str, i); i += loops  [1];     const winding = g2850(str[i]); i += winding[1];       const region = new c2038(         '',          loops  [0],         winding[0]);       i = d3710(str, i, region);       return [region, i - r3769]; } 


class t2036 extends i2050 {     nodeId;      regions;        constructor(nodeId,                 regions = new x2021())     {         super(q1261);          this.nodeId  = nodeId;          this.regions = regions;      }        static fromObject(a111)     {         return new t2036(             a111.nodeId,             new x2021(a111.regions.map(r => c2038.fromObject(a111.nodeId, r))));     }        copy()     {         const copy = new t2036(             this.nodeId,             this.regions.copy());          copy.n3359(this);          return copy;     }        equals(other)     {         return other             && this.regions.equals(other.regions);     }        static create(nodeId, regions)     {         return new t2036(             nodeId,             regions);     }        async eval(parse)     {         return this;     }        c3712()     {         return this.regions.c3712();     }        isValid()     {         return this.regions.isValid();     }        toString()     {         return this.regions.toString();     }        z3705()     {         return this.regions.z3705();     }        h3706()     {         return this.regions.h3706();     }        x3633()     {         return this.copy();     }        k2847(gen)     {         return '';     }        o3358()     {         return t2036.NaN.copy();     }        static NaN = Object.freeze(new t2036(         '',         x2021.NaN)); }    function q3663(str, i = -1) {     if (   i <  0 && str    == g964         || i >= 0 && str[i] == g964)         return [t2036.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const r3769 = i;      const regions = u3482(str, i); i += regions[1];       const net = new t2036(         '',          regions[0]);       return [net, i - r3769]; } 


class k2027 extends k2029 {     operation;     children;        constructor(nodeId, children, operation)     {         super(h1287, nodeId);          this.children  = children;         this.operation = operation;          this.objects =              children.objects             ? children.objects.map(o => o.copy())             : null;     }        copy()     {         const copy = new k2027(             this.nodeId,             this.children .copy(),             this.operation.copy());          copy.n3359(this);          return copy;     }        equals(bool)     {         return bool             && this.children .equals(bool.children )             && this.operation.equals(bool.operation);     }        async eval(parse)     {         return this;     }        toString()     {         return      this.children .toString()             + ' ' + this.operation.toString();     }        z3705()     {         return      this.children .z3705()             + ' ' + this.operation.z3705();     }        h3706()     {         return      this.children .h3706()             + ' ' + this.operation.h3706();     }        x3633()     {         return this.copy();     }        isValid()     {         return super.isValid()             && this.children .isValid()             && this.operation.isValid();     }            static NaN = new k2027(         '',         x2021  .NaN,         d2022.NaN); }    function h3829(str, i = -1) {     if (   i <  0 && str    == g964         || i >= 0 && str[i] == g964)         return [k2027.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const r3769 = i;      const children  = u3482  (str, i); i += children [1];     const operation = g2850(str[i]); i += operation[1];      const bool = new k2027(         '',          children [0],         operation[0]);       i = d3710(str, i, bool);           return [bool, i - r3769]; } 


class WavePathValue extends k2029 {     shape;     x;     y;     width;     amplitude;     frequency;     offset;     alignX;       alignY;        degree;        constructor(nodeId,                 shape     = new d2022(0),                 x         = new d2022(0),                  y         = new d2022(0),                  width     = new d2022(0),                  amplitude = new d2022(0),                 frequency = new d2022(0),                 offset    = new d2022(0),                 alignX    = new d2022(0),                 alignY    = new d2022(0))     {         super(g1234, nodeId);          this.shape     = shape;         this.x         = x;         this.y         = y;         this.width     = width;         this.amplitude = amplitude;         this.frequency = frequency;         this.offset    = offset;         this.alignX    = alignX;         this.alignY    = alignY;          this.degree   = new d2022(2);     }        copy()     {         const copy = new WavePathValue(             this.nodeId,             this.shape    .copy(),             this.x        .copy(),              this.y        .copy(),              this.width    .copy(),              this.amplitude.copy(),             this.frequency.copy(),             this.offset   .copy(),             this.alignX   .copy(),             this.alignY   .copy());          copy.n3359(this);          return copy;     }        equals(wave)     {         return wave             && this.shape    .equals(wave.shape    )             && this.x        .equals(wave.x        )             && this.y        .equals(wave.y        )             && this.width    .equals(wave.width    )             && this.amplitude.equals(wave.amplitude)             && this.frequency.equals(wave.frequency)             && this.offset   .equals(wave.offset   )             && this.alignX   .equals(wave.alignX   )             && this.alignY   .equals(wave.alignY   );     }        async eval(parse)     {         return this.copy();     }                    c3712()     {         return super.c3712()             && this.shape    .c3712()             && this.x        .c3712()             && this.y        .c3712()             && this.width    .c3712()             && this.amplitude.c3712()             && this.frequency.c3712()             && this.offset   .c3712()             && this.alignX   .c3712()             && this.alignY   .c3712();     }        isValid()     {         return super.isValid()             && this.shape    .isValid()             && this.x        .isValid()             && this.y        .isValid()             && this.width    .isValid()             && this.amplitude.isValid()             && this.frequency.isValid()             && this.offset   .isValid()             && this.alignX   .isValid()             && this.alignY   .isValid();     }        x3633()     {         return this.copy();     }        toString()     {         return      this.shape    .toString()             + ' ' + this.x        .toString()             + ' ' + this.y        .toString()             + ' ' + this.width    .toString()             + ' ' + this.amplitude.toString()             + ' ' + this.frequency.toString()             + ' ' + this.offset   .toString()             + ' ' + this.alignX   .toString()             + ' ' + this.alignY   .toString()             + ' ' + super.toString();     }        z3705()     {         return 'wave';                                                                                                                          }        h3706()     {         return      this.shape    .h3706()             + ' ' + this.x        .h3706()             + ' ' + this.y        .h3706()             + ' ' + this.width    .h3706()             + ' ' + this.amplitude.h3706()             + ' ' + this.frequency.h3706()             + ' ' + this.offset   .h3706()             + ' ' + this.alignX   .h3706()             + ' ' + this.alignY   .h3706();     }        static NaN = new WavePathValue(         '',         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN); }    function parseWavePathValue(str, i = -1) {     if (   i <  0 && str    == g964         || i >= 0 && str[i] == g964)         return [WavePathValue.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const r3769 = i;      const shape     = g2850(str[i]); i += shape    [1];     const x         = g2850(str[i]); i += x        [1];     const y         = g2850(str[i]); i += y        [1];     const width     = g2850(str[i]); i += width    [1];     const amplitude = g2850(str[i]); i += amplitude[1];     const frequency = g2850(str[i]); i += frequency[1];     const offset    = g2850(str[i]); i += offset   [1];     const alignX    = g2850(str[i]); i += alignX   [1];     const alignY    = g2850(str[i]); i += alignY   [1];       const wave = new WavePathValue(         '',          shape    [0],         x        [0],         y        [0],         width    [0],         amplitude[0],         frequency[0],         offset   [0],         alignX   [0],         alignY   [0]);       i = d3710(str, i, wave);           return [wave, i - r3769]; } 


class ArcPathValue extends k2029 {     position;     x;     y;     width;     height;     start;     sweep;      degree;         constructor(nodeId,                 position = new d2022(0),                 x        = new d2022(0),                  y        = new d2022(0),                  width    = new d2022(0),                  height   = new d2022(0),                  start    = new d2022(0),                 sweep    = new d2022(0))     {         super(m1231, nodeId);          this.position = position;         this.x        = x;         this.y        = y;         this.width    = width;         this.height   = height;         this.start    = start;         this.sweep    = sweep;          this.degree   = new d2022(2);     }        copy()     {         const copy = new ArcPathValue(             this.nodeId,             this.position.copy(),              this.x       .copy(),              this.y       .copy(),              this.width   .copy(),              this.height  .copy(),              this.start   .copy(),             this.sweep   .copy());          copy.n3359(this);          return copy;     }        equals(arc)     {         return arc             && this.position.equals(arc.position)             && this.x       .equals(arc.x       )             && this.y       .equals(arc.y       )             && this.width   .equals(arc.width   )             && this.height  .equals(arc.height  )             && this.start   .equals(arc.start   )             && this.sweep   .equals(arc.sweep   );     }        async eval(parse)     {         return this.copy();     }                    c3712()     {         return super.c3712()             && this.position.c3712()             && this.x       .c3712()             && this.y       .c3712()             && this.width   .c3712()             && this.height  .c3712()             && this.start   .c3712()             && this.sweep   .c3712();     }        isValid()     {         return super.isValid()             && this.position.isValid()             && this.x       .isValid()             && this.y       .isValid()             && this.width   .isValid()             && this.height  .isValid()             && this.start   .isValid()             && this.sweep   .isValid();     }        x3633()     {         return this.copy();     }        toString()     {         return      this.position.toString()             + ' ' + this.x       .toString()             + ' ' + this.y       .toString()             + ' ' + this.width   .toString()             + ' ' + this.height  .toString()             + ' ' + this.start   .toString()             + ' ' + this.sweep   .toString()             + ' ' + super.toString();     }        z3705()     {         return 'arc';                                                                                                }        h3706()     {         return      this.position.h3706()             + ' ' + this.x       .h3706()             + ' ' + this.y       .h3706()             + ' ' + this.width   .h3706()             + ' ' + this.height  .h3706()             + ' ' + this.start   .h3706()             + ' ' + this.sweep   .h3706();     }        static NaN = Object.freeze(new ArcPathValue(         '',         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN)); }    function parseArcPathValue(str, i = -1) {     if (   i <  0 && str    == g964         || i >= 0 && str[i] == g964)         return [ArcPathValue.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const r3769 = i;      const pos    = g2850(str[i]); i += pos   [1];     const x      = g2850(str[i]); i += x     [1];     const y      = g2850(str[i]); i += y     [1];     const width  = g2850(str[i]); i += width [1];     const height = g2850(str[i]); i += height[1];     const start  = g2850(str[i]); i += start [1];     const sweep  = g2850(str[i]); i += sweep [1];       const arc = new ArcPathValue(         '',          pos   [0],         x     [0],         y     [0],         width [0],         height[0],         start [0],         sweep [0]);       i = d3710(str, i, arc);           return [arc, i - r3769]; } 


class g2028 extends i2050 {     items = [];        constructor(nodeId, items = [])     {         super(c1264, nodeId);          this.items = items;               }        copy()     {         const copy = new g2028(             this.nodeId,             this.items.map(i => i.copy()));          copy.n3359(this);          return copy;     }        equals(group)     {         if (!group)                                  return false;         if (!(group instanceof g2028))     return false;         if (this.items.length != group.items.length) return false;                      for (let i = 0; i < this.items.length; i++)             if (!this.items[i].equals(group.items[i]))                 return false;          return true;     }        async eval(parse)     {         return this;     }        toString()     {         if (!this.items)             return '';           let str = '';                           str += this.items.length;          for (let i = 0; i < this.items.length; i++)         {             const item = this.items[i];              str += ' ' + item.type + ' ';             str += item.toString();         }           return str;     }        z3705()     {         if (!this.items)             return '';           let str = '';                           str += this.items.length;          for (let i = 0; i < this.items.length; i++)         {             const item = this.items[i];              str += ' ' + item.type + ' ';             str += item.z3705();         }           return str;     }        h3706()     {         if (!this.items)             return '';           let str = '';                           str += this.items.length;          for (let i = 0; i < this.items.length; i++)         {             const item = this.items[i];              str += ' ' + item.type + ' ';             str += item.h3706();         }           return str;     }        x3633()     {         return this.copy();     }        isValid()     {         return  this.items             && !this.items.find(i => !i.isValid());     }            static NaN = new g2028(         '',         x2021.NaN); }    function y3830(str, i = -1) {     if (i < 0)     {         str = str.split(' ');         i   = 0;     }               const r3769 = i;      const group = new g2028();           const a4209 = parseInt(str[i++]);       for (let j = 0; j < a4209; j++)     {         const type = str[i++];                  switch (type)         {             case          y1056:               case    y1059: { const _list   = u3482        (str, i);  i += _list  [1];  group.items.push(_list  [0]);  break; }               case     w1218: { const rect    = p3711   (str, i);  i += rect   [1];  group.items.push(rect   [0]);  break; }             case          h1221: { const line    = w3822        (str, i);  i += line   [1];  group.items.push(line   [0]);  break; }             case       m1224: { const ellipse = k3823     (str, i);  i += ellipse[1];  group.items.push(ellipse[0]);  break; }             case       r1227: { const ellipse = c3824     (str, i);  i += ellipse[1];  group.items.push(ellipse[0]);  break; }             case       d1236: { const poly    = o3825     (str, i);  i += poly   [1];  group.items.push(poly   [0]);  break; }             case          x1239: { const star    = m3826        (str, i);  i += star   [1];  group.items.push(star   [0]);  break; }             case    f1242: { const text    = z3827   (str, i);  i += text   [1];  group.items.push(text   [0]);  break; }             case         t1245: { const point   = n3828       (str, i);  i += point  [1];  group.items.push(point  [0]);  break; }             case   m1249: { const path    = h3670  (str, i);  i += path   [1];  group.items.push(path   [0]);  break; }             case h1287: { const path    = h3829(str, i);  i += path   [1];  group.items.push(path   [0]);  break; }             case   c1264: { const _group  = y3830  (str, i);  i += _group [1];  group.items.push(_group [0]);  break; }             case         t1267: { const frame   = d3831       (str, i);  i += frame  [1];  group.items.push(frame  [0]);  break; }         }     }           return [         group,          i - r3769]; } 


class p2014 extends k2029 {     children;     position;     x;     y;     width;     height;     round;     clip;        constructor(nodeId, children, position, x, y, width, height, round, clip)     {         super(t1267, nodeId);          this.children = children;         this.position = position;         this.x        = x;         this.y        = y;         this.width    = width;         this.height   = height;         this.round    = round;         this.clip     = clip;          this.objects =                 children             && children.objects              ? children.objects.map(o => o.copy())              : [];     }        copy()     {         const copy = new p2014(             this.nodeId,             this.children.copy(),             this.position.copy(),             this.x       .copy(),             this.y       .copy(),             this.width   .copy(),             this.height  .copy(),             this.round   .copy(),             this.clip    .copy());          copy.n3359(this);          return copy;     }        equals(frame)     {         return frame             && this.children.equals(frame.children)             && this.position.equals(frame.position)             && this.x       .equals(frame.x       )             && this.y       .equals(frame.y       )             && this.width   .equals(frame.width   )             && this.height  .equals(frame.height  )             && this.round   .equals(frame.round   )             && this.clip    .equals(frame.clip    );     }        async eval(parse)     {         return this;     }        toString()     {         return       this.children.toString()              + ' ' + this.position.toString()              + ' ' + this.x       .toString()              + ' ' + this.y       .toString()              + ' ' + this.width   .toString()              + ' ' + this.height  .toString()              + ' ' + this.round   .toString()              + ' ' + this.clip    .toString()              + ' ' + super.toString();     }        z3705()     {         return 'frame';                                                                                                             }        h3706()     {         return       this.children.h3706()              + ' ' + this.position.h3706()              + ' ' + this.x       .h3706()              + ' ' + this.y       .h3706()              + ' ' + this.width   .h3706()              + ' ' + this.height  .h3706()              + ' ' + this.clip    .h3706()              + ' ' + this.round   .h3706();     }        x3633()     {         return this.copy();     }        isValid()     {         return super.isValid()             && this.children.isValid()             && this.position.isValid()             && this.x       .isValid()             && this.y       .isValid()             && this.width   .isValid()             && this.height  .isValid()             && this.round   .isValid()             && this.clip    .isValid();     }            static NaN = new p2014(         '',         x2021  .NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN,         d2022.NaN); }    function d3831(str, i = -1) {     if (   i <  0 && str    == g964         || i >= 0 && str[i] == g964)         return [p2014.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const r3769 = i;      const children = u3482  (str, i); i += children[1];     const position = g2850(str[i]); i += position[1];     const x        = g2850(str[i]); i += x       [1];     const y        = g2850(str[i]); i += y       [1];     const width    = g2850(str[i]); i += width   [1];     const height   = g2850(str[i]); i += height  [1];     const round    = g2850(str[i]); i += round   [1];     const clip     = g2850(str[i]); i += clip    [1];      const frame = new p2014(         '',          children[0],         position[0],         x       [0],         y       [0],         width   [0],         height  [0],         round   [0],         clip    [0]);       i = d3710(str, i, frame);           return [frame, i - r3769]; } 


class d1867 extends i2044 {     count            = null;     iteration        = null;    k3680            = null;     loop             = null;      c3819 = [];      isTerminal       = false;      activeAfter      = false;      listAfter        = false;         constructor(nodeId, options)     {         super(m1064, nodeId, options);     }            reset()     {         super.reset();          this. count      = null;         this. iteration  = null;         this.k3680      = null;         this. loop       = null;          this.isTerminal  = false;         this.activeAfter = false;         this.listAfter   = false;          this.c3819 = [];     }        copy()     {         const copy = new d1867(this.nodeId, this.options);          copy.n3359(this);          if (this. value    ) copy. value     = this. value    .copy();         if (this. iteration) copy. iteration = this. iteration.copy();         if (this. count    ) copy. count     = this. count    .copy();         if (this.k3680    ) copy.k3680     = this.k3680    .copy();         if (this. loop     ) copy. loop      = this. loop     .copy();          copy.isTerminal  = this.isTerminal;         copy.activeAfter = this.activeAfter;         copy.listAfter   = this.listAfter;          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       let   count     = await evalNumberValue(this.count,     parse);         let   iteration = await evalNumberValue(this.iteration, parse);         let  k3680     = new d2022(1);           let iterations = [];          if (iteration.isValid())         {             if (iteration.type != t1143)                 iteration = new j2033(iteration.value.toString());              const _iterations = iteration.value.split(',');                          if (_iterations.length > 1)             {                 for (const iter of _iterations)                 {                     if (iter.includes('-'))                     {                         const iterParts = iter.split('-');                          if (iterParts.length == 2)                         {                             let start = iterParts[0];                             let end   = iterParts[1];                              if (   !isNaN(Number(start))                                 && !isNaN(Number(end  )))                             {                                 for (let i = start; i <= end; i++)                                     iterations.push(parseInt(i));                             }                         }                     }                     else                         iterations.push(parseInt(iter));                 }             }             else                 iterations.push(parseInt(iteration.value));         }           count =              count             ? new d2022(Math.floor(count.value))             : new d2022(0);           if (   this.loop              && this.loop.type != t1091)              h3357(this.loop, this);           this.value = new x2021();         this.value.objects = [];           if (   count             && count.value > 0)                                                             {             if (this.input)             {                 const c3180    = Date.now();                 let   a3818 = false;                   const nRepeats =                      this.options.enabled                      ? count.value                      : 0;                                   let repeat =                 {                     repeatId:         this.nodeId,                     currentIteration: 0,                     total:            nRepeats                 };                                       parse.repeats.push(repeat);                  if (parse.repeats.length == 1)                     parse.y3640 += nRepeats;                   if (   this.loop                     && this.loop.o3629)                     this.loop.o3629(parse, this.nodeId);                   if (this.loop)                 {                     parse.evalAccumulate = false;                     await this.loop.eval(parse);                      parse.evalAccumulate = true;                 }                   for (let i = 0, o = 0; i < Math.max(1, nRepeats); i++)                 {                     if (  !a3818                         && Date.now() - c3180 > 50)                     {                         x2077(this.nodeId);                         a3818 = true;                     }                       repeat.currentIteration = i;                       this.input.o4089(parse, this, false);                                           const input = await evalValue      (this.input, parse);                          k3680 = await evalNumberValue(this.k3680, parse);                       if (   input                         && nRepeats > 0                         && (  !k3680                              || k3680.value > 0))                     {                                                                           if (g957(input.type))                         {                             if (input.condensed === true)                                 this.value.items.push(input);                             else                             {                                 for (const item of input.items)                                     this.value.items.push(item);                             }                         }                         else                             this.value.items.push(input);                                   if (   this.options.active                             || this.options.s2998                             || this.options.beforeList)                         {                             this.c3819 = [];                                                       if (input.objects)                             {                                 for (let j = 0; j < input.objects.length; j++, o++)                                 {                                     const a111 = b3738(input.objects[j]);                                       this.c3819.push(a111.copy());                                       if (  !iteration.isValid()                                         || iterations.includes(i))                                     {                                         a111.nodeId      = this.nodeId;                                         a111.listId      = i;                                          a111.objectId   += h967 + this.nodeId + ':' + (o+1).toString();                                         a111.objectName += ' ' + (o+1).toString();                                          a111.t3820   = repeat.currentIteration;                                          if (this.value.objects)                                             this.value.objects.push(a111);                                     }                                 }                             }                         }                     }                       this.input.t4087(parse);                       if (   this.loop                         && this.loop.iterateCache)                         this.loop.iterateCache(parse, this);                                           if (parse.repeats.length == 1)                     {                         parse.g3639++;                          if (await r3862(parse.z2067))                         {                             y2079(this.nodeId);                             return this;                         }                     }                                           if (a3818)                         y2078(parse, this.nodeId, i / nRepeats);                 }                   if (   this.loop                     && this.loop.u3632)                     this.loop.u3632(parse, this.nodeId);                   if (this.startTimer > -1)                 {                     clearTimeout(this.startTimer);                     this.startTimer = -1;                 }                   y2079(this.nodeId);                   l952(parse.repeats.at(-1) == repeat, 'invalid nested repeat \'' + this.nodeId + '\'');                 parse.repeats.pop();             }             else if (this.input)                 await evalValue(this.input, parse);         }         else if (this.input)             await evalValue(this.input, parse);                   const type = this.outputListType();          this.n4101(parse,         [             ['type',      type     ],             ['count',     count    ],             ['iteration', iteration]         ]);           this.validate();          return this;     }        x3633()     {         return this.value.copy();     }        isValid()     {         return super.isValid()             && this. count     && this. count    .isValid()             && this. iteration && this. iteration.isValid()             && (!this.k3680   || this.k3680    .isValid());     }        r4088(parse)     {         super.r4088(parse);          if (this. count    ) this. count    .r4088(parse);         if (this. iteration) this. iteration.r4088(parse);         if (this.k3680    ) this.k3680    .r4088(parse);         if (this. loop     ) this. loop     .r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this. count    ) this. count    .o4089(parse, from, force);         if (this. iteration) this. iteration.o4089(parse, from, force);         if (this.k3680    ) this.k3680    .o4089(parse, from, force);         if (this. loop     ) this. loop     .o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this. count    ) this. count    .t4087(parse);         if (this. iteration) this. iteration.t4087(parse);         if (this.k3680    ) this.k3680    .t4087(parse);         if (this. loop     ) this. loop     .t4087(parse);     } }    function h3357(loop, node) {     l952(            loop.type == l1086         || loop.type == t1066         || loop.type == l1104         || loop.type == a1105         || loop.type == w1103         || loop.type == c1106         || loop.type == a1107         || loop.type == g1108         || loop.type == v1069         || loop.type == PARAM,          'only volatile types can be repeated'); }


class z1876 extends i2044 {     from   = null;      z3821 = NULL;            constructor(nodeId, options)     {         super(p1063, nodeId, options);     }            reset()     {         super.reset();          this.from = null;     }        copy()     {         const copy = new z1876(this.nodeId, this.options);          copy.n3359(this);          if (this.value) copy.value = this.value.copy();          return copy;     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        async eval(parse)     {         if (     !parse.evalFeedback)             return this;                    const input = await evalValue(this.input, parse);                     this.n4101(parse,          [             ['type', this.outputListType()]         ]);           await this.v4100(parse, {input});                   this.validate();          return this;     }        async v4100(parse, options = {})     {         const repeat = parse.repeats.find(r => r.repeatId == this.z3821);           const feedback =                 repeat             && repeat.currentIteration > 0             && this.from;                   this.value = new x2021();          if (feedback)         {             for (const a111 of this.from.c3819)                 this.value.items.push(a111.x3633());              if (this.from.c3819)                 this.value.objects = this.from.c3819.map(o => o.copy());         }         else if (options.input               && options.input.isValid())         {             this.value.items.push(options.input);              if (options.input.objects)                 this.value.objects = options.input.objects.map(o => o.copy());         }           const iter =             repeat              ? NAME_SEPARATOR + repeat.currentIteration              : '';          for (const item of this.value.items)             item.nodeId = this.nodeId;          if (this.value.objects)         {             for (let i = 0; i < this.value.objects.length; i++)             {                 const a111 = this.value.objects[i];                  a111.nodeId   = this.nodeId;                 a111.objectId = this.nodeId + h967 + i + iter;             }         }           await super.v4100(parse);     }        x3633()     {         return this.value.copy();     }                                o3629(parse, nodeId)     {         super.o3629(parse, nodeId);          this.from = parse.k4243.find(n => n.nodeId == nodeId);     }        u3632(parse, nodeId)     {         super.u3632(parse, nodeId);          this.from = null;     } } 


class q1866 extends i2044 {     constructor(nodeId, options)     {         super(d1060, nodeId, options);     }            copy()     {         const copy = new q1866(this.nodeId, this.options);          copy.n3359(this);          if (this.value) copy.value = this.value.copy();         if (this.input) copy.input = this.input.copy();          return copy;     }        async eval(parse)     {                             this.value =              this.input              ? (await this.input.eval(parse)).x3633()              : new g4217();           this.y4216();           this.n4101(parse,         [             ['type', this.outputType()]         ]);           this.validate();          return this;     }        x3633()     {         return this.value              ? this.value.copy()              : null;     } } 


class t1881 extends g2043 {     varValue = null;        constructor(nodeId, options, styleId)     {         super(w1061, nodeId, options);     }        reset()     {         super.reset();          this.varValue = null;     }        copy()     {         const copy = new e1887(this.nodeId, this.options);          if (this.varValue) copy.varValue = this.varValue.copy();                  return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                   this.value =              this.varValue             ? (await this.varValue.eval(parse)).x3633()             : new g4217();           this.n4101(parse,         [             ['value', this.value]         ]);           this.validate();          return this;     }        evalVariable(options = {})     {         if (!this.options.enabled)             return;     }        isValid()     {         return this.varValue && this.varValue.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.varValue) this.varValue.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.varValue) this.varValue.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.varValue) this.varValue.t4087(parse);     } }


class z1882 extends g2043 {     input = null;        constructor(nodeId, options)     {         super(p1062, nodeId, options);     }        copy()     {         const copy = new j1864(this.nodeId, this.options);                  copy.n3359(this);          if (this.input) copy.input = this.input.copy();                  for (const key of this.keys())         {             if (this[key] instanceof i2050)                 Object.assign(copy, {[key]: this[key]});         }          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await evalListValue(this.input, parse);           this.e3096 = [];                                                                                                                                                                                                                                                  this.n4101(parse, [['', new g4217()]], true);                                        this.validate();          return this;     }                f4242(p2992)     {         return this.value             && this.value.items             && p2992 != 'value'             ? this.value.items.find(i => i.valueId == p2992)              : null;     }        x3633()     {         return this.value.copy();     }        isValid()     {         return this.input && this.input.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.input) this.input.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.input) this.input.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.input) this.input.t4087(parse);     } }


class i1854 extends i2044 {     p4212 = null;        constructor(nodeId, options)     {         super(p1065, nodeId, options);     }            reset()     {         super.reset();          this.p4212 = null;     }        copy()     {         const copy = new i1854(this.nodeId, this.options);          copy.n3359(this);          if (this.value) copy.value = this.value.copy();                   return copy;     }        async eval(parse)     {         if (!this.options.enabled)             this.p4212 = null;                      if (   this.isCached()             && this.p4212)             return this;           if (this.p4212)         {             this.value = this.p4212.copy();         }         else         {             const input = await evalValue(this.input, parse);              this.value = input;              if (   this.options.enabled                 && this.value)                 this.p4212 = this.value.copy();                       }           this.y4216();           this.n4101(parse,         [             ['type', this.outputType()]         ]);           this.validate();          return this;     }        x3633()     {         return this.value              ? this.value.copy()              : null;     }        iterateCache(parse, from)     {         this.p4212 = null;          super.iterateCache(parse, from);     } } 


class q1862 extends i2044 {     frozen = false;      z3821 = NULL;        constructor(nodeId, options)     {         super(t1066, nodeId, options);     }            reset()     {         super.reset();          this.frozen = false;     }        copy()     {         const copy = new q1862(this.nodeId, this.options);          copy.n3359(this);          if (this.value) copy.value = this.value.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const repeat = parse.repeats.find(r => r.repeatId == this.z3821);           if (      repeat                && repeat.currentIteration == 0             || !this.options.enabled)             this.frozen = false;           if (!this.frozen)         {             this.value =                  this.input                  ? (await this.input.eval(parse)).x3633()                 : new g4217();              this.frozen = true;              this.y4216();         }           this.n4101(parse,         [             ['type', this.outputType()]         ]);           this.validate();          return this;     }        x3633()     {         return this.value              ? this.value.copy()              : null;     } } 


class o1878 extends i2044 {     interval = null;    k3680    = null;     loop     = null;        constructor(nodeId, options)     {         super(n1067, nodeId, options);     }            reset()     {         super.reset();          this. interval = null;         this.k3680    = null;         this. loop     = null;     }        copy()     {         const copy = new o1878(this.nodeId, this.options);          copy.n3359(this);          if (this. interval) copy. interval = this. interval.copy();         if (this.k3680   ) copy.k3680    = this.k3680   .copy();         if (this. loop    ) copy. loop     = this. loop    .copy();          return copy;     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;           const  interval = await evalNumberValue(this. interval, parse);         const k3680    = await evalNumberValue(this.k3680,    parse);         const  loop     = await evalNumberValue(this. loop,     parse);                       if (this.loop.type != t1091) h3357(this.loop, this);          if (k3680.value == 0)             return this;           if (this.input)         {             this.input.o4089(parse, this, true);              const input = await evalValue(this.input, parse);              this.value = input ? input : new g4217();              if (this.loop.type != t1091)                 this.loop.t4087(parse);         }         else             this.value = new g4217();                       this.n4101(parse,         [             ['value',    this.value],             ['interval', interval  ]         ]);                   this.y4216();           this.validate();          return this;     }        x3633()     {         return this.value.copy();     }        isValid()     {         return super.isValid()             && this.interval && this.interval.isValid()             && this.k3680   && this.k3680  .isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this. interval) this. interval.r4088(parse);         if (this.k3680   ) this.k3680   .r4088(parse);         if (this. loop    ) this. loop    .r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this. interval) this. interval.o4089(parse, from, force);         if (this.k3680   ) this.k3680   .o4089(parse, from, force);         if (this. loop    ) this. loop    .o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this. interval) this. interval.t4087(parse);         if (this.k3680   ) this.k3680   .t4087(parse);         if (this. loop    ) this. loop    .t4087(parse);     } } 


class c1880 extends i2044 {     name = null;        constructor(nodeId, options)     {         super(i1068, nodeId, options);     }            reset()     {         super.reset();          this.name = null;     }        copy()     {         const copy = new c1880(this.nodeId, this.options);          copy.n3359(this);          if (this.value) copy.value = this.value.copy();         if (this.name ) copy.name  = this.name .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value =              this.input              ? (await this.input.eval(parse)).x3633()              : new g4217();                   const name = await evalTextValue(this.name, parse);           if (   this.options.enabled             && this.value.isValid())         {             this.value.valueId = name.value;         }           this.y4216();           this.n4101(parse,         [             ['type', this.outputType()],             ['name', name             ]         ]);           this.validate();          return this;     }        x3633()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.name && this.name.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.name) this.name.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.name) this.name.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.name) this.name.t4087(parse);     }        u3632(parse, nodeId)     {         super.u3632(parse, nodeId);          if (this.name) this.name.u3632(parse, nodeId);     } } 


class GGetListValueNames extends i2044 {             constructor(nodeId, options)     {         super(f1352, nodeId, options);     }            reset()     {         super.reset();               }        copy()     {         const copy = new GGetListValueNames(this.nodeId, this.options);          copy.n3359(this);          return copy;     }        async eval(parse)     {         if (   this.isCached())                          return this;           const input = await evalListValue(this.input, parse);           this.counts = new x2021();                                                    if (   input                 && input.items)             {                 if (this.options.enabled)                 {                     this.value = new x2021();                     this.value.objects = [];                      for (let i = 0; i < input.items.length; i++)                         this.value.items.push(new j2033(input.items[i].valueId));                      if (input.objects)                     {                         for (let i = 0; i < input.objects.length; i++)                             this.value.objects.push(input.objects[i]);                     }                 }                 else                     this.value = input.copy();             }             else                 this.value = x2021.NaN.copy();                                       this.y4216();           this.n4101(parse,          [             ['type',   this.outputListType()                   ],             ['length', new d2022(this.value.items.length)]         ]);                           if (parse.settings.l3734)         {             this.n4101(parse,             [                 ['preview', new x2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     } } 


class GListValueNames extends u2045 {     constructor(nodeId, options)     {         super(y1353, nodeId, options);     }            copy()     {         const copy = new GListValueNames(this.nodeId, this.options);          copy.n3359(this);          if (this.value) copy.value = this.value.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const e4083 = await evalListValue(this.e4083, parse);         const j4084 = await evalListValue(this.j4084, parse);                   if (   this.options.enabled             && e4083             && j4084             && e4083.items             && j4084.items)         {             for (let i = 0; i < e4083.items.length && i < j4084.items.length; i++)                 e4083.items[i].valueId = j4084.items[i].value;              this.value = e4083;         }         else if (e4083)             this.value = e4083;            this.y4216();           this.n4101(parse,         [             ['type', this.outputListType()]         ]);           this.validate();          return this;     } } 


class GObjectName extends i2044 {     name    = null;           constructor(nodeId, options)     {         super(c1354, nodeId, options);     }            reset()     {         super.reset();          this.name    = null;            }        copy()     {         const copy = new GObjectName(this.nodeId, this.options);          copy.n3359(this);          if (this.value  ) copy.value   = this.value  .copy();         if (this.name   ) copy.name    = this.name   .copy();                 return copy;     }        async eval(parse)     {                             this.value =              this.input              ? (await this.input.eval(parse)).x3633()              : new g4217();                   const name    = await evalTextValue  (this.name, parse);                          if (   this.options.enabled             && this.value.isValid()             && this.value.objects)         {             for (const a111 of this.value.objects)             {                 a111.nodeId     = this.nodeId;                 a111.objectName = name.value;                           }         }           this.y4216();           this.n4101(parse,         [             ['type',    this.outputType()],             ['name',    name             ]                    ]);           this.validate();          return this;     }        x3633()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.name    && this.name   .isValid()               }        r4088(parse)     {         super.r4088(parse);          if (this.name   ) this.name   .r4088(parse);           }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.name   ) this.name   .o4089(parse, from, force);           }        t4087(parse)     {         super.t4087(parse);          if (this.name   ) this.name   .t4087(parse);           }        u3632(parse, nodeId)     {         super.u3632(parse, nodeId);          if (this.name   ) this.name   .u3632(parse, nodeId);           } } 


class d1857 extends g2043 {     inputs = [];      value;        constructor(nodeId, options)     {         super(v1069, nodeId, options);     }            reset()     {         super.reset();          this.inputs = [];     }        copy()     {         const copy = new d1857(this.nodeId, this.options);          copy.n3359(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.value) copy.value = this.value.copy();          return copy;     }        isCached()     {         for (const input of this.inputs)             if (!input.isCached())                 return false;          return super.isCached();     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new x2021();          this.value.objects = [];           for (let i = 0; i < this.inputs.length; i++)         {             const input = await evalValue(this.inputs[i], parse);               if (   input                 && input.isValid()                 && this.options.enabled)             {                 if (g957(input.type))                 {                     if (input.condensed === true)                         this.value.items.push(input);                     else                     {                         for (const item of input.items)                             this.value.items.push(item);                     }                 }                 else                     this.value.items.push(input);             }               const inputObjects = this.d3627(input, i);                          for (const a111 of inputObjects)             {                 a111.objectId += h967 + i;                 a111.t3820 = i;             }              this.value.objects.push(...inputObjects);         }                     const bounds = getObjBounds(this.value.objects);          const singlePoint =                this.value.objects.length  == 1              && this.value.objects[0].type == g1246;          for (const a111 of this.value.objects)         {             const angle1 = i884(a111.sp0, a111.sp1);             const angle2 = i884(a111.sp0, a111.sp2);              a111.n3742(a111.sp0.x, a111.sp0.y);                          a111.sp1 = y895(a111.sp0, vector(angle1, 1));             a111.sp2 = y895(a111.sp0, vector(angle2, 1));              a111.resetSpace(bounds, singlePoint);         }                   const length = new d2022(this.value.items.length);         const type   = new j2033(m3479(this.value.items));           this.n4101(parse,         [             ['length', length],             ['type',   type  ]         ]);           if (parse.settings.l3734)         {             this.n4101(parse,             [                 ['preview', new x2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        x3633()     {         return this.value.copy();     }        isValid()     {         return !this.inputs.find(i => !i.isValid());     }        r4088(parse)     {         super.r4088(parse);          this.inputs.forEach(i => i.r4088(parse));     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          this.inputs.forEach(i => i.o4089(parse, from, force));     }        o3629(parse, z3821)     {         this.inputs.forEach(i => i.o3629(parse, z3821));     }        j3630(parse, nodeId)     {         this.inputs.forEach(i => i.j3630(parse, nodeId));     }        t4087(parse)     {         this.inputs.forEach(i => i.t4087(parse));     }        iterateCache(parse, from)     {         for (const input of this.inputs)         {             if (   input.type == c1080                 || input.type == v1069                 || input.type == p1065)                 input.iterateCache(parse, from);         }     }        u3632(parse, nodeId)     {         this.inputs.forEach(i => i.u3632(parse, nodeId));     } }


class w1858 extends i2044 {             constructor(nodeId, options)     {         super(j1070, nodeId, options);     }            reset()     {         super.reset();               }        copy()     {         const copy = new w1858(this.nodeId, this.options);          copy.n3359(this);                    return copy;     }        async eval(parse)     {         if (   this.isCached())                          return this;           this.value = new x2021();         this.value.condensed = true;          let length = 0;           const input = await evalListValue(this.input, parse);                                                    if (input)             {                 length = input.items.length;                                                       if (   g957(input.type)                     && this.options.enabled)                 {                     for (const item of input.items)                     {                         const copy = item.copy();                          this.value.items.push(copy);                                              }                 }                 else                 {                     const copy = input.copy();                      this.value.items.push(copy);                     this.value.objects.push(...copy.objects);                 }             }             else                 this.value = new x2021();                                       this.y4216();               this.n4101(parse,         [             ['length', new d2022(length)                              ],             ['type', new j2033(m3479(this.value.items))]         ]);                   this.validate();          return this;     } } 


class j1860 extends i2044 {     indices     = null;                  constructor(nodeId, options)     {         super(m1071, nodeId, options);     }            reset()     {         super.reset();          this.indices = null;                   }        copy()     {         const copy = new j1860(this.nodeId, this.options);          copy.n3359(this);          if (this.indices) copy.indices = this.indices.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input   = await evalListValue(this.input,   parse);         const indices = await evalListValue(this.indices, parse);           this.value = new x2021();          let length = 0;                                                            if (   input                 && indices                 && input.items)             {                 length = input.items.length;                   if (this.options.enabled)                 {                     for (let i = 0; i < indices.items.length; i++)                     {                         const item = input.items[Math.round(indices.items[i].value)];                                                  this.value.items.push(item ? item.copy() : new g4217());                                                  if (   item                             && item.objects                             && this.value.objects)                              this.value.objects.push(...item.objects);                     }                 }             }             else                 this.value = x2021.NaN.copy();                               this.y4216();           this.n4101(parse,         [             ['type',    this.outputListType()                   ],             ['length',  new d2022(this.value.items.length)],              ['indices', indices                                 ]         ]);                   if (parse.settings.l3734)         {             this.n4101(parse,             [                 ['preview', new x2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.indices && this.indices.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.indices) this.indices.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.indices) this.indices.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.indices) this.indices.t4087(parse);     } } 


class g1873 extends u2045 {     name = null;            constructor(nodeId, options)     {         super(v1072, nodeId, options);     }            reset()     {         super.reset();          this.name  = null;     }        copy()     {         const copy = new g1873(this.nodeId, this.options);          copy.n3359(this);          if (this.name) copy.name = this.name.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const e4083 = await evalValue    (this.e4083, parse);         const j4084 = await evalValue    (this.j4084, parse);         const name   = await evalTextValue(this.name,   parse);           if (   e4083             && name)         {             let nameValue = name.value.trim();               if (g957(e4083.type))             {                 this.value = new x2021();                  if (this.options.enabled)                 {                     for (let i = 0; i < e4083.items.length; i++)                     {                         const item = e4083.items[i];                          if (   j4084                             && name.value.trim() != '')                             item.customParams.push([nameValue, j4084]);                                                   if (   item                             && item[nameValue]                             && item[nameValue].objects                              && this.value.objects)                             this.value.objects.push(...item[nameValue].objects);                     }                 }                 else                     this.value = e4083;             }             else             {                 this.value = e4083;                  if (   j4084                     && nameValue != ''                     && this.options.enabled)                     this.value.customParams.push([nameValue, j4084]);             }         }         else         {             this.value = new g4217();         }           this.y4216();           this.n4101(parse,         [             ['type', this.outputType()],             ['name', name             ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.name && this.name.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.name) this.name.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.name) this.name.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.name) this.name.t4087(parse);     } } 


class v1874 extends i2044 {     name = null;            constructor(nodeId, options)     {         super(v1073, nodeId, options);     }            reset()     {         super.reset();          this.name  = null;     }        copy()     {         const copy = new v1874(this.nodeId, this.options);          copy.n3359(this);          if (this.name) copy.name = this.name.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalValue    (this.input, parse);         const name  = await evalTextValue(this.name,  parse);           if (   input             && name             && name.value.trim() != '')         {             if (this.options.enabled)             {                 if (g957(input.type))                 {                     this.value = new x2021();                      for (let i = 0; i < input.items.length; i++)                         this.value.items.push(getGetParamValue(input.items[i], name));                 }                 else                     this.value = getGetParamValue(input, name);             }             else                 this.value = input.copy();         }         else         {             this.value = new g4217();         }           this.y4216();           const type = this.outputType();                  this.n4101(parse,         [             ['value', this.value],             ['type',  type      ],             ['name',  name      ]         ]);                   if (type.value == t1143 && parse.settings.u3733)         {             this.n4101(parse,             [                 ['preview', this.value]             ],             true);         }         else if (g957(type.value)   && parse.settings.l3734)         {             this.n4101(parse,             [                 ['preview', new x2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.name && this.name.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.name) this.name.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.name) this.name.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.name) this.name.t4087(parse);     } }    function getGetParamValue(input, name) {     let nameValue = name.value.trim();       if (    input         && !input[nameValue])     {              if (input[name.value.toUpperCase()]) nameValue = name.value.toUpperCase();         else if (input[name.value.toLowerCase()]) nameValue = name.value.toLowerCase();     }       let value = null;      if (   input         && input[nameValue])     {         value = input[nameValue];     }     else     {         const customIndex = input.customParams.findIndex(p => p[0] == nameValue);          value =             customIndex > -1             ? input.customParams[customIndex][1]             : new g4217();     }       if (   input         && input[nameValue]         && input[nameValue].objects          && this.value.objects)         value.objects.push(...input[nameValue].objects);       return value; }


class k1877 extends i2044 {     start       = null;     end         = null;                  constructor(nodeId, options)     {         super(w1074, nodeId, options);     }            reset()     {         super.reset();          this.start       = null;         this.end         = null;               }        copy()     {         const copy = new k1877(this.nodeId, this.options);          copy.n3359(this);          if (this.start) copy.start = this.start.copy();         if (this.end  ) copy.end   = this.end  .copy();          return copy;     }        async eval(parse)     {         if (   this.isCached())                          return this;           const input = await evalListValue  (this.input, parse);         const start = await evalNumberValue(this.start, parse);         const end   = await evalNumberValue(this.end,   parse);           let length = 0;                                                                this.value = new x2021();             this.value.objects = [];               if (   input                 && start                 && end)             {                 if (input.items)                 {                     length = input.items.length;                       const _end =                         end.isValid()                         ? end                         : new d2022(input.items.length);                       if (this.options.enabled)                     {                         const endValue =                              _end.value < 0                             ? length + _end.value                             : _end.value;                          if (start.value < endValue)                         {                             for (let i = start.value, j = 0; i < endValue; i++, j++)                             {                                 const item = input.items[i];                                                                  this.value.items.push(item ? item.copy() : new g4217());                                                                  if (   item                                     && this.value.objects                                     && item.objects)                                 {                                     item.objects.forEach(o => o.t3820 = j);                                     this.value.objects.push(...item.objects);                                 }                             }                         }                         else                             this.value = x2021.NaN.copy();                     }                     else                         this.value = input.copy();                 }                 else                     this.value = x2021.NaN.copy();             }                                   this.y4216();           this.n4101(parse,         [             ['type',       this.outputListType()                          ],             ['length',     new d2022(this.value.items.length)       ],              ['fullLength', new d2022(input ? input.items.length : 0)],              ['start',      start                                          ],             ['end',        end                                            ]         ]);                   if (parse.settings.l3734)         {             this.n4101(parse,             [                 ['preview', new x2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.start && this.start.isValid()             && this.end   && this.end  .isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.start) this.start.r4088(parse);         if (this.end  ) this.end  .r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.start) this.start.o4089(parse, from, force);         if (this.end  ) this.end  .o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.start) this.start.t4087(parse);         if (this.end  ) this.end  .t4087(parse);     } } 


class f1879 extends i2044 {     counts      = null;     indices     = null;                  constructor(nodeId, options)     {         super(g1075, nodeId, options);     }            reset()     {         super.reset();          this.counts  = null;         this.indices = null;                       }        copy()     {         const copy = new f1879(this.nodeId, this.options);          copy.n3359(this);          if (this.counts ) copy.counts  = this.counts .copy();         if (this.indices) copy.indices = this.indices.copy();          return copy;     }        async eval(parse)     {         if (   this.isCached())                          return this;           const input = await evalListValue(this.input, parse);                                                    this.counts  = new x2021();             this.indices = new x2021();                           if (input)             {                 if (this.options.enabled)                 {                     this.value = new x2021();                      for (let i = 0; i < input.items.length; i++)                     {                         const item       = input.items[i];                         const foundIndex = this.value.items.findIndex(i => i.equals(item));                          if (foundIndex < 0)                         {                             this.value.items.push(item.copy());                              if (   this.value.objects                                 && item.objects)                                 this.value.objects.push(...item.objects);                              this.counts .items.push(new d2022(1));                             this.indices.items.push(new x2021([new d2022(i)]));                         }                         else                         {                             this.counts .items[foundIndex].value++;                             this.indices.items[foundIndex].items.push(new d2022(i));                         }                     }                 }                 else                     this.value = input.copy();             }             else                 this.value = new x2021();                               this.y4216();           this.n4101(parse,         [             ['type',    this.outputListType()                   ],             ['length',  new d2022(this.value.items.length)],             ['counts',  this.counts                             ],             ['indices', this.indices                            ]         ]);                   if (parse.settings.l3734)         {             this.n4101(parse,             [                 ['preview', new x2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }                                                                                                                                        } 


class x1868 extends i2044 {     indices = null;            constructor(nodeId, options)     {         super(q1349, nodeId, options);     }            reset()     {         super.reset();          this.indices = null;     }        copy()     {         const copy = new x1868(this.nodeId, this.options);          copy.n3359(this);          if (this.indices) copy.indices = this.indices.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input   = await evalListValue(this.input,   parse);         const indices = await evalListValue(this.indices, parse);           this.value         = new x2021();         this.value.objects = [];           if (   input             && input.items)         {             if (   this.options.enabled                 && indices                 && input.items                 && indices.items                 && input.items.length == indices.items.length)             {                 this.value.items = new Array(input.items.length);                  for (let i = 0; i < input.items.length; i++)                     this.value.items[i] = input.items[indices.items[i].value];                                   for (let i = 0; i < this.value.items.length; i++)                 {                     const item = this.value.items[i];                      if (   item.objects                         && this.value.objects)                     {                         const objects = ordered.objects.filter(o => o.t3820 == t3820).map(o => o.copy());                         objects.forEach(o => o.t3820 = i);                          this.value.objects.push(...objects);                     }                 }             }             else                 this.value = input.copy();         }         else             this.value = new x2021();           this.y4216();           this.n4101(parse,         [             ['type',    this.outputListType()],             ['indices', indices              ]         ]);                   if (parse.settings.l3734)         {             this.n4101(parse,             [                 ['preview', new x2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.indices && this.indices.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.indices) this.indices.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.indices) this.indices.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.indices) this.indices.t4087(parse);     } }


class e1869 extends i2044 {     offset = null;            constructor(nodeId, options)     {         super(f1350, nodeId, options);     }            reset()     {         super.reset();          this.offset = null;     }        copy()     {         const copy = new e1869(this.nodeId, this.options);          copy.n3359(this);          if (this.offset) copy.offset = this.offset.copy();          return copy;     }        async eval(parse)     {         if (   this.isCached())                          return this;           const input  = await evalListValue  (this.input,  parse);         const offset = await evalNumberValue(this.offset, parse);           let length = 0;                       this.value = new x2021();         this.value.objects = [];           if (   input             && offset)         {             if (input.items)             {                 length = input.items.length;                  if (this.options.enabled)                 {                     let _offset = offset.value % input.items.length;                     while (_offset < 0) _offset += input.items.length;                      let j = 0;                     for (let i = _offset; i < input.items.length; i++, j++)                         this.addItem(input, i, j);                      for (let i = 0; i < _offset; i++, j++)                         this.addItem(input, i, j);                 }                 else                     this.value = input.copy();             }             else                 this.value = x2021.NaN.copy();         }           this.y4216();           this.n4101(parse,         [             ['type',       this.outputListType()                          ],             ['length',     new d2022(this.value.items.length)       ],              ['offset',     offset                                         ]         ]);                   if (parse.settings.l3734)         {             this.n4101(parse,             [                 ['preview', new x2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        addItem(input, i, j)     {         const item = input.items[i];          this.value.items.push(item ? item.copy() : new g4217());                  if (   item             && this.value.objects             && input.objects)         {                          item.objects.forEach(o => o.t3820 = j);              this.value.objects.push(...item.objects);         }     }        isValid()     {         return super.isValid()             && this.offset && this.offset.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.offset) this.offset.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.offset) this.offset.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.offset) this.offset.t4087(parse);     } } 


class l1870 extends i2044 {     constructor(nodeId, options)     {         super(b1076, nodeId, options);     }            reset()     {         super.reset();     }        copy()     {         const copy = new l1870(this.nodeId, this.options);          copy.n3359(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalValue(this.input, parse);           if (input)         {             if (this.options.enabled)             {                 this.value = new x2021();                 this.value.objects = [];                  for (let i = input.items.length-1; i >= 0; i--)                     this.value.items.push(input.items[i]);                  if (input.objects)                 {                     for (let i = input.objects.length-1; i >= 0; i--)                         this.value.objects.push(input.objects[i]);                 }             }             else                 this.value = input.copy();         }         else             this.value = x2021.NaN.copy();               this.y4216();           this.n4101(parse,          [             ['type',   this.outputListType()                   ],             ['length', new d2022(this.value.items.length)]         ]);                           if (parse.settings.l3734)         {             this.n4101(parse,             [                 ['preview', new x2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     } } 


class GBuckleList extends i2044 {     amount;        constructor(nodeId, options)     {         super(q1351, nodeId, options);     }            reset()     {         super.reset();          this.buckle = null;     }        copy()     {         const copy = new GBuckleList(this.nodeId, this.options);          copy.n3359(this);          if (this.amount) copy.amount = this.amount.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalListValue  (this.input,  parse);         const amount = await evalNumberValue(this.amount, parse);          amount.value = Math.round(amount.value);                           if (   input             && input.isValid())         {             const _amount = Math.min(amount.value + 1, Math.floor(input.items.length/2));              if (this.options.enabled)             {                 const temp1 =                  [                     ...input.items.slice(input.items.length - _amount).map(i => i.value),                     ...input.items.slice(0, _amount)                  .map(i => i.value).map(i => i - input.items[0].value + input.items.at(-1).value)                 ];                  const temp2 =                  [                     ...input.items.slice(input.items.length - _amount).map(i => i.value).map(i => i - input.items.at(-1).value + input.items[0].value),                     ...input.items.slice(0, _amount)                  .map(i => i.value)                 ];                  l952(                     temp1.length == temp2.length,                     'error building list edge blend');                                   const temp = [];                  for (let i = 0; i < _amount*2; i++)                     temp.push(new d2022(b1035(temp1[i], temp2[i], i/(_amount*2-1))));                   this.value = new x2021();                  for (let i = 0; i < _amount; i++)                     this.value.items.push(temp[_amount + i]);                  for (let i = _amount; i < input.items.length - _amount; i++)                     this.value.items.push(input.items[i]);                  for (let i = 0; i < _amount; i++)                     this.value.items.push(temp[i]);             }             else                 this.value = input;         }         else             this.value = x2021.NaN.copy();               this.n4101(parse,          [             ['length', new d2022(this.value.items.length)],             ['amount', amount                                  ]         ]);                           if (parse.settings.l3734)         {             this.n4101(parse,             [                 ['preview', new x2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     } } 


class a1875 extends i2044 {     condition     = null;     reverse       = null;     indices       = null;      t4213 = null;                   constructor(nodeId, options)     {         super(w1077, nodeId, options);     }            reset()     {         super.reset();          this.condition = null;         this.reverse   = null;         this.indices   = null;     }        copy()     {         const copy = new a1875(this.nodeId, this.options);          copy.n3359(this);          if (this.condition) copy.condition = this.condition.copy();         if (this.reverse  ) copy.reverse   = this.reverse  .copy();         if (this.indices  ) copy.indices   = this.indices  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input   = await evalListValue  (this.input,   parse);         const reverse = await evalNumberValue(this.reverse, parse);           this.value         = new x2021();         this.value.objects = [];           let maxColumns = 0;          this.indices = new x2021();           if (   input             && reverse)         {             if (this.options.enabled)             {                 if (  !this.condition                     || this.condition.t3768)                 {                     if (this.condition)                         await this.condition.eval(parse);                      const conditionNode =                          this.condition                         ? this.condition.t3768(parse)                         : null;                       if (  !this.condition                         || conditionNode)                     {                         const g4214 = reverse.value > 0 ? -1 : 1;                         const r4215          = [...input.items];                           [ input       .items,                            this.indices.items ] = await asyncSort(                             parse,                              r4215,                              this.condition                              ? conditionNode                              : null,                                      this,                             this.condition,                              g4214);                           input.items.forEach(i => maxColumns = Math.max(maxColumns, g957(i.type) ? i.items.length : 1));                                                   for (let i = 0; i < input.items.length; i++)                         {                             const row       = input   .items[i];                             const t3820 = r4215.indexOf(row);                              this.value.items.push(row.copy());                              if (   row.objects                                 && this.value.objects)                             {                                 const objects = input.objects.filter(o => o.t3820 == t3820).map(o => o.copy());                                 objects.forEach(o => o.t3820 = i);                                  this.value.objects.push(...objects);                             }                         }                     }                 }                 else                 {                     this.value   = input;                     this.indices = new x2021(Array.from(Array(input.items.length).keys()).map(i => new d2022(i)));                 }             }             else             {                 this.value   = input;                 this.indices = new x2021(Array.from(Array(input.items.length).keys()).map(i => new d2022(i)));             }         }         else         {             this.value   = new x2021();             this.indices = new x2021();         }           this.y4216();           this.n4101(parse,         [             ['type',    this.outputListType()                   ],             ['length',  new d2022(this.value.items.length)],             ['reverse', reverse                                 ],             ['indices', this.indices                            ]         ]);                   if (parse.settings.l3734)         {             this.n4101(parse,             [                 ['preview', new x2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && (!this.condition || this.condition.isValid())             && this.reverse && this.reverse.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.condition) this.condition.r4088(parse);         if (this.reverse  ) this.reverse  .r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.condition) this.condition.o4089(parse, from, force);         if (this.reverse  ) this.reverse  .o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.condition) this.condition.t4087(parse);         if (this.reverse  ) this.reverse  .t4087(parse);     } }    async function asyncSort(parse, r4215, conditionNode, node, condition, g4214) {     const q3569 = conditionNode ? conditionNode.input : null;       const sorted  = [];       for (let i = 0; i < r4215.length; i++)     {         const item = r4215[i];          const cond = await getSortCondition(parse, conditionNode, node, condition, item);         if (!cond) return [r4215, [...r4215.keys()]];                  const condValue = cond.x3633();                   if (   condValue.type != t1091             && condValue.type != t1143)              return [r4215, [...r4215.keys()]];          sorted.push({item, condition: condValue.value, index: i});     }       sorted.sort((a, b) =>     {         if (   typeof(a.condition) == 'number'             && typeof(b.condition) == 'number')         {             if (a.condition < b.condition) return -1*g4214;             if (a.condition > b.condition) return  1*g4214;         }         else if (typeof(a.condition) == 'string'               && typeof(b.condition) == 'string')         {             if (a.condition.localeCompare(b.condition) < 0) return -1*g4214;             if (a.condition.localeCompare(b.condition) > 0) return  1*g4214;         }          return 0;     });       if (conditionNode)         conditionNode.input = q3569;       return [ sorted.map(item => item.item),               sorted.map(item => new d2022(item.index)) ]; }    async function getSortCondition(parse, conditionNode, node, condition, item) {     if (!conditionNode)         return item;          conditionNode.reset();      conditionNode.input = item.copy();     condition.o4089(parse, node, true);       return await condition.eval(parse); }


class g1861 extends i2044 {     condition = null;     indices   = null;                  constructor(nodeId, options)     {         super(h1085, nodeId, options);     }            reset()     {         super.reset();          this.condition = null;         this.indices   = null;     }        copy()     {         const copy = new g1861(this.nodeId, this.options);          copy.n3359(this);          if (this.condition) copy.condition = this.condition.copy();         if (this.indices  ) copy.indices   = this.indices  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalListValue(this.input, parse);           this.value         = new x2021();         this.value.objects = [];          let maxColumns = 0;                   this.indices = new x2021();           if (input)         {             if (this.options.enabled)             {                 if (  !this.condition                     || this.condition.t3768)                 {                     if (this.condition)                         await this.condition.eval(parse);                      const conditionNode =                          this.condition                         ? this.condition.t3768(parse)                         : null;                       if (  !this.condition                         || conditionNode)                     {                         const unfiltered = [...input.items];                           [input.items, this.indices.items] = await asyncFilter(                             parse,                              unfiltered,                              conditionNode,                             this,                             this.condition);                           input.items.forEach(i => maxColumns = Math.max(maxColumns, g957(i.type) ? i.items.length : 1));                                                   for (let i = 0; i < input.items.length; i++)                         {                             const row       = input   .items[i];                             const t3820 = unfiltered.indexOf(row);                              this.value.items.push(row.copy());                              if (   row.objects                                 && this.value.objects)                             {                                 const objects = input.objects.filter(o => o.t3820 == t3820).map(o => o.copy());                                 objects.forEach(o => o.t3820 = i);                                  this.value.objects.push(...objects);                             }                         }                     }                 }                 else                     this.value = await evalListValue(this.input, parse);             }             else                 this.value = input.copy();         }         else             this.value = new x2021();           this.y4216();           this.n4101(parse,         [             ['type',    this.outputListType()                   ],             ['length',  new d2022(this.value.items.length)],             ['indices', this.indices                            ]         ]);                   if (parse.settings.l3734)         {             this.n4101(parse,             [                 ['preview', new x2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && (!this.condition || this.condition.isValid());     }        r4088(parse)     {         super.r4088(parse);          if (this.condition) this.condition.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.condition) this.condition.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.condition) this.condition.t4087(parse);     } }    async function asyncFilter(parse, array, conditionNode, node, condition) {     const q3569 = conditionNode ? conditionNode.input : null;      const filtered = [];     const indices  = [];      for (let i = 0; i < array.length; i++)     {         const item = array[i];          const cond = await getFilterCondition(parse, conditionNode, node, condition, item);         if (!cond) return array;                  const condValue = cond.x3633();                   if (   condValue.type == t1091             && condValue.value > 0)         {             filtered.push(item);             indices .push(new d2022(i));         }     }      if (conditionNode)         conditionNode.input = q3569;      return [filtered, indices]; }    async function getFilterCondition(parse, conditionNode, node, condition, item) {     if (!conditionNode)         return item;          conditionNode.reset();      const value = conditionNode.x3633();     if (!value) return item;      if (   value.type == item.type         || value.type == u1087)     {         conditionNode.input = item.copy();         condition.o4089(parse, node, true);      }      return await condition.eval(parse); }


class v1856 extends i2044 {     index       = null;                  constructor(nodeId, options)     {         super(p1078, nodeId, options);     }            reset()     {         super.reset();          this.index       = null;               }        copy()     {         const copy = new v1856(this.nodeId, this.options);          copy.n3359(this);          if (this.index) copy.index = this.index.copy();          return copy;     }        async eval(parse)     {         if (   this.isCached())                          return this;           const input = await evalListValue  (this.input, parse);         const index = await evalNumberValue(this.index, parse);                   this.value = new x2021();          let maxColumns = 0;                                                    if (   input                 && index)             {                 if (isTable(input))                 {                     input.items.forEach(i => maxColumns = Math.max(maxColumns, i.items.length));                      if (index.value < maxColumns)                     {                         const valueIds = [];                          for (let i = 0; i < input.items.length; i++)                         {                             const row = input.items[i];                              if (index.value < row.items.length)                             {                                 const item = row.items[index.value].copy();                                  item.valueId = s1483(                                     item.valueId,                                      id => valueIds.includes(id),                                     item.valueId,                                     '',                                     1,                                     true);                                                                 this.value.items.push(item);                                  p949(valueIds, item.valueId);                                  if (   this.value.objects                                      && row.items[index.value].objects)                                     this.value.objects.push(...row.items[index.value].objects);                             }                         }                     }                 }                 else if (g957(input.type))                 {                     this.value = input.copy();                     maxColumns = 1;                 }             }                               this.y4216();          this.n4101(parse,         [             ['type',    this.outputListType()                   ],             ['length',  new d2022(this.value.items.length)],             ['columns', new d2022(maxColumns, 0)          ],             ['index',   index                                   ]         ]);               if (parse.settings.l3734)         {             this.n4101(parse,             [                 ['preview', new x2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.index && this.index.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.index) this.index.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.index) this.index.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.index) this.index.t4087(parse);     } }    function isTable(value) {     if (!g957(value.type))         return false;      for (const item of value.items)     {         if (!g957(item.type))             return false;     }      return true; }


class y1855 extends i2044 {     column;     row;            constructor(nodeId, options)     {         super(o1079, nodeId, options);     }            reset()     {         super.reset();          this.column = null;         this.row    = null;     }        copy()     {         const copy = new y1855(this.nodeId, this.options);          copy.n3359(this);          if (this.column) copy.column = this.column.copy();         if (this.row   ) copy.row    = this.row   .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalListValue  (this.input,  parse);         const column = await evalNumberValue(this.column, parse);         const row    = await evalNumberValue(this.row,    parse);           let columns = 0;         let rows    = 0;          if (   input             && column             && row)         {             if (isTable(input))             {                 rows = input.items.length;                  input.items.forEach(i => columns = Math.max(columns, i.items ? i.items.length : null));                  if (row.value < rows)                 {                     const _row = input.items[row.value];                      if (column.value < columns)                         this.value = _row.items[column.value].copy();                     else                         this.value = new g4217();                 }                 else                     this.value = new g4217();             }             else                 this.value = new g4217();         }         else             this.value = new g4217();           this.n4101(parse,         [                          ['type',    this.outputType()          ],             ['columns', new d2022(columns, 0)],             ['rows',    new d2022(rows   , 0)]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.column && this.column.isValid()             && this.row    && this.row   .isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.column) this.column.r4088(parse);         if (this.row   ) this.row   .r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.column) this.column.o4089(parse, from, force);         if (this.row   ) this.row   .o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.column) this.column.t4087(parse);         if (this.row   ) this.row   .t4087(parse);     } }


class j1864 extends i2044 {     p4212 = null;        constructor(nodeId, options)     {         super(c1080, nodeId, options);     }        reset()     {         super.reset();          this.p4212 = null;     }        copy()     {         const copy = new j1864(this.nodeId, this.options);                  copy.n3359(this);          if (this.input) copy.input = this.input.copy();                  for (const key of this.keys())         {             if (this[key] instanceof i2050)                 Object.assign(copy, {[key]: this[key]});         }          return copy;     }        f4242(p2992)     {         let param =                this.value             && this.value.items             && p2992 != 'value'             ? this.value.items.find(i => i.valueId == p2992)             : null;          if (!param)             param = this[p2992];          return param;     }        async eval(parse)     {         if (   this.isCached()             && this.p4212)             return this;           const input = await evalListValue(this.input, parse);            if (this.p4212)            this.value = this.p4212.copy();          else         {             this.value = input ?? new g4217();             this.p4212 = this.value.copy();         }           this.e3096 = [];           if (    this.value.isValid()             &&  this.value.items             && !isEmpty(this.value.items))         {             for (let i = 0; i < this.value.items.length; i++)             {                 const item = this.value.items[i];                                  let valueId =                      item.valueId.trim() != ''                     ? item.valueId                     : i.toString();                  valueId = s1483(                     valueId,                     id => this.value.items.find(i =>                            i != item                          && i.valueId == id));                  Object.assign(this, {[valueId]: item});                 this.n4101(parse, [[valueId, item]], true);                  item.sortId = i;             }              this.e3096.sort((a, b) => a.sortId - b.sortId);               this.n4101(parse, [['-type-', this.outputType()]], true);         }         else             this.n4101(parse, [['-type-', new j2033(y1056)]], true);           this.y4216();           this.validate();          return this;     }                x3633()     {         return this.value.copy();     }        iterateCache(parse, from)     {         this.p4212 = null;     } }


class r1871 extends g2043 {     inputs = [];      index = null;            constructor(nodeId, options)     {         super(x1083, nodeId, options);     }        reset()     {         super.reset();          this.inputs = [];                  this.index = null;     }           copy()     {         const copy = new r1871(this.nodeId, this.options);          copy.n3359(this);                  copy.inputs = this.inputs.map(i => i.copy());          if (this.index) copy.index = this.index.copy();         if (this.value) copy.value = this.value.copy();          return copy;     }        isCached()     {         for (const input of this.inputs)             if (!input.isCached())                 return false;          return super.isCached();     }        async eval(parse)     {         if (this.isCached())             return this;          let index  = await evalNumberValue(this.index, parse);         let length = 0;           const inputs = [];          for (let i = 0; i < this.inputs.length; i++)             inputs.push(await evalValue(this.inputs[i], parse));           if (inputs.length > 0)         {             length = inputs.length;               index =                     index.isValid()                 && index.value >= -inputs.length                 && index.value <   inputs.length                 ? new d2022(Math.round(index.value))                 : new d2022(0);                           if (   index.isValid()                 && index.value >= -inputs.length                 && index.value <   inputs.length)             {                 this.value = inputs.at(index.value);                                   if (this.value.objects)                 {                     for (let i = 0; i < this.value.objects.length; i++)                     {                         const a111 = this.value.objects[i];                          a111.nodeId = this.nodeId;                         a111.listId = -1;                          a111.objectId = this.nodeId;                                                  if (a111.objectId != NULL)                              a111.objectId += '/';                          a111.objectId += index.value.toString();                          if (this.value.objects.length > 1)                         {                             a111.objectId += '/';                             a111.objectId += i.toString();                         }                     }                 }             }             else             {                 this.value = new g4217();             }         }         else         {             this.value = new g4217();         }                   const type = this.outputType();          this.n4101(parse,         [             ['value',      type == x1168                          || type == k1178                          ? this.value                          : new g4217()      ],             ['type',    type                   ],             ['length',  new d2022(length)],             ['index',   index                  ]         ]);           if (type.value == t1143 && parse.settings.u3733)         {             this.n4101(parse,             [                 ['preview', this.value]             ],             true);         }         else if (g957(type.value) && parse.settings.l3734)         {             this.n4101(parse,             [                 ['preview', new x2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return !this.inputs.find(i => !i.isValid())             &&  this.index && this.index.isValid();     }        r4088(parse)     {         super.r4088(parse);          this.inputs.forEach(i => i.r4088(parse));          if (this.index) this.index.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          this.inputs.forEach(i => i.o4089(parse, from, force));          if (this.index) this.index.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          this.inputs.forEach(i => i.t4087(parse));          if (this.index) this.index.t4087(parse);     } }


class h1872 extends i2044 {     index = null;        constructor(nodeId, options)     {         super(a1360, nodeId, options);     }        reset()     {         super.reset();          this.index = null;     }        copy()     {         const copy = new h1872(this.nodeId, this.options);                  copy.n3359(this);          if (this.input) copy.input = this.input.copy();         if (this.index) copy.index = this.index.copy();         if (this.value) copy.value = this.value.copy();          return copy;     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;                   const input = await evalListValue  (this.input, parse);         let   index = await evalNumberValue(this.index, parse);                  let  length = 0;                                    if (   input             && input.isValid()             && g957(input.type)             && input.items             && input.items.length > 0)         {             length = input.items.length;               index =                     index.isValid()                 && index.value >= -input.items.length                 && index.value <   input.items.length                 ? new d2022(Math.round(index.value))                 : new d2022(0);                           if (   index.isValid()                 && index.value >= -input.items.length                 && index.value <   input.items.length)             {                 this.value = input.items.at(index.value);                                  if (   input.objects                     && input.objects.at(index.value))                     this.value.objects = [input.objects.at(index.value)];                   if (this.value.objects)                 {                     for (let i = 0; i < this.value.objects.length; i++)                     {                         const a111 = this.value.objects[i];                          a111.nodeId = this.nodeId;                         a111.listId = -1;                          a111.objectId = this.nodeId;                                                  if (a111.objectId != NULL)                             a111.objectId += '/';                          a111.objectId += index.value.toString();                     }                 }             }             else             {                 this.value = new g4217();             }         }         else          {             this.value = new g4217();         }           const type = this.outputType();          this.n4101(parse,         [             ['value',      type == x1168                          || type == k1178                          ? this.value                          : new g4217()],             ['type',    type                   ],             ['length',  new d2022(length)],             ['index',   index                  ]         ]);           if (type.value == t1143 && parse.settings.u3733)         {             this.n4101(parse,             [                 ['preview', this.value]             ],             true);         }         else if (g957(type.value) && parse.settings.l3734)         {             this.n4101(parse,             [                 ['preview', new x2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.index && this.index.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.index) this.index.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.index) this.index.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.index) this.index.t4087(parse);     } }


class v1865 extends i2044 {     start = null;        constructor(nodeId, options)     {         super(k1081, nodeId, options);     }        reset()     {         super.reset();          this.start = null;     }        copy()     {         const copy = new v1865(this.nodeId, this.options);                  copy.n3359(this);          if (this.input) copy.input = this.input.copy();         if (this.start) copy.start = this.start.copy();                  if (this.count) copy.count = this.count.copy();          return copy;     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalListValue  (this.input, parse);         const start = await evalNumberValue(this.start, parse);                   if (input)         {             const count = input.items.length;             this.value = new d2022(count - (start.value == 0 ? 1 : 0));         }         else             this.value = d2022.NaN.copy();           this.n4101(parse,         [             ['value', this.value],             ['start', start     ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.start && this.start.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.start) this.start.r4088(parse);     }            o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.start) this.start.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.start) this.start.t4087(parse);     }     }


class GObjectCount extends i2044 {     start = null;        constructor(nodeId, options)     {         super(k1081, nodeId, options);     }        reset()     {         super.reset();          this.start = null;     }        copy()     {         const copy = new v1865(this.nodeId, this.options);                  copy.n3359(this);          if (this.input) copy.input = this.input.copy();         if (this.start) copy.start = this.start.copy();                  if (this.count) copy.count = this.count.copy();          return copy;     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalValue      (this.input, parse);         const start = await evalNumberValue(this.start, parse);                   if (input)         {             const count =                  input.objects                 ? input.objects.length                 : 0;              this.value = new d2022(count - (start.value == 0 ? 1 : 0));         }         else             this.value = d2022.NaN.copy();           this.n4101(parse,         [             ['value', this.value],             ['start', start     ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.start && this.start.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.start) this.start.r4088(parse);     }            o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.start) this.start.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.start) this.start.t4087(parse);     }     }


class r1859 extends u2045 {     first;     last;     all;        constructor(nodeId, options)     {         super(t1082, nodeId, options);     }            reset()     {         super.reset();          this.first = null;         this.last  = null;         this.all   = null;     }        copy()     {         const copy = new r1859(this.nodeId, this.options);          copy.n3359(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const e4083 = await evalListValue(this.e4083, parse);         const j4084 = await evalValue    (this.j4084, parse);               if (   e4083 && e4083.isValid()              && j4084 && j4084.isValid())         {             const indices = [];                           if (   j4084                 && j4084.isValid())             {                 for (let i = 0; i < e4083.items.length; i++)                 {                     if (e4083.items[i].equals(j4084))                         indices.push(i);                 }                     this.value = new d2022(indices.length > 0 ? 1 : 0);                  this.first = indices.length > 0 ? new d2022(indices.at( 0)) : d2022.NaN.copy();                 this.last  = indices.length > 0 ? new d2022(indices.at(-1)) : d2022.NaN.copy();                  this.all   = new x2021();                  for (const index of indices)                     this.all.items.push(new d2022(index));             }             else             {                 this.value = new d2022(1);                  this.first = d2022.NaN.copy();                 this.last  = d2022.NaN.copy();                 this.all   =   x2021.NaN.copy();             }         }         else                           {             this.value = d2022.NaN.copy();             this.first = d2022.NaN.copy();             this.last  = d2022.NaN.copy();             this.all   =   x2021.NaN.copy();         }               this.n4101(parse,         [             ['value', this.value],             ['first', this.first],             ['last',  this.last ],             ['all',   this.all  ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.first && this.first.isValid()             && this.last  && this.last .isValid()             && this.all   && this.all  .isValid();     } }


class v1863 extends g2043 {     e4083    = null;     j4084    = null;      condition = null;        constructor(nodeId, options)     {         super(w1084, nodeId, options);     }            reset()     {         super.reset();          this.e4083    = null;         this.j4084    = null;          this.condition = null;     }        copy()     {         const copy = new v1863(this.nodeId, this.options);          copy.n3359(this);          if (this.e4083   ) copy.e4083    = this.e4083   .copy();         if (this.j4084   ) copy.j4084    = this.j4084   .copy();          if (this.condition) copy.condition = this.condition.copy();          if (this.value    ) copy.value     = this.value    .copy();          return copy;     }        isCached()     {         return super.isCached()             && (!this.e4083 || this.e4083.isCached())             && (!this.j4084 || this.j4084.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;                   const e4083 = await evalValue(this.e4083, parse);         const j4084 = await evalValue(this.j4084, parse);                  const cond   = await evalNumberValue(this.condition, parse);             if (   e4083                && j4084) this.value = cond.value != 0 ? e4083 : j4084;         else if (e4083) this.value = cond.value != 0 ? e4083 : new g4217();         else if (j4084) this.value = cond.value == 0 ? j4084 : new g4217();         else             this.value = new g4217();           this.y4216();           this.n4101(parse,         [             ['type',      this.outputType()],             ['condition', cond             ]         ]);                           this.validate();          return this;     }        x3633()     {         return this.value              ? this.value.copy()               : null;     }        isValid()     {         return this.e4083    && this.e4083   .isValid()             && this.j4084    && this.j4084   .isValid()             && this.condition && this.condition.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.e4083   ) this.e4083   .r4088(parse);         if (this.j4084   ) this.j4084   .r4088(parse);         if (this.condition) this.condition.r4088(parse);     }            o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.e4083   ) this.e4083   .o4089(parse, from, force);         if (this.j4084   ) this.j4084   .o4089(parse, from, force);         if (this.condition) this.condition.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.e4083   ) this.e4083   .t4087(parse);         if (this.j4084   ) this.j4084   .t4087(parse);         if (this.condition) this.condition.t4087(parse);     }     } 


class f1899 extends g2043 {     inputs = [];        reset()     {         super.reset();          this.inputs = [];     }        t3768()     {         const conditionNodes = [];          for (const input of this.inputs)         {             const conditionNode = input.t3768();             if (conditionNode) conditionNodes.push(conditionNode);                     }          console.assert(conditionNodes.length < 2, 'Error: sort order requires not more than one order node');          return conditionNodes.length == 1              ? conditionNodes[0]              : null;     }        isCached()     {         for (const input of this.inputs)             if (!input.isCached())                 return false;          return super.isCached();     }        isValid()     {         return  this.inputs.length > 0             && !this.inputs.find(i => !i.isValid());     }        r4088(parse)     {         super.r4088(parse);          this.inputs.forEach(i => i.r4088(parse));     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          this.inputs.forEach(i => i.o4089(parse, from, force));     }        t4087(parse)     {         super.t4087(parse);          this.inputs.forEach(i => i.t4087(parse));     } } 


class y1936 extends i2044 {     constructor(nodeId, options)     {         super(g1092, nodeId, options);     }        copy()     {         const copy = new y1936(this.nodeId, this.options);                  copy.n3359(this);          copy.value = this.value;          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalNumberValue(this.input, parse);           if (input)             this.value = input;         else if (this.value)             await this.value.eval(parse);         else             this.value = d2022.NaN.copy();           this.n4101(parse,          [             ['value', this.value]         ]);           this.validate();          return this;     }        isValid()     {         return !this.input               || this.input.isValid();     } }


class GSetPrecision extends i2044 {     decimals;        constructor(nodeId, options)     {         super(y1355, nodeId, options);     }            reset()     {         super.reset();          this.decimals = null;     }        copy()     {         const copy = new GSetPrecision(this.nodeId, this.options);          copy.n3359(this);          if (this.decimals) copy.decimals = this.decimals.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new d2022(0);                   const input    = await evalNumberValue(this.input,    parse);         const decimals = await evalNumberValue(this.decimals, parse);           if (input)         {             if (this.options.enabled)             {                 if (g957(input.type))                 {                     this.value = new x2021();                      for (let i = 0; i < input.items.length; i++)                     {                         const item = input.items[i];                          this.value.items.push(                             item.type == t1091                             ? getSetPrecisionValue(item, decimals)                             : d2022.NaN.copy());                        }                 }                 else                     this.value = getSetPrecisionValue(input, decimals);             }             else                 this.value = input;         }         else             this.value = d2022.NaN.copy();           this.n4101(parse,         [             ['type',     this.outputType()],             ['value',    this.value       ],             ['decimals', decimals         ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.decimals && this.decimals.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.decimals) this.decimals.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.decimals) this.decimals.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.decimals) this.decimals.t4087(parse);     } }    function getSetPrecisionValue(input, decimals) {     l952(          input == t1091,          'input must be NUMBER_VALUE');      return new d2022(input.value, decimals.value); }


class o1943 extends i2044 {     constructor(nodeId, options)     {         super(w1093, nodeId, options);     }            copy()     {         const copy = new o1943(this.nodeId, this.options);          copy.n3359(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalNumberValue(this.input, parse);           if (input)         {             if (g957(input.type))             {                 this.value = new x2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == t1091                         ? getSignValue(item)                         : d2022.NaN.copy());                    }             }             else                 this.value = getSignValue(input); }         else             this.value = d2022.NaN.copy();           this.n4101(parse,          [             ['type', this.outputType()]         ]);           this.validate();          return this;     } }    function getSignValue(input) {     l952(          input.type == t1091,          'input.type must be NUMBER_VALUE');      return new d2022(Math.sign(input.value)); }


class p1924 extends i2044 {     constructor(nodeId, options)     {         super(z1094, nodeId, options);     }            copy()     {         const copy = new p1924(this.nodeId, this.options);          copy.n3359(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalNumberValue(this.input, parse);           if (input)         {             if (g957(input.type))             {                 this.value = new x2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == t1091                         ? getAbsoluteValue(item, this.options.enabled)                         : d2022.NaN.copy());                    }             }             else                 this.value = getAbsoluteValue(input, this.options.enabled);         }         else             this.value = d2022.NaN.copy();           this.n4101(parse,          [             ['type', this.outputType()]         ]);           this.validate();          return this;     } }    function getAbsoluteValue(input, enabled) {     l952(          input.type == t1091,          'input.type must be NUMBER_VALUE');      return enabled         ? new d2022(Math.abs(input.value), input.decimals)         : input; }


class GNegative extends i2044 {     constructor(nodeId, options)     {         super(h1356, nodeId, options);     }            copy()     {         const copy = new GNegative(this.nodeId, this.options);          copy.n3359(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalNumberValue(this.input, parse);                       if (input)         {             if (g957(input.type))             {                 this.value = new x2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == t1091                         ? getNegativeValue(item, this.options.enabled)                         : d2022.NaN.copy());                    }             }             else                 this.value = getNegativeValue(input, this.options.enabled);         }         else             this.value = d2022.NaN.copy();           this.n4101(parse,          [             ['type', this.outputType()]         ]);           this.validate();          return this;     } }    function getNegativeValue(input, enabled) {     l952(          input == t1091,          'input must be NUMBER_VALUE');      return new d2022(         (enabled ? -1 : 1) * input.value,         input.decimals); }


class p1941 extends i2044 {     type;     decimals;        constructor(nodeId, options)     {         super(e1095, nodeId, options);     }            reset()     {         super.reset();          this.type     = null;         this.decimals = null;     }        copy()     {         const copy = new p1941(this.nodeId, this.options);          copy.n3359(this);          if (this.type    ) copy.type     = this.type    .copy();         if (this.decimals) copy.decimals = this.decimals.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new d2022(0);                   const input = await evalNumberValue(this.input,    parse);         const type  = await evalNumberValue(this.type,     parse);         const dec   = await evalNumberValue(this.decimals, parse);           if (   input             && type             && dec)         {             if (g957(input.type))             {                 this.value = new x2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == t1091                         ? getRoundValue(item, type, dec, this.options.enabled)                         : d2022.NaN.copy());                    }             }             else                 this.value = getRoundValue(input, type, dec, this.options.enabled); }         else             this.value = d2022.NaN.copy();           this.n4101(parse,         [             ['_type',    this.outputType()],             ['type',     type             ],             ['decimals', dec              ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.type     && this.type    .isValid()             && this.decimals && this.decimals.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.type    ) this.type    .r4088(parse);         if (this.decimals) this.decimals.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.type    ) this.type    .o4089(parse, from, force);         if (this.decimals) this.decimals.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.type    ) this.type    .t4087(parse);         if (this.decimals) this.decimals.t4087(parse);     } }    function getRoundValue(input, type, dec, enabled) {     l952(         input.type == t1091,         'input.type must be NUMBER_VALUE');       if (!enabled)         return input;      switch (type.value)     {         case 0: return new d2022(p1015(input.value, dec.value), dec.value);         case 1: return new d2022(n1016(input.value, dec.value), dec.value);         case 2: return new d2022( q1017(input.value, dec.value), dec.value);     } }


class GQuantize extends i2044 {     type;     base;     step;     amount;        constructor(nodeId, options)     {         super(z1357, nodeId, options);     }            reset()     {         super.reset();          this.type   = null;         this.base   = null;         this.step   = null;         this.amount = null;     }        copy()     {         const copy = new GQuantize(this.nodeId, this.options);          copy.n3359(this);          if (this.type  ) copy.type   = this.type  .copy();         if (this.base  ) copy.base   = this.base  .copy();         if (this.step  ) copy.step   = this.step  .copy();         if (this.amount) copy.amount = this.amount.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new d2022(0);                   const input  = await evalNumberValue(this.input,  parse);         const type   = await evalNumberValue(this.type,   parse);         const base   = await evalNumberValue(this.base,   parse);         const step   = await evalNumberValue(this.step,   parse);         const amount = await evalNumberValue(this.amount, parse);           if (input)         {             if (g957(input.type))             {                 this.value = new x2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == t1091                         ? getQuantizeValue(item, type, base, step, amount, this.options.enabled)                         : d2022.NaN.copy());                    }             }             else                 this.value = getQuantizeValue(input, type, base, step, amount, this.options.enabled); }         else             this.value = d2022.NaN.copy();           this.n4101(parse,         [             ['_type',  this.outputType()],             ['type',   type             ],             ['base',   base             ],             ['step',   step             ],             ['amount', amount           ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.type   && this.type  .isValid()             && this.base   && this.base  .isValid()             && this.step   && this.step  .isValid()             && this.amount && this.amount.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.type  ) this.type  .r4088(parse);         if (this.base  ) this.base  .r4088(parse);         if (this.step  ) this.step  .r4088(parse);         if (this.amount) this.amount.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.type  ) this.type  .o4089(parse, from, force);         if (this.base  ) this.base  .o4089(parse, from, force);         if (this.step  ) this.step  .o4089(parse, from, force);         if (this.amount) this.amount.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.type  ) this.type  .t4087(parse);         if (this.base  ) this.base  .t4087(parse);         if (this.step  ) this.step  .t4087(parse);         if (this.amount) this.amount.t4087(parse);     } }    function getQuantizeValue(input, type, base, step, amount, enabled) {     l952(          input.type == t1091,          'input.type must be NUMBER_VALUE');           if (!enabled)         return input;       let qval;      switch (type.value)     {         case 0: qval = base.value + step.value * Math.floor((input.value - base.value) / step.value); break;         case 1: qval = base.value + step.value * Math.round((input.value - base.value) / step.value); break;         case 2: qval = base.value + step.value * Math. ceil((input.value - base.value) / step.value); break;     }      return new d2022(         input.value + (qval - input.value) * amount.value/100,         Math.max(base.decimals, step.decimals)); }


class e1944 extends i2044 {     operand;     operation;        constructor(nodeId, options)     {         super(f1096, nodeId, options);     }            reset()     {         super.reset();          this.operand   = null;         this.operation = null;     }        copy()     {         const copy = new p1941(this.nodeId, this.options);          copy.n3359(this);          if (this.operand  ) copy.operand   = this.operand  .copy();         if (this.operation) copy.operation = this.operation.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new d2022(0);                   const input   = await evalNumberValue(this.input,     parse);         const operand = await evalNumberValue(this.operand,   parse);         const op      = await evalNumberValue(this.operation, parse);           if (input)         {             if (this.options.enabled)             {                 if (g957(input.type))                 {                     this.value = new x2021();                      for (let i = 0; i < input.items.length; i++)                     {                         const item = input.items[i];                          this.value.items.push(                             item.type == t1091                             ? getSimpleMinMaxValue(item, operand, op, this.options.enabled)                             : d2022.NaN.copy());                        }                 }                 else                 {                     this.value = getSimpleMinMaxValue(input, operand, op, this.options.enabled);                 }             }             else                 this.value = input.copy();         }         else             this.value = d2022.NaN.copy();           this.n4101(parse,         [                          ['type',      this.outputType()],             ['operand',   operand          ],             ['operation', op               ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.operand   && this.operation.isValid()             && this.operation && this.operand  .isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.operand  ) this.operand  .r4088(parse);         if (this.operation) this.operation.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.operand  ) this.operand  .o4089(parse, from, force);         if (this.operation) this.operation.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.operand  ) this.operand  .t4087(parse);         if (this.operation) this.operation.t4087(parse);     } }    function getSimpleMinMaxValue(input, operand, op, enabled) {     l952(         input.type == t1091,          'input.type is ' + input.type + ', must be NUMBER_VALUE');       if (enabled)     {         op.value = Math.min(Math.max(0, Math.floor(op.value)), 1);          return new d2022(op.value == 0             ? Math.min(input.value, operand.k3703())             : Math.max(input.value, operand.k3703()));     }     else         return input; }


class i1933 extends f1899 {     operation;        constructor(nodeId, options)     {         super(g1097, nodeId, options);     }            reset()     {         super.reset();          this.operation = null;     }        copy()     {         const copy = new i1933(this.nodeId, this.options);          copy.n3359(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.operation) copy.operation = this.operation.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           let op = await evalNumberValue(this.operation, parse);          if (op) op = op.q3729();           if (this.options.enabled)             op.value = Math.min(Math.max(0, op.value), b1311.length-1);                   this.value = await evalMinMaxInputs(this.inputs, op.value, parse);                   this.n4101(parse,         [             ['operation', op        ]                      ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.operation && this.operation.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.operation) this.operation.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.operation) this.operation.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.operation) this.operation.t4087(parse);     } }    async function evalMinMaxInputs(inputs, op, parse) {     if (isEmpty(inputs))         return d2022.NaN.copy();       let value = new d2022(0);       const e3690 = await evalNumberValue(inputs[0], parse);       if (   inputs.length == 1         && e3690.type == t1091)     {         value = new d2022(-e3690.value);     }     else if (g957(e3690.type)             && !isEmpty(e3690.items))     {         value = e3690.items[0].copy();                  for (let i = 1; i < e3690.items.length; i++)         {             const item = e3690.items[i];              if (item.type == t1091)             {                 value = new d2022(                      op == 0                     ? Math.min(value.value, item.value)                     : Math.max(value.value, item.value));             }                             }     }     else     {         if (e3690.type != t1091)             return d2022.NaN.copy();          value = e3690;     }       for (let i = 1; i < inputs.length; i++)     {         const val = await evalNumberValue(inputs[i], parse);           if (g957(val.type))         {             for (const item of val.items)             {                 if (item.type == t1091)                 {                     value = new d2022(                         op == 0                         ? Math.min(value.value, item.value)                         : Math.max(value.value, item.value));                                       }                                 }         }         else         {             l952(                 val.type == t1091,                  'val.type must be NUMBER_VALUE');                              value = new d2022(                 op == 0                 ? Math.min(value.value, val.value)                 : Math.max(value.value, val.value));                       }     }       return value; }


class m1932 extends i2044 {     min = null;     max = null;            constructor(nodeId, options)     {         super(j1098, nodeId, options);     }            reset()     {         super.reset();          this.min = null;         this.max = null;     }        copy()     {         const copy = new m1932(this.nodeId, this.options);          copy.n3359(this);          if (this.min) copy.min = this.min.copy();         if (this.max) copy.max = this.max.copy();          return copy;     }        isCached()     {         return super.isCached()             && (!this.min || this.min.isCached())             && (!this.max || this.max.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;                       const input = await evalNumberValue(this.input, parse);         const min   = await evalNumberValue(this.min,   parse);         const max   = await evalNumberValue(this.max,   parse);           if (input)         {             if (g957(input.type))             {                 this.value = new x2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == t1091                         ? getLimitsValue(item, min, max, this.options.enabled)                         : d2022.NaN.copy());                    }             }             else                 this.value = getLimitsValue(input, min, max, this.options.enabled);         }         else             this.value = d2022.NaN.copy();           this.n4101(parse,         [             ['type', this.outputType()],             ['min',   min             ],             ['max',   max             ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.min && this.min.isValid()             && this.max && this.max.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.input) this.input.r4088(parse);         if (this.min  ) this.min  .r4088(parse);         if (this.max  ) this.max  .r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.input) this.input.o4089(parse, from, force);         if (this.min  ) this.min  .o4089(parse, from, force);         if (this.max  ) this.max  .o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.input) this.input.t4087(parse);         if (this.min  ) this.min  .t4087(parse);         if (this.max  ) this.max  .t4087(parse);     } }    function getLimitsValue(input, min, max, enabled) {     l952(          input.type == t1091,          'input.type must be NUMBER_VALUE');      if (!enabled)         return input;      return new d2022(         Math.min(Math.max(             min.value,             input.value),             max.value),         input.decimals); }


class d1937 extends i2044 {     min   = null;     max   = null;     power = null;            constructor(nodeId, options)     {         super(l1099, nodeId, options);     }            reset()     {         super.reset();          this.min   = null;         this.max   = null;         this.power = null;     }        copy()     {         const copy = new d1937(this.nodeId, this.options);          copy.n3359(this);          if (this.min  ) copy.min   = this.min  .copy();         if (this.max  ) copy.max   = this.max  .copy();         if (this.power) copy.power = this.power.copy();          return copy;     }        isCached()     {         return super.isCached()             && (!this.min   || this.min  .isCached())             && (!this.max   || this.max  .isCached())             && (!this.power || this.power.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;                       const input = await evalNumberValue(this.input, parse);         const min   = await evalNumberValue(this.min,   parse);         const max   = await evalNumberValue(this.max,   parse);         const power = await evalNumberValue(this.power, parse);           if (input)         {             if (g957(input.type))             {                 this.value = new x2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == t1091                         ? getNumberCurveValue(item, min, max, power, this.options.enabled)                         : d2022.NaN.copy());                    }             }             else                 this.value = getNumberCurveValue(input, min, max, power, this.options.enabled);         }         else             this.value = d2022.NaN.copy();           this.n4101(parse,         [             ['type',  this.outputType()],             ['min',   min              ],             ['max',   max              ],             ['power', power            ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.min   && this.min  .isValid()             && this.max   && this.max  .isValid()             && this.power && this.power.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.min  ) this.min  .r4088(parse);         if (this.max  ) this.max  .r4088(parse);         if (this.power) this.power.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.min  ) this.min  .o4089(parse, from, force);         if (this.max  ) this.max  .o4089(parse, from, force);         if (this.power) this.power.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.min  ) this.min  .t4087(parse);         if (this.max  ) this.max  .t4087(parse);         if (this.power) this.power.t4087(parse);     } }    function getNumberCurveValue(input, min, max, power, enabled) {     l952(         input.type == t1091,         'input.type must be NUMBER_VALUE');       if (!enabled)         return input;       let f = (input.value - min.value) / (max.value - min.value);      f = Math.pow(f, power.value);     f = min.value + f * (max.value - min.value);          return new d2022(f); }


class GNumberMap extends i2044 {     from = null;     to   = null;            constructor(nodeId, options)     {         super(x1358, nodeId, options);     }            reset()     {         super.reset();          this.from = null;         this.to   = null;     }        copy()     {         const copy = new GNumberMap(this.nodeId, this.options);          copy.n3359(this);          if (from) copy.from = this.from.copy();         if (to  ) copy.to   = this.to  .copy();          return copy;     }        isCached()     {         return super.isCached()             && (!this.from  || this.from.isCached())             && (!this.to    || this.to  .isCached());     }        async eval(parse)     {         if (this.isCached())             return this;                       const input = await evalValue    (this.input, parse);         const from  = await evalListValue(this.from,  parse);         const to    = await evalListValue(this.to,    parse);           if (   input              && input.isValid())         {             if (this.options.enabled)             {                 if (   from && from.isValid() && from.items.length > 0                     && to   && to  .isValid() && to  .items.length > 0)                 {                     if (g957(input.type))                     {                         this.value = new x2021();                                  for (let i = 0; i < input.items.length; i++)                         {                             const item = input.items[i];                                      this.value.items.push(                                 item.type == t1091                                 ? getNumberMapValue(item, from, to)                                 : d2022.NaN.copy());                            }                     }                     else                         this.value = getNumberMapValue(input, from, to);                 }                 else                     this.value = d2022.NaN.copy();             }             else                 this.value = input;         }         else             this.value = d2022.NaN.copy();           this.n4101(parse,         [             ['type', this.outputType()],             ['from', from             ],             ['to',   to               ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.from && this.from.isValid()             && this.to   && this.to  .isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.from) this.from.r4088(parse);         if (this.to  ) this.to  .r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.from) this.from.o4089(parse, from, force);         if (this.to  ) this.to  .o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.from) this.from.t4087(parse);         if (this.to  ) this.to  .t4087(parse);     } }    function getNumberMapValue(input, from, to) {     l952(         input.type == t1091,         'input.type must be NUMBER_VALUE');       const maxDec = Math.max(         from.items.reduce((max, val) => Math.max(max, val.decimals), 0),         to  .items.reduce((max, val) => Math.max(max, val.decimals), 0));       if (from.items.length == 1)         return input;             const nFromSegments = Math.floor(from.items.length-1);     let   fromIndex     = 0;      while (fromIndex < nFromSegments-1)     {         if (   input.value >= from.items[fromIndex  ]             && input.value <  from.items[fromIndex+1])             break;          fromIndex++;     }               const fromLocal =              (input.value - from.items[fromIndex].value)          / (from.items[fromIndex+1].value - from.items[fromIndex].value);      const f = fromIndex/nFromSegments + fromLocal * ((fromIndex+1)/nFromSegments - fromIndex/nFromSegments);                 const nToSegments = Math.floor(to.items.length-1);     const toIndex     = Math.min(Math.max(0, Math.floor((to.items.length-1) * f)), nToSegments-1);       if (to.items.length == 1)         return to.items[0];      else if (to.items.length > 0             && toIndex < to.items.length-1)     {         const toLocal =              nToSegments > 1             ? (f - toIndex/nToSegments) * nToSegments             : f;           const e3690 = to.items[toIndex  ];         const val1 = to.items[toIndex+1];          return new d2022(             b1035(e3690.value, val1.value, toLocal),             maxDec);     } }


class GNumberBias extends i2044 {     min    = null;     max    = null;     bias   = null;     spread = null;            constructor(nodeId, options)     {         super(l1359, nodeId, options);     }            reset()     {         super.reset();          this.min    = null;         this.max    = null;         this.bias   = null;         this.spread = null;     }        copy()     {         const copy = new GNumberBias(this.nodeId, this.options);          copy.n3359(this);          if (this.min   ) copy.min    = this.min   .copy();         if (this.max   ) copy.max    = this.max   .copy();         if (this.bias  ) copy.bias   = this.bias  .copy();         if (this.spread) copy.spread = this.spread.copy();          return copy;     }        isCached()     {         return super.isCached()             && (!this.min    || this.min   .isCached())             && (!this.max    || this.max   .isCached())             && (!this.bias   || this.bias  .isCached())             && (!this.spread || this.spread.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;                       const input  = await evalNumberValue(this.input,  parse);         const min    = await evalNumberValue(this.min,    parse);         const max    = await evalNumberValue(this.max,    parse);         const bias   = await evalNumberValue(this.bias,   parse);         const spread = await evalNumberValue(this.spread, parse);           if (input)         {             if (g957(input.type))             {                 this.value = new x2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == t1091                         ? getNumberBiasValue(item, min, max, bias, spread, this.options.enabled)                         : d2022.NaN.copy());                    }             }             else                 this.value = getNumberBiasValue(input, min, max, bias, spread, this.options.enabled);         }         else             this.value = d2022.NaN.copy();           this.n4101(parse,         [             ['type',   this.outputType()],             ['min',    min              ],             ['max',    max              ],             ['bias',   bias             ],             ['spread', spread           ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.min    && this.min   .isValid()             && this.max    && this.max   .isValid()             && this.bias   && this.bias  .isValid()             && this.spread && this.spread.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.min   ) this.min   .r4088(parse);         if (this.max   ) this.max   .r4088(parse);         if (this.bias  ) this.bias  .r4088(parse);         if (this.spread) this.spread.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.min   ) this.min   .o4089(parse, from, force);         if (this.max   ) this.max   .o4089(parse, from, force);         if (this.bias  ) this.bias  .o4089(parse, from, force);         if (this.spread) this.spread.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.min   ) this.min   .t4087(parse);         if (this.max   ) this.max   .t4087(parse);         if (this.bias  ) this.bias  .t4087(parse);         if (this.spread) this.spread.t4087(parse);     } }    function f3735(f, bias, spread) {     const b = bias   / 50;     const s = spread / 50;       f =          b >= 0         ? 1 - Math.pow(1-f, 1+b)         :     Math.pow(  f, 1-b);            if (s >= 0 && f >= 0.5) f = 1 - Math.pow((1-f)*2, 1+s) / 2;     else if (s >= 0 && f <  0.5) f = Math.pow(f*2, 1+s) / 2;     else if (s < 0)              f = b1037(0, (1-s)/3, (2+s)/3, 1, f);       return f; }    function getNumberBiasValue(input, min, max, bias, spread, enabled) {     l952(         input.type == t1091,         'input.type must be NUMBER_VALUE');       if (!enabled)         return input;       let f = (input.value - min.value) / (max.value - min.value);      f = f3735(f, bias.value, spread.value);     f = min.value + f * (max.value - min.value);      return new d2022(f); }


class j1934 extends i2044 {     _value = null;        constructor(nodeId, options)     {         super(e1100, nodeId, options);     }            reset()     {         super.reset();          this._value = null;     }        copy()     {         const copy = new j1934(this.nodeId, this.options);          copy.n3359(this);          if (this._value) copy._value = this._value.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const  input = await evalNumberValue(this. input, parse);         const _value = await evalNumberValue(this._value, parse);           if (input)         {             if (g957(input.type))             {                 this.value = new x2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == t1091                         ? getNaNisNumberValue(item, _value, this.options.enabled)                         : j2033.NaN.copy());                    }             }             else             {                 this.value = getNaNisNumberValue(input, _value, this.options.enabled);             }         }          else             this.value = d2022.NaN.copy();           this.n4101(parse,         [             ['type',   this.outputType()]                      ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.value && this.value.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.value) this.value.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.value) this.value.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.value) this.value.t4087(parse);     } }    function getNaNisNumberValue(input, value, enabled) {     if (    enabled         && !input.isValid())         return value;     else         return input; }


class y1927 extends g2043 {     constant;        constructor(nodeId, options)     {         super(i1101, nodeId, options);     }            reset()     {         super.reset();          this.constant = null;     }        copy()     {         const copy = new y1927(this.nodeId, this.options);          copy.n3359(this);          if (this.constant) copy.constant = this.constant.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                                  const constant = await evalNumberValue(this.constant, parse);                   let value;          switch (Math.min(Math.max(0, constant.k3703()), 5))         {             case 0: value = 1.4142135623; break;              case 1: value = 2.7182818284; break;              case 2: value = 0.6180339887; break;              case 3: value = 1.6180339887; break;              case 4: value = 3.1415926536; break;              case 5: value = 6.2831853072; break;          }           this.value = new d2022(value);                   this.n4101(parse,         [             ['value',   this.value],             ['constant', constant ]         ]);           this.validate();          return this;     }        isValid()     {         return this.constant && this.constant.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.constant) this.constant.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.constant) this.constant.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.constant) this.constant.t4087(parse);     } } 


class e1929 extends g2043 {     seconds   = null;     minutes   = null;     hours     = null;     dayOfWeek = null;     date      = null;     month     = null;     year      = null;                    constructor(nodeId, options)     {         super(j1098, nodeId, options);     }            reset()     {         super.reset();                  this.seconds   = null;         this.minutes   = null;         this.hours     = null;         this.dayOfWeek = null;         this.date      = null;         this.month     = null;         this.year      = null;     }        copy()     {         const copy = new m1932(this.nodeId, this.options);                  copy.n3359(this);                  if (this.seconds  ) copy.seconds   = this.seconds  .copy();         if (this.minutes  ) copy.minutes   = this.minutes  .copy();         if (this.hours    ) copy.hours     = this.hours    .copy();         if (this.dayOfWeek) copy.dayOfWeek = this.dayOfWeek.copy();         if (this.date     ) copy.date      = this.date     .copy();         if (this.month    ) copy.month     = this.month    .copy();         if (this.year     ) copy.year      = this.year     .copy();          return copy;     }                        isCached()     {         return super.isCached()             && (!this.year      || this.year     .isCached())             && (!this.month     || this.month    .isCached())             && (!this.date      || this.date     .isCached())             && (!this.dayOfWeek || this.dayOfWeek.isCached())             && (!this.hours     || this.hours    .isCached())             && (!this.minutes   || this.minutes  .isCached())             && (!this.seconds   || this.seconds  .isCached())     }        async eval(parse)     {         if (this.isCached())             return this;           this.e3096 = [];                   if (this.options.enabled)         {             const dateTime = new Date();              const seconds   = new d2022(dateTime.getSeconds() );             const minutes   = new d2022(dateTime.getMinutes() );             const hours     = new d2022(dateTime.getHours()   );             const dayOfWeek = new d2022(dateTime.getDay()     );             const date      = new d2022(dateTime.getDate()    );             const month     = new d2022(dateTime.getMonth()   );             const year      = new d2022(dateTime.getFullYear());               this.n4101(parse,             [                 ['seconds',   seconds  ],                 ['minutes',   minutes  ],                 ['hours',     hours    ],                 ['dayOfWeek', dayOfWeek],                 ['date',      date     ],                 ['month',     month    ],                 ['year',      year     ]             ]);             }                       this.validate();          return this;     }            isValid()     {         return this.year      && this.year     .isValid()             && this.month     && this.month    .isValid()             && this.date      && this.date     .isValid()             && this.dayOfWeek && this.dayOfWeek.isValid()             && this.hours     && this.hours    .isValid()             && this.minutes   && this.minutes  .isValid()             && this.seconds   && this.seconds  .isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.year     ) this.year     .r4088(parse);         if (this.month    ) this.month    .r4088(parse);         if (this.date     ) this.date     .r4088(parse);         if (this.dayOfWeek) this.dayOfWeek.r4088(parse);         if (this.hours    ) this.hours    .r4088(parse);         if (this.minutes  ) this.minutes  .r4088(parse);         if (this.seconds  ) this.seconds  .r4088(parse);     }            o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.year     ) this.year     .o4089(parse, from, force);         if (this.month    ) this.month    .o4089(parse, from, force);         if (this.date     ) this.date     .o4089(parse, from, force);         if (this.dayOfWeek) this.dayOfWeek.o4089(parse, from, force);         if (this.hours    ) this.hours    .o4089(parse, from, force);         if (this.minutes  ) this.minutes  .o4089(parse, from, force);         if (this.seconds  ) this.seconds  .o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.year     ) this.year     .t4087(parse);         if (this.month    ) this.month    .t4087(parse);         if (this.date     ) this.date     .t4087(parse);         if (this.dayOfWeek) this.dayOfWeek.t4087(parse);         if (this.hours    ) this.hours    .t4087(parse);         if (this.minutes  ) this.minutes  .t4087(parse);         if (this.seconds  ) this.seconds  .t4087(parse);     }     } 


class w1930 extends g2043 {     inputs = [];        constructor(nodeId, options)     {         super(l1086, nodeId, options);     }            reset()     {         super.reset();          this.input = [];     }        copy()     {         const copy = new w1930(this.nodeId, this.options);          copy.n3359(this);          copy.inputs = this.inputs.map(i => i.copy());          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const _values = [];          for (let i = 0; i < this.inputs.length; i++)         {             const input = await evalValue(this.inputs[i], parse);              if (   input                 && this.options.enabled)                         {                 if (g957(input.type))                 {                     for (const item of input.items)                         _values.push(item.copy());                    }                 else                     _values.push(input.copy());             }         }                       this.value =              _values.length > 0             ? _values[this.currentIteration % _values.length]             : new g4217();           if (   this.value              && this.value.objects)         {             for (let i = 0; i < this.value.objects.length; i++)             {                 const a111 = this.value.objects[i];                      a111.nodeId = this.nodeId;                 a111.listId = -1;                      a111.objectId = this.nodeId;                                  if (a111.objectId != NULL)                      a111.objectId += '/';                      a111.objectId += i.toString();             }         }           this.v4100(parse);                   this.n4101(parse,         [             ['type', this.outputType()]         ]);                   this.validate();          return this;     }        x3633()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return !this.inputs.find(i => !i.isValid());     }        r4088(parse)     {         super.r4088(parse);          this.inputs.forEach(i => i.r4088(parse));     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          this.inputs.forEach(i => i.o4089(parse, from, force));     }        t4087(parse)     {         super.t4087(parse);          this.inputs.forEach(i => i.t4087(parse));     } } 


class v1942 extends g2043 {     start    = null;     multiply = null;     add      = null;     end      = null;      current  = null;                    constructor(nodeId, options)     {         super(w1103, nodeId, options);     }        reset()     {         super.reset();                  this.start    = null;         this.multiply = null;         this.add      = null;         this.end      = null;              this.current  = null;     }           copy()     {         const copy = new v1942(this.nodeId, this.options);          copy.n3359(this);          if (this.start   ) copy.start    = this.start   .copy();         if (this.multiply) copy.multiply = this.multiply.copy();         if (this.add     ) copy.add      = this.add     .copy();         if (this.end     ) copy.end      = this.end     .copy();          if (this.current) copy.current = this.current.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const start = await evalNumberValue(this.start,    parse);         const mult  = await evalNumberValue(this.multiply, parse);         const add   = await evalNumberValue(this.add,      parse);         const end   = await evalNumberValue(this.end,      parse);               if (   start             && mult             && add             && end)         {             const value = start.value + (this.options.enabled ? add.value * this.currentIteration : 0);              if (!end.isValid())                 this.value = getSequenceValue(start, mult, add, this.currentIteration, this.options.enabled);              else if (   end.isValid()                         && (   add.value == 0                          || add.value >  0 && start.value < end.value                                            &&       value < end.value                          || add.value <  0 && start.value > end.value                                            &&       value > end.value))                 this.value = getSequenceValue(start, mult, add, this.currentIteration, this.options.enabled);              else                 this.value = d2022.NaN.copy();         }         else             this.value = d2022.NaN.copy();           this.n4101(parse,         [             ['start',    start],             ['multiply', mult ],             ['add',      add  ],             ['end',      end  ]         ]);                   this.validate();          return this;     }        x3633()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return this.start    && this.start   .isValid()             && this.multiply && this.multiply.isValid()             && this.add      && this.add     .isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.start   ) this.start   .r4088(parse);         if (this.multiply) this.multiply.r4088(parse);         if (this.add     ) this.add     .r4088(parse);         if (this.end     ) this.end     .r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.start   ) this.start   .o4089(parse, from, force);         if (this.multiply) this.multiply.o4089(parse, from, force);         if (this.add     ) this.add     .o4089(parse, from, force);         if (this.end     ) this.end     .o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.start   ) this.start   .t4087(parse);         if (this.multiply) this.multiply.t4087(parse);         if (this.add     ) this.add     .t4087(parse);         if (this.end     ) this.end     .t4087(parse);     } }    function getSequenceValue(start, mult, add, iteration, enabled) {     let value = start.value;      if (enabled)     {         for (let i = 0; i < iteration; i++)         {             value *= mult.value;             value += add .value;         }     }      return new d2022(value); }


class r1940 extends g2043 {     from  = null;     start = null;     end   = null;                constructor(nodeId, options)     {         super(l1104, nodeId, options);     }            reset()     {         super.reset();          this.from  = null;         this.start = null;         this.end   = null;     }        copy()     {         const copy = new r1940(this.nodeId, this.options);          copy.n3359(this);          if (this.from   ) copy.from    = this.from   .copy();         if (this.start  ) copy.start   = this.start  .copy();         if (this.end    ) copy.end     = this.end    .copy();          if (this.current) copy.current = this.current.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const from  = await evalNumberValue(this.from,  parse);         const start = await evalNumberValue(this.start, parse);         const end   = await evalNumberValue(this.end,   parse);               const repeat    = parse.repeats.find(r => r.repeatId == this.z3821);         const iteration = repeat ? repeat.currentIteration : 0;           if (   from             && start             && end)         {             let delta = end.value - start.value;              let step =                  repeat                 && this.options.enabled                 ? delta / Math.max(1, repeat.total - (from.value == 1 ? 1 : 0))                 : 0;                               let startOffset;                   if (from  .value == 2) startOffset = step;             else if (from  .value == 1                 && repeat                 && repeat.total == 1) startOffset = delta/2;             else                        startOffset = 0;               let f;                          if (repeat)             {                      if (from.value == 2) f = iteration/repeat.total;                 else if (from.value == 1) f = (repeat.total > 1 ? iteration/(repeat.total-1) : 0);                 else if (from.value == 0) f = iteration/repeat.total;             }             else                 f = 0;               this.value = new d2022(                 start.value + startOffset + f * delta,                 Math.max(start.decimals, end.decimals));         }         else             this.value = d2022.NaN.copy();           this.n4101(parse,         [             ['from',  from ],             ['start', start],             ['end',   end  ]         ]);           this.validate();          return this;     }        x3633()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return this.from  && this.from .isValid()             && this.start && this.start.isValid()             && this.end   && this.end  .isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.from ) this.from .r4088(parse);         if (this.start) this.start.r4088(parse);         if (this.end  ) this.end  .r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.from ) this.from .o4089(parse, from, force);         if (this.start) this.start.o4089(parse, from, force);         if (this.end  ) this.end  .o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.from ) this.from .t4087(parse);         if (this.start) this.start.t4087(parse);         if (this.end  ) this.end  .t4087(parse);     } } 


class i1946 extends g2043 {     shape     = null;     base      = null;     amplitude = null;     frequency = null;     offset    = null;     bias      = null;          useWavelength;     offsetAbsolute;        constructor(nodeId, options)     {         super(a1105, nodeId, options);     }            reset()     {         super.reset();          this.shape     = null;         this.base      = null;         this.amplitude = null;         this.frequency = null;         this.offset    = null;         this.bias      = null;     }        copy()     {         const copy = new i1946(this.nodeId, this.options);          copy.n3359(this);          if (this.shape    ) copy.shape     = this.shape    .copy();         if (this.base     ) copy.base      = this.base     .copy();         if (this.amplitude) copy.amplitude = this.amplitude.copy();         if (this.frequency) copy.frequency = this.frequency.copy();         if (this.offset   ) copy.offset    = this.offset   .copy();         if (this.bias     ) copy.bias      = this.bias     .copy();          if (this.current) copy.current = this.current.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const shape  = await evalNumberValue(this.shape,     parse);         const base   = await evalNumberValue(this.base,      parse);         const amp    = await evalNumberValue(this.amplitude, parse);         let   freq   = await evalNumberValue(this.frequency, parse);         const offset = await evalNumberValue(this.offset,    parse);         const bias   = await evalNumberValue(this.bias,      parse);               const repeat    = parse.repeats.find(r => r.repeatId == this.z3821);         const iteration = repeat ? repeat.currentIteration : 0;            if (this.options.enabled)         {             let t;                                       if (   repeat                 && shape                 && freq                 && offset)             {                 const _freq =                     this.useWavelength                     ? repeat.total / nozero(freq.value)                     : freq.value;                  let _offset =                     this.offsetAbsolute                     ? offset.value/repeat.total                     : (offset.value/100)/_freq;                  if (shape.value == 3)                     _offset -= 0.25;                  t = (iteration/repeat.total - _offset) * _freq;                  while (t < 0) t++;                 while (t > 1) t--;                  switch (shape.value)                 {                     case 0: t = (t%1) < 0.5 ? 1 : -1;      break;                      case 1: t = (1 - (t%1)*2);             break;                      case 2: t = ((t%1)*2 - 1);             break;                      case 3: t = 1 - 2*Math.abs(2*(t%1)-1); break;                      case 4: t = Math.sin(t * Tau);         break;                  }             }             else                  t = 0;                           if (bias)             {                 const b = bias.value / 100;                  if (b >= 0) t = t / (1+b) + b/2;                 else        t = t / (1-b) + b/2;             }               if (amp ) t = t * amp .value;             if (base) t = t + base.value;               this.value = new d2022(t);         }         else             this.value = base;                   this.n4101(parse,         [             ['shape',     shape ],             ['base',      base  ],             ['amplitude', amp   ],             ['frequency', freq  ],             ['offset',    offset],             ['bias',      bias  ]         ]);           this.validate();          return this;     }        x3633()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return this.shape     && this.shape    .isValid()             && this.base      && this.base     .isValid()             && this.amplitude && this.amplitude.isValid()             && this.frequency && this.frequency.isValid()             && this.offset    && this.offset   .isValid()             && this.bias      && this.bias     .isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.shape    ) this.shape    .r4088(parse);         if (this.base     ) this.base     .r4088(parse);         if (this.amplitude) this.amplitude.r4088(parse);         if (this.frequency) this.frequency.r4088(parse);         if (this.offset   ) this.offset   .r4088(parse);         if (this.bias     ) this.bias     .r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.shape    ) this.shape    .o4089(parse, from, force);         if (this.base     ) this.base     .o4089(parse, from, force);         if (this.amplitude) this.amplitude.o4089(parse, from, force);         if (this.frequency) this.frequency.o4089(parse, from, force);         if (this.offset   ) this.offset   .o4089(parse, from, force);         if (this.bias     ) this.bias     .o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.shape    ) this.shape    .t4087(parse);         if (this.base     ) this.base     .t4087(parse);         if (this.amplitude) this.amplitude.t4087(parse);         if (this.frequency) this.frequency.t4087(parse);         if (this.offset   ) this.offset   .t4087(parse);         if (this.bias     ) this.bias     .t4087(parse);     } } 


class g1939 extends g2043 {     seed         = null;     iteration    = null;     min          = null;     max          = null;     bias         = null;     spread       = null;     unique       = null;      random       = null;     randomUnique = null;      lastValue1   = -1;     lastValue2   = -1;     uniqueOffset =  0;        constructor(nodeId, options)     {         super(c1106, nodeId, options);     }            reset()     {         super.reset();          this.seed      = null;         this.iteration = null;         this.min       = null;         this.max       = null;         this.bias      = null;         this.spread    = null;         this.unique    = null;     }        copy()     {         const copy = new g1939(this.nodeId, this.options);          copy.n3359(this);          if (this.seed     ) copy.seed      = this.seed     .copy();         if (this.iteration) copy.iteration = this.iteration.copy();         if (this.min      ) copy.min       = this.min      .copy();         if (this.max      ) copy.max       = this.max      .copy();         if (this.bias     ) copy.bias      = this.bias     .copy();         if (this.spread   ) copy.spread    = this.spread   .copy();         if (this.unique   ) copy.unique    = this.unique   .copy();          if (this.random   ) copy.random    = this.random   .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const seed      = await evalNumberValue(this.seed,      parse);         const iteration = await evalNumberValue(this.iteration, parse);         const min       = await evalNumberValue(this.min,       parse);         const max       = await evalNumberValue(this.max,       parse);         const bias      = await evalNumberValue(this.bias,      parse);         const spread    = await evalNumberValue(this.spread,    parse);         const unique    = await evalNumberValue(this.unique,    parse);               if (   this.options.enabled             && iteration             && seed             && min             && max             && bias             && spread             && unique)         {             if (  !this.random                 || this.random.seed != seed.value)             {                 this.random       = new Random(seed.value);                 this.randomUnique = new Random(seed.value+1);             }               if (iteration.isValid())                 this.currentIteration = Math.round(iteration.value);               if (this.currentIteration >= 0)             {                 let f  = this.random.get(this.currentIteration + this.uniqueOffset);                  f = f3735(f, bias.value, spread.value);                 f = min.value + f * (max.value - min.value);                                  this.value = new d2022(f, Math.max(min.decimals, max.decimals));                                       const _unique = unique.value/100;                                   if (max.value - min.value >= 1)                 {                     while (this.value.k3703() == this.lastValue1                         && this.randomUnique.get(this.currentIteration) < _unique)                         this.value = new d2022(                             min.value + this.random.get(this.currentIteration + ++this.uniqueOffset) * (max.value - min.value),                             Math.max(min.decimals, max.decimals));                 }                  if (max.value - min.value >= 2)                 {                     while ((   this.value.k3703() == this.lastValue1                             || this.value.k3703() == this.lastValue2)                         && this.randomUnique.get(this.currentIteration) < Math.max(_unique - 1))                         this.value = new d2022(                             min.value + this.random.get(this.currentIteration + ++this.uniqueOffset) * (max.value - min.value),                             Math.max(min.decimals, max.decimals));                 }                     }             else                 this.value = new d2022((min.value + max.value) / 2);         }         else             this.value = d2022.NaN.copy();           if (this.value.isValid())             this.value.value = this.value.k3703();          this.lastValue2 = this.lastValue1;         this.lastValue1 = this.value.value;           this.n4101(parse,         [             ['iteration', iteration],             ['seed',      seed     ],             ['min',       min      ],             ['max',       max      ],             ['bias',      bias     ],             ['spread',    spread   ],             ['unique',    unique   ]         ]);                   this.validate();          return this;     }        x3633()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return this.seed      && this.seed     .isValid()             && this.iteration && this.iteration.isValid()             && this.min       && this.min      .isValid()             && this.max       && this.max      .isValid()             && this.bias      && this.bias     .isValid()             && this.spread    && this.spread   .isValid()             && this.unique    && this.unique   .isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.seed     ) this.seed     .r4088(parse);         if (this.iteration) this.iteration.r4088(parse);         if (this.min      ) this.min      .r4088(parse);         if (this.max      ) this.max      .r4088(parse);         if (this.bias     ) this.bias     .r4088(parse);         if (this.spread   ) this.spread   .r4088(parse);         if (this.unique   ) this.unique   .r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.seed     ) this.seed     .o4089(parse, from, force);         if (this.iteration) this.iteration.o4089(parse, from, force);         if (this.min      ) this.min      .o4089(parse, from, force);         if (this.max      ) this.max      .o4089(parse, from, force);         if (this.bias     ) this.bias     .o4089(parse, from, force);         if (this.spread   ) this.spread   .o4089(parse, from, force);         if (this.unique   ) this.unique   .o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.seed     ) this.seed     .t4087(parse);         if (this.iteration) this.iteration.t4087(parse);         if (this.min      ) this.min      .t4087(parse);         if (this.max      ) this.max      .t4087(parse);         if (this.bias     ) this.bias     .t4087(parse);         if (this.spread   ) this.spread   .t4087(parse);         if (this.unique   ) this.unique   .t4087(parse);     }        o3629(parse, nodeId)     {         super.o3629(parse, nodeId);          this.uniqueOffset = 0;     }        u3632(parse, nodeId)     {         super.u3632(parse, nodeId);          this.uniqueOffset = 0;     } } 


class o1935 extends g2043 {     seed        = null;     iteration   = null;     min         = null;     max         = null;     scale       = null;     interpolate = null;     offset      = null;     evolve      = null;     detail      = null;          randoms     = [];     offsets     = [];                    constructor(nodeId, options)     {         super(a1107, nodeId, options);     }                    reset()     {         super.reset();                  this.seed          = null;         this.iteration     = null;         this.min           = null;         this.max           = null;         this.scale         = null;         this.interpolate   = null;         this.offset        = null;         this.evolve        = null;         this.detail        = null;     }        copy()     {         const copy = new o1935(this.nodeId, this.options);          copy.n3359(this);          if (this.seed       ) copy.seed        = this.seed       .copy();         if (this.iteration  ) copy.iteration   = this.iteration  .copy();         if (this.min        ) copy.min         = this.min        .copy();         if (this.max        ) copy.max         = this.max        .copy();         if (this.scale      ) copy.scale       = this.scale      .copy();         if (this.offset     ) copy.offset      = this.offset     .copy();         if (this.evolve     ) copy.evolve      = this.evolve     .copy();         if (this.interpolate) copy.interpolate = this.interpolate.copy();         if (this.detail     ) copy.detail      = this.detail     .copy();          if (this.randoms    ) copy.randoms     = this.randoms.map(r => r.copy());         if (this.offsets    ) copy.offsets     = this.offsets.slice();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const seed        = await evalNumberValue(this.seed,        parse);         const iteration   = await evalNumberValue(this.iteration,   parse);         const min         = await evalNumberValue(this.min,         parse);         const max         = await evalNumberValue(this.max,         parse);         const scale       = await evalNumberValue(this.scale,       parse);         const offset      = await evalNumberValue(this.offset,      parse);         const evolve      = await evalNumberValue(this.evolve,      parse);         const interpolate = await evalNumberValue(this.interpolate, parse);         const detail      = await evalNumberValue(this.detail,      parse);               if (   this.options.enabled             && seed             && iteration             && min             && max             && scale             && offset             && evolve             && interpolate             && detail)         {             const _detail = Math.max(1, Math.ceil(detail.value));               if (  !this.randoms                 || this.randoms.length < _detail)             {                 const randoms = new Array(_detail);                  for (let c = 0; c < this.randoms.length; c++)                     randoms[c] = this.randoms[c];                                   let _seed = seed.value;                  for (let c = this.randoms.length; c < _detail; c++)                 {                     randoms[c] = new f375(_seed);                     _seed = seed.value;                 }                   this.randoms = randoms;                   this.updateOffsets(this.randoms[0].width * _detail);             }               let   size  = 1;             let   power = 1;                          const avg   = (min.value + max.value) / 2;             let   r;                           if (iteration.isValid())                 this.currentIteration = Math.round(iteration.value);                               if (   this.options.enabled                 && scale  && scale .isValid()                 && offset && offset.isValid()                 && evolve && evolve.isValid())             {                 r = avg;                                  if (this.currentIteration >= 0)                 {                     for (let c = 0; c < _detail; c++)                     {                         const i  = Math.max(0, this.currentIteration / (Math.max(0.000001, scale.value) * size) + offset.value);                         const i0 = Math.floor(i);                         const i1 = Math.ceil (i);                                                   this.updateOffsets((i1 + 1) * _detail);                          const o0 = this.offsets[i0];                         const o1 = this.offsets[i1];                         let   _o;                          switch (interpolate.value)                         {                             case 0: _o = o0;                                                 break;                             case 1: _o = b1035(o0, o1, i-i0);                                 break;                             case 2: _o = (o0 + (o1 - o0) * (-Math.cos((i-i0)*Tau/2) + 1)/2); break;                         }                                                   const j   = evolve.value + _o;                         const j0  = Math.floor(j);                         const j1  = Math.ceil (j);                           const r00 = this.randoms[c].get(i0, j0);                         const r10 = this.randoms[c].get(i1, j0);                         const r01 = this.randoms[c].get(i0, j1);                         const r11 = this.randoms[c].get(i1, j1);                                       let _r, _r0, _r1;                                                  switch (interpolate.value)                         {                             case 0:                                  _r = r00;                                 break;                              case 1:                                  _r0 = b1035(r00, r10, i-i0);                                 _r1 = b1035(r01, r11, i-i0);                                 _r  = b1035(_r0, _r1, j-j0);                                 break;                              case 2:                                  _r0 = (r00 + (r10 - r00) * (-Math.cos((i-i0)*Tau/2) + 1)/2);                                  _r1 = (r01 + (r11 - r01) * (-Math.cos((i-i0)*Tau/2) + 1)/2);                                  _r  = (_r0 + (_r1 - _r0) * (-Math.cos((j-j0)*Tau/2) + 1)/2);                                  break;                         }                           const clamp =                              detail.value - c < 1                              ? detail.value - c                              : 1;                          r +=                              - power *      (avg       - min.value) * clamp                             + power * _r * (max.value - min.value) * clamp;                                                   size  /= 2;                         power /= 2;                                                   this.updateOffsets(this.randoms[0].width * _detail);                     }                 }             }             else             {                 r = min.value;             }               this.value = new d2022(r, Math.max(min.decimals, max.decimals));         }         else         {             this.value = d2022.NaN.copy();         }           this.n4101(parse,         [             ['seed',        seed       ],             ['iteration',   iteration  ],             ['min',         min        ],             ['max',         max        ],             ['scale',       scale      ],             ['offset',      offset     ],             ['evolve',      evolve     ],             ['interpolate', interpolate],             ['detail',      detail     ]         ]);                   this.validate();          return this;     }        updateOffsets(newSize)     {         if (newSize < this.offsets.length)              return;          this.offsets = new Array(newSize);         const offsetRandom = new Random(0);          for (let o = 0; o < newSize; o++)             this.offsets[o] = offsetRandom.get(o);     }        x3633()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return this.seed        && this.seed       .isValid()             && this.iteration   && this.iteration  .isValid()             && this.min         && this.min        .isValid()             && this.max         && this.max        .isValid()             && this.scale       && this.scale      .isValid()             && this.offset      && this.offset     .isValid()             && this.evolve      && this.evolve     .isValid()             && this.interpolate && this.interpolate.isValid()             && this.detail      && this.detail     .isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.seed       ) this.seed       .r4088(parse);         if (this.iteration  ) this.iteration  .r4088(parse);         if (this.min        ) this.min        .r4088(parse);         if (this.max        ) this.max        .r4088(parse);         if (this.scale      ) this.scale      .r4088(parse);         if (this.offset     ) this.offset     .r4088(parse);         if (this.evolve     ) this.evolve     .r4088(parse);         if (this.interpolate) this.interpolate.r4088(parse);         if (this.detail     ) this.detail     .r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.seed       ) this.seed       .o4089(parse, from, force);         if (this.iteration  ) this.iteration  .o4089(parse, from, force);         if (this.min        ) this.min        .o4089(parse, from, force);         if (this.max        ) this.max        .o4089(parse, from, force);         if (this.scale      ) this.scale      .o4089(parse, from, force);         if (this.offset     ) this.offset     .o4089(parse, from, force);         if (this.evolve     ) this.evolve     .o4089(parse, from, force);         if (this.interpolate) this.interpolate.o4089(parse, from, force);         if (this.detail     ) this.detail     .o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.seed       ) this.seed       .t4087(parse);         if (this.iteration  ) this.iteration  .t4087(parse);         if (this.min        ) this.min        .t4087(parse);         if (this.max        ) this.max        .t4087(parse);         if (this.scale      ) this.scale      .t4087(parse);         if (this.offset     ) this.offset     .t4087(parse);         if (this.evolve     ) this.evolve     .t4087(parse);         if (this.interpolate) this.interpolate.t4087(parse);         if (this.detail     ) this.detail     .t4087(parse);     } } 


class x1938 extends u2045 {     seed      = null;     iteration = null;     chance    = null;     alternate = null;      random    = null;        constructor(nodeId, options)     {         super(g1108, nodeId, options);     }            reset()     {         super.reset();          this.seed      = null;         this.iteration = null;         this.chance    = null;         this.alternate = null;     }        copy()     {         const copy = new g1939(this.nodeId, this.options);          copy.n3359(this);          if (this.seed     ) copy.seed      = this.seed     .copy();         if (this.iteration) copy.iteration = this.iteration.copy();         if (this.chance   ) copy.chance    = this.chance   .copy();         if (this.alternate) copy.alternate = this.alternate.copy();          if (this.random) copy.random = this.random.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const e4083    = await evalValue      (this.e4083,    parse);         const j4084    = await evalValue      (this.j4084,    parse);         const seed      = await evalNumberValue(this.seed,      parse);         const iteration = await evalNumberValue(this.iteration, parse);         const chance    = await evalNumberValue(this.chance,    parse);         const alternate = await evalNumberValue(this.alternate, parse);               if (   seed             && iteration             && chance             && alternate)         {             if (  !this.random                 || this.random.seed != seed.value)                 this.random = new Random(seed.value);               if (iteration.isValid())                 this.currentIteration = Math.round(iteration.value);               if (this.currentIteration >= 0)             {                 const calt  = this.currentIteration % 2 == 0 ? 0 : 1;                  let   cval  = chance.value/100;                       cval += alternate.value/100 * (calt - cval);                  const ch    = this.random.get(this.currentIteration) > cval ? 0 : 1;                                   if (   e4083                      && j4084)                 {                     if (   e4083.isValid()                         && j4084.isValid())                         this.value = ch < 0.5 ? e4083 : j4084;                     else                         this.value = new g4217();                 }                  else if (e4083)                     this.value = e4083;                                  else if (j4084)                     this.value = j4084;                                  else                     this.value = new d2022(ch < 0.5 ? 0 : 1);             }             else                 this.value = new g4217();         }         else             this.value = new g4217();           this.n4101(parse,         [             ['type',      this.outputType()],             ['seed',      seed             ],             ['iteration', iteration        ],             ['chance',    chance           ],             ['alternate', alternate        ]         ]);                   this.validate();          return this;     }        x3633()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return this.seed      && this.seed     .isValid()             && this.iteration && this.iteration.isValid()             && this.chance    && this.chance   .isValid()             && this.alternate && this.alternate.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.seed     ) this.seed     .r4088(parse);         if (this.iteration) this.iteration.r4088(parse);         if (this.chance   ) this.chance   .r4088(parse);         if (this.alternate) this.alternate.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.seed     ) this.seed     .o4089(parse, from, force);         if (this.iteration) this.iteration.o4089(parse, from, force);         if (this.chance   ) this.chance   .o4089(parse, from, force);         if (this.alternate) this.alternate.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.seed     ) this.seed     .t4087(parse);         if (this.iteration) this.iteration.t4087(parse);         if (this.chance   ) this.chance   .t4087(parse);         if (this.alternate) this.alternate.t4087(parse);     } } 


class n1925 extends i2044 {     current;     when;        constructor(nodeId, options)     {         super(r1109, nodeId, options);          this.current = new d2022(0);     }            reset()     {         super.reset();          this.current = null;         this.when    = null;     }        copy()     {         const copy = new n1925(this.nodeId, this.options);          copy.n3359(this);          if (this.when   ) copy.when    = this.when   .copy();         if (this.current) copy.current = this.current.copy();          return copy;     }        async eval(parse)     {         if (    this.isCached()             || !parse.evalAccumulate)             return this;           const input = await evalNumberValue(this.input, parse);         const when  = await evalNumberValue(this.when,  parse);                       if (   input             && when)         {             if (this.options.enabled)             {                 if (when.value > 0)                     this.value = this.current.copy();                  if (input)                 {                     this.current.value   += input.value;                     this.current.decimals = Math.max(this.current.decimals, input.decimals);                 }                  if (when.value == 0)                     this.value = this.current.copy();             }             else                 this.value = input.copy();         }         else             this.value = d2022.NaN.copy();           this.n4101(parse,          [             ['when', when]         ]);                   this.validate();          return this;     }        x3633()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.when && this.when.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.when) this.when.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.when) this.when.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.when) this.when.t4087(parse);     }        u3632(parse, nodeId)     {         super.u3632(parse, nodeId);          this.current = new d2022(0);     } } 


class GHold extends i2044 {     current;     first;        constructor(nodeId, options)     {         super(HOLD, nodeId, options);          this.current = null;     }            reset()     {         super.reset();          this.current = null;         this.first   = null;     }        copy()     {         const copy = new GHold(this.nodeId, this.options);          copy.n3359(this);          if (this.first  ) copy.first   = this.first  .copy();         if (this.current) copy.current = this.current.copy();          return copy;     }        async eval(parse)     {         if (    this.isCached()             || !parse.evalAccumulate)             return this;           const input = await evalValue(this.input, parse);         const first = await evalValue(this.first, parse);                       if (   input             && first)         {             if (this.options.enabled)             {                 this.value   = this.current ? this.current : first;                 this.current = input;             }             else                 this.value = input;         }         else             this.value = d2022.NaN.copy();           this.n4101(parse,          [             ['type', this.outputType()]         ]);                   this.validate();          return this;     }        x3633()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.first && this.first.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.first) this.first.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.first) this.first.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.first) this.first.t4087(parse);     }        u3632(parse, nodeId)     {         super.u3632(parse, nodeId);          this.current = null;     } } 


class a1931 extends u2045 {     inputs = [];      amount;     degree;        constructor(nodeId, options)     {         super(y1110, nodeId, options);     }            reset()     {         super.reset();          this.inputs = [];          this.amount = null;         this.degree = null;     }        copy()     {         const copy = new a1931(this.nodeId, this.options);          copy.n3359(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.amount) copy.amount = this.amount.copy();         if (this.degree) copy.degree = this.degree.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const amount = await evalNumberValue(this.amount, parse);         const degree = await evalNumberValue(this.degree, parse);           const values = [];                  for (const m3812 of this.inputs)         {             const input = await evalNumberValue(m3812, parse);              if (g957(input.type))             {                 for (const item of input.items)                 {                                                                    const value = await evalNumberValue(item, parse);                     values.push(value);                 }             }             else             {                 const value = await evalNumberValue(input, parse);                 values.push(value);             }         }                           const maxDec = values.reduce((max, v) => Math.max(max, v.decimals), 0);           const deg =             degree.value < 3             ? Math.min(degree.value, 2) + 1             : 1;          const nSegments = Math.floor((values.length-1)/deg);         const index     = Math.min(Math.floor((values.length-1)/deg * amount.value/100), nSegments-1);           if (values.length == 1)             this.value = values[0];          else if (values.length > 0               && index < values.length - deg)         {             const localAmount =                  nSegments > 1                 ? (amount.value/100 - index/nSegments) * nSegments                 : amount.value/100;               if (degree.value == 0)              {                 const e3690 = values[index*deg  ];                 const val1 = values[index*deg+1];                  this.value = new d2022(                     b1035(e3690.value, val1.value, localAmount),                     maxDec);             }             else if (degree.value == 1)              {                 const e3690 = values[index*deg  ];                 const val1 = values[index*deg+1];                 const val2 = values[index*deg+2];                  this.value = new d2022(                     g1036(e3690.value, val1.value, val2.value, localAmount),                     maxDec);             }             else if (degree.value == 2)              {                 const e3690 = values[index*deg  ];                 const val1 = values[index*deg+1];                 const val2 = values[index*deg+2];                 const val3 = values[index*deg+3];                  this.value = new d2022(                     b1037(e3690.value, val1.value, val2.value, val3.value, localAmount),                     maxDec);             }             else if (degree.value == 3)              {                 const e3690 = values[index*deg  ];                 const val1 = values[index*deg+1];                  this.value = new d2022(                     lerpCos(e3690.value, val1.value, localAmount),                     maxDec);             }             else                 this.value = d2022.NaN.copy();         }          else                               this.value = d2022.NaN.copy();           this.n4101(parse,         [             ['value',  this.value],             ['amount', amount    ],             ['degree', degree    ]         ]);                   this.validate();          return this;     }        isValid()     {         return  super.isValid()             &&  this.inputs.length > 0             && !this.inputs.find(i => !i.isValid())             &&  this.amount && this.amount.isValid()             &&  this.degree && this.degree.isValid();     }        r4088(parse)     {         super.r4088(parse);          this.inputs.forEach(i => i.r4088(parse));          if (this.amount) this.amount.r4088(parse);         if (this.degree) this.degree.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          this.inputs.forEach(i => i.o4089(parse, from, force));          if (this.amount) this.amount.o4089(parse, from, force);         if (this.degree) this.degree.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          this.inputs.forEach(i => i.t4087(parse));          if (this.amount) this.amount.t4087(parse);         if (this.degree) this.degree.t4087(parse);     } } 


class e1945 extends i2044 {     current = null;     target  = null;      temp    = null;            constructor(nodeId, options)     {         super(j1098, nodeId, options);     }            reset()     {         super.reset();          this.current = null;         this.target  = null;         this.temp    = null;     }        copy()     {         const copy = new e1945(this.nodeId, this.options);          copy.n3359(this);          if (this.current) copy.current = this.current.copy();         if (this.target ) copy.target  = this.target .copy();          return copy;     }        isCached()     {         return super.isCached()             && this.current.isCached()             && this.target .isCached();     }        async eval(parse)     {         if (this.isCached())             return this;           let   input   = await evalNumberValue(this.input,   parse);         let   current = await evalNumberValue(this.current, parse);         const target  = await evalNumberValue(this.target,  parse);           if (   input             && current.isValid()             && target .isValid())         {             l952(                 input.type == t1091,                  'input.type must be NUMBER_VALUE');               if (this.options.enabled)             {                 let   diff      = target.value - current.value;                 let   prevDiff  = 0;                   let   temp      = 0;                 let   step      = Number.MAX_SAFE_INTEGER/65536;                   let   iter      = 0;                 const maxIter   = 1000;                                   x2077(this.nodeId);                   parse.y3640 += maxIter;                   while (iter++ < maxIter)                 {                     temp += step;                       if (this.input.type == PARAM)                     {                         this.input.node[this.input.p2992].value    = temp;                         this.input.node[this.input.p2992].decimals = x1004(temp);                     }                                               this.current.o4089(parse, this);                     current = await evalNumberValue(this.current, parse);                                                                                      if (current.isValid())                     {                         diff = target.value - current.value;                                                   if (Math.abs(diff) < 0.0000001)                             break;                                                       if (   Math.abs (diff) >  Math.abs (prevDiff)                             || Math.sign(diff) != Math.sign(prevDiff))                             step /= -2;                                                                             prevDiff = diff;                     }                                               parse.g3639++;                     y2078(parse, this.nodeId, iter / maxIter);                 }                   if (iter < maxIter)                 {                     parse.g3639 += maxIter - iter;                      input = await evalNumberValue(this.input, parse);                     this.value = input.copy();                 }                 else                 {                     this.value = d2022.NaN.copy();                     console.warn('max solve iterations');                 }             }             else                 this.value = input.copy();         }         else         {             if (this.input)                  await this.input.eval(parse);              this.value = d2022.NaN.copy();         }                             this.n4101(parse,         [                          ['current', current   ],             ['target',  target    ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.current && this.current.isValid()             && this.target  && this.target .isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.current) this.current.r4088(parse);         if (this.target ) this.target .r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.current) this.current.o4089(parse, from, force);         if (this.target ) this.target .o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.current) this.current.t4087(parse);         if (this.target ) this.target .t4087(parse);     } } 


class v1926 extends g2043 {     from   = null;     to     = null;     curve  = null;     repeat = null;     length = null;     time   = null;                    constructor(nodeId, options)     {         super(w1112, nodeId, options);     }                    reset()     {         super.reset();                  this.from   = null;         this.to     = null;         this.curve  = null;         this.repeat = null;         this.length = null;         this.time   = null;     }        copy()     {         const copy = new v1926(this.nodeId, this.options);          copy.n3359(this);          if (this.from  ) copy.from   = this.from  .copy();         if (this.to    ) copy.to     = this.to    .copy();         if (this.curve ) copy.curve  = this.curve .copy();         if (this.repeat) copy.repeat = this.repeat.copy();         if (this.length) copy.length = this.length.copy();         if (this.time  ) copy.time   = this.time  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const from   = await evalNumberValue(this.from,   parse);         const to     = await evalNumberValue(this.to,     parse);         const curve  = await evalNumberValue(this.curve,  parse);         const repeat = await evalNumberValue(this.repeat, parse);         const length = await evalNumberValue(this.length, parse);         const time   = await evalNumberValue(this.time,   parse);               const maxDec = Math.max(from.decimals, to.decimals);          switch (curve.value)         {             case 0:              {                 this.value = new d2022(                     time.value < length.value ? from.value : to.value,                      maxDec);                      break;             }             case 1:              {                 this.value = new d2022(                     from.value + (to.value - from.value) * time.value / length.value,                     maxDec);                  break;             }             case 2:              {                 let f = time.value / length.value;                  f = 1 - sqr(1 - f);                  this.value = new d2022(                     from.value + (to.value - from.value) * f,                     maxDec);                      break;             }             case 3:              {                 let f = time.value / length.value;                  f = sqr(f);                  this.value = new d2022(                     from.value + (to.value - from.value) * f,                     maxDec);                      break;             }             case 4:              {                 let f = time.value / length.value;                  f = 6*Math.pow(f, 5) - 15*Math.pow(f, 4) + 10*Math.pow(f, 3);                  this.value = new d2022(                     from.value + (to.value - from.value) * f,                     maxDec);                      break;             }         }                   this.n4101(parse,         [             ['from',   from  ],             ['to',     to    ],             ['curve',  curve ],             ['repeat', repeat],             ['length', length],             ['time',   time  ]         ]);                   this.validate();          return this;     }        isValid()     {         return this.from   && this.from  .isValid()             && this.to     && this.to    .isValid()             && this.curve  && this.curve .isValid()             && this.repeat && this.repeat.isValid()             && this.length && this.length.isValid()             && this.time   && this.time  .isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.from  ) this.from  .r4088(parse);         if (this.to    ) this.to    .r4088(parse);         if (this.curve ) this.curve .r4088(parse);         if (this.repeat) this.repeat.r4088(parse);         if (this.length) this.length.r4088(parse);         if (this.time  ) this.time  .r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.from  ) this.from  .o4089(parse, from, force);         if (this.to    ) this.to    .o4089(parse, from, force);         if (this.curve ) this.curve .o4089(parse, from, force);         if (this.repeat) this.repeat.o4089(parse, from, force);         if (this.length) this.length.o4089(parse, from, force);         if (this.time  ) this.time  .o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.from  ) this.from  .t4087(parse);         if (this.to    ) this.to    .t4087(parse);         if (this.curve ) this.curve .t4087(parse);         if (this.repeat) this.repeat.t4087(parse);         if (this.length) this.length.t4087(parse);         if (this.time  ) this.time  .t4087(parse);     } } 


class u1902 extends f1899 {     operation;        constructor(nodeId, options)     {         super(w1114, nodeId, options);     }       reset()     {         super.reset();          this.operation = null;     }            copy()     {         const copy = new u1902(this.nodeId, this.options);          copy.n3359(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.operation) copy.operation = this.operation.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           let op = await evalNumberValue(this.operation, parse);          if (op) op = op.q3729();                   if (op.isValid())         {             op.value    = Math.min(Math.max(0, Math.round(op.value)), b1311.length-1);             op.decimals = 0;         }           if (this.options.enabled)         {             switch (op.value)             {                 case 0: this.value = await f3701  (this, this.inputs, parse); break;                 case 1: this.value = await n3700  (this, this.inputs, parse); break;                 case 2: this.value = await f3698(this, this.inputs, parse); break;                 case 3: this.value = await q3697     (this, this.inputs, parse); break;                 case 4: this.value = await g3699(this, this.inputs, parse); break;                 case 5: this.value = await y3702(this, this.inputs, parse); break;             }         }          else if (this.inputs.length > 0)             this.value =                     this.inputs.length > 0                  && this.inputs[0]                  ? (await this.inputs[0].eval(parse)).x3633()                  : null;          else             this.value = d2022.NaN.copy();           this.n4101(parse,         [                          ['operation', op        ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.operation && this.operation.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.operation) this.operation.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.operation) this.operation.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.operation) this.operation.t4087(parse);     } }    async function q3697(node, inputs, parse) {     if (isEmpty(inputs))         return d2022.NaN.copy();       const value = new d2022(0);       for (let i = 0; i < inputs.length; i++)     {         const val = await evalValue(inputs[i], parse);                   if (   !val             || !val.isValid())         {             for (let j = i+1; j < inputs.length; j++)                 await evalValue(inputs[j], parse);                          return d2022.NaN.copy();         }           if (g957(val.type))         {             if (   isEmpty(val.items)                 || val.items[0].type != t1091)                 return d2022.NaN.copy();              for (const item of val.items)             {                 if (item.type == t1091)                 {                     value.value   += item.value;                     value.decimals = Math.max(value.decimals, item.decimals);                 }             }         }         else         {             l952(                  val.type == t1091,                  'val.type must be NUMBER_VALUE');              value.value   += val.value;             value.decimals = Math.max(value.decimals, val.decimals);         }     }       return value; }    async function f3698(node, inputs, parse) {     if (isEmpty(inputs))         return d2022.NaN.copy();       let value = new d2022(0);       if (!isEmpty(inputs))     {         const e3690 = await evalValue(inputs[0], parse);          if (   !e3690             || !e3690.isValid())         {             for (let j = 1; j < inputs.length; j++)                 await evalValue(inputs[j], parse);                          return d2022.NaN.copy();         }                                                                 if (     g957(e3690.type)              && !isEmpty(e3690.items))         {             const d3689 = e3690.items[0];              if (   !d3689                 || !d3689.isValid())                 return d2022.NaN.copy();               value.value    = d3689.value;             value.decimals = d3689.decimals;              for (let i = 1; i < e3690.items.length; i++)             {                 const item = e3690.items[i];                  if (   !item                     || !item.isValid())                     return d2022.NaN.copy();                  if (item.type == t1091)                 {                     value.value   -= item.value;                     value.decimals = Math.max(value.decimals, item.decimals);                 }                                 }         }         else         {             if (e3690.type != t1091)                 return d2022.NaN.copy();              value.value    = e3690.value;             value.decimals = e3690.decimals;         }           for (let i = 1; i < inputs.length; i++)         {             const val = await evalNumberValue(inputs[i], parse);              if (   !val                 || !val.isValid())             {                 for (let j = i+1; j < inputs.length; j++)                     await evalValue(inputs[j], parse);                                  return d2022.NaN.copy();             }               if (g957(val.type))             {                 for (const item of val.items)                 {                     if (item.type == t1091)                     {                         value.value   -= item.value;                         value.decimals = Math.max(value.decimals, item.decimals);                     }                                     }             }             else             {                 l952(                      val.type == t1091,                      'val.type must be NUMBER_VALUE');                                      value.value   -= val.value;                 value.decimals = Math.max(value.decimals, val.decimals);             }         }     }       return value; }    async function g3699(node, inputs, parse) {     if (isEmpty(inputs))         return d2022.NaN.copy();       const value = new d2022(0);       if (!isEmpty(inputs))     {         value.value = 1;          for (let i = 0; i < inputs.length; i++)         {             const val = await evalValue(inputs[i], parse);              if (   !val                 || !val.isValid())             {                 for (let j = i+1; j < inputs.length; j++)                     await evalValue(inputs[j], parse);                                  return d2022.NaN.copy();             }               if (g957(val.type))             {                 if (   isEmpty(val.items)                     || val.items[0].type != t1091)                     return d2022.NaN.copy();                  for (const item of val.items)                 {                     value.value   *= item.value;                     value.decimals = Math.max(value.decimals, item.decimals);                 }             }             else             {                 l952(                      val.type == t1091,                      'val.type must be NUMBER_VALUE');                  value.value   *= val.value;                 value.decimals = Math.max(value.decimals, val.decimals);             }         }     }       return value; }    async function n3700(node, inputs, parse) {     if (isEmpty(inputs))         return d2022.NaN.copy();               let value = new d2022(0);               if (!isEmpty(inputs))     {         const e3690 = await evalValue(inputs[0], parse);          if (   !e3690             || !e3690.isValid())         {             for (let j = 1; j < inputs.length; j++)                 await evalValue(inputs[j], parse);                          return d2022.NaN.copy();         }           if (    g957(e3690.type)             && !isEmpty(e3690.items))         {             const d3689 = e3690.items[0];              if (   !d3689                 || !d3689.isValid())                 return d2022.NaN.copy();               value.value    = d3689.value;             value.decimals = d3689.decimals;              for (let i = 1; i < e3690.items.length; i++)             {                 const item = e3690.items[i];                  if (   !item                     || !item.isValid())                     return d2022.NaN.copy();                                       if (item.type == t1091)                 {                     if (item.value == 0)                      {                          value.value    = Number.NaN;                          value.decimals = 0;                         break;                      }                      value.value    = value.value / item.value;                     value.decimals = Math.max(value.decimals, item.decimals);                 }                                 }         }         else         {             if (e3690.type != t1091)                 return d2022.NaN.copy();              value.value    = e3690.value;             value.decimals = e3690.decimals;         }                   for (let i = 1; i < inputs.length; i++)         {             const val = await evalNumberValue(inputs[i], parse);              if (   !val                 || !val.isValid())             {                 for (let j = i+1; j < inputs.length; j++)                     await evalValue(inputs[j], parse);                                  return d2022.NaN.copy();             }               if (g957(val.type))             {                 for (const item of val.items)                 {                     if (   !item                         || !item.isValid())                         return d2022.NaN.copy();                       if (item.type == t1091)                     {                         if (item.value == 0)                          {                              value.value    = Number.NaN;                              value.decimals = 0;                             break;                          }                                                   value.value    = value.value / item.value;                         value.decimals = Math.max(value.decimals, item.decimals);                     }                                     }             }             else             {                 l952(                      val.type == t1091,                      'val.type must be NUMBER_VALUE');                  if (val.value == 0)                  {                      value.value    = Number.NaN;                      value.decimals = 0;                     break;                  }                                                        value.value    = value.value / val.value;                 value.decimals = Math.max(value.decimals, val.decimals);             }         }     }       return value; }    async function f3701(node, inputs, parse) {     if (isEmpty(inputs))         return d2022.NaN.copy();               const value = new d2022(0);               if (!isEmpty(inputs))     {         const e3690 = await evalValue(inputs[0], parse);          if (   !e3690             || !e3690.isValid())         {             for (let j = 1; j < inputs.length; j++)                 await evalValue(inputs[j], parse);                          return d2022.NaN.copy();         }           if (    g957(e3690.type)             && !isEmpty(e3690.items))         {             const d3689 = e3690.items[0];              if (   !d3689                 || !d3689.isValid())                 return d2022.NaN.copy();               value.value    = d3689.value;             value.decimals = d3689.decimals;              for (let i = 1; i < e3690.items.length; i++)             {                 const item = e3690.items[i];                                  if (   !item                     || !item.isValid())                     return d2022.NaN.copy();                   if (item.type == t1091)                 {                     if (item.value == 0)                      {                          value.value    = Number.NaN;                          value.decimals = 0;                         break;                      }                      value.decimals = Math.max(value.decimals, item.decimals);                     value.value    = value.value % item.value;                 }                                 }         }         else         {             if (e3690.type != t1091)                 return d2022.NaN.copy();              value.value    = e3690.value;             value.decimals = e3690.decimals;         }           for (let i = 1; i < inputs.length; i++)         {             const val = await evalNumberValue(inputs[i], parse);              if (   !val                 || !val.isValid())             {                 for (let j = i+1; j < inputs.length; j++)                     await evalValue(inputs[j], parse);                                  return d2022.NaN.copy();             }               if (g957(val.type))             {                 for (const item of val.items)                 {                     if (   !item                         || !item.isValid())                         return d2022.NaN.copy();                       if (item.type == t1091)                     {                         if (item.value == 0)                          {                              value.value    = Number.NaN;                              value.decimals = 0;                             break;                          }                          value.decimals = Math.max(value.decimals, item.decimals);                         value.value    = p1015(value.value % item.value, value.decimals);                     }                                     }             }             else             {                 l952(                      val.type == t1091,                      'val.type must be NUMBER_VALUE');                  if (val.value == 0)                  {                      value.value    = Number.NaN;                      value.decimals = 0;                     break;                  }                  value.decimals = Math.max(value.decimals, val.decimals);                 value.value    = p1015(value.value % val.value, value.decimals);             }         }     }       return value; }    async function y3702(node, inputs, parse) {     if (isEmpty(inputs))         return d2022.NaN.copy();       const value = new d2022(0);       if (!isEmpty(inputs))     {         const e3690 = await evalValue(inputs[0], parse);          if (   !e3690             || !e3690.isValid())         {             for (let j = 1; j < inputs.length; j++)                 await evalValue(inputs[j], parse);                          return d2022.NaN.copy();         }           if (    g957(e3690.type)             && !isEmpty(e3690.items))         {             const d3689 = e3690.items[0];              if (   !d3689                 || !d3689.isValid())                 return d2022.NaN.copy();               value.value    = d3689.value;             value.decimals = d3689.decimals;              for (let i = 1; i < e3690.items.length; i++)             {                 const item = e3690.items[i];                                  if (   !item                     || !item.isValid())                     return d2022.NaN.copy();                   if (item.type == t1091)                 {                     value.value    = Math.pow(value.value,    item.value);                     value.decimals = Math.max(value.decimals, item.decimals);                 }                                 }         }         else         {             if (e3690.type != t1091)                 return d2022.NaN.copy();              value.value    = e3690.value;             value.decimals = e3690.decimals;         }           for (let i = 1; i < inputs.length; i++)         {             const val = await evalNumberValue(inputs[i], parse);              if (   !val                 || !val.isValid())             {                 for (let j = i+1; j < inputs.length; j++)                     await evalValue(inputs[j], parse);                                  return d2022.NaN.copy();             }               if (g957(val.type))             {                 for (const item of val.items)                 {                     if (   !item                         || !item.isValid())                         return d2022.NaN.copy();                      if (item.type == t1091)                     {                         value.value    = Math.pow(value.value,    item.value);                         value.decimals = Math.max(value.decimals, item.decimals);                     }                                     }             }             else             {                 l952(                     val.type == t1091,                      'val.type must be NUMBER_VALUE');                  value.value    = Math.pow(value.value,    val.value);                 value.decimals = Math.max(value.decimals, val.decimals);             }         }     }       return value; }


class m1905 extends i2044 {     operation;     operand;     invert;        constructor(nodeId, options)     {         super(g1113, nodeId, options);     }            reset()     {         super.reset();          this.operation = null;         this.operand   = null;         this.invert    = null;     }        copy()     {         const copy = new p1941(this.nodeId, this.options);          copy.n3359(this);          if (this.operation) copy.operation = this.operation.copy();         if (this.operand  ) copy.operand   = this.operand  .copy();         if (this.invert   ) copy.invert    = this.invert   .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new d2022(0);           const input   = await evalNumberValue(this.input,     parse);         const op      = await evalNumberValue(this.operation, parse);         const operand = await evalNumberValue(this.operand,   parse);         const invert  = await evalNumberValue(this.invert,    parse);           if (op)         {             op.value    = Math.min(Math.max(0, Math.round(op.value)), b1311.length-1);             op.decimals = 0;         }           if (   input             && op)         {             if (this.options.enabled)             {                 if (g957(input.type))                 {                     this.value = new x2021();                      for (let i = 0; i < input.items.length; i++)                     {                         const item = input.items[i];                          this.value.items.push(                             item.type == t1091                             ? f3696(item, operand, op, invert, this.options.enabled)                             : d2022.NaN.copy());                        }                 }                 else                 {                     this.value = f3696(input, operand, op, invert, this.options.enabled);                 }             }             else                 this.value = input.copy();         }         else             this.value = d2022.NaN.copy();           this.n4101(parse,         [                          ['type',      this.outputType()],             ['operation', op               ],             ['operand',   operand          ],             ['invert',    invert           ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.operation && this.operation.isValid()             && this.operand   && this.operand  .isValid()             && this.invert    && this.invert   .isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.operation) this.operation.r4088(parse);         if (this.operand  ) this.operand  .r4088(parse);         if (this.invert   ) this.invert   .r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.operation) this.operation.o4089(parse, from, force);         if (this.operand  ) this.operand  .o4089(parse, from, force);         if (this.invert   ) this.invert   .o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.operation) this.operation.t4087(parse);         if (this.operand  ) this.operand  .t4087(parse);         if (this.invert   ) this.invert   .t4087(parse);     } }    function f3696(input, operand, op, invert, enabled) {     l952(         input.type == t1091,          'input.type is ' + input.type + ', must be NUMBER_VALUE');       if (enabled)     {         op.value = Math.min(Math.max(0, Math.floor(op.value)), b1311.length-1);          const w3695 = Math.max(input.decimals, operand.decimals);          switch (op.value)         {             case 0:                  return invert.value == 0                     ? new d2022(input.value % operand.value, w3695)                     : new d2022(operand.value % input.value, w3695);              case 1:                  if (      operand.value == 0                        && invert .value == 0                     ||    input  .value == 0                        && invert .value == 1)                     return d2022.NaN.copy();                 else                     return invert.value == 0                         ? new d2022(input.value / operand.value, w3695)                         : new d2022(operand.value / input.value, w3695);              case 2:                  return invert.value == 0                     ? new d2022(input.value - operand.value, w3695)                     : new d2022(operand.value - input.value, w3695);              case 3:                  return invert.value == 0                     ? new d2022(input.value + operand.value, w3695)                     : new d2022(operand.value + input.value, w3695);              case 4:                  return invert.value == 0                     ? new d2022(input.value * operand.value, w3695)                     : new d2022(operand.value * input.value, w3695);              case 5:                  return invert.value == 0                     ? new d2022(Math.pow(input.value, operand.value), w3695)                     : new d2022(Math.pow(operand.value, input.value), w3695);         }           j953('invalid math operation');         return input;     }     else         return input; }


class i1908 extends f1899 {     operation;        constructor(nodeId, options)     {         super(z1121, nodeId, options);     }        reset()     {         super.reset();          this.operation = null;     }           copy()     {         const copy = new i1908(this.nodeId, this.options);          copy.n3359(this);          copy.inputs    = this.inputs.map(i => i.copy());          if (this.operation) copy.operation = this.operation.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           let op = await evalNumberValue(this.operation, parse);          if (op) op = op.q3729();           op.value     =          op.i3789 = Math.min(Math.max(0, op.value), j1317.length-1);                   switch (op.value)         {             case s1313: this.value = await g3694(this.inputs, parse); break;             case l1314: this.value = await b3691 (this.inputs, parse); break;             case a1315:  this.value = await s3692  (this.inputs, parse); break;             case j1316: this.value = await w3693 (this.inputs, parse); break;         }                   this.n4101(parse,         [                          ['operation', op        ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.operation && this.operation.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.operation) this.operation.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.operation) this.operation.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.operation) this.operation.t4087(parse);     } }


class h1909 extends f1899 {     constructor(nodeId, options)     {         super(d1122, nodeId, options);     }            copy()     {         const copy = new h1909(this.nodeId, this.options);         copy.n3359(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await g3694(this.inputs, parse);                   this.n4101(parse,          [             ['', new g4217()]                      ]);           this.validate();          return this;     } }    async function g3694(inputs, parse) {     if (isEmpty(inputs))         return d2022.NaN.copy();       const value = new d2022();       if (!isEmpty(inputs))     {         const e3690 = await evalNumberValue(inputs[0], parse);         if (!e3690.isValid()) return d2022.NaN.copy();          if (    g957(e3690.type)             && !isEmpty(e3690.items))         {             const d3689 = e3690.items[0];              value.value = d3689.k3703() != 0 ? 0 : 1;              for (let i = 1; i < e3690.items.length; i++)             {                 const item = e3690.items[i];                                  if (   item.type == t1091                     && item.k3703() == 0)                     value.value = 1;             }         }         else         {             if (e3690.type != t1091)                 return d2022.NaN.copy();              value.value = e3690.k3703() != 0 ? 0 : 1;         }           for (let i = 1; i < inputs.length; i++)         {             const val = await evalNumberValue(inputs[i], parse);             if (!val.isValid()) return d2022.NaN.copy();              if (g957(val.type))             {                 for (const item of val.items)                 {                     if (   item.type == t1091                         && item.k3703() == 0)                         value.value = 1;                 }             }             else             {                 l952(                     val.type == t1091,                      'val.type must be NUMBER_VALUE');                  if (val.k3703() == 0)                     value.value = 1;             }         }     }       return value; } 


class h1907 extends f1899 {     constructor(nodeId, options)     {         super(k1123, nodeId, options);     }            copy()     {         const copy = new h1907(this.nodeId, this.options);         copy.n3359(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await w3693(this.inputs, parse);                   this.n4101(parse,          [             ['', new g4217()]                      ]);                   this.validate();          return this;     } }    async function w3693(inputs, parse) {     if (isEmpty(inputs))         return d2022.NaN.copy();       const value = new d2022();       if (!isEmpty(inputs))     {         const e3690 = await evalNumberValue(inputs[0], parse);         if (!e3690.isValid()) return d2022.NaN.copy();           if (    g957(e3690.type)             && !isEmpty(e3690.items))         {             const d3689 = e3690.items[0];              value.value = d3689.k3703();              for (let i = 1; i < e3690.items.length; i++)             {                 const item = e3690.items[i];                                  if (item.type == t1091)                     value.value = Math.min(value.value, item.k3703());             }         }         else         {             if (e3690.type != t1091)                 return d2022.NaN.copy();              value.value = e3690.k3703();         }           for (let i = 1; i < inputs.length; i++)         {             const val = await evalNumberValue(inputs[i], parse);             if (!val.isValid()) return d2022.NaN.copy();               if (g957(val.type))             {                 for (const item of val.items)                 {                     if (item.type == t1091)                         value.value = Math.min(value.value, item.k3703());                 }             }             else             {                 l952(                     val.type == t1091,                      'val.type must be NUMBER_VALUE');                  value.value = Math.min(value.value, val.k3703());             }         }                   if (value.value != 0)             value.value = 1;     }       return value; }


class y1910 extends f1899 {     constructor(nodeId, options)     {         super(s1124, nodeId, options);     }            copy()     {         const copy = new y1910(this.nodeId, this.options);          copy.n3359(this);          copy.inputs = this.inputs.map(i => i.copy());          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await s3692(this.inputs, parse);                   this.n4101(parse,          [             ['', new g4217()]                      ]);           this.validate();          return this;     } }    async function s3692(inputs, parse) {     if (isEmpty(inputs))         return d2022.NaN.copy();       const value = new d2022();       if (!isEmpty(inputs))     {         const e3690 = await evalNumberValue(inputs[0], parse);         if (!e3690.isValid()) return d2022.NaN.copy();          if (    g957(e3690.type)             && !isEmpty(e3690.items))         {             const d3689 = e3690.items[0];              value.value = d3689.k3703();              for (let i = 1; i < e3690.items.length; i++)             {                 const item = e3690.items[i];                                  if (item.type == t1091)                     value.value = Math.max(value.value, item.k3703());             }         }         else         {             if (e3690.type != t1091)                 return d2022.NaN.copy();              value.value = e3690.k3703();         }           for (let i = 1; i < inputs.length; i++)         {             const val = await evalNumberValue(inputs[i], parse);             if (!val.isValid()) return d2022.NaN.copy();              if (g957(val.type))             {                 for (const item of val.items)                 {                     if (item.type == t1091)                         value.value = Math.max(value.value, item.k3703());                 }             }             else             {                 l952(                     val.type == t1091,                      'val.type must be NUMBER_VALUE');                                      value.value = Math.max(value.value, val.k3703());             }         }           if (value.value != 0)             value.value = 1;     }       return value; }


class k1911 extends f1899 {     constructor(nodeId, options)     {         super(p1125, nodeId, options);     }            copy()     {         const copy = new k1911(this.nodeId, this.options);         copy.n3359(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await b3691(this.inputs, parse);                   this.n4101(parse,          [             ['', new g4217()]                      ]);           this.validate();          return this;     } }    async function b3691(inputs, parse) {     if (isEmpty(inputs))         return d2022.NaN.copy();       const value = new d2022(0);       let flipped;      if (!isEmpty(inputs))     {         const e3690 = await evalNumberValue(inputs[0], parse);         if (!e3690.isValid()) return d2022.NaN.copy();          if (    g957(e3690.type)             && !isEmpty(e3690.items))         {             const d3689 = e3690.items[0];              flipped = d3689.k3703() != 0;              for (let i = 1; i < e3690.items.length; i++)             {                 const item = e3690.items[i];                                  if (   item.type == t1091                     && item.k3703() != 0)                     flipped++;             }         }         else         {             if (e3690.type != t1091)                 return d2022.NaN.copy();              flipped = e3690.k3703() != 0;         }           for (let i = 1; i < inputs.length; i++)         {             const val = await evalNumberValue(inputs[i], parse);             if (!val.isValid()) return d2022.NaN.copy();              if (g957(val.type))             {                 for (const item of val.items)                 {                     if (   item.type == t1091                         && item.k3703() != 0)                         flipped++;                     }             }             else             {                 l952(                     val.type == t1091,                      'val.type must be NUMBER_VALUE');                                      if (val.k3703() != 0)                     flipped++;             }         }           value.value = flipped == 1 ? 1 : 0;     }       return value; }


class p1912 extends i2044 {     operation;     operand;        constructor(nodeId, options)     {         super(g1126, nodeId, options);     }            reset()     {         super.reset();          this.operation = null;         this.operand   = null;     }        copy()     {         const copy = new p1912(this.nodeId, this.options);          copy.n3359(this);          if (this.operation) copy.operation = this.operation.copy();         if (this.operand  ) copy.operand   = this.operand  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const op      = await evalNumberValue(this.operation, parse);         const operand = await evalNumberValue(this.operand,   parse);          op.value = Math.min(Math.max(0, op.value), t1324.length-1);                   switch (op.value)         {             case y1318:              this.value = await a3688(this.input, operand, ((a, b) => a <  b), parse);  break;             case i1319:     this.value = await a3688(this.input, operand, ((a, b) => a <= b), parse);  break;             case y1320:         this.value = await a3688(this.input, operand, ((a, b) => a != b), parse);  break;             case g1321:             this.value = await a3688(this.input, operand, ((a, b) => a == b), parse);  break;             case f1322:  this.value = await a3688(this.input, operand, ((a, b) => a >= b), parse);  break;             case c1323:           this.value = await a3688(this.input, operand, ((a, b) => a >  b), parse);  break;         }           this.n4101(parse,         [                          ['operation', op        ],             ['operand',   operand   ]         ]);           this.validate();      return this;     }        isValid()     {         return super.isValid()             && this.operation && this.operation.isValid()             && this.operand   && this.operand  .isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.operation) this.operation.r4088(parse);         if (this.operand  ) this.operand  .r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.operation) this.operation.o4089(parse, from, force);         if (this.operand  ) this.operand  .o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.operation) this.operation.t4087(parse);         if (this.operand  ) this.operand  .t4087(parse);     } }    async function a3688(e4083, j4084, op, parse)  {     const e3690 = await evalNumberValue(e4083, parse);     const val1 = await evalNumberValue(j4084, parse);      if (   e3690 && e3690.isValid()          && val1 && val1.isValid())         return new d2022(op(e3690.k3703(), val1.k3703()) ? 1 : 0);     else                           return d2022.NaN.copy(); }


class r1913 extends u2045 {     constructor(nodeId, options)     {         super(y1127, nodeId, options);     }            copy()     {         const copy = new r1913(this.nodeId, this.options);         copy.n3359(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await a3688(             this.e4083,              this.j4084,              (a, b) => a == b,              parse);                       this.n4101(parse,          [             ['', new g4217()]                      ]);           this.validate();          return this;     } } 


class c1918 extends u2045 {     constructor(nodeId, options)     {         super(v1128, nodeId, options);     }            copy()     {         const copy = new c1918(this.nodeId, this.options);         copy.n3359(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await a3688(             this.e4083,              this.j4084,              (a, b) => a != b,              parse);                   this.n4101(parse,          [             ['', new g4217()]                      ]);           this.validate();          return this;     } }


class h1916 extends u2045 {     constructor(nodeId, options)     {         super(s1129, nodeId, options);     }            copy()     {         const copy = new h1916(this.nodeId, this.options);         copy.n3359(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await a3688(             this.e4083,              this.j4084,              (a, b) => a < b,              parse);                       this.n4101(parse,          [             ['', new g4217()]                      ]);           this.validate();          return this;     } }


class l1917 extends u2045 {     constructor(nodeId, options)     {         super(b1130, nodeId, options);     }            copy()     {         const copy = new l1917(this.nodeId, this.options);         copy.n3359(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await a3688(             this.e4083,              this.j4084,              (a, b) => a <= b,              parse);                       this.n4101(parse,          [             ['', new g4217()]                      ]);           this.validate();          return this;     } } 


class p1914 extends u2045 {     constructor(nodeId, options)     {         super(u1131, nodeId, options);     }            copy()     {         const copy = new p1914(this.nodeId, this.options);         copy.n3359(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await a3688(             this.e4083,              this.j4084,              (a, b) => a > b,              parse);                   this.n4101(parse,          [             ['', new g4217()]                      ]);           this.validate();          return this;     } }


class q1915 extends u2045 {     constructor(nodeId, options)     {         super(m1132, nodeId, options);     }            copy()     {         const copy = new q1915(this.nodeId, this.options);          copy.n3359(this);          copy.inputs = this.inputs.map(i => i.copy());          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await a3688(             this.e4083,              this.j4084,              (a, b) => a >= b,              parse);                       this.n4101(parse,          [             ['', new g4217()]                      ]);           this.validate();          return this;     } } 


class v1923 extends i2044 {     function;        constructor(nodeId, options)     {         super(e1133, nodeId, options);     }            reset()     {         super.reset();          this.function = null;     }        copy()     {         const copy = new v1923(this.nodeId, this.options);          copy.n3359(this);          if (this.function) copy.function = this.function.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalNumberValue(this.input,    parse);         const func  = await evalNumberValue(this.function, parse);          func.value = Math.min(Math.max(0, func.value), x1331.length-1);                   if (input)         {             if (g957(input.type))             {                 this.value = new x2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == t1091                         ? await getTrigValue(item, func, this.options.enabled)                         : d2022.NaN.copy());                    }             }             else                 this.value = await getTrigValue(input, func, this.options.enabled); }         else             this.value = d2022.NaN.copy();           this.n4101(parse,         [             ['type',     this.outputType()],             ['function', func             ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.function && this.function.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.function) this.function.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.function) this.function.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.function) this.function.t4087(parse);     } }    async function getTrigValue(input, func, enabled) {     l952(         input.type == t1091,         'input.type must be NUMBER_VALUE');       if (!enabled)         return input;       switch (func.value)     {         case q1325:  return await o4236   (input, false);         case q1326:  return await f4237 (input, false);         case g1327:  return await a4238(input, false);         case h1328: return await o4236   (input, true );         case i1329: return await f4237 (input, true );         case d1330: return await a4238(input, true );     } }


class m1921 extends i2044 {     constructor(nodeId, options)     {         super(j1134, nodeId, options);     }            copy()     {         const copy = new m1921(this.nodeId, this.options);                  copy.n3359(this);          if (this.input) copy.input = this.input.copy();                  return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await o4236(this.input, parse);           this.n4101(parse,          [             ['', new g4217()]                      ]);           this.validate();          return this;     }        x3633()     {         return this.value.copy();     } }    async function o4236(input, arc) {     if (!input)         return d2022.NaN.copy();      const val =          !arc          ? Math.sin (input.value)          : Math.asin(input.value);      return new d2022(val, x1004(val)); }


class y1920 extends i2044 {     constructor(nodeId, options)     {         super(u1135, nodeId, options);     }            copy()     {         const copy = new y1920(this.nodeId, this.options);                  copy.n3359(this);          if (this.input) copy.input = this.input.copy();                  return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await f4237(this.input, parse);           this.n4101(parse,          [             ['', new g4217()]                      ]);           this.validate();          return this;     } }    async function f4237(input, arc) {     if (!input)         return d2022.NaN.copy();      const val =          !arc          ? Math.cos (input.value)          : Math.acos(input.value);     return new d2022(val, x1004(val)); }


class h1922 extends i2044 {     constructor(nodeId, options)     {         super(h1136, nodeId, options);     }            copy()     {         const copy = new h1922(this.nodeId, this.options);                  copy.n3359(this);          if (this.input) copy.input = this.input.copy();                  return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await a4238(this.input, parse);           this.n4101(parse,          [             ['', new g4217()]                      ]);           this.validate();          return this;     } }    async function a4238(input, arc) {     if (!input)         return d2022.NaN.copy();      const val =          !arc          ? Math.tan (input.value)          : Math.atan(input.value);          return new d2022(val, x1004(val)); }


class n1919 extends g2043 {     x;     y;            constructor(nodeId, options)     {         super(x1137, nodeId, options);     }            reset()     {         super.reset();          this.x = null;         this.y = null;     }        copy()     {         const copy = new n1919(this.nodeId, this.options);          copy.n3359(this);          if (this.x) copy.x = this.x.copy();         if (this.y) copy.y = this.y.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const x = await evalNumberValue(this.x, parse);         const y = await evalNumberValue(this.y, parse);           this.value = new d2022(Math.atan2(y.value, x.value));           this.n4101(parse,         [                          ['x',     x         ],             ['y',     y         ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.x && this.x.isValid()             && this.y && this.y.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.x) this.x.r4088(parse);         if (this.y) this.y.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.x) this.x.o4089(parse, from, force);         if (this.y) this.y.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.x) this.x.t4087(parse);         if (this.y) this.y.t4087(parse);     } } 


class p1928 extends i2044 {     from;        constructor(nodeId, options)     {         super(l1138, nodeId, options);     }            reset()     {         super.reset();          this.from = null;     }        copy()     {         const copy = new p1928(this.nodeId, this.options);          copy.n3359(this);          if (this.from) copy.from = this.from.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new d2022(0);                   const input = await evalNumberValue(this.input, parse);         const from  = await evalNumberValue(this.from,  parse);           if (input)         {             if (g957(input.type))             {                 this.value = new x2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == t1091                         ? getConvertAngleValue(item, from, this.options.enabled)                         : d2022.NaN.copy());                    }             }             else                 this.value = getConvertAngleValue(input, from, this.options.enabled);         }         else             this.value = d2022.NaN.copy();           this.n4101(parse,         [             ['type',  this.outputType()],                          ['from',  from             ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.from && this.from.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.from) this.from.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.from) this.from.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.from) this.from.t4087(parse);     } }    function getConvertAngleValue(input, from, enabled) {     l952(          input == t1091,          'input must be NUMBER_VALUE');               const value = input;          if (enabled)     {         switch (from.value)         {             case 0: value.value = value.value/360 * Tau; break;             case 1: value.value = value.value/Tau * 360; break;         }          value.decimals = x1004(value.value);     }       return value; }


class w1992 extends i2044 {     constructor(nodeId, options)     {         super(z1144, nodeId, options);     }        copy()     {         const copy = new w1992(this.nodeId, this.options);                  copy.n3359(this);          copy.value = this.value;                  return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           if (this.input)             this.value = await evalTextValue(this.input, parse);         else if (this.value)             await this.value.eval(parse);         else             this.value = new j2033();           this.n4101(parse,         [             ['value', this.value]         ]);                   this.validate();          return this;     }        isValid()     {         return   !this.input                && this.value != b963              || this.input.isValid();     } }


class f2000 extends i2044 {     length;        constructor(nodeId, options)     {         super(a1145, nodeId, options);     }            reset()     {         super.reset();          this.length = null;     }        copy()     {         const copy = new f2000(this.nodeId, this.options);          copy.n3359(this);          if (this.length) copy.length = this.length.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalTextValue(this.input, parse);          if (   input             && input.value)         {             l952(input.type == t1143, 'input must be TEXT_VALUE');              this.length = new d2022(input.value.length);         }         else             this.length = d2022.NaN.copy();               this.n4101(parse,         [             ['length', this.length]         ]);           this.validate();          return this;     } } 


class z2007 extends i2044 {     start = null;     end   = null;            constructor(nodeId, options)     {         super(x1146, nodeId, options);     }            reset()     {         super.reset();          this.start = null;         this.end   = null;     }        copy()     {         const copy = new z2007(this.nodeId, this.options);          copy.n3359(this);          if (this.start) copy.start = this.start.copy();         if (this.end  ) copy.end   = this.end  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const start = await evalNumberValue(this.start, parse);         const end   = await evalNumberValue(this.end,   parse);           if (this.input)         {             const input = await evalTextValue(this.input, parse);                          if (g957(input.type))             {                 this.value = new x2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == t1143                         ? x3430(item, start, end, this.options.enabled)                         : new j2033());                    }             }             else             {                 this.value = x3430(input, start, end, this.options.enabled);             }         }         else             this.value = new j2033();           this.n4101(parse,         [                          ['type',  this.outputType()],             ['start', start            ],             ['end',   end              ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.start && this.start.isValid()             && this.end   && this.end  .isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.start) this.start.r4088(parse);         if (this.end  ) this.end  .r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.start) this.start.o4089(parse, from, force);         if (this.end  ) this.end  .o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.start) this.start.t4087(parse);         if (this.end  ) this.end  .t4087(parse);     } }    function x3430(input, start, end, enabled) {     l952(input.type == t1143, 'input.type must be TEXT_VALUE');                     const value = input.copy();      if (enabled)     {         if (start.value.length > 0) value.value = k954(value.value, r1490(start.value));         if (end  .value.length > 0) value.value = a955  (value.value, r1490(end  .value));     }      return value; }


class k2004 extends i2044 {     start = null;     end   = null;            constructor(nodeId, options)     {         super(z1147, nodeId, options);     }            reset()     {         super.reset();          this.start = null;         this.end   = null;     }        copy()     {         const copy = new k2004(this.nodeId, this.options);          copy.n3359(this);          if (this.start) copy.start = this.start.copy();         if (this.end  ) copy.end   = this.end  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalTextValue  (this.input, parse);         const start = await evalNumberValue(this.start, parse);         const end   = await evalNumberValue(this.end,   parse);           let length = 0;           if (   input             && start             && end)         {             length = input.value.length;                          this.value = input.copy();                          l952(this.value.type == t1143, 'this.value.type must be TEXT_VALUE');                                               const _end =                 end.isValid()                 ? end                 : new d2022(input.value.length);               if (this.options.enabled)             {                 const endValue =                      _end.value < 0                     ? length + _end.value                     : _end.value;                  if (start.value <= endValue)                     this.value.value = this.value.value.substring(start.value, endValue);                 else                     this.value = new j2033();             }             else                 this.value = input.copy();         }         else             this.value = new j2033();           this.n4101(parse,         [             ['length',     new d2022(length)                        ],              ['fullLength', new d2022(input ? input.value.length : 0)],              ['start',      start                                          ],             ['end',        end                                            ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.start && this.start.isValid()             && this.end   && this.end  .isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.start) this.start.r4088(parse);         if (this.end  ) this.end  .r4088(parse);     }        r4088(parse)     {         super.r4088(parse);          if (this.start) this.start.r4088(parse);         if (this.end  ) this.end  .r4088(parse);     }        t4087(parse, from)     {         super.t4087(parse, from);          if (this.start) this.start.t4087(parse, from);         if (this.end  ) this.end  .t4087(parse, from);     } } 


class l1995 extends u2045 {     first;     last;     all;        constructor(nodeId, options)     {         super(a1148, nodeId, options);     }            reset()     {         super.reset();          this.first = null;         this.last  = null;         this.all   = null;     }        copy()     {         const copy = new l1995(this.nodeId, this.options);          copy.n3359(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const e4083 = await evalTextValue(this.e4083, parse);         const j4084 = await evalTextValue(this.j4084, parse);               if (   e4083 && e4083.isValid()              && j4084 && j4084.isValid())         {             const indices = [];             let   index   = 0;              if (j4084.value != '')             {                 while (index != -1)                  {                     index = e4083.value.indexOf(j4084.value, index);                      if (index != -1)                      {                         indices.push(index);                         index += 1;                     }                 }                                   this.value = new d2022(indices.length > 0 ? 1 : 0);                  this.first = indices.length > 0 ? new d2022(indices.at( 0)) : d2022.NaN.copy();                 this.last  = indices.length > 0 ? new d2022(indices.at(-1)) : d2022.NaN.copy();                  this.all   = new x2021();                  for (const index of indices)                     this.all.items.push(new d2022(index));             }             else             {                 this.value = new d2022(1);                  this.first = d2022.NaN.copy();                 this.last  = d2022.NaN.copy();                 this.all   =   x2021.NaN.copy();             }         }         else                           {             this.value = d2022.NaN.copy();             this.first = d2022.NaN.copy();             this.last  = d2022.NaN.copy();             this.all   =   x2021.NaN.copy();         }               this.n4101(parse,         [             ['value', this.value],             ['first', this.first],             ['last',  this.last ],             ['all',   this.all  ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.first && this.first.isValid()             && this.last  && this.last .isValid()             && this.all   && this.all  .isValid();     } }


class d1993 extends i2044 {     case;            constructor(nodeId, options)     {         super(h1149, nodeId, options);     }            reset()     {         super.reset();          this.case = null;     }        copy()     {         const copy = new d1993(this.nodeId, this.options);          copy.n3359(this);          if (this.case) copy.case = this.case.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalTextValue  (this.input, parse);         const h3659 = await evalNumberValue(this.case,  parse);           if (input)         {             if (this.options.enabled)             {                 if (g957(input.type))                 {                     this.value = new x2021();                      for (let i = 0; i < input.items.length; i++)                     {                         const item = input.items[i];                          this.value.items.push(                             item.type == t1143                             ? getTextCaseValue(item, h3659)                             : new j2033());                        }                 }                 else                 {                     this.value = getTextCaseValue(input, h3659);                 }             }             else                 this.value = input.copy();         }         else             this.value = new j2033();           this.n4101(parse,         [                          ['type',   this.outputType()],             ['case',  h3659             ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.case && this.case.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.case) this.case.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.case) this.case.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.case) this.case.t4087(parse);     } }    function getTextCaseValue(input, h3659) {     l952(input.type == t1143, 'input.type must be TEXT_VALUE');      const val   = input.value;     const value = new j2033();           if (h3659.value == 0)           value.value = val.toLowerCase();      else if (h3659.value == 1)     {         if (val.length > 0) value.value += val.substring(0, 1).toUpperCase();         if (val.length > 1) value.value += val.substring(1)   .toLowerCase();     }      else if (h3659.value == 2)     {         let i = 0;         while (i < val.length)         {             while (i < val.length                 && /\s/.test(val.charAt(i)))                 value.value += val.charAt(i++);              if (i < val.length)                 value.value += val.charAt(i++).toUpperCase();              while (i < val.length                 && !/\s/.test(val.charAt(i)))                 value.value += val.charAt(i++).toLowerCase();         }     }      else if (h3659.value == 3)          value.value = val.toUpperCase();       return value; }


class z1991 extends i2044 {     base;     decimals;     thousands;            constructor(nodeId, options)     {         super(s1157, nodeId, options);     }            reset()     {         super.reset();          this.base      = null;         this.decimals  = null;         this.thousands = null;     }        copy()     {         const copy = new z1991(this.nodeId, this.options);          copy.n3359(this);          if (this.base     ) copy.base      = this.base     .copy();         if (this.decimals ) copy.decimals  = this.decimals .copy();         if (this.thousands) copy.thousands = this.thousands.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input     = await evalNumberValue(this.input,     parse);         const base      = await evalNumberValue(this.base,      parse);         const decimals  = await evalNumberValue(this.decimals,  parse);         const thousands = await evalNumberValue(this.thousands, parse);           if (input)         {             if (g957(input.type))             {                 this.value = new x2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == t1091                         ? g3431(item, base, decimals, thousands)                         : j2033.NaN.copy());                    }             }             else             {                 this.value = g3431(input, base, decimals, thousands);             }         }         else             this.value = j2033.NaN.copy();           this.n4101(parse,         [                          ['type',      this.outputType()],             ['base',      base             ],             ['decimals',  decimals         ],             ['thousands', thousands        ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.base      && this.base     .isValid()             && this.decimals  && this.decimals .isValid()             && this.thousands && this.thousands.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.base     ) this.base     .r4088(parse);         if (this.decimals ) this.decimals .r4088(parse);         if (this.thousands) this.thousands.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.base     ) this.base     .o4089(parse, from, force);         if (this.decimals ) this.decimals .o4089(parse, from, force);         if (this.thousands) this.thousands.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.base     ) this.base     .t4087(parse);         if (this.decimals ) this.decimals .t4087(parse);         if (this.thousands) this.thousands.t4087(parse);     } }    function g3431(input, base, decimals, thousands) {     return input.isValid()          ? new j2033(h1006(                input.value,                -input.decimals,                 base.value == 1,                 decimals.value,                 thousands.value))          : new j2033('?'); }


class a1989 extends i2044 {     format;            constructor(nodeId, options)     {         super(d1158, nodeId, options);     }       reset()     {         super.reset();          this.format = null;     }            copy()     {         const copy = new a1989(this.nodeId, this.options);          copy.n3359(this);          if (this.format) copy.format = this.format.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalColorValue (this.input,  parse);         const format = await evalNumberValue(this.format, parse);           if (input)         {             if (g957(input.type))             {                 this.value = new x2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == t1091                         ? getColorToTextValue(item, format)                         : j2033.NaN.copy());                    }             }             else             {                 this.value = getColorToTextValue(input, format);             }         }          else             this.value = j2033.NaN.copy();           this.n4101(parse,         [             ['type',   this.outputType()],             ['format', format           ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.format && this.format.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.format) this.format.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.format) this.format.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.format) this.format.t4087(parse);     } }    function getColorToTextValue(input, format) {     let str = b963;      const rgb = input.e3242();      switch (format.value)     {         case 0:              str = f151(rgb);             break;          case 1:              str =                    h1006(rgb[0], -3) + ', '                 + h1006(rgb[1], -3) + ', '                 + h1006(rgb[2], -3);             break;          case 2:              str =                    Math.round(rgb[0] * 255) + ', '                 + Math.round(rgb[1] * 255) + ', '                 + Math.round(rgb[2] * 255);             break;          case 3:              str = createColorName(rgb);             break;     }      return new j2033(str); }


class d2006 extends i2044 {     base      = null;     decimals  = null;     thousands = null;            constructor(nodeId, options)     {         super(w1159, nodeId, options);     }            reset()     {         super.reset();          this.base      = null;         this.decimals  = null;         this.thousands = null;     }        copy()     {         const copy = new d2006(this.nodeId, this.options);          copy.n3359(this);          if (this.base     ) copy.base      = this.base     .copy();         if (this.decimals ) copy.decimals  = this.decimals .copy();         if (this.thousands) copy.thousands = this.thousands.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input     = await evalTextValue  (this.input,     parse);         const base      = await evalNumberValue(this.base,      parse);         const decimals  = await evalNumberValue(this.decimals,  parse);         const thousands = await evalTextValue  (this.thousands, parse);           if (   input             && input.isValid())         {             if (g957(input.type))             {                 this.value = new x2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == t1143                         ? getTextToNumberValue(item, base, decimals, thousands)                         : d2022.NaN.copy());                    }             }             else                 this.value = getTextToNumberValue(input, base, decimals, thousands);         }          else             this.value = d2022.NaN.copy();           this.n4101(parse,         [             ['type',      this.outputType()],             ['base',      base             ],             ['decimals',  decimals         ],             ['thousands', thousands        ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.base      && this.base     .isValid()             && this.decimals  && this.decimals .isValid()             && this.thousands && this.thousands.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.base     ) this.base     .r4088(parse);         if (this.decimals ) this.decimals .r4088(parse);         if (this.thousands) this.thousands.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.base     ) this.base     .o4089(parse, from, force);         if (this.decimals ) this.decimals .o4089(parse, from, force);         if (this.thousands) this.thousands.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.base     ) this.base     .t4087(parse);         if (this.decimals ) this.decimals .t4087(parse);         if (this.thousands) this.thousands.t4087(parse);     } }    function getTextToNumberValue(input, base, decimals, thousands) {     let num   = Number.NaN;     let value = input.value;      if (thousands)         value = value.replaceAll(thousands.value, '');           if (base)     {         switch (base.value)         {             case 0:              {                 if (value.lastIndexOf(decimals.value) < 0)                     num = parseInt(value.replace(/\D/g, ''), 10);                 else                 {                     value = o1497(value, decimals.value, '.');                     num   = parseFloat(value);                 }                          break;             }             case 1:              {                 const decIndex = value.lastIndexOf(decimals.value);                  if (decIndex < -1)                     num = parseInt(value, 16);                 else                 {                     const whole = value.slice(0, decIndex);                     const frac  = value.slice(decIndex + decimals.value.length);                      num =                          parseInt(whole, 16)                         + frac.split('')                             .reduce((sum, digit, index) => sum + parseInt(digit, 16) / Math.pow(16, index + 1), 0);                 }                  break;             }         }     }       return new d2022(num, x1004(num)); }


class f2005 extends i2044 {     constructor(nodeId, options)     {         super(u1160, nodeId, options);     }            copy()     {         const copy = new f2005(this.nodeId, this.options);          copy.n3359(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           if (this.input)         {             const input = await evalTextValue(this.input, parse);              if (g957(input.type))             {                 this.value = new x2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == t1143                         ? getTextToColorValue(item)                         : d2022.NaN.copy());                    }             }             else             {                 this.value = getTextToColorValue(input);             }         }         else             this.value = s2010.NaN.copy();           this.n4101(parse,         [             ['value', this.value       ],             ['type',  this.outputType()]         ]);           this.validate();          return this;     } }    function getTextToColorValue(input) {     const str = input.value.trim();       let rgb;        if (settings.preferHtmlColorNames)     {                    let webColor = l1499.find(wc => wc.name.toLowerCase() == str);         if (!webColor) webColor = l1499.find(wc => f1491(wc.name.toLowerCase(), str) <= 1);                  if (webColor)              rgb = e153(webColor.color);     }     else     {         const hsl = parseColorName(str);          rgb =              hsl              ? f50(hsl)              : e153(str);     }           return s2010.k3773(t4142(rgb)); }


class c1988 extends i2044 {     constructor(nodeId, options)     {         super(h1154, nodeId, options);     }            copy()     {         const copy = new c1988(this.nodeId, this.options);          copy.n3359(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalNumberValue(this.input, parse);           if (input)         {             if (g957(input.type))             {                 this.value = new x2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == t1091                         ? getCodeToCharacterValue(item)                         : j2033.NaN.copy());                    }             }             else             {                 this.value = getCodeToCharacterValue(input);             }         }         else             this.value = j2033.NaN.copy();           this.n4101(parse,         [                          ['type',  this.outputType()]         ]);           this.validate();          return this;     } }    function getCodeToCharacterValue(input) {     return new j2033(String.fromCharCode(Math.min(Math.max(0, input.value), 0xffff))); }


class b1987 extends i2044 {     constructor(nodeId, options)     {         super(f1155, nodeId, options);     }            copy()     {         const copy = new b1987(this.nodeId, this.options);          copy.n3359(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalTextValue(this.input, parse);           if (input)         {             if (g957(input.type))             {                 this.value = new x2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == t1143                         ? getCharacterToCodeValue(item)                         : d2022.NaN.copy());                    }             }             else             {                 this.value = getCharacterToCodeValue(input);             }         }         else             this.value = d2022.NaN.copy();           this.n4101(parse,         [                          ['type',  this.outputType()]         ]);           this.validate();          return this;     } }    function getCharacterToCodeValue(input) {     return input.value.length > 0          ? new d2022(input.value.charCodeAt(0))          : d2022.NaN.copy(); }


class h1990 extends g2043 {     name;     index;            constructor(nodeId, options)     {         super(f1156, nodeId, options);     }            reset()     {         super.reset();          this.index = null;     }        copy()     {         const copy = new h1990(this.nodeId, this.options);          copy.n3359(this);          if (this.name ) copy.name  = this.name .copy();         if (this.index) copy.index = this.index.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const name  = await evalTextValue  (this.name,  parse);         const index = await evalNumberValue(this.index, parse);           switch (name.value)         {             case 0: this.value = new j2033(                 [                     'monday',                      'tuesday',                      'wednesday',                      'thursday',                      'friday',                      'saturday',                      'sunday'                 ]                  [index.value-1]);                  break;              case 1: this.value = new j2033(                 [                     'january',                      'february',                      'march',                      'april',                      'may',                      'june',                      'july',                     'august',                     'september',                     'october',                     'november',                     'december'                 ]                  [index.value-1]);                  break;              case 2:                 this.value = new j2033(w4039[index.value]);                 break;          }           this.n4101(parse,         [                          ['name',  name      ],             ['index', index     ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.index && this.index.isValid()             && this.name  && this.name .isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.index) this.index.r4088(parse);         if (this.name ) this.name .r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.index) this.index.o4089(parse, from, force);         if (this.name ) this.name .o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.index) this.index.t4087(parse);         if (this.name ) this.name .t4087(parse);     } } 


class x2002 extends i2044 {     what  = null;     with  = null;     regex = null;        constructor(nodeId, options)     {         super(a1150, nodeId, options);     }            reset()     {         super.reset();          this.what  = null;         this.with  = null;         this.regex = null;     }        copy()     {         const copy = new x2002(this.nodeId, this.options);          copy.n3359(this);          if (this.what ) copy.what  = this.what .copy();         if (this.with ) copy.with  = this.with .copy();         if (this.regex) copy.regex = this.regex.copy();          if (this.value) copy.value = this.value.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const  input = await evalTextValue  (this.input, parse);         const _what  = await evalTextValue  (this.what,  parse);         const _with  = await evalTextValue  (this.with,  parse);         const _regex = await evalNumberValue(this.regex, parse);           if (input)         {             if (this.options.enabled)             {                 if (g957(input.type))                 {                     this.value = new x2021();                      for (let i = 0; i < input.items.length; i++)                     {                         const item = input.items[i];                          this.value.items.push(                             item.type == t1143                             ? getReplaceValue(item, _what, _with, _regex)                             : new j2033());                        }                 }                 else                 {                     this.value = getReplaceValue(input, _what, _with, _regex);                 }             }             else                 this.value = input.copy();         }         else             this.value = new j2033();           this.n4101(parse,         [                          ['type',   this.outputType()],             ['what',  _what             ],             ['with',  _with             ],             ['regex', _regex            ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.what  && this.what .isValid()             && this.with  && this.with .isValid()             && this.regex && this.regex.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.what ) this.what .r4088(parse);         if (this.with ) this.with .r4088(parse);         if (this.regex) this.regex.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.what ) this.what .o4089(parse, from, force);         if (this.with ) this.with .o4089(parse, from, force);         if (this.regex) this.regex.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.what ) this.what .t4087(parse);         if (this.with ) this.with .t4087(parse);         if (this.regex) this.regex.t4087(parse);     } }    function getReplaceValue(input, _what, _with, _regex) {     l952(input.type == t1143, 'input.type must be TEXT_VALUE');      const value = new j2033();           if (_regex.value > 0)     {         try         {             value.value = input.value.replace(                 new RegExp(unescapeRegexPattern(_what.value), 'gu'),                 unescapeRegexReplacement(_with.value));         }         catch (e)         {             h4042(e.message, {error: true});         }     }     else if (input.value)     {         value.value = input.value.replaceAll(             r1490(_what.value),             r1490(_with.value));     }       return value; }


class h1999 extends g2043 {     inputs = [];      with = null;            constructor(nodeId, options)     {         super(n1151, nodeId, options);     }        reset()     {         super.reset();          this.inputs = [];                  this.with = null;     }           copy()     {         const copy = new h1999(this.nodeId, this.options);         copy.n3359(this);                  copy.inputs = this.inputs.map(i => i.copy());         copy.with   = this.with;          return copy;     }        isCached()     {         for (const input of this.inputs)             if (!input.isCached())                 return false;          return super.isCached();     }        async eval(parse)     {         if (this.isCached())             return this;           const _with = await evalTextValue(this.with, parse);          this.value = await evalJoinInputs(this.inputs, _with, parse);                   this.n4101(parse,         [                          ['with',  _with     ]         ]);           this.validate();          return this;     }        isValid()     {         return !this.inputs.find(i => !i.isValid())             && this.with && this.with.isValid();     }        r4088(parse)     {         super.r4088(parse);          this.inputs.forEach(i => i.r4088(parse));          if (this.with) this.with.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          this.inputs.forEach(i => i.o4089(parse, from, force));          if (this.with) this.with.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          this.inputs.forEach(i => i.t4087(parse));          if (this.with) this.with.t4087(parse);     } }    async function evalJoinInputs(inputs, _with, parse) {     if (isEmpty(inputs))         return new j2033();       const value = new j2033();     const w     = r1490(_with.value);      for (let i = 0; i < inputs.length; i++)     {         const val = await evalTextValue(inputs[i], parse);         if (!val) continue;           if (i > 0)             value.value += w;           if (g957(val.type))         {             for (let j = 0; j < val.items.length; j++)             {                 if (j > 0)                     value.value += w;                   const item = val.items[j];                  if (item.type == t1143)                     value.value += item.value;             }         }         else         {             l952(val.type == t1143, 'val.type must be TEXT_VALUE');              value.value += val.value;         }     }       return value; }


class b2001 extends i2044 {     g3655   = null;     z3656 = null;     d3657     = null;     d3658   = null;                    constructor(nodeId, options)     {         super(n1152, nodeId, options);     }            reset()     {         super.reset();                  this.g3655   = null;         this.z3656 = null;         this.d3657     = null;         this.d3658   = null;     }        copy()     {         const copy = new b2001(this.nodeId, this.options);          copy.n3359(this);          if (this.g3655  ) copy.g3655   = this.g3655  .copy();         if (this.z3656) copy.z3656 = this.z3656.copy();         if (this.d3657    ) copy.d3657     = this.d3657    .copy();         if (this.d3658  ) copy.d3658   = this.d3658  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const g3655   = await evalTextValue  (this.g3655,   parse);         const z3656 = await evalNumberValue(this.z3656, parse);         const d3657     = await evalTextValue  (this.d3657,     parse);         const d3658   = await evalNumberValue(this.d3658,   parse);           if (this.input)         {             const input = await evalTextValue(this.input, parse);                          if (g957(input.type))             {                 this.value = new x2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == t1143                         ? getPadValue(                             item,                              g3655,                              z3656,                              d3657,                              d3658,                              this.options.enabled)                         : new j2033());                    }             }             else             {                 this.value = getPadValue(                     input,                      g3655,                      z3656,                      d3657,                      d3658,                      this.options.enabled);             }         }         else             this.value = new j2033();           this.n4101(parse,         [                          ['type',       this.outputType()],             ['startPad',   g3655         ],             ['startCount', z3656       ],             ['endPad',     d3657           ],             ['endCount',   d3658         ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.g3655   && this.g3655  .isValid()             && this.z3656 && this.z3656.isValid()             && this.d3657     && this.d3657    .isValid()             && this.d3658   && this.d3658  .isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.g3655  ) this.g3655  .r4088(parse);         if (this.z3656) this.z3656.r4088(parse);         if (this.d3657    ) this.d3657    .r4088(parse);         if (this.d3658  ) this.d3658  .r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.g3655  ) this.g3655  .o4089(parse, from, force);         if (this.z3656) this.z3656.o4089(parse, from, force);         if (this.d3657    ) this.d3657    .o4089(parse, from, force);         if (this.d3658  ) this.d3658  .o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.g3655  ) this.g3655  .t4087(parse);         if (this.z3656) this.z3656.t4087(parse);         if (this.d3657    ) this.d3657    .t4087(parse);         if (this.d3658  ) this.d3658  .t4087(parse);     } }    function getPadValue(input, g3655, z3656, d3657, d3658, enabled) {     l952(input.type == t1143, 'input.type must be TEXT_VALUE');      const value = input.copy();          if (enabled)         value.value = input.value             .padStart(z3656.value, r1490(g3655.value))             .padEnd  (  d3658.value, d3657.value != '' ? r1490(d3657.value) : r1490(g3655.value));      return value; }


class s2003 extends i2044 {     separator;        constructor(nodeId, options)     {         super(d1161, nodeId, options);     }        reset()     {         super.reset();          this.separator = null;     }           copy()     {         const copy = new s2003(this.nodeId, this.options);          copy.n3359(this);          if (this.separator) copy.separator = this.separator.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const separator = await evalTextValue(this.separator, parse);           this.value = new x2021();           if (   this.input             && separator)         {             const input = await evalTextValue(this.input, parse);                          if (   input                 && input.value)             {                 l952(input.type == t1143, 'input must be TEXT_VALUE');                 const items = input.value.split(r1490(separator.value));                  for (const item of items)                     this.value.items.push(new j2033(item));             }         }               this.n4101(parse,         [             ['length',    new d2022(this.value.items.length)],             ['separator', separator                               ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.separator && this.separator.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.separator) this.separator.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.separator) this.separator.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.separator) this.separator.t4087(parse);     } } 


class p1994 extends u2045 {     operation;        constructor(nodeId, options)     {         super(d1153, nodeId, options);     }            reset()     {         super.reset();          this.operation = null;     }        copy()     {         const copy = new p1994(this.nodeId, this.options);          copy.n3359(this);          if (this.operation) copy.operation = this.operation.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = d2022.NaN.copy();                           const op = await evalNumberValue(this.operation, parse);                   if (op)         {             op.value = Math.min(Math.max(0, op.value), t1324.length-1);              switch (op.value)             {                 case y1318:              this.value = await evalCompareInputs(this.e4083, this.j4084, ((a, b) => a <  b), parse);  break;                 case i1319:     this.value = await evalCompareInputs(this.e4083, this.j4084, ((a, b) => a <= b), parse);  break;                 case y1320:         this.value = await evalCompareInputs(this.e4083, this.j4084, ((a, b) => a != b), parse);  break;                 case g1321:             this.value = await evalCompareInputs(this.e4083, this.j4084, ((a, b) => a == b), parse);  break;                 case f1322:  this.value = await evalCompareInputs(this.e4083, this.j4084, ((a, b) => a >= b), parse);  break;                 case c1323:           this.value = await evalCompareInputs(this.e4083, this.j4084, ((a, b) => a >  b), parse);  break;             }         }           this.n4101(parse,         [             ['value',     this.value],             ['operation', op        ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.operation && this.operation.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.operation) this.operation.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.operation) this.operation.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.operation) this.operation.t4087(parse);     } }    async function evalCompareInputs(e4083, j4084, op, parse)  {     const e3690 = await evalTextValue(e4083, parse);     const val1 = await evalTextValue(j4084, parse);      if (   e3690 && e3690.isValid()          && val1 && val1.isValid())         return new d2022(op(e3690.value, val1.value) ? 1 : 0);     else                           return new g4217(); }


class w1996 extends i2044 {     a3648;     n3649;        constructor(nodeId, options)     {         super(o1163, nodeId, options);     }            reset()     {         super.reset();          this.a3648    = null;         this.n3649 = null;     }        copy()     {         const copy = new w1996(this.nodeId, this.options);          copy.n3359(this);          if (this.a3648   ) copy.a3648    = this.a3648   .copy();         if (this.n3649) copy.n3649 = this.n3649.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const a3648    = await evalTextValue(this.a3648,    parse);         const n3649 = await evalTextValue(this.n3649, parse);           this.value = new x2021();           let maxColumns = 0;                   let nRows    = 0;         let nColumns = 0;           if (   this.input             && a3648             && n3649             && a3648.value != '')         {             const input = await evalTextValue(this.input, parse);                           const rows =                     input                 && input.value                             ? input.value.split(r1490(a3648.value))                 : [];               for (const _row of rows)             {                 const cells =                      _row                     ? _row.split(r1490(n3649.value))                     : [];                   const row = new x2021();                  for (const cell of cells)                     row.items.push(new j2033(cell));                  maxColumns = Math.max(maxColumns, row.items.length);                   this.value.items.push(row);             }               nRows    = this.value.items.length;             nColumns = maxColumns;         }               this.n4101(parse,         [             ['rowSeparator',    a3648             ],             ['columnSeparator', n3649          ],             ['rows',            new d2022(nRows   )],             ['columns',         new d2022(nColumns)]         ]);                   if (parse.settings.l3734)         {             this.n4101(parse,             [                 ['preview', new x2021(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.a3648    && this.a3648   .isValid()             && this.n3649 && this.n3649.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.a3648   ) this.a3648   .r4088(parse);         if (this.n3649) this.n3649.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.a3648   ) this.a3648   .o4089(parse, from, force);         if (this.n3649) this.n3649.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.a3648   ) this.a3648   .t4087(parse);         if (this.n3649) this.n3649.t4087(parse);     } } 


class GTextJson extends i2044 {     constructor(nodeId, options)     {         super(t3505, nodeId, options);     }            copy()     {         const copy = new GTextJson(this.nodeId, this.options);          copy.n3359(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new x2021();           if (this.input)         {             const input = await evalTextValue(this.input, parse);                          try             {                 const json = JSON.parse(input.value);                 this.value = this.evalItems(json);             }             catch (e)             {                 this.value = new x2021();             }         }               this.n4101(parse,         [             ['length',  new d2022(this.value.items.length)]                      ]);                   if (parse.settings.u3733)         {             this.n4101(parse,             [                 ['preview', this.value]             ],             true);         }           this.validate();          return this;     }        evalItems(json)     {         let list = new x2021();           for (const key in json)         {             if (   typeof json[key] === 'object'                 && json[key] !== null)             {                 const a111 = this.evalItems(json[key]);                 a111.valueId = key;                 list.items.push(a111);             }             else             {                 let value;                  if (   typeof json[key] === 'number'                     || c1487(json[key]))                     value = d2022.fromString(json[key].toString());                 else if (typeof json[key] === 'boolean')                     value = new d2022(r923(json[key].toString()) ? 1 : 0);                 else                     value = new j2033(json[key]);                                       value.valueId =                      key == 'value'                     ? '(value)'                      : key;                  list.items.push(value);             }         }                   return list;     } } 


class r1997 extends g2043 {     request;     p4212;        constructor(nodeId, options)     {         super(q1164, nodeId, options);     }            reset()     {         super.reset();          this.request     = null;         this.p4212 = null;     }        copy()     {         const copy = new r1997(this.nodeId, this.options);          copy.n3359(this);          if (this.request    ) copy.request     = this.request    .copy();         if (this.p4212) copy.p4212 = this.p4212.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const request     = await evalTextValue(this.request,     parse);         const p4212 = await evalTextValue(this.p4212, parse);                   x2077(this.nodeId);           if (p4212.value == '')         {             try              {                 const response = await fetch(request.value);                 const content  = await response.text();                                  this.value = new j2033(content);             }             catch (e)             {                                                   this.value =                      request.value.trim() == NULL                     ? new j2033()                     : new j2033('invalid request');             }         }         else         {             this.value = this.p4212.copy();         }           this.n4101(parse,         [             ['value',   this.value],             ['request', request   ]         ]);                           if (parse.settings.u3733)         {             this.n4101(parse,             [                 ['preview', this.value]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return this.request && this.request.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.request) this.request.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.request) this.request.o4089(parse, from, force);          this.p4212 = new j2033();     }        t4087(parse)     {         super.t4087(parse);          if (this.request) this.request.t4087(parse);     } }


class d1998 extends g2043 {               p4212 = null;        constructor(nodeId, options)     {         super(d1165, nodeId, options);     }            reset()     {         super.reset();          this.p4212 = null;     }        copy()     {         const copy = new d1998(this.nodeId, this.options);          copy.n3359(this);          if (this.p4212) copy.p4212 = this.p4212.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const p4212 = await evalTextValue(this.p4212, parse);                          x2077(this.nodeId);           this.value = p4212 ?? new j2033();           this.n4101(parse,         [             ['', new g4217()]                      ]);                           if (parse.settings.u3733)         {             this.n4101(parse,             [                 ['preview', this.value]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return false;     }        r4088(parse)     {         super.r4088(parse);          if (this.path) this.path.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.path) this.path.o4089(parse, from, force);               }        t4087(parse)     {         super.t4087(parse);          if (this.path) this.path.t4087(parse);     } }


class v1796 {     name;      max;     value;          constructor(name = '', max = 0, value = 0)     {         this.name  = name;         this.max   = max;         this.value = value;     } }    async function w1797(parse,                               nodeId,                               color,                               order, p3684, r3685, g3686,                               f3713, w3714, d3715, z3716)  {     const d3717 = b4194(k4200(color));           let h1806 = [...color],         o1807 = null,          s1808 = order ? order.value : -1,         s1809     = -1,         h1810     = -1,         y1811     = -1;       let progress = 0,         total    = 6 * Math.pow(2, Tau);               let d = 1;              parse.y3640 += 1024;       dLoop:     while (d > 1/1024)     {         if (parse.p3641)             break dLoop;          let _closestColor = [...h1806];           for (let g3683 = 0; g3683 < 6; g3683++)         {             if (parse.p3641)                 break dLoop;              h1806 = [..._closestColor];              const [min1, min2, min3] = o1803(color[0], g3683);             const [max1, max2, max3] = l1804(color[0], g3683);              let start1 = b1035(min1, s1809, 1-d),  h1812 = b1035(max1, s1809, 1-d),                 start2 = b1035(min2, h1810, 1-d),  y1813 = b1035(max2, h1810, 1-d),                 start3 = b1035(min3, y1811, 1-d),  o1814 = b1035(max3, y1811, 1-d);                                                                                                                                     if (w3714) { s1809 = p3684.k3703(); start1 = s1809; h1812 = s1809+Epsilon; }             if (d3715) { h1810 = r3685.k3703(); start2 = h1810; y1813 = h1810+Epsilon; }             if (z3716) { y1811 = g3686.k3703(); start3 = y1811; o1814 = y1811+Epsilon; }                                                   [ h1806,             o1807,             s1808,             s1809,             h1810,             y1811,             progress ] = await findCorrectionInOrder(                 parse,                 nodeId,                 d3717,                 g3683,                  f3713,                  w3714,  d3715,  z3716,                 s1809, h1810, y1811,                 start1,   start2,   start3,                  h1812,     y1813,     o1814,                 [...h1806],                 o1807,                  s1808,                 progress,                 total);         }           if (parse.p3641)             break;                   d /= 2;           parse.g3639++;           if (await r3862(parse.z2067))             break;     }       if (!parse.p3641)     {                   const a3718 = w1798(color, s1808, s1809, h1810, y1811)[2];          let c1 = s1809;         let c2 = h1810;         let c3 = y1811;          while (c1 >= 0 && r108(w1798(color, s1808, c1-1, h1810, y1811)[2], a3718)) c1--;         while (c2 >= 0 && r108(w1798(color, s1808, s1809, c2-1, y1811)[2], a3718)) c2--;         while (c3 >= 0 && r108(w1798(color, s1808, s1809, h1810, c3-1)[2], a3718)) c3--;          s1809 = Math.max(0, c1);         h1810 = Math.max(0, c2);         y1811 = Math.max(0, c3);     }           return [         s1808,         s1809,         h1810,         y1811 ]; }    async function findCorrectionInOrder(parse,                                      nodeId,                                      d3717,                                      order,                                       f3713,                                       w3714,  d3715,  z3716,                                      s1809, h1810, y1811,                                      start1,   start2,   start3,                                       h1812,     y1813,     o1814,                                      h1806,                                      o1807,                                      s1808,                                      progress,                                      total) {     const color = [...h1806];          let j3719 = w3714 ? 1 : 2;     let x3720 = d3715 ? 1 : 2;     let k3721 = z3716 ? 1 : 2;       cLoop:     for (let m1 = start1; m1 < h1812; m1 += (h1812-start1)/j3719)     {         if (parse.p3641)             break cLoop;          for (let m2 = start2; m2 < y1813; m2 += (y1813-start2)/x3720)         {             if (parse.p3641)                 break cLoop;              for (let m3 = start3; m3 < o1814; m3 += (o1814-start3)/k3721)             {                 if (parse.p3641)                     break cLoop;                  const [e3199, _oklab, j124] = w1798(color, order, m1, m2, m3);                  if (   x78(j124)                     && (  !o1807                         || h102(d3717, _oklab) < h102(d3717, o1807)))                 {                     h1806 = e3199;                     o1807 = _oklab;                                          if (!f3713)                         s1808 = order;                      s1809 = m1;                     h1810 = m2;                     y1811 = m3;                 }                  progress++;             }         }                   y2078(parse, nodeId, progress / total, false);     }           return [         h1806,         o1807,         s1808,         s1809,         h1810,         y1811,         progress ]; }    function w1798(color, order, m1, m2, m3) {     const e3199 = d1799(color, order, m1, m2, m3);     const oklab  = b4194(k4200(e3199));     const rgb    = x3985(oklab);      return [e3199, oklab, rgb]; }    function d1799(color, order, c1, c2, c3) {     if (order < 0)         return color;       const [i1, i2, i3] = s1802(order);                                 color = r1800(color, i1, c1);     if (!h150(color)) color = r1800(color, i2, c2);     if (!h150(color)) color = r1800(color, i3, c3);                 let rgb = g4195(color);      if (x78(rgb))         rgb = w80(rgb);                   color = i4196(         z146(rgb),         color[0]);           return color; }    function r1800(color, p3722, margin) {     const factor = e4192(color[0]);      margin /= factor[p3722];       const o3727 = [...color];     const c3064 = color[p3722+1];      const d = 0.001;       let g3725  = c3064,          g3726 = c3064;      let t3723  = h150(color);     let  m3724 = t3723;       let d3728 = 1/d*2;       while (   !t3723            && ! m3724            && d3728-- > 0)     {         g3725  -= d;  t3723  = o1801(g3725 , p3722, o3727);          g3726 += d;   m3724 = o1801( g3726, p3722, o3727);     }       d3728 = 1/d*2;     color = [...o3727];       if (t3723)      {          t3723 = h150(color);         g3725     = c3064;          while (   !t3723                && margin > 0                && d3728-- > 0)         {             g3725 -= d;              t3723 = o1801(g3725, p3722, o3727);             margin -= Math.sign(margin) * d;         }          color[p3722+1] = g3725;     }     else if (m3724)     {          m3724 = h150(color);         g3726     = c3064;          while (   !m3724                && margin > 0                && d3728-- > 0)         {             g3726 += d;              m3724 = o1801(g3726, p3722, o3727);             margin -= Math.sign(margin) * d;         }          color[p3722+1] = g3726;     }       return color; }    function o1801(c, p3722, o3727) {     let color = [...o3727];     color[p3722+1] = c;      return h150(color); }    function s1802(order) {     switch (order)     {         case 0: return [0, 1, 2];         case 1: return [1, 0, 2];         case 2: return [1, 2, 0];         case 3: return [0, 2, 1];         case 4: return [2, 0, 1];         case 5: return [2, 1, 0];     }           j953('invalid correction order ' + order);     return [0, 0, 0]; }    function o1803(space, order) {     const [c1, c2, c3] = s1802(order);      let min;      switch (space)     {         case 'hex':         case 'rgb':   min = [0, 0, 0]; break;          case 'hsv':          case 'hsl':   min = [0, 0, 0]; break;          case 'hclok':         case 'hclab':         case 'hcluv': min = [0, 0, 0]; break;          case 'oklab':         case 'lab':         case 'luv':   min = [0, -y4130[1]/2, -y4130[2]/2]; break;                  default:                          j953('invalid validation order ' + order);             return [0, 0, 0];     }      return [min[c1], min[c2], min[c3]]; }    function l1804(space, order) {     const [c1, c2, c3] = s1802(order);      let max;      switch (space)     {         case 'hex':         case 'rgb':   max = [...m4127]; break;          case 'hsv':          case 'hsl':   max = [w4128[0]/2, w4128[1], w4128[2]]; break;          case 'hclok':         case 'hclab':         case 'hcluv': max = [r4129[0]/2, r4129[1], r4129[2]]; break;          case 'oklab':         case 'lab':         case 'luv':   max = [...y4130]; break;                  default:                          j953('invalid validation order ' + order);             return [0, 0, 0];     }      return [max[c1], max[c2], max[c3]]; }    function reorderCorrection(s1808,                            s1809, h1810, y1811,                            w3714,  d3715,  z3716) {     let c1 = { closest: s1809, locked: w3714 };     let c2 = { closest: h1810, locked: d3715 };     let c3 = { closest: y1811, locked: z3716 };      if (   c1.closest <  Epsilon         && c2.closest <  Epsilon         && c3.closest >= Epsilon)     {         switch (s1808)         {             case 0: s1808 = 4; break;             case 1: s1808 = 5; break;             case 2: s1808 = 0; break;             case 3: s1808 = 1; break;             case 4: s1808 = 2; break;             case 5: s1808 = 3; break;         }          const tmp = c2;         c1 = c3;         c2 = c1;         c3 = tmp;     }     else if (c1.closest >= Epsilon           && c2.closest <  Epsilon)     {         switch (s1808)         {             case 0: s1808 = 3; break;             case 1: s1808 = 2; break;             case 2: s1808 = 1; break;             case 3: s1808 = 0; break;             case 4: s1808 = 5; break;             case 5: s1808 = 4; break;         }          const tmp = c2;         c2 = c3;         c3 = tmp;     }     else if (c1.closest < Epsilon)     {         switch (s1808)         {             case 0: s1808 = 2; break;             case 1: s1808 = 3; break;             case 2: s1808 = 4; break;             case 3: s1808 = 5; break;             case 4: s1808 = 0; break;             case 5: s1808 = 1; break;         }          const tmp = c1;         c1 = c2;         c2 = c3;         c3 = tmp;     }       return [         s1808,         c1.closest, c2.closest, c3.closest,         c1.locked,  c2.locked,  c3.locked ]; }    function u1805(p133) {     switch (p133)     {     case 'hex':     case 'rgb':         return [             new v1796('R', m4127[0]),             new v1796('G', m4127[1]),             new v1796('B', m4127[2]) ];      case 'hsv':         return [             new v1796('H', w4128[0]/2),             new v1796('S', w4128[1]),             new v1796('V', w4128[2]) ];      case 'hsl':         return [             new v1796('H', w4128[0]/2),             new v1796('S', w4128[1]),             new v1796('L', w4128[2]) ];      case 'hclok':     case 'hclab':     case 'hcluv':         return [             new v1796('H', r4129[0]/2),             new v1796('C', r4129[1]),             new v1796('L', r4129[2]) ];      case 'oklab':      case 'lab':         return [             new v1796('L', y4130[0]),             new v1796('a', y4130[1]),             new v1796('b', y4130[2]) ];      case 'luv':         return [             new v1796('L', y4130[0]),             new v1796('u', y4130[1]),             new v1796('v', y4130[2]) ];     }       j953('invalid color space ' + p133);     return [         new v1796(),         new v1796(),         new v1796() ]; }


class n1815 extends i2044 {     space   = null;         p3684      = null;    r3685      = null;    g3686      = null;          c1      = null;     c2      = null;     c3      = null;      convert = null;          z3265;        constructor(nodeId, options)     {         super(b1169, nodeId, options);     }                reset()     {         super.reset();                  this.space   = null;                  this.p3684     = null;         this.r3685     = null;         this.g3686     = null;                  this.c1      = null;         this.c2      = null;         this.c3      = null;              this.convert = null;     }        copy()     {         const copy = new n1815(this.nodeId, this.options);          copy.n3359(this);          copy.space = this.space.copy();          if (this.p3684) copy.p3684 = this.p3684.copy();         if (this.r3685) copy.r3685 = this.r3685.copy();         if (this.g3686) copy.g3686 = this.g3686.copy();          if (this. c1) copy. c1 = this. c1.copy();         if (this. c2) copy. c2 = this. c2.copy();         if (this. c3) copy. c3 = this. c3.copy();          if (this.convert)              copy.convert = this.convert.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalColorValue (this.input, parse);         let   space = await evalNumberValue(this.space, parse);          let   c1    = await evalNumberValue(this.p3684,   parse);         let   c2    = await evalNumberValue(this.r3685,   parse);         let   c3    = await evalNumberValue(this.g3686,   parse);          if (space) space = space.q3729();                   if (input)         {             if (input.isValid())             {                 if (this.options.enabled)                 {                     this.value = input.copy();                                           const fromSpaceIndex = input.space.value;                      const toSpaceIndex = Math.min(Math.max(                         0,                         Math.round(space.value)),                          k4126(parse)-1);                       if (toSpaceIndex != fromSpaceIndex)                     {                         this.convertColor(                             this.value,                             p133(fromSpaceIndex),                              p133(  toSpaceIndex));                          this.value.space.value = toSpaceIndex;                     }                                           if (!c1) c1 = this.value.c1;                     if (!c2) c2 = this.value.c2;                     if (!c3) c3 = this.value.c3;                       if (c1) { this.value.c1 = c1; this.c1 = c1; }                     if (c2) { this.value.c2 = c2; this.c2 = c2; }                     if (c3) { this.value.c3 = c3; this.c3 = c3; }                 }                 else                     this.value = input.copy();             }             else                 this.value = s2010.NaN.copy();                               if (!this.convert)                 this.convert = d2022.NaN.copy();         }         else if (space               && c1               && c2               && c3)         {             this.value = new s2010(space, c1, c2, c3);               const toSpaceIndex = Math.min(Math.max(                 0,                 Math.round(this.value.space.value)),                  k4126(parse)-1);              this.value.space.value = toSpaceIndex;               if (    this.convert                 &&  this.convert.isValid()                 &&  this.convert.value > -1                 &&  this.value.isValid()                 && !this.z3265)             {                 await this.convert.eval(parse);                  this.convertColor(                     this.value,                     p133(this.convert.value),                      p133(toSpaceIndex));             }         }         else             this.value = s2010.NaN.copy();           if (!this.value.space.isValid())             this.value = new s2010(                 this.space ? this.space.x3633() : d2022.NaN,                 d2022.NaN,                 d2022.NaN,                 d2022.NaN);           this.n4101(parse,         [             ['convert', this.convert    ],             ['space',   this.value.space],             ['c1',      this.value.c1   ],             ['c2',      this.value.c2   ],             ['c3',      this.value.c3   ]         ]);                                        this.validate();          return this;     }        convertColor(color, fromSpace, z3206)     {         let col = [             fromSpace,              n4176(color.c1.value, fromSpace, 0),             n4176(color.c2.value, fromSpace, 1),             n4176(color.c3.value, fromSpace, 2) ];          col = m4187(i4196(col, z3206));          color.c1.value = col[1];         color.c2.value = col[2];         color.c3.value = col[3];     }        x3633()     {         return this.options.enabled              ? this.value.copy()              : s2010.NaN.copy();     }        isValid()     {         return (!this.input || this.input.isValid())             && this.space && this.space.isValid()             && this.c1    && this.c1   .isValid()             && this.c2    && this.c2   .isValid()             && this.c3    && this.c3   .isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.space) this.space.r4088(parse);         if (this.p3684  ) this.p3684  .r4088(parse);         if (this.r3685  ) this.r3685  .r4088(parse);         if (this.g3686  ) this.g3686  .r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.space) this.space.o4089(parse, from, force);         if (this.p3684  ) this.p3684  .o4089(parse, from, force);         if (this.r3685  ) this.r3685  .o4089(parse, from, force);         if (this.g3686  ) this.g3686  .o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.space) this.space.t4087(parse);         if (this.p3684  ) this.p3684  .t4087(parse);         if (this.r3685  ) this.r3685  .t4087(parse);         if (this.g3686  ) this.g3686  .t4087(parse);     } }


class t1822 extends i2044 {     quality      = null;      corrections  = [];        constructor(nodeId, options)     {         super(k1170, nodeId, options);     }            reset()     {         super.reset();          this.quality     = null;         this.corrections = [];     }        copy()     {         const copy = new t1822(this.nodeId, this.options);          copy.n3359(this);          if (this.value  ) copy.value   = this.value  .copy();         if (this.quality) copy.quality = this.quality.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input   = await evalColorValue (this.input,   parse);         const quality = await evalNumberValue(this.quality, parse);           if (input)         {             if (this.options.enabled)             {                 if (g957(input.type))                 {                     this.value = new x2021();                      for (let i = 0; i < input.items.length; i++)                         this.value.items.push(await g2805(parse, this, input.items[i], quality));                 }                 else                     this.value = await g2805(parse, this, input, quality);             }             else                 this.value = input.copy();         }         else             this.value = s2010.NaN.copy();                    this.n4101(parse,         [             ['value',   this.value       ],             ['type',    this.outputType()],             ['quality', quality          ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.quality && this.quality.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.quality) this.quality.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.quality) this.quality.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.quality) this.quality.t4087(parse);     } }    async function g2805(parse, node, input, quality) {     let rgb = input.e3242();      if (quality.value == 0)      {         rgb[0] = Math.round(Math.min(Math.max(0, rgb[0]), 1) * 0xff);            rgb[1] = Math.round(Math.min(Math.max(0, rgb[1]), 1) * 0xff);            rgb[2] = Math.round(Math.min(Math.max(0, rgb[2]), 1) * 0xff);                   return s2010.k3773(rgb);     }     else if (quality.value == 1)      {         rgb = m129(rgb);          rgb[0] = Math.round(rgb[0] * 0xff);         rgb[1] = Math.round(rgb[1] * 0xff);         rgb[2] = Math.round(rgb[2] * 0xff);          return s2010.k3773(rgb);     }     else      {         if (!x78(rgb))             x2077(node.nodeId);                   const inputColor = input.o3241();           const       [ s1808,         s1809,         h1810,         y1811 ] = await w1797(             parse,             node.nodeId,             inputColor,             quality, null,  null,  null,             false,   false, false, false);                       if (!parse.p3641)         {             if (   s1808 >= 0                 && s1808 <  6)             {                 node.e3199 = d1799(                     inputColor,                     s1808,                     s1809,                     h1810,                     y1811);                  return s2010.n2806(node.e3199);             }             else             {                 return s2010.NaN.copy();             }         }     }           return s2010.NaN.copy(); }


class t1821 extends i2044 {     g3683  = null;     p3684     = null;     r3685     = null;     g3686     = null;          order   = null;     c1      = null;     c2      = null;     c3      = null;      corrections = [];        constructor(nodeId, options)     {         super(g1171, nodeId, options);     }            reset()     {         super.reset();          this.g3683  = null;         this.p3684     = null;         this.r3685     = null;         this.g3686     = null;                  this.order   = null;         this.c1      = null;         this.c2      = null;         this.c3      = null;              this.corrections = [];     }        copy()     {         const copy = new t1821(this.nodeId, this.options);          copy.n3359(this);                  if (this.g3683) copy.g3683 = this.order .copy();         if (this.p3684   ) copy.p3684    = this.p3684   .copy();         if (this.r3685   ) copy.r3685    = this.r3685   .copy();         if (this.g3686   ) copy.g3686    = this.g3686   .copy();                  if (this. order) copy. order = this.order .copy();         if (this. c1   ) copy. c1    = this. c1   .copy();         if (this. c2   ) copy. c2    = this. c2   .copy();         if (this. c3   ) copy. c3    = this. c3   .copy();                  if (this.value ) copy. value = this. value.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalColorValue (this. input, parse);         let   order = await evalNumberValue(this.g3683, parse);         const c1    = await evalNumberValue(this.p3684,    parse);         const c2    = await evalNumberValue(this.r3685,    parse);         const c3    = await evalNumberValue(this.g3686,    parse);          if (order)          {             order       = order.q3729();             order.value = Math.min(Math.max(0, order.value), 5);         }           if (input)         {             if (this.options.enabled)             {                 const rgb = input.e3242();                                  if (!x78(rgb))                     x2077(this.nodeId);                   const inputColor = input.o3241();                   const               [ s1808,                 s1809,                 h1810,                 y1811 ] = await w1797(                     parse,                     this.nodeId,                     inputColor,                      order, c1, c2, c3,                      this.order != null,                     this.c1    != null,                      this.c2    != null,                      this.c3    != null);                                        if (    !parse.p3641)                 {                     if (   s1808 >= 0                          && s1808 <  6)                     {                         this.e3199 = d1799(                             inputColor,                             s1808,                             s1809,                             h1810,                             y1811);                                                       this.order = new d2022(s1808);                         this.c1    = new d2022(s1809);                         this.c2    = new d2022(h1810);                         this.c3    = new d2022(y1811);                                                   this.value = s2010.n2806(this.e3199);                          this.value.c1.decimals = input.c1.decimals;                         this.value.c2.decimals = input.c2.decimals;                         this.value.c3.decimals = input.c3.decimals;                           this.n4101(parse,                         [                             ['order', new d2022(s1808, 0)],                             ['c1',    new d2022(s1809,     1)],                             ['c2',    new d2022(h1810,     1)],                             ['c3',    new d2022(y1811,     1)],                             ['value', this.value                      ]                         ]);                     }                     else                     {                         this.order = d2022.NaN.copy();                         this.c1    = d2022.NaN.copy();                         this.c2    = d2022.NaN.copy();                         this.c3    = d2022.NaN.copy();                         this.value = input.copy();                                  this.n4101(parse,                         [                             ['order', this.order],                             ['c1',    this.c1   ],                             ['c2',    this.c2   ],                             ['c3',    this.c3   ],                             ['value', this.value]                         ]);                     }                 }                 else                 {                     this.order = d2022.NaN.copy();                     this.c1    = d2022.NaN.copy();                     this.c2    = d2022.NaN.copy();                     this.c3    = d2022.NaN.copy();                     this.value = input.copy();                          this.n4101(parse,                     [                         ['order', this.order],                         ['c1',    this.c1   ],                         ['c2',    this.c2   ],                         ['c3',    this.c3   ],                         ['value', this.value]                     ]);                 }             }             else             {                 this.order = d2022.NaN.copy();                 this.c1    = d2022.NaN.copy();                 this.c2    = d2022.NaN.copy();                 this.c3    = d2022.NaN.copy();                 this.value = input.copy();                  this.n4101(parse,                 [                     ['order', this.order],                     ['c1',    this.c1   ],                     ['c2',    this.c2   ],                     ['c3',    this.c3   ],                     ['value', this.value]                 ]);             }         }         else         {             this.order = d2022.NaN.copy();             this.c1    = d2022.NaN.copy();             this.c2    = d2022.NaN.copy();             this.c3    = d2022.NaN.copy();             this.value = s2010 .NaN.copy();              this.n4101(parse,             [                 ['order', d2022.NaN],                 ['c1',    d2022.NaN],                 ['c2',    d2022.NaN],                 ['c3',    d2022.NaN],                 ['value', s2010 .NaN]             ]);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.order && this.order.isValid()             && this.c1    && this.c1   .isValid()             && this.c2    && this.c2   .isValid()             && this.c3    && this.c3   .isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.g3683) this.g3683.r4088(parse);         if (this.p3684   ) this.p3684   .r4088(parse);         if (this.r3685   ) this.r3685   .r4088(parse);         if (this.g3686   ) this.g3686   .r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.g3683) this.g3683.o4089(parse, from, force);         if (this.p3684   ) this.p3684   .o4089(parse, from, force);         if (this.r3685   ) this.r3685   .o4089(parse, from, force);         if (this.g3686   ) this.g3686   .o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.g3683) this.g3683.t4087(parse);         if (this.p3684   ) this.p3684   .t4087(parse);         if (this.r3685   ) this.r3685   .t4087(parse);         if (this.g3686   ) this.g3686   .t4087(parse);     } } 


class i1818 extends u2045 {     standard = null;     contrast = null;       constructor(nodeId, options)     {         super(x1173, nodeId, options);     }        reset()     {         super.reset();          this.standard = null;         this.contrast = null;     }        copy()     {         const copy = new i1818(this.nodeId, this.options);          copy.n3359(this);          if (this.standard) copy.standard = this.standard.copy();         if (this.contrast) copy.contrast = this.contrast.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const e4083   = await evalColorValue (this.e4083,   parse);         const j4084   = await evalColorValue (this.j4084,   parse);         const standard = await evalNumberValue(this.standard, parse);                   if (standard.isValid())             standard.value = Math.min(Math.max(0, standard.value), 1);           if (   e4083              && j4084)         {             if (   e4083.isValid()                 && j4084.isValid())             {                 if (   y149(e4083.o3241())                     && y149(j4084.o3241()))                 {                     if (standard.value == 0)                     {                         const value = c157(e4083.e3242(), j4084.e3242());                         this.contrast = new d2022(value, 2);                     }                     else                     {                         const value = q161(e4083.e3242(), j4084.e3242());                         this.contrast = new d2022(value, 1);                     }                 }                 else                     this.contrast = d2022.NaN.copy();             }             else                 this.contrast = d2022.NaN.copy();               this.value =                  e4083                  ? e4083                 : s2010.NaN.copy();               this.n4101(parse,             [                 ['text', e4083],                 ['back', j4084]             ]);         }          else if (e4083)          {             this.n4101(parse,             [                 ['text', e4083.isValid() ? e4083 : s2010.NaN],                 ['back', s2010.NaN                            ]             ]);                          this.value    = e4083;             this.contrast = d2022.NaN.copy();         }          else if (j4084)          {             this.n4101(parse,             [                 ['text', s2010.NaN                            ],                 ['back', j4084.isValid() ? j4084 : s2010.NaN]             ]);              this.value    = s2010 .NaN.copy();             this.contrast = d2022.NaN.copy();         }          else         {             this.value    = s2010 .NaN.copy();             this.contrast = d2022.NaN.copy();              this.n4101(parse,             [                 ['text', s2010.NaN],                 ['back', s2010.NaN]             ]);         }                    this.n4101(parse,         [             ['standard', standard     ],             ['contrast', this.contrast]         ],         true);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.standard && this.standard.isValid()             && (!this.contrast || this.contrast.isValid());     }        r4088(parse)     {         super.r4088(parse);          if (this.standard) this.standard.r4088(parse);         if (this.contrast) this.contrast.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.standard) this.standard.o4089(parse, from, force);         if (this.contrast) this.contrast.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.standard) this.standard.t4087(parse);         if (this.contrast) this.contrast.t4087(parse);     } } 


class v1820 extends i2044 {     from = null;        constructor(nodeId, options)     {         super(g1172, nodeId, options);     }            reset()     {         super.reset();          this.from = null;     }        copy()     {         const copy = new v1820(this.nodeId, this.options);          copy.n3359(this);          if (this.value) copy.value = this.value.copy();         if (this.from ) copy.from  = this.from .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalColorValue (this.input, parse);         let   from  = await evalNumberValue(this.from,  parse);          if (from) from = from.q3729();                   if (input)         {             if (this.options.enabled)             {                 if (g957(input.type))                 {                     this.value = new x2021();                      for (let i = 0; i < input.items.length; i++)                         this.value.items.push(await getConvertP3Value(input.items[i], from));                 }                 else                     this.value = await getConvertP3Value(input, from);             }             else                 this.value = input.copy();         }         else             this.value = s2010.NaN.copy();                    this.n4101(parse,         [             ['value',   this.value       ],             ['type',    this.outputType()],             ['quality', from             ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.from && this.from.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.from) this.from.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.from) this.from.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.from) this.from.t4087(parse);     } }    function getConvertP3Value(input, from) {     return s2010.k3773(         from.value == 0         ? t4142(s61(input.e3242()))         : t4142(s62(input.e3242()))); }


class j1817 extends i2044 {     l;     m;     s;       constructor(nodeId, options)     {         super(b1174, nodeId, options);     }            reset()     {         super.reset();          this.l = null;         this.m = null;         this.s = null;     }        copy()     {         const copy = new j1817(this.nodeId, this.options);          copy.n3359(this);          if (this.l) copy.l = this.l.copy();         if (this.m) copy.m = this.m.copy();         if (this.s) copy.s = this.s.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalColorValue (this.input, parse);         const l     = await evalNumberValue(this.l,     parse);          const m     = await evalNumberValue(this.m,     parse);         const s     = await evalNumberValue(this.s,     parse);           if (input)         {             if (this.options.enabled)             {                 if (g957(input.type))                 {                     this.value = new x2021();                      for (let i = 0; i < input.items.length; i++)                         this.value.items.push(getColorBlindValue(input.items[i], l, m, s));                 }                 else                     this.value = getColorBlindValue(input, l, m, s);             }             else                 this.value = input.copy();         }         else             this.value = s2010.NaN.copy();           this.n4101(parse,         [             ['value',  this.value       ],             ['type',   this.outputType()],             ['l',      l                ],             ['m',      m                ],             ['s',      s                ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.l && this.l.isValid()             && this.m && this.m.isValid()             && this.s && this.s.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.l) this.l.r4088(parse);         if (this.m) this.m.r4088(parse);         if (this.s) this.s.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.l) this.l.o4089(parse, from, force);         if (this.m) this.m.o4089(parse, from, force);         if (this.s) this.s.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.l) this.l.t4087(parse);         if (this.m) this.m.t4087(parse);         if (this.s) this.s.t4087(parse);     } }    function getColorBlindValue(input, l, m, s) {     const rgb   = input.e3242();      const rgbCb = x134(         rgb,         l.value / 2,         m.value / 2,         s.value / 2);      if (   !h73(rgb  )         && !h73(rgbCb))     {         const validRgbCb = rgbCb;              const validCol = i4196(             z146(validRgbCb),              p133(input.space.value));          return s2010.n2806(validCol);     }     else         return s2010.NaN.copy(); }


class t1819 extends u2045 {     space;     amount;     gamma;       constructor(nodeId, options)     {         super(s1175, nodeId, options);     }            reset()     {         super.reset();          this.space  = null;         this.amount = null;         this.gamma  = null;     }        copy()     {         const copy = new t1819(this.nodeId, this.options);          copy.n3359(this);          if (this.space ) copy.space  = this.space .copy();         if (this.amount) copy.amount = this.amount.copy();         if (this.gamma ) copy.gamma  = this.gamma .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const e4083 = await evalColorValue (this.e4083, parse);         const j4084 = await evalColorValue (this.j4084, parse);         let   space  = await evalNumberValue(this.space,  parse);         const amount = await evalNumberValue(this.amount, parse);         const gamma  = await evalNumberValue(this.gamma,  parse);          if (space) space = space.q3729();                   if (   e4083              && j4084)         {             l952(                 amount.type == t1091,                  'this.result.type must be NUMBER_VALUE');              const f = amount.value / 100;               const spaceIndex = Math.min(Math.max(0, space.value), k4126()-1);             const gammaValue = Math.max(0.0001, gamma.value);              const _space = p133(spaceIndex);              const e3199 = this.interpolate(                 spaceIndex,                 i4196(e4083.o3241(), _space),                 i4196(j4084.o3241(), _space),                 f,                 gammaValue);                                          this.value = s2010.n2806(e3199, spaceIndex);         }          else if (e4083)              this.value = e4083;          else if (j4084)              this.value = j4084;                      else              this.value = s2010.NaN.copy();           this.n4101(parse,         [             ['space',  space     ],             ['amount', amount    ],             ['gamma',  gamma     ],             ['value',  this.value]         ]);                   this.validate();                  return this;     }        interpolate(space, col0, m103, f, gamma)     {         if (   space <= 1             || space >  6)          {             gamma = Math.max(0.01, gamma);              const r0 = Math.sign(col0[1]) * Math.pow(Math.abs(col0[1]), gamma);               const g0 = Math.sign(col0[2]) * Math.pow(Math.abs(col0[2]), gamma);               const b0 = Math.sign(col0[3]) * Math.pow(Math.abs(col0[3]), gamma);                const r1 = Math.sign(m103[1]) * Math.pow(Math.abs(m103[1]), gamma);             const g1 = Math.sign(m103[2]) * Math.pow(Math.abs(m103[2]), gamma);             const b1 = Math.sign(m103[3]) * Math.pow(Math.abs(m103[3]), gamma);              const r = b1035(r0, r1, f);                     const g = b1035(g0, g1, f);                         const b = b1035(b0, b1, f);                      return [                 p133(space),                 Math.sign(r) * Math.pow(Math.abs(r), 1/gamma),                 Math.sign(g) * Math.pow(Math.abs(g), 1/gamma),                 Math.sign(b) * Math.pow(Math.abs(b), 1/gamma) ];         }         else          {             const h0 = col0[1] * Tau;  const h1 = m103[1] * Tau;             const c0 = col0[2];        const c1 = m103[2];             const l0 = col0[3];        const l1 = m103[3];              return [                 p133(space),                 v1038(h0 + q887(h0, h1) * f) / Tau,                 b1035(c0, c1, f),                 b1035(l0, l1, f) ];         }     }        isValid()     {         return super.isValid()             && this.space  && this.space .isValid()             && this.amount && this.amount.isValid()             && this.gamma  && this.gamma .isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.space ) this.space .r4088(parse);         if (this.amount) this.amount.r4088(parse);         if (this.gamma ) this.gamma .r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.space ) this.space .o4089(parse, from, force);         if (this.amount) this.amount.o4089(parse, from, force);         if (this.gamma ) this.gamma .o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.space ) this.space .t4087(parse);         if (this.amount) this.amount.t4087(parse);         if (this.gamma ) this.gamma .t4087(parse);     } } 


class k1816 extends u2045 {     mode    = null;     opacity = null;           constructor(nodeId, options)     {         super(l1176, nodeId, options);     }            reset()     {         super.reset();          this.mode    = null;         this.opacity = null;     }        copy()     {         const copy = new k1816(this.nodeId, this.options);          copy.n3359(this);          if (this.mode   ) copy.mode    = this.mode   .copy();         if (this.opacity) copy.opacity = this.opacity.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const e4083  = await evalColorValue (this.e4083,  parse);         const j4084  = await evalColorValue (this.j4084,  parse);         let   mode    = await evalNumberValue(this.mode,    parse);         const opacity = await evalNumberValue(this.opacity, parse);                  if (mode) mode = mode.q3729();           if (   e4083              && j4084)         {             l952(                 opacity.type == t1091,                  'this.result.type must be NUMBER_VALUE');              const b3772 = opacity.value / 100;              const g3771 = Math.min(Math.max(0, mode.value), w1393.length-1);               const col = this.blend(                 g3771,                 e4083.e3242(),                 j4084.e3242(),                 b3772);              this.value = s2010.k3773(t4142(col));         }          else if (e4083)              this.value = e4083;          else if (this.j4084)              this.value = j4084;                      else              this.value = s2010.NaN.copy();           this.n4101(parse,         [             ['value',   this.value],             ['mode',    mode      ],             ['opacity', opacity   ]         ]);           this.validate();                  return this;     }        blend(mode, col0, m103, opacity)     {         switch (mode)         {             case  0: return r4248    (col0, m103, opacity);              case  1: return j4249    (col0, m103, opacity);             case  2: return h4250  (col0, m103, opacity);             case  3: return b4251 (col0, m103, opacity);              case  4: return e4252   (col0, m103, opacity);             case  5: return y4253    (col0, m103, opacity);             case  6: return s4255(col0, m103, opacity);              case  7: return m4257   (col0, m103, opacity);             case  8: return g4258 (col0, m103, opacity);             case  9: return i4260 (col0, m103, opacity);              case 10: return y4262(col0, m103, opacity);             case 11: return k4263 (col0, m103, opacity);              case 12: return y4265       (col0, m103, opacity);             case 13: return d4266(col0, m103, opacity);             case 14: return i4267     (col0, m103, opacity);             case 15: return e4268(col0, m103, opacity);         }     }        isValid()     {         return super.isValid()             && this.mode    && this.mode   .isValid()             && this.opacity && this.opacity.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.mode   ) this.mode   .r4088(parse);         if (this.opacity) this.opacity.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.mode   ) this.mode   .o4089(parse, from, force);         if (this.opacity) this.opacity.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.mode   ) this.mode   .t4087(parse);         if (this.opacity) this.opacity.t4087(parse);     } } 


function r4248(col, back, opacity) {     return [ col[0] * opacity + back[0] * (1 - opacity),              col[1] * opacity + back[1] * (1 - opacity),              col[2] * opacity + back[2] * (1 - opacity) ]; }    function j4249(col, back, opacity) {     return r4248(         [ Math.min(back[0], col[0]),           Math.min(back[1], col[1]),           Math.min(back[2], col[2]) ],         back,         opacity); }    function chanMultiply(c, b) {     return c * b; }    function h4250(col, back, opacity) {     return r4248(         [ chanMultiply(col[0], back[0]),           chanMultiply(col[1], back[1]),           chanMultiply(col[2], back[2]) ],         back,         opacity); }    function chanColorBurn(c, b) {          if (b == 1) return 1;     else if (c == 0) return 0;     else             return 1 - Math.min((1 - b) / c, 1); }    function b4251(col, back, opacity) {     return r4248(          [ chanColorBurn(col[0], back[0]),            chanColorBurn(col[1], back[1]),            chanColorBurn(col[2], back[2]) ],         back,         opacity); }    function e4252(col, back, opacity) {     return r4248(         [ Math.max(back[0], col[0]),           Math.max(back[1], col[1]),           Math.max(back[2], col[2]) ],         back,         opacity); }    function h4254(c, b) {     return b + c - b*c; }    function y4253(col, back, opacity) {     return r4248(         [ h4254(col[0], back[0]),           h4254(col[1], back[1]),           h4254(col[2], back[2]) ],         back,         opacity); }    function i4256(c, b) {          if (b == 0) return 0;     else if (c == 1) return 1;     else             return Math.min(b / (1 - c), 1); }    function s4255(col, back, opacity) {     return r4248(         [ i4256(col[0], back[0]),           i4256(col[1], back[1]),           i4256(col[2], back[2]) ],         back,         opacity); }    function m4257(col, back, opacity) {     return r4248(         [ i4261(back[0], col[0]),           i4261(back[1], col[1]),           i4261(back[2], col[2]) ],         back,         opacity); }    function j2807(b) {     return b <= 0.25          ? ((16 * b - 12) * b + 4) * b          : Math.sqrt(b); }    function u4259(c, b) {     return c <= 0.5          ? b - (1 - 2*c) * b * (1 - b)          : b + (2*c - 1) * (j2807(b) - b); }    function g4258(col, back, opacity) {     return r4248(         [ u4259(col[0], back[0]),           u4259(col[1], back[1]),           u4259(col[2], back[2]) ],         back,         opacity); }    function i4261(c, b) {     if (c <= 0.5) return chanMultiply(b, 2 * c);     else          return h4254(b, 2 * c - 1); }    function i4260(col, back, opacity) {     return r4248(         [ i4261(col[0], back[0]),           i4261(col[1], back[1]),           i4261(col[2], back[2]) ],         back,         opacity); }    function y4262(col, back, opacity) {     return [ Math.abs(back[0] - col[0]),              Math.abs(back[1] - col[1]),              Math.abs(back[2] - col[2]) ]; }    function s4264(c, b) {     return b + c - 2*b*c; }    function k4263(col, back, opacity) {     return r4248(         [ s4264(col[0], back[0]),           s4264(col[1], back[1]),           s4264(col[2], back[2]) ],         back,         opacity); }    function w2808(col) {     return col[0] * 0.30          + col[1] * 0.59          + col[2] * 0.11; }    function x2809(k127, l) {     const col = [...k127];      const d = l - w2808(col);      col[0] += d;     col[1] += d;     col[2] += d;      return i2817(col); }    function p2810(col) {     return Math.max(col[0], col[1], col[2])           - Math.min(col[0], col[1], col[2]); }    function z2811(col) {          if (col[0] <= col[1]            && col[0] <= col[2]) return 0;     else if (col[1] <= col[1]            && col[1] <= col[2]) return 1;     else                       return 2; }    function m2812(col) {          if (   col[0] >= col[1]               && col[0] <= col[2]           ||    col[0] <= col[1]               && col[0] >= col[2]) return 0;     else if (   col[1] >= col[0]               && col[1] <= col[2]           ||    col[1] <= col[0]               && col[1] >= col[2]) return 1;     else                          return 2; }    function f2813(col) {          if (col[0] >= col[1]            && col[0] >= col[2]) return 0;     else if (col[1] >= col[1]            && col[1] >= col[2]) return 1;     else                       return 2; }    function p2814(col)  {     if (   col[0] == col[1]          && col[0] == col[2])         return [0, 1, 2];      else          return [             z2811(col),              m2812(col),              f2813(col)]; }    function p2815(k127, s) {     const col       = [...k127];     const [n, d, x] = p2814(col);      if (col[x] > col[n])     {         col[d] = (((col[d] - col[n]) * s) / (col[x] - col[n]));         col[x] = s;     }     else         col[d] = col[x] = 0;      col[n] = 0;      return col; }    function t2816(c, l, n, x) {          if (n < 0) return l + (((c - l) * l) / (l - n));     else if (x > 1) return l + (((c - l) * (1 - l)) / (x - l));     else            return c; }    function i2817(col) {     const l   = w2808(col);      const n = Math.min(col[0], col[1], col[2]);     const x = Math.max(col[0], col[1], col[2]);      return [ t2816(col[0], l, n, x),              t2816(col[1], l, n, x),              t2816(col[2], l, n, x) ]; }    function y4265(col, back, opacity) {     return r4248(         x2809(p2815(col, p2810(back)), w2808(back)),         back,         opacity); }    function d4266(col, back, opacity) {     return r4248(         x2809(p2815(back, p2810(col)), w2808(back)),         back,         opacity); }    function i4267(col, back, opacity) {     return r4248(         x2809(col, w2808(back)),         back,         opacity); }    function e4268(col, back, opacity) {     return r4248(         x2809(back, w2808(col)),         back,         opacity); }


class e1887 extends g2043 {     id;      colorStyle;     a2818;           linked;        constructor(nodeId, options, styleId)     {         super(e1216, nodeId, options);          this.id == styleId;     }        copy()     {         const copy = new e1887(this.nodeId, this.options);          copy.id = this.id;          if (this.colorStyle) copy.colorStyle = this.colorStyle.copy();         if (this.a2818  ) copy.a2818   = this.a2818  .copy();                         copy.linked   = this.linked;          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                   this.value = await evalColorValue(this.a2818, parse);           if (   this.value.isValid()             && this.linked)                                   {             if (this.value.type == x1168)                 this.value = v2013.k3773(t4142(this.value.e3242()), 0xff);              const rgba       = this.value.h99();             const d3261 = p100(x120(rgba), rgba[3]);              this.evalStyle({rgba: d3261});         }         else             this.value = v2013.NaN.copy();           this.n4101(parse,         [             ['value', this.value]         ]);           this.validate();          return this;     }        evalStyle(options = {})     {         if (!this.options.enabled)             return;                       const colorStyle = new b1839(this.nodeId, this.id, this.name);                     colorStyle.paints =          [             [ 'SOLID',                        Math.round(options.rgba[0] * 0xff)               + ' ' + Math.round(options.rgba[1] * 0xff)               + ' ' + Math.round(options.rgba[2] * 0xff)               + ' ' + Math.round(options.rgba[3] * 100 ) ]         ];           this.colorStyle = colorStyle;     }        isValid()     {         return this.a2818 && this.a2818.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.a2818) this.a2818.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.a2818) this.a2818.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.a2818) this.a2818.t4087(parse);     } }


class c1889 extends i2044 {     color   = null;     opacity = null;     blend   = null;        constructor(nodeId, options)     {         super(r1179, nodeId, options);     }        reset()     {         super.reset();          this.color   = null;         this.opacity = null;         this.blend   = null;     }        copy()     {         const copy = new c1889(this.nodeId, this.options);          copy.n3359(this);          if (this.color  ) copy.color   = this.color  .copy();         if (this.opacity) copy.opacity = this.opacity.copy();         if (this.blend  ) copy.blend   = this.blend  .copy();          return copy;     }        f4242(p2992)     {         switch (p2992)         {             case 'color':   return this.input ? this.value.color   : this.color;             case 'opacity': return this.input ? this.value.opacity : this.opacity;             case 'blend':   return this.input ? this.value.blend   : this.blend;         }          return null;     }        async eval(parse)     {         if (this.isCached())             return this;           const input   = await evalFillValue  (this.input,   parse);         let   color   = await evalColorValue (this.color,   parse);         let   opacity = await evalNumberValue(this.opacity, parse);         let   blend   = await evalNumberValue(this.blend,   parse);           if (input)         {             this.value = new v2013(                 color   ?? input.color,                 opacity ?? input.opacity,                 blend   ?? input.blend);         }         else if ((!color   || color  .type == x1168 )               && (!opacity || opacity.type == t1091)               && (!blend   || blend  .type == t1091))         {             this.value = new v2013(                 color,                  opacity,                 blend);         }         else             this.value = v2013.NaN.copy();           this.n4101(parse,         [             ['value',   this.value],             ['color',   color     ],             ['opacity', opacity   ],             ['blend',   blend     ]         ]);                                                this.validate();          return this;     }        x3633()     {         return this.options.enabled             ? new v2013(                 this.color   ? this.color  .x3633() : this.input.value.color  .x3633(),                 this.opacity ? this.opacity.x3633() : this.input.value.opacity.x3633(),                 this.blend   ? this.blend  .x3633() : this.input.value.blend  .x3633())             : v2013.NaN.copy();     }        isValid()     {         return (!this.input || this.input.isValid())             && this.color   && this.color  .isValid()             && this.opacity && this.opacity.isValid()             && this.blend   && this.blend  .isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.color  ) this.color  .r4088(parse);         if (this.opacity) this.opacity.r4088(parse);         if (this.blend  ) this.blend  .r4088(parse);     }                    o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.color  ) this.color  .o4089(parse, from, force);         if (this.opacity) this.opacity.o4089(parse, from, force);         if (this.blend  ) this.blend  .o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.color  ) this.color  .t4087(parse);         if (this.opacity) this.opacity.t4087(parse);         if (this.blend  ) this.blend  .t4087(parse);     } }


class w1886 extends i2044 {     fill     = null;     position = null;        constructor(nodeId, options)     {         super(n1185, nodeId, options);     }        reset()     {         super.reset();          this.fill     = null;         this.position = null;     }        copy()     {         const copy = new w1886(this.nodeId, this.options);          copy.n3359(this);          if (this.fill    ) copy.fill     = this.fill    .copy();         if (this.position) copy.position = this.position.copy();          return copy;     }        f4242(p2992)     {         switch (p2992)         {             case 'fill':      return this.input ? this.value.fill     : this.fill;             case 'position':  return this.input ? this.value.position : this.position;         }          return null;     }        async eval(parse)     {         if (this.isCached())             return this;                                     const input    = await evalColorStopValue(this.input,    parse);         let   fill     = await evalFillValue     (this.fill,     parse);         const position = await evalNumberValue   (this.position, parse);                  fill = this.validateFill(fill);           if (input)         {             this.value = new w2009(                    fill                  && fill.type != k1178                      ? fill                      : input.fill,                 position ?? input.position);         }         else         {             this.value = new w2009(                 fill,                  position);         }           this.n4101(parse,          [             ['value', this.value]         ]);                   if (!this.fill    ) this.fill     = this.value.fill    .copy();         if (!this.position) this.position = this.value.position.copy();           this.validate();          return this;     }        validateFill(fill)     {         if (!fill)             return null;           if (fill.type == x1168)             return v2013.k3773(t4142(fill.e3242()), 100);         else             return fill;     }        x3633()     {         return new w2009(             this.options.enabled             ? this.validateFill(this.fill ? this.fill.x3633() : this.input.fill.x3633())             : v2013.NaN,             this.position ? this.position.x3633() : this.input.position.x3633());     }                         isValid()     {         return (!this.input || this.input.isValid())             && this.fill     && this.fill    .isValid()             && this.position && this.position.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.fill    ) this.fill    .r4088(parse);         if (this.position) this.position.r4088(parse);     }                    o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.fill    ) this.fill    .o4089(parse, from, force);         if (this.position) this.position.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.fill    ) this.fill    .t4087(parse);         if (this.position) this.position.t4087(parse);     } }


class o1890 extends g2043 {     inputs = [];      x3687 = null;     position = null;     x        = null;     y        = null;     size     = null;     angle    = null;     aspect   = null;     skew     = null;     blend    = null;          diagAspect;                constructor(nodeId, options)     {         super(x1188, nodeId, options);     }                    reset()     {         super.reset();                  this.inputs = [];              this.x3687 = null;         this.position = null;         this.x        = null;         this.y        = null;         this.size     = null;         this.angle    = null;         this.aspect   = null;         this.skew     = null;         this.blend    = null;     }        copy()     {         const copy = new o1890(this.nodeId, this.options);          copy.n3359(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.x3687) copy.x3687 = this.x       .copy();         if (this.position) copy.position = this.position.copy();         if (this.x       ) copy.x        = this.x       .copy();         if (this.y       ) copy.y        = this.y       .copy();         if (this.size    ) copy.size     = this.size    .copy();         if (this.angle   ) copy.angle    = this.angle   .copy();         if (this.aspect  ) copy.aspect   = this.aspect  .copy();         if (this.skew    ) copy.skew     = this.skew    .copy();         if (this.blend   ) copy.blend    = this.blend   .copy();          return copy;     }        f4242(p2992)     {         switch (p2992)         {             case 'gradType':  return this.input ? this.value.x3687 : this.x3687;             case 'position':  return this.input ? this.value.position : this.position;             case 'x':         return this.input ? this.value.x        : this.x;             case 'y':         return this.input ? this.value.y        : this.y;             case 'size':      return this.input ? this.value.size     : this.size;             case 'angle':     return this.input ? this.value.angle    : this.angle;             case 'aspect':    return this.input ? this.value.aspect   : this.aspect;             case 'skew':      return this.input ? this.value.skew     : this.skew;             case 'blend':     return this.input ? this.value.blend    : this.blend;         }          return null;     }        async eval(parse)     {         if (this.isCached())             return this;                       let x3687 = await evalNumberValue(this.x3687, parse);         let position = await evalNumberValue(this.position, parse);         let x        = await evalNumberValue(this.x,        parse);         let y        = await evalNumberValue(this.y,        parse);         let size     = await evalNumberValue(this.size,     parse);         let angle    = await evalNumberValue(this.angle,    parse);         let aspect   = await evalNumberValue(this.aspect,   parse);         let skew     = await evalNumberValue(this.skew,     parse);         let blend    = await evalNumberValue(this.blend,    parse);           if (position) position.value = Math.min(Math.max(0, Math.floor(position.value)), 4);         if (blend   ) blend   .value = Math.min(Math.max(0, Math.floor(blend   .value)), w1393.length-1);           let stops = new x2021();           const inputs = [];                  for (const input of this.inputs)             inputs.push(await evalValue(input, parse));           if (   inputs.length == 1             && inputs[0].type == i1187)         {             this.value        = inputs[0].x3633();             this.value.nodeId = this.nodeId;             this.value.r3626(inputs[0]);              if (x3687)  this.value.x3687 = x3687;  else  x3687 = this.value.x3687;                   if (position)  this.value.position = position;  else  position = this.value.position;                   if (x       )  this.value.x        = x;         else  x        = this.value.x;                   if (y       )  this.value.y        = y;         else  y        = this.value.y;                   if (size    )  this.value.size     = size;      else  size     = this.value.size;                   if (angle   )  this.value.angle    = angle;     else  angle    = this.value.angle;                   if (aspect  )  this.value.aspect   = aspect;    else  aspect   = this.value.aspect;                   if (skew    )  this.value.skew     = skew;      else  skew     = this.value.skew;                   if (blend   )  this.value.blend    = blend;     else  blend    = this.value.blend;               }         else         {             for (let i = 0, o = 0; i < inputs.length; i++)             {                 const input = inputs[i];                  if (   input                     && this.options.enabled)                 {                     if (g957(input.type))                     {                         for (const item of input.items)                             if (item.isValid())                                 stops.items.push(item);                     }                     else if (input.type == i1187)                     {                         for (const item of input.stops.items)                             stops.items.push(item);                     }                     else                         if (input.isValid())                             stops.items.push(input);                 }             }               stops.items = a1827(stops.items);              w1829(stops.items);               this.value = new a2015(                 stops,                 x3687,                 position,                 x,                  y,                  size,                  angle,                  aspect,                 this.diagAspect,                 skew,                 blend);         }                   this.n4101(parse,         [             ['value',    this.value],             ['gradType', x3687  ],             ['position', position  ],             ['x',        x         ],             ['y',        y         ],             ['size',     size      ],             ['angle',    angle     ],             ['aspect',   aspect    ],             ['skew',     skew      ],             ['blend',    blend     ]         ]);                   if (   inputs.length == 1             && inputs[0].type == i1187)         {             if (!this.x3687) this.x3687 = this.value.x3687.copy();             if (!this.position) this.position = this.value.position.copy();             if (!this.x       ) this.x        = this.value.x       .copy();             if (!this.y       ) this.y        = this.value.y       .copy();             if (!this.size    ) this.size     = this.value.size    .copy();             if (!this.angle   ) this.angle    = this.value.angle   .copy();             if (!this.aspect  ) this.aspect   = this.value.aspect  .copy();             if (!this.skew    ) this.skew     = this.value.skew    .copy();             if (!this.blend   ) this.blend    = this.value.blend   .copy();         }           this.validate();          return this;     }                x3633()     {         return this.value.copy();     }                         isValid()     {         return !this.inputs.find(i => !i.isValid())             && this.x3687 && this.x3687.isValid()             && this.position && this.position.isValid()             && this.x        && this.x       .isValid()             && this.y        && this.y       .isValid()             && this.size     && this.size    .isValid()             && this.angle    && this.angle   .isValid()             && this.aspect   && this.aspect  .isValid()             && this.skew     && this.skew    .isValid()             && this.blend    && this.blend   .isValid();     }        r4088(parse)     {         super.r4088(parse);          this.inputs.forEach(i => i.r4088(parse));          if (this.x3687) this.x3687.r4088(parse);         if (this.position) this.position.r4088(parse);         if (this.x       ) this.x       .r4088(parse);         if (this.y       ) this.y       .r4088(parse);         if (this.size    ) this.size    .r4088(parse);         if (this.angle   ) this.angle   .r4088(parse);         if (this.aspect  ) this.aspect  .r4088(parse);         if (this.skew    ) this.skew    .r4088(parse);         if (this.blend   ) this.blend   .r4088(parse);     }            o4089(parse, from, force)     {         super.o4089(parse, from, force);          this.inputs.forEach(i => i.o4089(parse, from, force));                  if (this.x3687) this.x3687.o4089(parse, from, force);         if (this.position) this.position.o4089(parse, from, force);         if (this.x       ) this.x       .o4089(parse, from, force);         if (this.y       ) this.y       .o4089(parse, from, force);         if (this.size    ) this.size    .o4089(parse, from, force);         if (this.angle   ) this.angle   .o4089(parse, from, force);         if (this.aspect  ) this.aspect  .o4089(parse, from, force);         if (this.skew    ) this.skew    .o4089(parse, from, force);         if (this.blend   ) this.blend   .o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          this.inputs.forEach(i => i.t4087(parse));          if (this.x3687) this.x3687.t4087(parse);         if (this.position) this.position.t4087(parse);         if (this.x       ) this.x       .t4087(parse);         if (this.y       ) this.y       .t4087(parse);         if (this.size    ) this.size    .t4087(parse);         if (this.angle   ) this.angle   .t4087(parse);         if (this.aspect  ) this.aspect  .t4087(parse);         if (this.skew    ) this.skew    .t4087(parse);         if (this.blend   ) this.blend   .t4087(parse);     }     }


class e1896 extends i2044 {     fills  = null;    c3675  = null;      weight = null;     fit    = null;     join   = null;     miter  = null;     cap    = null;     dashes = null;                constructor(nodeId, options)     {         super(y1182, nodeId, options);     }                reset()     {         super.reset();                  this. fills  = null;         this.c3675  = null;          this. weight = null;         this. fit    = null;         this. join   = null;         this. miter  = null;         this. cap    = null;         this. dashes = null;     }        copy()     {         const copy = new e1896(this.nodeId, this.options);          copy.n3359(this);          if (this.fills ) copy. fills  = this.fills .copy();         if (this.c3675) copy.c3675  = this.c3675.copy();         if (this.weight) copy. weight = this.weight.copy();         if (this.fit   ) copy. fit    = this.fit   .copy();         if (this.join  ) copy. join   = this.join  .copy();         if (this.miter ) copy. miter  = this.miter .copy();         if (this.cap   ) copy. cap    = this.cap   .copy();         if (this.dashes) copy. dashes = this.dashes.copy();          return copy;     }        f4242(p2992)     {         switch (p2992)         {             case 'fills ':  return this.input ? this.value.fills  : this.fills;             case 'weight':  return this.input ? this.value.weight : this.weight;             case 'fit':     return this.input ? this.value.fit    : this.fit;             case 'join':    return this.input ? this.value.join   : this.join;             case 'miter':   return this.input ? this.value.miter  : this.miter;             case 'cap':     return this.input ? this.value.cap    : this.cap;             case 'dashes':  return this.input ? this.value.dashes : this.dashes;         }          return null;     }        async eval(parse)     {         if (this.isCached())             return this;          const input = await evalStrokeValue(this. input, parse);         let   fills = await evalListValue  (this.c3675, parse);          fills = this.validateFills(fills);          if (!g957(this.c3675.type))             this.fills = fills;           const weight = await evalNumberValue(this.weight, parse);         const fit    = await evalNumberValue(this.fit,    parse);         const join   = await evalNumberValue(this.join,   parse);         const miter  = await evalNumberValue(this.miter,  parse);         const cap    = await evalNumberValue(this.cap,    parse);         const dashes = await evalTextValue  (this.dashes, parse);           if (input)         {             this.value = new y2031(                 fills  ?? input.fills,                 weight ?? input.weight,                 fit    ?? input.fit,                 join   ?? input.join,                 miter  ?? input.miter,                 cap    ?? input.cap,                 dashes ?? input.dashes);         }         else         {             this.value = new y2031(                 fills,                  weight,                  fit,                  join,                 miter,                 cap,                 dashes);         }           this.n4101(parse,         [             ['value',  this.value],             ['fills',  fills     ],             ['weight', weight    ],             ['fit',    fit       ],             ['join',   join      ],             ['miter',  miter     ],             ['cap',    cap       ],             ['dashes', dashes    ]         ]);           this.validate();          return this;     }        validateFills(fills)     {                     if (!fills)             return null;          if (fills.type == x1168)             return new x2021([v2013.k3773(t4142(fills.e3242()), 100)]);          else if (fills.type ==     k1178               || fills.type == i1187)             return new x2021([fills]);         else         {             l952(fills.type == y1056, 'stroke.fills must be a LIST_VALUE');             return fills;         }     }        x3633()     {         return new y2031(             this.options.enabled             ? this.validateFills(this.fills ? this.fills.x3633() : this.input.fills.x3633())             : new x2021(),             this.weight ? this.weight.x3633() : this.input.weight.x3633(),             this.fit    ? this.fit   .x3633() : this.input.fit   .x3633(),             this.join   ? this.join  .x3633() : this.input.join  .x3633(),             this.miter  ? this.miter .x3633() : this.input.miter .x3633(),             this.cap    ? this.cap   .x3633() : this.input.cap   .x3633(),             this.dashes ? this.dashes.x3633() : this.input.dashes.x3633());     }                         isValid()     {         return (!this.input || this.input.isValid())             && this.fills  && this.fills .isValid()             && this.weight && this.weight.isValid()             && this.fit    && this.fit   .isValid()             && this.join   && this.join  .isValid()             && this.miter  && this.miter .isValid()             && this.cap    && this.cap   .isValid()             && this.dashes && this.dashes.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.c3675) this.c3675.r4088(parse);         if (this.weight) this.weight.r4088(parse);         if (this.fit   ) this.fit   .r4088(parse);         if (this.join  ) this.join  .r4088(parse);         if (this.miter ) this.miter .r4088(parse);         if (this.cap   ) this.cap   .r4088(parse);         if (this.dashes) this.dashes.r4088(parse);     }                    o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.c3675) this.c3675.o4089(parse, from, force);         if (this.weight) this.weight.o4089(parse, from, force);         if (this.fit   ) this.fit   .o4089(parse, from, force);         if (this.join  ) this.join  .o4089(parse, from, force);         if (this.miter ) this.miter .o4089(parse, from, force);         if (this.cap   ) this.cap   .o4089(parse, from, force);         if (this.dashes) this.dashes.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.c3675) this.c3675.t4087(parse);         if (this.weight) this.weight.t4087(parse);         if (this.fit   ) this.fit   .t4087(parse);         if (this.join  ) this.join  .t4087(parse);         if (this.miter ) this.miter .t4087(parse);         if (this.cap   ) this.cap   .t4087(parse);         if (this.dashes) this.dashes.t4087(parse);     }     }


class GStrokeSides extends i2044 {     top    = null;     left   = null;     right  = null;     bottom = null;                constructor(nodeId, options)     {         super(o1191, nodeId, options);     }                reset()     {         super.reset();                  this.top    = null;         this.left   = null;         this.right  = null;         this.bottom = null;     }        copy()     {         const copy = new GStrokeSides(this.nodeId, this.options);          copy.n3359(this);          if (this.top   ) copy.top    = this.top   .copy();         if (this.left  ) copy.left   = this.left  .copy();         if (this.right ) copy.right  = this.right .copy();         if (this.bottom) copy.bottom = this.bottom.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalStrokeSidesValue(this.input,  parse);         const top    = await evalNumberValue     (this.top,    parse);         const left   = await evalNumberValue     (this.left,   parse);         const right  = await evalNumberValue     (this.right,  parse);         const bottom = await evalNumberValue     (this.bottom, parse);           if (input)         {             this.value = new g4272(                 top    ?? input.top,                 left   ?? input.left,                 right  ?? input.right,                 bottom ?? input.bottom,                 this.options.enabled);         }         else         {             this.value = new g4272(                 top,                  left,                  right,                  bottom,                 this.options.enabled);         }           this.n4101(parse,         [             ['top',    this.value.top   ],             ['left',   this.value.left  ],             ['right',  this.value.right ],             ['bottom', this.value.bottom]         ]);                   if (!this.top   ) this.top    = this.value.top   .copy();         if (!this.left  ) this.left   = this.value.left  .copy();         if (!this.right ) this.right  = this.value.right .copy();         if (!this.bottom) this.bottom = this.value.bottom.copy();           this.validate();          return this;     }        x3633()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.top    && this.top   .isValid()             && this.left   && this.left  .isValid()             && this.right  && this.right .isValid()             && this.bottom && this.bottom.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.top   ) this.top   .r4088(parse);         if (this.left  ) this.left  .r4088(parse);         if (this.right ) this.right .r4088(parse);         if (this.bottom) this.bottom.r4088(parse);     }                   o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.top   ) this.top   .o4089(parse, from, force);         if (this.left  ) this.left  .o4089(parse, from, force);         if (this.right ) this.right .o4089(parse, from, force);         if (this.bottom) this.bottom.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.top   ) this.top   .t4087(parse);         if (this.left  ) this.left  .t4087(parse);         if (this.right ) this.right .t4087(parse);         if (this.bottom) this.bottom.t4087(parse);     } }


class q1895 extends i2044 {     tl = null;     tr = null;     bl = null;     br = null;                constructor(nodeId, options)     {         super(b1194, nodeId, options);     }                reset()     {         super.reset();                  this.tl = null;         this.tr = null;         this.bl = null;         this.br = null;     }        copy()     {         const copy = new q1895(this.nodeId, this.options);          copy.n3359(this);          if (this.tl) copy.tl = this.tl.copy();         if (this.tr) copy.tr = this.tr.copy();         if (this.bl) copy.bl = this.bl.copy();         if (this.br) copy.br = this.br.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalRoundedCornersValue(this.input, parse);         const tl    = await evalNumberValue        (this.tl,    parse);         const tr    = await evalNumberValue        (this.tr,    parse);         const bl    = await evalNumberValue        (this.bl,    parse);         const br    = await evalNumberValue        (this.br,    parse);           if (input)         {             this.value = new h2026(                 tl ?? input.tl,                 tr ?? input.tr,                 bl ?? input.bl,                 br ?? input.br,                 this.options.enabled);         }         else         {             this.value = new h2026(                 tl,                  tr,                  bl,                  br,                 this.options.enabled);         }           this.n4101(parse,         [             ['tl', this.value.tl],             ['tr', this.value.tr],             ['bl', this.value.bl],             ['br', this.value.br]         ]);                   if (!this.tl) this.tl = this.value.tl.copy();         if (!this.tr) this.tr = this.value.tr.copy();         if (!this.bl) this.bl = this.value.bl.copy();         if (!this.br) this.br = this.value.br.copy();           this.validate();          return this;     }        x3633()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.tl && this.tl.isValid()             && this.tr && this.tr.isValid()             && this.bl && this.bl.isValid()             && this.br && this.br.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.tl) this.tl.r4088(parse);         if (this.tr) this.tr.r4088(parse);         if (this.bl) this.bl.r4088(parse);         if (this.br) this.br.r4088(parse);     }                   o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.tl) this.tl.o4089(parse, from, force);         if (this.tr) this.tr.o4089(parse, from, force);         if (this.bl) this.bl.o4089(parse, from, force);         if (this.br) this.br.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.tl) this.tl.t4087(parse);         if (this.tr) this.tr.t4087(parse);         if (this.bl) this.bl.t4087(parse);         if (this.br) this.br.t4087(parse);     } }


class v1888 extends i2044 {     x      = null;     y      = null;     blur   = null;     spread = null;     fill   = null;     blend  = null;     behind = null;                constructor(nodeId, options)     {         super(z1197, nodeId, options);     }                reset()     {         super.reset();                  this.x      = null;         this.y      = null;         this.blur   = null;         this.spread = null;         this.fill   = null;         this.blend  = null;         this.behind = null;     }        copy()     {         const copy = new v1888(this.nodeId, this.options);          copy.n3359(this);          if (this.x     ) copy.x      = this.x     .copy();         if (this.y     ) copy.y      = this.y     .copy();         if (this.blur  ) copy.blur   = this.blur  .copy();         if (this.spread) copy.spread = this.spread.copy();         if (this.fill  ) copy.fill   = this.fill  .copy();         if (this.blend ) copy.blend  = this.blend .copy();         if (this.behind) copy.behind = this.behind.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalValue      (this.input,  parse);         const x      = await evalNumberValue(this.x,      parse);         const y      = await evalNumberValue(this.y,      parse);         const blur   = await evalNumberValue(this.blur,   parse);         const spread = await evalNumberValue(this.spread, parse);         let   fill   = await evalFillValue  (this.fill,   parse);         const blend  = await evalNumberValue(this.blend,  parse);         const behind = await evalNumberValue(this.behind, parse);           if (   fill             && fill.type == x1168)             fill = new v2013(fill);                   if (input)         {             this.value = new m2011(                 x      ?? input.x,                 y      ?? input.y,                 blur   ?? input.blur,                 spread ?? input.spread,                 fill   ?? input.fill,                 blend  ?? input.blend,                 behind ?? input.behind,                 this.options.enabled);         }         else         {             this.value = new m2011(                 x,                  y,                  blur,                  spread,                  fill,                  blend,                  behind,                 this.options.enabled);         }           this.n4101(parse,         [             ['x',      this.value.x     ],             ['y',      this.value.y     ],             ['blur',   this.value.blur  ],             ['spread', this.value.spread],             ['fill',   this.value.fill  ],             ['blend',  this.value.blend ],             ['behind', this.value.behind]         ]);                   if (!this.x     ) this.x      = this.value.x     .copy();         if (!this.y     ) this.y      = this.value.y     .copy();         if (!this.blur  ) this.blur   = this.value.blur  .copy();         if (!this.spread) this.spread = this.value.spread.copy();         if (!this.fill  ) this.fill   = this.value.fill  .copy();         if (!this.blend ) this.blend  = this.value.blend .copy();         if (!this.behind) this.behind = this.value.behind.copy();           this.validate();          return this;     }        x3633()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.x      && this.x     .isValid()             && this.y      && this.y     .isValid()             && this.blur   && this.blur  .isValid()             && this.spread && this.spread.isValid()             && this.fill   && this.fill  .isValid()             && this.blend  && this.blend .isValid()             && this.behind && this.behind.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.x     ) this.x     .r4088(parse);         if (this.y     ) this.y     .r4088(parse);         if (this.blur  ) this.blur  .r4088(parse);         if (this.spread) this.spread.r4088(parse);         if (this.fill  ) this.fill  .r4088(parse);         if (this.blend ) this.blend .r4088(parse);         if (this.behind) this.behind.r4088(parse);     }                   o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.x     ) this.x     .o4089(parse, from, force);         if (this.y     ) this.y     .o4089(parse, from, force);         if (this.blur  ) this.blur  .o4089(parse, from, force);         if (this.spread) this.spread.o4089(parse, from, force);         if (this.fill  ) this.fill  .o4089(parse, from, force);         if (this.blend ) this.blend .o4089(parse, from, force);         if (this.behind) this.behind.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.x     ) this.x     .t4087(parse);         if (this.y     ) this.y     .t4087(parse);         if (this.blur  ) this.blur  .t4087(parse);         if (this.spread) this.spread.t4087(parse);         if (this.fill  ) this.fill  .t4087(parse);         if (this.blend ) this.blend .t4087(parse);         if (this.behind) this.behind.t4087(parse);     } }


class y1891 extends i2044 {     x      = null;     y      = null;     blur   = null;     spread = null;     fill   = null;     blend  = null;                constructor(nodeId, options)     {         super(k1200, nodeId, options);     }        reset()     {         super.reset();          this.x      = null;         this.y      = null;         this.blur   = null;         this.spread = null;         this.fill   = null;         this.blend  = null;     }        copy()     {         const copy = new y1891(this.nodeId, this.options);          copy.n3359(this);          if (this.x     ) copy.x      = this.x     .copy();         if (this.y     ) copy.y      = this.y     .copy();         if (this.blur  ) copy.blur   = this.blur  .copy();         if (this.spread) copy.spread = this.spread.copy();         if (this.fill  ) copy.fill   = this.fill  .copy();         if (this.blend ) copy.blend  = this.blend .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalInnerShadowValue(this.input,  parse);         const x      = await evalNumberValue     (this.x,      parse);         const y      = await evalNumberValue     (this.y,      parse);         const blur   = await evalNumberValue     (this.blur,   parse);         const spread = await evalNumberValue     (this.spread, parse);         let   fill   = await evalFillValue       (this.fill,   parse);         const blend  = await evalNumberValue     (this.blend,  parse);                   if (   fill             && fill.type == x1168)             fill = new v2013(fill);           if (input)         {             this.value = new c2016(                 x      ?? input.x,                 y      ?? input.y,                 blur   ?? input.blur,                 spread ?? input.spread,                 fill   ?? input.fill,                 blend  ?? input.blend,                 this.options.enabled);         }         else         {             this.value = new c2016(                 x,                  y,                  blur,                  spread,                  fill,                  blend,                 this.options.enabled);         }           this.n4101(parse,         [             ['x',      this.value.x     ],             ['y',      this.value.y     ],             ['blur',   this.value.blur  ],             ['spread', this.value.spread],             ['fill',   this.value.fill  ],             ['blend',  this.value.blend ],         ]);                   if (!this.x     ) this.x      = this.value.x     .copy();         if (!this.y     ) this.y      = this.value.y     .copy();         if (!this.blur  ) this.blur   = this.value.blur  .copy();         if (!this.spread) this.spread = this.value.spread.copy();         if (!this.fill  ) this.fill   = this.value.fill  .copy();         if (!this.blend ) this.blend  = this.value.blend .copy();           this.validate();          return this;     }        x3633()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.x      && this.x     .isValid()             && this.y      && this.y     .isValid()             && this.blur   && this.blur  .isValid()             && this.spread && this.spread.isValid()             && this.fill   && this.fill  .isValid()             && this.blend  && this.blend .isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.x     ) this.x     .r4088(parse);         if (this.y     ) this.y     .r4088(parse);         if (this.blur  ) this.blur  .r4088(parse);         if (this.spread) this.spread.r4088(parse);         if (this.fill  ) this.fill  .r4088(parse);         if (this.blend ) this.blend .r4088(parse);     }                    o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.x     ) this.x     .o4089(parse, from, force);         if (this.y     ) this.y     .o4089(parse, from, force);         if (this.blur  ) this.blur  .o4089(parse, from, force);         if (this.spread) this.spread.o4089(parse, from, force);         if (this.fill  ) this.fill  .o4089(parse, from, force);         if (this.blend ) this.blend .o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.x     ) this.x     .t4087(parse);         if (this.y     ) this.y     .t4087(parse);         if (this.blur  ) this.blur  .t4087(parse);         if (this.spread) this.spread.t4087(parse);         if (this.fill  ) this.fill  .t4087(parse);         if (this.blend ) this.blend .t4087(parse);     } }


class j1893 extends i2044 {     radius = null;        constructor(nodeId, options)     {         super(y1203, nodeId, options);     }        reset()     {         super.reset();          this.radius = null;     }        copy()     {         const copy = new j1893(this.nodeId, this.options);          copy.n3359(this);          if (this.radius) copy.radius = this.radius.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalLayerBlurValue(this.input,  parse);         const radius = await evalNumberValue   (this.radius, parse);                   if (input)         {             this.value = new j2018(                 radius ?? input.radius,                 this.options.enabled);         }         else         {             this.value = new j2018(                 radius,                 this.options.enabled);         }           this.n4101(parse,         [             ['radius', this.value.radius]         ]);                   if (!this.radius) this.radius = this.value.radius.copy();           this.validate();          return this;     }        x3633()     {         return new j2018(             this.radius ? this.radius.x3633() : this.input.radius.x3633(),             this.options.enabled);     }        isValid()     {         return super.isValid()             && this.radius && this.radius.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.radius) this.radius.r4088(parse);     }                    o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.radius) this.radius.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.radius) this.radius.t4087(parse);     } }


class w1885 extends i2044 {     radius = null;        constructor(nodeId, options)     {         super(h1206, nodeId, options);     }        reset()     {         super.reset();          this.radius = null;     }        copy()     {         const copy = new w1885(this.nodeId, this.options);          copy.n3359(this);          if (this.radius) copy.radius = this.radius.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalValue      (this.input,  parse);         const radius = await evalNumberValue(this.radius, parse);                   if (input)         {             this.value = new p2008(                 radius ?? input.radius,                 this.options.enabled);         }         else         {             this.value = new p2008(                 radius,                 this.options.enabled);         }           this.n4101(parse,         [             ['radius', this.value.radius]         ]);                   if (!this.radius) this.radius = this.value.radius.copy();           this.validate();          return this;     }        x3633()     {         return new p2008(             this.radius ? this.radius.x3633() : this.input.radius.x3633(),             this.options.enabled);     }        isValid()     {         return super.isValid()             && this.radius && this.radius.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.radius) this.radius.r4088(parse);     }                    o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.radius) this.radius.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.radius) this.radius.t4087(parse);     } }


class w1892 extends g2043 {     opacity;     blend;        constructor(nodeId, options)     {         super(h1212, nodeId, options);     }        reset()     {         super.reset();          this.opacity = null;         this.blend   = null;     }        copy()     {         const copy = new w1892(this.nodeId, this.options);          copy.n3359(this);          if (this.opacity) copy.opacity = this.opacity.copy();         if (this.blend  ) copy.blend   = this.blend  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const opacity = await evalNumberValue(this.opacity, parse);         const blend   = await evalNumberValue(this.blend,   parse);           this.value =              this.options.enabled             ? new f2017(opacity, blend)             : new f2017(new d2022(100), new d2022(0));           this.n4101(parse,          [             ['opacity', opacity],             ['blend',   blend  ]         ]);           this.validate();          return this;     }        x3633()     {         return this.value.copy();     }        isValid()     {         return this.opacity && this.opacity.isValid()             && this.blend   && this.blend  .isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.opacity) this.opacity.r4088(parse);         if (this.blend  ) this.blend  .r4088(parse);     }                    o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.opacity) this.opacity.o4089(parse, from, force);         if (this.blend  ) this.blend  .o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.opacity) this.opacity.t4087(parse);         if (this.blend  ) this.blend  .t4087(parse);     } }


class r1894 extends g2043 {     maskType;        constructor(nodeId, options)     {         super(o1209, nodeId, options);     }        reset()     {         super.reset();          this.maskType = null;     }        copy()     {         const copy = new r1894(this.nodeId, this.options);          copy.n3359(this);          if (this.maskType) copy.maskType = this.maskType.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const maskType = await evalNumberValue(this.maskType, parse);           this.value = new g2019(maskType, this.options.enabled);           this.n4101(parse,          [             ['maskType', maskType]         ]);           this.validate();          return this;     }        x3633()     {         return this.value.copy();     }        isValid()     {         return this.maskType && this.maskType.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.maskType) this.maskType.r4088(parse);     }                    o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.maskType) this.maskType.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.maskType) this.maskType.t4087(parse);     } }


class j1975 extends g2043 {     x      = null;     y      = null;     width  = null;     height = null;        constructor(type, nodeId, options)     {         super(type, nodeId, options);     }        reset()     {         super.reset();                  this.x      = null;         this.y      = null;         this.width  = null;         this.height = null;     }        n3359(base)     {         super.n3359(base);          if (base.x     ) this.x      = base.x     .copy();         if (base.y     ) this.y      = base.y     .copy();         if (base.width ) this.width  = base.width .copy();         if (base.height) this.height = base.height.copy();     }        async evalBaseParams(parse, evalHeight = true)     {         let x      =              await evalNumberValue(this.x,      parse);         let y      =              await evalNumberValue(this.y,      parse);         let width  =              await evalNumberValue(this.width,  parse);         let height = evalHeight ? await evalNumberValue(this.height, parse) : null;          return [x, y, width, height];     }        evalStyle(options = {})     {                       }        isValid()     {         return this.x      && this.x     .isValid()             && this.y      && this.y     .isValid()             && this.width  && this.width .isValid()             && this.height && this.height.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.x     ) this.x     .r4088(parse);         if (this.y     ) this.y     .r4088(parse);         if (this.width ) this.width .r4088(parse);         if (this.height) this.height.r4088(parse);     }            o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.x     ) this.x     .o4089(parse, from, force);         if (this.y     ) this.y     .o4089(parse, from, force);         if (this.width ) this.width .o4089(parse, from, force);         if (this.height) this.height.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.x     ) this.x     .t4087(parse);         if (this.y     ) this.y     .t4087(parse);         if (this.width ) this.width .t4087(parse);         if (this.height) this.height.t4087(parse);     } }    function validateObjectRect(x, y, w, h, a = 0, _a = 0) {     if (w < 0)     {         x += w * Math.cos(_a);         y += w * Math.sin(_a);     }      if (h < 0)     {         y += h * Math.cos(_a);         x -= h * Math.sin(_a);     }             w = Math.abs(w);     h = Math.abs(h);       return [x, y, w, h, a, _a]; }


class w1974 extends j1975 {     input = null;      props = null;           constructor(type, nodeId, options)     {         super(type, nodeId, options);     }        reset()     {         super.reset();          this.input = null;         this.props = null;     }        n3359(base)     {         super.n3359(base);                  if (base.input) this.input = base.input.copy();         if (base.props) this.props = base.props.copy();     }        f4242(p2992)     {         switch (p2992)         {             case 'props':  return this.input ? this.value.props : this.props;         }          return null;     }        i2897()     {         return this.value             && this.value.props             && this.value.props.isValid();     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        async t2896(parse)     {         let props = await evalListValue(this.props, parse);          if (   props             && o1215.includes(props.type))             props = new x2021([props]);                   if (this.value)         {             if (this.input)             {                 this.value.props = props ?? this.input.x3633().props;                                  if (props)  this.value.props = props;  else  props = this.value.props;               }             else                 this.value.props = props;                                   if (   this.value                 && this.value.isValid()                 && this.value.props != undefined)              {                 this.n4101(parse,                  [                                      ],                  true);                                   if (!this.props) this.props = this.value.props.copy();             }         }     }        async v4100(parse)     {         if (!this.value)             return;           for (const a111 of this.value.objects)         {             l952(a111.fills,   'obj.fills   must not be null');             l952(a111.strokes, 'obj.strokes must not be null');             l952(a111.effects, 'obj.effects must not be null');               if (this.value.props)                 addProps(a111, this.value.props);         }     }        evalStyle(options = {})     {      }        isValid()     {         return super.isValid()             && (!this.input || this.input.isValid())             && this.props && this.props.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.input) this.input.r4088(parse);         if (this.props) this.props.r4088(parse);     }            o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.input) this.input.o4089(parse, from, force);         if (this.props) this.props.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.input) this.input.t4087(parse);         if (this.props) this.props.t4087(parse);     } }    function addProps(a111, props) {     if (g957(props.type))     {                        for (let i = 0; i < props.items.length; i++)             p1823(a111, props.items[i]);     }     else         p1823(a111, props); }


class b1969 extends w1974 {     round = null;        constructor(nodeId, options)     {         super(d1219, nodeId, options);     }        reset()     {         super.reset();          this.round = null;     }        copy()     {         const copy = new b1969(this.nodeId, this.options);          copy.n3359(this);          if (this.round) copy.round = this.round.copy();          return copy;     }        f4242(p2992)     {         switch (p2992)         {             case 'x':      return this.input ? this.value.x      : this.x;             case 'y':      return this.input ? this.value.y      : this.y;             case 'width':  return this.input ? this.value.width  : this.width;             case 'height': return this.input ? this.value.height : this.height;             case 'round':  return this.input ? this.value.round  : this.round;         }          return super.f4242(p2992);     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalRectangleValue(this.input, parse);         let   round = await evalNumberValue   (this.round, parse);          if (round && !round.isValid()) round = d2022.NaN.copy();                   let [x, y, width, height] = await this.evalBaseParams(parse);           if (input)         {             this.value        = input.x3633();             this.value.nodeId = this.nodeId;             this.value.r3626(input);                          if (x     )  this.value.x      = x;       else  x      = this.value.x;                   if (y     )  this.value.y      = y;       else  y      = this.value.y;                   if (width )  this.value.width  = width;   else  width  = this.value.width;               if (height)  this.value.height = height;  else  height = this.value.height;              if (round )  this.value.round  = round;   else  round  = this.value.round;           }         else         {             this.value = new s2025(                 this.nodeId,                  x,                  y,                  width,                  height,                  round);         }                  this.n4101(parse,          [             ['x',      x     ],             ['y',      y     ],             ['width',  width ],             ['height', height],             ['round',  round ]         ]);           await this.t2896(parse);           await this.v4100(parse);           if (!this.x     ) this.x      = this.value.x     .copy();         if (!this.y     ) this.y      = this.value.y     .copy();         if (!this.width ) this.width  = this.value.width .copy();         if (!this.height) this.height = this.value.height.copy();         if (!this.round ) this.round  = this.value.round .copy();           this.validate();          return this;     }        async v4100(parse, options = {})     {         if (!this.options.enabled)             return;                        this.value.objects = [];           if (   super.i2897()                && this.value.x     .isValid()             && this.value.y     .isValid()             && this.value.width .isValid()             && this.value.height.isValid()             && this.value.round .isValid())         {             let   x = this.value.x     .value;             let   y = this.value.y     .value;             let   w = this.value.width .value;             let   h = this.value.height.value;             const r = Math.max(0, this.value.round.value);               [x, y, w, h, , ] = validateObjectRect(x, y, w, h);               if (   w != 0                  && h != 0)             {                 const rect = new r1846(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     x, y, w, h, r);                  rect.r4098(x, y);                 rect.x3730(x, y, w, h);                  this.value.objects.push(rect);             }         }                   await super.v4100(parse);     }                                                                                    isValid()     {         return super.isValid()             && this.round && this.round.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.round) this.round.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.round) this.round.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.round) this.round.t4087(parse);     } }


class q1960 extends w1974 {     constructor(nodeId, options)     {         super(t1222, nodeId, options);     }        copy()     {         const copy = new q1960(this.nodeId, this.options);          copy.n3359(this);          return copy;     }        f4242(p2992)     {         switch (p2992)         {             case 'x':     return this.input ? this.value.x     : this.x;             case 'y':     return this.input ? this.value.y     : this.y;             case 'width': return this.input ? this.value.width : this.width;         }          return super.f4242(p2992);     }        async eval(parse)     {         if (this.isCached())             return this;           let input = await evalLineValue(this.input, parse);          let [x, y, width, ] = await this.evalBaseParams(parse, false);                       if (input)         {             this.value        = input.x3633();             this.value.nodeId = this.nodeId;             this.value.r3626(input);              if (x    )  this.value.x     = x;      else  x     = this.value.x;                   if (y    )  this.value.y     = y;      else  y     = this.value.y;                   if (width)  this.value.width = width;  else  width = this.value.width;           }         else         {             this.value = new s2020(                 this.nodeId,                  x,                  y,                  width);         }           this.n4101(parse,          [             ['x',      x     ],             ['y',      y     ],             ['width',  width ]         ]);           await this.t2896(parse);           await this.v4100(parse);           if (!this.x    ) this.x     = this.value.x    .copy();         if (!this.y    ) this.y     = this.value.y    .copy();         if (!this.width) this.width = this.value.width.copy();           this.validate();          return this;     }        async v4100(parse, options = {})     {         if (!this.options.enabled)             return;                       this.value.objects = [];           if (   super.i2897()                && this.value.x    .isValid()             && this.value.y    .isValid()             && this.value.width.isValid())          {             let x = this.value.x    .value;             let y = this.value.y    .value;             let w = this.value.width.value;               [x, y, w, , , ] = validateObjectRect(x, y, w, 0);               if (w != 0)             {                 const line = new u1842(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     x, y, w);                  line.r4098(x, y);                 line.x3730(x, y, w, 0.01);                                  this.value.objects.push(line);             }         }                   await super.v4100(parse);     }        isValid()     {         return super.isValid()             && this.x     && this.x    .isValid()             && this.y     && this.y    .isValid()             && this.width && this.width.isValid();     }        r4088(parse)     {         super.r4088(parse);           if (this.x    ) this.x    .r4088(parse);         if (this.y    ) this.y    .r4088(parse);         if (this.width) this.width.r4088(parse);     }                   o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.x    ) this.x    .o4089(parse, from, force);         if (this.y    ) this.y    .o4089(parse, from, force);         if (this.width) this.width.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);           if (this.x    ) this.x    .t4087(parse);         if (this.y    ) this.y    .t4087(parse);         if (this.width) this.width.t4087(parse);     } }


class g1956 extends w1974 {     position = null;     round    = null;     start    = null;     sweep    = null;     inner    = null;      innerAbsolute;     sweepInDegrees;        constructor(nodeId, options)     {         super(w1225, nodeId, options);     }        reset()     {         super.reset();          this.position = null;         this.round    = null;         this.start    = null;         this.sweep    = null;         this.inner    = null;     }        copy()     {         const copy = new g1956(this.nodeId, this.options);          copy.n3359(this);          if (this.position) copy.position = this.position.copy();         if (this.round   ) copy.round    = this.round   .copy();         if (this.start   ) copy.start    = this.start   .copy();         if (this.sweep   ) copy.sweep    = this.sweep   .copy();         if (this.inner   ) copy.inner    = this.inner   .copy();                  return copy;     }        f4242(p2992)     {         switch (p2992)         {             case 'position': return this.input ? this.value.position : this.position;             case 'x':        return this.input ? this.value.x        : this.x;             case 'y':        return this.input ? this.value.y        : this.y;             case 'width':    return this.input ? this.value.width    : this.width;             case 'height':   return this.input ? this.value.height   : this.height;             case 'round':    return this.input ? this.value.round    : this.round;             case 'start':    return this.input ? this.value.start    : this.start;             case 'sweep':    return this.input ? this.value.sweep    : this.sweep;             case 'inner':    return this.input ? this.value.inner    : this.inner         }          return super.f4242(p2992);     }        async eval(parse)     {         if (this.isCached())             return this;           let [x, y, width, height] = await this.evalBaseParams(parse);          let input = await evalValue      (this.input,    parse);         let pos   = await evalNumberValue(this.position, parse);         let round = await evalNumberValue(this.round,    parse);         let start = await evalNumberValue(this.start,    parse);         let sweep = await evalNumberValue(this.sweep,    parse);         let inner = await evalNumberValue(this.inner,    parse);          if (pos   && !pos  .isValid()) pos   = d2022.NaN.copy();         if (round && !round.isValid()) round = d2022.NaN.copy();         if (start && !start.isValid()) start = d2022.NaN.copy();         if (sweep && !sweep.isValid()) sweep = d2022.NaN.copy();         if (inner && !inner.isValid()) inner = d2022.NaN.copy();           if (input)         {             this.value        = input.copy();             this.value.nodeId = this.nodeId;             this.value.r3626(input);              if (pos   )  this.value.position = pos;     else  pos    = this.value.position;             if (x     )  this.value.x        = x;       else  x      = this.value.x;                   if (y     )  this.value.y        = y;       else  y      = this.value.y;                   if (width )  this.value.width    = width;   else  width  = this.value.width;               if (height)  this.value.height   = height;  else  height = this.value.height;              if (round )  this.value.round    = round;   else  round  = this.value.round;               if (start )  this.value.start    = start;   else  start  = this.value.start;             if (sweep )  this.value.sweep    = sweep;   else  sweep  = this.value.sweep;             if (inner )  this.value.inner    = inner;   else  inner  = this.value.inner;           }         else         {             this.value = new i2012(                 this.nodeId,                 pos,                 x,                  y,                  width,                  height,                 round,                 start,                 sweep,                 inner);         }           this.n4101(parse,          [             ['position', pos   ],             ['x',        x     ],             ['y',        y     ],             ['width',    width ],             ['height',   height],             ['round',    round ],             ['start',    start ],             ['sweep',    sweep ],             ['inner',    inner ]         ]);           await this.t2896(parse);           await this.v4100(parse);           this.validate();          return this;     }        async v4100(parse, options = {})     {        if (!this.options.enabled)            return;                                 this.value.objects = [];           if (   super.i2897()             && this.value.x     .isValid()             && this.value.y     .isValid()             && this.value.width .isValid()             && this.value.height.isValid())          {             const vpos = this.value.position;             const vx   = this.value.x;             const vy   = this.value.y;             const vw   = this.value.width;             const vh   = this.value.height;              const _x = vpos.value <= 0 ? vx : new d2022(vx.value - vw.value, Math.max(vx.decimals, vw.decimals));             const _y = vpos.value <= 0 ? vy : new d2022(vy.value - vh.value, Math.max(vy.decimals, vh.decimals));             const _w = vpos.value <= 0 ? vw : new d2022(vw.value*2, Math.max(vx.decimals, vw.decimals));             const _h = vpos.value <= 0 ? vh : new d2022(vh.value*2, Math.max(vy.decimals, vh.decimals));                          let   x  = _x.value;             let   y  = _y.value;             let   w  = _w.value;             let   h  = _h.value;             let   r  = this.value.round .value;             const st = this.value.start .value;             let   sw = this.value.sweep .value;             let   i  = this.value.inner .value;               [x, y, w, h, , ] = validateObjectRect(x, y, w, h);               if (   w != 0                  && h != 0)             {                 if (this.innerAbsolute ) i  /= Math.max(w, h) / 200;                 if (this.sweepInDegrees) sw /= 3.6;                  const ellipse = new x1840(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     x, y, w, h, r, st, sw, i);                  ellipse.r4098(x, y);                 ellipse.x3730(x, y, w, h);                  this.value.objects.push(ellipse);             }         }           await super.v4100(parse);     }                       isValid()     {         return super.isValid()             && this.position && this.position.isValid()             && this.round    && this.round   .isValid()             && this.start    && this.start   .isValid()             && this.sweep    && this.sweep   .isValid()             && this.inner    && this.inner   .isValid();     }        r4088(parse)     {         super.r4088(parse);           if (this.position) this.position.r4088(parse);         if (this.round   ) this.round   .r4088(parse);         if (this.start   ) this.start   .r4088(parse);         if (this.sweep   ) this.sweep   .r4088(parse);         if (this.inner   ) this.inner   .r4088(parse);     }                   o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.position) this.position.o4089(parse, from, force);         if (this.round   ) this.round   .o4089(parse, from, force);         if (this.start   ) this.start   .o4089(parse, from, force);         if (this.sweep   ) this.sweep   .o4089(parse, from, force);         if (this.inner   ) this.inner   .o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);           if (this.position) this.position.t4087(parse);         if (this.round   ) this.round   .t4087(parse);         if (this.start   ) this.start   .t4087(parse);         if (this.sweep   ) this.sweep   .t4087(parse);         if (this.inner   ) this.inner   .t4087(parse);     } }


class e1980 extends w1974 {     round = null;     bias  = null;        constructor(nodeId, options)     {         super(w1228, nodeId, options);     }        reset()     {         super.reset();          this.round = null;         this.bias  = null;     }        copy()     {         const copy = new e1980(this.nodeId, this.options);          copy.n3359(this);          if (this.round) copy.round = this.round.copy();         if (this.bias ) copy.bias  = this.bias .copy();          return copy;     }        f4242(p2992)     {         switch (p2992)         {             case 'x':      return this.input ? this.value.x      : this.x;             case 'y':      return this.input ? this.value.y      : this.y;             case 'width':  return this.input ? this.value.width  : this.width;             case 'height': return this.input ? this.value.height : this.height;             case 'round':  return this.input ? this.value.round  : this.round;             case 'bias':   return this.input ? this.value.bias   : this.bias;         }          return super.f4242(p2992);     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalValue      (this.input, parse);         let   round = await evalNumberValue(this.round, parse);         let   bias  = await evalNumberValue(this.bias,  parse);                  let [x, y, width, height] = await this.evalBaseParams(parse);           if (input)         {             this.value        = input.x3633();             this.value.nodeId = this.nodeId;             this.value.r3626(input);              if (x     )  this.value.x      = x;       else  x      = this.value.x;                   if (y     )  this.value.y      = y;       else  y      = this.value.y;                   if (width )  this.value.width  = width;   else  width  = this.value.width;               if (height)  this.value.height = height;  else  height = this.value.height;              if (round )  this.value.round  = round;   else  round  = this.value.round;               if (bias  )  this.value.bias   = bias;    else  bias   = this.value.bias;           }         else         {             this.value = new f2034(                 this.nodeId,                  x,                  y,                  width,                  height,                  round,                 bias);         }                  this.n4101(parse,          [             ['x',      x     ],             ['y',      y     ],             ['width',  width ],             ['height', height],             ['round',  round ],             ['bias',   bias  ]         ]);           await this.t2896(parse);           await this.v4100(parse);           if (!this.x     ) this.x      = this.value.x     .copy();         if (!this.y     ) this.y      = this.value.y     .copy();         if (!this.width ) this.width  = this.value.width .copy();         if (!this.height) this.height = this.value.height.copy();         if (!this.round ) this.round  = this.value.round .copy();         if (!this.bias  ) this.bias   = this.value.bias  .copy();           this.validate();          return this;     }        async v4100(parse, options = {})     {         if (!this.options.enabled)             return;                        this.value.objects = [];           if (   super.i2897()                && this.value.x     .isValid()                 && this.value.y     .isValid()                 && this.value.width .isValid()             && this.value.height.isValid()             && this.value.round .isValid()             && this.value.bias  .isValid())         {             let   x = this.value.x     .value;             let   y = this.value.y     .value;             let   w = this.value.width .value;             let   h = this.value.height.value;             const r = Math.max(0, this.value.round.value);             let   b = this.value.bias  .value;               [x, y, w, h, , ] = validateObjectRect(x, y, w, h);               if (   w != 0                  && h != 0)             {                 const trapeze = new m1851(                     this.nodeId,                      this.nodeId,                      this.nodeName,                      x, y, w, h, r, b);                  trapeze.r4098(x, y);                 trapeze.x3730(x, y, w, h);                  this.value.objects.push(trapeze);             }         }           await super.v4100(parse);     }        isValid()     {         return super.isValid()             && this.round && this.round.isValid()             && this.bias  && this.bias .isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.round) this.round.r4088(parse);         if (this.bias ) this.bias .r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.round) this.round.o4089(parse, from, force);         if (this.bias ) this.bias .o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.round) this.round.t4087(parse);         if (this.bias ) this.bias .t4087(parse);     } }


class h1968 extends w1974 {     position = null;     round    = null;     corners  = null;        constructor(nodeId, options)     {         super(a1237, nodeId, options);     }        reset()     {         super.reset();          this.position = null;         this.round    = null;         this.corners  = null;     }        copy()     {         const copy = new h1968(this.nodeId, this.options);          copy.n3359(this);          if (this.position) copy.position = this.position.copy();         if (this.round   ) copy.round    = this.round   .copy();         if (this.corners ) copy.corners  = this.corners .copy();          return copy;     }        f4242(p2992)     {         switch (p2992)         {             case 'position': return this.input ? this.value.position : this.position;             case 'x':        return this.input ? this.value.x        : this.x;             case 'y':        return this.input ? this.value.y        : this.y;             case 'width':    return this.input ? this.value.width    : this.width;             case 'height':   return this.input ? this.value.height   : this.height;             case 'round':    return this.input ? this.value.round    : this.round;             case 'corners':  return this.input ? this.value.corners  : this.corners;         }          return super.f4242(p2992);     }        async eval(parse)     {         if (this.isCached())             return this;                       let [x, y, width, height] = await this.evalBaseParams(parse);          let input   = await evalPolygonValue(this.input,    parse);         let pos     = await evalNumberValue (this.position, parse);         let round   = await evalNumberValue (this.round,    parse);         let corners = await evalNumberValue (this.corners,  parse);           if (input)         {             this.value        = input.x3633();             this.value.nodeId = this.nodeId;             this.value.r3626(input);              if (pos    )  this.value.position = pos;      else  pos     = this.value.position;             if (x      )  this.value.x        = x;        else  x       = this.value.x;                   if (y      )  this.value.y        = y;        else  y       = this.value.y;                   if (width  )  this.value.width    = width;    else  width   = this.value.width;               if (height )  this.value.height   = height;   else  height  = this.value.height;              if (round  )  this.value.round    = round;    else  round   = this.value.round;               if (corners)  this.value.corners  = corners;  else  corners = this.value.corners;           }         else         {             this.value = new t2024(                 this.nodeId,                 pos,                 x,                  y,                  width,                  height,                 round,                 corners);         }           this.n4101(parse,          [             ['position', pos    ],             ['x',        x      ],             ['y',        y      ],             ['width',    width  ],             ['height',   height ],             ['round',    round  ],             ['corners',  corners]         ]);           await this.t2896(parse);           await this.v4100(parse);           if (!this.position) this.position = this.value.position.copy();         if (!this.x       ) this.x        = this.value.x       .copy();         if (!this.y       ) this.y        = this.value.y       .copy();         if (!this.width   ) this.width    = this.value.width   .copy();         if (!this.height  ) this.height   = this.value.height  .copy();         if (!this.round   ) this.round    = this.value.round   .copy();         if (!this.corners ) this.corners  = this.value.corners .copy();           this.validate();          return this;     }        async v4100(parse, options = {})     {         if (!this.options.enabled)             return;                                   this.value.objects = [];           if (   super.i2897()                && this.value.x      .isValid()             && this.value.y      .isValid()             && this.value.width  .isValid()             && this.value.height .isValid()             && this.value.round  .isValid()             && this.value.corners.isValid())         {             const vpos = this.value.position;             const vx   = this.value.x;             const vy   = this.value.y;             const vw   = this.value.width;             const vh   = this.value.height;              const _x = vpos.value <= 0 ? vx : new d2022(vx.value - vw.value, Math.max(vx.decimals, vw.decimals));             const _y = vpos.value <= 0 ? vy : new d2022(vy.value - vh.value, Math.max(vy.decimals, vh.decimals));             const _w = vpos.value <= 0 ? vw : new d2022(vw.value*2, Math.max(vx.decimals, vw.decimals));             const _h = vpos.value <= 0 ? vh : new d2022(vh.value*2, Math.max(vy.decimals, vh.decimals));                          let   x = _x.value;             let   y = _y.value;             let   w = _w.value;             let   h = _h.value;             const r = Math.max(0, this.value.round.value);             const c = Math.max(3, Math.floor(this.value.corners.value));               [x, y, w, h, , ] = validateObjectRect(x, y, w, h);               if (   w != 0                  && h != 0)             {                 const poly = new m1845(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     x, y, w, h, r, c);                  poly.r4098(x, y);                 poly.x3730(x, y, w, h);                  this.value.objects.push(poly);             }         }                   await super.v4100(parse);     }                                                                                              isValid()     {         return super.isValid()             && this.position && this.position.isValid()             && this.round    && this.round   .isValid()             && this.corners  && this.corners .isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.position) this.position.r4088(parse);         if (this.round   ) this.round   .r4088(parse);         if (this.corners ) this.corners .r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.position) this.position.o4089(parse, from, force);         if (this.round   ) this.round   .o4089(parse, from, force);         if (this.corners ) this.corners .o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.position) this.position.t4087(parse);         if (this.round   ) this.round   .t4087(parse);         if (this.corners ) this.corners .t4087(parse);     } }


 class q1978 extends w1974 {     position = null;     round    = null;     points   = null;     convex   = null;        constructor(nodeId, options)     {         super(f1240, nodeId, options);     }        reset()     {         super.reset();          this.position = null;         this.round    = null;         this.points   = null;         this.convex   = null;     }        copy()     {         const copy = new q1978(this.nodeId, this.options);          copy.n3359(this);          if (this.position) copy.position = this.position.copy();         if (this.round   ) copy.round    = this.round   .copy();         if (this.points  ) copy.points   = this.points  .copy();         if (this.convex  ) copy.convex   = this.convex  .copy();          return copy;     }        f4242(p2992)     {         switch (p2992)         {             case 'position': return this.input ? this.value.position : this.position;             case 'x':        return this.input ? this.value.x        : this.x;             case 'y':        return this.input ? this.value.y        : this.y;             case 'width':    return this.input ? this.value.width    : this.width;             case 'height':   return this.input ? this.value.height   : this.height;             case 'round':    return this.input ? this.value.round    : this.round;             case 'points':   return this.input ? this.value.points   : this.points;             case 'convex':   return this.input ? this.value.convex   : this.convex;         }          return super.f4242(p2992);     }        async eval(parse)     {         if (this.isCached())             return this;                       let [x, y, width, height] = await this.evalBaseParams(parse);          let input  = await evalValue      (this.input,    parse);         let pos    = await evalNumberValue(this.position, parse);         let round  = await evalNumberValue(this.round,    parse);         let points = await evalNumberValue(this.points,   parse);         let convex = await evalNumberValue(this.convex,   parse);           if (input)         {             this.value        = input.x3633();             this.value.nodeId = this.nodeId;             this.value.r3626(input);              if (pos   )  this.value.position = pos;     else  pos    = this.value.position;             if (x     )  this.value.x        = x;       else  x      = this.value.x;                   if (y     )  this.value.y        = y;       else  y      = this.value.y;                   if (width )  this.value.width    = width;   else  width  = this.value.width;               if (height)  this.value.height   = height;  else  height = this.value.height;              if (round )  this.value.round    = round;   else  round  = this.value.round;               if (points)  this.value.points   = points;  else  points = this.value.points;               if (convex)  this.value.convex   = convex;  else  convex = this.value.convex;          }         else         {             this.value = new n2030(                 this.nodeId,                 pos,                 x,                  y,                  width,                  height,                 round,                 points,                 convex);         }           this.n4101(parse,          [             ['position', pos   ],             ['x',        x     ],             ['y',        y     ],             ['width',    width ],             ['height',   height],             ['round',    round ],             ['points',   points],             ['convex',   convex]         ]);           await this.t2896(parse);           await this.v4100(parse);           if (!this.position) this.position = this.value.position.copy();         if (!this.x       ) this.x        = this.value.x       .copy();         if (!this.y       ) this.y        = this.value.y       .copy();         if (!this.width   ) this.width    = this.value.width   .copy();         if (!this.height  ) this.height   = this.value.height  .copy();         if (!this.round   ) this.round    = this.value.round   .copy();         if (!this.points  ) this.points   = this.value.points  .copy();         if (!this.convex  ) this.convex   = this.value.convex  .copy();            this.validate();          return this;    }       async v4100(parse, options = {})    {         if (!this.options.enabled)            return;                                 this.value.objects = [];           if (   super.i2897()                && this.value.x     .isValid()             && this.value.y     .isValid()             && this.value.width .isValid()             && this.value.height.isValid()              && this.value.round .isValid()             && this.value.points.isValid()             && this.value.convex.isValid())         {             const vpos = this.value.position;             const vx   = this.value.x;             const vy   = this.value.y;             const vw   = this.value.width;             const vh   = this.value.height;              const _x = vpos.value <= 0 ? vx : new d2022(vx.value - vw.value, Math.max(vx.decimals, vw.decimals));             const _y = vpos.value <= 0 ? vy : new d2022(vy.value - vh.value, Math.max(vy.decimals, vh.decimals));             const _w = vpos.value <= 0 ? vw : new d2022(vw.value*2, Math.max(vx.decimals, vw.decimals));             const _h = vpos.value <= 0 ? vh : new d2022(vh.value*2, Math.max(vy.decimals, vh.decimals));                          let   x = _x.value;             let   y = _y.value;             let   w = _w.value;             let   h = _h.value;             const r = Math.max(0, this.value.round.value);             const p = Math.max(3, Math.floor(this.value.points.value));             const c = this.value.convex.value;               if (   w != 0                 && h != 0)             {                 const star = new s1849(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     x, y, w, h, r, p, c);                  star.r4098(x, y);                 star.x3730(x, y, w, h);                  this.value.objects.push(star);             }         }                  await super.v4100(parse);     }                                                                                                    isValid()     {         return super.isValid()             && this.position && this.position.isValid()             && this.round    && this.round   .isValid()             && this.points   && this.points  .isValid()             && this.convex   && this.convex  .isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.position) this.position.r4088(parse);         if (this.round   ) this.round   .r4088(parse);         if (this.points  ) this.points  .r4088(parse);         if (this.convex  ) this.convex  .r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.position) this.position.o4089(parse, from, force);         if (this.round   ) this.round   .o4089(parse, from, force);         if (this.points  ) this.points  .o4089(parse, from, force);         if (this.convex  ) this.convex  .o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.position) this.position.t4087(parse);         if (this.round   ) this.round   .t4087(parse);         if (this.points  ) this.points  .t4087(parse);         if (this.convex  ) this.convex  .t4087(parse);     } }


class l1979 extends w1974 {     text          = null;     x             = null;     y             = null;     width         = null;     height        = null;     font          = null;     size          = null;     style         = null;     alignX        = null;     alignY        = null;     lineHeight    = null;     letterSpacing = null;                constructor(nodeId, options)     {         super(j1243, nodeId, options);     }            reset()     {         super.reset();                  this.text          = null;         this.x             = null;         this.y             = null;         this.width         = null;         this.height        = null;         this.font          = null;         this.size          = null;         this.style         = null;         this.alignX        = null;         this.alignY        = null;         this.lineHeight    = null;         this.letterSpacing = null;     }        copy()     {         const copy = new l1979(this.nodeId, this.options);          copy.n3359(this);          if (this.text         ) copy.text          = this.text         .copy();         if (this.x            ) copy.x             = this.x            .copy();         if (this.y            ) copy.y             = this.y            .copy();         if (this.width        ) copy.width         = this.width        .copy();         if (this.height       ) copy.height        = this.height       .copy();         if (this.font         ) copy.font          = this.font         .copy();         if (this.style        ) copy.style         = this.style        .copy();         if (this.size         ) copy.size          = this.size         .copy();         if (this.alignX       ) copy.alignX        = this.alignX       .copy();         if (this.alignY       ) copy.alignY        = this.alignY       .copy();         if (this.lineHeight   ) copy.lineHeight    = this.lineHeight   .copy();         if (this.letterSpacing) copy.letterSpacing = this.letterSpacing.copy();          return copy;     }        f4242(p2992)     {         switch (p2992)         {             case 'text':          return this.input ? this.value.text          : this.text;             case 'x':             return this.input ? this.value.x             : this.x;             case 'y':             return this.input ? this.value.y             : this.y;             case 'width':         return this.input ? this.value.width         : this.width;             case 'height':        return this.input ? this.value.height        : this.height;             case 'font':          return this.input ? this.value.font          : this.font;             case 'style':         return this.input ? this.value.style         : this.style;             case 'size':          return this.input ? this.value.size          : this.size;             case 'alignX':        return this.input ? this.value.alignX        : this.alignX;             case 'alignY':        return this.input ? this.value.alignY        : this.alignY;             case 'lineHeight':    return this.input ? this.value.lineHeight    : this.lineHeight;             case 'letterSpacing': return this.input ? this.value.letterSpacing : this.letterSpacing;         }          return super.f4242(p2992);     }        async eval(parse)     {         if (this.isCached())             return this;           const input         = await evalTextShapeValue(this.input,         parse);         let   text          = await evalNumberValue   (this.text,          parse);         let   x             = await evalNumberValue   (this.x,             parse);         let   y             = await evalNumberValue   (this.y,             parse);         let   width         = await evalNumberValue   (this.width,         parse);         let   height        = await evalNumberValue   (this.height,        parse);         let   font          = await evalNumberValue   (this.font,          parse);         let   style         = await evalNumberValue   (this.style,         parse);         let   size          = await evalNumberValue   (this.size,          parse);         let   alignX        = await evalNumberValue   (this.alignX,        parse);         let   alignY        = await evalNumberValue   (this.alignY,        parse);         let   lineHeight    = await evalNumberValue   (this.lineHeight,    parse);         let   letterSpacing = await evalNumberValue   (this.letterSpacing, parse);           if (text          && !text         .isValid()) text          = new j2033();         if (x             && !x            .isValid()) x             = d2022.NaN.copy();         if (y             && !y            .isValid()) y             = d2022.NaN.copy();         if (width         && !width        .isValid()) width         = d2022.NaN.copy();         if (height        && !height       .isValid()) height        = d2022.NaN.copy();         if (font          && !font         .isValid()) font          = d2022.NaN.copy();         if (style         && !style        .isValid()) style         = d2022.NaN.copy();         if (size          && !size         .isValid()) size          = d2022.NaN.copy();         if (alignX        && !alignX       .isValid()) alignX        = d2022.NaN.copy();         if (alignY        && !alignY       .isValid()) alignY        = d2022.NaN.copy();         if (lineHeight    && !lineHeight   .isValid()) lineHeight    = d2022.NaN.copy();         if (letterSpacing && !letterSpacing.isValid()) letterSpacing = d2022.NaN.copy();                    if (text          && text         .type !=   t1143) text          = new j2033();         if (x             && x            .type != t1091) x             = d2022.NaN.copy();         if (y             && y            .type != t1091) y             = d2022.NaN.copy();         if (width         && width        .type != t1091) width         = d2022.NaN.copy();         if (height        && height       .type != t1091) height        = d2022.NaN.copy();         if (font          && font         .type != t1091) font          = d2022.NaN.copy();         if (style         && style        .type != t1091) style         = d2022.NaN.copy();         if (size          && size         .type != t1091) size          = d2022.NaN.copy();         if (alignX        && alignX       .type != t1091) alignX        = d2022.NaN.copy();         if (alignY        && alignY       .type != t1091) alignY        = d2022.NaN.copy();         if (lineHeight    && lineHeight   .type != t1091) lineHeight    = d2022.NaN.copy();         if (letterSpacing && letterSpacing.type != t1091) letterSpacing = d2022.NaN.copy();                   if (input)         {             this.value        = input.x3633();             this.value.nodeId = this.nodeId;             this.value.r3626(input);                          if (text         )  this.value.text          = text;           else  text          = this.value.text;             if (x            )  this.value.x             = x;              else  x             = this.value.x;             if (y            )  this.value.y             = y;              else  y             = this.value.y;             if (width        )  this.value.width         = width;          else  width         = this.value.width;             if (height       )  this.value.height        = height;         else  height        = this.value.height;             if (font         )  this.value.font          = font;           else  font          = this.value.font;             if (style        )  this.value.style         = style;          else  style         = this.value.style;             if (size         )  this.value.size          = size;           else  size          = this.value.size;             if (alignX       )  this.value.alignX        = alignX;         else  alignX        = this.value.alignX;             if (alignY       )  this.value.alignY        = alignY;         else  alignY        = this.value.alignY;             if (lineHeight   )  this.value.lineHeight    = lineHeight;     else  lineHeight    = this.value.lineHeight;             if (letterSpacing)  this.value.letterSpacing = letterSpacing;  else  letterSpacing = this.value.letterSpacing;          }         else         {             this.value = new q2032(                 this.nodeId,                  text,                  x,                  y,                  width,                  height,                  font,                  style,                 size,                 alignX,                 alignY,                 lineHeight,                 letterSpacing);         }                  this.n4101(parse,          [             ['text',          text         ],             ['x',             x            ],             ['y',             y            ],             ['width',         width        ],             ['height',        height       ],             ['font',          font         ],             ['style',         style        ],             ['size',          size         ],             ['alignX',        alignX       ],             ['alignY',        alignY       ],             ['lineHeight',    lineHeight   ],             ['letterSpacing', letterSpacing]         ]);           await this.t2896(parse);           await this.v4100(parse);           if (!this.text         ) this.text          = this.value.text         .copy();         if (!this.x            ) this.x             = this.value.x            .copy();         if (!this.y            ) this.y             = this.value.y            .copy();         if (!this.width        ) this.width         = this.value.width        .copy();         if (!this.height       ) this.height        = this.value.height       .copy();         if (!this.font         ) this.font          = this.value.font         .copy();         if (!this.style        ) this.style         = this.value.style        .copy();         if (!this.size         ) this.size          = this.value.size         .copy();         if (!this.alignX       ) this.alignX        = this.value.alignX       .copy();         if (!this.alignY       ) this.alignY        = this.value.alignY       .copy();         if (!this.lineHeight   ) this.lineHeight    = this.value.lineHeight   .copy();         if (!this.letterSpacing) this.letterSpacing = this.value.letterSpacing.copy();                   this.validate();          return this;     }        async v4100(parse, options = {})     {         if (!this.options.enabled)             return;                   this.value.objects = [];           if (   super.i2897()                && this.value.text         .isValid()             && this.value.x            .isValid()             && this.value.y            .isValid()             && this.value.width        .isValid()             && this.value.height       .isValid()             && this.value.font         .isValid()             && this.value.style        .isValid()             && this.value.size         .isValid()             && this.value.alignX       .isValid()             && this.value.alignY       .isValid()             && this.value.lineHeight   .isValid()             && this.value.letterSpacing.isValid())         {             let x = this.value.x     .value;             let y = this.value.y     .value;             let w = this.value.width .value;             let h = this.value.height.value;              const fontName   = w4039[this.value.font.value];             const fontStyles = getFontStyles(fontName);              const text = new e1850(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 this.value.text.value,                 x, y, w, h,                 fontName,                 this.value.size         .value,                 fontStyles[Math.min(this.value.style.value, fontStyles.length-1)],                 this.value.alignX       .value,                 this.value.alignY       .value,                 this.value.lineHeight   .value,                 this.value.letterSpacing.value);                               text.r4098(x, y);                                                                                                                                                                                                text.x3730(x, y, w, h);                  this.value.objects.push(text);                      }                   await super.v4100(parse);     }        isValid()     {         return super.isValid()             && this.text          && this.text         .isValid()             && this.x             && this.x            .isValid()             && this.y             && this.y            .isValid()             && this.width         && this.width        .isValid()             && this.height        && this.height       .isValid()             && this.font          && this.font         .isValid()             && this.style         && this.style        .isValid()             && this.size          && this.size         .isValid()             && this.alignX        && this.alignX       .isValid()             && this.alignY        && this.alignY       .isValid()             && this.lineHeight    && this.lineHeight   .isValid()             && this.letterSpacing && this.letterSpacing.isValid();     }        r4088(parse)     {         super.r4088(parse);                  if (this.text         ) this.text         .r4088(parse);         if (this.x            ) this.x            .r4088(parse);         if (this.y            ) this.y            .r4088(parse);         if (this.width        ) this.width        .r4088(parse);         if (this.height       ) this.height       .r4088(parse);         if (this.font         ) this.font         .r4088(parse);         if (this.style        ) this.style        .r4088(parse);         if (this.size         ) this.size         .r4088(parse);         if (this.alignX       ) this.alignX       .r4088(parse);         if (this.alignY       ) this.alignY       .r4088(parse);         if (this.lineHeight   ) this.lineHeight   .r4088(parse);         if (this.letterSpacing) this.letterSpacing.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);                  if (this.text         ) this.text         .o4089(parse, from, force);         if (this.x            ) this.x            .o4089(parse, from, force);         if (this.y            ) this.y            .o4089(parse, from, force);         if (this.width        ) this.width        .o4089(parse, from, force);         if (this.height       ) this.height       .o4089(parse, from, force);         if (this.font         ) this.font         .o4089(parse, from, force);         if (this.style        ) this.style        .o4089(parse, from, force);         if (this.size         ) this.size         .o4089(parse, from, force);         if (this.alignX       ) this.alignX       .o4089(parse, from, force);         if (this.alignY       ) this.alignY       .o4089(parse, from, force);         if (this.lineHeight   ) this.lineHeight   .o4089(parse, from, force);         if (this.letterSpacing) this.letterSpacing.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);                  if (this.text         ) this.text         .t4087(parse);         if (this.x            ) this.x            .t4087(parse);         if (this.y            ) this.y            .t4087(parse);         if (this.width        ) this.width        .t4087(parse);         if (this.height       ) this.height       .t4087(parse);         if (this.font         ) this.font         .t4087(parse);         if (this.style        ) this.style        .t4087(parse);         if (this.size         ) this.size         .t4087(parse);         if (this.alignX       ) this.alignX       .t4087(parse);         if (this.alignY       ) this.alignY       .t4087(parse);         if (this.lineHeight   ) this.lineHeight   .t4087(parse);         if (this.letterSpacing) this.letterSpacing.t4087(parse);     } }


class k1964 extends i2044 {     x = null;     y = null;        constructor(nodeId, options)     {         super(g1246, nodeId, options);     }        reset()     {         super.reset();          this.x = null;         this.y = null;     }        copy()     {         const copy = new k1964(this.nodeId, this.options);          copy.n3359(this);          if (this.value) copy.value = this.value.copy();         if (this.x    ) copy.x     = this.x    .copy();         if (this.y    ) copy.y     = this.y    .copy();          return copy;     }        f4242(p2992)     {         switch (p2992)         {             case 'x': return this.input ? this.value.x : this.x;             case 'y': return this.input ? this.value.y : this.y;         }          return null;     }        async eval(parse)     {         if (this.isCached())             return this;                   let input = await evalPointValue (this.input, parse);         let x     = await evalNumberValue(this.x,     parse);         let y     = await evalNumberValue(this.y,     parse);           if (   input             && input.isValid())         {             const m3812 = input;              if (input.type == c1252)             {                 input = new h2023(input.nodeId, input.x, input.y);                 input.r3626(m3812);             }                          this.value        = input;             this.value.nodeId = this.nodeId;             this.value.r3626(input);               if (   this.value.objects                 && this.value.objects.length > 0)             {                 this.value.x = new d2022(this.value.objects[0].x);                 this.value.y = new d2022(this.value.objects[0].y);             }                          if (x)  this.value.x = x;  else  x = this.value.x;             if (y)  this.value.y = y;  else  y = this.value.y;         }         else if (x                && y)         {             this.value = new h2023(                 this.nodeId,                  x,                  y);         }         else             this.value = h2023.NaN.copy();           this.value.x3736 = this.x3736;           await this.v4100(parse);           this.n4101(parse,          [             ['x', x],             ['y', y]         ]);               this.validate();          return this;     }        async v4100(parse, options = {})     {         if (!this.options.enabled)             return;                                   if (!this.value.objects)             this.value.objects = [];           if (   this.value.x             && this.value.y                && this.value.x.isValid()             && this.value.y.isValid())         {             const x = this.value.x.value;             const y = this.value.y.value;              const point = new a1844(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 x,                 y,                 this.smooth ? this.smooth.value/100 : 1);              point.r4098(x, y);              this.value.objects = [point];         }           await super.v4100(parse);     }        isValid()     {         return super.isValid()             && this.x && this.x.isValid()             && this.y && this.y.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.x) this.x.r4088(parse);         if (this.y) this.y.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.x) this.x.o4089(parse, from, force);         if (this.y) this.y.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.x) this.x.t4087(parse);         if (this.y) this.y.t4087(parse);     } }


class x1965 extends i2044 {     smooth = null;        constructor(nodeId, options)     {         super(k1248, nodeId, options);     }        reset()     {         super.reset();          this.smooth = null;     }        copy()     {         const copy = new x1965(this.nodeId, this.options);          copy.n3359(this);          if (this.value ) copy.value  = this.value .copy();         if (this.smooth) copy.smooth = this.smooth.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                   const input  = await evalPointValue (this.input,  parse);         const smooth = await evalNumberValue(this.smooth, parse);                  if (input)         {             this.value        = input;             this.value.nodeId = this.nodeId;             this.value.r3626(input);              this.value.smooth = smooth;               if (   this.value.objects                 && this.value.objects.length > 0)             {                 this.value.x = new d2022(this.value.objects[0].x);                 this.value.y = new d2022(this.value.objects[0].y);             }         }         else             this.value = h2023.NaN.copy();           await this.v4100(parse);           this.n4101(parse,          [             ['smooth', smooth]         ]);           this.validate();          return this;     }        async v4100(parse, options = {})     {         if (!this.options.enabled)             return;                                   this.value.objects = [];           if (   this.value.x.isValid()             && this.value.y.isValid())         {             const x      = this.value.x.value;             const y      = this.value.y.value;             const smooth = this.value.smooth ? this.value.smooth.value/100 : 1;              const point = new a1844(                 this.nodeId,                  this.nodeId,                  this.nodeName,                  x,                  y,                  smooth);              point.r4098(x, y);              this.value.objects = [point];         }           await super.v4100(parse);     }        x3633()     {         return this.value.copy();                                                    }        isValid()     {         return super.isValid()             && this.smooth && this.smooth.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.smooth) this.smooth.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.smooth) this.smooth.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.smooth) this.smooth.t4087(parse);     } }


class u1984 extends w1974 {     points  = null;     closed  = null;     degree  = null;     winding = null;     round   = null;        constructor(nodeId, options)     {         super(v1250, nodeId, options);     }        reset()     {         super.reset();          this.points  = null;         this.closed  = null;         this.degree  = null;         this.winding = null;         this.round   = null;     }        copy()     {         const copy = new u1984(this.nodeId, this.options);          copy.n3359(this);          if (this.points ) copy.points  = this.points .copy();         if (this.closed ) copy.closed  = this.closed .copy();         if (this.degree ) copy.degree  = this.degree .copy();         if (this.winding) copy.winding = this.winding.copy();         if (this.round  ) copy.round   = this.round  .copy();          return copy;     }        f4242(p2992)     {         switch (p2992)         {             case 'points':  return this.input ? this.value.points  : this.points;             case 'closed':  return this.input ? this.value.closed  : this.closed;             case 'degree':  return this.input ? this.value.degree  : this.degree;             case 'winding': return this.input ? this.value.winding : this.winding;             case 'round':   return this.input ? this.value.round   : this.round;         }          return super.f4242(p2992);     }        async eval(parse)     {         if (this.isCached())             return this;           const input   = await evalVectorPathValue(this.input,   parse);         let   points  = await evalNumberValue    (this.points,  parse);         let   closed  = await evalNumberValue    (this.closed,  parse);         let   degree  = await evalNumberValue    (this.degree,  parse);         let   winding = await evalNumberValue    (this.winding, parse);         let   round   = await evalNumberValue    (this.round,   parse);           await this.evalBaseParams(parse);           if (input)         {                                                    if (   input.points                 && input.points.items                 && input.points.objects)             {                 l952(                      input.points.items.length == input.points.objects.length,                     'Vector path points input item count must match object count');                  for (let i = 0; i < input.points.items.length; i++)                 {                     const item = input.points.items  [i].copy();                     const a111  = input.points.objects[i].copy();                      if (item && a111)                     {                         item.x = new d2022(a111.x);                         item.y = new d2022(a111.y);                     }                 }             }               this.value = new l2037(                 this.nodeId,                    points                  && points.items.length > 0                  ? points                 : input.points,                 closed  ?? input.closed,                 degree  ?? input.degree,                 winding ?? input.winding,                 round   ?? input.round);              this.value.r3626(input);                           if (points )  this.value.points   = points;   else  points  = this.value.points;                 if (closed )  this.value.closed   = closed;   else  closed  = this.value.closed;                 if (degree )  this.value.degree   = degree;   else  degree  = this.value.degree;               if (winding)  this.value.windingt = winding;  else  winding = this.value.winding;              if (round  )  this.value.round    = round;    else  round   = this.value.round;           }         else         {             this.value = new l2037(                 this.nodeId,                  points,                  closed,                  degree,                  winding,                  round);         }                   this.n4101(parse,          [                        ['closed',  closed ],             ['degree',  degree ],             ['winding', winding],             ['round',   round  ]         ]);           await this.t2896(parse);           await this.v4100(parse);           this.validate();          return this;     }        async v4100(parse, options = {})     {         if (!this.options.enabled)             return;                       const points = [];          if (this.value.points.objects)         {             const c4102 = this.value.points.objects.filter(o => o.type == g1246);              for (const pt of c4102)             {                 const p = h2023.create(this.nodeId, pt.x, pt.y);                                  if (pt.smooth != null)                     p.smooth = new d2022(pt.smooth);                  points.push(p);             }         }           this.value.objects = [];           if (   super.i2897()                && points.length >= 2             && this.value.closed .isValid()             && this.value.degree .isValid()             && this.value.winding.isValid()             && this.value.round  .isValid())         {             const path = new d1853(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 points,                 this.value.closed .value,                 this.value.degree .value,                 this.value.winding.value,                 this.value.round  .value);                               const bounds = getObjBounds([path]);              path.n3742(                 bounds.x + bounds.width /2,                             bounds.y + bounds.height/2                         );               let x = bounds.x;             let y = bounds.y;             let w = bounds.w;             let h = bounds.h;                          path.r4098(x, y);             path.x3730(x, y, w, h);               this.value.objects.push(path);         }           await super.v4100(parse);     }        isValid()     {         return super.isValid()             && this.points  && this.points .isValid()             && this.closed  && this.closed .isValid()             && this.degree  && this.degree .isValid()             && this.winding && this.winding.isValid()             && this.round   && this.round  .isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.points ) this.points .r4088(parse);         if (this.closed ) this.closed .r4088(parse);         if (this.degree ) this.degree .r4088(parse);         if (this.winding) this.winding.r4088(parse);         if (this.round  ) this.round  .r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.points ) this.points .o4089(parse, from, force);         if (this.closed ) this.closed .o4089(parse, from, force);         if (this.degree ) this.degree .o4089(parse, from, force);         if (this.winding) this.winding.o4089(parse, from, force);         if (this.round  ) this.round  .o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.points ) this.points .t4087(parse);         if (this.closed ) this.closed .t4087(parse);         if (this.degree ) this.degree .t4087(parse);         if (this.winding) this.winding.t4087(parse);         if (this.round  ) this.round  .t4087(parse);     } }


class e1986 extends i2044 {     x     = null;     y     = null;     join  = null;     cap   = null;     round = null;        constructor(nodeId, options)     {         super(z1253, nodeId, options);     }        reset()     {         super.reset();          this.x     = null;         this.y     = null;         this.join  = null;         this.cap   = null;         this.round = null;     }        copy()     {         const copy = new e1986(this.nodeId, this.options);          copy.n3359(this);          if (this.x    ) copy.x     = this.x    .copy();         if (this.y    ) copy.y     = this.y    .copy();         if (this.join ) copy.join  = this.join .copy();         if (this.cap  ) copy.cap   = this.cap  .copy();         if (this.round) copy.round = this.round.copy();          return copy;     }        f4242(p2992)     {         switch (p2992)         {             case 'x':     return this.input ? this.value.x     : this.x;             case 'y':     return this.input ? this.value.y     : this.y;             case 'join':  return this.input ? this.value.join  : this.join;             case 'cap':   return this.input ? this.value.cap   : this.cap;             case 'round': return this.input ? this.value.round : this.round;         }          return null;     }        async eval(parse)     {         if (this.isCached())             return this;                   let input = await evalVectorVertexValue(this.input, parse);         let x     = await evalNumberValue      (this.x,     parse);         let y     = await evalNumberValue      (this.y,     parse);         let join  = await evalNumberValue      (this.join,  parse);         let cap   = await evalNumberValue      (this.cap,   parse);         let round = await evalNumberValue      (this.round, parse);           if (input)         {             const m3812 = input;              if (input.type == t1245)             {                 input = new o2039(input.nodeId, input.x, input.y);                 input.r3626(m3812);             }                          this.value        = input.copy();             this.value.nodeId = this.nodeId;             this.value.r3626(input);                                                                                                                          this.value.x     = new d2022(this.value.objects[0].x    );             this.value.y     = new d2022(this.value.objects[0].y    );             this.value.join  = new d2022(this.value.objects[0].join );             this.value.cap   = new d2022(this.value.objects[0].cap  );             this.value.round = new d2022(this.value.objects[0].round);              if (x    )  this.value.x     = x;      else  x     = this.value.x;             if (y    )  this.value.y     = y;      else  y     = this.value.y;             if (join )  this.value.join  = join;   else  join  = this.value.join;             if (cap  )  this.value.cap   = cap;    else  cap   = this.value.cap;             if (round)  this.value.round = round;  else  round = this.value.round;         }         else         {             this.value = new o2039(                 this.nodeId,                  x,                  y,                  join,                  cap,                  round);         }                  this.value.x3736 = this.x3736;           await this.v4100(parse);           this.n4101(parse,          [             ['value', this.value]         ]);           this.validate();          return this;     }        async v4100(parse, options = {})     {         if (!this.options.enabled)             return;                                   this.value.objects = [];           if (   this.value.x                 && this.value.y                 && this.value.join              && this.value.cap               && this.value.round)         {             const x     = this.value.x    .value;             const y     = this.value.y    .value;                                                     const point = new a1844(this.nodeId, this.nodeId, this.nodeName, x, y);              point.r4098(x, y);              this.value.objects = [point];         }           await super.v4100(parse);     }        x3633()     {         const point = new o2039(             this.nodeId,             this.x    .x3633(),             this.y    .x3633(),             this.join .x3633(),             this.cap  .x3633(),             this.round.x3633());          point.r3626(this.value);          point.objects  = this.value.objects.map(o => o.copy());         point.x3736 = this.value.x3736;          return point;     }        isValid()     {         return super.isValid()             && this.x    .isValid()             && this.y    .isValid()             && this.join .isValid()             && this.cap  .isValid()             && this.round.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.x    ) this.x    .r4088(parse);         if (this.y    ) this.y    .r4088(parse);         if (this.join ) this.join .r4088(parse);         if (this.cap  ) this.cap  .r4088(parse);         if (this.round) this.round.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.x    ) this.x    .o4089(parse, from, force);         if (this.y    ) this.y    .o4089(parse, from, force);         if (this.join ) this.join .o4089(parse, from, force);         if (this.cap  ) this.cap  .o4089(parse, from, force);         if (this.round) this.round.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.x    ) this.x    .t4087(parse);         if (this.y    ) this.y    .t4087(parse);         if (this.join ) this.join .t4087(parse);         if (this.cap  ) this.cap  .t4087(parse);         if (this.round) this.round.t4087(parse);     } }


class q1981 extends u2045 {     e3665 = null;     h3666   = null;                    constructor(nodeId, options)     {         super(m1256, nodeId, options);     }        reset()     {         super.reset();                  this.e3665 = null;         this.h3666   = null;     }        copy()     {         const copy = new q1981(this.nodeId, this.options);          copy.n3359(this);          if (this.e3665) copy.e3665 = this.e3665.copy();         if (this.h3666  ) copy.h3666   = this.h3666  .copy();          return copy;     }        f4242(p2992)     {         switch (p2992)         {             case 'startTangent': return this.input ? this.value.e3665 : this.e3665;             case 'endTangent':   return this.input ? this.value.h3666   : this.h3666;         }          return null;     }        async eval(parse)     {         if (this.isCached())             return this;                   let e4083       = await evalVectorVertexValue(this.e4083,       parse);         let j4084       = await evalVectorVertexValue(this.j4084,       parse);         let e3665 = await evalNumberValue      (this.e3665, parse);         let   h3666 = await evalNumberValue      (this.  h3666, parse);          if (   e4083             && j4084             && e3665             && h3666)         {             if (e4083.type == t1245) e4083 = new o2039(e4083.nodeId, e4083.x, e4083.y);             if (j4084.type == t1245) j4084 = new o2039(j4084.nodeId, j4084.x, j4084.y);              if (e3665.type == c1252) e3665 = new h2023(e3665.nodeId, e3665.x, e3665.y);             if (  h3666.type == c1252)   h3666 = new h2023(  h3666.nodeId,   h3666.x,   h3666.y);               this.value = new c2035(                 this.nodeId,                 e4083,                 j4084,                 e3665,                 h3666);               this.value.x3736 = this.x3736;         }         else             this.value = c2035.NaN.copy();                           await this.v4100(parse);           this.n4101(parse,          [             ['value', this.value]         ]);           this.validate();          return this;     }        async v4100(parse, options = {})     {         if (   !this.options.enabled             || !this.value.start.isValid()             || !this.value.end  .isValid())             return;                                   this.value.objects = [];           if (   this.value.start.isValid()             && this.value.end  .isValid())         {             const path = new d1853(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 [ this.value.start,                   this.value.e3665.isValid() ? this.value.e3665 : this.value.start,                   this.value.h3666  .isValid() ? this.value.  h3666 : this.value.end,                   this.value.end ],                 0,                 2,                  0,                 0);                           const bounds = getObjBounds([path]);              let x = bounds.x;             let y = bounds.y;             let w = bounds.w;             let h = bounds.h;               path.r4098(x, y);             path.x3730(x, y, w, h);              this.value.objects.push(path);         }           await super.v4100(parse);     }                                                                               isValid()     {         return super.isValid()             && this.e3665.isValid()             && this.h3666  .isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.e3665) this.e3665.r4088(parse);         if (this.h3666  ) this.h3666  .r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.e3665) this.e3665.o4089(parse, from, force);         if (this.h3666  ) this.h3666  .o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.e3665) this.e3665.t4087(parse);         if (this.h3666  ) this.h3666  .t4087(parse);     } }


class e1985 extends w1974 {     inputs  = [];      loops   = null;     winding = null;        constructor(nodeId, options)     {         super(a1259, nodeId, options);     }        reset()     {         super.reset();          this.inputs  = [];          this.loops   = null;         this.winding = null;     }        copy()     {         const copy = new e1985(this.nodeId, this.options);          copy.n3359(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.winding) copy.winding = this.winding.copy();          return copy;     }        f4242(p2992)     {         switch (p2992)         {             case 'loops':   return this.input ? this.value.loops   : this.loops;             case 'winding': return this.input ? this.value.winding : this.winding;         }          return super.f4242(p2992);     }        isCached()     {         for (const input of this.inputs)             if (!input.isCached())                 return false;          return super.isCached()             && this.winding.isCached();     }        async eval(parse)     {         if (this.isCached())             return this;                   const winding = await evalNumberValue(this.winding, parse);           this.loops = new x2021();           const loop = new x2021();          for (let i = 0; i < this.inputs.length; i++)         {             const input = await evalVectorEdgeValue(this.inputs[i], parse);              if (g957(input.type))             {                 const _loop = new x2021();                  for (let j = 0; j < input.items.length; j++)                 {                     const item = input.items[j];                      if (item.type == d1255)                     {                         const edge = item.copy();                          if (_loop.items.length > 0)                         {                             const prevEdge = _loop.items.at(-1);                              if (   edge.end.x.equals(prevEdge.end.x)                                 && edge.end.y.equals(prevEdge.end.y))                             {                                 [edge.start,        edge.end       ] = [edge.end,        edge.start       ];                                 [edge.e3665, edge.h3666] = [edge.h3666, edge.e3665];                             }                         }                          _loop.items.push(edge);                     }                 }                  if (!isEmpty(_loop.items))                     loops.items.push(_loop);             }             else             {                 l952(                      input.type == d1255,                      'input.type must be VECTOR_EDGE_VALUE');                  const edge = input.copy();                  if (loop.items.length > 0)                 {                     const prevEdge = loop.items.at(-1);                      if (   edge.end.x.equals(prevEdge.end.x)                         && edge.end.y.equals(prevEdge.end.y))                     {                         [edge.start,        edge.end       ] = [edge.end,        edge.start       ];                         [edge.e3665, edge.h3666] = [edge.h3666, edge.e3665];                     }                 }                  loop.items.push(edge);             }         }           if (!isEmpty(loop.items))             this.loops.items.push(loop);           this.value = new c2038(             this.nodeId,             this.loops,              winding);           this.value.x3736 = this.x3736;           this.n4101(parse,         [             ['value',   this.value],             ['winding', winding   ]         ]);           await this.t2896(parse);           await this.v4100(parse);           this.validate();          return this;     }        async v4100(parse, options = {})     {         if (   !this.options.enabled             || !this.value.isValid())             return;                                   this.value.objects = [];                   if (   this.loops  .isValid()             && this.winding.isValid())         {             const regions = [];               for (let i = 0; i < this.loops.items.length; i++)             {                 const loop = this.loops.items[i];                   const points = [];                      for (let j = 0; j < loop.items.length; j++)                 {                     const edge = loop.items[j];                     const next = loop.items[j == loop.items.length-1 ? 0 : j+1];                      points.push(                            edge.start.x3736 == next.start.x3736                         || edge.start.x3736 == next.end  .x3736                         ? edge.end                           : edge.start);                 }                   regions.push(new d1853(                     this.nodeId,                     this.nodeId + '/' + i,                     this.nodeName,                     points,                     1,                     0,                      this.winding.value,                     0));             }                           let bounds = getObjBounds(regions);              let x = bounds.x;             let y = bounds.y;             let w = bounds.w;             let h = bounds.h;               for (const region of regions)             {                 region.r4098(x, y);                 region.x3730(x, y, w, h);                  this.value.objects.push(region);             }         }           await super.v4100(parse);     }                                                                          isValid()     {         if (!super.isValid())             return false;                      for (const input of this.inputs)             if (!input.isCached())                 return false;                  return this.winding.isValid()             && this.props  .isValid();     }        r4088(parse)     {         super.r4088(parse);          this.inputs.forEach(i => i.r4088(parse));          if (this.winding) this.winding.r4088(parse);         if (this.props  ) this.props  .r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          this.inputs.forEach(i => i.o4089(parse, from, force));          if (this.winding) this.winding.o4089(parse, from, force);         if (this.props  ) this.props  .o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          this.inputs.forEach(i => i.t4087(parse));          if (this.winding) this.winding.t4087(parse);         if (this.props  ) this.props  .t4087(parse);     } }


class n1983 extends w1974 {     inputs = [];        constructor(nodeId, options)     {         super(s1262, nodeId, options);     }        reset()     {         super.reset();          this.inputs = [];     }        copy()     {         const copy = new n1983(this.nodeId, this.options);          copy.n3359(this);          copy.inputs = this.inputs.map(i => i.copy());          return copy;     }        isCached()     {         for (const input of this.inputs)             if (!input.isCached())                 return false;          return super.isCached();     }        async eval(parse)     {         if (this.isCached())             return this;                   const regions = new x2021();          for (let i = 0; i < this.inputs.length; i++)         {             const input = await evalVectorRegionValue(this.inputs[i], parse);              l952(                  input.type == l1258,                  'input.type must be VECTOR_REGION_VALUE');              regions.items.push(input);         }           this.value = new t2036(             this.nodeId,             regions);           this.n4101(parse,          [             ['value', this.value]         ]);           await this.t2896(parse);                   await this.v4100(parse);           this.validate();          return this;     }        async v4100(parse, options = {})     {         if (   !this.options.enabled             || !this.value.isValid())             return;                                   this.value.objects = [];           if (!isEmpty(this.value.regions.items))         {             let points  = [];             let edges   = [];             let regions = [];               for (const region of this.value.regions.items)             {                 if (!isEmpty(region.objects))                     region.fills = region.objects[0].fills;                   if (region.loops)                 {                     for (const loop of region.loops.items)                     {                         for (const edge of loop.items)                         {                             o950(points, edge.start, p => p.x3736 == edge.start.x3736);                             o950(points, edge.end,   p => p.x3736 == edge.end  .x3736);                              o950(edges, edge, e => e.x3736 == edge.x3736);                         }                     }                      o950(regions, region, r => r.x3736 == region.x3736);                 }             }                           const network = new o1852(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 points,                 edges,                 regions);                           const bounds = getObjBounds([network]);              let x = bounds.x;             let y = bounds.y;             let w = bounds.w;             let h = bounds.h;               network.r4098(x, y);             network.x3730(x, y, w, h);              this.value.objects.push(network);         }           await super.v4100(parse);     }                                                                isValid()     {         return super.isValid()             && this.regions.isValid();     }        r4088(parse)     {         super.r4088(parse);          this.inputs.forEach(i => i.r4088(parse));     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          this.inputs.forEach(i => i.r4088(parse));     }        t4087(parse)     {         super.t4087(parse);          this.inputs.forEach(i => i.t4087(parse));     } }


class GArcPath extends w1974 {     position = null;     start    = null;     sweep    = null;      sweepInDegrees;        constructor(nodeId, options)     {         super(l1230, nodeId, options);     }        reset()     {         super.reset();          this.position = null;         this.start    = null;         this.sweep    = null;     }        copy()     {         const copy = new GArcPath(this.nodeId, this.options);          copy.n3359(this);          if (this.position) copy.position = this.position.copy();         if (this.start   ) copy.start    = this.start   .copy();         if (this.sweep   ) copy.sweep    = this.sweep   .copy();                  return copy;     }        f4242(p2992)     {         switch (p2992)         {             case 'position': return this.input ? this.value.position : this.position;             case 'x':        return this.input ? this.value.x        : this.x;             case 'y':        return this.input ? this.value.y        : this.y;             case 'width':    return this.input ? this.value.width    : this.width;             case 'height':   return this.input ? this.value.height   : this.height;             case 'start':    return this.input ? this.value.start    : this.start;             case 'sweep':    return this.input ? this.value.sweep    : this.sweep;         }          return super.f4242(p2992);     }        async eval(parse)     {         if (this.isCached())             return this;           let [x, y, width, height] = await this.evalBaseParams(parse);          let input = await evalArcPathValue(this.input,    parse);         let pos   = await evalNumberValue (this.position, parse);         let start = await evalNumberValue (this.start,    parse);         let sweep = await evalNumberValue (this.sweep,    parse);           if (input)         {             this.value        = input.copy();             this.value.nodeId = this.nodeId;             this.value.r3626(input);              if (pos   )  this.value.position = pos;     else  pos    = this.value.position;             if (x     )  this.value.x        = x;       else  x      = this.value.x;                   if (y     )  this.value.y        = y;       else  y      = this.value.y;                   if (width )  this.value.width    = width;   else  width  = this.value.width;               if (height)  this.value.height   = height;  else  height = this.value.height;              if (start )  this.value.start    = start;   else  start  = this.value.start;             if (sweep )  this.value.sweep    = sweep;   else  sweep  = this.value.sweep;         }         else         {             this.value = new ArcPathValue(                 this.nodeId,                 pos,                 x,                  y,                  width,                  height,                 start,                 sweep);         }           this.n4101(parse,          [             ['position', pos   ],             ['x',        x     ],             ['y',        y     ],             ['width',    width ],             ['height',   height],             ['start',    start ],             ['sweep',    sweep ]         ]);           await this.t2896(parse);           await this.v4100(parse);           this.validate();          return this;     }        async v4100(parse, options = {})     {        if (!this.options.enabled)            return;                                 this.value.objects = [];           if (   super.i2897()             && this.value.x     .isValid()             && this.value.y     .isValid()             && this.value.width .isValid()             && this.value.height.isValid())          {             const vpos = this.value.position;             const vx   = this.value.x;             const vy   = this.value.y;             const vw   = this.value.width;             const vh   = this.value.height;              const _x   = vpos.value <= 0 ? vx : new d2022(vx.value - vw.value, Math.max(vx.decimals, vw.decimals));             const _y   = vpos.value <= 0 ? vy : new d2022(vy.value - vh.value, Math.max(vy.decimals, vh.decimals));             const _w   = vpos.value <= 0 ? vw : new d2022(vw.value*2, Math.max(vx.decimals, vw.decimals));             const _h   = vpos.value <= 0 ? vh : new d2022(vh.value*2, Math.max(vy.decimals, vh.decimals));                          let   x    = _x.value;             let   y    = _y.value;             let   w    = _w.value;             let   h    = _h.value;             const st   = this.value.start.value/360 * Tau;             let   sw   = this.value.sweep.value/100 * Tau;               [x, , w, , , ] = validateObjectRect(x, y, w, h);                                                          if (this.sweepInDegrees) sw /= 3.6;                  const arc = new FigmaArcPath(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     vpos.value,                     x, y, w, h, st, sw);                   const bounds = getObjBounds([arc]);                          arc.n3742(x + w/2, y + h/2);                 arc.r4098(bounds.x, bounds.y);                 arc.x3730(bounds.x, bounds.y, bounds.w, bounds.h);                   this.value.objects.push(arc);                      }           await super.v4100(parse);     }                       isValid()     {         return super.isValid()             && this.position && this.position.isValid()             && this.start    && this.start   .isValid()             && this.sweep    && this.sweep   .isValid();     }        r4088(parse)     {         super.r4088(parse);           if (this.position) this.position.r4088(parse);         if (this.start   ) this.start   .r4088(parse);         if (this.sweep   ) this.sweep   .r4088(parse);     }                   o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.position) this.position.o4089(parse, from, force);         if (this.start   ) this.start   .o4089(parse, from, force);         if (this.sweep   ) this.sweep   .o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);           if (this.position) this.position.t4087(parse);         if (this.start   ) this.start   .t4087(parse);         if (this.sweep   ) this.sweep   .t4087(parse);     } }


class GWavePath extends w1974 {     shape     = null;     amplitude = null;     frequency = null;     offset    = null;     alignX    = null;     alignY    = null;      useWavelength;     offsetAbsolute;        constructor(nodeId, options)     {         super(o1233, nodeId, options);     }        reset()     {         super.reset();          this.shape     = null;         this.amplitude = null;         this.frequency = null;         this.offset    = null;         this.alignX    = null;         this.alignY    = null;     }        copy()     {         const copy = new GWavePath(this.nodeId, this.options);          copy.n3359(this);          if (this.shape    ) copy.shape     = this.shape    .copy();         if (this.amplitude) copy.amplitude = this.amplitude.copy();         if (this.frequency) copy.frequency = this.frequency.copy();         if (this.offset   ) copy.offset    = this.offset   .copy();         if (this.alignX   ) copy.alignX    = this.alignX   .copy();         if (this.alignY   ) copy.alignY    = this.alignY   .copy();                  return copy;     }        f4242(p2992)     {         switch (p2992)         {             case 'shape':     return this.input ? this.value.shape     : this.shape;             case 'x':         return this.input ? this.value.x         : this.x;             case 'y':         return this.input ? this.value.y         : this.y;             case 'width':     return this.input ? this.value.width     : this.width;             case 'amplitude': return this.input ? this.value.amplitude : this.amplitude;             case 'frequency': return this.input ? this.value.frequency : this.frequency;             case 'offset':    return this.input ? this.value.offset    : this.offset;             case 'alignX':    return this.input ? this.value.alignX    : this.alignX;             case 'alignY':    return this.input ? this.value.alignY    : this.alignY;         }          return super.f4242(p2992);     }        async eval(parse)     {         if (this.isCached())             return this;           let [x, y, width, ] = await this.evalBaseParams(parse);           let input     = await evalWavePathValue(this.input,     parse);         let shape     = await evalNumberValue  (this.shape,     parse);         let amplitude = await evalNumberValue  (this.amplitude, parse);         let frequency = await evalNumberValue  (this.frequency, parse);         let offset    = await evalNumberValue  (this.offset,    parse);         let alignX    = await evalNumberValue  (this.alignX,    parse);         let alignY    = await evalNumberValue  (this.alignY,    parse);           if (input)         {             this.value        = input.copy();             this.value.nodeId = this.nodeId;             this.value.r3626(input);              if (shape    )  this.value.shape     = shape;      else  shape      = this.value.shape;             if (x        )  this.value.x         = x;          else  x          = this.value.x;                   if (y        )  this.value.y         = y;          else  y          = this.value.y;                   if (width    )  this.value.width     = width;      else  width      = this.value.width;               if (amplitude)  this.value.amplitude = amplitude;  else  amplitude  = this.value.amplitude;             if (frequency)  this.value.frequency = frequency;  else  frequency  = this.value.frequency;             if (offset   )  this.value.offset    = offset;     else  offset     = this.value.offset;             if (alignX   )  this.value.alignX    = alignX;     else  alignX     = this.value.alignX;             if (alignY   )  this.value.alignY    = alignY;     else  alignY     = this.value.alignY;         }         else         {             this.value = new WavePathValue(                 this.nodeId,                 shape,                 x,                  y,                  width,                  amplitude,                 frequency,                 offset,                 alignX,                 alignY);         }           this.n4101(parse,          [             ['shape',     shape    ],             ['x',         x        ],             ['y',         y        ],             ['width',     width    ],             ['amplitude', amplitude],             ['frequency', frequency],             ['offset',    offset   ],             ['alignX',    alignX   ],             ['alignY',    alignY   ]         ]);           await this.t2896(parse);           await this.v4100(parse);           this.validate();          return this;     }        async v4100(parse, options = {})     {        if (!this.options.enabled)            return;                                 this.value.objects = [];           if (   super.i2897()             && this.value.shape    .isValid()             && this.value.x        .isValid()             && this.value.y        .isValid()             && this.value.width    .isValid()             && this.value.amplitude.isValid()             && this.value.frequency.isValid()             && this.value.offset   .isValid()             && this.value.alignX   .isValid()             && this.value.alignY   .isValid())         {             const sh     = this.value.shape    .value;             let   x      = this.value.x        .value;             let   y      = this.value.y        .value;             let   w      = this.value.width    .value;             const amp    = this.value.amplitude.value;             let   freq   = this.value.frequency.value;             const off    = this.value.offset   .value;             const alignX = this.value.alignX   .value;             const alignY = this.value.alignY   .value;               [x, y, w, , ] = validateObjectRect(x, y, w, 0);               const _freq = this.useWavelength ? w/nozero(freq) : freq;             const wl    = this.useWavelength ? freq : w/nozero(freq);              const so    = this.shape.value >= 3 ? 0.25 : 0;              const _off =                 this.offsetAbsolute                 ? off - so*wl                 : (off/100 - so) * wl;                                                          const wave = new FigmaWavePath(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     sh,                      x, y, w,                     amp,                     _freq,                     _off,                     alignX,                     alignY);                   const bounds = getObjBounds([wave]);                  wave.n3742(                     bounds.x + bounds.width /2,                                 bounds.y + bounds.height/2                             );                  wave.r4098(bounds.x, bounds.y);                 wave.x3730(bounds.x, bounds.y, bounds.w, bounds.h);                   this.value.objects.push(wave);                      }           await super.v4100(parse);     }                       isValid()     {         return super.isValid()             && this.shape     && this.shape    .isValid()             && this.amplitude && this.amplitude.isValid()             && this.frequency && this.frequency.isValid()             && this.offset    && this.offset   .isValid()             && this.alignX    && this.alignX   .isValid()             && this.alignY    && this.alignY   .isValid();     }        r4088(parse)     {         super.r4088(parse);           if (this.shape    ) this.shape    .r4088(parse);         if (this.amplitude) this.amplitude.r4088(parse);         if (this.frequency) this.frequency.r4088(parse);         if (this.offset   ) this.offset   .r4088(parse);         if (this.alignX   ) this.alignX   .r4088(parse);         if (this.alignY   ) this.alignY   .r4088(parse);     }                   o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.shape    ) this.shape    .o4089(parse, from, force);         if (this.amplitude) this.amplitude.o4089(parse, from, force);         if (this.frequency) this.frequency.o4089(parse, from, force);         if (this.offset   ) this.offset   .o4089(parse, from, force);         if (this.alignX   ) this.alignX   .o4089(parse, from, force);         if (this.alignY   ) this.alignY   .o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);           if (this.shape    ) this.shape    .t4087(parse);         if (this.amplitude) this.amplitude.t4087(parse);         if (this.frequency) this.frequency.t4087(parse);         if (this.offset   ) this.offset   .t4087(parse);         if (this.alignX   ) this.alignX   .t4087(parse);         if (this.alignY   ) this.alignY   .t4087(parse);     } }


class q1976 extends j1975 {     inputs = [];        constructor(nodeId, options)     {         super(i1265, nodeId, options);     }        reset()     {         super.reset();          this.inputs = [];     }        copy()     {         const copy = new q1976(this.nodeId, this.options);          copy.n3359(this);          copy.inputs = this.inputs.map(i => i.copy());          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new g2028(this.nodeId);          this.value.objects = [];                  const inputs = [];                  if (this.options.enabled)         {             for (let i = 0; i < this.inputs.length; i++)             {                 const input = await evalValue(this.inputs[i], parse);                  if (input)                             {                     inputs.push(input);                      if (   input.type == y1059                         || input.type == y1056)                     {                         for (const item of input.items)                         {                             if (!r1294.includes(item.type))                                 continue;                              this.value.items.push(item);                                                      }                     }                     else                     {                         this.value.items.push(input);                                              }                 }             }         }           this.n4101(parse,          [             ['value', this.value]         ]);                      await this.v4100(parse, {inputs: inputs});           this.validate();          return this;     }        async v4100(parse, options = {})     {         if (!this.options.enabled)             return;                       if (this.value.items)         {             const group = new a1848(                 this.nodeId,                 this.nodeId,                 this.nodeName);               for (let i = 0; i < options.inputs.length; i++)             {                 const input = options.inputs[i];                  if (input.objects)                 {                     for (let j = 0; j < input.objects.length; j++)                         this.s3737(group.children, input.objects[j], i, j);                 }             }                                 const bounds = getObjBounds(group.children);              const singlePoint =                    group.children.length  == 1                  && group.children[0].type == g1246;              for (const a111 of group.children)             {                                                        a111.n3742(a111.sp0.x, a111.sp0.y);                                                                     a111.resetSpace(bounds, singlePoint);             }               group.x      = bounds.x;             group.y      = bounds.y;             group.width  = bounds.width;             group.height = bounds.height;                           group.n3742();             group.resetSpace(bounds);              group.r4098(bounds.x, bounds.y);             group.x3730(bounds.x, bounds.y, bounds.width, bounds.height);               this.value.objects = [group];         }         else         {             this.value.objects = [];         }           await super.v4100(parse);     }        s3737(objects, _obj, inputIndex, objIndex)     {         const a111 = b3738(_obj);          a111.nodeId    = this.nodeId;         a111.objectId += h967 + inputIndex;         a111.listId    = -1;          objects.push(a111);     }        x3633()     {         return this.value.copy();     }        isValid()     {         if (!super.isValid())              return false;          for (const input of this.inputs)             if (!input.isValid())                 return false;          return true;     }        r4088(parse)     {         super.r4088(parse);          this.inputs.forEach(i => i.r4088(parse));     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          this.inputs.forEach(i => i.o4089(parse, from, force));     }        t4087(parse)     {         super.t4087(parse);          this.inputs.forEach(i => i.t4087(parse));     } }


class z1957 extends w1974 {     children = null;     position = null;     round    = null;     clip     = null;        constructor(nodeId, options)     {         super(f1268, nodeId, options);     }        reset()     {         super.reset();          this.children = null;         this.position = null;         this.round    = null;         this.clip     = null;     }        copy()     {         const copy = new z1957(this.nodeId, this.options);          copy.n3359(this);          if (this.children) copy.children = this.children.copy();         if (this.position) copy.position = this.position.copy();         if (this.round   ) copy.round    = this.round   .copy();         if (this.clip    ) copy.clip     = this.clip    .copy();          return copy;     }        f4242(p2992)     {         switch (p2992)         {             case 'children': return this.input ? this.value.children : this.children;             case 'position': return this.input ? this.value.position : this.position;             case 'x':        return this.input ? this.value.x        : this.x;             case 'y':        return this.input ? this.value.y        : this.y;             case 'width':    return this.input ? this.value.width    : this.width;             case 'height':   return this.input ? this.value.height   : this.height;             case 'round':    return this.input ? this.value.round    : this.round;             case 'clip':     return this.input ? this.value.clip     : this.clip;         }          return super.f4242(p2992);     }        async eval(parse)     {         if (this.isCached())             return this;           const [x, y, width, height] = await this.evalBaseParams(parse);          let children = await evalListValue  (this.children, parse);         let position = await evalNumberValue(this.position, parse);         let round    = await evalNumberValue(this.round,    parse);         let clip     = await evalNumberValue(this.clip,     parse);           if (   children             && r1294.includes(children.type)             && children.type != y1059)         {             const objects    = children.objects;             children         = new x2021([children]);             children.objects = objects;         }           let input = null;          if (this.input)         {             input = await evalFrameValue(this.input, parse);              this.value = new p2014(                 this.nodeId,                 children ?? input.children,                 position ?? input.position,                 x        ?? input.x,                 y        ?? input.y,                 width    ?? input.width,                 height   ?? input.height,                 round    ?? input.round,                 clip     ?? input.clip);         }         else         {             this.value = new p2014(                 this.nodeId,                  children,                 position,                 x,                  y,                  width,                 height,                  round,                 clip);         }           const childType = new j2033(m3479(children.items));          this.n4101(parse,          [             ['childType', childType],             ['position',  position ],             ['x',         x        ],             ['y',         y        ],             ['width',     width    ],             ['height',    height   ],             ['round',     round    ],             ['clip',      clip     ]         ]);           await this.t2896(parse);           await this.v4100(parse);           if (!this.children) this.children = this.value.children.copy();         if (!this.position) this.position = this.value.position.copy();         if (!this.x       ) this.x        = this.value.x       .copy();         if (!this.y       ) this.y        = this.value.y       .copy();         if (!this.width   ) this.width    = this.value.width   .copy();         if (!this.height  ) this.height   = this.value.height  .copy();         if (!this.round   ) this.round    = this.value.round   .copy();         if (!this.clip    ) this.clip     = this.value.clip    .copy();           this.validate();          return this;     }        async v4100(parse, options = {})     {         if (!this.options.enabled)             return;                       if (   this.value.position             && this.value.x             && this.value.y             && this.value.width             && this.value.height             && this.value.round             && this.value.clip)         {             let   pos = this.value.position.value;             let   x   = this.value.x       .value;             let   y   = this.value.y       .value;             let   w   = this.value.width   .value;             let   h   = this.value.height  .value;             const r   = Math.max(0, this.value.round.value);             const c   = this.value.clip    .value;               const frame = new u1841(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 x, y, w, h, r, c);               const bounds = getObjBounds(this.value.objects);              const singlePoint =                    this.value.objects.length  == 1                  && this.value.objects[0].type == g1246;                               const xoff = r893(-x, -y);              for (let i = 0; i < this.value.objects.length; i++)             {                 const a111 = this.value.objects[i];                                                     a111.n3742();                                                                     a111.resetSpace(bounds, singlePoint);                  if (pos > 0)                     a111.n4099(xoff, 2);                  this.s3737(frame.children, a111);             }               frame.r4098(x, y);             frame.x3730(x, y, w, h);                      this.value.objects = [frame];                           this.n4101(parse,              [                 ['nChildren', new d2022(frame.children.length)]             ],              true);         }           await super.v4100(parse);     }        s3737(objects, _obj)     {         const a111 = b3738(_obj);                              a111.nodeId   = this.nodeId;         a111.objectId = a111.objectId + h967 + this.nodeId;         a111.listId   = -1;                  objects.push(a111);     }        x3633()     {         return this.value.copy();     }        isValid()     {         return super.isValid()             && this.children && this.children.isValid()             && this.position && this.position.isValid()             && this.round    && this.round   .isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.children) this.children.r4088(parse);         if (this.position) this.position.r4088(parse);         if (this.round   ) this.round   .r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.children) this.children.o4089(parse, from, force);         if (this.position) this.position.o4089(parse, from, force);         if (this.round   ) this.round   .o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.children) this.children.t4087(parse);         if (this.position) this.position.t4087(parse);         if (this.round   ) this.round   .t4087(parse);     } }


class l1953 extends i2044 {     props   = null;     replace = null;        constructor(nodeId, options)     {         super(k1277, nodeId, options);     }        reset()     {         super.reset();          this.props   = null;         this.replace = null;     }        copy()     {         const copy = new l1953(this.nodeId, this.options);          copy.n3359(this);          if (this.props  ) copy.props   = this.props  .copy();         if (this.replace) copy.replace = this.replace.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                   const input   = await evalValue    (this.input,   parse);         const props   = await evalListValue(this.props,   parse);         const replace = await evalValue    (this.replace, parse);            if (input)         {             this.value         = input;             this.value.props   = props;             this.value.replace = replace;         }         else         {             this.value = new g4217();         }                  await this.v4100(parse);           this.n4101(parse,          [             ['type',    this.outputType()],                          ['props',   props            ],             ['replace', replace          ]         ]);           this.validate();          return this;     }        async v4100(parse, options = {})     {         if (this.value.isValid())         {             this.value.objects =                     this.input                  && this.input.value                 ? this.input.value.objects.map(o => o.copy())                  : [];         }           if (this.value.objects)         {             for (const a111 of this.value.objects)             {                 a111.nodeId   = this.nodeId;                 a111.objectId = a111.objectId + h967 + this.nodeId;             }              this.applyProps(this.value.objects, this.value.props, this.value.replace.value);         }                   await super.v4100(parse);     }        applyProps(objects, props, replace)     {         for (const a111 of objects)         {             if (this.options.enabled)             {                                                                                                                                          {                     if (replace == 1)                     {                         a111.fills    = [];                         a111.strokes  = [];                         a111.effects  = [];                         a111.maskType = 0;                     }                       if (g957(props.type))                     {                                        for (let i = props.items.length-1; i >= 0; i--)                             p1823(a111, props.items[i]);                     }                     else                         p1823(a111, props);                 }             }         }     }        x3633()     {         return this.value              ? this.value.copy()              : null;     }            isValid()     {         return super.isValid()             && this.props   && this.props  .isValid()             && this.replace && this.replace.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.props  ) this.props  .r4088(parse);         if (this.replace) this.replace.r4088(parse);     }       o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.props  ) this.props  .o4089(parse, from, force);         if (this.replace) this.replace.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.props  ) this.props  .t4087(parse);         if (this.replace) this.replace.t4087(parse);     } }


class e1947 extends w1974 {     children  = null;     operation = null;        constructor(nodeId, options)     {         super(j1286, nodeId, options);     }        reset()     {         super.reset();          this.children  = null;         this.operation = null;     }        copy()     {         const copy = new e1947(this.nodeId, this.options);          copy.n3359(this);          if (this.children ) copy.children  = this.children .copy();         if (this.operation) copy.operation = this.operation.copy();          return copy;     }        f4242(p2992)     {         switch (p2992)         {             case 'children':  return this.input ? this.value.children  : this.children;             case 'operation': return this.input ? this.value.operation : this.operation;         }          return super.f4242(p2992);     }        async eval(parse)     {         if (this.isCached())             return this;           await this.evalBaseParams(parse);          let   children  = await evalListValue  (this.children,  parse);         const operation = await evalNumberValue(this.operation, parse);           if (   children             && r1294.includes(children.type)             && children.type != y1059)         {             const objects    = children.objects;             children         = new x2021([children]);             children.objects = objects;         }           let input = null;          if (this.input)         {             input = await evalValue(this.input, parse);              this.value = new k2027(                 this.nodeId,                 children  ?? input.children,                 operation ?? input.operation);         }         else         {             this.value = new k2027(                 this.nodeId,                  children,                 operation);         }           this.n4101(parse,         [             ['operation', operation]         ]);           await this.t2896(parse);           await this.v4100(parse);           if (!this.children ) this.children  = this.value.children .copy();         if (!this.operation) this.operation = this.value.operation.copy();           this.validate();          return this;     }        async v4100(parse, options = {})     {         if (!this.options.enabled)             return;                       if (   this.value.objects             && this.value.operation)         {             let typeSuffix = '';              switch (this.operation.value)             {                 case 0: typeSuffix = '+'; break;                 case 1: typeSuffix = '-'; break;                 case 2: typeSuffix = '*'; break;                 case 3: typeSuffix = '/'; break;             }               const bool = new b1838(                 this.nodeId,                 this.nodeId + h967 + typeSuffix,                 this.nodeName,                 this.operation.value);               const bounds = getObjBounds(this.value.objects);              for (let i = 0; i < this.value.objects.length; i++)             {                 const a111 = this.value.objects[i];                                                     a111.n3742();                                                                     a111.resetSpace(bounds, false);                  this.s3737(bool.children, a111);             }                            bool.x      = bounds.x;             bool.y      = bounds.y;             bool.width  = bounds.width;             bool.height = bounds.height;                           bool.n3742();             bool.resetSpace(bounds);              bool.r4098(bounds.x, bounds.y);             bool.x3730(bounds.x, bounds.y, bounds.width, bounds.height);                      this.value.objects = [bool];               const nChildren = new d2022(                 this.children.objects                  ? this.children.objects.length                 : 0);               this.n4101(parse,             [                 ['nChildren', nChildren]             ],             true);         }         else         {             this.value.objects = [];                          this.n4101(parse,             [                 ['nChildren', new d2022(0)]             ],             true);         }                   await super.v4100(parse);     }        s3737(objects, _obj)     {         const a111 = b3738(_obj);          a111.nodeId   = this.nodeId;         a111.objectId = a111.objectId + h967 + this.nodeId;         a111.listId   = -1;          objects.push(a111);     }       x3633()     {         return this.value.copy();     }        isValid()     {         return super.isValid()             && this.children  && this.children .isValid()             && this.operation && this.operation.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.input    ) this.input    .r4088(parse);         if (this.children ) this.children .r4088(parse);         if (this.operation) this.operation.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.input    ) this.input    .o4089(parse, from, force);         if (this.children ) this.children .o4089(parse, from, force);         if (this.operation) this.operation.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.input    ) this.input    .t4087(parse);         if (this.children ) this.children .t4087(parse);         if (this.operation) this.operation.t4087(parse);     } }














class r1970 extends j1975 {     inputs = [];      retain = null;      finalize;        constructor(nodeId, options)     {         super(r1293, nodeId, options);     }        reset()     {         super.reset();          this.inputs = [];         this.retain = null;     }        copy()     {         const copy = new r1970(this.nodeId, this.options);          copy.n3359(this);          copy.inputs = this.inputs.map(i => i.copy());          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;          const retain   = await evalNumberValue(this.retain, parse);         const finalize = this.finalize.value > 0;           this.value = new x2021();          this.value.objects = [];           for (let i = 0, o = 0; i < this.inputs.length; i++)         {             await this.inputs[i].eval(parse);              const objects = u3628(this.inputs[i].value);                                   if (   this.options.enabled                 && (   finalize                     || retain.value == 1))             {                 for (let j = 0; j < objects.length; j++, o++)                 {                     let a111 = objects[j];                                            a111.nodeId   = this.nodeId;                     a111.objectId = a111.objectId + h967 + this.nodeId;                     a111.listId   = -1;                      if (  (   !isEmpty(a111.fills  )                            || !isEmpty(a111.strokes))                         && !a111.q3739)                             a111.retain = finalize ? 2 : 1;                                                  this.value.objects.push(a111);                 }             }         }           this.n4101(parse, [['', new g4217()]]);           this.validate();          return this;     }        x3633()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && !this.inputs.find(i => !i.isValid())             && this.retain && this.retain.isValid();     }        r4088(parse)     {         super.r4088(parse);          this.inputs.forEach(i => i.r4088(parse));          if (this.retain) this.retain.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          this.inputs.forEach(i => i.o4089(parse, from, force));          if (this.retain) this.retain.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          this.inputs.forEach(i => i.t4087(parse));          if (this.retain) this.retain.t4087(parse);     } }


class GExport extends j1975 {     inputs = [];      scale;     format;         suffix;          constructor(nodeId, options)     {         super(EXPORT, nodeId, options);     }        reset()     {         super.reset();          this.inputs = [];                  this.scale    = null;         this.format   = null;                     this.suffix   = null;           }        copy()     {         const copy = new GExport(this.nodeId, this.options);          copy.n3359(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.scale   ) copy.scale    = this.scale   .copy();         if (this.format  ) copy.format   = this.format  .copy();                     if (this.suffix  ) copy.suffix   = this.suffix  .copy();                return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const scale      = await evalNumberValue(this.scale,    parse);         const format     = await evalNumberValue(this.format,   parse);                     const suffix     = await evalTextValue  (this.suffix,   parse);                 this.value = new x2021();          this.value.objects = [];           for (let i = 0, o = 0; i < this.inputs.length; i++)         {             await this.inputs[i].eval(parse);              const objects = u3628(this.inputs[i].value);                                   for (let j = 0; j < objects.length; j++, o++)             {                 let a111 = objects[j];                                    a111.nodeId   = this.nodeId;                 a111.objectId = a111.objectId + h967 + this.nodeId;                 a111.listId   = -1;                  this.value.objects.push(a111);             }         }           this.n4101(parse,          [             ['objectIds', new x2021(this.value.objects.map(o => new j2033(o.objectId)))]         ]);           this.validate();          return this;     }        x3633()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && !this.inputs.find(i => !i.isValid())             && this.scale    && this.scale   .isValid()             && this.format   && this.format  .isValid()                                 && this.suffix   && this.suffix  .isValid();               }        r4088(parse)     {         super.r4088(parse);          this.inputs.forEach(i => i.r4088(parse));          if (this.scale   ) this.scale   .r4088(parse);         if (this.format  ) this.format  .r4088(parse);                     if (this.suffix  ) this.suffix  .r4088(parse);           }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          this.inputs.forEach(i => i.o4089(parse, from, force));          if (this.scale   ) this.scale   .o4089(parse, from, force);         if (this.format  ) this.format  .o4089(parse, from, force);                     if (this.suffix  ) this.suffix  .o4089(parse, from, force);           }        t4087(parse)     {         super.t4087(parse);          this.inputs.forEach(i => i.t4087(parse));          if (this.scale   ) this.scale   .t4087(parse);         if (this.format  ) this.format  .t4087(parse);                     if (this.suffix  ) this.suffix  .t4087(parse);           } }


class s1962 extends i2044 {     j3662    = null;     x           = null;     y           = null;     affectSpace = null;          _a          = 0;        constructor(nodeId, options)     {         super(k1270, nodeId, options);     }        reset()     {         super.reset();          this.j3662    = null;         this.x           = null;         this.y           = null;         this.affectSpace = null;          this._a          = 0;     }        copy()     {         const copy = new s1962(this.nodeId, this.options);          copy.n3359(this);          if (this.j3662   ) copy.j3662    = this.j3662   .copy();         if (this.x          ) copy.x           = this.x          .copy();         if (this.y          ) copy.y           = this.y          .copy();         if (this.affectSpace) copy.affectSpace = this.affectSpace.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const input       = await evalValue      (this.input,       parse);         const j3662    = await evalNumberValue(this.j3662,    parse);         const x           = await evalNumberValue(this.x,           parse);         const y           = await evalNumberValue(this.y,           parse);         const affectSpace = await evalNumberValue(this.affectSpace, parse);           if (input)         {             this.value = input.copy();              if (this.value)                 this.value.nodeId = this.nodeId;         }         else         {             this.value = new g4217();         }           await this.v4100(             parse,              {                 j3662:    j3662,                 x:           x,                  y:           y,                 affectSpace: affectSpace             });           this.n4101(parse,         [             ['type',        this.outputType()],             ['moveType',    j3662         ],             ['x',           x                ],             ['y',           y                ],             ['affectSpace', affectSpace      ]         ]);           this.validate();          return this;     }        async v4100(parse, options = {})     {         if (   this.value             && this.value.isValid()             && options.j3662             && options.x             && options.y             && options.affectSpace)         {             this.value.objects = u3628(this.input.value);               if (g957(this.value.type))             {                 for (let i = 0; i < this.value.items.length; i++)                     this.value.items[i].objects = this.value.objects.filter(o => o.t3820 == i);             }                              const j3662    = options.j3662   .value;             const x           = options.x          .value;             const y           = options.y          .value;             const affectSpace = options.affectSpace.value;               let _a = y/360*Tau;              while (_a <  0  ) _a += Tau;             while (_a >= Tau) _a -= Tau;                   const _v = vector(_a, x);                          const _x = j3662 == 0 ? x : _v.x;             const _y = j3662 == 0 ? y : _v.y;               const h4208 =                  j3662 == 0                 ? r893(_x, _y)                 : c889(                     r893(_x, _y),                     e892(-_a));                                    for (const a111 of this.value.objects)             {                 a111.nodeId    = this.nodeId;                 a111.objectId += h967 + this.nodeId;                  if (this.options.enabled)                     a111.n4099(h4208, affectSpace);             }               if (   this.value.type == m1249                 && this.value.objects                 && this.value.objects.length > 0                 && this.value.points.objects)             {                 for (let i = 0; i < this.value.objects[0].points.length; i++)                 {                     const p = this.value.objects[0].points[i].n3747();                          this.value.points.objects[i].x = p.x;                     this.value.points.objects[i].y = p.y;                 }             }         }                           await super.v4100(parse);     }        x3633()     {         return this.value              ? this.value.copy()              : null;     }                    isValid()     {         return super.isValid()             && this.j3662    && this.j3662   .isValid()             && this.x           && this.x          .isValid()             && this.y           && this.y          .isValid()             && this.affectSpace && this.affectSpace.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.j3662   ) this.j3662   .r4088(parse);         if (this.x          ) this.x          .r4088(parse);         if (this.y          ) this.y          .r4088(parse);         if (this.affectSpace) this.affectSpace.r4088(parse);     }       o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.j3662   ) this.j3662   .o4089(parse, from, force);         if (this.x          ) this.x          .o4089(parse, from, force);         if (this.y          ) this.y          .o4089(parse, from, force);         if (this.affectSpace) this.affectSpace.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.j3662   ) this.j3662   .t4087(parse);         if (this.x          ) this.x          .t4087(parse);         if (this.y          ) this.y          .t4087(parse);         if (this.affectSpace) this.affectSpace.t4087(parse);     } }


class w1952 extends i2044 {     affectSpace = null;        constructor(type, nodeId, options)     {         super(type, nodeId, options);     }        reset()     {         super.reset();          this.affectSpace = null;     }        n3359(base)     {         super.n3359(base);          if (base.affectSpace) this.affectSpace = base.affectSpace.copy();     }        async evalBaseParams(parse)     {         const affectSpace = await evalNumberValue(this.affectSpace, parse);          return [affectSpace];     }        async evalAffineObjects(parse, options, k3740, scaleStyle, getXform)     {         if (   !this.value             || !this.value.isValid()             || !this.input)             return l1047.NaN;           this.value.objects = u3628(this.input.value);                  if (g957(this.value.type))         {             for (let i = 0; i < this.value.items.length; i++)                 this.value.items[i].objects = this.value.objects.filter(o => o.t3820 == i);         }           const bounds = getObjBounds(this.value.objects);         const h4208  = getXform();           for (const a111 of this.value.objects)         {             a111.nodeId   = this.nodeId;             a111.objectId = a111.objectId + h967 + this.nodeId;               if (this.options.enabled)             {                 a111.n4099(                     h4208,                      options.affectSpace ? options.affectSpace.value : 2);                  a111.checkFlipped(                     options.flipX === true && h4208[0][0] < 0,                      options.flipY === true && h4208[1][1] < 0);                                      a111.k3740 *= Math.abs(k3740);                 a111.scaleStyle   *= Math.abs(scaleStyle  );                                  if (a111.type == j1243)                 {                     const sx = Math.sqrt(sqr(h4208[0][0]) + sqr(h4208[0][1]));                     const sy = Math.sqrt(sqr(h4208[1][0]) + sqr(h4208[1][1]));                      a111.size *= Math.min(sx, sy);                 }             }         }           if (   this.value.type == m1249             && this.value.objects             && this.value.objects.length > 0             && this.value.points.objects)         {             for (let i = 0; i < this.value.objects[0].points.length; i++)             {                 const p = this.value.objects[0].points[i].n3747();                  this.value.points.objects[i].x = p.x;                 this.value.points.objects[i].y = p.y;             }         }           return bounds;     }        isValid()     {         return super.isValid()             && this.affectSpace && this.affectSpace.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.affectSpace) this.affectSpace.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.affectSpace) this.affectSpace.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.affectSpace) this.affectSpace.t4087(parse);     } }


class o1972 extends w1952 {     angle = null;        constructor(nodeId, options)     {         super(e1271, nodeId, options);     }        reset()     {         super.reset();          this.angle = null;     }        copy()     {         const copy = new o1972(this.nodeId, this.options);          copy.n3359(this);          if (this.angle) copy.angle = this.angle.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalValue      (this.input, parse);         const angle = await evalNumberValue(this.angle, parse);           const [affectSpace] = await this.evalBaseParams(parse);           if (input)         {             this.value = input.copy();                          if (this.value)                 this.value.nodeId = this.nodeId;         }         else         {             this.value = new g4217();         }                  const _bounds = await this.v4100(             parse,              {                 angle:       angle,                  affectSpace: affectSpace             });                   const bounds = new s2025(             this.nodeId,             new d2022(_bounds.x     ),              new d2022(_bounds.y     ),              new d2022(_bounds.width ),             new d2022(_bounds.height),             new d2022(0));           this.n4101(parse,         [             ['type',        this.outputType()],             ['angle',       angle            ],             ['affectSpace', affectSpace      ],             ['bounds',      bounds           ]         ]);           this.validate();          return this;     }        async v4100(parse, options)     {         const a     = options.angle ? options.angle.value/360*Tau : 0;         const h4208 = e892(a);          options.flipX = false;         options.flipY = false;          return await this.evalAffineObjects(             parse,             options,              1,              1,             () => h4208);     }        x3633()     {         return this.value         ? this.value.copy()         : null;     }                    isValid()     {         return super.isValid()             && this.angle && this.angle.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.angle) this.angle.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.angle) this.angle.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.angle) this.angle.t4087(parse);     } }


class w1973 extends w1952 {     scaleX        = null;     scaleY        = null;     affectCorners = null;     affectStyle   = null;            constructor(nodeId, options)     {         super(y1272, nodeId, options);     }        reset()     {         super.reset();          this.scaleX        = null;         this.scaleY        = null;         this.affectCorners = null;         this.affectStyle   = null;     }        copy()     {         const copy = new w1973(this.nodeId, this.options);          copy.n3359(this);          if (this.scaleX       ) copy.scaleX        = this.scaleX       .copy();         if (this.scaleY       ) copy.scaleY        = this.scaleY       .copy();         if (this.affectCorners) copy.affectCorners = this.affectCorners.copy();         if (this.affectStyle  ) copy.affectStyle   = this.affectStyle  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input         = await evalValue      (this.input,         parse);         let   scaleX        = await evalNumberValue(this.scaleX,        parse);         let   scaleY        = await evalNumberValue(this.scaleY,        parse);         let   affectCorners = await evalNumberValue(this.affectCorners, parse);         let   affectStyle   = await evalNumberValue(this.affectStyle,   parse);           const [affectSpace] = await this.evalBaseParams(parse);           if (input)         {             this.value = input.copy();                          if (this.value)                 this.value.nodeId = this.nodeId;         }         else         {             this.value = new g4217();         }                  const _bounds = await this.v4100(             parse,              {                 scaleX:        scaleX,                  scaleY:        scaleY,                  affectSpace:   affectSpace,                 affectCorners: affectCorners,                 affectStyle:   affectStyle             });           const bounds = new s2025(             this.nodeId,             new d2022(_bounds.x     ),              new d2022(_bounds.y     ),              new d2022(_bounds.width ),             new d2022(_bounds.height),             new d2022(0));           this.n4101(parse,         [             ['type',          this.outputType()],             ['scaleX',        scaleX           ],             ['scaleY',        scaleY           ],             ['affectSpace',   affectSpace      ],             ['affectCorners', affectCorners    ],             ['affectStyle',   affectStyle      ],             ['bounds',        bounds           ]         ]);                   this.validate();          return this;     }        async v4100(parse, options)     {         let sx = y879(options.scaleX.value / 100);         let sy = y879(options.scaleY.value / 100);          options.flipX = sx < 0;         options.flipY = sy < 0;                  const scale = Math.min(sx, sy);          return await this.evalAffineObjects(             parse,             options,              this.affectCorners.value > 0 ? scale : 1,             this.affectStyle  .value > 0 ? scale : 1,             () => [[sx, 0,  0],                    [0,  sy, 0],                    [0,  0,  1]]);     }        isValid()     {         return super.isValid()             && this.scaleX        && this.scaleX       .isValid()             && this.scaleY        && this.scaleY       .isValid()             && this.affectCorners && this.affectCorners.isValid()             && this.affectStyle   && this.affectStyle  .isValid();     }        x3633()     {         return this.value              ? this.value.copy()              : null;     }        r4088(parse)     {         super.r4088(parse);          if (this.scaleX       ) this.scaleX       .r4088(parse);         if (this.scaleY       ) this.scaleY       .r4088(parse);         if (this.affectCorners) this.affectCorners.r4088(parse);         if (this.affectStyle  ) this.affectStyle  .r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.scaleX       ) this.scaleX       .o4089(parse, from, force);         if (this.scaleY       ) this.scaleY       .o4089(parse, from, force);         if (this.affectCorners) this.affectCorners.o4089(parse, from, force);         if (this.affectStyle  ) this.affectStyle  .o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.scaleX       ) this.scaleX       .t4087(parse);         if (this.scaleY       ) this.scaleY       .t4087(parse);         if (this.affectCorners) this.affectCorners.t4087(parse);         if (this.affectStyle  ) this.affectStyle  .t4087(parse);     } }


class t1977 extends w1952 {     skewX = null;     skewY = null;        constructor(nodeId, options)     {         super(z1273, nodeId, options);     }        reset()     {         super.reset();          this.skewX = null;         this.skewY = null;     }        copy()     {         const copy = new t1977(this.nodeId, this.options);          copy.n3359(this);          if (this.skewX) copy.skewX = this.skewX.copy();         if (this.skewY) copy.skewY = this.skewY.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const input = await evalValue      (this.input, parse);         let   skewX = await evalNumberValue(this.skewX, parse);         let   skewY = await evalNumberValue(this.skewY, parse);           const [affectSpace] = await this.evalBaseParams(parse);           if (input)         {             this.value = input;              if (this.value)                 this.value.nodeId = this.nodeId;         }         else         {             this.value = new g4217();         }                   const _bounds = await this.v4100(             parse,              {                 skewX:       skewX,                  skewY:       skewY,                  affectSpace: affectSpace             });           const bounds = new s2025(             this.nodeId,             new d2022(_bounds.x     ),              new d2022(_bounds.y     ),              new d2022(_bounds.width ),             new d2022(_bounds.height),             new d2022(0));           this.n4101(parse,         [             ['type',        this.outputType()],             ['skewX',       skewX            ],             ['skewY',       skewY            ],             ['affectSpace', affectSpace      ],             ['bounds',      bounds           ]         ]);           this.validate();          return this;     }        async v4100(parse, options)     {         const sx = -options.skewX.value / 100;         const sy = -options.skewY.value / 100;          options.flipX = false;         options.flipY = false;          return await this.evalAffineObjects(             parse,             options,              1, 1,             () => [[1,  sx, 0],                    [sy, 1,  0],                    [0,  0,  1]]);     }        isValid()     {         return super.isValid()             && this.skewX && this.skewX.isValid()             && this.skewY && this.skewY.isValid();     }        x3633()     {         return this.value              ? this.value.copy()              : null;     }        r4088(parse)     {         super.r4088(parse);          if (this.skewX) this.skewX.r4088(parse);         if (this.skewY) this.skewY.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.skewX) this.skewX.o4089(parse, from, force);         if (this.skewY) this.skewY.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.skewX) this.skewX.t4087(parse);         if (this.skewY) this.skewY.t4087(parse);     } }


class GShowCenter extends i2044 {     show = null;        constructor(nodeId, options)     {         super(SHOW_CENTER, nodeId, options);     }        copy()     {         const copy = new GShowCenter(this.nodeId, this.options);          copy.n3359(this);          if (this.show) copy.show = this.show.copy();                  return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalValue      (this.input, parse);         const show  = await evalNumberValue(this.show,  parse);           if (   input             && show)         {             this.value = input;              this.value.nodeId = this.nodeId;         }         else             this.value = new g4217();                   await this.v4100(parse, {show: show && show.value > 0});           const type = this.outputType();          this.n4101(parse,         [             ['type', type],             ['show', show]         ]);           this.validate();          return this;     }        async v4100(parse, options = {})     {         if (   this.value             && this.value.isValid())         {             this.value.objects = u3628(this.input.value);               for (const a111 of this.value.objects)             {                 a111.nodeId   = this.nodeId;                 a111.objectId = a111.objectId + h967 + this.nodeId;                                  if (   this.options.enabled                     && options.show)                     a111.showCenter = options.show;             }         }                           await super.v4100(parse);     }        x3633()     {         return this.value         ? this.value.copy()         : null;     }        isValid()     {         return super.isValid()             && this.show && this.show.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.show) this.show.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.show) this.show.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.show) this.show.t4087(parse);     } }


class g1954 extends i2044 {     centerX = null;     centerY = null;     units   = null;        constructor(nodeId, options)     {         super(x1274, nodeId, options);     }        reset()     {         super.reset();          this.centerX = null;         this.centerY = null;         this.units   = null;     }        copy()     {         const copy = new g1954(this.nodeId, this.options);          copy.n3359(this);          if (this.centerX) copy.centerX = this.centerX.copy();         if (this.centerY) copy.centerY = this.centerY.copy();         if (this.units  ) copy.units   = this.units  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const input   = await evalValue      (this.input,   parse);         const centerX = await evalNumberValue(this.centerX, parse);         const centerY = await evalNumberValue(this.centerY, parse);         const units   = await evalNumberValue(this.units,   parse);           if (this.input)         {             this.value = input.copy();              if (this.value)                 this.value.nodeId = this.nodeId;         }         else         {             this.value = new g4217();         }                   await this.v4100(             parse,              {                 centerX:    centerX,                  centerY:    centerY,                 units:      units             });           const type = this.outputType();          this.n4101(parse,         [             ['type',    type   ],             ['centerX', centerX],             ['centerY', centerY],             ['units',   units  ]         ]);           this.validate();          return this;     }        async v4100(parse, options = {})     {         if (   this.value             && this.value.isValid())         {             this.value.objects = u3628(this.input.value);                           const centerX = options.centerX    ? options.centerX   .value : 0;             const centerY = options.centerY    ? options.centerY   .value : 0;             const units   = options.units      ? options.units     .value : 0;                   const cx      = units == 0 ? centerX/100 : centerX;             const cy      = units == 0 ? centerY/100 : centerY;               const bounds  = getObjBounds(this.value.objects);               const singlePoint =                      this.value.objects.length  == 1                  && this.value.objects[0].type == g1246;               for (const a111 of this.value.objects)             {                 a111.nodeId   = this.nodeId;                 a111.objectId = a111.objectId + h967 + this.nodeId;                  if (this.options.enabled)                     a111.resetSpace(bounds, singlePoint, cx, cy, units);             }         }                           await super.v4100(parse);     }        x3633()     {         return this.value             ? this.value.copy()             : null;     }                    isValid()     {         return super.isValid()             && this.centerX && this.centerX.isValid()             && this.centerY && this.centerY.isValid()             && this.units   && this.units  .isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.centerX) this.centerX.r4088(parse);         if (this.centerY) this.centerY.r4088(parse);         if (this.units  ) this.units  .r4088(parse);     }       o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.centerX) this.centerX.o4089(parse, from, force);         if (this.centerY) this.centerY.o4089(parse, from, force);         if (this.units  ) this.units  .o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.centerX) this.centerX.t4087(parse);         if (this.centerY) this.centerY.t4087(parse);         if (this.units  ) this.units  .t4087(parse);     } }


class d1971 extends i2044 {     constructor(nodeId, options)     {         super(d1275, nodeId, options);     }        copy()     {         const copy = new d1971(this.nodeId, this.options);          copy.n3359(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalValue(this.input, parse);           if (input)         {             this.value = input;              this.value.nodeId = this.nodeId;         }         else             this.value = new g4217();                   await this.v4100(parse);           const type = this.outputType();          this.n4101(parse,         [             ['type', type]         ]);           this.validate();          return this;     }        async v4100(parse, options = {})     {         if (   this.value             && this.value.isValid())         {             this.value.objects = u3628(this.input.value);               const bounds = getObjBounds(this.value.objects);              const singlePoint =                    this.value.objects.length  == 1                  && this.value.objects[0].type == g1246;               for (const a111 of this.value.objects)             {                 a111.nodeId    = this.nodeId;                 a111.objectId += h967 + this.nodeId;                  if (this.options.enabled)                 {                     a111.n3742();                     a111.resetSpace(bounds, singlePoint);                 }             }         }                           await super.v4100(parse);     }        x3633()     {         return this.value         ? this.value.copy()         : null;     } }


class GJoinPaths extends w1974 {     inputs  = [];      closed  = null;     degree  = null;     winding = null;     round   = null;        constructor(nodeId, options)     {         super(JOIN_PATHS, nodeId, options);     }        reset()     {         super.reset();          this.inputs  = [];          this.closed  = null;         this.degree  = null;         this.winding = null;         this.round   = null;     }        copy()     {         const copy = new GJoinPaths(this.nodeId, this.options);          copy.n3359(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.closed ) copy.closed  = this.closed .copy();         if (this.degree ) copy.degree  = this.degree .copy();         if (this.winding) copy.winding = this.winding.copy();         if (this.round  ) copy.round   = this.round  .copy();          return copy;     }        f4242(p2992)     {         switch (p2992)         {             case 'closed':  return this.input ? this.value.closed  : this.closed;             case 'degree':  return this.input ? this.value.degree  : this.degree;             case 'winding': return this.input ? this.value.winding : this.winding;             case 'round':   return this.input ? this.value.round   : this.round;         }          return super.f4242(p2992);     }        async eval(parse)     {         if (this.isCached())             return this;           const closed  = await evalNumberValue(this.closed,  parse);         const degree  = await evalNumberValue(this.degree,  parse);         const winding = await evalNumberValue(this.winding, parse);         const round   = await evalNumberValue(this.round,   parse);           if (this.inputs.length > 0)         {             const paths  = [];             const points = new x2021();              for (const m3812 of this.inputs)             {                 const input = await evalVectorPathValue(m3812, parse);                  if (g957(input.type)) paths.push(...input.items);                 else                             paths.push(input);             }                                          for (let i = 0; i < paths.length; i++)             {                 const path = paths[i];                                  if (   !path                     || !path.objects                     ||  path.objects.length == 0)                     continue;                   let _degree;                       if (path.type == m1249) _degree = path.degree.value;                 else if (path.type == m1231   ) _degree = 2;                 else if (path.type == g1234  ) _degree = path.shape.value == 4 ? 2 : 0;                   const y3746 = path.objects[0].y3746;                 const pathDegree = Math.min(_degree, 2) + 1;                                   if (y3746.length == 0) continue;                   const segment = this.makeCubic(y3746, pathDegree);                  if (   i > 0                     && points.items.length > 1                     && segment.length > 1)                     this.joinSegment(points, segment, degree);                  points.items.push(...segment.map(p => h2023.fromPoint(this.nodeId, p)));             }               if (   closed.value > 0                 && points.items.length > 1)             {                 const segment = [ points.items[0].n3747(),                                   points.items[1].n3747() ];                  this.joinSegment(points, segment, degree);                  points.items.push(points.items[0].copy());             }               this.value = new l2037(                 this.nodeId,                  points,                  closed,                  new d2022(2),                 winding,                  round);               this.value.points.objects = this.value.points.items.map(p =>             {                 return new a1844(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     p.x.value,                     p.y.value,                     p.smooth ? p.smooth.value/100 : 1);             });         }         else         {             this.value = new l2037(                 this.nodeId,                  new x2021(),                  closed,                  new d2022(2),                 winding,                  round);         }           this.n4101(parse,          [             ['closed',  closed ],             ['degree',  degree ],             ['winding', winding],             ['round',   round  ]         ]);           await this.t2896(parse);           await this.v4100(parse);           this.validate();          return this;     }        joinSegment(points, segment, degree)     {         const p_2 = points.items.at(-2).n3747();         const p_1 = points.items.at(-1).n3747();          const p0  = segment[0];         const p1  = segment[1];          if (!x1019(p_1, p0))             points.items.push(...this.getJoinPoints(p_2, p_1, p0, p1, degree).map(p => h2023.fromPoint(this.nodeId, p)));         else             points.items.pop();     }        getJoinPoints(p_2, p_1, p0, p1, degree)     {         const points = [];           switch (degree.value)         {              case 0:                  points.push(d986(p_1, p0, 1/3));                 points.push(d986(p_1, p0, 2/3));                 break;              case 1:              {                 const c = y989(p_2, p_1, p1, p0, false);                 points.push(y895(p_1, x897(o886(a900(c, p_1)), Math.min(distv(p_2, p_1), distv(p_1, c) * 2/3))));                 points.push(y895(p0,  x897(o886(a900(c, p0 )), Math.min(distv(p1,  p0),  distv(p0,  c) * 2/3))));                 break;             }             case 2:                  points.push(y895(p_2, x897(a900(p_1, p_2), 2)));                 points.push(y895(p1,  x897(a900(p0,  p1),  2)));                 break;              case 3:                  points.push(point(b1035(p_1.x, p0.x, 0.3615), p_1.y));                 points.push(point(b1035(p0.x, p_1.x, 0.3615), p0 .y));                 break;              case 4:                  points.push(point(p_1.x, b1035(p_1.y, p0.y, 0.3615)));                 points.push(point(p0 .x, b1035(p0.y, p_1.y, 0.3615)));                 break;         }                   return points;     }        makeCubic(y3746, pathDegree)     {         const points = [y3746[0]];           for (let i = 0; i < y3746.length-pathDegree; i += pathDegree)         {             let segPoints;              switch (pathDegree)             {                 case 1: segPoints = linear2cubic(y3746.slice(i, i+2)); break;                 case 2: segPoints =   quad2cubic(y3746.slice(i, i+3)); break;                 case 3: segPoints =              y3746.slice(i, i+4);  break;             }              points.push(...segPoints.slice(1));          }                  return points;     }        async v4100(parse, options = {})     {         if (!this.options.enabled)             return;                       const points = [];          for (const pt of this.value.points.items)         {             const p = h2023.create(this.nodeId, pt.x.value, pt.y.value);                          if (pt.smooth != null)                 p.smooth = new d2022(pt.smooth);              points.push(p);         }           this.value.objects = [];           if (   super.i2897()                && points.length >= 2             && this.value.closed .isValid()             && this.value.degree .isValid()             && this.value.winding.isValid()             && this.value.round  .isValid())         {             const path = new d1853(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 points,                 this.value.closed .value,                 this.value.degree .value,                 this.value.winding.value,                 this.value.round  .value);                               const bounds = getObjBounds([path]);              let x = bounds.x;             let y = bounds.y;             let w = bounds.w;             let h = bounds.h;                           path.n3742(x + w/2, y + h/2);             path.r4098(x, y);             path.x3730(x, y, w, h);              this.value.objects.push(path);         }           await super.v4100(parse);     }        isValid()     {         if (!super.isValid())              return false;          for (const input of this.inputs)             if (!input.isValid())                 return false;          return this.closed  && this.closed .isValid()             && this.degree  && this.degree .isValid()             && this.winding && this.winding.isValid()             && this.round   && this.round  .isValid();     }        r4088(parse)     {         super.r4088(parse);          this.inputs.forEach(i => i.r4088(parse));          if (this.closed ) this.closed .r4088(parse);         if (this.degree ) this.degree .r4088(parse);         if (this.winding) this.winding.r4088(parse);         if (this.round  ) this.round  .r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          this.inputs.forEach(i => i.o4089(parse, from, force));          if (this.closed ) this.closed .o4089(parse, from, force);         if (this.degree ) this.degree .o4089(parse, from, force);         if (this.winding) this.winding.o4089(parse, from, force);         if (this.round  ) this.round  .o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          this.inputs.forEach(i => i.t4087(parse));          if (this.closed ) this.closed .t4087(parse);         if (this.degree ) this.degree .t4087(parse);         if (this.winding) this.winding.t4087(parse);         if (this.round  ) this.round  .t4087(parse);     } }


class GReorientPaths extends w1974 {     inputs  = [];      reverse = null;        constructor(nodeId, options)     {         super(JOIN_PATHS, nodeId, options);     }        reset()     {         super.reset();          this.inputs  = [];          this.reverse = null;     }        copy()     {         const copy = new GReorientPaths(this.nodeId, this.options);          copy.n3359(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.reverse) copy.reverse = this.reverse.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const reverse = await evalNumberValue(this.reverse, parse);           if (this.inputs.length > 0)         {             const paths = [];              for (const m3812 of this.inputs)             {                 const input = await evalVectorPathValue(m3812, parse);                  if (g957(input.type)) paths.push(...input.items);                 else                             paths.push(input);             }               this.value = new x2021();               const reorientedPaths =                  this.options.enabled                 ? reorientPaths(paths, reverse.value > 0)                 : paths                       .filter(path => path.objects && path.objects.length > 0)                       .map   (path => path.objects[0].y3746);         ;              l952(paths.length == reorientedPaths.length, 'original path count must match reoriented path count');                                       for (let i = 0; i < reorientedPaths.length; i++)             {                 const points =                      reorientedPaths[i]                     ? reorientedPaths[i].map(p => h2023.fromPoint(this.nodeId, p))                     :    paths[i]                     && paths[i].points                     ? paths[i].points.items                     : [];                  if (points.length == 0)                     continue;                                  const path = new l2037(                     this.nodeId,                     new x2021(points),                     paths[i].closed,                     paths[i].degree,                     paths[i].winding,                     paths[i].round);                                      path.n3359(paths[i]);                                  this.value.items.push(path);             }         }         else         {             this.value = new x2021();         }           this.n4101(parse,          [             ['reverse', reverse]         ]);           await this.t2896(parse);           await this.v4100(parse);           this.validate();          return this;     }        async v4100(parse, options = {})     {         this.value.objects = [];           for (let i = 0; i < this.value.items.length; i++)         {             const _path = this.value.items[i];             if (!_path) continue;               if (   _path.points.items.length >= 2                 && _path.closed .isValid()                 && _path.degree .isValid()                 && _path.winding.isValid()                 && _path.round  .isValid())             {                 const path = new d1853(                      this.nodeId,                      this.nodeId + h967 + i,                      this.nodeName,                     _path.points.items,                     _path.closed .value,                     _path.degree .value,                     _path.winding.value,                     _path.round  .value);                   if (_path.props)                     addProps(path, _path.props);                                       _path.objects = [path];                  this.value.objects.push(path);             }         }           const bounds = getObjBounds(this.value.objects);          for (const path of this.value.objects)         {             path.n3742(                 bounds.x + bounds.width /2,                             bounds.y + bounds.height/2                         );               let x = bounds.x;             let y = bounds.y;             let w = bounds.w;             let h = bounds.h;                          path.r4098(x, y);             path.x3730(x, y, w, h);         }           await super.v4100(parse);     }        isValid()     {         if (!super.isValid())              return false;          for (const input of this.inputs)             if (!input.isValid())                 return false;          return this.reverse && this.reverse.isValid();     }        r4088(parse)     {         super.r4088(parse);          this.inputs.forEach(i => i.r4088(parse));          if (this.reverse) this.reverse.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          this.inputs.forEach(i => i.o4089(parse, from, force));              if (this.reverse) this.reverse.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          this.inputs.forEach(i => i.t4087(parse));          if (this.reverse) this.reverse.t4087(parse);     } }    function reorientPaths(paths, reverse)  {     const orderedPaths = [];      let remainingPaths = paths         .filter(path => path.objects && path.objects.length > 0)         .map   (path => path.objects[0].y3746);       orderedPaths.push(remainingPaths.shift());       while (remainingPaths.length > 0)      {         const currentPath = orderedPaths.at(-1);                  const { closestPathIndex, shouldReverse } = findNextPath(currentPath, remainingPaths);          if (closestPathIndex == -1)              break;           let nextPath = remainingPaths.splice(closestPathIndex, 1)[0];                  if (shouldReverse)             nextPath.reverse();          orderedPaths.push(nextPath);     }       return reverse          ? orderedPaths.reverse().map(path => path.slice().reverse())          : orderedPaths; }    function findNextPath(currentPath, remainingPaths) {     let minDistance      = Infinity;     let closestPathIndex = -1;     let shouldReverse    = false;       const currentEndPoint = currentPath.at(-1);      remainingPaths.forEach((path, index) =>      {         const distanceToStart = distv(currentEndPoint, path.at( 0));         const distanceToEnd   = distv(currentEndPoint, path.at(-1));          if (distanceToStart < minDistance)          {             minDistance      = distanceToStart;             closestPathIndex = index;             shouldReverse    = false;         }          if (distanceToEnd < minDistance)          {             minDistance      = distanceToEnd;             closestPathIndex = index;             shouldReverse    = true;         }     });       return { closestPathIndex, shouldReverse }; }


class g1961 extends i2044 {     length = null;     angle  = null;            constructor(nodeId, options)     {         super(k1278, nodeId, options);     }            reset()     {         super.reset();          this.length = null;         this.angle  = null;     }        copy()     {         const copy = new g1961(this.nodeId, this.options);          copy.n3359(this);          if (this.length) copy.length = this.length.copy();         if (this.angle ) copy.angle  = this.angle .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalPointValue(this.input, parse);           if (input)         {             const v   = input.n3747();              const len = m885(v);             let   ang = p883 (v);              if (ang > Tau/2) ang -= Tau;              this.length = new d2022(len, -2);              this.angle =                  len > 0                  ? new d2022(ang/Tau * 360, -2)                  : d2022.NaN.copy();         }         else         {             this.length = d2022.NaN.copy();             this.angle  = d2022.NaN.copy();         }           this.n4101(parse,         [             ['length', this.length],             ['angle',  this.angle ]         ]);                   this.validate();          return this;     } }


class GPointAngle extends i2044 {     constructor(nodeId, options)     {         super(s1279, nodeId, options);     }            copy()     {         const copy = new GPointAngle(this.nodeId, this.options);          copy.n3359(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalPointValue(this.input, parse);           if (input)         {             if (g957(input.type))             {                 this.value = new x2021();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                     const a111  = input.objects[i];                      this.value.items.push(                         item.type == t1245                         ? new d2022(anglev2(a111.sp0, a111.sp1) / Tau * 360)                         : d2022.NaN.copy());                    }             }             else             {                 if (input.objects)                 {                     const a111 = input.objects[0];                     this.value = new d2022(anglev2(a111.sp0, a111.sp1) / Tau * 360);                 }             }         }         else             this.value = d2022.NaN.copy();           this.n4101(parse,         [                          ['type',  this.outputType()]         ]);           this.validate();          return this;     } }         


class e1982 extends u2045 {     transform = null;        constructor(nodeId, options)     {         super(p1280, nodeId, options);     }            reset()     {         super.reset();                  this.transform = null;     }        copy()     {         const copy = new e1982(this.nodeId, this.options);          copy.n3359(this);          if (this.transform) copy.transform = this.transform .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const e4083    = await evalPointValue (this.e4083,    parse);         const j4084    = await evalPointValue (this.j4084,    parse);         const transform = await evalNumberValue(this.transform, parse);           if (   e4083 && e4083.objects && e4083.objects.length > 0 && e4083.objects[0]             && j4084 && j4084.objects && j4084.objects.length > 0 && j4084.objects[0])         {             this.value = h2023.fromPoint(                 this.nodeId,                 a900(j4084.objects[0].n3747(), e4083.objects[0].n3747()));              await this.v4100(                 parse,                  {                     transform: transform,                 });         }         else         {             this.value = h2023.NaN.copy();         }           this.n4101(parse,         [             ['transform', transform]         ]);                   this.validate();          return this;     }        async v4100(parse, options = {})     {                                                     if (!this.value.objects)             this.value.objects = [];           if (   this.value.x             && this.value.y                && this.value.x.isValid()             && this.value.y.isValid())         {             const x = this.value.x.value;             const y = this.value.y.value;              const point = new a1844(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 x,                 y,                 this.smooth ? this.smooth.value/100 : 1);               point.r4098(x, y);                           if (options.transform.value > 0)             {                 point.n4099(                     getTransformFromAngle(p883(point.n3747())),                     2);             }                       this.value.objects = [point];         }           await super.v4100(parse);     }        isValid()     {         return super.isValid()             && this.transform && this.transform.isValid(); }        r4088(parse)     {         super.r4088(parse);          if (this.transform) this.transform.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.transform) this.transform.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.transform) this.transform.t4087(parse);     } }    function getTransformFromAngle(a)  {     const cosa = Math.cos(a);     const sina = Math.sin(a);      return [[ cosa, -sina, 0 ],              [ sina,  cosa, 0 ],              [ 0,     0,    1 ]]; }


class j1955 extends q2046 {     constructor(nodeId, options)     {         super(g1281, nodeId, options);     }                                   copy()     {         const copy = new j1955(this.nodeId, this.options);          copy.n3359(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const e4083 = await evalPointValue(this.e4083, parse);         const j4084 = await evalPointValue(this.j4084, parse);         const n4085 = await evalPointValue(this.n4085, parse);           if (   e4083 && e4083.isValid()             && j4084 && j4084.isValid()             && n4085 && n4085.isValid())         {             const pc = o996(                 e4083.n3747(),                 j4084.n3747(),                 n4085.n3747());              this.value = h2023.fromPoint(this.nodeId, pc);         }         else         {             this.value = h2023.NaN.copy();         }           await this.v4100(parse);           this.n4101(parse,          [             ['', new g4217()]                      ]);                   this.validate();          return this;     }        async v4100(parse, options = {})     {         if (!this.options.enabled)             return;                                   this.value.objects = [];           if (   this.value.x.isValid()             && this.value.y.isValid())         {             const x = this.value.x.value;             const y = this.value.y.value;              const point = new a1844(this.nodeId, this.nodeId, this.nodeName, x, y);              point.r4098(x, y);              this.value.objects = [point];         }           await super.v4100(parse);     } }


class GArcFromPoints extends w1974 {     e4083  = null;     j4084  = null;     n4085  = null;            constructor(nodeId, options)     {         super(ARC_FROM_POINTS, nodeId, options);     }            reset()     {         super.reset();          this.e4083  = null;         this.j4084  = null;         this.n4085  = null;     }        copy()     {         const copy = new GArcFromPoints(this.nodeId, this.options);          copy.n3359(this);          if (base.e4083 ) this.e4083  = base.e4083 .copy();         if (base.j4084 ) this.j4084  = base.j4084 .copy();         if (base.n4085 ) this.n4085  = base.n4085 .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const e4083 = await evalPointValue(this.e4083, parse);         const j4084 = await evalPointValue(this.j4084, parse);         const n4085 = await evalPointValue(this.n4085, parse);           if (   e4083 && e4083.isValid()             && j4084 && j4084.isValid()             && n4085 && n4085.isValid())         {                           const p0 = e4083.objects[0].n3747();             const p1 = j4084.objects[0].n3747();             const p2 = n4085.objects[0].n3747();              const points = makeArc(p0, p1, p2);              this.value = new l2037(                 this.nodeId,                 new x2021(points.map(p => h2023.fromPoint(this.nodeId, p))),                 new d2022(0),                 new d2022(2),                 new d2022(0),                 new d2022(0));         }         else         {             this.value = l2037.NaN.copy();         }           this.n4101(parse,          [             ['', new g4217()]         ]);           await this.t2896(parse);           await this.v4100(parse);           this.validate();          return this;     }        async v4100(parse, options = {})     {         if (!this.options.enabled)             return;                                   const points = [];          if (this.value.points)         {             for (const pt of this.value.points.items)             {                 const p = h2023.create(this.nodeId, pt.x.value, pt.y.value);                                  if (pt.smooth != null)                     p.smooth = new d2022(pt.smooth);                  points.push(p);             }         }           this.value.objects = [];           if (   points.length >= 2             && this.value             && this.value.closed .isValid()             && this.value.degree .isValid()             && this.value.winding.isValid()             && this.value.round  .isValid())         {             const path = new d1853(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 points,                 this.value.closed .value,                 this.value.degree .value,                 this.value.winding.value,                 this.value.round  .value);                           const bounds = getObjBounds([path]);              let x = bounds.x;             let y = bounds.y;             let w = bounds.w;             let h = bounds.h;                           path.n3742(x + w/2, y + h/2);             path.r4098(x, y);             path.x3730(x, y, w, h);              this.value.objects.push(path);         }           await super.v4100(parse);     }        isValid()     {         return super.isValid()             && this.e4083 && this.e4083.isValid()             && this.j4084 && this.j4084.isValid()             && this.n4085 && this.n4085.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.e4083) this.e4083.r4088(parse);         if (this.j4084) this.j4084.r4088(parse);         if (this.n4085) this.n4085.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.e4083) this.e4083.o4089(parse, from, force);         if (this.j4084) this.j4084.o4089(parse, from, force);         if (this.n4085) this.n4085.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.e4083) this.e4083.t4087(parse);         if (this.j4084) this.j4084.t4087(parse);         if (this.n4085) this.n4085.t4087(parse);     } }


class GPathLength extends i2044 {     length;        constructor(nodeId, options)     {         super(PATH_LENGTH, nodeId, options);     }            reset()     {         super.reset();          this.length = null;     }        copy()     {         const copy = new GPathLength(this.nodeId, this.options);          copy.n3359(this);          if (this.length) copy.length = this.length.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalVectorPathValue(this.input, parse);           if (   input             && input.objects.length > 0)         {             l952(input.type == m1249, 'input must be VECTOR_PATH_VALUE');              const degree = Math.min(input.degree.value, 2) + 1;              const points = createCcompleteCurve(                 degree,                  input.objects[0].y3746,                  input.closed.value > 0);               let length = curveLength(degree, points);               if (input.closed.value > 0)             {                 const endPoints = points.slice(points.length - degree);                 length += curveLength(degree, [...endPoints, points[0]]);             }              this.length = new d2022(length, -2);         }         else             this.length = d2022.NaN.copy();               this.n4101(parse,         [             ['length', this.length]         ]);           this.validate();          return this;     } } 


class y1966 extends i2044 {     position  = null;     distance  = null;     offset    = null;     transform = null;                    constructor(nodeId, options)     {         super(e1284, nodeId, options);     }            reset()     {         super.reset();          this.position  = null;         this.distance  = null;         this.offset    = null;         this.transform = null;     }        copy()     {         const copy = new y1966(this.nodeId, this.options);          copy.n3359(this);          if (this.position ) copy.position  = this.position .copy();         if (this.distance ) copy.distance  = this.distance .copy();         if (this.offset   ) copy.offset    = this.offset   .copy();         if (this.transform) copy.transform = this.transform.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input     = await evalVectorPathValue(this.input,     parse);         const position  = await evalNumberValue    (this.position,  parse);         const distance  = await evalNumberValue    (this.distance,  parse);         const offset    = await evalNumberValue    (this.offset,    parse);         const transform = await evalNumberValue    (this.transform, parse);           let pt;         let tangent = c984;           if (   input             && input.objects.length > 0)         {             const degree = Math.min(input.degree.value, 2) + 1;              const points = createCompleteCurve(                 degree,                  input.objects[0].y3746,                  input.closed.value > 0);               let length = curveLength(degree, points);                           const dist =                  position.value > 0                  ? distance.value                                                          : Math.min(Math.max(0, distance.value/100), 1) * length;                if (   dist >= 0                  && dist <= length                 && points.length >= degree-1)             {                 pt      =   pointAlongCurve(degree, points, dist);                 tangent = tangentAlongCurve(degree, points, dist);                  this.value = h2023.fromPoint(this.nodeId, pt);             }             else                 this.value = h2023.NaN.copy();         }         else             this.value = h2023.NaN.copy();           this.n4101(parse,         [             ['position',  position ],             ['distance',  distance ],             ['offset',    offset   ],             ['transform', transform]         ]);                   await this.v4100(parse,         {             transform:  transform,             tangent:    tangent,             offset:     offset.value         });           this.validate();          return this;     }        async v4100(parse, options = {})     {         if (!this.options.enabled)             return;                                   if (!this.value.objects)             this.value.objects = [];           if (   this.value.x             && this.value.y                && this.value.x.isValid()             && this.value.y.isValid())         {             const x = this.value.x.value;             const y = this.value.y.value;              const point = new a1844(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 x,                 y,                 this.smooth ? this.smooth.value/100 : 1);              point.r4098(x, y);               if (   options.transform.value > 0                 && options.tangent)             {                 const a     = -p883(options.tangent);                 let   h4208 = r893();                  h4208 = c889(h4208, e892(a));                  if (options.offset)                     h4208 = c889(h4208, r893(0, options.offset));                  point.n4099(h4208, options.transform.value > 0 ? 2 : 0);             }               this.value.objects = [point];         }           await super.v4100(parse);     }        isValid()     {         return super.isValid()             && this.position  && this.position .isValid()             && this.distance  && this.distance .isValid()             && this.offset    && this.offset   .isValid()             && this.transform && this.transform.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.position ) this.position .r4088(parse);         if (this.distance ) this.distance .r4088(parse);         if (this.offset   ) this.offset   .r4088(parse);         if (this.transform) this.transform.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.position ) this.position .o4089(parse, from, force);         if (this.distance ) this.distance .o4089(parse, from, force);         if (this.offset   ) this.offset   .o4089(parse, from, force);         if (this.transform) this.transform.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.position ) this.position .t4087(parse);         if (this.distance ) this.distance .t4087(parse);         if (this.offset   ) this.offset   .t4087(parse);         if (this.transform) this.transform.t4087(parse);     } }


class g1967 extends u2045 {     constrain = null;     transform = null;                    constructor(nodeId, options)     {         super(u1285, nodeId, options);     }            reset()     {         super.reset();          this.constrain = null;         this.transform = null;     }        copy()     {         const copy = new g1967(this.nodeId, this.options);          copy.n3359(this);          if (this.constrain) copy.constrain  = this.constrain.copy();         if (this.transform) copy.transform  = this.transform.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const e4083    = await evalVectorPathValue(this.e4083,     parse);         const j4084    = await evalPointValue     (this.j4084,     parse);          const constrain = await evalNumberValue    (this.constrain,  parse);         const transform = await evalNumberValue    (this.transform,  parse);           let tangent = c984;           if (   e4083             && j4084             && e4083.objects.length > 0             && j4084.objects.length > 0)         {             const degree = Math.min(e4083.degree.value, 2) + 1;              const points = createCompleteCurve(                 degree,                  e4083.objects[0].y3746,                  e4083.closed.value > 0);              let closest;             [closest, tangent] = closestTangentOnCurve(                 degree,                  points,                  j4084.objects[0].n3747(),                 constrain.value);                              this.value = h2023.fromPoint(this.nodeId, closest);         }         else             this.value = h2023.NaN.copy();           this.n4101(parse,         [             ['constrain',  constrain ],             ['transform',  transform ]         ]);                   await this.v4100(parse,         {             transform: transform,             tangent:   tangent         });           this.validate();          return this;     }        async v4100(parse, options = {})     {         if (!this.options.enabled)             return;                                   if (!this.value.objects)             this.value.objects = [];           if (   this.value.x             && this.value.y                && this.value.x.isValid()             && this.value.y.isValid())         {             const x = this.value.x.value;             const y = this.value.y.value;              const point = new a1844(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 x,                 y,                 this.smooth ? this.smooth.value/100 : 1);              point.r4098(x, y);               if (   options.transform.value > 0                 && options.tangent)             {                 const a     = -p883(options.tangent);                 const h4208 =  e892(a);                  point.n4099(h4208, options.transform.value > 0 ? 2 : 0);             }                                       this.value.objects = [point];         }           await super.v4100(parse);     }        isValid()     {         return super.isValid()             && this.transform && this.transform.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.transform) this.transform.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.transform) this.transform.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.transform) this.transform.t4087(parse);     } }


class u1959 extends b2047 {     segment = null;        constructor(nodeId, options)     {         super(g1282, nodeId, options);     }            reset()     {         super.reset();          if (this.segment) this.segment.reset();     }        copy()     {         const copy = new u1959(this.nodeId, this.options);          copy.n3359(this);          if (this.segment) copy.segment = this.segment.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const e4083  = await evalPointValue (this.e4083,  parse);         const j4084  = await evalPointValue (this.j4084,  parse);         const n4085  = await evalPointValue (this.n4085,  parse);         const x4086  = await evalPointValue (this.x4086,  parse);         const segment = await evalNumberValue(this.segment, parse);           if (   e4083             && j4084             && n4085             && x4086)         {             const p = y989(                 e4083.n3747(),                 j4084.n3747(),                 n4085.n3747(),                 x4086.n3747(),                 segment.value > 0);              this.value = h2023.fromPoint(this.nodeId, p);         }         else         {             this.value = h2023.NaN.copy();         }           await this.v4100(parse);           this.n4101(parse,          [             ['value',   this.value],             ['segment', segment   ]         ]);                   this.validate();          return this;     }        async v4100(parse, options = {})     {         if (!this.options.enabled)             return;                                   this.value.objects = [];           if (   this.value.x.isValid()             && this.value.y.isValid())         {             const x = this.value.x.value;             const y = this.value.y.value;              const point = new a1844(this.nodeId, this.nodeId, this.nodeName, x, y);              point.r4098(x, y);              this.value.objects = [point];         }           await super.v4100(parse);     }        isValid()     {         return super.isValid()             && this.segment && this.segment.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.segment) this.segment.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.segment) this.segment.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.segment) this.segment.t4087(parse);     } }


class g1958 extends u2045 {     amount    = null;     transform = null;            constructor(nodeId, options)     {         super(j1283, nodeId, options);     }            reset()     {         super.reset();          this.amount    = null;         this.transform = null;     }        copy()     {         const copy = new g1958(this.nodeId, this.options);          copy.n3359(this);          if (this.amount   ) copy.amount    = this.amount   .copy();         if (this.transform) copy.transform = this.transform.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const e4083    = await evalPointValue (this.e4083,    parse);         const j4084    = await evalPointValue (this.j4084,    parse);         const amount    = await evalNumberValue(this.amount,    parse);         const transform = await evalNumberValue(this.transform, parse);           if (   e4083 && e4083.isValid() && e4083.objects  && e4083.objects.length > 0             && j4084 && j4084.isValid() && j4084.objects  && j4084.objects.length > 0)         {             const p0  = point(e4083.objects[0].x, e4083.objects[0].y);             const p1  = point(j4084.objects[0].x, j4084.objects[0].y);             const amt = amount.value / 100;              const p   = d986(p0, p1, amt);                               let sp0 = d986(e4083.objects[0].sp0, j4084.objects[0].sp0, amt);             let sp1 = d986(e4083.objects[0].sp1, j4084.objects[0].sp1, amt);             let sp2 = d986(e4083.objects[0].sp2, j4084.objects[0].sp2, amt);              if (transform.value > 0)             {                 const l1 = distv(sp0, sp1);                 const l2 = distv(sp0, sp2);                  sp0 = clone(p);                 sp1 = y895(sp0, x897(o886(a900(p1, p0)), l1));                 sp2 = y895(sp0, s1022(x897(o886(a900(p1, p0)), l2)));             }               this.value = new h2023(this.nodeId, new d2022(p.x), new d2022(p.y));              const pt = new a1844(this.nodeId, this.nodeId, this.nodeName, p.x, p.y);             pt.r4098(p.x, p.y);             this.value.objects = [pt];              this.value.objects[0].sp0 = sp0;             this.value.objects[0].sp1 = sp1;             this.value.objects[0].sp2 = sp2;         }         else             this.value = h2023.NaN.copy();           this.n4101(parse,         [             ['amount',    amount   ],             ['transform', transform]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.amount    && this.amount   .isValid()             && this.transform && this.transform.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.amount   ) this.amount   .r4088(parse);         if (this.transform) this.transform.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.amount   ) this.amount   .o4089(parse, from, force);         if (this.transform) this.transform.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.amount   ) this.amount   .t4087(parse);         if (this.transform) this.transform.t4087(parse);     } }


class GReversePath extends i2044 {     constructor(nodeId, options)     {         super(REVERSE_PATH, nodeId, options);     }        copy()     {         const copy = new GReversePath(this.nodeId, this.options);          copy.n3359(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const input = await evalVectorPathValue(this.input, parse);           if (   input             && input.objects.length > 0             && input.objects[0].y3746)         {             this.value        = input.copy();             this.value.nodeId = this.nodeId;         }         else         {             this.value = new g4217();         }           await this.v4100(parse);           this.n4101(parse,         [             ['type', this.outputType()]         ]);           this.validate();          return this;     }        async v4100(parse, options = {})     {         if (   this.value             && this.value.isValid())         {             this.value.objects = u3628(this.input.value);               for (const a111 of this.value.objects)             {                 a111.nodeId   = this.nodeId;                 a111.objectId = a111.objectId + h967 + this.nodeId;                  if (   this.options.enabled                     && PATH_TYPES.includes(a111.type))                     a111.y3746.reverse();             }         }                           await super.v4100(parse);     }        x3633()     {         return this.value              ? this.value.copy()              : null;     } }


class GBlendPath extends w1974 {     inputs = [];      amount;     degree;        constructor(nodeId, options)     {         super(BLEND_PATH, nodeId, options);     }        reset()     {         super.reset();          this.inputs = [];          this.amount = null;         this.degree = null;     }        copy()     {         const copy = new GBlendPath(this.nodeId, this.options);          copy.n3359(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.amount) copy.amount = this.amount.copy();         if (this.degree) copy.degree = this.degree.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const amount = await evalNumberValue(this.amount, parse);         const degree = await evalNumberValue(this.degree, parse);           const paths = [];                  for (const m3812 of this.inputs)         {             const input = await evalVectorPathValue(m3812, parse);              if (g957(input.type))             {                 for (const item of input.items)                 {                     const path = await evalVectorPathValue(item, parse);                     paths.push(path);                 }             }             else             {                 const path = await evalVectorPathValue(input, parse);                 paths.push(path);             }         }                           if (paths.length == 1)             this.value = paths[0];          else if (paths.length > 0)         {                                                                                                                                                                                                                                                                                                                                                              this.value = l2037.NaN.copy();         }          else                               this.value = l2037.NaN.copy();           await this.v4100(parse);           this.n4101(parse,         [             ['type',   this.outputType()],             ['amount', amount           ],             ['degree', degree           ]         ]);           this.validate();          return this;     }        async v4100(parse, options = {})     {         if (   this.value             && this.value.isValid())         {             this.value.objects = u3628(this.input.value);               for (const a111 of this.value.objects)             {                 a111.nodeId   = this.nodeId;                 a111.objectId = a111.objectId + h967 + this.nodeId;                                                }         }                           await super.v4100(parse);     }        x3633()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return  super.isValid()             &&  this.inputs.length > 0             && !this.inputs.find(i => !i.isValid())             &&  this.amount && this.amount.isValid()             &&  this.degree && this.degree.isValid();     }        r4088(parse)     {         super.r4088(parse);          this.inputs.forEach(i => i.r4088(parse));          if (this.amount) this.amount.r4088(parse);         if (this.degree) this.degree.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          this.inputs.forEach(i => i.o4089(parse, from, force));          if (this.amount) this.amount.o4089(parse, from, force);         if (this.degree) this.degree.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          this.inputs.forEach(i => i.t4087(parse));          if (this.amount) this.amount.t4087(parse);         if (this.degree) this.degree.t4087(parse);     } }


class d1963 extends i2044 {     position  = null;     transform = null;                constructor(nodeId, options)     {         super(b1276, nodeId, options);     }        reset()     {         super.reset();                  this.position  = null;         this.transform = null;     }        copy()     {         const copy = new d1963(this.nodeId, this.options);          copy.n3359(this);          if (this.position ) copy.position  = this.position .copy();         if (this.transform) copy.transform = this.transform.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const input     = await evalValue      (this.input,     parse);         const position  = await evalPointValue (this.position,  parse);         const transform = await evalNumberValue(this.transform, parse);          if (   input             && position)         {             this.value = input.copy();              if (this.value)                 this.value.nodeId = this.nodeId;         }         else             this.value = new g4217();           if (   position             && position.isValid()             && position.objects             && position.objects.length > 0)         {             const p0 = point(                 position.objects[0].x,                  position.objects[0].y);              const p1 = y895(p0, a900(position.objects[0].sp1, position.objects[0].sp0));             const p2 = y895(p0, a900(position.objects[0].sp2, position.objects[0].sp0));              await this.v4100(                 parse,                  {                     transform:  transform,                     sp0:        p0,                     sp1:        p1,                     sp2:        p2                 });         }                   this.n4101(parse,         [             ['position',  position ],             ['transform', transform]         ]);           this.validate();          return this;     }        async v4100(parse, options)     {         if (   this.value             && this.value.isValid())         {             this.value.objects = u3628(this.input.value);               const place = r893(                 options.sp0 ? options.sp0.x : 0,                 options.sp0 ? options.sp0.y : 0);               for (const a111 of this.value.objects)             {                 a111.nodeId   = this.nodeId;                 a111.objectId = a111.objectId + h967 + this.nodeId;                   if (this.options.enabled)                 {                     let h4208 = c889(                         r893(                             -a111.sp0.x,                              -a111.sp0.y),                         place);                       if (   options.transform.value > 0                         && options.sp0                         && options.sp1                         && options.sp2)                     {                         const sp = getTransformFromPoints(                             options.sp0,                              options.sp1,                              options.sp2);                          h4208 = c889(h4208, sp);                          a111.sp1 = y895(a111.sp0, point(1, 0));                         a111.sp2 = y895(a111.sp0, point(0, 1));                     }                       a111.n4099(h4208, true);                 }             }         }                           await super.v4100(parse);     }        x3633()     {         return this.value              ? this.value.copy()              : null;     }                    isValid()     {         return super.isValid()             && this.position  && this.position .isValid()             && this.transform && this.transform.isValid();     }        r4088(parse)     {         super.r4088(parse);          if (this.position ) this.position .r4088(parse);         if (this.transform) this.transform.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.position ) this.position .o4089(parse, from, force);         if (this.transform) this.transform.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.position ) this.position .t4087(parse);         if (this.transform) this.transform.t4087(parse);     } }    function getTransformFromPoints(p0, p1, p2)  {     const dx   = p1.x - p0.x;     const dy   = p1.y - p0.y;      const a    = Math.atan2(dy, dx);        const cosa = Math.cos(a);     const sina = Math.sin(a);                        return [[ cosa,         -sina , 0 ],              [ sina , cosa,          0 ],              [ 0,             0,             1 ]]; }


class e1883 extends g2043 {     j3092 = [];     params   = [];        constructor(nodeId, options)     {         super(g1298, nodeId, options);     }            copy()     {         const copy = new e1883(this.nodeId, this.options);          copy.n3359(this);          copy.params = this.params.map(p => p.copy());          return copy;     }        f4242(p2992)     {         return this.params[this.j3092.findIndex(id => id == p2992)];     }        async eval(parse)     {         if (this.isCached())             return this;           this.e3096 = [];           if (!isEmpty(this.params))         {             for (let i = 0; i < this.params.length; i++)             {                 const param = await this.params[i].eval(parse);                 this.n4101(parse, [[this.j3092[i], param.x3633()]], true);             }         }         else             this.n4101(parse, [['', new g4217()]], true);                                   this.validate();          return this;     }        x3633()     {         return this.value              ? this.value.copy()               : null;     }        r4088(parse)     {         super.r4088(parse);          this.inputs.forEach(i => i.r4088(parse));         this.params.forEach(p => p.r4088(parse));     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          this.inputs.forEach(i => i.o4089(parse, from, force));         this.params.forEach(p => p.o4089(parse, from, force));     }        t4087(parse)     {         super.t4087(parse);          this.inputs.forEach(i => i.t4087(parse));         this.params.forEach(p => p.t4087(parse));     } } 


class s1884 extends g2043 {     input    = null;          dataType = NULL;        constructor(nodeId, options)     {         super(a1299, nodeId, options);     }        reset()     {         super.reset();          this.input    = null;         this.dataType = null;     }        copy()     {         const copy = new s1884(this.nodeId, this.options);                  copy.n3359(this);          if (this.input) copy.input = this.input.copy();                  copy.dataType = this.dataType;                return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           if (this.input)         {             if (!this.input.value)                 await this.input.eval(parse);              this.value = this.input.x3633();         }          else if (this.dataType != NULL)             this.value = nanFromType(this.dataType);                  else             this.value = new g4217();           this.n4101(parse,         [             ['value', this.value]         ]);           this.validate();          return this;     }        r4088(parse)     {         super.r4088(parse);          if (this.input) this.input.r4088(parse);     }        x3633()     {         return this.value.copy();     }        r4088(parse)     {         super.r4088(parse);          if (this.input) this.input.r4088(parse);     }        o4089(parse, from, force)     {         super.o4089(parse, from, force);          if (this.input) this.input.o4089(parse, from, force);     }        t4087(parse)     {         super.t4087(parse);          if (this.input) this.input.t4087(parse);     } }


class a2040 extends g2043 {     constructor(nodeId, options)     {         super(n1301, nodeId, options);     }            copy()     {         const copy = new a2040(this.nodeId, this.options);          copy.n3359(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new g4217();           this.n4101(parse, [['', new g4217()]]);                           this.validate();          return this;     }        x3633()     {         return this.value              ? this.value.copy()               : null;     } } 


class f2041 extends g2043 {     constructor(nodeId, options)     {         super(b1302, nodeId, options);     }            copy()     {         const copy = new f2041(this.nodeId, this.options);          copy.n3359(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new g4217();           this.n4101(parse, [['', new g4217()]]);                           this.validate();          return this;     }        x3633()     {         return this.value              ? this.value.copy()               : null;     } } 


class o2048 extends g2043 {     constructor(nodeId, options)     {         super(q1303, nodeId, options);     }            copy()     {         const copy = new o2048(this.nodeId, this.options);          copy.n3359(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new g4217();           this.n4101(parse, [['', new g4217()]]);                           this.validate();          return this;     }        x3633()     {         return this.value              ? this.value.copy()               : null;     } } 


var f3864 = false;  var b3865          = [];   var z4038            = []; var w4039  = [];       var lastMessage = null;   onmessage = function(e) {     const msg = JSON.parse(e.data);       if (msg.cmd == 'returnUiGetValueForGenerator')          return;           if (msg.cmd == 'genRequest')     {         if (   lastMessage             && lastMessage.cmd == 'genRequest')             return;           u4018(msg.request, msg.save);              }     else     {         switch (msg.cmd)         {             case 'initFonts':        initFonts(msg.fonts, msg.uniqueFontNames); break;                      case 'genEndUiMessage':  o2054 (msg.msgCmd);              break;             case 'genEndFigMessage': i2055();                        break;         }          lastMessage = null;     }       r2051(     {         cmd:   'uiEndGenMessage',         msgCmd: msg.cmd     }); };         function r2051(msg) {     if (msg == undefined)     {         j953('undefined message');         console.trace();     }      postMessage(JSON.stringify(msg)); }    function i2052(msg) {     b3865.push(msg);     w2053(); }    function w2053(msg) {     if (!isEmpty(b3865))          {                  let msg = b3865.shift();                                                                                                                                                                               r2051(msg);     } }    function o2054(msgCmd) {          w2053(); }    function i2055() {     f3864 = false;          if (   !isEmpty(s2059 )         || !isEmpty(y2060)         || !isEmpty(t2061 ))     {         b3861(             y2056,             false,             -1,              Number.MAX_SAFE_INTEGER,              p2057,              z2058,              [],              [],             [],             false);     }      w2053(); }  


var y2056     = -1; var p2057  =  NULL; var z2058 =  NULL; var s2059  =  []; var y2060 =  []; var t2061  =  [];    function initFonts(fonts, uniqueFontNames) {     z4038           = fonts;     w4039 = uniqueFontNames; }    function u4018(request, save) {     const z2067       = parseInt(request[0]);     const actionId        = parseInt(request[1]);     const set             = parseInt(request[2]);     const e4021 = parseInt(request[3]);       const settings =     {         showAllColorSpaces:  ((set >> 0) & 1) != 0,         logRequests:         ((set >> 1) & 1) != 0,         h2554: ((set >> 2) & 1) != 0,         w189:        ((set >> 3) & 1) != 0,         u3733:    ((set >> 4) & 1) != 0,         l3734:    ((set >> 5) & 1) != 0     };       const s4019  = request[4];     const f4020 = request[5];      const viewportZoom  = request[6];       const parse = new j1786(         request,          7,         z2067,         s4019,          f4020,          viewportZoom,         settings,         save);       const d3728 = 100;      while (   parse.pos < parse.request.length            && parse.so  < d3728)         a1788(parse);       if (settings.logRequests)         r2123(parse);       const d4231 = parse.g3642         .map(id => parse.k4243.find(n => n.nodeId == id));                const n3863 = parse.k4243         .filter(n =>                  n.topLevel              && !d4231.find(w3497 => w3497.nodeId == n.nodeId));      const otherNodes = parse.k4243.filter(n =>                !d4231   .find(w3497 => w3497.nodeId == n.nodeId)             && !n3863.find(w3497 => w3497.nodeId == n.nodeId));       (async () =>     {         let stop = false;           for (const nodes of [d4231, n3863])         {             for (const node of nodes)             {                 if (await r3862(parse.z2067)) { stop = true; break; }                 await node.eval(parse);             }         }           if (    stop             && !settings.w189)             return;           i2052({cmd: 'uiEndGlobalProgress'});                  for (const nodes of [n3863, otherNodes])             for (const node of nodes)                  node.r4088(parse);                           for (const node of parse.k4243)         {             if (node.options.active === true)             {                 if (   node.value                     && node.value.objects)                     node.value.objects.forEach(o => e2063(parse, o));                  if (node.colorStyle)                      j2064(parse, node.colorStyle);             }         }           for (const node of parse.k4243)         {             if (   node.options.active === true                 && node.value                 && node.value.objects)             {                 for (const a111 of node.value.objects)                 {                     if (a111.showCenter)                     {                         e2063(                             parse,                              g2586(node, a111));                     }                       if (    parse.settings.h2554                         && !a111.q3739                         &&  a111.xp0                         &&  a111.xp1                         &&  a111.xp2)                     {                         const xp0 = clone(a111.xp0);                         const xp1 = clone(a111.xp1);                         const xp2 = clone(a111.xp2);                         const xp3 = y895(xp2, a900(xp1, xp0));                          e2063(                             parse,                              createDecoPoly(                                 node.nodeId,                                 a111.objectId,                                 a111.objectName,                                 a111.sp0,                                 [xp0, xp2, xp3, xp1],                                 true,                                 '1, 2',                                 [12, 140, 233],                                 o971,                                 false));                     }                 }             }         }                    await b3861(             parse.z2067,             settings.w189,             actionId,             e4021,             parse.s4019,             parse.f4020,             parse.e3096,             parse.g3643,             parse.k3644,             save);     })(); }    async function r3862(z2067) {     const uiCurRequestId = await genGetValueFromUi('curRequestId');      if (uiCurRequestId.value > z2067)      {          i2052({cmd: 'uiEndGlobalProgress'});         return true;      }      return false }    function s2062(parse, nodeId, p2992, value) {     if (!value)         return;           s945(parse.e3096, v =>            v.nodeId     == nodeId         && v.p2992    == p2992         && v.value.type == value.type);               parse.e3096.push(     {         nodeId:  nodeId,         p2992: p2992,         type:    value.type,          value:   value.n2119()     }); }    function e2063(parse, object) {     h951(         parse.g3643,         object,         o =>    o.nodeId   == object.nodeId              && o.objectId == object.objectId); }    function j2064(parse, style) {     h951(         parse.k3644,         style,         o => o.nodeId == style.nodeId); }    function t2065() {     p2057  =  NULL;     z2058 =  NULL;      s2059  =  [];     y2060 =  [];     t2061  =  []; }    async function b3861(z2067, w189, actionId, e4021, s4019, f4020, e3096, g3643, k3644, save) {     if (   isEmpty(e3096 )         && isEmpty(g3643)         && isEmpty(k3644 ))     {         s4019  = p2057;         f4020 = z2058;                  e3096  = s2059;         g3643 = y2060;         k3644  = t2061;          t2065();     }     else if (f3864)     {         y2056     = z2067;         p2057  = s4019;         z2058 = f4020;          s2059  = e3096;         y2060 = g3643;         t2061  = k3644;          return;     }       const nodeIds = g1465(e3096.map(v => v.nodeId));     const counts  = nodeIds.map(id => e3096.filter(v => v.nodeId == id).length);             const approxNodeChunkSize = 1000000;     const objChunkSize        = 1000000;     const styleChunkSize      = 1000000;           let n  = 0;      let o  = 0;      let s  = 0;       let nc = 0;      let oc = 0;      let sc = 0;        let g2070   = [],         q2071       = [],         c2072     = [];      let m2069 = 0;      let n2075   = true;               i2052(     {         cmd:      'uiInitGlobalProgress',         z2067: z2067     });       let p2068 = 0;     g3643.forEach(o => p2068 += o.getCount());           while (   n < nodeIds      .length            || o < g3643.length            || s < k3644 .length)     {         if (n < nodeIds.length)         {             g2070.push(nodeIds[n], counts[n]);              const values = e3096.filter(v => v.nodeId == nodeIds[n]);                           for (const v of values)                 g2070.push(v.p2992, v.type, v.value);              n++, nc++;         }           if (o < g3643.length)         {             q2071.push(g3643[o].s3741());             o++, oc++;         }           if (s < k3644.length)         {             c2072.push(k3644[s].s3741());             s++, sc++;         }           const chunkNotEmpty =                nc >= approxNodeChunkSize             || oc == objChunkSize             || sc == styleChunkSize;           if (chunkNotEmpty)         {             const l2076 =                        n >= nodeIds      .length                 && o >= g3643.length                 && s >= k3644 .length                 && (   !isEmpty(g2070)                     || !isEmpty(q2071    )                     || !isEmpty(c2072  ));              w2066(                 z2067,                 actionId,                 s4019,                 f4020,                 e4021,                 p2068,                 m2069++,                 g2070,                 q2071,                 c2072,                 n,                 nodeIds.length,                 n2075,                 l2076,                 save);              g2070 = [];  nc = 0;             q2071     = [];  oc = 0;             c2072   = [];  sc = 0;              n2075 = false;         }           if (await r3862(z2067))              break;     }       const lastChunkNotEmpty =            !isEmpty(g2070)         || !isEmpty(q2071    )         || !isEmpty(c2072  );       if (   lastChunkNotEmpty         || w189         ||    isEmpty(e3096)             && isEmpty(g3643)            && isEmpty(k3644))     {         w2066(             z2067,             actionId,             s4019,             f4020,             e4021,             p2068,             m2069++,             g2070,             q2071,             c2072,             nodeIds.length,             nodeIds.length,             false,             true,             save);     }       i2052({         cmd: 'uiForwardToFigma',         msg: {cmd: 'figCommitUndo'}     }) }    function w2066(z2067, actionId, s4019, f4020, e4021, p2068, m2069, g2070, q2071, c2072, u2073, f2074, n2075, l2076, save) {     i2052({         cmd:            'uiUpdateValuesAndObjects',         z2067:       z2067,         actionId:        actionId,         s4019:    s4019,         f4020:   f4020,         e4021: e4021,         p2068:    p2068,         chunkId:         m2069,         values:          [...g2070].map(v => v.toString()),         objects:         [...q2071    ],         styles:          [...c2072  ],         u2073:    u2073,         f2074:      f2074,         n2075:    n2075,         l2076:     l2076,         save:            save     });       if (   !isEmpty(q2071  )         || !isEmpty(c2072))         f3864 = true; }    function x2077(nodeId) {     i2052(     {         cmd:   'uiInitNodeProgress',         nodeId: nodeId     }); }    function y2078(parse, nodeId, progress, updateGlobal = true) {     i2052(     {         cmd:           'uiUpdateNodeProgress',         nodeId:         nodeId,         progress:       progress,         globalProgress: parse.g3639 / parse.y3640,         updateGlobal:   updateGlobal     }); }    function y2079(nodeId, endGlobal) {     i2052(     {         cmd:      'uiEndNodeProgress',         nodeId:    nodeId,         endGlobal: endGlobal     }); }    async function genGetObjectSizeFromFigma(a111)  {     return new Promise((resolve, reject) =>      {         const timeout = 1000;          r2051(         {             cmd: 'uiForwardToFigma',             msg:               {                 cmd:   'figGetObjectSize',                 object: a111             }         });          const q2742 = setTimeout(() =>              reject(new Error('Timeout: Result not received within the specified time')),             timeout);          function o4031(event)          {             const msg = JSON.parse(event.data);              if (msg.cmd === 'returnFigGetObjectSize')              {                 clearTimeout(q2742);                                  const { objectId, width, height } = msg;                 resolve({ objectId, width, height });                  self.removeEventListener('message', o4031);             }         }          self.addEventListener('message', o4031);     }); }    async function genGetValueFromUi(key)  {     return new Promise((resolve, reject) =>      {         const timeout = 60000;          r2051(         {             cmd: 'uiGetValueForGenerator',             key:  key          });          const q2742 = setTimeout(() =>              reject(new Error('Timeout: Result not received by Generator within the specified time')),             timeout);          function o4031(event)          {             const msg = JSON.parse(event.data);              if (msg.cmd === 'returnUiGetValueForGenerator')              {                 clearTimeout(q2742);                  resolve(                 {                      key:   msg.key,                      value: msg.value                  });                  self.removeEventListener('message', o4031);             }         }          self.addEventListener('message', o4031);     }); }


function l1623(parse) {     parse.pos++;       const col = parse.move();      if (parse.settings.logRequests)          e2131(x1168, col, parse);      return s2866(col)[0]; }    function a1624(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const col = new n1815(nodeId, options);      col.z3265 = options.z3265;             let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(col, parse, ignore, a4209);       if (ignore)      {         z1791(parse, col);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;           let j3092;      if (a4209 == 1)     {         col.input = a1788(parse);         j3092 = parse.move().split(',');     }     else         j3092 = ['space', 'convert', 'c1', 'c2', 'c3'];       parse.i1789 = false;          for (const id of j3092)     {         switch (id)         {         case 'space':   col.space        = a1788(parse);  break;         case 'convert': col.convert      = a1788(parse);  break;         case 'c1':      col.p3684 = col.c1 = a1788(parse);  break;         case 'c2':      col.r3685 = col.c2 = a1788(parse);  break;         case 'c3':      col.g3686 = col.c3 = a1788(parse);  break;         }     }           parse.v3647--;       z1791(parse, col);     return col; }    function q1625(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const valid = new t1822(nodeId, options);       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(valid, parse, ignore, a4209);       if (ignore)      {         z1791(parse, valid);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         valid.input = a1788(parse);       valid.quality = a1788(parse);     valid.value   = a1788(parse);       parse.v3647--;       z1791(parse, valid);     return valid; }    function k1626(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const corr = new t1821(nodeId, options);      corr.z3265 = options.z3265;       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(corr, parse, ignore, a4209);       if (ignore)      {         z1791(parse, corr);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       let j3092;      if (a4209 == 1)         corr.input = a1788(parse);       j3092 = parse.move().split(',');      parse.i1789 = false;          for (const id of j3092)     {         switch (id)         {         case 'order':  corr.g3683 = corr.order = a1788(parse);  break;         case 'c1':     corr.p3684    = corr.c1    = a1788(parse);  break;         case 'c2':     corr.r3685    = corr.c2    = a1788(parse);  break;         case 'c3':     corr.g3686    = corr.c3    = a1788(parse);  break;         case 'value':  corr.value               = a1788(parse);  break;         }     }                       parse.v3647--;       z1791(parse, corr);     return corr; }    function i1627(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const cnt = new i1818(nodeId, options);       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 2, 'nInputs must be [0, 2]');     }       const c3682 =          a4209 == 1         ? parseInt(parse.move())         : -1;           if (parse.settings.logRequests)          b2130(cnt, a4209, c3682, parse, ignore);       if (ignore)      {         z1791(parse, cnt);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 2)     {         cnt.e4083   = a1788(parse);         cnt.j4084   = a1788(parse);     }     else if (a4209 == 1)     {              if (c3682 == 0) cnt.e4083 = a1788(parse);          else if (c3682 == 1) cnt.j4084 = a1788(parse);      }         cnt.standard = a1788(parse);       parse.v3647--;       z1791(parse, cnt);     return cnt; }    function f1628(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const convert = new v1820(nodeId, options);       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(convert, parse, ignore, a4209);       if (ignore)      {         z1791(parse, convert);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         convert.input = a1788(parse);       convert.from = a1788(parse);       parse.v3647--;       z1791(parse, convert);     return convert; }    function y1629(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const cb = new j1817(nodeId, options);       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(cb, parse, ignore, a4209);       if (ignore)      {         z1791(parse, cb);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         cb.input = a1788(parse);      cb.l = a1788(parse);     cb.m = a1788(parse);     cb.s = a1788(parse);           parse.v3647--;       z1791(parse, cb);     return cb; }    function b1630(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const b1035 = new t1819(nodeId, options);       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.logRequests)          i2124(b1035, parse, ignore, a4209);       if (ignore)      {         z1791(parse, b1035);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 2)     {         b1035.e4083 = a1788(parse);         b1035.j4084 = a1788(parse);     }      else if (a4209 == 1)         b1035.e4083 = a1788(parse);       else if (a4209 != 0)         j953('nInputs must be [0, 2]');       b1035.space  = a1788(parse);     b1035.amount = a1788(parse);     b1035.gamma  = a1788(parse);       parse.v3647--;       z1791(parse, b1035);     return b1035; }    function c1631(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const blend = new k1816(nodeId, options);       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.logRequests)          i2124(blend, parse, ignore, a4209);       if (ignore)      {         z1791(parse, blend);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 2)     {         blend.e4083 = a1788(parse);         blend.j4084 = a1788(parse);     }      else if (a4209 == 1)         blend.e4083 = a1788(parse);       else if (a4209 != 0)         j953('nInputs must be [0, 2]');       blend.mode    = a1788(parse);     blend.opacity = a1788(parse);       parse.v3647--;       z1791(parse, blend);     return blend; }    function k1669(parse) {     parse.pos++;       const grad = parse.move();      if (parse.settings.logRequests)          e2131(i1187, grad, parse);      return c3676(grad)[0]; }    function i1670(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const grad = new o1890(nodeId, options);      grad.z3265 = options.z3265;       let a4209 = 0;          if (!ignore)         a4209 = parseInt(parse.move());       if (parse.settings.logRequests)          i2124(grad, parse, ignore, a4209);       if (ignore)     {         z1791(parse, grad);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       for (let i = 0; i < a4209; i++)         grad.inputs.push(a1788(parse));       const w3668 = p1793(parse);       for (let i = 0; i < w3668; i++)     {         const p2992 = p1795(parse);          parse.i1789 = true;          switch (p2992)         {         case 'gradType': grad.x3687 = a1788(parse); break;         case 'position': grad.position = a1788(parse); break;         case 'x':        grad.x        = a1788(parse); break;         case 'y':        grad.y        = a1788(parse); break;         case 'size':     grad.size     = a1788(parse); break;         case 'angle':    grad.angle    = a1788(parse); break;         case 'aspect':   grad.aspect   = a1788(parse); break;         case 'skew':     grad.skew     = a1788(parse); break;         case 'blend':    grad.blend    = a1788(parse); break;         }     }                                                         grad.diagAspect = parseInt(parse.move()) > 0;       parse.i1789 = false;     parse.v3647--;       z1791(parse, grad);     return grad; }                function v1671(parse) {     parse.pos++;       const stop = parse.move();      if (parse.settings.logRequests)          e2131(r1184, stop, parse);      return l2867(stop)[0]; }    function j1672(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const stop = new w1886(nodeId, options);      stop.z3265 = options.z3265;       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(stop, parse, ignore, a4209);       if (ignore)     {         z1791(parse, stop);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       let j3092;      if (a4209 == 1)     {         stop.input = a1788(parse);         j3092 = parse.move().split(',');     }     else         j3092 = ['fill', 'position'];       parse.i1789 = false;      for (const id of j3092)     {         switch (id)         {         case 'fill':     stop.fill     = a1788(parse); break;         case 'position': stop.position = a1788(parse); break;         }     }               parse.v3647--;       z1791(parse, stop);     return stop; }


function v1632(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const _null = new q1866(nodeId, options);       let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(_null, parse, ignore, a4209);       if (ignore)      {         z1791(parse, _null);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         _null.input = a1788(parse);       parse.v3647--;       z1791(parse, _null);     return _null; }    function s1633(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const variable = new t1881(nodeId, options);      variable.existing = options.existing;       if (parse.settings.logRequests)          i2124(variable, parse, ignore);       if (ignore)      {         z1791(parse, variable);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;     parse.i1789 = false;       const y3679 = parseInt(parse.move());      if (y3679 == 1)         variable.varValue = a1788(parse);           parse.v3647--;           variable.linked = variable.id != NULL;       z1791(parse, variable);     return variable; }    function j1634(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const group = new z1882(nodeId, options);           let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(group, parse, ignore, a4209);       if (ignore)      {         z1791(parse, group);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         group.input = a1788(parse);       parse.v3647--;       z1791(parse, group);     return group; }    function e1635(parse) {     parse.pos++;       const list = parse.move();      if (parse.settings.logRequests)          e2131(y1056, list, parse);      return u3482(list)[0]; }    function i1636(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const cmb = new d1857(nodeId, options);           let a4209 = 0;          if (!ignore)         a4209 = parseInt(parse.move());       if (parse.settings.logRequests)          i2124(cmb, parse, ignore, a4209);       if (ignore)      {         z1791(parse, cmb);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;           for (let i = 0; i < a4209; i++)         cmb.inputs.push(a1788(parse));       parse.v3647--;               z1791(parse, cmb);     return cmb; }    function a1637(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const listAsItem = new w1858(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(listAsItem, parse, ignore, a4209);       if (ignore)      {         z1791(parse, listAsItem);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         listAsItem.input = a1788(parse);           parse.v3647--;       z1791(parse, listAsItem);     return listAsItem; }    function t1638(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const extr = new j1860(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(extr, parse, ignore, a4209);       if (ignore)      {         z1791(parse, extr);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         extr.input = a1788(parse);      extr.indices = a1788(parse);           parse.v3647--;       z1791(parse, extr);     return extr; }    function w1639(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const set = new g1873(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(set, parse, ignore, a4209);       if (ignore)      {         z1791(parse, set);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 2)     {         set.e4083 = a1788(parse);         set.j4084 = a1788(parse);         set.name   = a1788(parse);     }     else if (a4209 == 1)     {         set.e4083 = a1788(parse);          set.name   = a1788(parse);     }     else if (a4209 == 0)     {         set.name   = a1788(parse);     }           parse.v3647--;       z1791(parse, set);     return set; }    function i1640(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const extr = new v1874(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(extr, parse, ignore, a4209);       if (ignore)      {         z1791(parse, extr);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         extr.input = a1788(parse);      extr.name = a1788(parse);           parse.v3647--;       z1791(parse, extr);     return extr; }    function n1641(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const sub = new k1877(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(sub, parse, ignore, a4209);       if (ignore)      {         z1791(parse, sub);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         sub.input = a1788(parse);      sub.start = a1788(parse);     sub.end   = a1788(parse);           parse.v3647--;       z1791(parse, sub);     return sub; }    function n1642(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const unique = new f1879(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(unique, parse, ignore, a4209);       if (ignore)      {         z1791(parse, unique);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         unique.input = a1788(parse);             parse.v3647--;       z1791(parse, unique);     return unique; }    function v1644(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const shift = new e1869(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(shift, parse, ignore, a4209);       if (ignore)      {         z1791(parse, shift);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         shift.input = a1788(parse);      shift.offset = a1788(parse);           parse.v3647--;       z1791(parse, shift);     return shift; }    function e1645(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const reverse = new l1870(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(reverse, parse, ignore, a4209);       if (ignore)      {         z1791(parse, reverse);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         reverse.input = a1788(parse);             parse.v3647--;       z1791(parse, reverse);     return reverse; }    function genParseBuckleList(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const buckle = new GBuckleList(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(buckle, parse, ignore, a4209);       if (ignore)      {         z1791(parse, buckle);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         buckle.input = a1788(parse);         buckle.amount = a1788(parse);           parse.v3647--;       z1791(parse, buckle);     return buckle; }    function q1643(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const reorder = new x1868(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(reorder, parse, ignore, a4209);       if (ignore)      {         z1791(parse, reorder);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         reorder.input = a1788(parse);       reorder.indices = a1788(parse);           parse.v3647--;       z1791(parse, reorder);     return reorder; }    function y1646(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const sort = new a1875(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(sort, parse, ignore, a4209);       if (ignore)      {         z1791(parse, sort);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         sort.input = a1788(parse);       const nConditions = parseInt(parse.move());      if (nConditions == 1)         sort.condition = a1788(parse);               sort.reverse   = a1788(parse);           parse.v3647--;       z1791(parse, sort);     return sort; }    function n1647(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const filter = new g1861(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(filter, parse, ignore, a4209);       if (ignore)      {         z1791(parse, filter);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         filter.input = a1788(parse);      filter.condition = a1788(parse);           parse.v3647--;       z1791(parse, filter);     return filter; }    function s1648(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const column = new v1856(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(column, parse, ignore, a4209);       if (ignore)      {         z1791(parse, column);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         column.input = a1788(parse);      column.index = a1788(parse);           parse.v3647--;       z1791(parse, column);     return column; }    function e1649(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const cell = new y1855(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(cell, parse, ignore, a4209);       if (ignore)      {         z1791(parse, cell);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         cell.input = a1788(parse);      cell.column = a1788(parse);     cell.row    = a1788(parse);           parse.v3647--;       z1791(parse, cell);     return cell; }    function p1650(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const list = new j1864(nodeId, options);           let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(list, parse, ignore, a4209);       if (ignore)      {         z1791(parse, list);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         list.input = a1788(parse);       parse.v3647--;       z1791(parse, list);     return list; }    function c1651(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const sel = new r1871(nodeId, options);           let a4209 = 0;          if (!ignore)         a4209 = parseInt(parse.move());       if (parse.settings.logRequests)          i2124(sel, parse, ignore, a4209);       if (ignore)      {         z1791(parse, sel);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;           for (let i = 0; i < a4209; i++)         sel.inputs.push(a1788(parse));      sel.index = a1788(parse);       parse.v3647--;               z1791(parse, sel);     return sel; }    function genParseSelectFromList(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const sel = new h1872(nodeId, options);           let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(sel, parse, ignore, a4209);       if (ignore)      {         z1791(parse, sel);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         sel.input = a1788(parse);      sel.index = a1788(parse);           parse.v3647--;       z1791(parse, sel);     return sel; }    function w1652(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const count = new v1865(nodeId, options);           let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(count, parse, ignore, a4209);       if (ignore)      {         z1791(parse, count);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         count.input = a1788(parse);      count.start = a1788(parse);       parse.v3647--;       z1791(parse, count);     return count; }    function genParseObjectCount(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const count = new GObjectCount(nodeId, options);           let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(count, parse, ignore, a4209);       if (ignore)      {         z1791(parse, count);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         count.input = a1788(parse);      count.start = a1788(parse);       parse.v3647--;       z1791(parse, count);     return count; }    function y1653(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const cont = new r1859(nodeId, options);          let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.logRequests)          i2124(cont, parse, ignore, a4209);       if (ignore)      {         z1791(parse, cont);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 2)     {         cont.e4083 = a1788(parse);         cont.j4084 = a1788(parse);     }     else if (a4209 == 1)     {         cont.e4083 = a1788(parse);      }             parse.v3647--;       z1791(parse, cont);     return cont; }    function w1654(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const w3681 = new v1863(nodeId, options);       let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 2, 'nInputs must be [0, 2]');     }       const c3682 =          a4209 == 1         ? parseInt(parse.move())         : -1;       if (parse.settings.logRequests)          i2124(w3681, parse, ignore, a4209);       if (ignore)      {         z1791(parse, w3681);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;      if (a4209 == 2)     {         w3681.e4083    = a1788(parse);         w3681.j4084    = a1788(parse);         w3681.condition = a1788(parse);     }     else if (a4209 == 1)     {              if (c3682 == 0) w3681.e4083 = a1788(parse);          else if (c3682 == 1) w3681.j4084 = a1788(parse);           w3681.condition = a1788(parse);     }     else if (a4209 == 0)     {         w3681.condition = a1788(parse);     }      parse.v3647--;       z1791(parse, w3681);     return w3681; }    function t1655(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const feedback = new z1876(nodeId, options);       let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(feedback, parse, ignore, a4209);       if (ignore)      {         z1791(parse, feedback);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         feedback.input = a1788(parse);       parse.v3647--;       z1791(parse, feedback);     return feedback; }    function k1656(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const repeat = new d1867(nodeId, options);       let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(repeat, parse, ignore, a4209);       if (ignore)      {         z1791(parse, repeat);         return parse.k4243.find(n => n.nodeId == nodeId);     }       repeat.isTerminal  = parseInt(parse.move()) > 0;     repeat.activeAfter = parseInt(parse.move()) > 0;     repeat.listAfter   = parseInt(parse.move()) > 0;       parse.v3647++;       if (a4209 == 1)         repeat.input = a1788(parse);      repeat. count     = a1788(parse);     repeat .iteration = a1788(parse);     repeat.k3680     = a1788(parse);        repeat. loop      = a1788(parse);         parse.v3647--;       z1791(parse, repeat);     return repeat; }    function h1657(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const cache = new i1854(nodeId, options);       let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(cache, parse, ignore, a4209);       if (ignore)      {         z1791(parse, cache);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         cache.input = a1788(parse);       parse.v3647--;       z1791(parse, cache);     return cache; }    function p1658(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const freeze = new q1862(nodeId, options);       let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(freeze, parse, ignore, a4209);       if (ignore)      {         z1791(parse, freeze);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         freeze.input = a1788(parse);       parse.v3647--;       z1791(parse, freeze);     return freeze; }    function j1659(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const timer = new o1878(nodeId, options);       let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(timer, parse, ignore, a4209);       if (ignore)      {         z1791(parse, timer);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         timer.input = a1788(parse);       timer.interval = a1788(parse);     timer.k3680   = a1788(parse);     timer. loop    = a1788(parse);         parse.v3647--;       z1791(parse, timer);     return timer; }    function g1660(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const name = new c1880(nodeId, options);       let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(name, parse, ignore, a4209);       if (ignore)      {         z1791(parse, name);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         name.input = a1788(parse);      name.name = a1788(parse);       parse.v3647--;       z1791(parse, name);     return name; }    function genParseGetListValueNames(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const names = new GGetListValueNames(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(names, parse, ignore, a4209);       if (ignore)      {         z1791(parse, names);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         names.input = a1788(parse);             parse.v3647--;       z1791(parse, names);     return names; }    function genParseListValueNames(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const names = new GListValueNames(nodeId, options);       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 2, 'nInputs must be [0, 2]');     }       const c3682 =          a4209 == 1         ? parseInt(parse.move())         : -1;       if (parse.settings.logRequests)          i2124(names, parse, ignore, a4209);       if (ignore)     {         z1791(parse, names);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;      if (a4209 == 2)     {         names.e4083 = a1788(parse);         names.j4084 = a1788(parse);     }     else if (a4209 == 1)     {              if (c3682 == 0) names.e4083 = a1788(parse);          else if (c3682 == 1) names.j4084 = a1788(parse);      }      parse.v3647--;       z1791(parse, names);     return names; }    function genParseObjectName(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const name = new GObjectName(nodeId, options);       let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(name, parse, ignore, a4209);       if (ignore)      {         z1791(parse, name);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         name.input = a1788(parse);      name.name    = a1788(parse);         parse.v3647--;       z1791(parse, name);     return name; }    function a1661(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const cmnt = new a2040(nodeId, options);           if (parse.settings.logRequests)          i2124(cmnt, parse, ignore);       if (ignore)      {         z1791(parse, cmnt);         return parse.k4243.find(n => n.nodeId == nodeId);     }       z1791(parse, cmnt);     return cmnt; }    function u1662(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const cmnt = new f2041(nodeId, options);           if (parse.settings.logRequests)          i2124(cmnt, parse, ignore);       if (ignore)      {         z1791(parse, cmnt);         return parse.k4243.find(n => n.nodeId == nodeId);     }       z1791(parse, cmnt);     return cmnt; }    function b1663(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const panel = new o2048(nodeId, options);           if (parse.settings.logRequests)          i2124(panel, parse, ignore);       if (ignore)      {         z1791(parse, panel);         return parse.k4243.find(n => n.nodeId == nodeId);     }       z1791(parse, panel);     return panel; }


function s1664(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const group = new e1883(nodeId, options);       let y3679 = -1;          if (!ignore)     {         y3679 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(group, parse, ignore);       if (ignore)     {         z1791(parse, group);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;             for (let i = 0; i < y3679; i++)     {         group.j3092.push(parse.move());         group.params  .push(a1788(parse));     }       parse.v3647--;       z1791(parse, group);     return group; }    function c1665(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const param = new s1884(nodeId, options);       let a4209  = -1;     let a3678 = -1;          if (!ignore)     {         a4209  = parseInt(parse.move());         a3678 = parseInt(parse.move());          l952(a4209  == 0 || a4209  == 1,  'nInputs must be [0, 1]');         l952(a3678 == 0 || a3678 == 1, 'nOutputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(param, parse, ignore);       if (ignore)      {         z1791(parse, param);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)     {         param.input    = a1788(parse);         param.dataType = parse.move();     }     else if (a3678 == 1)         param.dataType = parse.move();       parse.v3647--;       z1791(parse, param);     return param; } 


function g1666(parse) {     parse.pos++;       const fill = parse.move();      if (parse.settings.logRequests)          e2131(k1178, fill, parse);      return k3677(fill)[0]; }    function v1667(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const fill = new c1889(nodeId, options);      fill.z3265 = options.z3265;       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(fill, parse, ignore, a4209);       if (ignore)     {         z1791(parse, fill);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       let j3092;      if (a4209 == 1)     {         fill.input = a1788(parse);         j3092 = parse.move().split(',');     }     else         j3092 = ['color', 'opacity', 'blend'];       parse.i1789 = false;      for (const id of j3092)     {         switch (id)         {         case 'color':   fill.color   = a1788(parse); break;         case 'opacity': fill.opacity = a1788(parse); break;         case 'blend':   fill.blend   = a1788(parse); break;         }     }           parse.v3647--;       z1791(parse, fill);     return fill; }    function g1668(parse) {     const fill = a1788(parse);       if (j1177.includes(fill.type))         fill.options.opacity = a1788(parse);      return fill; }    function i1673(parse) {     parse.pos++;       const stroke = parse.move();      if (parse.settings.logRequests)          e2131(g1181, stroke, parse);      return y3832(stroke)[0]; }    function b1674(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const stroke = new e1896(nodeId, options);      stroke.z3265 = options.z3265;       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(stroke, parse, ignore, a4209);       if (ignore)     {         z1791(parse, stroke);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       let j3092;      if (a4209 == 1)     {         stroke.input = a1788(parse);         j3092 = parse.move().split(',');     }     else         j3092 = ['fill', 'weight', 'fit', 'join', 'miter', 'cap', 'dashes'];       parse.i1789 = false;      for (const id of j3092)     {         switch (id)         {         case 'fill':   stroke.c3675 = a1788(parse); stroke.fills = stroke.c3675; break;         case 'weight': stroke.weight = a1788(parse); break;         case 'fit':    stroke.fit    = a1788(parse); break;         case 'join':   stroke.join   = a1788(parse); break;         case 'miter':  stroke.miter  = a1788(parse); break;         case 'cap':    stroke.cap    = a1788(parse); break;         case 'dashes': stroke.dashes = a1788(parse); break;         }     }               parse.v3647--;       z1791(parse, stroke);     return stroke; }    function v1675(parse) {     const stroke = a1788(parse);       if (    r1180.includes(stroke.type)         || j1177.includes(stroke.type))         stroke.data.weight = a1788(parse);      return stroke; }    function genParseStrokeSidesValue(parse) {     parse.pos++;       const sides = parse.move();      if (parse.settings.logRequests)          e2131(p1190, sides, parse);      return parseStrokeSidesValue(sides)[0]; }    function genParseStrokeSides(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const sides = new GStrokeSides(nodeId, options);      sides.z3265 = options.z3265;       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(sides, parse, ignore, a4209);       if (ignore)     {         z1791(parse, sides);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       let j3092;      if (a4209 == 1)     {         sides.input = a1788(parse);         j3092 = parse.move().split(',');     }     else         j3092 = ['top', 'left', 'right', 'bottom'];       parse.i1789 = false;      for (const id of j3092)     {         switch (id)         {         case 'top':    sides.top    = a1788(parse); break;         case 'left':   sides.left   = a1788(parse); break;         case 'right':  sides.right  = a1788(parse); break;         case 'bottom': sides.bottom = a1788(parse); break;         }     }               parse.v3647--;       z1791(parse, sides);     return sides; }    function n1676(parse) {     parse.pos++;       const corners = parse.move();      if (parse.settings.logRequests)          e2131(p1193, corners, parse);      return d3838(corners)[0]; }    function n1677(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const corners = new q1895(nodeId, options);      corners.z3265 = options.z3265;       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(corners, parse, ignore, a4209);       if (ignore)     {         z1791(parse, corners);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       let j3092;      if (a4209 == 1)     {         corners.input = a1788(parse);         j3092 = parse.move().split(',');     }     else         j3092 = ['tl', 'tr', 'bl', 'br'];       parse.i1789 = false;      for (const id of j3092)     {         switch (id)         {         case 'tl': corners.tl = a1788(parse); break;         case 'tr': corners.tr = a1788(parse); break;         case 'bl': corners.bl = a1788(parse); break;         case 'br': corners.br = a1788(parse); break;         }     }               parse.v3647--;       z1791(parse, corners);     return corners; }    function q1678(parse) {     parse.pos++;       const shadow = parse.move();      if (parse.settings.logRequests)          e2131(g1196, shadow, parse);      return j3833(shadow)[0]; }    function v1679(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const shadow = new v1888(nodeId, options);      shadow.z3265 = options.z3265;       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(shadow, parse, ignore, a4209);       if (ignore)     {         z1791(parse, shadow);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       let j3092;      if (a4209 == 1)     {         shadow.input = a1788(parse);         j3092 = parse.move().split(',');     }     else         j3092 = ['x', 'y', 'blur', 'spread', 'fill', 'blend', 'behind'];       parse.i1789 = false;      for (const id of j3092)     {         switch (id)         {         case 'x':      shadow.x      = a1788(parse); break;         case 'y':      shadow.y      = a1788(parse); break;         case 'blur':   shadow.blur   = a1788(parse); break;         case 'spread': shadow.spread = a1788(parse); break;         case 'fill':   shadow.fill   = a1788(parse); break;         case 'blend':  shadow.blend  = a1788(parse); break;         case 'behind': shadow.behind = a1788(parse); break;         }     }               parse.v3647--;       z1791(parse, shadow);     return shadow; }    function r1680(parse) {     parse.pos++;       const shadow = parse.move();      if (parse.settings.logRequests)          e2131(w1199, shadow, parse);      return s3834(shadow)[0]; }    function w1681(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const shadow = new y1891(nodeId, options);      shadow.z3265 = options.z3265;       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(shadow, parse, ignore, a4209);       if (ignore)     {         z1791(parse, shadow);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       let j3092;      if (a4209 == 1)     {         shadow.input = a1788(parse);         j3092 = parse.move().split(',');     }     else         j3092 = ['x', 'y', 'blur', 'spread', 'fill', 'blend'];       parse.i1789 = false;      for (const id of j3092)     {         switch (id)         {         case 'x':      shadow.x      = a1788(parse); break;         case 'y':      shadow.y      = a1788(parse); break;         case 'blur':   shadow.blur   = a1788(parse); break;         case 'spread': shadow.spread = a1788(parse); break;         case 'fill':   shadow.fill   = a1788(parse); break;         case 'blend':  shadow.blend  = a1788(parse); break;         }     }               parse.v3647--;       z1791(parse, shadow);     return shadow; }    function p1682(parse) {     parse.pos++;       const blur = parse.move();      if (parse.settings.logRequests)          e2131(c1202, blur, parse);      return r3835(blur)[0]; }    function a1683(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const blur = new j1893(nodeId, options);      blur.z3265 = options.z3265;       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(blur, parse, ignore, a4209);       if (ignore)     {         z1791(parse, blur);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       let j3092;      if (a4209 == 1)     {         blur.input = a1788(parse);         j3092 = parse.move().split(',');     }     else         j3092 = ['radius'];       parse.i1789 = false;      for (const id of j3092)     {         switch (id)         {         case 'radius': blur.radius = a1788(parse); break;         }     }               parse.v3647--;       z1791(parse, blur);     return blur; }    function i1684(parse) {     parse.pos++;       const blur = parse.move();      if (parse.settings.logRequests)          e2131(t1205, blur, parse);      return o3707(blur)[0]; }    function z1685(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const blur = new w1885(nodeId, options);      blur.z3265 = options.z3265;       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(blur, parse, ignore, a4209);       if (ignore)     {         z1791(parse, blur);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       let j3092;      if (a4209 == 1)     {         blur.input = a1788(parse);         j3092 = parse.move().split(',');     }     else         j3092 = ['radius'];       parse.i1789 = false;      for (const id of j3092)     {         switch (id)         {         case 'radius': blur.radius = a1788(parse); break;         }     }               parse.v3647--;       z1791(parse, blur);     return blur; }    function g1686(parse) {     parse.pos++;       const layer = parse.move();      if (parse.settings.logRequests)          e2131(v1211, layer, parse);      return k3708(layer)[0]; }    function x1687(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const layer = new w1892(nodeId, options);       if (parse.settings.logRequests)          i2124(layer, parse, ignore);       if (ignore)     {         z1791(parse, layer);         return parse.k4243.find(n => n.nodeId == nodeId);     }       layer.opacity = a1788(parse);     layer.blend   = a1788(parse);               z1791(parse, layer);     return layer; }    function w1688(parse) {     parse.pos++;       const mask = parse.move();      if (parse.settings.logRequests)          e2131(c1208, mask, parse);      return t3709(mask)[0]; }    function p1689(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const mask = new r1894(nodeId, options);       if (parse.settings.logRequests)          i2124(mask, parse, ignore);       if (ignore)     {         z1791(parse, mask);         return parse.k4243.find(n => n.nodeId == nodeId);     }       mask.maskType = a1788(parse);               z1791(parse, mask);     return mask; }


function a1691(parse) {     parse.pos++;       const val = parse.move();      if (parse.settings.logRequests)          e2131(t1091, val, parse);      return val.indexOf(',') >= 0          ? g2850      (val)[0]          : y3836(val)[0]; }    function k1692(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const num = new y1936(nodeId, options);           if (parse.settings.logRequests)          i2124(num, parse, ignore);       if (ignore)      {         z1791(parse, num);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;     parse.i1789 = false;       if (parse.next == t1091) num.value = a1788(parse);     else                            num.input = a1788(parse);       parse.v3647--;       z1791(parse, num);     return num; }    function genParseSetPrecision(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const prec = new GSetPrecision(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(prec, parse, ignore, a4209);       if (ignore)      {         z1791(parse, prec);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         prec.input = a1788(parse);      prec.decimals = a1788(parse);           parse.v3647--;       z1791(parse, prec);     return prec; }    function k1693(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const m3674 = new y1927(nodeId, options);       if (parse.settings.logRequests)          i2124(m3674, parse, ignore);       if (ignore)      {         z1791(parse, m3674);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       m3674.constant = a1788(parse);       parse.v3647--;       z1791(parse, m3674);     return m3674; }    function p1694(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const dateTime = new e1929(nodeId, options);       if (parse.settings.logRequests)          i2124(dateTime, parse, ignore);       if (ignore)      {         z1791(parse, dateTime);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       dateTime.seconds   = a1788(parse);     dateTime.minutes   = a1788(parse);     dateTime.hours     = a1788(parse);     dateTime.dayOfWeek = a1788(parse);     dateTime.date      = a1788(parse);     dateTime.month     = a1788(parse);     dateTime.year      = a1788(parse);       parse.v3647--;       z1791(parse, dateTime);     return dateTime; }    function i1695(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const sign = new o1943(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(sign, parse, ignore);       if (ignore)      {         z1791(parse, sign);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         sign.input = a1788(parse);           parse.v3647--;       z1791(parse, sign);     return sign; }    function s1696(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const abs = new p1924(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(abs, parse, ignore);       if (ignore)      {         z1791(parse, abs);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         abs.input = a1788(parse);           parse.v3647--;       z1791(parse, abs);     return abs; }    function genParseNegative(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const neg = new GNegative(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(neg, parse, ignore);       if (ignore)      {         z1791(parse, neg);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         neg.input = a1788(parse);           parse.v3647--;       z1791(parse, neg);     return neg; }    function l1697(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const round = new p1941(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(round, parse, ignore, a4209);       if (ignore)      {         z1791(parse, round);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         round.input = a1788(parse);      round.type     = a1788(parse);     round.decimals = a1788(parse);           parse.v3647--;       z1791(parse, round);     return round; }    function genParseQuantize(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const quant = new GQuantize(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(quant, parse, ignore, a4209);       if (ignore)      {         z1791(parse, quant);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         quant.input = a1788(parse);      quant.type   = a1788(parse);     quant.base   = a1788(parse);     quant.step   = a1788(parse);     quant.amount = a1788(parse);           parse.v3647--;       z1791(parse, quant);     return quant; }    function x1698(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const j3673 = new e1944(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(j3673, parse, ignore, a4209);       if (ignore)      {         z1791(parse, j3673);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         j3673.input = a1788(parse);      j3673.operand   = a1788(parse);     j3673.operation = a1788(parse);           parse.v3647--;       z1791(parse, j3673);     return j3673; }    function s1699(parse) {     const [type, nodeId, options, ignore] = l1790(parse);       const k3672 = new i1933(nodeId, options);           let a4209 = 0;          if (!ignore)         a4209 = parseInt(parse.move());       if (parse.settings.logRequests)          i2124(k3672, parse, ignore, a4209);       if (ignore)      {         z1791(parse, k3672);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;      for (let i = 0; i < a4209; i++)         k3672.inputs.push(a1788(parse));       k3672.operation = a1788(parse);       parse.v3647--;               z1791(parse, k3672);     return k3672; }    function y1700(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const limits = new m1932(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(limits, parse, ignore, a4209);       if (ignore)      {         z1791(parse, limits);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         limits.input = a1788(parse);      limits.min = a1788(parse);     limits.max = a1788(parse);           parse.v3647--;       z1791(parse, limits);     return limits; }    function c1701(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const curve = new d1937(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(curve, parse, ignore, a4209);       if (ignore)      {         z1791(parse, curve);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         curve.input = a1788(parse);      curve.min    = a1788(parse);     curve.max    = a1788(parse);     curve.power  = a1788(parse);           parse.v3647--;       z1791(parse, curve);     return curve; }    function genParseNumberMap(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const map = new GNumberMap(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(map, parse, ignore, a4209);       if (ignore)      {         z1791(parse, map);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         map.input = a1788(parse);      map.from = a1788(parse);     map.to   = a1788(parse);           parse.v3647--;       z1791(parse, map);     return map; }    function genParseNumberBias(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const bias = new GNumberBias(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(bias, parse, ignore, a4209);       if (ignore)      {         z1791(parse, bias);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         bias.input = a1788(parse);      bias.min    = a1788(parse);     bias.max    = a1788(parse);     bias.bias   = a1788(parse);     bias.spread = a1788(parse);           parse.v3647--;       z1791(parse, bias);     return bias; }    function g1702(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const y3671 = new j1934(nodeId, options);       let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(y3671, parse, ignore, a4209);       if (ignore)      {         z1791(parse, y3671);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         y3671.input = a1788(parse);      y3671._value = a1788(parse);      parse.v3647--;       z1791(parse, y3671);     return y3671; }    function h1703(parse, u1690) {     const [type, nodeId, options, ignore] = l1790(parse);       const math = u1690(nodeId, options);           let a4209 = 0;          if (!ignore)         a4209 = parseInt(parse.move());       if (parse.settings.logRequests)          i2124(math, parse, ignore, a4209);       if (ignore)      {         z1791(parse, math);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;      for (let i = 0; i < a4209; i++)         math.inputs.push(a1788(parse));       math.operation = a1788(parse);       parse.v3647--;               z1791(parse, math);     return math; }    function w1704(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const smath = new m1905(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(smath, parse, ignore, a4209);       if (ignore)      {         z1791(parse, smath);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         smath.input = a1788(parse);      smath.operation = a1788(parse);     smath.operand   = a1788(parse);     smath.invert    = a1788(parse);           parse.v3647--;       z1791(parse, smath);     return smath; }    function t1705(parse, u1690) {     const [type, nodeId, options, ignore] = l1790(parse);       const arith = u1690(nodeId, options);       let a4209 = 0;          if (!ignore)         a4209 = parseInt(parse.move());       if (parse.settings.logRequests)          i2124(arith, parse, ignore, a4209);       if (ignore)      {         z1791(parse, arith);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;      for (let i = 0; i < a4209; i++)         arith.inputs.push(a1788(parse));      parse.v3647--;               z1791(parse, arith);     return arith; }    function s1706(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const convert = new p1928(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(convert, parse, ignore, a4209);       if (ignore)      {         z1791(parse, convert);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         convert.input = a1788(parse);      convert.from = a1788(parse);           parse.v3647--;       z1791(parse, convert);     return convert; }    function genParseIterate(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const define = new w1930(nodeId, options);       let a4209 = 0;          if (!ignore)         a4209 = parseInt(parse.move());       if (parse.settings.logRequests)          i2124(define, parse, ignore, a4209);       if (ignore)      {         z1791(parse, define);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;           for (let i = 0; i < a4209; i++)         define.inputs.push(a1788(parse));       parse.v3647--;       z1791(parse, define);     return define; }    function x1708(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const dist = new r1940(nodeId, options);       if (parse.settings.logRequests)          i2124(dist, parse, ignore);       if (ignore)      {         z1791(parse, dist);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       dist.from   = a1788(parse);     dist.start  = a1788(parse);     dist.end    = a1788(parse);       parse.v3647--;       z1791(parse, dist);     return dist; }    function b1709(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const wave = new i1946(nodeId, options);       if (parse.settings.logRequests)          i2124(wave, parse, ignore);       if (ignore)      {         z1791(parse, wave);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       wave.shape     = a1788(parse);     wave.base      = a1788(parse);     wave.amplitude = a1788(parse);     wave.frequency = a1788(parse);     wave.offset    = a1788(parse);     wave.bias      = a1788(parse);       wave.useWavelength  = parseInt(parse.move()) > 0;     wave.offsetAbsolute = parseInt(parse.move()) > 0;       parse.v3647--;       z1791(parse, wave);     return wave; }    function g1710(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const seq = new v1942(nodeId, options);       if (parse.settings.logRequests)          i2124(seq, parse, ignore);       if (ignore)      {         z1791(parse, seq);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       seq.start    = a1788(parse);     seq.multiply = a1788(parse);     seq.add      = a1788(parse);     seq.end      = a1788(parse);       parse.v3647--;       z1791(parse, seq);     return seq; }    function w1711(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const rnd = new g1939(nodeId, options);       if (parse.settings.logRequests)          i2124(rnd, parse, ignore);       if (ignore)      {         z1791(parse, rnd);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       rnd.seed      = a1788(parse);     rnd.iteration = a1788(parse);     rnd.min       = a1788(parse);     rnd.max       = a1788(parse);     rnd.bias      = a1788(parse);     rnd.spread    = a1788(parse);     rnd.unique    = a1788(parse);       parse.v3647--;       z1791(parse, rnd);     return rnd; }    function r1712(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const noise = new o1935(nodeId, options);       if (parse.settings.logRequests)          i2124(noise, parse, ignore);       if (ignore)      {         z1791(parse, noise);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       noise.seed        = a1788(parse);     noise.iteration   = a1788(parse);     noise.min         = a1788(parse);     noise.max         = a1788(parse);     noise.scale       = a1788(parse);     noise.offset      = a1788(parse);     noise.evolve      = a1788(parse);     noise.interpolate = a1788(parse);     noise.detail      = a1788(parse);       parse.v3647--;       z1791(parse, noise);     return noise; }    function u1713(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const prob = new x1938(nodeId, options);       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 2, 'nInputs must be [0, 2]');     }       const c3682 =          a4209 == 1         ? parseInt(parse.move())         : -1;       if (parse.settings.logRequests)          i2124(prob, parse, ignore, a4209);       if (ignore)      {         z1791(parse, prob);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 2)     {         prob.e4083   = a1788(parse);         prob.j4084   = a1788(parse);     }     else if (a4209 == 1)     {              if (c3682 == 0) prob.e4083 = a1788(parse);          else if (c3682 == 1) prob.j4084 = a1788(parse);      }       prob.seed      = a1788(parse);     prob.iteration = a1788(parse);     prob.chance    = a1788(parse);     prob.alternate = a1788(parse);       parse.v3647--;       z1791(parse, prob);     return prob; }    function s1714(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const accum = new n1925(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(accum, parse, ignore, a4209);       if (ignore)      {         z1791(parse, accum);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         accum.input = a1788(parse);      accum.when = a1788(parse);               parse.v3647--;       z1791(parse, accum);     return accum; }    function genParseHold(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const hold = new GHold(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(hold, parse, ignore, a4209);       if (ignore)      {         z1791(parse, hold);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         hold.input = a1788(parse);      hold.first = a1788(parse);               parse.v3647--;       z1791(parse, hold);     return hold; }    function j1715(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const b1035 = new a1931(nodeId, options);       let a4209 = 0;          if (!ignore)         a4209 = parseInt(parse.move());       if (parse.settings.logRequests)          i2124(b1035, parse, ignore, a4209);       if (ignore)      {         z1791(parse, b1035);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;      for (let i = 0; i < a4209; i++)         b1035.inputs.push(a1788(parse));       b1035.amount = a1788(parse);     b1035.degree = a1788(parse);       parse.v3647--;       z1791(parse, b1035);     return b1035; }    function k1716(parse) {     const [type, nodeId, options, ignore] = l1790(parse);       const bool = new i1908(nodeId, options);           let a4209 = 0;          if (!ignore)         a4209 = parseInt(parse.move());       if (parse.settings.logRequests)          i2124(bool, parse, ignore, a4209);       if (ignore)      {         z1791(parse, bool);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;      for (let i = 0; i < a4209; i++)         bool.inputs.push(a1788(parse));       bool.operation = a1788(parse);       parse.v3647--;               z1791(parse, bool);     return bool; }    function u1717(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const cond = new p1912(nodeId, options);       let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(cond, parse, ignore, a4209);       if (ignore)      {         z1791(parse, cond);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         cond.input = a1788(parse);             cond.operation = a1788(parse);     cond.operand   = a1788(parse);       parse.v3647--;       z1791(parse, cond);     return cond; }    function t1718(parse, u1690) {     const [type, nodeId, options, ignore] = l1790(parse);       const cond = u1690(nodeId, options);       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.logRequests)         i2124(cond, parse, ignore, a4209);        if (ignore)      {         z1791(parse, cond);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;      if (a4209 == 2)     {         cond.e4083 = a1788(parse);         cond.j4084 = a1788(parse);     }     else if (a4209 == 1)     {         cond.e4083 = a1788(parse);      }      parse.v3647--;       z1791(parse, cond);     return cond; }    function t1719(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const trig = new v1923(nodeId, options);       let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(trig, parse, ignore, a4209);       if (ignore)      {         z1791(parse, trig);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         trig.input = a1788(parse);      trig.function = a1788(parse);      parse.v3647--;       z1791(parse, trig);     return trig; }    function w1720(parse, u1690) {     const [type, nodeId, options, ignore] = l1790(parse);       const trig = u1690(nodeId, options);       let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)         i2124(trig, parse, ignore, a4209);        if (ignore)      {         z1791(parse, trig);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         trig.input = a1788(parse);       parse.v3647--;       z1791(parse, trig);     return trig; }    function i1721(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const atan2 = new n1919(nodeId, options);              if (parse.settings.logRequests)          i2124(atan2, parse, ignore);       if (ignore)      {         z1791(parse, atan2);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       atan2.x = a1788(parse);     atan2.y = a1788(parse);           parse.v3647--;       z1791(parse, atan2);     return atan2; }    function z1722(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const solve = new e1945(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(solve, parse, ignore, a4209);       if (ignore)      {         z1791(parse, solve);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         solve.input = a1788(parse);      solve.current = a1788(parse);     solve.target  = a1788(parse);           parse.v3647--;       z1791(parse, solve);     return solve; }    function q1723(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const anim = new v1926(nodeId, options);       if (parse.settings.logRequests)          i2124(anim, parse);       if (ignore)      {         z1791(parse, anim);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       anim.from   = a1788(parse);     anim.to     = a1788(parse);     anim.curve  = a1788(parse);     anim.repeat = a1788(parse);     anim.length = a1788(parse);     anim.time   = a1788(parse);       parse.v3647--;       z1791(parse, anim);     return anim; } 


function q1724(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const rect = new b1969(nodeId, options);       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(rect, parse, ignore);       if (ignore)      {         z1791(parse, rect);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         rect.input = a1788(parse);       const w3668 = p1793(parse);      for (let i = 0; i < w3668; i++)     {         const p2992 = p1795(parse);          parse.i1789 = true;          switch (p2992)         {         case 'x':      rect.x      = a1788(parse); break;         case 'y':      rect.y      = a1788(parse); break;         case 'width':  rect.width  = a1788(parse); break;         case 'height': rect.height = a1788(parse); break;         case 'round':  rect.round  = a1788(parse); break;         case 'props':  rect.props  = a1788(parse); break;         }     }       parse.i1789 = false;     parse.v3647--;       z1791(parse, rect);     return rect; }                                                                     function i1725(parse) {     const [, nodeId, options, ignore] = l1790(parse);         const line = new q1960(nodeId, options);       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(line, parse, ignore);       if (ignore)      {         z1791(parse, line);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         line.input = a1788(parse);       const w3668 = p1793(parse);      for (let i = 0; i < w3668; i++)     {         const p2992 = p1795(parse);          parse.i1789 = true;          switch (p2992)         {         case 'x':     line.x     = a1788(parse); break;         case 'y':     line.y     = a1788(parse); break;         case 'width': line.width = a1788(parse); break;         case 'props': line.props = a1788(parse); break;         }     }       parse.i1789 = false;     parse.v3647--;       z1791(parse, line);     return line; }    function l1726(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const ellipse = new g1956(nodeId, options);       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(ellipse, parse, ignore);       if (ignore)      {         z1791(parse, ellipse);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         ellipse.input = a1788(parse);       const w3668 = p1793(parse);      for (let i = 0; i < w3668; i++)     {         const p2992 = p1795(parse);          parse.i1789 = true;          switch (p2992)         {         case 'position': ellipse.position = a1788(parse); break;         case 'x':        ellipse.x        = a1788(parse); break;         case 'y':        ellipse.y        = a1788(parse); break;         case 'width':    ellipse.width    = a1788(parse); break;         case 'height':   ellipse.height   = a1788(parse); break;         case 'round':    ellipse.round    = a1788(parse); break;         case 'start':    ellipse.start    = a1788(parse); break;         case 'sweep':    ellipse.sweep    = a1788(parse); break;         case 'inner':    ellipse.inner    = a1788(parse); break;         case 'props':    ellipse.props    = a1788(parse); break;         }     }               ellipse.innerAbsolute  = parseInt(parse.move()) > 0;     ellipse.sweepInDegrees = parseInt(parse.move()) > 0;       parse.i1789 = false;     parse.v3647--;       z1791(parse, ellipse);     return ellipse; }    function z1727(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const trapeze = new e1980(nodeId, options);       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(trapeze, parse, ignore);       if (ignore)      {         z1791(parse, trapeze);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         trapeze.input = a1788(parse);       const w3668 = p1793(parse);      for (let i = 0; i < w3668; i++)     {         const p2992 = p1795(parse);          parse.i1789 = true;          switch (p2992)         {         case 'x':      trapeze.x      = a1788(parse); break;         case 'y':      trapeze.y      = a1788(parse); break;         case 'width':  trapeze.width  = a1788(parse); break;         case 'height': trapeze.height = a1788(parse); break;         case 'round':  trapeze.round  = a1788(parse); break;         case 'bias':   trapeze.bias   = a1788(parse); break;         case 'props':  trapeze.props  = a1788(parse); break;         }     }               parse.i1789 = false;     parse.v3647--;       z1791(parse, trapeze);     return trapeze; }    function s1728(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const poly = new h1968(nodeId, options);       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(poly, parse, ignore);       if (ignore)      {         z1791(parse, poly);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         poly.input = a1788(parse);       const w3668 = p1793(parse);      for (let i = 0; i < w3668; i++)     {         const p2992 = p1795(parse);          parse.i1789 = true;          switch (p2992)         {         case 'position': poly.position = a1788(parse); break;         case 'x':        poly.x        = a1788(parse); break;         case 'y':        poly.y        = a1788(parse); break;         case 'width':    poly.width    = a1788(parse); break;         case 'height':   poly.height   = a1788(parse); break;         case 'round':    poly.round    = a1788(parse); break;         case 'corners':  poly.corners  = a1788(parse); break;         case 'props':    poly.props    = a1788(parse); break;         }     }               parse.i1789 = false;     parse.v3647--;       z1791(parse, poly);     return poly; }    function t1729(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const star = new q1978(nodeId, options);       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(star, parse, ignore);       if (ignore)      {         z1791(parse, star);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         star.input = a1788(parse);       const w3668 = p1793(parse);      for (let i = 0; i < w3668; i++)     {         const p2992 = p1795(parse);          parse.i1789 = true;          switch (p2992)         {         case 'position': star.position = a1788(parse); break;         case 'x':        star.x        = a1788(parse); break;         case 'y':        star.y        = a1788(parse); break;         case 'width':    star.width    = a1788(parse); break;         case 'height':   star.height   = a1788(parse); break;         case 'round':    star.round    = a1788(parse); break;         case 'points':   star.points   = a1788(parse); break;         case 'convex':   star.convex   = a1788(parse); break;         case 'props':    star.props    = a1788(parse); break;         }     }               parse.i1789 = false;     parse.v3647--;       z1791(parse, star);     return star; }    function d1730(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const text = new l1979(nodeId, options);       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(text, parse, ignore);       if (ignore)      {         z1791(parse, text);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         text.input = a1788(parse);       const w3668 = p1793(parse);      for (let i = 0; i < w3668; i++)     {         const p2992 = p1795(parse);          parse.i1789 = true;          switch (p2992)         {                case 'text':          text.text          = a1788(parse); break;         case 'x':             text.x             = a1788(parse); break;         case 'y':             text.y             = a1788(parse); break;         case 'width':         text.width         = a1788(parse); break;         case 'height':        text.height        = a1788(parse); break;         case 'font':          text.font          = a1788(parse); break;         case 'size':          text.size          = a1788(parse); break;         case 'style':         text.style         = a1788(parse); break;         case 'props':         text.props         = a1788(parse); break;         case 'alignX':        text.alignX        = a1788(parse); break;         case 'alignY':        text.alignY        = a1788(parse); break;         case 'lineHeight':    text.lineHeight    = a1788(parse); break;         case 'letterSpacing': text.letterSpacing = a1788(parse); break;         }     }       parse.i1789 = false;     parse.v3647--;       z1791(parse, text);     return text; }    function b1731(parse) {     parse.pos++;       const point = parse.move();      if (parse.settings.logRequests)          e2131(t1245, point, parse);      return n3828(point)[0]; }    function q1732(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const point = new k1964(nodeId, options);       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(point, parse, ignore);       if (ignore)      {         z1791(parse, point);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         point.input = a1788(parse);       const w3668 = p1793(parse);      for (let i = 0; i < w3668; i++)     {         const p2992 = p1795(parse);          parse.i1789 = true;          switch (p2992)         {         case 'x': point.x = a1788(parse); break;         case 'y': point.y = a1788(parse); break;         }     }       parse.i1789 = false;     parse.v3647--;       z1791(parse, point);     return point; }    function x1733(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const corner = new x1965(nodeId, options);       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(corner, parse, ignore);       if (ignore)      {         z1791(parse, corner);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         corner.input = a1788(parse);      corner.smooth = a1788(parse);       parse.i1789 = false;     parse.v3647--;       z1791(parse, corner);     return corner; }    function x1734(parse) {     parse.pos++;       const path = parse.move();      if (parse.settings.logRequests)          e2131(m1249, path, parse);      return h3670(path)[0]; }    function o1735(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const path = new u1984(nodeId, options);       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(path, parse, ignore);       if (ignore)      {         z1791(parse, path);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         path.input = a1788(parse);       const w3668 = p1793(parse);      for (let i = 0; i < w3668; i++)     {         const p2992 = p1795(parse);          parse.i1789 = true;          switch (p2992)         {                case 'points':  path.points  = a1788(parse); break;         case 'closed':  path.closed  = a1788(parse); break;         case 'degree':  path.degree  = a1788(parse); break;         case 'winding': path.winding = a1788(parse); break;         case 'round':   path.round   = a1788(parse); break;         case 'props':   path.props   = a1788(parse); break;         }     }       parse.i1789 = false;     parse.v3647--;       z1791(parse, path);     return path; }    function genParsePathLength(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const len = new GPathLength(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(len, parse, ignore, a4209);       if (ignore)      {         z1791(parse, len);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         len.input = a1788(parse);           parse.v3647--;       z1791(parse, len);     return len; }    function genParseJoinPaths(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const join = new GJoinPaths(nodeId, options);       let a4209 = 0;          if (!ignore)         a4209 = parseInt(parse.move());       if (parse.settings.logRequests)          i2124(join, parse, ignore, a4209);       if (ignore)      {         z1791(parse, join);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       for (let i = 0; i < a4209; i++)         join.inputs.push(a1788(parse));       const w3668 = p1793(parse);      for (let i = 0; i < w3668; i++)     {         const p2992 = p1795(parse);          parse.i1789 = true;          switch (p2992)         {                case 'closed':  join.closed  = a1788(parse); break;         case 'degree':  join.degree  = a1788(parse); break;         case 'winding': join.winding = a1788(parse); break;         case 'round':   join.round   = a1788(parse); break;         case 'props':   join.props   = a1788(parse); break;         }     }       parse.i1789 = false;     parse.v3647--;       z1791(parse, join);     return join; }    function genParseReorientPaths(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const reorient = new GReorientPaths(nodeId, options);       let a4209 = 0;          if (!ignore)         a4209 = parseInt(parse.move());       if (parse.settings.logRequests)          i2124(reorient, parse, ignore, a4209);       if (ignore)      {         z1791(parse, reorient);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       for (let i = 0; i < a4209; i++)         reorient.inputs.push(a1788(parse));       reorient.reverse = a1788(parse);                   parse.i1789 = false;     parse.v3647--;       z1791(parse, reorient);     return reorient; }    function p1736(parse) {     parse.pos++;       const point = parse.move();      if (parse.settings.logRequests)          e2131(c1252, point, parse);      return q3669(point)[0]; }    function i1737(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const point = new e1986(nodeId, options);       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(point, parse, ignore);       if (ignore)      {         z1791(parse, point);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         point.input = a1788(parse);       const w3668 = p1793(parse);      for (let i = 0; i < w3668; i++)     {         const p2992 = p1795(parse);          parse.i1789 = true;          switch (p2992)         {         case 'x':     point.x     = a1788(parse); break;         case 'y':     point.y     = a1788(parse); break;         case 'join':  point.join  = a1788(parse); break;         case 'cap':   point.cap   = a1788(parse); break;         case 'round': point.round = a1788(parse); break;         }     }       parse.i1789 = false;     parse.v3647--;       z1791(parse, point);     return point; }    function e1738(parse) {     parse.pos++;       const edge = parse.move();      if (parse.settings.logRequests)          e2131(d1255, edge, parse);      return p3667(edge)[0]; }    function p1739(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const edge = new q1981(nodeId, options);       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.logRequests)          i2124(edge, parse, ignore, a4209);       if (ignore)      {         z1791(parse, edge);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 2)     {         edge.e4083 = a1788(parse);         edge.j4084 = a1788(parse);     }     else if (a4209 == 1)     {         edge.e4083 = a1788(parse);      }       edge.e3665 = a1788(parse);     edge.  h3666 = a1788(parse);       parse.i1789 = false;     parse.v3647--;       z1791(parse, edge);     return edge; }    function h1740(parse) {     parse.pos++;       const region = parse.move();      if (parse.settings.logRequests)          e2131(l1258, region, parse);      return b3664(region)[0]; }    function r1741(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const region = new e1985(nodeId, options);       let a4209 = 0;          if (!ignore)         a4209 = parseInt(parse.move());       if (parse.settings.logRequests)          i2124(region, parse, ignore, a4209);       if (ignore)      {         z1791(parse, region);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       for (let i = 0; i < a4209; i++)         region.inputs.push(a1788(parse));       region.winding = a1788(parse);     region.props   = a1788(parse);       parse.i1789 = false;     parse.v3647--;       z1791(parse, region);     return region; }    function a1742(parse) {     parse.pos++;       const region = parse.move();      if (parse.settings.logRequests)          e2131(q1261, region, parse);      return q3663(region)[0]; }    function u1743(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const network = new n1983(nodeId, options);       let a4209 = 0;          if (!ignore)         a4209 = parseInt(parse.move());       if (parse.settings.logRequests)          i2124(network, parse, ignore, a4209);       if (ignore)      {         z1791(parse, network);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       for (let i = 0; i < a4209; i++)         network.inputs.push(a1788(parse));      network.props = a1788(parse);       parse.v3647--;        z1791(parse, network);     return network; }    function i1744(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const bool = new e1947(nodeId, options);       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(bool, parse, ignore);       if (ignore)      {         z1791(parse, bool);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         bool.input = a1788(parse);       const w3668 = p1793(parse);      for (let i = 0; i < w3668; i++)     {         const p2992 = p1795(parse);          parse.i1789 = true;          switch (p2992)         {         case 'children':  bool.children  = a1788(parse); break;         case 'operation': bool.operation = a1788(parse); break;         case 'props':     bool.props     = a1788(parse); break;         }     }       parse.i1789 = false;     parse.v3647--;       z1791(parse, bool);     return bool; }    function genParseArcPath(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const arc = new GArcPath(nodeId, options);       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(arc, parse, ignore);       if (ignore)      {         z1791(parse, arc);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         arc.input = a1788(parse);       const w3668 = p1793(parse);      for (let i = 0; i < w3668; i++)     {         const p2992 = p1795(parse);          parse.i1789 = true;          switch (p2992)         {         case 'position': arc.position = a1788(parse); break;         case 'x':        arc.x        = a1788(parse); break;         case 'y':        arc.y        = a1788(parse); break;         case 'width':    arc.width    = a1788(parse); break;         case 'height':   arc.height   = a1788(parse); break;         case 'start':    arc.start    = a1788(parse); break;         case 'sweep':    arc.sweep    = a1788(parse); break;         case 'props':    arc.props    = a1788(parse); break;         }     }               arc.sweepInDegrees = parseInt(parse.move()) > 0;       parse.i1789 = false;     parse.v3647--;       z1791(parse, arc);     return arc; }    function genParseWavePath(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const wave = new GWavePath(nodeId, options);       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(wave, parse, ignore);       if (ignore)      {         z1791(parse, wave);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         wave.input = a1788(parse);       const w3668 = p1793(parse);      for (let i = 0; i < w3668; i++)     {         const p2992 = p1795(parse);          parse.i1789 = true;          switch (p2992)         {         case 'shape':     wave.shape     = a1788(parse); break;         case 'x':         wave.x         = a1788(parse); break;         case 'y':         wave.y         = a1788(parse); break;         case 'width':     wave.width     = a1788(parse); break;         case 'amplitude': wave.amplitude = a1788(parse); break;         case 'frequency': wave.frequency = a1788(parse); break;         case 'offset':    wave.offset    = a1788(parse); break;         case 'alignX':    wave.alignX    = a1788(parse); break;         case 'alignY':    wave.alignY    = a1788(parse); break;         case 'props':     wave.props     = a1788(parse); break;         }     }               wave.useWavelength  = parseInt(parse.move()) > 0;     wave.offsetAbsolute = parseInt(parse.move()) > 0;       parse.i1789 = false;     parse.v3647--;       z1791(parse, wave);     return wave; }    function x1745(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const group = new q1976(nodeId, options);       let a4209 = 0;          if (!ignore)         a4209 = parseInt(parse.move());       if (parse.settings.logRequests)          i2124(group, parse, ignore, a4209);       if (ignore)      {         z1791(parse, group);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       for (let i = 0; i < a4209; i++)         group.inputs.push(a1788(parse));       parse.v3647--;       z1791(parse, group);     return group; }    function i1746(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const frame = new z1957(nodeId, options);       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(frame, parse, ignore);       if (ignore)      {         z1791(parse, frame);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         frame.input = a1788(parse);       const w3668 = p1793(parse);      for (let i = 0; i < w3668; i++)     {         const p2992 = p1795(parse);          parse.i1789 = true;          switch (p2992)         {         case 'children': frame.children = a1788(parse); break;         case 'position': frame.position = a1788(parse); break;         case 'x':        frame.x        = a1788(parse); break;         case 'y':        frame.y        = a1788(parse); break;         case 'width':    frame.width    = a1788(parse); break;         case 'height':   frame.height   = a1788(parse); break;         case 'round':    frame.round    = a1788(parse); break;         case 'clip':     frame.clip     = a1788(parse); break;         case 'props':    frame.props    = a1788(parse); break;         }     }       parse.i1789 = false;     parse.v3647--;       z1791(parse, frame);     return frame; }    function q1747(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const move = new s1962(nodeId, options);       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(move, parse, ignore);       if (ignore)      {         z1791(parse, move);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         move.input = a1788(parse);      move.j3662    = a1788(parse);     move.x           = a1788(parse);     move.y           = a1788(parse);     move.affectSpace = a1788(parse);       parse.i1789 = false;     parse.v3647--;       z1791(parse, move);     return move; }    function s1748(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const rotate = new o1972(nodeId, options);       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(rotate, parse, ignore);       if (ignore)      {         z1791(parse, rotate);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         rotate.input = a1788(parse);      rotate.angle       = a1788(parse);     rotate.affectSpace = a1788(parse);           parse.i1789 = false;     parse.v3647--;       z1791(parse, rotate);     return rotate; }    function f1749(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const scale = new w1973(nodeId, options);       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(scale, parse, ignore);       if (ignore)      {         z1791(parse, scale);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         scale.input = a1788(parse);      scale.scaleX        = a1788(parse);     scale.scaleY        = a1788(parse);     scale.affectCorners = a1788(parse);     scale.affectStyle   = a1788(parse);     scale.affectSpace   = a1788(parse);           parse.i1789 = false;     parse.v3647--;       z1791(parse, scale);     return scale; }    function x1750(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const skew = new t1977(nodeId, options);       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(skew, parse, ignore);       if (ignore)      {         z1791(parse, skew);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         skew.input = a1788(parse);      skew.skewX       = a1788(parse);     skew.skewY       = a1788(parse);     skew.affectSpace = a1788(parse);       parse.i1789 = false;     parse.v3647--;       z1791(parse, skew);     return skew; }    function genParseShowCenter(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const showCenter = new GShowCenter(nodeId, options);       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(showCenter, parse, ignore);       if (ignore)      {         z1791(parse, showCenter);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         showCenter.input = a1788(parse);      showCenter.show = a1788(parse);       parse.i1789 = false;     parse.v3647--;       z1791(parse, showCenter);     return showCenter; }    function x1751(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const center = new g1954(nodeId, options);       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(center, parse, ignore);       if (ignore)      {         z1791(parse, center);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         center.input = a1788(parse);      center.centerX    = a1788(parse);     center.centerY    = a1788(parse);     center.units      = a1788(parse);       parse.i1789 = false;     parse.v3647--;       z1791(parse, center);     return center; }    function s1752(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const reset = new d1971(nodeId, options);       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(reset, parse, ignore);       if (ignore)      {         z1791(parse, reset);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         reset.input = a1788(parse);       parse.v3647--;       z1791(parse, reset);     return reset; }    function e1753(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const measure = new g1961(nodeId, options);       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(measure, parse, ignore, a4209);       if (ignore)      {         z1791(parse, measure);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;           if (a4209 == 1)         measure.input = a1788(parse);                 parse.v3647--;       z1791(parse, measure);     return measure; }    function w1754(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const angle = new GPointAngle(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(angle, parse, ignore, a4209);       if (ignore)      {         z1791(parse, angle);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         angle.input = a1788(parse);           parse.v3647--;       z1791(parse, angle);     return angle; }    function p1755(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const vector = new e1982(nodeId, options);       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.logRequests)          i2124(vector, parse, ignore, a4209);       if (ignore)      {         z1791(parse, vector);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;           if (a4209 == 2)     {         vector.e4083 = a1788(parse);         vector.j4084 = a1788(parse);     }     else if (a4209 == 1)     {         vector.e4083 = a1788(parse);      }       vector.transform  = a1788(parse);       parse.v3647--;       z1791(parse, vector);     return vector; }    function d1756(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const center = new j1955(nodeId, options);       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 3, 'nInputs must be [0, 3]');     }           if (parse.settings.logRequests)          i2124(center, parse, ignore, a4209);       if (ignore)      {         z1791(parse, center);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;           if (a4209 == 3)     {         center.e4083 = a1788(parse);         center.j4084 = a1788(parse);         center.n4085 = a1788(parse);     }     else if (a4209 == 2)     {         center.e4083 = a1788(parse);         center.j4084 = a1788(parse);     }     else if (a4209 == 1)     {         center.e4083 = a1788(parse);     }       parse.v3647--;       z1791(parse, center);     return center; }    function genParseArcFromPoints(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const arc = new GArcFromPoints(nodeId, options);       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 3, 'nInputs must be [0, 3]');     }           if (parse.settings.logRequests)          i2124(arc, parse, ignore, a4209);       if (ignore)      {         z1791(parse, arc);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;           if (a4209 == 3)     {         arc.e4083 = a1788(parse);         arc.j4084 = a1788(parse);         arc.n4085 = a1788(parse);     }     else if (a4209 == 2)     {         arc.e4083 = a1788(parse);         arc.j4084 = a1788(parse);     }     else if (a4209 == 1)     {         arc.e4083 = a1788(parse);     }       const w3668 = p1793(parse);      for (let i = 0; i < w3668; i++)     {         const p2992 = p1795(parse);          parse.i1789 = true;          switch (p2992)         {                case 'props':   arc.props   = a1788(parse); break;         }     }       parse.i1789 = false;     parse.v3647--;       z1791(parse, arc);     return arc; }    function q1757(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const inter = new u1959(nodeId, options);       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 4, 'nInputs must be [0, 4]');     }           if (parse.settings.logRequests)          i2124(inter, parse, ignore, a4209);       if (ignore)      {         z1791(parse, inter);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;           if (a4209 == 4)     {         inter.e4083 = a1788(parse);         inter.j4084 = a1788(parse);         inter.n4085 = a1788(parse);         inter.x4086 = a1788(parse);     }     else if (a4209 == 3)     {         inter.e4083 = a1788(parse);         inter.j4084 = a1788(parse);         inter.n4085 = a1788(parse);     }     else if (a4209 == 2)     {         inter.e4083 = a1788(parse);         inter.j4084 = a1788(parse);     }     else if (a4209 == 1)     {         inter.e4083 = a1788(parse);     }       inter.segment = a1788(parse);       parse.v3647--;       z1791(parse, inter);     return inter; }    function r1758(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const b1035 = new g1958(nodeId, options);       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.logRequests)          i2124(b1035, parse, ignore, a4209);       if (ignore)      {         z1791(parse, b1035);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 2)     {         b1035.e4083 = a1788(parse);         b1035.j4084 = a1788(parse);     }     else if (a4209 == 1)     {         b1035.e4083 = a1788(parse);      }       b1035.amount     = a1788(parse);     b1035.transform  = a1788(parse);       parse.v3647--;       z1791(parse, b1035);     return b1035; }    function genParsePointAlongPath(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const pap = new y1966(nodeId, options);       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(pap, parse, ignore, a4209);       if (ignore)      {         z1791(parse, pap);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         pap.input = a1788(parse);        pap.position   = a1788(parse);     pap.distance   = a1788(parse);     pap.offset     = a1788(parse);     pap.transform  = a1788(parse);       parse.v3647--;       z1791(parse, pap);     return pap; }    function genParseClosestPointOnPath(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const cpop = new g1967(nodeId, options);       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.logRequests)          i2124(cpop, parse, ignore, a4209);       if (ignore)      {         z1791(parse, cpop);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 2)     {         cpop.e4083 = a1788(parse);         cpop.j4084 = a1788(parse);     }     else if (a4209 == 1)     {         cpop.e4083 = a1788(parse);      }       cpop.constrain  = a1788(parse);     cpop.transform  = a1788(parse);       parse.v3647--;       z1791(parse, cpop);     return cpop; }    function genParseReversePath(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const reverse = new GReversePath(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(reverse, parse, ignore, a4209);       if (ignore)      {         z1791(parse, reverse);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         reverse.input = a1788(parse);             parse.v3647--;       z1791(parse, reverse);     return reverse; }    function genParseBlendPath(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const blend = new GBlendPath(nodeId, options);          let a4209 = 0;          if (!ignore)         a4209 = parseInt(parse.move());       if (parse.settings.logRequests)          i2124(blend, parse, ignore, a4209);       if (ignore)      {         z1791(parse, blend);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;           for (let i = 0; i < a4209; i++)         blend.inputs.push(a1788(parse));       blend.amount = a1788(parse);     blend.degree = a1788(parse);             parse.v3647--;       z1791(parse, blend);     return blend; }    function i1760(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const place = new d1963(nodeId, options);       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(place, parse, ignore);       if (ignore)      {         z1791(parse, place);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         place.input = a1788(parse);      place.position   = a1788(parse);     place.transform  = a1788(parse);       parse.i1789 = false;     parse.v3647--;       z1791(parse, place);     return place; }    function s1761(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const apply = new l1953(nodeId, options);       let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(apply, parse, ignore);       if (ignore)      {         z1791(parse, apply);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         apply.input = a1788(parse);      apply.props   = a1788(parse);     apply.replace = a1788(parse);       parse.i1789 = false;     parse.v3647--;       z1791(parse, apply);     return apply; }    function v1762(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const render = new r1970(nodeId, options);       let a4209 = 0;          if (!ignore)         a4209 = parseInt(parse.move());       if (parse.settings.logRequests)          i2124(render, parse, ignore, a4209);       if (ignore)      {         z1791(parse, render);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       for (let i = 0; i < a4209; i++)         render.inputs.push(a1788(parse));      render.retain   = a1788(parse);     render.finalize = a1788(parse);       parse.v3647--;       z1791(parse, render);     return render; }    function genParseExport(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const _export = new GExport(nodeId, options);       let a4209 = 0;          if (!ignore)         a4209 = parseInt(parse.move());       if (parse.settings.logRequests)          i2124(_export, parse, ignore, a4209);       if (ignore)      {         z1791(parse, _export);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       for (let i = 0; i < a4209; i++)         _export.inputs.push(a1788(parse));      _export.scale    = a1788(parse);     _export.format   = a1788(parse);         _export.suffix   = a1788(parse);     _export.profile  = a1788(parse);       parse.v3647--;       z1791(parse, _export);     return _export; }


              function d1763(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const style = new e1887(nodeId, options);      style.existing = options.existing;       if (parse.settings.logRequests)          i2124(style, parse, ignore);       if (ignore)      {         z1791(parse, style);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;     parse.i1789 = false;       style.id       = parse.move();     style.name     = options.nodeName;          style.a2818 = a1788(parse);           parse.v3647--;           style.linked = style.id != NULL;       z1791(parse, style);     return style; }                             


 function y1764(parse) {     parse.pos++;       const val = parse.move();      if (parse.settings.logRequests)          e2131(t1143, val, parse);      return s2865(val)[0]; }    function e1765(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const text = new w1992(nodeId, options);           if (parse.settings.logRequests)          i2124(text, parse, ignore);       if (ignore)      {         z1791(parse, text);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;     parse.i1789 = false;       if (parse.next == t1143) text.value = a1788(parse);     else                          text.input = a1788(parse);       parse.v3647--;       z1791(parse, text);     return text; }    function f1766(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const len = new f2000(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(len, parse, ignore, a4209);       if (ignore)      {         z1791(parse, len);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         len.input = a1788(parse);           parse.v3647--;       z1791(parse, len);     return len; }    function t1767(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const trim = new z2007(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(trim, parse, ignore, a4209);       if (ignore)      {         z1791(parse, trim);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         trim.input = a1788(parse);      trim.start = a1788(parse);     trim.end   = a1788(parse);           parse.v3647--;       z1791(parse, trim);     return trim; }    function x1768(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const sub = new k2004(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(sub, parse, ignore, a4209);       if (ignore)      {         z1791(parse, sub);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         sub.input = a1788(parse);      sub.start = a1788(parse);     sub.end   = a1788(parse);           parse.v3647--;       z1791(parse, sub);     return sub; }    function d1769(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const cont = new l1995(nodeId, options);          let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.logRequests)          i2124(cont, parse, ignore, a4209);       if (ignore)      {         z1791(parse, cont);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 2)     {         cont.e4083 = a1788(parse);         cont.j4084 = a1788(parse);     }     else if (a4209 == 1)     {         cont.e4083 = a1788(parse);      }             parse.v3647--;       z1791(parse, cont);     return cont; }    function t1770(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const h3659 = new d1993(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(h3659, parse, ignore, a4209);       if (ignore)      {         z1791(parse, h3659);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         h3659.input = a1788(parse);      h3659.case = a1788(parse);           parse.v3647--;       z1791(parse, h3659);     return h3659; }    function c1771(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const replace = new x2002(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(replace, parse, ignore, a4209);       if (ignore)      {         z1791(parse, replace);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         replace.input = a1788(parse);      replace.what  = a1788(parse);     replace.with  = a1788(parse);     replace.regex = a1788(parse);           parse.v3647--;       z1791(parse, replace);     return replace; }                                                                     function q1772(parse, u1690) {     const [type, nodeId, options, ignore] = l1790(parse);       const join = new h1999(nodeId, options);       let a4209 = 0;          if (!ignore)         a4209 = parseInt(parse.move());       if (parse.settings.logRequests)          i2124(join, parse, ignore, a4209);       if (ignore)      {         z1791(parse, join);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       for (let i = 0; i < a4209; i++)         join.inputs.push(a1788(parse));       join.with = a1788(parse);           parse.v3647--;               z1791(parse, join);     return join; }    function d1773(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const pad = new b2001(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(pad, parse, ignore, a4209);       if (ignore)      {         z1791(parse, pad);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         pad.input = a1788(parse);      pad.g3655   = a1788(parse);     pad.z3656 = a1788(parse);     pad.d3657     = a1788(parse);     pad.d3658   = a1788(parse);           parse.v3647--;       z1791(parse, pad);     return pad; }    function l1774(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const cmp = new p1994(nodeId, options);          let a4209 = -1;      if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 => 0 && a4209 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.logRequests)          i2124(cmp, parse, ignore, a4209);       if (ignore)      {         z1791(parse, cmp);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 2)     {         cmp.e4083 = a1788(parse);         cmp.j4084 = a1788(parse);     }     else if (a4209 == 1)     {         cmp.e4083 = a1788(parse);      }             cmp.operation = a1788(parse);           parse.v3647--;       z1791(parse, cmp);     return cmp; }    function e1775(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const w3654 = new c1988(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(w3654, parse, ignore, a4209);       if (ignore)      {         z1791(parse, w3654);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         w3654.input = a1788(parse);           parse.v3647--;       z1791(parse, w3654);     return w3654; }    function i1776(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const x3653 = new b1987(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(x3653, parse, ignore, a4209);       if (ignore)      {         z1791(parse, x3653);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         x3653.input = a1788(parse);           parse.v3647--;       z1791(parse, x3653);     return x3653; }    function e1777(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const index = new h1990(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(index, parse, ignore, a4209);       if (ignore)      {         z1791(parse, index);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       index.name  = a1788(parse);     index.index = a1788(parse);           parse.v3647--;       z1791(parse, index);     return index; }    function i1778(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const x3652 = new z1991(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(x3652, parse, ignore, a4209);       if (ignore)      {         z1791(parse, x3652);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         x3652.input = a1788(parse);      x3652.base      = a1788(parse);     x3652.decimals  = a1788(parse);     x3652.thousands = a1788(parse);           parse.v3647--;       z1791(parse, x3652);     return x3652; }    function s1779(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const s3651 = new a1989(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(s3651, parse, ignore, a4209);       if (ignore)      {         z1791(parse, s3651);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         s3651.input = a1788(parse);      s3651.format = a1788(parse);           parse.v3647--;       z1791(parse, s3651);     return s3651; }    function z1780(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const y3650 = new d2006(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(y3650, parse, ignore);       if (ignore)      {         z1791(parse, y3650);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         y3650.input = a1788(parse);      y3650.base      = a1788(parse);     y3650.decimals  = a1788(parse);     y3650.thousands = a1788(parse);           parse.v3647--;       z1791(parse, y3650);     return y3650; }    function v1781(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const text2col = new f2005(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          i2124(text2col, parse, ignore);       if (ignore)      {         z1791(parse, text2col);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         text2col.input = a1788(parse);           parse.v3647--;       z1791(parse, text2col);     return text2col; }    function h1782(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const split = new s2003(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(split, parse, ignore, a4209);       if (ignore)      {         z1791(parse, split);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         split.input = a1788(parse);      split.separator = a1788(parse);           parse.v3647--;       z1791(parse, split);     return split; }    function m1783(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const csv = new w1996(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(csv, parse, ignore, a4209);       if (ignore)      {         z1791(parse, csv);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         csv.input = a1788(parse);      csv.a3648    = a1788(parse);     csv.n3649 = a1788(parse);           parse.v3647--;       z1791(parse, csv);     return csv; }    function f3704(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const json = new GTextJson(nodeId, options);          let a4209 = -1;          if (!ignore)     {         a4209 = parseInt(parse.move());         l952(a4209 == 0 || a4209 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          i2124(json, parse, ignore, a4209);       if (ignore)      {         z1791(parse, json);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       if (a4209 == 1)         json.input = a1788(parse);           parse.v3647--;       z1791(parse, json);     return json; }    function v1784(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const fetch = new r1997(nodeId, options);          if (parse.settings.logRequests)          i2124(fetch, parse, ignore);       if (ignore)      {         z1791(parse, fetch);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       fetch.request     = a1788(parse);     fetch.p4212 = a1788(parse);           parse.v3647--;       z1791(parse, fetch);     return fetch; }    function f1785(parse) {     const [, nodeId, options, ignore] = l1790(parse);       const file = new d1998(nodeId, options);          if (parse.settings.logRequests)          i2124(file, parse, ignore);       if (ignore)      {         z1791(parse, file);         return parse.k4243.find(n => n.nodeId == nodeId);     }       parse.v3647++;       file.p4212 = a1788(parse);                parse.v3647--;       z1791(parse, file);     return file; }


class j1786 {     request;     z2067;          pos;      so;      settings = {};      save;       log  = '';          v3647 = 0;      get tab() { return this.i1789 ? ' ' : (j872 + x870.repeat(Math.max(0, this.v3647))); }           i1789 = false;       evalAccumulate = true;     evalFeedback   = true;           s4019;     f4020;      viewportZoom;      g3639 = 0;     y3640   = 0;      scope           = [];      k4243     = [];            repeats         = [];        p3641    = false;           g3642    = [];        f2876    = [];     e3096    = [];     g3643   = [];     k3644    = [];            get next() { return this.request[this.pos]; }      get v3646()      {          return this.pos+1 < this.request.length               ? this.request[this.pos+1]              : null;     }        constructor(request, u3645, z2067, s4019, f4020, viewportZoom, settings, save)     {         this.request       = request;         this.z2067     = z2067;                    this.pos           = u3645;          this.so            = 0;                  this.s4019  = s4019;          this.f4020 = f4020;             this.viewportZoom  = viewportZoom;          this.settings      = settings;          this.save          = save;     }        move()     {                   const token = this.request[this.pos++];                  return token;     }        m1787()      {         return isEmpty(this.repeats)             ||    this.repeats.length == 1                && this.repeats[0].currentIteration == this.repeats[0].total-1;     }  }    function a1788(parse, i1789 = true) {           if (!i1789)         parse.i1789 = false;       let result = null;            if (parse.next == PARAM                  ) result = g1794             (parse);              else if (parse.next ==        y1056                        || parse.next == m1057                        || parse.next ==   u1058                        || parse.next ==  y1059      ) result = e1635         (parse);       else if (parse.next == d1060              ) result = v1632              (parse);     else if (parse.next == w1061               ) result = s1633          (parse);     else if (parse.next == p1062         ) result = j1634     (parse);     else if (parse.next == w1084                ) result = w1654            (parse);     else if (parse.next == p1063               ) result = t1655          (parse);     else if (parse.next == m1064                 ) result = k1656            (parse);     else if (parse.next == p1065                  ) result = h1657             (parse);     else if (parse.next == l1086                ) result = genParseIterate           (parse);     else if (parse.next == t1066                 ) result = p1658            (parse);     else if (parse.next == n1067                  ) result = j1659             (parse);     else if (parse.next == i1068             ) result = g1660         (parse);     else if (parse.next == f1352   ) result = genParseGetListValueNames (parse);     else if (parse.next == y1353       ) result = genParseListValueNames    (parse);     else if (parse.next == c1354            ) result = genParseObjectName        (parse);      else if (parse.next == v1069                ) result = i1636           (parse);     else if (parse.next == j1070           ) result = a1637        (parse);     else if (parse.next == m1071                ) result = t1638           (parse);     else if (parse.next == v1072              ) result = w1639          (parse);     else if (parse.next == v1073              ) result = i1640          (parse);     else if (parse.next == w1074                ) result = n1641           (parse);     else if (parse.next == g1075                 ) result = n1642            (parse);     else if (parse.next == q1349           ) result = q1643       (parse);     else if (parse.next == f1350             ) result = v1644         (parse);     else if (parse.next == b1076           ) result = e1645       (parse);     else if (parse.next == q1351            ) result = genParseBuckleList        (parse);     else if (parse.next == w1077                   ) result = y1646              (parse);     else if (parse.next == h1085                 ) result = n1647            (parse);     else if (parse.next == p1078                 ) result = s1648            (parse);     else if (parse.next == o1079                   ) result = e1649              (parse);     else if (parse.next == c1080                   ) result = p1650              (parse);     else if (parse.next == x1083                 ) result = c1651            (parse);     else if (parse.next == a1360       ) result = genParseSelectFromList    (parse);     else if (parse.next == k1081             ) result = w1652         (parse);     else if (parse.next == OBJECT_COUNT           ) result = genParseObjectCount       (parse);     else if (parse.next == t1082               ) result = y1653      (parse);           else if (parse.next == t1091           ) result = a1691          (parse);     else if (parse.next == g1092                 ) result = k1692            (parse);     else if (parse.next == y1355       ) result = genParseSetPrecision      (parse);     else if (parse.next == w1093            ) result = i1695              (parse);     else if (parse.next == z1094        ) result = s1696          (parse);     else if (parse.next == h1356        ) result = genParseNegative          (parse);     else if (parse.next == e1095           ) result = l1697             (parse);     else if (parse.next == z1357        ) result = genParseQuantize          (parse);     else if (parse.next == g1097          ) result = s1699            (parse);     else if (parse.next == f1096   ) result = x1698      (parse);     else if (parse.next == j1098          ) result = y1700            (parse);     else if (parse.next == l1099           ) result = c1701       (parse);     else if (parse.next == x1358             ) result = genParseNumberMap         (parse);     else if (parse.next == l1359            ) result = genParseNumberBias        (parse);     else if (parse.next == e1100             ) result = g1702       (parse);     else if (parse.next == i1101        ) result = k1693          (parse);     else if (parse.next == d1102        ) result = p1694          (parse);     else if (parse.next == w1103        ) result = g1710          (parse);     else if (parse.next == l1104           ) result = x1708             (parse);     else if (parse.next == a1105            ) result = b1709              (parse);     else if (parse.next == c1106          ) result = w1711            (parse);     else if (parse.next == a1107           ) result = r1712             (parse);     else if (parse.next == g1108            ) result = u1713       (parse);     else if (parse.next == r1109      ) result = s1714        (parse);     else if (parse.next == HOLD                   ) result = genParseHold              (parse);     else if (parse.next == y1110     ) result = j1715       (parse);     else if (parse.next == c1111           ) result = z1722             (parse);     else if (parse.next == w1112         ) result = q1723           (parse);          else if (parse.next == w1114            ) result = h1703              (parse, (nodeId, options) => new u1902          (nodeId, options));     else if (parse.next == g1113     ) result = w1704        (parse, (nodeId, options) => new u1902          (nodeId, options));     else if (parse.next == s1115             ) result = t1705        (parse, (nodeId, options) => new y1898           (nodeId, options));     else if (parse.next == d1116        ) result = t1705        (parse, (nodeId, options) => new e1906      (nodeId, options));     else if (parse.next == s1117        ) result = t1705        (parse, (nodeId, options) => new h1904      (nodeId, options));     else if (parse.next == t1118          ) result = t1705        (parse, (nodeId, options) => new v1900        (nodeId, options));     else if (parse.next == f1119          ) result = t1705        (parse, (nodeId, options) => new w1903        (nodeId, options));     else if (parse.next == e1120        ) result = t1705        (parse, (nodeId, options) => new o1901      (nodeId, options));           else if (parse.next == z1121         ) result = k1716           (parse);     else if (parse.next == d1122             ) result = t1705        (parse, (nodeId, options) => new h1909           (nodeId, options));     else if (parse.next == k1123             ) result = t1705        (parse, (nodeId, options) => new h1907           (nodeId, options));     else if (parse.next == s1124              ) result = t1705        (parse, (nodeId, options) => new y1910            (nodeId, options));     else if (parse.next == p1125             ) result = t1705        (parse, (nodeId, options) => new k1911           (nodeId, options));           else if (parse.next == g1126       ) result = u1717         (parse);     else if (parse.next == y1127           ) result = t1718     (parse, (nodeId, options) => new r1913         (nodeId, options));     else if (parse.next == v1128       ) result = t1718     (parse, (nodeId, options) => new c1918      (nodeId, options));     else if (parse.next == s1129            ) result = t1718     (parse, (nodeId, options) => new h1916          (nodeId, options));     else if (parse.next == b1130   ) result = t1718     (parse, (nodeId, options) => new l1917   (nodeId, options));     else if (parse.next == u1131         ) result = t1718     (parse, (nodeId, options) => new p1914       (nodeId, options));     else if (parse.next == m1132) result = t1718     (parse, (nodeId, options) => new q1915(nodeId, options));       else if (parse.next == e1133            ) result = t1719     (parse);     else if (parse.next == j1134             ) result = w1720          (parse, (nodeId, options) => new m1921          (nodeId, options));     else if (parse.next == u1135             ) result = w1720          (parse, (nodeId, options) => new y1920        (nodeId, options));     else if (parse.next == h1136             ) result = w1720          (parse, (nodeId, options) => new h1922       (nodeId, options));     else if (parse.next == x1137           ) result = i1721             (parse, (nodeId, options) => new h1922       (nodeId, options));      else if (parse.next == l1138          ) result = s1706      (parse);       else if (parse.next == t1143             ) result = y1764         (parse);     else if (parse.next == z1144                   ) result = e1765              (parse);     else if (parse.next == a1145            ) result = f1766        (parse);     else if (parse.next == x1146              ) result = t1767          (parse);     else if (parse.next == z1147         ) result = x1768     (parse);     else if (parse.next == a1148          ) result = d1769      (parse);     else if (parse.next == h1149              ) result = t1770          (parse);     else if (parse.next == h1154              ) result = e1775   (parse);     else if (parse.next == f1155           ) result = i1776   (parse);     else if (parse.next == f1156          ) result = e1777       (parse);     else if (parse.next == s1157         ) result = i1778      (parse);     else if (parse.next == d1158          ) result = s1779       (parse);     else if (parse.next == w1159         ) result = z1780      (parse);     else if (parse.next == u1160          ) result = v1781       (parse);     else if (parse.next == a1150           ) result = c1771       (parse);     else if (parse.next == n1151              ) result = q1772          (parse);     else if (parse.next == n1152               ) result = d1773           (parse);     else if (parse.next == d1153           ) result = l1774       (parse);     else if (parse.next == d1161             ) result = h1782         (parse);     else if (parse.next == o1163               ) result = m1783           (parse);     else if (parse.next == t3505              ) result = f3704          (parse);     else if (parse.next == q1164             ) result = v1784         (parse);     else if (parse.next == d1165              ) result = f1785          (parse);       else if (parse.next == x1168            ) result = l1623        (parse);     else if (parse.next == b1169                  ) result = a1624             (parse);     else if (parse.next == k1170            ) result = q1625        (parse);     else if (parse.next == g1171          ) result = k1626      (parse);     else if (parse.next == x1173         ) result = i1627     (parse);     else if (parse.next == g1172       ) result = f1628    (parse);     else if (parse.next == b1174             ) result = y1629        (parse);     else if (parse.next == s1175      ) result = b1630  (parse);     else if (parse.next == l1176            ) result = c1631        (parse);            else if (parse.next == k1178             ) result = g1666         (parse);     else if (parse.next == r1179                   ) result = v1667              (parse);            else if (parse.next == r1184       ) result = v1671    (parse);     else if (parse.next == n1185             ) result = j1672         (parse);            else if (parse.next == i1187         ) result = k1669     (parse);     else if (parse.next == x1188               ) result = i1670          (parse);            else if (parse.next == g1181           ) result = i1673       (parse);     else if (parse.next == y1182                 ) result = b1674            (parse);            else if (parse.next == p1190     ) result = genParseStrokeSidesValue  (parse);     else if (parse.next == o1191           ) result = genParseStrokeSides       (parse);            else if (parse.next == p1193    ) result = n1676 (parse);     else if (parse.next == b1194          ) result = n1677      (parse);            else if (parse.next == g1196      ) result = q1678   (parse);     else if (parse.next == z1197            ) result = v1679        (parse);            else if (parse.next == w1199     ) result = r1680  (parse);     else if (parse.next == k1200           ) result = w1681       (parse);            else if (parse.next == c1202       ) result = p1682    (parse);     else if (parse.next == y1203             ) result = a1683         (parse);            else if (parse.next == t1205        ) result = i1684     (parse);     else if (parse.next == h1206              ) result = z1685          (parse);      else if (parse.next == v1211      ) result = g1686   (parse);     else if (parse.next == h1212            ) result = x1687        (parse);            else if (parse.next == c1208       ) result = w1688    (parse);     else if (parse.next == o1209             ) result = p1689         (parse);            else if (parse.next == e1216            ) result = d1763        (parse);            else if (parse.next == d1219              ) result = q1724         (parse);          else if (parse.next == t1222                   ) result = i1725              (parse);     else if (parse.next == w1225                ) result = l1726           (parse);     else if (parse.next == w1228                ) result = z1727           (parse);     else if (parse.next == a1237                ) result = s1728           (parse);     else if (parse.next == f1240                   ) result = t1729              (parse);     else if (parse.next == j1243             ) result = d1730         (parse);       else if (parse.next == t1245            ) result = b1731        (parse);     else if (parse.next == g1246                  ) result = q1732             (parse);     else if (parse.next == k1248           ) result = x1733       (parse);     else if (parse.next == m1249      ) result = x1734   (parse);     else if (parse.next == v1250            ) result = o1735        (parse);          else if (parse.next == c1252    ) result = p1736 (parse);     else if (parse.next == z1253          ) result = i1737      (parse);     else if (parse.next == d1255      ) result = e1738   (parse);     else if (parse.next == m1256            ) result = p1739        (parse);     else if (parse.next == l1258    ) result = h1740 (parse);     else if (parse.next == a1259          ) result = r1741      (parse);     else if (parse.next == q1261   ) result = a1742(parse);     else if (parse.next == s1262         ) result = u1743     (parse);      else if (parse.next == h1287    ) result = d3839 (parse);     else if (parse.next == j1286          ) result = i1744      (parse);      else if (parse.next == m1231         ) result = genParseArcPathValue      (parse);     else if (parse.next == l1230               ) result = genParseArcPath           (parse);      else if (parse.next == g1234        ) result = genParseWavePathValue     (parse);     else if (parse.next == o1233              ) result = genParseWavePath          (parse);      else if (parse.next == c1264      ) result = t3840   (parse);     else if (parse.next == i1265            ) result = x1745        (parse);       else if (parse.next == t1267            ) result = s3841        (parse);     else if (parse.next == f1268                  ) result = i1746             (parse);       else if (parse.next == k1270                   ) result = q1747              (parse);     else if (parse.next == e1271                 ) result = s1748            (parse);     else if (parse.next == y1272                  ) result = f1749             (parse);     else if (parse.next == z1273                   ) result = x1750              (parse);      else if (parse.next == SHOW_CENTER            ) result = genParseShowCenter        (parse);     else if (parse.next == x1274             ) result = x1751            (parse);     else if (parse.next == d1275            ) result = s1752    (parse);      else if (parse.next == PATH_LENGTH            ) result = genParsePathLength        (parse);     else if (parse.next == JOIN_PATHS             ) result = genParseJoinPaths         (parse);     else if (parse.next == REORIENT_PATHS         ) result = genParseReorientPaths     (parse);     else if (parse.next == k1278         ) result = e1753     (parse);     else if (parse.next == s1279            ) result = w1754        (parse);     else if (parse.next == p1280                 ) result = p1755            (parse);     else if (parse.next == g1281          ) result = d1756      (parse);     else if (parse.next == ARC_FROM_POINTS        ) result = genParseArcFromPoints     (parse);     else if (parse.next == g1282        ) result = q1757    (parse);     else if (parse.next == j1283      ) result = r1758  (parse);     else if (parse.next == e1284       ) result = genParsePointAlongPath    (parse);     else if (parse.next == u1285  ) result = genParseClosestPointOnPath(parse);     else if (parse.next == REVERSE_PATH           ) result = genParseReversePath       (parse);     else if (parse.next == BLEND_PATH             ) result = genParseBlendPath         (parse);      else if (parse.next == b1276                  ) result = i1760             (parse);     else if (parse.next == k1277            ) result = s1761        (parse);          else if (parse.next == r1293                 ) result = v1762            (parse);     else if (parse.next == EXPORT                 ) result = genParseExport            (parse);       else if (parse.next == g1298             ) result = s1664         (parse);     else if (parse.next == a1299            ) result = c1665        (parse);       else if (parse.next == n1301                ) result = a1661           (parse);     else if (parse.next == b1302          ) result = u1662      (parse);     else if (parse.next == q1303                  ) result = b1663             (parse);      else j953('unknown parse token \'' + parse.next + '\' @ ' + parse.pos);       parse.i1789 = false;       if (result)         return result;     else     {         parse.so++;         return null;     } }    function l1790(parse) {     const type     = parse.move();     const nodeId   = parse.move();     const nodeName = parse.move();           parse.scope.push(nodeId);       if (parse.k4243.find(n => n.nodeId == nodeId))         return [type, nodeId, {nodeName: nodeName}, true];       const options = q1792(parse);      options.nodeName = nodeName;       return [type, nodeId, options, false]; }    function z1791(parse, node = null) {     parse.scope.pop();      if (node)     {         if (isEmpty(parse.scope))             node.topLevel = true;          p949(parse.k4243, node);     } }    function q1792(parse) {     const opt = parseInt(parse.move());      const options =      {         active:       ((opt >>  0) & 1) != 0,         s2998: ((opt >>  1) & 1) != 0,         beforeList:   ((opt >>  2) & 1) != 0,         enabled:      ((opt >>  3) & 1) != 0,         cached:       ((opt >>  4) & 1) != 0,         unknown:      ((opt >>  5) & 1) != 0,         notCondition: ((opt >>  6) & 1) != 0,         z3265:    ((opt >> 20) & 1) != 0,         existing:     ((opt >> 21) & 1) != 0     };      return options; }    function p1793(parse) {     const w3668 = parseInt(parse.move());      if (parse.settings.logRequests)          parse.log += parse.tab + w3668;      return w3668; }    function g1794(parse) {     if (parse.next != PARAM)          return null;              parse.move();      const type = parse.move();            const nodeId  = parse.move();     const p2992 = parse.move();          const param   = new p2049(nodeId, p2992);        p949(parse.g3642, nodeId);       if (parse.settings.logRequests)          e2128(param, type, parse);       return param; }    function p1795(parse) {     const p2992 = parse.move();      if (parse.settings.logRequests)         parse.log += parse.tab + p2992;      return p2992; }


class a2132 {     request;     pos;      so            = 0;     v3647          = 0;        skipNewLine   = false;      loggedNodeIds = [];            constructor(request, pos)     {         this.request = request;         this.pos     = pos;     }       get tab()      {          if (this.skipNewLine)         {             this.skipNewLine = false;             return '';         }         else              return j872 + x870.repeat(Math.max(0, this.v3647));      } }    function log(str) {     n3882.innerHTML = str; }    function j2133(a2134, a111 = null) {     let str = a2134;      if (a111)         str = a111.id + '.' + str;      console.log(         '%c ' + str + ' ',          'background: #fc0; color: #632;'); }    function l2135(str, color = 'white', background = 'red') {     console.log(         '%c ' + str + ' ',          'background: ' + background + '; color: ' + color + ';'); }    function logValueUpdates(s4019, f4020, values) {           let log     = '';     let newLine = true;      if (   s4019  != ''          || f4020 != '')         log = '↓ ' + e2126(s4019) + '.' + e2126(f4020);     else         newLine = false;                 let i    = 0;     let v3647 = 0;      while (i < values.length)     {         const nodeId  = values[i++];         const a4209 = parseInt(values[i++]);          log +=                (newLine ? j872 : '') + x870.repeat(Math.max(0, v3647))             + nodeId;          newLine = true;          v3647++;          for (let j = 0; j < a4209; j++)         {             const index = values[i++];             const type  = values[i++];             const value = values[i++];              log +=                    j872 + x870.repeat(Math.max(0, v3647))                 + index + ' ' + b4210(type, value);         }          v3647--;     }       console.log(         '%c%s',          'background: #e70; color: white;',          log); }    function logObjectUpdates(objects) {     console.log(         '%cobjects',          'background: #07e; color: white;',          objects); }    function logStyleUpdates(styles) {     console.log(         '%cstyles',          'background: #b4d; color: white;',          styles); }    function t2136(pageJson) {     console.log('%cSAVING PAGES\n' + pageJson, 'color: black; background: #ddeeee;'); }    function v2137(nodeJson) {     console.log('%cSAVING NODES\n' + nodeJson, 'color: black; background: #ddeeff;'); }    function i2138(j2139) {     let log = 'SAVING ' + j2139.length + ' ' + j4016(j2139.length, 'CONNECTION');      for (const i243 of j2139)         log += '\n' + i243.n2119();      console.log(         '%c' + log,          'color: black; background: #ddeeff;'); }    function h2140(j2139) {     let log = 'UPDATING ' + j2139.length + ' ' + j4016(j2139.length, 'SAVED CONNECTION');      for (const i243 of j2139)         log += '\n' + i243.n2119();      console.log(         '%c' + log,          'color: black; background: #ddeeff;'); }    function b2141() {     let log =          'UNDO STACK:\n'         + y2886.actions.map(a => '    ' + a.name).join('\n');      console.log('%c%s', 'background: #ffd; color: #b80;', log); }    function c2142() {     let log =           'REDO STACK:\n'         + y2886.l2888.map(a => '    ' + a.name).join('\n');      console.log('%c%s', 'background: #fff4e8; color: #c64;', log); }


function r2123(parse) {     let log = '';      if (   parse.s4019  != ''          || parse.f4020 != '')         log = '↓ ' + e2126(parse.s4019) + '.' + e2126(parse.f4020);      log += parse.log;      console.log(         '%c%s',          'background: #60aa60; color: #fff',           log); }    function i2124(node, parse, ignore, a4209 = -1) {     parse.log += parse.tab + node.type;     parse.log += c2125(node, ignore);      if (    a4209 > -1         && !ignore)         parse.log += ' ' + a4209; }    function c2125(node, ignore = false) {     return ' '           + e2126(node.nodeId)           + ' ' + e2126(node.nodeName)          + (!ignore             ? s2127(node)             : ''); }    function e2126(nodeId) {     return nodeId == '' ? '\'\'' : nodeId; }    function s2127(node) {     let log = '';      if ( node.options.active      ) log += ' ' + c1304;     if ( node.options.s2998) log += ' ' + r1305;     if ( node.options.beforeList  ) log += ' ' + s1306;     if (!node.options.enabled     ) log += ' ' + d1307;      if (!node.cached              ) log += ' ' + c1308;      return log; }    function e2128(param, type, parse) {     parse.log +=                  parse.tab + PARAM         + ' ' + type          + ' ' + e2126(param.nodeId)          + '.' + e2126(param.p2992); }    function y2129(node, parse) {     parse.log += parse.tab + node.type;     parse.log += c2125(node); }    function b2130(b1035, a4209, c3682, parse, ignore) {     parse.log += parse.tab + x1173;     parse.log += c2125(b1035, ignore);      if (!ignore)     {         parse.log += ' ' + a4209;          if (a4209 == 1)             parse.log += ' ' + c3682;     } }    function e2131(type, val, parse) {     parse.log += parse.tab + type + ' ' + b4210(type, val); }                                           


async function logSavedNode(nodeKey, o4007) {     const log  = c2120(await b1564(nodeKey, false));      if (o4007)     {         console.log(             '%c%s\n%c%s',              'background: #fa24; color: white;',              y1054(nodeKey),              'background: #fa44; color: #edc;',             log);     }     else     {         console.log(             '%c%s\n%c%s',              'background: #fdb; color: black;',              y1054(nodeKey),              'background: #fed; color: black;',             log);     } }    function c2120(json) {     let u4033 = json         .replace('{\n', '')         .replace('\n}', '')          .replace('[\n' + x870, '')         .replace('\n' + x870 + ']', '')          .split(x870 + '"params":\n').join('')           .split('": "').join(': ')         .split('", "').join(': ')          .split(x870 + '"').join(x870)         .split(x870 + x870 + '["').join(x870 + x870)                  .split('",\n').join('\n')         .split('"\n').join('\n')                  .split('"],\n').join('\n');       if (u4033[u4033.length-1] == '"')         u4033 = u4033.substring(0, u4033.length - 1);      if (u4033.substring(u4033.length-2) == '"]')             u4033 = u4033.substring(0, u4033.length - 2);      return u4033; }    function d2121(json) {     let u4033 = json         .replace('{\n', '')         .replace('\n}', '')         .replace('[\n' + x870, '')         .replace('\n' + x870 + ']', '');      return u4033; }    function e2122(i243, o4007) {     const p4211 = o924(i243, true);      if (o4007)     {         console.log(             '%c%s',              'background: #4f44; color: #ded',              p4211);      }     else     {         console.log(             '%c%s',              'background: #cfc; color: black;',              p4211);      } }


  const D65 = [0.95047, 1, 1.08883];    function x31(R, G, B, Y, W, gamma, degamma, regamma, luminance) {     return {             R:         R,         G:         G,         B:         B,          Y:         Y,          W:         W,          c3975:   w32(R, G, B, W),         xyz2lin:   f891(w32(R, G, B, W)),          gamma:     gamma,                  degamma:   degamma,         regamma:   regamma,                  luminance: luminance     }; }   function w32(R, G, B, W) {     const C0 = c33(R);     const C1 = c33(G);     const C2 = c33(B);      const M = [ [ C0[0], C1[0], C2[0] ],                  [ C0[1], C1[1], C2[1] ],                  [ C0[2], C1[2], C2[2] ] ];      const S = j948(W, f891(M));      return [ [ S[0]*C0[0], S[1]*C1[0], S[2]*C2[0] ],              [ S[0]*C0[1], S[1]*C1[1], S[2]*C2[1] ],              [ S[0]*C0[2], S[1]*C1[2], S[2]*C2[2] ] ]; }   function c33(c) {     const x = c[0],           y = c[1];      return [x/y, 1, (1-x-y)/y]; } 


const z36 = x31 (     [0.64, 0.33],      [0.3,  0.6 ],      [0.15, 0.06],       [0.212656,      0.715158,      0.072186],       D65,              2.4,                function(v)      {         return v >= 0.04045                ? Math.pow((v + 0.055) / 1.055, this.gamma)                : v / 12.92;     },            function(v)      {         return v > 0.0031308                ? 1.055 * Math.pow(v, 1/this.gamma) - 0.055                : v * 12.92;     },                function(rgb)      {         return  this.Y[0] * this.degamma(rgb[0])                + this.Y[1] * this.degamma(rgb[1])                + this.Y[2] * this.degamma(rgb[2]);     } ); 


function d66(rgb, amount) {     const hsv = k52(rgb);     hsv[2] *= amount;     return g54(hsv); }    function u67(rgb, amount) {     const hsv = k52(rgb);     hsv[1] *= amount;     return g54(hsv); }    function g68(rgb, amount) {     const hsl = t48(rgb);     hsl[1] *= amount;     return f50(hsl); }


function w51(r, g, b) {     let h, s, v;      let min = Math.min(Math.min(r, g), b),         max = Math.max(Math.max(r, g), b);      let delta = max - min;      v = max;     s = max == 0 ? 0 : delta / max; 	     if      (max == r) h = 1/6 * (g - b) / delta + 1;        else if (max == g) h = 1/6 * (b - r) / delta + 1/3;      else if (max == b) h = 1/6 * (r - g) / delta + 2/3;   	if (h > 1) h -= 1; 	      return [h, s, v]; }    function k52(rgb) {     return w51(rgb[0], rgb[1], rgb[2]); }    function g53(h, s, v) {     while (h < 0) h++;     h %= 1;      if (s == 0)         return [v, v, v];       h *= 6 - 0.0000001;      let i = Math.floor(h);     let f = h - i; 	     let p = v * (1 - s);     let q = v * (1 - s * f);     let t = v * (1 - s * (1 - f));      switch (i)     {         case 0:  return [v, t, p];         case 1:  return [q, v, p];         case 2:  return [p, v, t];         case 3:  return [p, q, v];         case 4:  return [t, p, v];         default: return [v, p, q];     } }    function g54(hsv) { 	return g53(hsv[0], hsv[1], hsv[2]); }


function o47(r, g, b) {     let h, s, l;      let min = Math.min(Math.min(r, g), b),         max = Math.max(Math.max(r, g), b);      let delta = max - min;      l = (max + min) / 2;           if (max == min) h = 0;     else if (max == r  ) h = 1/6 * (g - b) / delta + 1;     else if (max == g  ) h = 1/6 * (b - r) / delta + 1/3;     else if (max == b  ) h = 1/6 * (r - g) / delta + 2/3;           if (max == min) s = 0;     else if (l <= 0.5)   s = delta / (2 * l);     else if (l >  0.5)   s = delta / (2 - 2 * l);      return [h, s, l]; }    function t48(rgb) {     return o47(rgb[0], rgb[1], rgb[2]); }    function n49(h, s, l) {     while (h < 0) h++;     h %= 1;      let q =         l < 0.5         ? l * (1 + s)         : l + s - l * s;      let p = 2 * l - q;      let tr = h + 1/3;     let tg = h;     let tb = h - 1/3;      if (tr < 0) tr += 1; if (tr > 1) tr -= 1;     if (tg < 0) tg += 1; if (tg > 1) tg -= 1;     if (tb < 0) tb += 1; if (tb > 1) tb -= 1;      let r, g, b;      let qp6 = (q - p) * 6;            if (tr <  1/6)				r = p + qp6 * tr;     else if (tr >= 1/6 && tr < 0.5)	r = q;     else if (tr >= 0.5 && tr < 2/3)	r = p + qp6 * (2/3 - tr);     else							r = p; 	          if (tg <  1/6)				g = p + qp6 * tg;     else if (tg >= 1/6 && tg < 0.5)	g = q;     else if (tg >= 0.5 && tg < 2/3) g = p + qp6 * (2/3 - tg);     else							g = p;           if (tb <  1/6)				b = p + qp6 * tb;     else if (tb >= 1/6 && tb < 0.5) b = q;     else if (tb >= 0.5 && tb < 2/3) b = p + qp6 * (2/3 - tb);     else							b = p;      return [r, g, b]; }    function f50(hsl) {     return n49(hsl[0], hsl[1], hsl[2]); }


function h59(xyz) {     return j948(xyz, CAT); }    function n60(lms) {     return j948(lms, invCAT); } 


function h69(rgb, cs = z36) {      return a70(degamma(rgb, cs), cs); }        function a70(rgb, cs = z36) {     return j948(rgb, cs.c3975); }            function z71(xyz, cs = z36) {     return regamma(v72(xyz, cs), cs); }    function v72(xyz, cs = z36) {     return j948(xyz, cs.xyz2lin); }


function e3977(rgb, cs = z36) {     return j3979(h69(rgb, cs), cs.W); }    function d3978(luv, cs = z36) {     return z71(y3980(luv, cs.W), cs); }    function j3979(xyz, W = z36.W) {     const x = xyz[0],            y = xyz[1],            z = xyz[2];      const e = cube(6/29);     const k = cube(29/3);      const yw = y / W[1];      let l =          yw > e         ? 116 * Math.cbrt(yw) - 16         : k * yw;      const u_ = 4*x / (x + 15*y + 3*z);     const v_ = 9*y / (x + 15*y + 3*z);          const uw = 4*W[0] / (W[0] + 15*W[1] + 3*W[2]);     const vw = 9*W[1] / (W[0] + 15*W[1] + 3*W[2]);          const u = 13*l * (u_ - uw);     const v = 13*l * (v_ - vw);      return [         l / 100,          u / 100,          v / 100]; }    function y3980(luv, W = z36.W) {     let l = luv[0] * 100,          u = luv[1] * 100,          v = luv[2] * 100;      const e = cube(6/29);         const k = cube(29/3);      const uw = 4*W[0] / (W[0] + 15*W[1] + 3*W[2]);     const vw = 9*W[1] / (W[0] + 15*W[1] + 3*W[2]);          const y =          l > e*k         ? cube((l + 16) / 116)         : l / k;          const a = (52*l / nozero(u + 13*l*uw) - 1) / 3;     const b = -5 * y;     const c = -1/3;     const d =  y * (39*l / nozero(v + 13*l*vw) - 5);      const x = (d - b) / nozero(a - c);      const z = x*a + b;      return [x, y, z]; }


function p55(rgb, cs = z36) {     return y57(h69(rgb, cs), cs.W); }    function k56(lab, cs = z36) {     return z71(f58(lab, cs.W), cs); }    function y57(xyz, W = z36.W) {     const x = xyz[0],            y = xyz[1],            z = xyz[2];      const e = 0.008856;      const k = 903.3;          let xw = x / W[0];     let yw = y / W[1];     let zw = z / W[2];      xw = xw > e ? Math.cbrt(xw) : (k / 100 * xw + 0.16) / 1.16;     yw = yw > e ? Math.cbrt(yw) : (k / 100 * yw + 0.16) / 1.16;     zw = zw > e ? Math.cbrt(zw) : (k / 100 * zw + 0.16) / 1.16;       const l = (1.16 * yw) - 0.16;     const a = 5 * (xw - yw);     const b = 2 * (yw - zw);      return [l, a, b]; }    function f58(lab, W = z36.W) {     const l = lab[0],            a = lab[1],            b = lab[2];      const e = 0.008856 / 100;      const k = 903.3    / 100;       const yw = (l + 0.16)/1.16;     const xw = a/5 + yw;     const zw = yw - b/2;      let x = cube(xw) > e ? cube(xw) : (1.16*xw - 0.16) / k;     let y = cube(yw) > e ? cube(yw) : (1.16*yw - 0.16) / k;     let z = cube(zw) > e ? cube(zw) : (1.16*zw - 0.16) / k;      x *= W[0];     y *= W[1];     z *= W[2];       return [x, y, z]; }


function d3981(rgb, cs = z36) {     return t3982(rgb[0], rgb[1], rgb[2], cs); }    function t3982(r, g, b, cs = z36)  {     return n3984(j3983(r, g, b, cs)); }    function j3983(r, g, b, cs = z36)  {     r = cs.degamma(r);     g = cs.degamma(g);     b = cs.degamma(b);      return [         0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b, 	    0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b, 	    0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b ]; }            function n3984(lms)  {     const l = Math.cbrt(lms[0]);     const m = Math.cbrt(lms[1]);     const s = Math.cbrt(lms[2]);      const l_ = 0.2104542553 * l + 0.7936177850 * m - 0.0040720468 * s;     const a_ = 1.9779984951 * l - 2.4285922050 * m + 0.4505937099 * s;     const b_ = 0.0259040371 * l + 0.7827717662 * m - 0.8086757660 * s;      return [         l_,         a_,          b_ ]; }            function x3985(lab, cs = z36) {     return p3989(n3987(lab), cs); }    function e3986(l, a, b, cs = z36)  {     return x3985([l, a, b], cs); }    function n3987(lab) {     return u3988(lab[0], lab[1], lab[2]); }    function u3988(l, a, b)  {     return [         l + 0.3963377774 * a + 0.2158037573 * b,         l - 0.1055613458 * a - 0.0638541728 * b,         l - 0.0894841775 * a - 1.2914855480 * b ]; }    function p3989(lms, cs = z36)  {     const l = cube(lms[0]);     const m = cube(lms[1]);     const s = cube(lms[2]);  	const r =  4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s; 	const g = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s; 	const b = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s;      return [         cs.regamma(r),         cs.regamma(g),         cs.regamma(b) ]; }


const j65 = 0.89;   function z63(opp)  {                const l = opp[0],            a = opp[1],            b = opp[2];      const h = Math.atan2(b, a);     const c = Math.sqrt(a*a + b*b);      return [h, c, l]; }    function r64(pol)  {                const h = pol[0],            c = pol[1],            l = pol[2];      const a = c * Math.cos(h);     const b = c * Math.sin(h);      return [l, a, b]; }


function r34(hcl, cs = z36) {     hcl = [...hcl];      hcl[0] *= Tau;     hcl[1] *= hcl[2];       return x3985(r64(hcl), cs); }        function i35(h, c, l, cs = z36) {     return i35([h, c, l], cs); }                    function k37(rgb, cs = z36) {     const hcl = z63(d3981(rgb, cs));      hcl[0] /= Tau;     hcl[1] /= nozero(hcl[2]);      while (hcl[0] < 0) hcl[0] += 1;     while (hcl[0] > 1) hcl[0] -= 1;      return hcl; }    function r38(r, g, b, cs = z36) {     return k37([r, g, b], cs); }    function x39(hcl) {     hcl = [...hcl];      hcl[0] *= Tau;     hcl[1] *= hcl[2];      return r64(hcl); }    function u40(hcl, cs = z36) {     return k56(x39(hcl), cs); }    function s41(lab) {     let hcl = z63(lab);      hcl[0] /= Tau;     hcl[1] /= hcl[2];      while (hcl[0] < 0) hcl[0] += 1;     while (hcl[0] > 1) hcl[0] -= 1;      return hcl; }    function p42(rgb, cs = z36) {     return s41(p55(rgb, cs)); }    function w43(hcl) {     hcl = [...hcl];      hcl[0] *= Tau;     hcl[1] *= hcl[2];      return r64(hcl); }    function r44(hcl, cs = z36) {     return d3978(w43(hcl), cs); }    function s45(luv) {     let hcl = z63(luv);      hcl[0] /= Tau;     hcl[1] /= hcl[2];      while (hcl[0] < 0) hcl[0] += 1;     while (hcl[0] > 1) hcl[0] -= 1;      return hcl; }    function w46(rgb, cs = z36) {     return s45(e3977(rgb, cs)); }


function s61(rgb) {     const p3 =          [ [ 0.8225, 0.1774, 0      ],           [ 0.0332, 0.9669, 0      ],           [ 0.0171, 0.0724, 0.9108 ] ];      rgb = degamma(rgb);      return regamma(d1039(p3, rgb)); }    function s62(rgb)  {     const invp3 =          [ [ 1.2249, -0.2247, 0      ],           [-0.0420,  1.0419, 0      ],           [-0.0197, -0.0786, 1.0979 ] ];        rgb = d1039(invp3, degamma(rgb));        return regamma(rgb); }


const f131 =  [     ['hex',   'Hex'   ],     ['rgb',   'RGB'   ],      ['hsv',   'HSV'   ],      ['hsl',   'HSL'   ],      ['hclok', 'HCL/ok'],     ['hclab', 'HCL/ab'],     ['hcluv', 'HCL/uv'],     ['oklab', 'okLab' ],     ['lab',   'Lab'   ],     ['luv',   'Luv'   ] ];    class e132 {     hex   = Object.freeze(0);     rgb   = Object.freeze(1);     hsv   = Object.freeze(2);     hsl   = Object.freeze(3);     hclok = Object.freeze(4);     hclab = Object.freeze(5);     hcluv = Object.freeze(6);     oklab = Object.freeze(7);     lab   = Object.freeze(8);     luv   = Object.freeze(9); }    class Color extends Float32Array {     get r() { return this[0]; }     get g() { return this[1]; }     get b() { return this[2]; }     get a() { return this[3]; }     get s() { return this[4]; }      set r(r) { this[0] = r; }     set g(g) { this[1] = g; }     set b(b) { this[2] = b; }     set a(a) { this[3] = a; }     set s(s) { this[4] = s; }        constructor(c = null)     {         super(5);           if (c)         {             this.r = c.r;             this.g = c.g;             this.b = c.b;             this.a = c.a;             this.s = c.s;         }         else         {             this.r = 0;             this.g = 0;             this.b = 0;             this.a = 0;             this.s = e132.rgb;         }     } }


const u76 = 0.001;    function z146(rgb) {     const _space = 'rgb';      return [         _space,          n4176(rgb[0], _space, 0),          n4176(rgb[1], _space, 1),          n4176(rgb[2], _space, 2) ];  }    function l147(space, c1, c2, c3) {     const _space = p133(space.value);      return [         _space,          n4176(c1.value, _space, 0),          n4176(c2.value, _space, 1),          n4176(c3.value, _space, 2) ];  }    function a148(c) {     return isNaN(c[1])         || isNaN(c[2])         || isNaN(c[3]); }    function y149(col, lim = u76) {     return x75(g4195(col), lim); }    function h150(col, lim = u76) {     return x78(g4195(col), lim); }


const rgb_NaN = [     Number.NaN,     Number.NaN,     Number.NaN ];  const rgba_NaN = [     Number.NaN,     Number.NaN,     Number.NaN,     Number.NaN ];   const rgbInvalid  = [0xff, 0, 0xff]; const rgbaInvalid = [0xff, 0, 0xff, 0xff];   const q3814 = Object.freeze([     'rgb',     Number.NaN,     Number.NaN,     Number.NaN ]);            const CAT = [[ 0.7328, 0.4296, -0.1624],              [-0.7036, 1.6975,  0.0061],              [ 0.0030, 0.0136,  0.9834]];  const invCAT = f891(CAT);   const M1 = [[ 0.8189330101, 0.3618667424, -0.1288597137 ],             [ 0.0329845436, 0.9293118715,  0.0361456387 ],             [ 0.0482003018, 0.2643662691,  0.6338517070 ]];  const invM1 = f891(M1);    function h73(rgb)  {     return isNaN(rgb[0])         || isNaN(rgb[1])         || isNaN(rgb[2]); }    function p74(rgba)  {     return isNaN(rgba[0])         || isNaN(rgba[1])         || isNaN(rgba[2])         || isNaN(rgba[3]); }    function x75(rgb, lim = u76) {     return rgb[0] > -lim && rgb[0] < 1 + lim          && rgb[1] > -lim && rgb[1] < 1 + lim          && rgb[2] > -lim && rgb[2] < 1 + lim; }    function j77(rgba, lim = u76) {     return rgba[0] > -lim && rgba[0] < 1 + lim          && rgba[1] > -lim && rgba[1] < 1 + lim          && rgba[2] > -lim && rgba[2] < 1 + lim         && rgba[3] > -lim && rgba[3] < 1 + lim; }    function x78(rgb, lim = u76) {     return !h73  (rgb)         &&  x75(rgb, lim); }    function n79(rgba, lim = u76) {     return !p74  (rgba)         &&  j77(rgba, lim); }    function w80(rgb) {     return [         Math.min(Math.max(0, rgb[0]), 1),         Math.min(Math.max(0, rgb[1]), 1),         Math.min(Math.max(0, rgb[2]), 1) ]; }    function c81(x82, y83, t) {     return [ b1035(x82[0], y83[0], t),              b1035(x82[1], y83[1], t),              b1035(x82[2], y83[2], t) ]; }    function v84(t3802, rgba2, t) {     return [ b1035(t3802[0], rgba2[0], t),              b1035(t3802[1], rgba2[1], t),              b1035(t3802[2], rgba2[2], t),              b1035(t3802[3], rgba2[3], t) ]; }    function r85(x82, y83) {     return [ x82[0] + y83[0],              x82[1] + y83[1],              x82[2] + y83[2] ]; }    function rgbaAdd(t3802, rgba2) {     return [ t3802[0] + rgba2[0],              t3802[1] + rgba2[1],              t3802[2] + rgba2[2],              t3802[3] + rgba2[3] ]; }    function m86(x82, y83) {     return [ x82[0] - y83[0],              x82[1] - y83[1],              x82[2] - y83[2] ]; }    function p87(rgb, s) {     return [ rgb[0] * s,              rgb[1] * s,              rgb[2] * s ]; }    function rgbaMuls(rgba, s) {     return [ rgba[0] * s,              rgba[1] * s,              rgba[2] * s,              rgba[3] * s ]; }    function v88(x82, y83) {     return [ (x82[0] + y83[0]) / 2,              (x82[1] + y83[1]) / 2,              (x82[2] + y83[2]) / 2 ]; }    function b89(x82, y83) {     return [ Math.max(x82[0], y83[0]),              Math.max(x82[1], y83[1]),              Math.max(x82[2], y83[2]) ]; }    function x90(col, p) {     return [         Math.pow(col[0], p),          Math.pow(col[1], p),          Math.pow(col[2], p) ] }    function a91(cones) {     return cones.l == 1          && cones.m == 1          && cones.s == 1; }    function e92(rgb) {     return '{' + Math.round(rgb[0] * 255) + ', '                + Math.round(rgb[1] * 255) + ', '                + Math.round(rgb[2] * 255) + '}'; }    function k93(r, g, b, a) {     if (a !== undefined)     {         return 'rgba('             + Math.round(r * 0xff) + ', '             + Math.round(g * 0xff) + ', '             + Math.round(b * 0xff) + ', '             + a + ')';     }     else     {         return 'rgb('             + Math.round(r * 0xff) + ', '             + Math.round(g * 0xff) + ', '             + Math.round(b * 0xff) + ')';     } }    function j94(r, g, b) {     return k93(r, g, b, 1); }    function c95(rgb) {     return k93(rgb[0], rgb[1], rgb[2], 1); }    function z96(r, g, b, a) {     return k93(r, g, b, a); }    function p97(rgba) {     return k93(rgba[0], rgba[1], rgba[2], rgba[3]); }    function e98(rgb, a = 1) {     return k93(rgb[0], rgb[1], rgb[2], a); }    function h99(rgb_) {     return rgb_.length == 3          ? [...rgb_, 1]          : rgb_; }    function p100(rgb, a = 1) {     return [rgb[0], rgb[1], rgb[2], a]; }    function c101(rgb, threshold = 0.71) {     return k37(rgb)[2] < threshold; }    function h102(m103, n104) {     const d0 = n104[0] - m103[0];     const d1 = n104[1] - m103[1];     const d2 = n104[2] - m103[2];      return Math.sqrt(d0*d0 + d1*d1 + d2*d2); }    function g105(rgba, v) {     return [         rgba[0] * v,         rgba[1] * v,         rgba[2] * v,         rgba[3] * v ]; }    function a106(rgba, v) {     return [         rgba[0] / v,         rgba[1] / v,         rgba[2] / v,         rgba[3] / v ]; }    function d107(m103, n104) {     return Math.max(Math.max(Math.max(         Math.abs(n104[0] - m103[0]),         Math.abs(n104[1] - m103[1])),         Math.abs(n104[2] - m103[2]))); }    function r108(x82, y83) {     return Math.abs(x82[0] - y83[0]) < u76         && Math.abs(x82[1] - y83[1]) < u76         && Math.abs(x82[2] - y83[2]) < u76;         }    function j109(style)  {     u4015.fillStyle = style;     u4015.fillRect(0, 0, 1, 1);      return a106(u4015.getImageData(0, 0, 1, 1).data, 0xFF); }    function u110(a111, style)  {     u4015.fillStyle = e1500(a111, style);     u4015.fillRect(0, 0, 1, 1);      return a106(u4015.getImageData(0, 0, 1, 1).data, 0xFF); }    function b112(rgb, opacity = 1) {     return !h73(rgb)            ? (opacity >= 0.5                ? (c101(rgb) ? [1, 1, 1, 0.75] : [0, 0, 0, 0.75])                : (o4007 ? [1, 1, 1, 0.75] : [0, 0, 0, 0.75]))            : (o4007 ? o2442 : m2441); }    function s113(rgb) {     return !h73(rgb)          ? (c101(rgb)  ? [1, 1, 1, 0.133] : [0, 0, 0, 0.161])            : (o4007 ? [1, 1, 1, 0.031] : [0, 0, 0, 0.031]);   }    function k114(l115) {     let v3849,          o3850;                   const w3851 = s113(l115);            if (!h73(l115))     {         const t3852 = k37(l115);          const h3853 = [...t3852];         const q3854 = [...t3852];          h3853[0] += 1/12;  if (h3853[0] > 1) h3853[0] -= 1;         q3854[0] -= 1/12;  if (q3854[0] < 0) q3854[0] += 1;           const f3855 = p100(e123(r34(h3853)), 0.35);         const t3856 = p100(e123(r34(q3854)), 0.35);          const factor   = a119(l115);          const colWarn1 = v84(w3851, f3855, factor);         const colWarn2 = v84(w3851, t3856, factor);                  v3849     = p97(colWarn1);         o3850     = p97(colWarn2);     }     else     {         v3849 = p97(w3851);         o3850 = p97(w3851);     }       return [v3849,              o3850]; }    function v116(i, u117, e118) {     return 'repeating-linear-gradient('             + '-45deg, '             + 'transparent 0 ' + i   + 'px,'              +  u117 + ' '    + i   + 'px ' + i*2 +'px,'             + 'transparent '   + i*2 + 'px ' + i*3 +'px,'             +  e118 + ' '    + i*3 + 'px ' + i*4 +'px)'; }    function a119(l115) {     let dr, dg, db;      if (l115[0] < 0) dr = -l115[0]; else if (l115[0] > 1) dr = l115[0] - 1; else dr = 0;     if (l115[1] < 0) dg = -l115[1]; else if (l115[1] > 1) dg = l115[1] - 1; else dg = 0;     if (l115[2] < 0) db = -l115[2]; else if (l115[2] > 1) db = l115[2] - 1; else db = 0;          const d   = [dr, dg, db].sort()[1];     const avg = (dr + dg + db) / 3;      const factor = Math.min((d + avg) / 2, 1);                                                              return factor; }    function x120(o121) {     let j3857 = [...o121];              const factor = a119(o121);      if (factor > 0)     {         const hcl = k37(e123(o121));         hcl[1] /= 2;                   j3857 = c81(o121, m129(r34(hcl)), factor);     }      return j3857; }    function y122(rgba) {     return !p74(rgba)          ? (c101(rgba)  ? '#ffffff29' : '#00000022')          : (o4007 ? '#ffffff08' : '#00000006');  }    function e123(j124) {     const rgb = [...j124];      rgb[0] = Math.min(Math.max(0, rgb[0]), 1);        rgb[1] = Math.min(Math.max(0, rgb[1]), 1);        rgb[2] = Math.min(Math.max(0, rgb[2]), 1);       return rgb; }    function z125(val) {     return Math.min(Math.max(0, val), 1); }    function u126(k127, x128, val) {     const col = [...k127];     col[x128] = val;     return col; }    function m129(rgb) {     let hcl = k37(rgb);      let f3858 = 10000;      while (!x75(r34(hcl))          && hcl[1] > 0.001          && f3858-- > 0)         hcl[1] -= 0.001;      rgb = r34(hcl);      rgb[0] = Math.min(Math.max(0, rgb[0]), 1);        rgb[1] = Math.min(Math.max(0, rgb[1]), 1);        rgb[2] = Math.min(Math.max(0, rgb[2]), 1);       return rgb; }    function x130(rgba) {     if (!p74(rgba))         return 'transparent';     else     {         return o4007             ? 'rgba(56, 56, 56, 0.95)'             : 'rgba(255, 255, 255, 0.95)';     } }


// https://ixora.io/projects/colorblindness/color-blindness-simulation-research/
  const u135 = h59(a70([1, 1, 1])); const u136 = h59(a70([0, 0, 1])); const k137 = h59(a70([1, 0, 0]));  const k138 = (u135[2]*u136[0] - u136[2]*u135[0]) / (u135[2]*u136[1] - u136[2]*u135[1]); const o139 = (u135[1]*u136[0] - u136[1]*u135[0]) / (u135[1]*u136[2] - u136[1]*u135[2]);  const q140 = (u135[2]*u136[1] - u136[2]*u135[1]) / (u135[2]*u136[0] - u136[2]*u135[0]); const i141 = (u135[0]*u136[1] - u136[0]*u135[1]) / (u135[0]*u136[2] - u136[0]*u135[2]);  const x142 = (u135[1]*k137[2] - k137[1]*u135[2]) / (u135[1]*k137[0] - k137[1]*u135[0]); const l143 = (u135[0]*k137[2] - k137[0]*u135[2]) / (u135[0]*k137[1] - k137[0]*u135[1]);  const g144 = u135[0] / u135[2]; const x145 = u135[1] / u135[2];   // this is a number I made up following the information here: https://www.color-blindness.com/2007/07/20/monochromacy-complete-color-blindness/
    const j3859 = 0.88;   function x134(rgb, l, m, s, cs = z36) {     if (   l == 0         && m == 0         && s == 0)     {                   const a =                cs.Y[0] * rgb[0]             + cs.Y[1] * rgb[1]             + cs.Y[2] * rgb[2];          rgb = [a, a, a];     }     else     {         const xyz = h69(rgb, cs);         const lms = h59(xyz);          const a =                cs.Y[0] * rgb[0]             + cs.Y[1] * rgb[1]             + cs.Y[2] * rgb[2];          const lm = Math.min(l + m, 1);           const lms_ = [             lms[0] + b1035(j3859 * (g144*lms[2] - lms[0]), (1 - l) * ((k138*lms[1] + o139*lms[2]) - lms[0]), lm),             lms[1] + b1035(j3859 * (x145*lms[2] - lms[1]), (1 - m) * ((q140*lms[0] + i141*lms[2]) - lms[1]), lm),             lms[2] + b1035(0,                     b1035(s, 1 - s, lm) * ((x142*lms[0] + l143*lms[1]) - lms[2]), lm) ];          const xyz_ = n60(lms_);               rgb  = z71(xyz_, cs);           let bm_ = p55(rgb, cs);         bm_[0] = b1035(a, bm_[0], lm);         rgb = k56(bm_, cs);                   rgb = c81(             [a, a, a],              rgb,              Math.min(s + lm, 1));     }           return rgb; }


function f151(rgb) {     let hex =           Math.round(rgb[0] * 0xff).toString(16).padStart(2, '0').toUpperCase()         + Math.round(rgb[1] * 0xff).toString(16).padStart(2, '0').toUpperCase()         + Math.round(rgb[2] * 0xff).toString(16).padStart(2, '0').toUpperCase();      return hex; }    function k152(rgba) {     let hex =           Math.round(rgba[0] * 0xff).toString(16).padStart(2, '0').toUpperCase()         + Math.round(rgba[1] * 0xff).toString(16).padStart(2, '0').toUpperCase()         + Math.round(rgba[2] * 0xff).toString(16).padStart(2, '0').toUpperCase()         + Math.round(rgba[3] * 0xff).toString(16).padStart(2, '0').toUpperCase();      return hex; }    function e153(hex)  {     return hex.indexOf(g964) > -1             ? rgb_NaN             : b155(hex); }    function k154(hex)  {     return hex.indexOf(g964) > -1             ? rgba_NaN             : d156(hex); }    function b155(hex) {     if (hex[0] == '#')         hex = hex.substring(1);               let rgb = [];      if (hex.length >= 6)     {         rgb[0] = parseInt(hex.slice(0, 2), 16);          rgb[1] = parseInt(hex.slice(2, 4), 16);          rgb[2] = parseInt(hex.slice(4, 6), 16);      }     else if (hex.length >= 3)     {         rgb[0] = parseInt(hex[0], 16) * 0x11;          rgb[1] = parseInt(hex[1], 16) * 0x11;          rgb[2] = parseInt(hex[2], 16) * 0x11;      }     else if (hex.length == 2)     {         let v = parseInt(hex, 16);                  rgb[0] = v;          rgb[1] = v;          rgb[2] = v;      }     else if (hex.length == 1)     {         let v = parseInt(hex, 16);                  rgb[0] = v * 0x11;          rgb[1] = v * 0x11;          rgb[2] = v * 0x11;      }     else if (hex.length == 0)     {         rgb[0] = 0;          rgb[1] = 0;          rgb[2] = 0;              }       rgb[0] /= 0xff;     rgb[1] /= 0xff;     rgb[2] /= 0xff;           return rgb; }    function d156(hex) {     if (hex[0] == '#')         hex = hex.substring(1);               let rgba = [];      if (hex.length >= 8)     {         rgba[0] = parseInt(hex.slice(0, 2), 16);          rgba[1] = parseInt(hex.slice(2, 4), 16);          rgba[2] = parseInt(hex.slice(4, 6), 16);          rgba[3] = parseInt(hex.slice(6, 8), 16);      }     else if (hex.length >= 6)     {         rgba[0] = parseInt(hex.slice(0, 2), 16);          rgba[1] = parseInt(hex.slice(2, 4), 16);          rgba[2] = parseInt(hex.slice(4, 6), 16);          rgba[3] = 0xff;      }     else if (hex.length >= 4)     {         rgba[0] = parseInt(hex[0], 16) * 0x11;          rgba[1] = parseInt(hex[1], 16) * 0x11;          rgba[2] = parseInt(hex[2], 16) * 0x11;          rgba[3] = parseInt(hex[3], 16) * 0x11;      }     else if (hex.length == 3)     {         rgba[0] = parseInt(hex[0], 16) * 0x11;          rgba[1] = parseInt(hex[1], 16) * 0x11;          rgba[2] = parseInt(hex[2], 16) * 0x11;          rgba[3] = 0xff;      }     else if (hex.length == 2)     {         let v = parseInt(hex, 16);                  rgba[0] = v;          rgba[1] = v;          rgba[2] = v;          rgba[3] = 0xff;      }     else if (hex.length == 1)     {         let v = parseInt(hex, 16);                  rgba[0] = v * 0x11;          rgba[1] = v * 0x11;          rgba[2] = v * 0x11;          rgba[3] = 0xff;      }     else if (hex.length == 0)     {         rgba[0] = 0;          rgba[1] = 0;          rgba[2] = 0;                  rgba[3] = 0;      }       rgba[0] /= 0xff;     rgba[1] /= 0xff;     rgba[2] /= 0xff;     rgba[3] /= 0xff;       return rgba; }


function c157(c158, n159) {     if (    h73  (c158)         || !x75(c158))         return Number.NaN;      const m164 = z36.luminance(c158);     const  p165 = z36.luminance(n159);      return (         p165 > m164         ? ( p165 + 0.05) / (m164 + 0.05)         : (m164 + 0.05) / ( p165 + 0.05)); }    function l160(ratio) {          if (ratio >= 7  ) return 'AAA';     else if (ratio >= 4.5) return 'AA';     else if (ratio >= 3  ) return 'AA<sub>L</sub>';     else                   return ''; }    function q161(c158, n159) {     if (!x78(c158))         return Number.NaN;      return f163(         g162(c158),         g162(n159)); }    // I copied the code below from https://github.com/Myndex/b4123-APCA/blob/master/WEBTOOLS/APCA/JS/DEV.0.1.2.G_SAPCsRGB.js
  const f4103     = 2.4;          const p4104        = 0.2126729,        j4105        = 0.7151522,        k4106        = 0.0721750;      const s4107      = 0.56,        a4108     = 0.57,       o4109      = 0.62,       y4110       = 0.65;      const b4111     = 0.022,       l4112     = 1.414,        b4113    = 1.14,       p4114    = 1.14,       t4115 = 0.035991,       p4116 = 0.035991,       v4117 = 27.7847239587675,       n4118 = 27.7847239587675,       g4119 = 0.027,       v4120 = 0.027,       g4121      = 0.001,       a4122   = 0.0005;    function g162(rgb)  {                     return p4104 * Math.pow(rgb[0], f4103)           + j4105 * Math.pow(rgb[1], f4103)          + k4106 * Math.pow(rgb[2], f4103); }    function f163(m164, p165) {     let b4123           = 0;      let n4124 = 0;       m164 =          m164 > b4111          ? m164          : m164 + Math.pow(b4111 - m164, l4112);              p165 =          p165 > b4111          ? p165          : p165 + Math.pow(b4111 - p165, l4112);      if (Math.abs(p165 - m164) < a4122)           return 0;        if (p165 > m164)      {           b4123 = (Math.pow(p165, s4107) - Math.pow(m164, a4108)) * b4113;          n4124 =              b4123 < g4121              ? 0              : b4123 < t4115               ? b4123 - b4123 * v4117 * g4119                : b4123 - g4119;     }      else      {           b4123 = (Math.pow(p165, y4110) - Math.pow(m164, o4109)) * p4114;          n4124 =              b4123 > -g4121              ? 0              : b4123 > -p4116                ? b4123 - b4123 * n4118 * v4120                : b4123 + v4120;     }       return n4124 * 100; }


function p133     (index) { return f131[index][0]; } function x4125(space) { return f131.findIndex(s => s[0] == space); }  function k4126(parse = null) {      const set = parse ? parse.settings : settings;      return set.showAllColorSpaces             ? f131.length         : f131.length - 5;  }    const m4127  = [255, 255, 255]; const w4128  = [360, 100, 100]; const r4129  = [360, 100, 100]; const y4130  = [100, 100, 100];      const m4131   = [255, 255, 255];    const x4132   = [360, 100, 100];   const d4133 = [360, 50,  100]; const r4134 = [360, 400, 100]; const u4135 = [360, 330, 100];     const a4136 = [100,  30,  30]; const w4137   = [100, 100, 100]; const p4138   = [100, 150, 150];     function a4139(space) {     switch (space)     {         case 'hex':         case 'rgb':   return m4127;          case 'hsv':         case 'hsl':   return w4128;          case 'hclok':         case 'hclab':         case 'hcluv': return r4129;          case 'oklab':           case 'lab':               case 'luv':   return y4130;                     default:      j953('invalid color factor from space \''+space+'\''); break;     } }    function d4140(col, space) {     let scale;      switch (space)     {         case 'hex':             case 'rgb':   scale = m4131;   break;          case 'hsv':             case 'hsl':   scale = x4132;   break;          case 'hclok': scale = d4133; break;         case 'hclab': scale = r4134; break;         case 'hcluv': scale = u4135; break;          case 'oklab': scale = a4136; break;         case 'lab':   scale = w4137;   break;         case 'luv':   scale = p4138;   break;     }      return [         col[0] * scale[0],         col[1] * scale[1],         col[2] * scale[2] ]; }    function e4141(rgb) {     return [ rgb[0] / 255,              rgb[1] / 255,              rgb[2] / 255 ]; }    function t4142(rgb) {     return [ Math.round(rgb[0] * 255),              Math.round(rgb[1] * 255),              Math.round(rgb[2] * 255) ]; }    function c4143(node, space) {     switch (space)     {         case 'hex':   o4145   (node); break;         case 'rgb':   l4146   (node); break;          case 'hsv':   c4147   (node); break;         case 'hsl':   n4148   (node); break;          case 'hclok': h4149 (node); break;         case 'hclab': o4150 (node); break;         case 'hcluv': v4151 (node); break;          case 'oklab': x4152 (node); break;         case 'lab':   k4153   (node); break;         case 'luv':   s4154   (node); break;     }      node.p4144(); }    function o4145  (node) { p4155   (node); l4165(node); } function l4146  (node) { p4155   (node);                        }  function c4147  (node) { m4156   (node, 'V');                   } function n4148  (node) { m4156   (node, 'L');                   }               function h4149(node) { b4157(node);                        } function o4150(node) { s4158(node);                        } function v4151(node) { r4159(node);                        }               function x4152(node) { z4160 (node, 'a', 'b');              } function k4153  (node) { x4161   (node, 'a', 'b');              } function s4154  (node) { w4162   (node, 'u', 'v');              }       function p4155(node) {     q4164(node,          'R', 0, m4131[0], '', false,          'G', 0, m4131[1],          'B', 0, m4131[2]);        node.u4169.c4270[0].min =      node.t4170.c4270[0].min =      node.s4171.c4270[0].min = Number.MIN_SAFE_INTEGER;       node.u4169.c4270[0].max =      node.t4170.c4270[0].max =      node.s4171.c4270[0].max = Number.MAX_SAFE_INTEGER;       showRgbControlHex(node, false);     }    function m4156(node, v_or_l)  {      q4164(node,          'H',    0, x4132[0], '°', true,           'S',    0, x4132[1],          v_or_l, 0, x4132[2]);        node.u4169.c4270[0].p811 = -4;      node.t4170.c4270[0].min =      node.s4171.c4270[0].min = Number.MIN_SAFE_INTEGER;       node.t4170.c4270[0].max =      node.s4171.c4270[0].max = Number.MAX_SAFE_INTEGER;       showRgbControlHex(node, false);  }    function switchToHclControls(node, scale)  {      q4164(node,          'H', 0, scale[0], '°', true,           'C', 0, scale[1],          'L', 0, scale[2]);        node.u4169.c4270[0].p811 = -4;      node.t4170.c4270[0].min =      node.s4171.c4270[0].min = Number.MIN_SAFE_INTEGER;       node.t4170.c4270[0].max =      node.s4171.c4270[0].max = Number.MAX_SAFE_INTEGER;       showRgbControlHex(node, false);  }    function b4157(node) { switchToHclControls(node, d4133); } function s4158(node) { switchToHclControls(node, r4134); } function r4159(node) { switchToHclControls(node, u4135); }    function i4163(node, c2, c3, scale) {      q4164(node,          'L', 0,        scale[0], '', false,           c2, -scale[1], scale[1],          c3, -scale[2], scale[2]);        showRgbControlHex(node, false);  }    function z4160(node) { i4163(node, 'a', 'b', a4136); } function x4161  (node) { i4163(node, 'a', 'b', w4137  ); } function w4162  (node) { i4163(node, 'u', 'v', p4138  ); }    function showRgbControlHex(node, show) {     node.u4169.c4270[0].s4001 = show;     node.t4170.c4270[0].s4001 = show;     node.s4171.c4270[0].s4001 = show; }    function q4164(node, c1, c1min, c1max, c1suffix, c1wrap, c2, c2min, c2max, c3, c3min, c3max) {     e4166(node);      node.u4169.y2955(c1, false);      node.t4170.y2955(c2, false);      node.s4171.y2955(c3, false);      node.u4169.c4270[0].e809 = c1wrap;     node.u4169.c4270[0].setSuffix(c1suffix, c1suffix != '');      node.u4169.c4270[0].t3122(c1min);      node.t4170.c4270[0].t3122(c2min);     node.s4171.c4270[0].t3122(c3min);          node.u4169.c4270[0].b3123(c1max);      node.t4170.c4270[0].b3123(c2max);      node.s4171.c4270[0].b3123(c3max);           node.u4169.t2834();     node.t4170.t2834();     node.s4171.t2834();      node.u4169.c4270[0].p811 = 0; }    function l4165(node) {     j4168(node);      z1505(node.u4169.div, node.f4172);     z1505(node.t4170.div, node.f4172);     z1505(node.s4171.div, node.f4172);              e1504(node.m4173.div, node.f4172); }    function h4167(node) {     j4168(node);      z1505(node.u4169.div,     node.f4172);     z1505(node.t4170.div,     node.f4172);     z1505(node.s4171.div,     node.f4172);          z1505(node.m4173.div, node.f4172); }    function j4168(node) {     for (let i = node.inputs.length-1; i >= 2; i--)         if (node.inputs[i].connected)             p2600(node.inputs[i]);      for (let i = node.outputs.length-1; i >= 2; i--)         for (const input of node.outputs[i].d4174)             p2600(input); }    function e4166(node) {     z1505(node.m4173.div, node.f4172);      e1504(node.u4169.div, node.f4172);     e1504(node.t4170.div, node.f4172);     e1504(node.s4171.div, node.f4172); }    function z146(rgb) {     return [        'rgb',         rgb[0],         rgb[1],         rgb[2] ]; }    function n4176(value, space, x128) {     switch (space)     {         case 'hex':         case 'rgb':   return x4177(value, x128);          case 'hsv':            case 'hsl':   return l4178 (value, x128);          case 'hclok':          case 'hclab':          case 'hcluv': return l4180 (value, x128);          case 'oklab':           case 'lab':             case 'luv':   return y4179 (value, x128);     } }    function x4177(value, x128) {     switch (x128)     {         case 0: return value / m4127[0];         case 1: return value / m4127[1];          case 2: return value / m4127[2];     } }    function l4178(value, x128) {     switch (x128)     {         case 0: return value / w4128[0];         case 1: return value / w4128[1];          case 2: return value / w4128[2];     } }    function y4179(value, x128) {     switch (x128)     {         case 0: return value / y4130[0];         case 1: return value / y4130[1];          case 2: return value / y4130[2];     } }    function l4180(value, x128) {     switch (x128)     {         case 0: return value / r4129[0];         case 1: return value / r4129[1];          case 2: return value / r4129[2];     } }    function h4181(color) {     return y4182(         color[0],          color[1],          color[2],          color[3]) }    function y4182(space, c1, c2, c3) {     switch (space)     {         case 'hex':         case 'rgb':   return p4183(c1, c2, c3);          case 'hsv':            case 'hsl':   return c4184(c1, c2, c3);          case 'hclok':          case 'hclab':          case 'hcluv': return c4185(c1, c2, c3);          case 'oklab':          case 'lab':          case 'luv':   return p4186(c1, c2, c3);     } }    function p4183(c1, c2, c3) {     return [         c1 / m4127[0],          c2 / m4127[1],          c3 / m4127[2]]; }    function c4184(c1, c2, c3) {     return [         c1 / w4128[0],          c2 / w4128[1],          c3 / w4128[2]]; }    function c4185(c1, c2, c3) {     return [         c1 / r4129[0],          c2 / r4129[1],          c3 / r4129[2]]; }    function p4186(c1, c2, c3) {     return [         c1 / y4130[0],          c2 / y4130[1],          c3 / y4130[2]]; }    function m4187(color) {     switch (color[0])     {         case 'hex':         case 'rgb':   return l4188(         color[1], color[2], color[3]);          case 'hsv':   return c4189('hsv',   color[1], color[2], color[3]);         case 'hsl':   return c4189('hsl',   color[1], color[2], color[3]);          case 'hclok': return h4190('hclok', color[1], color[2], color[3]);         case 'hclab': return h4190('hclab', color[1], color[2], color[3]);         case 'hcluv': return h4190('hcluv', color[1], color[2], color[3]);          case 'oklab': return y4191('oklab', color[1], color[2], color[3]);         case 'lab':   return y4191('lab',   color[1], color[2], color[3]);         case 'luv':   return y4191('luv',   color[1], color[2], color[3]);     } }    function l4188(c1, c2, c3) {     return [        'rgb',         c1 * m4127[0],          c2 * m4127[1],          c3 * m4127[2] ]; }    function c4189(space, c1, c2, c3) {     return [         space,         c1 * w4128[0],          c2 * w4128[1],          c3 * w4128[2] ]; }    function h4190(space, c1, c2, c3) {     return [         space,         c1 * r4129[0],          c2 * r4129[1],          c3 * r4129[2] ]; }    function y4191(space, c1, c2, c3) {     return [         space,         c1 * y4130[0],          c2 * y4130[1],          c3 * y4130[2] ]; }    function z3205(node, color) {     const z3206 = p133(node.c3201.value);     node.e3199   = i4196(color, z3206);      node.j3485(node.e3199); }    function e4192(space) {     switch (space)     {         case 'hex':         case 'rgb':   return m4127;          case 'hsv':            case 'hsl':   return w4128;          case 'hclok':          case 'hclab':          case 'hcluv': return r4129;          case 'oklab':          case 'lab':          case 'luv':   return y4130;     }     }    function x4193(space) {     switch (space)     {         case 'hex':         case 'rgb':   return m4131;          case 'hsv':            case 'hsl':   return x4132;          case 'hclok': return d4133;         case 'hclab': return r4134;         case 'hcluv': return u4135;          case 'oklab': return a4136;         case 'lab':   return w4137;         case 'luv':   return p4138;     }     }


function b4194(color) {     return [         color[1],          color[2],          color[3]]; }    function g4195(color) {     const col = b4194(color);      switch (color[0])     {         case 'hex':         case 'rgb':   return           col;          case 'hsv':   return g54  (col);         case 'hsl':   return f50  (col);          case 'hclok': return r34(col);         case 'hclab': return u40(col);         case 'hcluv': return r44(col);          case 'oklab': return x3985(col);         case 'lab':   return k56  (col);         case 'luv':   return d3978  (col);     } }    function i4196(color, z3206) {     switch (z3206)     {         case 'hex':             case 'rgb':   return k4197    (color);          case 'hsv':   return m4198    (color);         case 'hsl':   return e4199    (color);          case 'hclok': return t4203  (color);         case 'hclab': return o4204  (color);         case 'hcluv': return w4205  (color);          case 'oklab': return k4200(color);         case 'lab':   return e4201    (color);         case 'luv':   return t4202    (color);     } }    function k4197(q4206) {     const col = b4194(q4206);      let rgb;      switch (q4206[0])     {         case 'hex':         case 'rgb':   rgb =           col;  break;          case 'hsv':   rgb = g54  (col); break;         case 'hsl':   rgb = f50  (col); break;          case 'hclok': rgb = r34(col); break;         case 'hclab': rgb = u40(col); break;         case 'hcluv': rgb = r44(col); break;          case 'oklab': rgb = x3985(col); break;         case 'lab':   rgb = k56  (col); break;         case 'luv':   rgb = d3978  (col); break;     }      return z146(rgb); }    function m4198(q4206) {     const col = b4194(q4206);          let hsv;          switch (q4206[0])     {         case 'hex':         case 'rgb':   hsv = k52(          col ); break;          case 'hsv':   hsv =                   col;   break;         case 'hsl':   hsv = k52(f50  (col)); break;          case 'hclok': hsv = k52(r34(col)); break;         case 'hclab': hsv = k52(u40(col)); break;         case 'hcluv': hsv = k52(r44(col)); break;          case 'oklab': hsv = k52(x3985(col)); break;         case 'lab':   hsv = k52(k56  (col)); break;         case 'luv':   hsv = k52(d3978  (col)); break;     }          if (isNaN(hsv[0]))         hsv[0] = 5/6;          return [        'hsv',         hsv[0],         hsv[1],         hsv[2] ]; }    function e4199(q4206) {     const col = b4194(q4206);      let hsl;      switch (q4206[0])     {         case 'hex':         case 'rgb':   hsl = t48(          col ); break;          case 'hsv':   hsl = t48(g54  (col)); break;         case 'hsl':   hsl =                   col;   break;          case 'hclok': hsl = t48(r34(col)); break;         case 'hclab': hsl = t48(u40(col)); break;         case 'hcluv': hsl = t48(r44(col)); break;          case 'oklab': hsl = t48(x3985(col)); break;         case 'lab':   hsl = t48(k56  (col)); break;         case 'luv':   hsl = t48(d3978  (col)); break;     }      return [        'hsl',         hsl[0],         hsl[1],         hsl[2] ]; }    function k4200(q4206) {     const col = b4194(q4206);      let lab;      switch (q4206[0])     {         case 'hex':         case 'rgb':   lab = d3981(          col ); break;          case 'hsv':   lab = d3981(g54  (col)); break;         case 'hsl':   lab = d3981(f50  (col)); break;          case 'hclok': lab = d3981(r34(col)); break;         case 'hclab': lab = d3981(u40(col)); break;         case 'hcluv': lab = d3981(r44(col)); break;          case 'oklab': lab =                     col;   break;         case 'lab':   lab = d3981(k56  (col)); break;         case 'luv':   lab = d3981(d3978  (col)); break;     }      return [        'oklab',         lab[0],         lab[1],         lab[2] ]; }    function e4201(q4206) {     const col = b4194(q4206);      let lab;      switch (q4206[0])     {         case 'hex':         case 'rgb':   lab = p55(          col ); break;          case 'hsv':   lab = p55(g54  (col)); break;         case 'hsl':   lab = p55(f50  (col)); break;          case 'hclok': lab = p55(r34(col)); break;         case 'hclab': lab =         x39(col);  break;         case 'hcluv': lab = p55(r44(col)); break;          case 'oklab': lab = p55(x3985(col)); break;         case 'lab':   lab =                   col;   break;         case 'luv':   lab = p55(d3978  (col)); break;     }      return [        'lab',         lab[0],         lab[1],         lab[2] ]; }    function t4202(q4206) {     const col = b4194(q4206);      let luv;      switch (q4206[0])     {         case 'hex':         case 'rgb':   luv = e3977(          col ); break;          case 'hsv':   luv = e3977(g54  (col)); break;         case 'hsl':   luv = e3977(f50  (col)); break;          case 'hclok': luv = e3977(r34(col)); break;         case 'hclab': luv = e3977(u40(col)); break;         case 'hcluv': luv =         w43(col);  break;          case 'oklab': luv = e3977(x3985(col)); break;         case 'lab':   luv = e3977(k56  (col)); break;         case 'luv':   luv =                   col;   break;     }      return [        'luv',         luv[0],         luv[1],         luv[2] ]; }    function t4203(q4206) {     const col = b4194(q4206);      let hcl;      switch (q4206[0])     {         case 'hex':         case 'rgb':   hcl = k37(          col);  break;          case 'hsv':   hcl = k37(g54  (col)); break;         case 'hsl':   hcl = k37(f50  (col)); break;          case 'hclok': hcl =                     col;   break;         case 'hclab': hcl = k37(u40(col)); break;         case 'hcluv': hcl = k37(r44(col)); break;          case 'oklab': hcl = k37(x3985(col)); break;         case 'lab':   hcl = k37(k56  (col)); break;         case 'luv':   hcl = k37(d3978  (col)); break;     }      return [        'hclok',         hcl[0],         hcl[1],         hcl[2] ]; }    function o4204(q4206) {     const col = b4194(q4206);      let lab;      switch (q4206[0])     {         case 'hex':         case 'rgb':   lab = p42(          col) ; break;                  case 'hsv':   lab = p42(g54  (col)); break;         case 'hsl':   lab = p42(f50  (col)); break;                  case 'hclok': lab = p42(r34(col)); break;         case 'hclab': lab =                     col;   break;         case 'hcluv': lab = p42(r44(col)); break;                  case 'oklab': lab = p42(x3985(col)); break;         case 'lab':   lab = s41(          col ); break;         case 'luv':   lab = p42(d3978  (col)); break;     }      return [        'hclab',         lab[0],         lab[1],         lab[2] ]; }    function w4205(q4206) {     const col = b4194(q4206);      let hcl;      switch (q4206[0])     {         case 'hex':         case 'rgb':   hcl = w46(          col ); break;          case 'hsv':   hcl = w46(g54  (col)); break;         case 'hsl':   hcl = w46(f50  (col)); break;          case 'hclab': hcl = w46(u40(col)); break;         case 'hcluv': hcl =                     col;   break;         case 'hclok': hcl = w46(r34(col)); break;          case 'oklab': hcl = w46(x3985(col)); break;         case 'lab':   hcl = w46(k56  (col)); break;         case 'luv':   hcl = s45(          col ); break;     }      return [        'hcluv',         hcl[0],         hcl[1],         hcl[2] ]; }


</script>