<script id='generatorScript' type='javascript/worker'>



function setStyle(id, properties)
{
    var elem = document.getElementById(id);

    for (var property in properties)
        elem.style[property] = properties[property];
}


function indexOfChild(parent, child)
{
    return Array.prototype.indexOf.call(parent.children, child);
}

function containsChild(parent, child)
{
    return child.parentNode == parent;
}


function forwardEvent(event, element)
{
    var e = new event.constructor(event.type, event);
    element.dispatchEvent(e);
}


// function triggerMouseEvent(element, event, px, py, button = 0)
// {
//     const e = new MouseEvent(event, 
//     {
//         clientX: px,
//         clientY: py,
//         button:  button
//     });

//     element.dispatchEvent(e);
// }


function removeFromArray(obj, array)
{
    array.splice(array.indexOf(obj), 1);
}


function clearChildren(parent) 
{
    while (parent.firstChild)
        parent.removeChild(parent.firstChild);
}


function colorStyle_(r, g, b, a)
{
    if (a != undefined)
    {
        return 'rgba('
            + Math.round(r * 0xff) + ', '
            + Math.round(g * 0xff) + ', '
            + Math.round(b * 0xff) + ', '
            + a + ')';
    }
    else
    {
        return 'rgb('
            + Math.round(r * 0xff) + ', '
            + Math.round(g * 0xff) + ', '
            + Math.round(b * 0xff) + ')';
    }
}


function colorStyle(rgb)
{
    return colorStyle_(rgb[R], rgb[G], rgb[B], 1);
}


function numToString(num, dec)
{
    var str = Number(num).toFixed(dec).toString();

    var i = 0;

    // find decimal place

    while (   i < str.length 
           && str[i] !== '.' 
           && str[i] !== ',')
        i++;

    if (i >= str.length) // if no decimal place
        return str;

    i = str.length-1;

    while (i >= 0 && str[i] === '0')
        str = str.substring(0, i--);

    if (str[i] === '.' || str[i] === ',') // hack because JavaScript has shit support for locales
        str = str.substring(0, i--);

    return str;
}


function isEmptyObject(obj)
{
    if (obj == null)
        return false;
        
    return (
           Object.keys(obj).length === 0 
        && obj.constructor === Object);
}


function shallowCopy(obj)
{
    return Object.assign({}, obj);
}


function deepCopy(obj)
{
    return JSON.parse(JSON.stringify(obj));
}


function createSvg(element)
{
    var svg = document.createElementNS('http://www.w3.org/2000/svg', element);
    svg.style.pointerEvents = 'none';
    return svg;
}


function show(element) { element.style.visibility = 'visible'; }
function hide(element) { element.style.visibility = 'hidden'; }


function colorFromDataType(dataType, active)
{
    switch (dataType)
    {
        case 'OBJ': return active ? ACTIVE_OBJ_COLOR : OBJ_COLOR;
        case 'NUM': return active ? ACTIVE_NUM_COLOR : NUM_COLOR;
    }

    return 'magenta';
}


const OBJ_COLOR = '#bee0ff';
const NUM_COLOR = '#ddd';

const ACTIVE_OBJ_COLOR = '#18a0fb';
const ACTIVE_NUM_COLOR = '#787878';

const IO_COLOR = 'rgba(0, 0, 0, 0.12)';


const R = 0, G = 1, B = 2, A = 3;
const Eps = 0.0000001;

function nozero(x)
{
    return x != 0 ? x : Eps;
}


function getDigitCount(i)
{
    var l = Math.floor(Math.log10(Math.abs(i))); // the minus sign doesn't count as a digit;
    return l + 1;
}


function isDigit(key)
{
    var is = 
           key >= '0' 
        && key <= '9';

    return is;
}

function isHexLetter(key)
{
    var is =
           key.length == 1
        && (   key >= 'A' && key <= 'F'
            || key >= 'a' && key <= 'f');

    return is;
}


function getNumberString(num, dec)
{
    var str = Number(num).toFixed(dec).toString();

    var i = 0;

    // find decimal place

    while (i < str.length && str[i] !== '.' && str[i] !== ',')
        i++;

    if (i >= str.length) // if no decimal place
        return str;

    i = str.length-1;

    while (i >= 0 && str[i] === '0')
    str = str.substring(0, i--);
    
    if (   str[i] === '.' 
        || str[i] === ',') // hack because JavaScript
        str = str.substring(0, i--);
    
    return str;
}    


const Tau = Math.PI * 2;
const phi = (Math.sqrt(5) - 1) / 2; // 0.618
const Phi = (Math.sqrt(5) + 1) / 2; // 1.618


function sqr (x) { return x*x;   };
function cube(x) { return x*x*x; };


function distance(p1, p2)
{
    var dx = p2.x - p1.x;
    var dy = p2.y - p1.y;

    return Math.sqrt(dx*dx + dy*dy);
}

function distance_(x1, y1, x2, y2)
{
    var dx = x2 - x1;
    var dy = y2 - y1;

    return Math.sqrt(dx*dx + dy*dy);
}


function vector(angle, dist)
{
    return { 
        x: dist * Math.cos(angle), 
        y: dist * Math.sin(angle) };
}


function equalv(v1, v2)
{
    return v1.x == v2.x
        && v1.y == v2.y;
}

function lengthv(v)
{
    return Math.sqrt(v.x*v.x + v.y*v.y);
}

function unitv(v)
{
    return { x: v.x == 0 ? 0 : v.x / lengthv(v),
             y: v.y == 0 ? 0 : v.y / lengthv(v) };
}

function addv(v1, v2)
{
    return { x: v1.x + v2.x,
             y: v1.y + v2.y };
}	


function subv(v1, v2)
{
    return { x: v1.x - v2.x,
             y: v1.y - v2.y };
}	


function mulv(v1, v2)
{
    return { x: v1.x * v2.x,
             y: v1.y * v2.y };
}	

function mulvs(v, s)
{
    return { x: v.x * s,
             y: v.y * s };
}	


function divvs(v, s)
{
    return { x: v.x / s,
             y: v.y / s };
}	


function crossv(v)
{
    // returns a cross product of v and the unit vector pointing up the Z axis

    return { x:  v.y, 
             y: -v.x };
}


function crossv2(v1, v2)
{
    // returns the magnitude of v1×v2 = ‖v1‖‖v2‖sinθ "perpendicular dot product",
    // equivalent to dot(v1, cross(v2)) (same as in 3D with a Z component of 0)
    // also the area of the parallelogram between the two vectors
    // also determinant of 2×2 matrix built from the two vectors
    // positive if turn from v1 to v2 is clockwise

    return (v1.x * v2.y 
          - v1.y * v2.x);
}	


function anglev(v1, v2)
{
    return anglev_(v1.x, v1.y, v2.x, v2.y);
}


function anglev_(x1, y1, x2, y2)
{
    var dx = x2 - x1;
    var dy = y2 - y1;

    var angle = Math.atan2(dy, dx);
    if (angle < 0) angle += Tau;

    return angle;
}


function clipEdge(p, q, t0, t1)
{
    if (p == 0 && q < 0)
    {
        return null;
    }
    else if (p < 0)
    {
        var r = q/p;

             if (r > t1) return null;
        else if (r > t0) t0 = r;
    }
    else if (p > 0)
    {
        var r = q/p;

             if (r < t0) return null;
        else if (r < t1) t1 = r;
    }

    return [t0, t1];
}



function clipLine(x1, y1, x2, y2, left, top, right, bottom)
{
    var t0 = 0;
    var t1 = 1;

    var dx = x2 - x1;
    var dy = y2 - y1;

    var cl = clipEdge(-dx, -(left - x1), t0, t1); if (cl != null) { t0 = cl[0]; t1 = cl[1]; } else return null;
    var cr = clipEdge( dx, right - x1,   t0, t1); if (cr != null) { t0 = cr[0]; t1 = cr[1]; } else return null;
    var ct = clipEdge(-dy, -(top - y1),  t0, t1); if (ct != null) { t0 = ct[0]; t1 = ct[1]; } else return null;
    var cb = clipEdge( dy, bottom - y1,  t0, t1); if (cb != null) { t0 = cb[0]; t1 = cb[1]; } else return null;

    if (t1 < 1)
    {
        x2 = x1 + t1*dx;
        y2 = y1 + t1*dy;
    }

    if (t0 > 0)
    {
        x1 = x1 + t0*dx;
        y1 = y1 + t0*dy;
    }

    return [
        {x:x1, y:y1}, 
        {x:x2, y:y2} ];
}



function intersect(p1, p2, q1, q2, segment)
{
    if (   equalv(p1, p2) 
        || equalv(q1, q2)) 
        return {x:NaN, y:NaN}; // undefined line

    var v1 = subv(p2, p1);
    var v2 = subv(q2, q1);

    if (crossv2(v1, v2) == 0) 
        return {x:NaN, y:NaN}; // parallel lines

    var t1 = crossv2(subv(q1, p1), v2) / crossv2(v1, v2);
    var t2 = crossv2(subv(q1, p1), v1) / crossv2(v1, v2);

    if ((  0 <= t1 && t1 <= 1
        && 0 <= t2 && t2 <= 1)
        || !segment)
        return addv(p1, mulvs(v1, t1));
        
    return {x:NaN, y:NaN};
}



function closestPointOnLine(l0, l1, p, segment)
{
    if (equalv(p, l0))
        return l0;
        
    var d = mulvs(
        unitv(crossv(subv(l1, l0))), // perpendicular unit vector from p towards the line
        distance(p, l0));            // the distance to any of the two points guarantees intersection with the line

    return intersect(l0, l1, p, subv(p, d), segment);
}



function signedPosOnLine(p0, p1, p)
{
    var cp = closestPointOnLine(p0, p1, p, false);

    var xform = mulm3m3(
        xmove(-p0),
        xrotate(-anglev(p0, p1)));

    p0 = transform(p0, xform);
    p1 = transform(p1, xform);
    cp = transform(cp, xform);

    return (cp.X - p0.X) / nozero(p1.X - p0.X);
}


function mulv2m3(v, m)
{
    var r = [0, 0, 0];

    for (var i = 0; i < 3; i++)
    {
        // calculate the dot product of the ith row of m and v
        for (var j = 0; j < 3; j++)
            r[i] += m[i][j] * v[j];
    }

    return {x: r[0], y: r[1]};
}


function mulm3m3(m1, m2)
{
    var m = [[0, 0, 0],
             [0, 0, 0],
             [0, 0, 0]];

    for (var i = 0; i < 3; i++)
    {
        for (var j = 0; j < 3; j++)
        {
            /*	calculate the dot product of ith row 
                of this and jth column of m  */
            for (var k = 0; k < 3; k++)
                m[i][j] += m1[i][k] * m2[k][j];
        }
    }

    return m;
}


function transform(p, xform)
{
    return mulv2m3(p, xform);
}


function xmove(v)
{
    return [[1, 0, v.x],
            [0, 1, v.y],
            [0, 0, 1  ]];
}


function xrotate(angle)
{
    return [[Math.cos(angle), -Math.sin(angle), 0],
            [Math.sin(angle),  Math.cos(angle), 0],
            [0,                0,               1]];
}


class Point
{
    x;
    y;

    constructor(x, y)
    {
        this.x = x;
        this.y = y;
    }
}


class Rect
{
    x;
    y;
    w;
    h;

    
    get l() { return this.x;            }
    get c() { return this.x + this.w/2; }
    get r() { return this.x + this.w;   }

    get t() { return this.y;            }
    get m() { return this.y + this.h/2  }
    get b() { return this.y + this.h;   }

    get tl() { return {x: this.l, y: this.t}; }
    get tc() { return {x: this.c, y: this.t}; }
    get tr() { return {x: this.r, y: this.t}; }
    get ml() { return {x: this.l, y: this.m}; }
    get mc() { return {x: this.c, y: this.m}; }
    get cm() { return {x: this.c, y: this.m}; }
    get mr() { return {x: this.r, y: this.m}; }
    get bl() { return {x: this.l, y: this.b}; }
    get bc() { return {x: this.c, y: this.b}; }
    get br() { return {x: this.r, y: this.b}; }


    get width()  { return this.w; }
    get height() { return this.h; }

    get left()   { return this.l; }
    get center() { return this.c; }
    get right()  { return this.r; }
    
    get top()    { return this.t; }
    get middle() { return this.m; }
    get bottom() { return this.b; }

    get topLeft()      { return this.tl; }
    get topCenter()    { return this.tc; }
    get topRight()     { return this.tr; }
    get middleLeft()   { return this.ml; }
    get middleCenter() { return this.mc; }
    get centerMiddle() { return this.cm; }
    get middleRight()  { return this.mr; }
    get bottomLeft()   { return this.bl; }
    get bottomCenter() { return this.bc; }
    get bottomRight()  { return this.br; }


    constructor(x, y, w, h)
    {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
    }

    static fromTypical(typ)
    {
        return new Rect(typ.x, typ.y, typ.width, typ.height); 
    }

    // w & h are kept 0 so that isEmpty() works logically on NaN rects
    static NaN = new Rect(Number.NaN, Number.NaN, 0, 0);

    static Zero = new Rect(0, 0, 0, 0);

    get isNaN()
    {
        return isNaN(this.x)
            || isNaN(this.y)
            || isNaN(this.w)
            || isNaN(this.h);
    }

	get isEmpty()
	{
		return (this.w == 0
			 || this.h == 0);
	}

    assign(rect)
    {
        this.x = rect.x;
        this.y = rect.y;
        this.w = rect.w;
        this.h = rect.h;
    }

    expandFromRect(rect)
    {
        if (rect.isNaN  ) return this;
        if (rect.isEmpty) return this;

        if (this.isNaN  ) this.assign(rect);
        if (this.isEmpty) return rect;
        
        const newRect = new AbsRect(
            Math.min(this.t, rect.t),
            Math.min(this.l, rect.l),
            Math.max(this.b, rect.b),
            Math.max(this.r, rect.r));

        this.assign(newRect);
    }
}


class   AbsRect
extends Rect
{
    constructor(t, l, b, r)
    {
        super(l, t, r-l, b-t);
    }
}


function rectsIntersect(rect1, rect2)
{
    return !(
           rect1.l >= rect2.r
        || rect1.r <= rect2.l
        || rect1.t >= rect2.b
        || rect1.b <= rect2.t); 
}



class Random
{
    seed;


    constructor(seed = 0xb9ef7ca4) { this.seed = seed; }


    next()
    {
        this.seed = (this.seed + 0x7ed55d16) + (this.seed << 12);
        this.seed = (this.seed ^ 0xc761c23c) ^ (this.seed >> 19);
        this.seed = (this.seed + 0x165667b1) + (this.seed <<  5);
        this.seed = (this.seed + 0xd3a2646c) ^ (this.seed <<  9);
        this.seed = (this.seed + 0xfd7046c5) + (this.seed <<  3);
        this.seed = (this.seed ^ 0xb55a4f09) ^ (this.seed >> 16);

        return this.seed / -0x7fffffff;
    }
}


const INTER_STEP   = 0,
      INTER_LINEAR = 1,
      INTER_COSINE = 2,
      INTER_CUBIC  = 3;


class NoiseSeed
{
    initial;
    current;

    
    constructor()
    {
        this.reset();
    }
    
    set(seed)
    {
        this.initial = seed;
        this.current = seed;
    }    
    
    rotate()
    {
        this.current = (this.current + 0x7ed55d16) + (this.current << 12);
        this.current = (this.current ^ 0xc761c23c) ^ (this.current >> 19);
        this.current = (this.current + 0x165667b1) + (this.current <<  5);
        this.current = (this.current + 0xd3a2646c) ^ (this.current <<  9);
        this.current = (this.current + 0xfd7046c5) + (this.current <<  3);
        this.current = (this.current ^ 0xb55a4f09) ^ (this.current >> 16);
    }    
    
    next()
    {
        const seed = this.current;
        this.rotate();
        return seed;
    }

    reset()
    {
        this.current = this.initial;
    }
};


class Noise
{
	interpolation = INTER_CUBIC;
	clip = false;

	seed = new NoiseSeed();

	v0;
	v1;
	v2;
	v3;

	step = 0;


    constructor(seed = 0)
    {
        this.seed.set(seed);
        this.reset();
    }


    next(scale = 1)
    {
        //scale = Math.pow(Phi, scale) / Phi;
        scale = Math.max(1, scale);

        var next = this.v1;

        if (this.step >= 1)
        {
            // get the next random value
        
            this.seed.rotate();

            this.v0 = this.v1;
        //------------------------
            this.v1 = this.v2;
            this.v2 = this.v3;
        //------------------------
            this.v3 = normalizeSeed(this.seed.current);

            this.step -= 1;
        }

        // get the next 'noise' value

        switch (this.interpolation)
        {
            case INTER_STEP:
            {
                next = this.v1;
                break;
            }
            case INTER_LINEAR:
            {
                next = this.v1 + this.step * (this.v2 - this.v1);
                break;
            }
            case INTER_COSINE:
            {
                const ft = this.step * Math.PI;
                const f  = (1 - Math.cos(ft)) * 0.5;
                
                next = this.v1 + f * (this.v2 - this.v1);
                break;
            }
            case INTER_CUBIC:
            {
                const p = (this.v3 - this.v2) - (this.v0 - this.v1);
                const q = (this.v0 - this.v1) - p;
                const r =  this.v2 - this.v0;
                const s =  this.v1;

                const val = 
                      p * cube(this.step) 
                    + q * sqr(this.step) 
                    + r * this.step 
                    + s;

                next = this.clip 
                    ? Math.max(0, Math.min(val, 1)) 
                    : val;

                break;
            }
        }

        this.step += 1 / scale;

        return next;
    }

   
    reset()
    {
        this.seed.reset();

        this.v0 = normalizeSeed(this.seed.current); this.seed.rotate();
        this.v1 = normalizeSeed(this.seed.current); this.seed.rotate();
        this.v2 = normalizeSeed(this.seed.current); this.seed.rotate();
        this.v3 = normalizeSeed(this.seed.current); this.seed.rotate();

        this.step = 0;
    }
}


function normalizeSeed(x)
{
    return x / -0x7fffffff;
}


class GParameter
{
    #name;
    get name() { return this.#name; }

    #type; 
    get type() { return this.#type; }
    
    _op; 
    get op() { return this._op; }

    constructor(name, type)
    {
        this.#name = name;
        this.#type = type;
    }
}


class   GNumberParam
extends GParameter
{
    #value;

    #min;
    #max;
    

    get value() 
    {
        var value = Math.min(Math.max(this.#min, this.#value), this.#max);

        if (this.input.connected)
        {
            value = Math.min(Math.max(this.#min, this.input.data.value), this.#max);

            postMessage({ 
                msg:   'showParamValue',
                nodeId: this.op.id,
                param:  this.name,
                value:  value
            });
        }

        return value;
    }
    
    set value(value) 
    {
        this.#value   = value;
        this.op.valid = false;
    }


    input; 


    constructor(name, 
                value = 0, 
                min   = Number.MIN_SAFE_INTEGER, 
                max   = Number.MAX_SAFE_INTEGER)
    {
        super(name, 'NUM');

        this.#value    = value;
   
        this.#min      = min;
        this.#max      = max;

        this.input = new GInput('NUM');
        this.input._param = this;
    }
}


class GGraph
{
    nodes = [];

    mutex = false;

    deferNodes = [];

    
    createNode(opType)
    {
        var node;

        switch (opType)
        {
            case 'number': node = new GOpNumber(); break;
            case 'random': node = new GOpRandom(); break;
            case 'rect':   node = new GOpRect();   break;
            case 'row':    node = new GOpRow();    break;
            case 'column': node = new GOpColumn(); break;
            case 'spread': node = new GOpSpread(); break;
        }
        
        this.addNode(node);

        return node;
    }


    addNode(node)
    {
        node.graph = this;
        this.nodes.push(node);
    }
    

    removeNodes(nodeIds)
    {
        for (const nodeId of nodeIds)
        {
            const node = this.nodes.find(n => n.id == nodeId);

            for (const input of node.inputs)
                if (input.connected) this.disconnect(input);

            if (!!node.output)
            {
                for (const input of node.output.connectedInputs)
                    this.disconnect(input);
            }

            node.graph = null;
            removeFromArray(node, this.nodes);
        }
    }


    connect(output, input)
    {
        if (input.connectedOutput == output)
            return false;
            
        if (input.connectedOutput != null)
            this.disconnect(input);

        output.connect(input);

        input.connectedOutput = output;

        const conn = new GConnection(output, input);

        input .connection = conn;
        output.connection = conn;
        
        input.valid = false;

        return true;
    }


    disconnect(input)
    {
        var output = input.connectedOutput;
        if (!output) return false;

        if (!!input.param)
            input.param.value = input.data.value;

        output.disconnect(input);
        
        input .connection     = null;
        output.connection     = null;

        input.connectedOutput = null;

        output.op.valid = false;
        input .op.valid = false;
            
        return true;
    }


    nodeFromId(id)
    {
        return this.nodes.find(n => n.id === id);
    }
}


class GInput
{
    #dataType;     
    get dataType() { return this.#dataType; }

    _op    = null; get op   () { return this._op;    }
    _param = null; get param() { return this._param; }

    connectedOutput = null;
    connection      = null;
    
    connecting      = false;
    

    get connected() { return this.connectedOutput != null; }


    constructor(dataType)
    {
        this.#dataType = dataType;
    }    
    

    get data()
    {
        return (
            this.connected
            ? this.connectedOutput.getData(this)
            : null);
    }
}


class   GOutput
extends EventTarget
{
    #dataType;     
    get dataType() { return this.#dataType; }
    
    _op    = null; get op   () { return this._op;    }
    _param = null; get param() { return this._param; }
    
    _data = {};
    
    connectedInputs = [];
    
    connecting      = false;
    
    get connected() { return this.connectedInputs.length > 0; }

    
    onconnect    = new Event('connect');
    ondisconnect = new Event('disconnect');


    constructor(dataType)
    {
        super();
        
        this.#dataType = dataType;
    }
    

    getData(callerInput = null) 
    {
        if (!this.op.valid)
            this.op.generate(callerInput);

        return this._data;
    }


    connect(input)
    {
        this.connectedInputs.push(input);

        this.dispatchEvent(new CustomEvent(
            'connect', 
            { 
                'output': this, 
                'input':  input 
            }));
    }


    disconnect(input)
    {
        removeFromArray(input, this.connectedInputs);

        this.dispatchEvent(new CustomEvent(
            'disconnect', 
            { 'input': input }));
    }
}


class GConnection
{
    output;
    input;


    constructor(output, input)
    {
        this.output = output;
        this.input  = input;
    }
}


/*
    data types:
        OBJ
        NUM
*/

class GOperator
{
    #opType;
    get opType() { return this.#opType; }
    
    #dataType;
    get dataType() { return this.#dataType; }

    _id;
    get id() { return this._id; }
    set id(id) { this._id = id; }
    
    graph = null;
    
    
    params = [];
    
    inputs = [];
    output = null;
    
    cachedObjects = [];

    _valid = false; // this is the flag for regeneration


    set valid(valid) { this._valid = valid; }
    
    get valid() 
    {
        var valid = this._valid;
        if (!valid) return valid;
        
        for (const input of this.inputs)
        {
            if (input.connected)
                valid &= input.connectedOutput.op.valid;
        }

        return valid;
    }

    
    active = false;


    div;
    inner;
    header;
    label;
    inputControls;
    outputControls;


    constructor(opType, dataType)
    {
        this.#opType   = opType;   // this is the operator type
        this.#dataType = dataType; // this is the op's main data type

        this._id = opType; // this is a temp until the op becomes a graph node
    }    
    
    
    addInput(input)
    {
        input._op = this;
        this.inputs.push(input);
    }


    setOutput(output)
    {
        if (this.output != null)
            this.output._op = null;

        output._op = this;
        this.output = output;
    }


    addParam(param)
    {
        this.params.push(param);

        param._op = this;

        param.input._op = this;
        this.inputs.push(param.input);
    }
 
    

    setId(newId)
    {
        if (this.graph.nodes.find(node => node.id == newId))
            return false; // graph already contains a node with this id

        this._id = newId;

        return true;
    }


    generate(callerInput) 
    { 
        this.valid = true; 
    }


    reset() // for the entire generation run
    {
        for (const input of this.inputs)
        {
            input.currentSeed = input.initialSeed;
            
            if (input.connected)
                input.connectedOutput.op.reset();
        }
    }


    refresh() // for repeats requests from nodes that duplicate their input, like row and column
    {
        for (const input of this.inputs)
        {
            if (input.connected)
                input.connectedOutput.op.refresh();
        }
    }

    
    isBefore(node)
    {
        if (   !this.output
            || !this.output.connected)
            return false;

        for (const input of output.connectedInputs)
        {
            if (input.op == node)        return true;
            if (input.op.isBefore(node)) return true;
        }

        return false;
    }


    isAfter(node)
    {
        if (this.inputs.length == 0)
            return false;

        for (const input of inputs)
        {
            if (input.connectedOutput.op == node)       return true;
            if (input.connectedOutput.op.isAfter(node)) return true;
        }

        return false;
    }
}


class   GOpRect
extends GOperator
{
    #width;
    #height;
    #round;
    

    constructor()
    {
        super('rect', 'OBJ');

        this.setOutput(new GOutput(this.dataType));

        this.addParam(this.#width  = new GNumberParam('width',  100, 0.01));
        this.addParam(this.#height = new GNumberParam('height', 100, 0.01));
        this.addParam(this.#round  = new GNumberParam('round',    0, 0));
    }


    generate(callerInput)
    {
        if (this.valid) return;
        super.generate(callerInput);


        this.output._data = 
        [{
            nodeId:  this.id,
            itemId:  this.id,
            
            objType: 'rect',
            
            x:       0,
            y:       0,
            width:   this.#width .value,
            height:  this.#height.value,
            round:   this.#round .value
        }];
    }
}


class   GOpRow
extends GOperator
{
    #count;
    #gap;


    constructor()
    {
        super('row', 'OBJ');

        this.addInput (new GInput (this.dataType));
        this.setOutput(new GOutput(this.dataType));
        
        this.addParam(this.#count = new GNumberParam('count',  7, 1));
        this.addParam(this.#gap   = new GNumberParam('gap',   10, 0));
    }


    generate(callerInput)
    {
        if (this.valid) return;
        super.generate(callerInput);


        const input = this.inputs[0];

        if (!input.connected)
        {
            this.output._data = [];
            return;
        }


        this.output._data = [];
        
        for (var i = 0, x = 0; i < this.#count.value; i++)
        {
            const inputData = input.data;

            const bounds = getBounds(inputData);
            const gap    = this.#gap.value;

            for (var j = 0; j < inputData.length; j++)
            {
                var item = shallowCopy(inputData[j]);
                item.itemId = this.id + '_' + (i+1) + '_' + item.itemId;
    
                item.x += x;
                
                this.output._data.push(item);
            }

            x += bounds.w + gap;

            // as this node duplicates its input, everything like
            // OpNumber upstream that does S&H needs to be refreshed
            this.refresh();
        }
    }
}


class   GOpColumn
extends GOperator
{
    #count;
    #gap;


    constructor()
    {
        super('column', 'OBJ');

        this.addInput (new GInput (this.dataType));
        this.setOutput(new GOutput(this.dataType));
        
        this.addParam(this.#count = new GNumberParam('count', 7, 1));
        this.addParam(this.#gap   = new GNumberParam('gap', 10, 0));
    }


    generate(callerInput)
    {
        if (this.valid) return;
        super.generate(callerInput);


        const input = this.inputs[0];

        if (!input.connected)
        {
            this.output._data = [];
            return;
        }


        this.output._data = [];
        
        for (var i = 0, y = 0; i < this.#count.value; i++)
        {
            const inputData = input.data;

            const bounds = getBounds(inputData);
            const gap    = this.#gap.value;

            for (var j = 0; j < inputData.length; j++)
            {
                var item = shallowCopy(inputData[j]);
                item.itemId = this.id + '_' + (i+1) + '_' + item.itemId;
    
                item.y += y;
                
                this.output._data.push(item);
            }
            
            y += bounds.h + gap;

            this.refresh();
        }
    }
}


class   GOpSpread 
extends GOperator
{
    #count;
    #radius;

    seed = 0;


    constructor()
    {
        super('spread', 'OBJ');

        this.addInput (new GInput (this.dataType));
        this.setOutput(new GOutput(this.dataType));
        
        this.addParam(this.#count  = new GNumberParam('count', 2, 1));
        this.addParam(this.#radius = new GNumberParam('radius', 100, 0.01));
    }


    generate(callerInput)
    {
        if (this.valid) return;
        super.generate(callerInput);


        var input = this.inputs[0];

        if (   !input.connected
            || isEmptyObject(input.connectedOutput.data)) 
        {
            this.output._data = {};
            return;
        }

        this.output._data = 
        {
            nodeId: this.id,
            opType: this.opType,

            count:  this.#count .value,
            radius: this.#radius.value,
            
            seed:   this.seed,

            inputs: [input.data]
        };
    }
}


class   GOpNumber
extends GOperator
{
    _value;

    _sampled = Number.NaN;


    constructor()
    {
        super('number', 'NUM');
        this.setOutput(new GOutput(this.dataType));
        this.addParam(this._value = new GNumberParam(''));
    }


    generate(callerInput)
    {
        if (this.valid) return;
        super.generate(callerInput);


        if (isNaN(this._sampled))
            this._sampled = this._value.value;

        this.output._data = 
        {
            nodeId: this.id,
            opType: this.opType,

            value:  this._sampled
        };
    }


    refresh()
    {
        super.refresh();
        
        this._sampled = Number.NaN;
    }
}


class   GOpRandom
extends GOperator
{
    #min;
    #max;
    #scale;
    #seed;

    noise = new Noise();

    constructor()
    {
        super('random', 'NUM');

        this.setOutput(new GOutput(this.dataType));

        this.addParam(this.#min   = new GNumberParam('min',   0));
        this.addParam(this.#max   = new GNumberParam('max', 100));
        this.addParam(this.#scale = new GNumberParam('scale', 1, 1));
        this.addParam(this.#seed  = new GNumberParam('seed', 1, 1));

        this.output.addEventListener('connect',    () => postMessage({msg: 'resetNode', nodeId: this.id}));
        this.output.addEventListener('disconnect', () => postMessage({msg: 'resetNode', nodeId: this.id}));
    }


    generate(callerInput)
    {
        if (this.valid) return;
        super.generate(callerInput);

        if (!!callerInput) this.noise.seed.current = callerInput.currentSeed;
        var rnd = this.noise.next(this.#scale.value);
        if (!!callerInput) callerInput.currentSeed = this.noise.seed.current;
        
        var value = this.#min.value + rnd * (this.#max.value - this.#min.value);

        this.output._data = 
        {
            nodeId: this.id,
            opType: this.opType,

            value:  value
        };    

        this.valid = false;
    }


    reset()
    {
        super.reset();

        this.noise.seed.set(this.#seed.value);
        
        for (const input of this.output.connectedInputs)
        {
            input.initialSeed = input.currentSeed = this.noise.seed.current;
            this.noise.next();
        }
    }
}


const ggraph = new GGraph();


onmessage = function(e)
{
    switch (e.data.msg)
    {
        case 'createNode': 
        {
            const node = ggraph.createNode(e.data.opType);
            
            node.id = e.data.nodeId;

            postMessage({ 
                msg:   'makeActive',
                nodeId: node.id
            });
            
            break;
        }
        case 'removeNodes':
        {
            ggraph.removeNodes(e.data.nodeIds);
            break;            
        }
        case 'setNodeId': 
        {
            const node = ggraph.nodeFromId(e.data.nodeId);
            node.id = e.data.newId;
            break;
        }
        case 'setActive': // this is only a state message, no regeneration
        {
            const node = ggraph.nodeFromId(e.data.nodeId);
            node.active = e.data.active;
            break;
        }
        case 'connect':
        {
            const outNode = ggraph.nodeFromId(e.data.output);

            for (const input of e.data.inputs)
            {
                const inNode = ggraph.nodeFromId(input.nodeId);

                ggraph.connect(
                    outNode.output, 
                    input.index >= 0
                    ? inNode.inputs[input.index]
                    : inNode.params.find(p => p.name == input.param).input);

                requestGenerate([input.nodeId]);
            }

            break;
        }
        case 'disconnect':
            const node  = ggraph.nodeFromId(e.data.input.nodeId);
            const input = node.inputs[e.data.input.index];

            ggraph.disconnect(input);

            break;
        
        case 'setParam':
        {
            const node  = ggraph.nodeFromId(e.data.nodeId);
            const param = node.params.find(p => p.name == e.data.param);
            param.value = e.data.value;
            requestGenerate([node.id]);
            break;
        }
        case 'invalidate':
        {
            const node = ggraph.nodes.find(n => n.id == e.data.nodeId);
            node.valid = false;
            break;
        }
        case 'generate':
        {
            for (const node of ggraph.nodes)
                node.reset();
                
            var objects = [];
            
            for (const nodeId of e.data.nodeIds)
            {
                const node = ggraph.nodeFromId(nodeId);
                objects = objects.concat(node.output.getData());
            }

            postMessage({ 
                msg:    'recreateObjects',
                nodeIds: e.data.nodeIds,
                objects: objects
            });

            break;
        }
    }
};


function requestGenerate(nodeIds)
{
    postMessage({
        msg:    'requestGenerate',
        nodeIds: nodeIds
    });
}


// function generateSpread(node)
// {
//     var input  = generate(node.inputs[0]);
//     var bounds = getBounds(input);

//     var rnd = new Random(node.seed);

//     result = [];

//     var a = 0;

//     for (var i = 0; i < node.count; i++)
//     {
//         var d = rnd.next() * node.radius;
//         var v = vector(a, d);
        
//         for (var j = 0; j < input.length; j++)
//         {
//             var item = shallowCopy(input[j]);
//             item.itemId = node.nodeId + '_' + i + '_' + j;

//             item.x += v.x;
//             item.y += v.y;
            
//             result.push(item);
//         }

//         a += Tau * phi;
//     }

//     return result;
// }


function getBounds(objects)
{
    var boundsL = Number.MAX_SAFE_INTEGER;
    var boundsT = Number.MAX_SAFE_INTEGER;
    var boundsR = Number.MIN_SAFE_INTEGER;
    var boundsB = Number.MIN_SAFE_INTEGER;
    
    for (const obj of objects)
    {
        boundsL = Math.min(boundsL, obj.x);
        boundsT = Math.min(boundsT, obj.y);
        boundsR = Math.max(boundsR, obj.x + obj.width);
        boundsB = Math.max(boundsB, obj.y + obj.height);
    }

    return {
        x: boundsL, 
        y: boundsT,
        w: boundsR - boundsL,
        h: boundsB - boundsT };
}


</script>