<script id="generatorScript" type="javascript/worker"> 'use strict';  


const generatorVersion     = 442;   const j866            = 2147483647;    const NULL                 = ''; const NULL_VALUE           = 'NULL';    const v867                 = '  ';  const n868                 = '    ';  const q870                   = '\n';    const j871          = '◦ G •'; const PLUGIN_NAME          = 'Generator'; const PLUGIN_LOGO_AND_NAME = j871 + ' ' + PLUGIN_NAME;  const t872        = j871 + ' ';  const p873              = 'G_NODE'; const s874              = 'G_CONN'; const g875              = 'G_PAGE'; const m876              = 'G_TEMP';  const minWindowWidth       = 602; const minWindowHeight      =  40;   const identity = Object.freeze(     [[1, 0, 0],      [0, 1, 0],      [0, 0, 1]]);    const Epsilon = 0.0000001; const Tau     = Math.PI * 2;    var enableAsserts = false;    function d877(x, eps = 0.000000001)  {      return Math.abs(x) < eps ? 0 : x; }    function hardPosZero(x, eps = 0.000000001)  {      return    x <  0             && x > -eps             ? 0             : x; }    function nozero(x, eps = 0.000000001)  {      return x != 0           ? x           : (x < 0 ? -eps : eps); }    function p878(v, eps = 0.000000001)  {      return point(         nozero(v.x, eps),          nozero(v.y, eps));  }    function equal(a, b, eps = 0.000000001) {     return Math.abs(b - a) < eps; }    function sqr (x) { return x*x;   }; function cube(x) { return x*x*x; };    function m879(f) { return Math.floor(f) | 0; }    function p880(x) {     x = m879(x);      x--;      x |= x >>  1;     x |= x >>  2;     x |= x >>  4;     x |= x >>  8;     x |= x >> 16;     x |= x >> 32;      return ++x; }    function gcd(a, b) {     let temp;     while (1)     {         temp = a % b;          if (temp == 0)           return b;          a = b;         b = temp;     } }    function distv(p1, p2) {     const dx = p2.x - p1.x;     const dy = p2.y - p1.y;      return Math.sqrt(dx*dx + dy*dy); }    function n881(v) {     let angle = Math.atan2(v.y, v.x);     if (angle < 0) angle += Tau;      return angle; }    function anglev2(v1, v2) {     return anglev2_(v1.x, v1.y, v2.x, v2.y); }    function anglev2_(x1, y1, x2, y2) {     const dx = x2 - x1;     const dy = y2 - y1;      let angle = Math.atan2(dy, dx);     if (angle < 0) angle += Tau;      return angle; }    function a883(v) {     return Math.sqrt(v.x*v.x + v.y*v.y); }    function lengthv_(x, y) {     return Math.sqrt(x*x + y*y); }    function i884(v) {     return point(         v.x == 0 ? 0 : v.x / a883(v),         v.y == 0 ? 0 : v.y / a883(v)); }    function dotv(v1, v2) {     return v1.x * v2.x + v1.y * v2.y; }    function m885(a1, a2) {     let diff = a2 - a1;      while (diff <= -Tau/2) diff += Tau;     while (diff >   Tau/2) diff -= Tau;      return diff;  }    function s886(v, m) {     let v3 = [v.x, v.y, 1];     let r  = m946(v3, m);      return point(r[0], r[1]); }    function g887(...mm) {     r950(mm.length > 0, 'mulm3m3() must take at least one argument');      let result = clone(mm[0]);      for (let a = 1; a < mm.length; a++)     {         const m1 = result;         const m2 = mm[a];          const m = [[0, 0, 0],                    [0, 0, 0],                    [0, 0, 0]];          for (let i = 0; i < 3; i++)         {             for (let j = 0; j < 3; j++)             {                                  for (let k = 0; k < 3; k++)                     m[i][j] += m1[i][k] * m2[k][j];             }         }          result = m;     }      return result; }    function o888(m, s) {     for (let i = 0; i < 3; i++)         for (let j = 0; j < 3; j++)             m[i][j] /= s;      return m; }    function adjugate(m) {     return cofactor(transpose(m)); }    function transpose(m) {     return [[m[0][0], m[1][0], m[2][0]],             [m[0][1], m[1][1], m[2][1]],             [m[0][2], m[1][2], m[2][2]]]; }    function cofactor(m) {     return [[  m[1][1] * m[2][2] - m[2][1] * m[1][2], -(m[1][0] * m[2][2] - m[2][0] * m[1][2]),  m[1][0] * m[2][1] - m[2][0] * m[1][1] ],             [-(m[0][1] * m[2][2] - m[2][1] * m[0][2]),  m[0][0] * m[2][2] - m[2][0] * m[0][2], -(m[0][0] * m[2][1] - m[2][0] * m[0][1])],             [  m[0][1] * m[1][2] - m[1][1] * m[0][2], -(m[0][0] * m[1][2] - m[1][0] * m[0][2]),  m[0][0] * m[1][1] - m[1][0] * m[0][1] ]];  }    function determinant(m) {     return   m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1])            - m[0][1] * (m[1][0] * m[2][2] - m[2][0] * m[1][2])            + m[0][2] * (m[1][0] * m[2][1] - m[2][0] * m[1][1]); }    function g889(m) {     return o888(adjugate(m), determinant(m)); }    function l890(angle) {     const cosA = d877(Math.cos(angle));     const sinA = d877(Math.sin(angle));      return [[ cosA, sinA, 0],             [-sinA, cosA, 0],             [ 0,    0,    1]]; }    function v891(x = 0, y = 0, scaleX = 1, scaleY = 1, angle = 0, skewX = 0, skewY = 0) {     const cosA = Math.cos(angle);     const sinA = Math.sin(angle);      return [[scaleX*cosA -  skewY*sinA, -skewX*cosA + scaleY*sinA, x],             [ skewY*cosA + scaleX*sinA, scaleY*cosA +  skewX*sinA, y],             [0,                         0,                         1]]; }    function x892(v1, v2) {                               return v1.x * v2.y - v1.y * v2.x; }	    function y893(v1, v2) {     return point(         v1.x + v2.x,         v1.y + v2.y); }	    function sqrv(v) {     return p894(v, v); }    function p894(v1, v2) {     return point(         v1.x * v2.x,         v1.y * v2.y); }	    function y895(v, s) {     return point(         v.x * s,         v.y * s); }	    function s896(v1, v2) {     return point(         v1.x / v2.x,         v1.y / v2.y); }	    function c897(v, s) {     return point(         v.x / s,         v.y / s); }	    function j898(v1, v2) {     return point(         v1.x - v2.x,         v1.y - v2.y); }	    function w899(str)  {     return decodeURI(encodeURIComponent(str)); }    function p900(str)  {     return decodeURIComponent(encodeURI(str)); }    function a901(bytes)  {     let str = '';      for (let i = 0; i < bytes.length; i++)         str += String.fromCharCode(bytes[i]);      return str; }    function x902(str) {     return Array.from(p900(str), c => c.charCodeAt(0)); }    function s903(array, size)  {     const newArray = new Uint8Array(size);     t904(array, newArray);     return newArray; }    function t904(src, dst) {     d905(         src, 0, src.length,         dst, 0, dst.length); }    function d905(src, h906, t907, dst, y908, y909) {     const size = Math.min(t907, y909);      for (let i = 0; i < size; i++)         dst[y908 + i] = src[h906 + i]; }    function l910(p911, i912) {     if (p911.length != i912.length)         return false;      for (let i = 0; i < p911.length; i++)     {         if (p911[i] != i912[i])             return false;     }      return true; }    function c913(z914, s915) {     return z914.findIndex(i => s915.includes(i)) > -1; }    function  g916(list) { return list ? '<==' : '<--'; };  function a917(list) { return list ? '==>' : '-->'; };   function r918(nodeId) { return p873 + ' ' + nodeId; } function j919(name)   { return s874 + ' ' + name;   } function b920(name)   { return g875 + ' ' + name;   }    function d921(str)  {      if (str.trim().toLowerCase() == 'true' ) return true;     if (str.trim().toLowerCase() == 'false') return false;       const num = parseFloat(str);      if (!isNaN(num))         return num > 0;       console.error('invalid bool string "' + str + '"');     return false; }    function stringIsNumber(str) {     const num = Number(str);          if (   (    isNaN(num)              ||  parseFloat(str).toString() !== str.trim())         && !Object.is(num, -0))         return false;          return true; }   function h922(h923, r924 = false) {     return t929(         h923.outputNodeId,         h923.outputId,         h923.outputOrder,         h923.inputNodeId,         h923.inputId,         h923.list,         r924); }    function v925(outputNodeId, outputId, outputOrder, inputNodeId, inputId) {     return j919(           outputNodeId + ' '         + outputId     + ' '         + outputOrder  + ' '         + inputNodeId  + ' '         + inputId); }    function l926(o243) {     return v925(         o243.outputNodeId,         o243.outputId,         o243.outputOrder,         o243.inputNodeId,         o243.inputId); }    function v927(o243) {     return v925(         o243.output.node.id,         o243.output.id,         o243.outputOrder,         o243.input.node.id,         o243.input.id); }    function z928(o243, r924 = false) {     return t929(         o243.output.node.id,         o243.output.id,         o243.outputOrder,         o243.input.node.id,         o243.input.id,         o243.list,         r924); }    function t929(outputNodeId, outputId, outputOrder, inputNodeId, inputId, list, r924 = false) {     const  sp   = r924 ? ' ' : '  ';      const jsp   = r924 ? ''  : ' ';       const arrow =            sp          + t933(typeof outputOrder == 'string' ? parseInt(outputOrder) : outputOrder)          + a917(typeof list == 'string' ? d921(list) : list)          + sp;      const join  = jsp + '.' + jsp;      return  outputNodeId + join + outputId          + arrow          + inputNodeId  + join + inputId;           }    function o930(pageId) {     return b920(pageId); }    function j931(num) {     const str = num.toString();      let sup = '';      for (const c of str)         sup += t932(c);      return sup; }    function t932(c) {     switch (c)     {         case '0': return '⁰';         case '1': return '¹';         case '2': return '²';         case '3': return '³';         case '4': return '⁴';         case '5': return '⁵';         case '6': return '⁶';         case '7': return '⁷';         case '8': return '⁸';         case '9': return '⁹';         case '.': return '·';     } }    function t933(num) {     const str = num.toString();      let sup = '';      for (const c of str)         sup += x934(c);      return sup; }    function x934(c) {     switch (c)     {         case '0': return '₀';         case '1': return '₁';         case '2': return '₂';         case '3': return '₃';         case '4': return '₄';         case '5': return '₅';         case '6': return '₆';         case '7': return '₇';         case '8': return '₈';         case '9': return '₉';         case '.': return ' ';     } }    function o935(bool) {     return bool ? 'true' : 'false'; }    function isValid(val) {     return val != undefined         && val != null; }    function isEmpty(array) {     return array.length == 0; }    function p936(array, item) {     r937(array, array.indexOf(item)); }    function r937(array, index) {     if (   index > -1          && index < array.length)         array.splice(index, 1); }    function h938(array) {     if (isEmpty(array))         return null;      let last = array.at(-1);     array.splice(array.length-1, 1);      return last; }    function e939(array) {     return array[array.length-1]; }    function f940(array, from, to)  {     const item = array[from];     array.splice(from, 1);     array.splice(to, 0, item); }    function y941(array, item) {     const index = array.indexOf(item);          if (index > -1)         array.splice(index, 1); }    function h942(i2706, array) {     for (const item of array)     {         const index = i2706.indexOf(item);                  if (index > -1)             i2706.splice(index, 1);     } }    function p943(array, where) {     const index = array.findIndex(where);          if (index > -1)         array.splice(index, 1); }    function v944(styleId) {     return styleId.split(',')[0] + ','; }    function w945(points) {     let b3913 = '';       if (points.length < 2)         return b3913;       b3913 += 'M';     b3913 += ' ' + d877(points[0].x);     b3913 += ' ' + d877(points[0].y);      for (let i = 1; i < points.length; i++)     {         b3913 +=                ' L'             + ' ' + d877(points[i].x)             + ' ' + d877(points[i].y);     }       return b3913; }    function point(x, y) { return {x: x, y: y}; }    function m946(v, m) {     let r = [0, 0, 0];      for (let i = 0; i < 3; i++)         for (let j = 0; j < 3; j++)             r[i] += v[j] * m[i][j];      return r; }    function clone(val)  {     const type = typeof val;          if (val === null)        return null;      else if (type === 'undefined'            || type === 'number'            || type === 'string'            || type === 'boolean')          return val;      else if (type === 'object')      {         if (val instanceof Array)              return val.map(x => clone(x));          else if (val instanceof Uint8Array)              return new Uint8Array(val);          else          {             let c111 = {};              for (const key in val)                  c111[key] = clone(val[key]);              return c111;         }     }      throw 'unknown'; }    function v947(array, item, equal = null) {     if (equal)     {         if (Array.isArray(item))             item.forEach(i => v947(array, i, equal));         else if (!array.find(i => equal(i, item)))             array.push(item);     }     else     {         if (Array.isArray(item))             item.forEach(i => v947(array, i));         else if (!array.includes(item))             array.push(item);     } }    function z948(array, item, equal) {     if (Array.isArray(item))         item.forEach(i => z948(array, i, equal));     else if (!array.find(equal))         array.push(item); }    function w949(array, item, except) {     if (Array.isArray(item))         item.forEach(i => w949(array, i, except));     else if (!array.find(except))         array.push(item); }    function r950(...args) {               if (enableAsserts)     {         console.assert(...args);              } }    function s951(...args) {               if (enableAsserts)         console.error(...args); }    function k952(str, trim)  {     while (str.length >= trim.length         && str.substring(0, trim.length) == trim)          str = str.substring(trim.length);      return str; }    function z953(str, trim)  {     while (str.length >= trim.length         && str.substring(str.length - trim.length) == trim)          str = str.substring(0, str.length - trim.length);      return str; }    function u954(p3971) {     const fills = [];       for (const fill of p3971)     {         switch (fill[0])         {             case 'SOLID':             {                 const color = {                     r: Math.min(Math.max(0, fill[1] / 0xff), 1),                      g: Math.min(Math.max(0, fill[2] / 0xff), 1),                      b: Math.min(Math.max(0, fill[3] / 0xff), 1) };                  const opacity = Math.min(Math.max(0, fill[4] / 100), 1);                   if (   !isNaN(color.r)                     && !isNaN(color.g)                     && !isNaN(color.b)                     && !isNaN(opacity))                     fills.push(                     {                         type:      fill[0],                          color:     color,                         opacity:   opacity,                         blendMode: fill[5]                     });                   break;             }              case 'GRADIENT_LINEAR':             case 'GRADIENT_RADIAL':             case 'GRADIENT_ANGULAR':             case 'GRADIENT_DIAMOND':             {                 const [p0, p1, p2] = fill[1];                  const h4086 =                      [[0,   1,   0],                      [0.5, 0.5, 1],                      [1,   1,   1]];                  let u4087 = [                     [p0.x, p1.x, p2.x],                     [p0.y, p1.y, p2.y],                     [1,    1,    1   ]];                  u4087 = g887(h4086, g889(u4087));                 u4087 = [u4087[0], u4087[1]];                   const stops = [];                  for (const stop of fill[2])                 {                     stops.push({                         color:                          {                             r: Math.min(Math.max(0, stop[0]), 1),                             g: Math.min(Math.max(0, stop[1]), 1),                             b: Math.min(Math.max(0, stop[2]), 1),                             a: Math.min(Math.max(0, stop[3]), 1)                         },                         position: stop[4]                     });                   }                   fills.push(                 {                     type:              fill[0],                     gradientTransform: u4087,                     gradientStops:     stops,                     blendMode:         fill[3]                 });                   break;             }         }     }       return fills; }    function l955(type) {     return d1088.includes(type); }    function isValueListOfLists(value) {     if (!l955(value.type))         return false;      for (const item of value.items)     {         if (!l955(item.type))             return false;     }      return true; }    function isValueListOfCondensedLists(value) {     if (   !value         || !l955(value.type))         return false;          for (const item of value.items)     {         if (   !item             || !l955(item.type)             ||  item.condensed !== true)             return false;     }      return true; }


function t956(type, active) {     return q957(type, active, c3889); }    function q957(type, active, c3889) {     if (a1146.includes(type))         return active              ? (c3889 ? m2228 : e2218)             : (c3889 ? o2229       : a2219      );      else if (b1147.includes(type))         return active              ? (c3889 ? h2234   : o2224)             : (c3889 ? t2235         : v2225      );      else if (o1276.includes(type)          || e1194.includes(type))         return active              ? (c3889 ? f2232  : b2222)             : (c3889 ? h2233        : x2223      );      else if (y1280.includes(type))         return active              ? (c3889 ? e2230  : v2220)             : (c3889 ? y2231        : y2221      );      else if (v1089.includes(type)           || type == r1086)         return active              ? (c3889 ? y2226   : n2216)             : (c3889 ? s2227         : a2217      );      else if (type == x1196)         return active              ? (c3889 ? y2226   : n2216)             : (c3889 ? s2227         : a2217      );       switch (type)     {         case s1148:               case m1158:         case x1161:         case o1164:         case d1167:          case j1149:                    case g1155:         case u1151:         case c1152:         case t1154:         case c1156:          case c1165:         case o1168:              return c3889                   ? s2227                           : a2217;                                             }                return c3889           ? s2227                   : a2217; }    function b958(color) {     return isNaN(color[1])         || isNaN(color[2])         || isNaN(color[3]); }


function e996(x, replace) {     return !isNaN(x) ? x : replace; }    function d997(c) {     return c >= 'a' && c <= 'z'         || c >= 'A' && c <= 'Z'; }   function f998(i) {     if (i == 0) return 1;      let l = Math.floor(Math.log10(Math.abs(i)));       return l + 1; }    function t999(dec) {     return Math.pow(10, -dec); }    function a1000(c) {     return c >= '0'          && c <= '9'; }    function x1001(c) {     return c.length == 1         && (   c >= 'A' && c <= 'F'             || c >= 'a' && c <= 'f'); }    function r1002(num)  {     if (typeof num !== 'number')         s951('Input must be a number');      return strDecDigits(num.toFixed(10)); }    function strDecDigits(strNum) {     const iDec = strNum.indexOf('.');          if (iDec === -1)         return 0;          let count = strNum.length - iDec - 1;          for (let i = strNum.length-1; i > iDec; i--)     {         if (strNum[i] === '0')             count--;         else             break;     }          return count; }    function o1003(code) {     return code == 'ArrowLeft'         || code == 'ArrowRight'         || code == 'ArrowUp'         || code == 'ArrowDown'; }    function s1004(num, dec = 0, d3883 = false, c1005 = '.', y1006 = '') {     return d3883          ? w1008(num, dec, c1005, y1006)          : x1007(num, dec, c1005, y1006); }    function x1007(num, dec, c1005 = '.', y1006 = '') {     const n3973 = Math.abs(dec);     let    str = Number(num).toFixed(n3973).toString(10);                     let i = str.length-1;          while (i >= 0         && str[i] !== '.'          && str[i] !== ',')         i--;      if (i < 0)          return s1009(str, y1006, 3);           let whole = str.slice(0, i);     let frac  = str.slice(i+1);             i = frac.length-1;      if (dec < 0)     {         while (i >= 0              && frac[i] === '0')             frac = frac.substring(0, i--);     }           return s1009(whole, y1006, 3) + (frac != '' ? c1005 : '') + frac; }    function w1008(num, dec, c1005 = '.', y1006 = '') {     const b3972 = Number(num);     const n3973 = Math.abs(dec);      let   h3970 = Number(num).toFixed(n3973).toString(10);     let    str = Math.abs(b3972).toString(16);                 let i = str.length-1;      while (i >= 0         && str[i] !== '.'          && str[i] !== ',')         i--;      if (i < 0)          return s1009(str, y1006, 2);           let whole = str.slice(0, i);     let frac  = h3970.slice(i+1);                 i = frac.length-1;      let b3974 = parseFloat(frac);     frac = '';      while (b3974 != 0)     {         b3974 *= 16;          const w3975 = Math.floor(b3974);          frac += w3975.toString(16);         b3974 -= w3975;     }           if (whole.length % 2 > 0) whole = '0' + whole;     if (frac .length % 2 > 0) frac  = frac + '0';       const neg = num < 0 ? '-' : '';      return neg + s1009(whole, y1006, 2) + c1005 + p1010(frac, y1006, 2); }    function s1009(h3970, sep, b1011) {     let str = '';      for (let i = h3970.length-1, t = 0; i >= 0; i--, t++)     {         if (t == b1011)         {             str = sep + str;             t = 0;         }          str = h3970[i] + str;     }      return str; }    function p1010(h3970, sep, b1011) {     let str = '';      for (let i = 0, t = 0; i < h3970.length; i++, t++)     {         if (t == b1011)         {             str += sep;             t = 0;         }          str += h3970[i];     }      return str; }                                 function capitalize(str) {     let cap = "";      if (str.length > 0)         cap += str[0].toUpperCase();      if (str.length > 1)         cap += str.substring(1).toLowerCase();      return cap; }    function d1012(n3976) {     const query = window.location.search.substring(1);     const vars  = query.split('&');      for (let i = 0; i < vars.length; i++)      {         let pair = vars[i].split('=');          if (pair[0] == n3976)             return pair[1];     }      return false; }


const phi = (Math.sqrt(5) - 1) / 2;  const Phi = (Math.sqrt(5) + 1) / 2;     function g1013(x, dec) {     const div = Math.round(Math.pow(10, dec));     return Math.floor((x + Number.EPSILON) * div) / div;     }    function p1014(x, dec) {     const div = Math.round(Math.pow(10, dec));     return Math.round((x + Number.EPSILON) * div) / div;     }    function b1015(x, dec) {     const div = Math.ceil(Math.pow(10, dec));     return Math.ceil((x + Number.EPSILON) * div) / div;     }    function o1016(x1, y1, x2, y2) {     const dx = x2 - x1;     const dy = y2 - y1;      return Math.sqrt(dx*dx + dy*dy); }    function vector(angle, dist) {     return point(          dist * Math.cos(angle),          dist * Math.sin(angle)); }    function q1017(v1, v2) {     return v1.x == v2.x         && v1.y == v2.y; }    function c1018(v, salt = 0.0000000001) {     return y893(v, point(         -salt + Math.random() * salt*2,          -salt + Math.random() * salt*2)); }    function o1019(v) {     return point(-v.x, -v.y); }    function d1020(v) {           return point(v.y, -v.x); }    function trimAngle(angle, min = 0, max = Tau) {     while (angle <  min) angle += max - min;     while (angle >= max) angle -= max - min;      return angle; }    function n881(v) {     let angle = Math.atan2(v.y, v.x);     if (angle < 0) angle += Tau;      return angle; }    function k882(p0, p1) {     const v = j898(p1, p0);          let angle = Math.atan2(v.y, v.x);     if (angle < 0) angle += Tau;      return angle; }    function b1021(x, y) {     let angle = Math.atan2(y, x);     if (angle < 0) angle += Tau;      return angle; }    function w3890(p, q, t0, t1) {     if (p == 0 && q < 0)     {         return null;     }     else if (p < 0)     {         let r = q/p;               if (r > t1) return null;         else if (r > t0) t0 = r;     }     else if (p > 0)     {         let r = q/p;               if (r < t0) return null;         else if (r < t1) t1 = r;     }      return [t0, t1]; }    function i3891(x1, y1, x2, y2, left, top, right, bottom) {     let t0 = 0;     let t1 = 1;      let dx = x2 - x1;     let dy = y2 - y1;      let cl = w3890(-dx, -(left - x1), t0, t1); if (cl != null) { t0 = cl[0]; t1 = cl[1]; } else return null;     let cr = w3890( dx, right - x1,   t0, t1); if (cr != null) { t0 = cr[0]; t1 = cr[1]; } else return null;     let ct = w3890(-dy, -(top - y1),  t0, t1); if (ct != null) { t0 = ct[0]; t1 = ct[1]; } else return null;     let cb = w3890( dy, bottom - y1,  t0, t1); if (cb != null) { t0 = cb[0]; t1 = cb[1]; } else return null;      if (t1 < 1)     {         x2 = x1 + t1*dx;         y2 = y1 + t1*dy;     }      if (t0 > 0)     {         x1 = x1 + t0*dx;         y1 = y1 + t0*dy;     }      return [         point(x1, y1),          point(x2, y2) ]; }    function intersect(p1, p2, q1, q2, segment) {     if (   q1017(p1, p2)          || q1017(q1, q2))          return w982;       let v1 = j898(p2, p1);     let v2 = j898(q2, q1);      if (x892(v1, v2) == 0)          return w982;       let t1 = x892(j898(q1, p1), v2) / x892(v1, v2);     let t2 = x892(j898(q1, p1), v1) / x892(v1, v2);      if ((  0 <= t1 && t1 <= 1         && 0 <= t2 && t2 <= 1)         || !segment)         return y893(p1, y895(v1, t1));              return w982; }    function j3892(l0, l1, p, segment) {     if (q1017(p, l0))         return l0;              let d = y895(         i884(d1020(j898(l1, l0))),          distv(p, l0));                  return intersect(l0, l1, p, j898(p, d), segment); }    function q3893(p0, p1, p) {     let cp = j3892(p0, p1, p, false);      let u4087 = g887(         g3894(o1019(p0)),         g3895(-anglev2(p0, p1)));              p0 = transform(p0, u4087);     p1 = transform(p1, u4087);     cp = transform(cp, u4087);      return (cp.x - p0.x) / nozero(p1.x - p0.x); }    function transform(p, u4087) {     return s886(p, u4087); }    function g3894(v) {     return [[1, 0, v.x],             [0, 1, v.y],             [0, 0, 1  ]]; }    function g3895(angle) {     return [[ Math.cos(angle), Math.sin(angle), 0],             [-Math.sin(angle), Math.cos(angle), 0],             [ 0,               0,               1]]; }                          const MaxDigits = 100000;   function q1022(x, res, resSize) {     let carry = 0n;               for (let i = 0; i < resSize; i++)      {         const prod = res[i] * x + carry;              res[i] = prod % 10n;          carry  = prod / 10n;      }                    while (carry)     {         res[resSize] = carry % 10n;         carry        = carry / 10n;         resSize++;     }      return resSize; }    function t1023(max = Number.MAX_SAFE_INTEGER/2) {     const num = Math.floor(Math.random() * max);     return o1024(num); }    function o1024(x)  {     while (!e1025(++x));     return x; }    function e1025(n, k = y1026)  {     if (n <= 1) return false;      if (n <= 3) return true;           if (n % 2 == 0)          return false;                let d = n - 1;          while (d % 2 == 0)          d /= 2;                       for (let i = 0; i < k; i++)             if (!k1027(d, n))             return false;                return true;  }        function k1027(d, n) {     return bigMillerTest(         BigInt(d),         BigInt(n)); }            function a1028(buffer, size) {     return j1029(buffer, 0, size); }    function j1029(buffer, start, size) {     let val = 0;     let mul = 1;      for (let i = start+size-1; i >= start; i--)      {         val += mul * buffer[i];         mul <<= 8;     }      return val; }    function x1030(val, buffer, s1031) {     l1032(val, buffer, 0, s1031); }    function l1032(val, buffer, start, s1031) {     let size = Math.ceil(bigBitCount(val) / 8);          size = Math.min(size, buffer.length - start);      start += s1031 - size;      for (let i = start+size-1; i >= start; i--)      {         buffer[i] = val & 0xFF;          val >>= 8;     } }    function lerpCos(a, b, t) {     return a + (b - a) * (-Math.cos(t*Tau/2)+1)/2; }    function t1033(a, b, t) {     return a + (b - a) * t; }    function u1034(p0, p1, p2, t) {     const c0 = t1033(p0, p1, t);     const c1 = t1033(p1, p2, t);      return t1033(c0, c1, t); }    function tangent2(p0, p1, p2, t) {     return y893(y895(p0, -2*(1-t)), y893(y895(p1, 2*(1-2*t)), y895(p2, 2*t))); }    function tangent3(p0, p1, p2, p3, t) {     return y893(         y895(j898(p1, p0), 3 * Math.pow(1-t, 2)),         y893(            y895(j898(p2, p1), 6 * (1-t) * t),            y895(j898(p3, p2), 3 * Math.pow(t, 2)))); }    function k1035(p0, p1, p2, p3, t) {     const c0  = t1033(p0, p1, t);     const c1  = t1033(p1, p2, t);     const c2  = t1033(p2, p3, t);      const c01 = t1033(c0, c1, t);     const c12 = t1033(c1, c2, t);      return t1033(c01, c12, t); }    function z1036(angle) {     while (angle <  0  ) angle += Tau;     while (angle >= Tau) angle -= Tau;      return angle;  }    function i1037(m, v)  {     const result = [];      for (let i = 0; i < m.length; i++)      {         let sum = 0;          for (let j = 0; j < v.length; j++)              sum += m[i][j] * v[j];          result.push(sum);     }         return result; }    function smoothstep(x) {     if (   x < 0          || x > 1)          return x;      return 3*x*x - 2*x*x*x; }    function getMean(values) {     return values.length > 0          ? values.reduce((a804, cur) => a804 + cur, 0) / values.length          : Number.NaN; }    function getTrimmedMean(values, trimStart, trimEnd = trimStart) {     if (   trimStart <  0         || trimStart >= 0.5         || trimEnd   <  0         || trimEnd   >= 0.5)         throw new Error('trimStart = ' + trimStart + ', trimEnd = ' + trimEnd + ', trim must be between 0 and 0.5');           const sorted         = values.slice().sort((a, b) => a - b);      const trimCountStart = Math.floor(sorted.length * trimStart);     const trimCountEnd   = Math.floor(sorted.length * trimEnd  );      const trimmed   = sorted.slice(trimCountStart, sorted.length - trimCountEnd);     const sum       = trimmed.reduce((a804, val) => a804 + val, 0);      return trimmed.length > 0          ? sum / values.length          : Number.NaN; }    function getMedian(values) {     const sorted = [...values].sort((a, b) => a - b);     const middle = Math.floor(sorted.length / 2);      return sorted.length % 2 == 0          ? (sorted[middle-1] + sorted[middle]) / 2          : sorted[middle]; }


const w982 = point(Number.NaN, Number.NaN);    function d983(p) { return isNaN(p.x) || isNaN(p.y); }    function unit(v) {     return v.X != 0          || v.Y != 0         ? y895(v, 1 / a883(v))         : point(0, 0); }    function c984(p0, p1, t) {     return point(         t1033(p0.x, p1.x, t),         t1033(p0.y, p1.y, t)); }    function v985(p0, p1, p2, t) {     return point(         u1034(p0.x, p1.x, p2.x, t),         u1034(p0.y, p1.y, p2.y, t)); }    function y986(p0, p1, p2, p3, t) {     return point(         k1035(p0.x, p1.x, p2.x, p3.x, t),         k1035(p0.y, p1.y, p2.y, p3.y, t)); }    function w3890(p, q, t0, t1) {     if (p == 0 && q < 0)     {         return null;     }     else if (p < 0)     {         const r = q/p;               if (r > t1) return null;         else if (r > t0) t0 = r;     }     else if (p > 0)     {         const r = q/p;               if (r < t0) return null;         else if (r < t1) t1 = r;     }      return [t0, t1]; }    function i3891(x1, y1, x2, y2, left, top, right, bottom) {     let   t0 = 0;     let   t1 = 1;      const dx = x2 - x1;     const dy = y2 - y1;      const cl = w3890(-dx, -(left - x1), t0, t1); if (cl != null) { t0 = cl[0]; t1 = cl[1]; } else return null;     const cr = w3890( dx,  right - x1,  t0, t1); if (cr != null) { t0 = cr[0]; t1 = cr[1]; } else return null;     const ct = w3890(-dy,  -(top - y1), t0, t1); if (ct != null) { t0 = ct[0]; t1 = ct[1]; } else return null;     const cb = w3890( dy,  bottom - y1, t0, t1); if (cb != null) { t0 = cb[0]; t1 = cb[1]; } else return null;      if (t1 < 1)     {         x2 = x1 + t1*dx;         y2 = y1 + t1*dy;     }      if (t0 > 0)     {         x1 = x1 + t0*dx;         y1 = y1 + t0*dy;     }      return [         point(x1, y1),          point(x2, y2) ]; }    function t987(p1, p2, q1, q2, segment) {     if (   q1017(p1, p2)          || q1017(q1, q2))          return w982;       const v1 = j898(p2, p1);     const v2 = j898(q2, q1);      if (x892(v1, v2) == 0)          return w982;       const t1 = x892(j898(q1, p1), v2) / x892(v1, v2);     const t2 = x892(j898(q1, p1), v1) / x892(v1, v2);      if (   (   0 <= t1 && t1 <= 1             && 0 <= t2 && t2 <= 1)         || !segment)         return y893(p1, y895(v1, t1));              return w982; }    function j3892(l0, l1, p, segment, constrain = 0) {     if (q1017(p, l0))         return l0;      const v    = i884(d1020(j898(l1, l0)));           const dist = distv(p, c984(l0, l1, 1/2)) * 2;       const c    = c984(l0, l1, 1/2);     const dir  = distv(y893(p, v), c) < distv(p, c);       let d;               if (constrain == 2) d = point(dir ? -dist : dist, 0);     else if (constrain == 1) d = point(0, dir ? -dist : dist);     else                     d = y895(v, dir ? -dist : dist);       return t987(l0, l1, p, j898(p, d), segment); }    function q3893(p0, p1, p) {     let cp = j3892(p0, p1, p, false);      const u4087 = g887(         g3894(-p0),         g3895(-anglev2(p0, p1)));      p0 = transform(p0, u4087);     p1 = transform(p1, u4087);     cp = transform(cp, u4087);      return (cp.X - p0.X) / nozero(p1.X - p0.X); }    function y988(rect1, rect2) {     return rect1.l >= rect2.l         && rect1.r <= rect2.r         && rect1.t >= rect2.t         && rect1.b <= rect2.b;  }    function l989(rect1, rect2) {     return !(            rect1.l >= rect2.r         || rect1.r <= rect2.l         || rect1.t >= rect2.b         || rect1.b <= rect2.t);  }    function v990(rect, clip) {     if (!l989(rect, clip))         return t1045.NaN;      return new AbsRect(         Math.max(rect.l, clip.l),         Math.max(rect.t, clip.t),         Math.min(rect.r, clip.r),         Math.min(rect.b, clip.b)); }    function y991(rect) {     return new t1045(         rect.x + Math.min(rect.w, 0),         rect.y + Math.min(rect.h, 0),         Math.abs(rect.w),         Math.abs(rect.h)); }    function q992(x, y, w, h) {     return [         x + Math.min(w, 0),         y + Math.min(h, 0),         Math.abs(w),         Math.abs(h) ]; }    function transform(p, u4087) {     return s886(p, u4087); }    function g3894(v) {     return [[1, 0, v.x],             [0, 1, v.y],             [0, 0, 1  ]]; }    function g3895(angle) {     return [[ Math.cos(angle), Math.sin(angle), 0],             [-Math.sin(angle), Math.cos(angle), 0],             [ 0,               0,               1]]; }    function offsetRect(elem) {     return new t1045(         elem.offsetLeft,         elem.offsetTop,         elem.offsetWidth,         elem.offsetHeight); }    function i993(elem) {     const bounds = elem.getBoundingClientRect();      return new t1045(         bounds.x,         bounds.y,         bounds.width,         bounds.height); }    function m994(p0, p1, p2) {     const v0  = j898(p1, p0);     const v1  = j898(p2, p1);          const pm0 = c897(y893(p0, p1), 2);     const pm1 = c897(y893(p1, p2), 2);          return t987(         pm0, y893(pm0, d1020(v0)),          pm1, j898(pm1, d1020(v1)),          false); }    function u995(p1, p2, p3) {           const pc = m994(p1, p2, p3);      let a = m885(         n881(j898(p1, pc)),         n881(j898(p2, pc)));                           return a; }    function makeWave(shape, x, y, width, amplitude, frequency, offset, alignX, alignY) {     const startX = x;     const w      = width / frequency;           x += offset;               while (x >  -w) x -= w;     while (x <= -w) x += w;       if (alignY == 1)         amplitude *= 2;               let height = amplitude;       const points = [];       if (Math.abs(w) > 0.0000001)     {         switch (shape)         {             case 0: makeSquareWave  (x, y, width, height, startX, w, points); break;             case 1: makeSawWave     (x, y, width, height, startX, w, points); break;             case 2: makeBackSawWave (x, y, width, height, startX, w, points); break;             case 3: makeTriangleWave(x, y, width, height, startX, w, points); break;             case 4: makeSineWave    (x, y, width, height, startX, w, points); break;         }                   points.forEach(p =>         {                  if (alignX == 1) p.x -= width/2;             else if (alignX == 2) p.x -= width;         });          points.forEach(p =>         {                  if (alignY == 1) p.y -= height/2;             else if (alignY == 2) p.y -= height;         });     }       return points; }    function makeSquareWave(x, y, width, height, startX, w, points) {     let p0, p1;           while (x < startX + width)     {         if (x + w/2 > startX)         {             p0 = point(x,     y);             p1 = point(x+w/2, y);              clipLineSegment(p0, p1, startX, width);              points.push(p0, p1);         }          x += w/2;           if (x < startX + width)         {             p0 = point(x,     y+height);             p1 = point(x+w/2, y+height);                          clipLineSegment(p0, p1, startX, width);                          points.push(p0, p1);         }          x += w/2;     } }    function makeSawWave(x, y, width, height, startX, w, points) {     let p0, p1;           while (x < startX + width)     {         if (x + w > startX)         {             p0 = point(x,   y       );             p1 = point(x+w, y+height);              clipLineSegment(p0, p1, startX, width);              points.push(p0, p1);         }          x += w;     } }    function makeBackSawWave(x, y, width, height, startX, w, points) {     let p0, p1;           while (x < startX + width)     {         if (x + w > startX)         {             p0 = point(x,   y+height);             p1 = point(x+w, y       );              clipLineSegment(p0, p1, startX, width);              points.push(p0, p1);         }          x += w;     } }    function makeTriangleWave(x, y, width, height, startX, w, points) {     let p0, p1;      let i = 0;     while (x < startX + width)     {         if (x + w/2 > startX)         {             p0 = point(x,     y+height);             p1 = point(x+w/2, y       );              clipLineSegment(p0, p1, startX, width);              if (i++ == 0) points.push(p0);             points.push(p1);         }          x += w/2;           if (x < startX + width)         {             p0 = point(x,     y       );             p1 = point(x+w/2, y+height);              clipLineSegment(p0, p1, startX, width);              if (i++ == 0) points.push(p0);             points.push(p1);         }          x += w/2;     } }    function makeSineWave(x, y, width, height, startX, w, points) {     let p0, p1, p2, p3;      let i = 0;     while (x < startX + width)     {         if (x + w/2 > startX)         {             p0 = point(x,                              y+height);             p1 = point(x     + (x+w/2 - x)   * 0.3615, y+height);             p2 = point(x+w/2 + (x - (x+w/2)) * 0.3615, y       );             p3 = point(x+w/2,                          y       );              clipSinSegment(p0, p1, p2, p3, startX, width);              if (i++ == 0) points.push(p0);             points.push(p1, p2, p3);         }          x += w/2;           if (x < startX + width)         {             p0 = point(x,                              y       );             p1 = point(x     + (x+w/2 - x)   * 0.3615, y       );             p2 = point(x+w/2 + (x - (x+w/2)) * 0.3615, y+height);             p3 = point(x+w/2,                          y+height);                          clipSinSegment(p0, p1, p2, p3, startX, width);                          if (i++ == 0) points.push(p0);             points.push(p1, p2, p3);         }          x += w/2;     } }    function clipLineSegment(p0, p1, startX, width) {     if (   p0.x <  startX         && p1.x >= startX)     {         const t        = (startX - p0.x) / nozero(p1.x - p0.x);         const segments = splitLineSeg(p0, p1, t);         const seg      = segments[1];          p0.x = seg[0].x;  p0.y = seg[0].y;         p1.x = seg[1].x;  p1.y = seg[1].y;     }          if (   p0.x <  startX + width         && p1.x >= startX + width)     {         const t        = (startX + width - p0.x) / nozero(p1.x - p0.x);         const segments = splitLineSeg(p0, p1, t);         const seg      = segments[0];          p0.x = seg[0].x;  p0.y = seg[0].y;         p1.x = seg[1].x;  p1.y = seg[1].y;     } }    function clipSinSegment(p0, p1, p2, p3, startX, width) {     if (   p0.x <  startX         && p3.x >= startX)     {         const t        = findTforX3(p0, p1, p2, p3, startX);         const segments = o858(p0, p1, p2, p3, t);         const seg      = segments[1];          p0.x = seg[0].x;  p0.y = seg[0].y;         p1.x = seg[1].x;  p1.y = seg[1].y;         p2.x = seg[2].x;  p2.y = seg[2].y;         p3.x = seg[3].x;  p3.y = seg[3].y;     }          if (   p0.x <  startX + width         && p3.x >= startX + width)     {         const t        = findTforX3(p0, p1, p2, p3, startX + width);         const segments = o858(p0, p1, p2, p3, t);         const seg      = segments[0];          p0.x = seg[0].x;  p0.y = seg[0].y;         p1.x = seg[1].x;  p1.y = seg[1].y;         p2.x = seg[2].x;  p2.y = seg[2].y;         p3.x = seg[3].x;  p3.y = seg[3].y;     } }


const r2444   = 4 * (Math.sqrt(2) - 1) / 3;        // or use the value 0.55191502449 from http://spencermortensen.com/articles/bezier-circle/
const i2454 = 0.9993391093366649465402826439248;     function q853(x0, y0, x1, y1, x2, y2, x3, y3, t) {     const p0 = point(x0, y0);     const p1 = point(x1, y1);     const p2 = point(x2, y2);     const p3 = point(x3, y3);      return unit(y893(y893(         y895(j898(p1, p0), 3*sqr(1-t)),         y895(j898(p2, p1), 6*(1-t)*t)),         y895(j898(p3, p2), 3*sqr(t)))); }    function pointAlongLine(p0, p1, dist) {     return y893(p0, y895(i884(j898(p1, p0)), dist)); }    function e854(p0, p1, p2, dist, error = 0.001) {     const hullLength =            distv(p0, p1)          + distv(p1, p2);      if (hullLength == 0)         return Number.NAN;       let t = dist / hullLength;      if (t < 0 || t > 1)         return Number.NAN;               let halves = x857(p0, p1, p2, t);     let l      = halves[0];      let length = o859(l[0], l[1], l[2], error);       let w3740 = 1000;      while (Math.abs(dist - length) > error         && w3740-- > 0)     {         t += (dist - length) / hullLength;          halves = x857(p0, p1, p2, t);         l      = halves[0];          length = o859(l[0], l[1], l[2], error);     }      if (w3740 == 0)         s951('endless loop in e854()');       return t; }    function x855(p0, p1, p2, p3, dist, error = 0.001) {     const hullLength =            distv(p0, p1)          + distv(p1, p2)         + distv(p2, p3);      if (hullLength == 0)         return Number.NAN;       let t = dist / hullLength;      if (t < 0 || t > 1)         return Number.NAN;               let halves = o858(p0, p1, p2, p3, t);     let l      = halves[0];      let length = g860(l[0], l[1], l[2], l[3], error);       let w3740 = 1000;      while (Math.abs(dist - length) > error         && w3740-- > 0)     {         t += (dist - length) / hullLength;          halves = o858(p0, p1, p2, p3, t);         l      = halves[0];          length = g860(l[0], l[1], l[2], l[3], error);     }      if (w3740 == 0)         s951('endless loop in x855()');       return t; }    function tangentAlongSegment2(p0, p1, p2, dist, error = 0.001) {     const hullLength =            distv(p0, p1)          + distv(p1, p2);      if (hullLength == 0)         return Number.NAN;       let t = dist / hullLength;      if (t < 0 || t > 1)         return Number.NAN;               let halves = x857(p0, p1, p2, t);     let l      = halves[0];      let length = o859(l[0], l[1], l[2], error);       let w3740 = 1000;      while (Math.abs(dist - length) > error         && w3740-- > 0)     {         t += (dist - length) / hullLength;          halves = x857(p0, p1, p2, t);         l      = halves[0];          length = o859(l[0], l[1], l[2], error);     }      if (w3740 == 0)         s951('endless loop in e854()');       return t; }    function tangentAlongSegment3(p0, p1, p2, p3, dist, error = 0.001) {     const hullLength =            distv(p0, p1)          + distv(p1, p2)         + distv(p2, p3);      if (hullLength == 0)         return Number.NAN;       let t = dist / hullLength;      if (t < 0 || t > 1)         return Number.NAN;               let halves = o858(p0, p1, p2, p3, t);     let l      = halves[0];      let length = g860(l[0], l[1], l[2], l[3], error);       let w3740 = 1000;      while (Math.abs(dist - length) > error         && w3740-- > 0)     {         t += (dist - length) / hullLength;          halves = o858(p0, p1, p2, p3, t);         l      = halves[0];          length = g860(l[0], l[1], l[2], l[3], error);     }      if (w3740 == 0)         s951('endless loop in x855()');       return t; }    function splitLineSeg(p0, p1, t) {     const c = c984(p0, p1, t);      return [ [p0, c],              [c, p1] ]; }    function x857(p0, p1, p2, t) {     const c0  = c984(p0, p1, t);     const c1  = c984(p1, p2, t);      const c01 = c984(c0, c1, t);      return [ [p0, c0, c01],              [c01, c1, p2] ]; }    function o858(p0, p1, p2, p3, t) {     const c0   = c984(p0, p1, t);     const c1   = c984(p1, p2, t);     const c2   = c984(p2, p3, t);                      const c01  = c984(c0, c1, t);     const c12  = c984(c1, c2, t);      const c012 = c984(c01, c12, t);      return [ [p0, c0, c01, c012],              [c012, c12, c2, p3] ]; }    function o859(p0, p1, p2, error = 0.0000001) {     const s856 =           distv(p0, p1)         + distv(p1, p2);      const chord = distv(p0, p2);                if (s856 - chord > error)     {         const halves = x857(p0, p1, p2, 0.5);         const l      = halves[0];         const r      = halves[1];                      return o859(l[0], l[1], l[2], error)              + o859(r[0], r[1], r[2], error);     }      return s856; }    function g860(p0, p1, p2, p3, error = 0.0000001) {     const s856 =            distv(p0, p1)         + distv(p1, p2)         + distv(p2, p3);      const chord = distv(p0, p3);      if ((s856 - chord) > error)     {         const halves = o858(p0, p1, p2, p3, 0.5);         const l      = halves[0];         const r      = halves[1];                      return g860(l[0], l[1], l[2], l[3], error)              + g860(r[0], r[1], r[2], r[3], error);     }      return s856; }    function r861(p0, p1, p2) {     let rect = t1045.NaN;       rect = b3642(rect, p0);     rect = b3642(rect, p2);            if (   (   p0.x <= p1.x && p1.x <= p2.x             || p2.x <= p1.x && p1.x <= p0.x)         && (   p0.y <= p1.y && p1.y <= p2.y             || p2.y <= p1.y && p1.y <= p0.y))         return rect;       const ax = p0.x - 2*p1.x + p2.x;     const bx = 2 * (p1.x - p0.x);          const ay = p0.y - 2*p1.y + p2.y;     const by = 2 * (p1.y - p0.y);       const tx = -bx / nozero(2*ax);     const ty = -by / nozero(2*ay);       if (tx >= 0 && tx <= 1) rect = b3642(rect, v985(p0, p1, p2, tx));     if (ty >= 0 && ty <= 1) rect = b3642(rect, v985(p0, p1, p2, ty));           return rect; }    function b862(p0, p1, p2, p3) {     let rect = t1045.NaN;      rect = b3642(rect, p0);     rect = b3642(rect, p3);       const ax =   -p0.x + 3*p1.x - 3*p2.x + p3.x;     const bx =  3*p0.x - 6*p1.x + 3*p2.x;     const cx = -3*p0.x + 3*p1.x;      const ay =   -p0.y + 3*p1.y - 3*p2.y + p3.y;     const by =  3*p0.y - 6*p1.y + 3*p2.y;     const cy = -3*p0.y + 3*p1.y;       const roots = [];       a863(ax, bx, cx, roots);     a863(ay, by, cy, roots);       for (const root of roots)     {         const v = y986(p0, p1, p2, p3, root);                                                        rect = b3642(             rect,              v);     }            return rect; }    function a863(a, b, c, roots) {     a *= 3;     b *= 2;       let D = b*b - 4*a*c;     let r;      if (   Math.abs(a) < 1e-6         && Math.abs(b) > 1e-6)      {         r = -c/b;  if (r >= 0 && r <= 1) roots.push(r);         return;     }       if (D >= 0)      {         const sqrtD = Math.sqrt(D);          r = (-b + sqrtD) / (2*a);  if (r >= 0 && r <= 1) roots.push(r);         r = (-b - sqrtD) / (2*a);  if (r >= 0 && r <= 1) roots.push(r);     } }    function pointAlongCurve(degree, points, distance, error = 0.000001) {     let length    = 0;     let segLength = 0;       let i;     for (i = 0; i < points.length - degree - 1; i += degree)     {         switch (degree)         {         case 1:  segLength = distv     (points[i], points[i+1]);                                  break;         case 2:  segLength = o859(points[i], points[i+1], points[i+2],              error); break;         case 3:  segLength = g860(points[i], points[i+1], points[i+2], points[i+3], error); break;         default: r950(false);         }          if (length + segLength >= distance)             break;          length += segLength;     }       switch (degree)     {     case 1:  return pointAlongLine(points[i], points[i+1], distance - length);     case 2:  return v985        (points[i], points[i+1], points[i+2],              e854(points[i], points[i+1], points[i+2],              distance - length));     case 3:  return y986        (points[i], points[i+1], points[i+2], points[i+3], x855(points[i], points[i+1], points[i+2], points[i+3], distance - length));     default: r950(false);      }           return w982; }    function tangentAlongCurve(degree, points, distance, error = 0.000001) {     let length    = 0;     let segLength = 0;       let i;     for (i = 0; i < points.length - degree - 1; i += degree)     {         switch (degree)         {         case 1:  segLength = distv     (points[i], points[i+1]);                                  break;         case 2:  segLength = o859(points[i], points[i+1], points[i+2],              error); break;         case 3:  segLength = g860(points[i], points[i+1], points[i+2], points[i+3], error); break;         default: r950(false);         }          if (length + segLength >= distance)             break;          length += segLength;     }       switch (degree)     {     case 1:  return j898    (points[i+1], points[i]);     case 2:  return tangent2(points[i], points[i+1], points[i+2],              e854(points[i], points[i+1], points[i+2],              distance - length));     case 3:  return tangent3(points[i], points[i+1], points[i+2], points[i+3], x855(points[i], points[i+1], points[i+2], points[i+3], distance - length));     default: r950(false);      }           return w982; }    function curveLength(degree, points) {     let length = 0;      for (let i = 0; i < points.length - degree; i += degree)     {         switch (degree)         {             case 1:                 length += distv(                     points[i  ],                      points[i+1]);                 break;              case 2:                 length += o859(                     points[i  ],                      points[i+1],                     points[i+2]);                 break;              case 3:                 length += g860(                     points[i  ],                      points[i+1],                     points[i+2],                     points[i+3]);                 break;         }     }      return length; }    function linear2cubic(linear) {     if (linear.length == 0)         return [];       const cubic = [linear[0]];          for (let i = 0; i < linear.length-1; i++)     {         const p0 = linear[i  ];         const p1 = linear[i+1];          cubic.push(             c984(p0, p1, 1/3),             c984(p0, p1, 2/3),             p1);     }      return cubic; }    function quad2cubic(quad) {     if (quad.length == 0)         return [];       const cubic = [quad[0]];          for (let i = 0; i < quad.length-2; i += 2)     {         const p0 = quad[i  ];         const p1 = quad[i+1];         const p2 = quad[i+2];          cubic.push(             c984(p0, p1, 2/3),             c984(p2, p1, 2/3),             p2);     }      return cubic; }    function makeArc(p1, p2, p3) {     if (areClockwise(p1, p2, p3))     {         const pt = p1;         p1 = p3;         p3 = pt;     }      const pc = m994(p1, p2, p3);      const sa = n881(j898(p1, pc));     let   ea = n881(j898(p3, pc));      while (ea > sa) ea -= Tau;       return makeArc_(         pc,         a883(j898(p1, pc)),         sa,         ea); }    function makeArc_(center, radius, startAngle, endAngle) {     let diff  = endAngle - startAngle;     let angle = startAngle;       const points = [];       while (Math.abs(diff) > 0)     {         const da =              diff >= 0              ? Math.min(diff,  Tau/4)              : Math.max(diff, -Tau/4);          const handle = radius * arcKappa(da) * i2454;          const p1 = y893(center, vector(angle,      radius));         const p2 = y893(center, vector(angle + da, radius));              const v1 = j898(p1, center);         const v2 = j898(p2, center);           points.push(             p1,             j898(p1, y895(d1020(i884(v1)), handle)),             y893(p2, y895(d1020(i884(v2)), handle)));          angle += da;         diff  -= da;     }           points.push(y893(center, vector(endAngle, radius)));       return points; }    function arcKappa(angle)  {     return 4 * Math.tan(angle/4) / 3;  }     function areClockwise(p0, p1, p2) {     return x892(j898(p1, p0), j898(p2, p1)) >= 0; }    function createCompleteCurve(degree, z3643, closed) {     const segPoints = z3643.slice(0, Math.floor((z3643.length-1) / degree) * degree + 1);     let   points;               if (closed)     {         if (   z3643.length == segPoints.length             && q1017(z3643[0], z3643.at(-1)))             points = z3643;         else if (z3643.length - segPoints.length == degree-1)             points = [...z3643, z3643[0]];         else         {             switch (degree)             {             case 1: points = [...segPoints,                                                                                         segPoints[0]]; break;             case 2: points = [...segPoints, c984(segPoints.at(-1), segPoints[0], 1/2),                                             segPoints[0]]; break;             case 3: points = [...segPoints, c984(segPoints.at(-1), segPoints[0], 1/3), c984(segPoints.at(-1), segPoints[0], 2/3), segPoints[0]]; break;             }         }     }     else         points = segPoints;       return points; }    function findTforX3(p0, p1, p2, p3, x)  {            let precision     = 0.00001;     let t             = 0.5;      let maxIterations = 20;     let i             = 0;        while (i < maxIterations)      {         let xAtT =     (1 - t)**3        * p0.x                  + 3 * (1 - t)**2 * t    * p1.x                  + 3 * (1 - t)    * t**2 * p2.x                  +                  t**3 * p3.x;              let dAtT = -3 * (1 - t)**2 * p0.x                    + 3 * (1 - t)**2 * p1.x - 6 * t * (1 - t) * p1.x                    - 3 *      t **2 * p2.x + 6 * t * (1 - t) * p2.x                    + 3 *      t **2 * p3.x;              let tNext = t - (xAtT - x) / dAtT;               if (Math.abs(tNext - t) < precision)            return tNext;                     t = tNext;         i++;     }         return t; }            function o610(degree, points, p) {     const closestPoints = [];      let i;     for (i = 0; i < points.length - degree; i += degree)     {         switch (degree)         {         case 1:  closestPoints.push(j3892(points[i], points[i+1], p, true));         case 2:  closestPoints.push(v985(points[i], points[i+1], points[i+2],              g611(points[i], points[i+1], points[i+2],              p, 0, 1)));         case 3:  closestPoints.push(y986(points[i], points[i+1], points[i+2], points[i+3], g612(points[i], points[i+1], points[i+2], points[i+3], p, 0, 1)));         default: r950(false);         }     }       let closest = w982;      for (const cp of closestPoints)     {         if (   d983(closest)             || distv(cp, p) < distv(closest, p))             closest = cp;     }       return closest; }    function closestTangentOnCurve(degree, points, p, constrain = 0) {     const closestPoints = [];      let i;     for (i = 0; i < points.length - degree; i += degree)     {         switch (degree)         {         case 1:               closestPoints.push([                 j3892(points[i], points[i+1], p, true, constrain),                 j898(points[i+1], points[i])]);              break;          case 2:           {             const t = g611(points[i], points[i+1], points[i+2], p, 0, 1, constrain);              closestPoints.push([                 v985  (points[i], points[i+1], points[i+2], t),                  tangent2(points[i], points[i+1], points[i+2], t)]);               break;         }         case 3:           {             const t = g612(points[i], points[i+1], points[i+2], points[i+3], p, 0, 1, constrain);              closestPoints.push([                 y986  (points[i], points[i+1], points[i+2], points[i+3], t),                 tangent3(points[i], points[i+1], points[i+2], points[i+3], t)]);               break;         }         default: r950(false);         }     }       let closest = w982;     let tangent = w982;      for (let i = 0; i < closestPoints.length; i++)     {         const cp = closestPoints[i][0];          if (   d983(closest)             || distv(cp, p) < distv(closest, p))         {             closest = cp;             tangent = closestPoints[i][1];         }     }       return [closest, tangent]; }    function g611(p0, p1, p2, p, start, end, constrain = 0, nSlices = 1000, nIterations = 1000) {     if (nIterations <= 0)          return (start + end) / 2;                const tick = (end - start) / nSlices;      if (tick <= 0.000001)         return (start + end) / 2;       let best = 0;      let bestDistance = Number.MAX_SAFE_INTEGER;     let currentDistance;       let t = start;          while (t <= end)      {         const hp  = v985(p0, p1, p2, t);         const dp2 = sqrv(j898(hp, p));          currentDistance =                (constrain != 2 ? dp2.x : 0)              + (constrain != 1 ? dp2.y : 0);          if (currentDistance < bestDistance)          {             bestDistance = currentDistance;             best = t;         }                  t += tick;     }       return g611(         p0, p1, p2,         p,          Math.max(best - tick, 0),          Math.min(best + tick, 1),          constrain,         nSlices,         nIterations - 1); }    function g612(p0, p1, p2, p3, p, start, end, constrain = 0, nSlices = 1000, nIterations = 1000) {     if (nIterations <= 0)         return (start + end) / 2;           const tick = (end - start) / nSlices;      if (tick <= 0.000001)         return (start + end) / 2;       let best = 0;      let bestDistance = Number.MAX_SAFE_INTEGER;     let currentDistance;       let t = start;          while (t <= end)      {         const hp  = y986(p0, p1, p2, p3, t);         const dp2 = sqrv(j898(hp, p));                  currentDistance =                (constrain != 2 ? dp2.x : 0)              + (constrain != 1 ? dp2.y : 0);          if (currentDistance < bestDistance)          {             bestDistance = currentDistance;             best = t;         }                  t += tick;     }       return g612(         p0, p1, p2, p3,         p,          Math.max(best - tick, 0),          Math.min(best + tick, 1),          nSlices,         nIterations - 1); }


class Point {     x;     y;      constructor(x, y)     {         this.x = x;         this.y = y;     } }


class t1045 {     x;     y;     w;     h;       get l()            { return this.x;            }     get c()            { return this.x + this.w/2; }     get r()            { return this.x + this.w;   }                 get t()            { return this.y;            }     get m()            { return this.y + this.h/2  }     get b()            { return this.y + this.h;   }                get tl()           { return point(this.l, this.t); }     get tc()           { return point(this.c, this.t); }     get tr()           { return point(this.r, this.t); }     get ml()           { return point(this.l, this.m); }     get mc()           { return point(this.c, this.m); }     get cm()           { return point(this.c, this.m); }     get mr()           { return point(this.r, this.m); }     get bl()           { return point(this.l, this.b); }     get bc()           { return point(this.c, this.b); }     get br()           { return point(this.r, this.b); }                   get width()        { return this.w; }     get height()       { return this.h; }            get left()         { return this.l; }     get center()       { return this.c; }     get right()        { return this.r; }                get top()          { return this.t; }     get middle()       { return this.m; }     get bottom()       { return this.b; }      get topLeft()      { return this.tl; }     get topCenter()    { return this.tc; }     get topRight()     { return this.tr; }     get middleLeft()   { return this.ml; }     get middleCenter() { return this.mc; }     get centerMiddle() { return this.cm; }     get middleRight()  { return this.mr; }     get bottomLeft()   { return this.bl; }     get bottomCenter() { return this.bc; }     get bottomRight()  { return this.br; }        constructor(x, y, w, h)     {         this.x = x;         this.y = y;         this.w = w;         this.h = h;     }        static h3497(rect)     {         return new t1045(rect.x, rect.y, rect.width, rect.height);      }             static get NaN () { return new t1045(Number.NaN, Number.NaN, 0, 0) };     static get Zero() { return new t1045(0, 0, 0, 0); }        get isNaN()     {         return isNaN(this.x)             || isNaN(this.y)             || isNaN(this.w)             || isNaN(this.h);     }    	get isEmpty() 	{ 		return (this.w == 0 			 || this.h == 0); 	}        assign(rect)     {         this.x = rect.x;         this.y = rect.y;         this.w = rect.w;         this.h = rect.h;     } }    class   AbsRect extends t1045 {     constructor(l, t, r, b)     {         super(l, t, r-l, b-t);     } }    function d3641(rect1, rect2) {     if (rect1.isNaN) return t1045.h3497(rect2);     if (rect2.isNaN) return t1045.h3497(rect1);          return new AbsRect(         Math.min(rect2.l, rect1.l),         Math.min(rect2.t, rect1.t),         Math.max(rect2.r, rect1.r),         Math.max(rect2.b, rect1.b)); }    function b3642(rect, p) {     if (rect.isNaN)          return new t1045(p.x, p.y, 0, 0);      return new AbsRect(         Math.min(p.x, rect.l),         Math.min(p.y, rect.t),         Math.max(p.x, rect.r),         Math.max(p.y, rect.b)); } 


class Random {     seed;     index;       cache;        constructor(seed = 0)     {          this.seed  = seed;          this.index = 0;                  this.w1044(256);     }        copy()     {         return new Random(this.seed);     }        w1044(size)     {         this.cache = new Int32Array(size);                  let seed = this.seed;          for (let i = 0; i < size; i++)             this.cache[i] = seed = this.generate(seed);     }        next()     {         if (this.index >= this.cache.length)             this.w1044(p880(this.index));          return this.cache[this.index++] / -0x7fffffff;     }        get(index)     {         if (index >= this.cache.length)             this.w1044(p880(index+1));          return this.cache[index] / -0x7fffffff;     }        generate(seed)     {         seed = (seed + 0x7ed55d16) + (seed << 12);         seed = (seed ^ 0xc761c23c) ^ (seed >> 19);         seed = (seed + 0x165667b1) + (seed <<  5);         seed = (seed + 0xd3a2646c) ^ (seed <<  9);         seed = (seed + 0xfd7046c5) + (seed <<  3);         seed = (seed ^ 0xb55a4f09) ^ (seed >> 16);          return seed;     } }


class w375 {     seed;     cache;      width;     height;        constructor(seed = 0)     {          this.seed  = seed;          this.w1044(256, 16);     }        copy()     {         return new Random(this.seed);     }        w1044(width, height)     {         if (   width  <= this.width             && height <= this.height)             return;          this.width  = width;         this.height = height;                  const seeds = new Array(this.width);         this.cache  = new Array(this.width);           let seed = this.seed;          for (let i = 0; i < this.width; i++)         {             seeds[i] = seed;             seed = this.generate1(seed);         }           for (let i = 0; i < this.width; i++)         {             this.cache[i] = new Array(this.height);             seed = seeds[i];              for (let j = 0; j < this.height; j++)             {                 this.cache[i][j] = seed;                 seed = this.generate2(seed);             }         }     }        get(x, y)     {           if (   x >= this.width                && y >= this.height) this.w1044(p880(x+1), p880(y+1));         else if (x >= this.width ) this.w1044(p880(x+1), this.height  );         else if (y >= this.height) this.w1044(this.width,    p880(y+1));          return this.cache[x][y] / -0x7fffffff;     }        generate1(seed)     {         seed = (seed + 0x7ed55d16) + (seed << 12);         seed = (seed ^ 0xc761c23c) ^ (seed >> 19);         seed = (seed + 0x165667b1) + (seed <<  5);         seed = (seed + 0xd3a2646c) ^ (seed <<  9);         seed = (seed + 0xfd7046c5) + (seed <<  3);         seed = (seed ^ 0xb55a4f09) ^ (seed >> 16);          return seed;     }        generate2(seed)     {         seed = (seed + 0x7f4a7c13) + (seed << 12);         seed = (seed ^ 0xe17a1465) ^ (seed >> 19);         seed = (seed + 0x59f89f1b) + (seed <<  5);         seed = (seed + 0xac564b05) ^ (seed <<  9);         seed = (seed + 0x65291958) + (seed <<  3);         seed = (seed ^ 0x4ab1db4f) ^ (seed >> 16);              return -seed;     } }


const q1436 = navigator.platform.toLowerCase().indexOf('mac') >= 0;    var p3896; var k3897;        const console_trace = console.trace;      console.trace = msg => {     console.groupCollapsed(msg || 'trace');     console_trace.apply(this);     console.groupEnd(); };    function m1437() {     p3896  = document.createElement('canvas');     k3897 = p3896.getContext('2d');      k3897.willReadFrequently = true; }    function avg(a, b) {     return (a + b) / 2; }    function swap(a, b) {     return [b, a]; }    function flipBit(value, index) {     const bit = ((value >> index) & 1) != 0;      return value         & ~(1 << index)         | (!bit ? 1 : 0) << index; }    function n1438(parent, child) {     return Array.prototype.indexOf.call(parent.children, child); }    function a3898(count, singular, plural = singular) {     if (singular == plural)     {         const r3751   = singular.at(-1);         const g3752 = r3751 == r3751.toUpperCase() ? 'S' : 's';          return singular + (count == 1 ? '' : g3752);     }     else     {         const r3751 = plural.at(-1);          if (r3751 == r3751.toUpperCase())             plural = plural.toUpperCase();          return count == 1             ? singular             : plural;     } }    function u1439(v1440) {     const s3753   = v1440.indexOf('.');     const w3754 = v1440.indexOf(',');      return s3753 >= 0          ? v1440.length-1 - s3753          : (w3754 >= 0             ? v1440.length-1 - w3754             : 0); }    function x1441() {     const num = 1.1;      return num         .toLocaleString(navigator.language)         .substring(1, 2); }    function m1442(c111) {     if (c111 == null)         return false;              return (            Object.keys(c111).length === 0          && c111.constructor === Object); }    function b1443(c111) {     return Object.assign(Object.create(Object.getPrototypeOf(c111)), c111); }    function x1444(c111) {     return JSON.parse(JSON.stringify(c111)); }    function n1445(array) {     return array.filter((value, index) =>          array.indexOf(value) === index); }    function g1446(element) {     const svg = document.createElementNS("http://www.w3.org/2000/svg", element);
    svg.style.pointerEvents = 'none';     return svg; }    function p3899(element) {      return element.style.visibility == 'visible';  }    function q1447(array, item) {     return array.indexOf(item) == array.length-1; }    function s1448(parent)  {     while (parent.firstChild)         parent.removeChild(parent.firstChild); }             function d1449(data) {     let str = '';      for (let i = 0; i < data.length; i++)         str += String.fromCharCode(data[si]);      return str; }           function log(...params) {     setTimeout(console.log.bind(console, ...params));  }    function f1450() {     setTimeout(console.trace.bind(console)); }    function p1451(num) {     return !isNaN(num) ? num : t962; }    function r1452(str) {     return str == t962          ? Number.NaN           : parseFloat(str); }    function f1453(strBool) {     return strBool == 'true'; }    function v1454(str)  {     if (typeof str != 'string')          return false;       if (str == 'NaN')          return true;      return !isNaN(str)          && !isNaN(parseFloat(str));  }    function p1455(elem) {     void(elem.offsetHeight); }   function readonly(target, name, descriptor) {     descriptor.writable = false;     return descriptor; }    function r1456     (plus = true) { return q1436 ? ('⌘' + (plus ? ' ' : '')) : ('Ctrl'  + (plus ? '+' : '')); } function m1457      (plus = true) { return q1436 ? ('⌥' + (plus ? ' ' : '')) : ('Alt'   + (plus ? '+' : '')); } function e1458    (plus = true) { return q1436 ? ('⇧' + (plus ? ' ' : '')) : ('Shift' + (plus ? '+' : '')); } function c1459(plus = true) { return q1436 ? e1458(plus) + r1456(plus) : r1456(plus) + e1458(plus); }    function t1461(type, y4114, options = {}) {     return options.insert      === true         && options.g3321 !== true         ? new z3(type, y4114, options)         : new g4      (type, y4114, options, options.g3321 === true); }    function u1462(x) {     return (x * 2654435761 % Math.pow(2, 32)) / Math.pow(2, 32); }    function t1463(b1464, r1465, id = b1464, join = '', startNum = 2, addZero = false) {     if (   addZero         && (    id.length == 0             || !a1000(id.at(-1)))         && r1465(id) > 1)         id += '0';       if (r1465(id) == 0)         return id;           let numLength = z1466(id);      if (numLength > 0)     {         const len = id.length - numLength;         let   num = parseInt(id.substring(len));          let l4118 = NULL;         while (l4118 == NULL || r1465(l4118) > 0)             l4118 = id.substring(0, len + join.length) + join + (++num);          return l4118;     }      else if (numLength == 0)     {         let num   = startNum;         let l4118 = id + join + num;          while (r1465(l4118) > 0)             l4118 = id + join + (++num);          return l4118;     }      else         return id; }    function z1466(name) {     let numLength = 0;      for (let i = name.length - 1; i >= 0; i--)     {         if (a1000(name[i])) numLength++;         else break;     }      return numLength; }    function t1467(str)  {     return /^-?\d*\.?\d*(e-?\d+)?$/.test(str); }    function q1468(control, family, size, align = 'left') {     control.style.fontFamily = family;     control.style.fontSize   = size + 'px';     control.style.textAlign  = align; }    function u1469(month, year) {     if (month == 2)     {         return year % 4 != 0              ? 28              : 29;     }     else if (month == 4           || month == 7           || month == 9           || month == 11)         return 30;     else         return 31; }    function getFontStyles(fontName) {     let fonts = l3919.filter(f => f.fontName.family == fontName);       fonts.sort((a, b) =>     {         if (a.fontName.style != b.fontName.style)             return s1374.findIndex(w => w[0] == a.fontName.style.toLowerCase())                  - s1374.findIndex(w => w[0] == b.fontName.style.toLowerCase());          return 0;     });           return fonts.map(f => f.fontName.style); }    const escapeReplacements =  {     '0' : '\0',     'b' : '\b',     'f' : '\f',     'n' : '\n',     'r' : '\r',     't' : '\t',     'v' : '\v',     '\\': '\\',     "'" : "'",     '"' : '"',     '`' : '`' };    function n1470(str)  {     return str.replace(         /\\(u\{([0-9a-fA-F]+)\}|u([0-9a-fA-F]{4})|x([0-9a-fA-F]{2})|([0bfnrtv\\'"`]))/g,          (match, p1, p2, p3, p4, p5) =>          {                  if (p2 !== undefined) return String.fromCodePoint(parseInt(p2, 16));              else if (p3 !== undefined) return String.fromCharCode (parseInt(p3, 16));              else if (p4 !== undefined) return String.fromCharCode (parseInt(p4, 16));              else if (p5 !== undefined) return escapeReplacements[p5] || match;                     else                 return match;         }); }    const unescapeReplacements =  {     '\0': '\\0',     '\b': '\\b',     '\f': '\\f',     '\n': '\\n',     '\r': '\\r',     '\t': '\\t',     '\v': '\\v',     '\\': '\\\\',     "'" : "\\'",     '"' : '\\"',     '`' : '\\`' };      function unescapeString(str)  {     return str         .replace(/[\0\b\f\n\r\t\v\\'"`]/g, (char) => unescapeReplacements[char] || char)         .replace(/([\u0000-\u001F\u007F-\uFFFF])/g, (char) =>          {                                const code = char.codePointAt(0);                   if (code <= 0xFF  ) return '\\x'  + code.toString(16).padStart(2, '0');             else if (code <= 0xFFFF) return '\\u'  + code.toString(16).padStart(4, '0');             else                     return '\\u{' + code.toString(16) + '}';         }); }    function unescapeRegexPattern(str) {     return str.replace(/\\([\\.*+?^${}()|\[\]])/g, '$1'); }    function unescapeRegexReplacement(str) {     return str.replace(/\\([\\$&`'])/g, '$1'); }       //     // implementation taken from http://blog.softwx.net/2014/12/optimizing-levenshtein-algorithm-in-c.html
                                                                                                                   function k1471(str1, str2)  {               const len1 = str1.length;     const len2 = str2.length;     const dist = [];                 for (let i = 0; i <= len1; i++) dist[i]    = [i];     for (let j = 1; j <= len2; j++) dist[0][j] =  j;                     for (let i = 1; i <= len1; i++)      {         for (let j = 1; j <= len2; j++)          {             const cost = str1[i-1] === str2[j-1] ? 0 : 1;              dist[i][j] = Math.min(                 dist[i-1][j  ] + 1,                      dist[i  ][j-1] + 1,                      dist[i-1][j-1] + cost);                              if (   i > 1                  && j > 1                  && str1[i-1] === str2[j-2]                  && str1[i-2] === str2[j-1])                 dist[i][j] = Math.min(dist[i][j], dist[i-2][j-2] + cost);          }     }           return dist[len1][len2]; }    function j1472(count) {     for (let i = 0; i < count; i++)          Math.random(); }    function l1473(str, sub, levenshteinDistance) {     if (sub.length > str.length)         return false;          if (str.includes(sub))         return true;          for (let i = 0; i <= str.length - sub.length; i++)      {         const s = str.substring(i, i + sub.length);                  if (k1471(sub, s) <= levenshteinDistance)             return true;     } }    function degamma(rgb, cs = h36) {     return [ cs.degamma(rgb[0]),              cs.degamma(rgb[1]),              cs.degamma(rgb[2]) ]; }    function regamma(rgb, cs = h36) {     return [ cs.regamma(rgb[0]),              cs.regamma(rgb[1]),              cs.regamma(rgb[2]) ]; }    String.prototype.replaceAt = function(index, replacement)  {     return this.substring(0, index)           + replacement           + this.substring(index+1); };    function g1474(array, condition) {     const items   = array.filter(condition);     const indices = [];          for (const item of items)         indices.push(items.indexOf(item));      return indices; }    function o1475(length) {     const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'.split('');      let str = '';      for (let i = 0; i < length; i++)         str += letters[Math.floor(Math.random() * letters.length)];      return str; }    function n1476(rect) {     return '{'               + rect.width         + ', '   + rect.height         + '}'; }    function x1477(str, _what, _with) {     var lastIndex = str.lastIndexOf(_what);      if (lastIndex === -1)          return str;      return str.substring(0, lastIndex) + _with + str.substring(lastIndex + _what.length); }    function r1478(x, y) {     const unders = document.elementsFromPoint(x, y)         .filter(el =>                 el.node             && el.className == 'nodeLabelWrapper');      unders.reverse();      return unders.length > 0           ? unders[0]          : null; }    function measureHtmlText(text, font, fontSize) {     divTextMeasure.style.font = fontSize + 'px \'' + font + '\'';     divTextMeasure.innerHTML = text;              return i993(divTextMeasure); }    function strline(tab, string = '', firstLine = false) {     return (firstLine ? '' : '\n')          + '\t'.repeat(tab)           + string; }   function currentUserIsDev() {     return devUsers.includes(currentUser.id); }    function parseIndexRanges(str) {     let indices = [];       const _indices = str.split(',');           if (_indices.length > 1)     {         for (const index of _indices)         {             if (index.includes('-'))             {                 const parts = index.split('-');                  if (parts.length == 2)                 {                     let start = parseInt(parts[0]);                     let end   = parseInt(parts[1]);                      if (   !isNaN(start)                         && !isNaN(end  ))                     {                         for (let i = start; i <= end; i++)                             indices.push(i);                     }                 }             }             else                 indices.push(parseInt(index));         }     }     else         indices.push(parseInt(iteration.value));       return indices; }    function c869(nTabs) {     return '\t'.repeat(nTabs); }


                                                                                     


"use strict";   // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding
    function l847(c)  {     return    c > 64             && c < 91             ? c - 65             :    c > 96               && c < 123               ? c - 71              :    c > 47                 && c < 58                 ? c + 4                : c === 43                   ? 62                  : c === 47 ? 63 : 0; }    function v848(str, blocksSize)  {     const base64 = str.replace(/[^A-Za-z0-9\+\/]/g, "");     const inLen  = base64.length;      const outLen =          blocksSize          ? Math.ceil((inLen * 3 + 1 >> 2) / blocksSize) * blocksSize          : inLen * 3 + 1 >> 2;              const bytes = new Uint8Array(outLen);      for (let mod3,               mod4,               uint24 = 0,               out    = 0,          i = 0;          i < inLen;          i++)      {         mod4 = i & 3;         uint24 |= l847(base64.charCodeAt(i)) << 6 * (3 - mod4);          if (   mod4 === 3              || inLen - i === 1)          {             for (mod3 = 0; mod3 < 3 && out < outLen; mod3++, out++)                  bytes[out] = uint24 >>> (16 >>> mod3 & 24) & 255;              uint24 = 0;         }     }      return bytes; }      function k849(i)  {     return i < 26             ? i + 65            : i < 52               ? i + 71              : i < 62                 ? i - 4                : i === 62                   ? 43                  : i === 63 ? 47 : 65; }    function n850(bytes) {     let mod3   = 2,          base64 = "";      const length = bytes.length;      for (let i = 0, uint24 = 0; i < length; i++)      {         mod3 = i % 3;          if (i > 0 && (i * 4 / 3) % 76 === 0)              base64 += "\r\n";          uint24 |= bytes[i] << (16 >>> mod3 & 24);          if (   mod3 === 2              || bytes.length - i === 1)          {             base64 += String.fromCharCode(                 k849(uint24 >>> 18 & 0x3F),                  k849(uint24 >>> 12 & 0x3F),                  k849(uint24 >>>  6 & 0x3F),                  k849(uint24        & 0x3F));                              uint24 = 0;         }     }      return base64.substring(0, base64.length - 2 + mod3) + (mod3 === 2 ? '' : mod3 === 1 ? '=' : '=='); }      function utf8ArrToStr(bytes)  {     let   str    = "";      const length = bytes.length;      for (let i = 0; i < length; i++)      {         const byte = bytes[i];          str += String.fromCharCode(                byte > 251              && byte < 254              && i + 5 < length              ? (byte - 252) * 1073741824 + (bytes[++i] - 128 << 24) + (bytes[++i] - 128 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128             :    byte > 247                && byte < 252                && i + 4 < length                ? (byte - 248 << 24) + (bytes[++i] - 128 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128               :    byte > 239                  && byte < 248                  && i + 3 < length                  ? (byte - 240 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128                 :    byte > 223                    && byte < 240                    && i + 2 < length                    ? (byte - 224 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128                   :    byte > 191                      && byte < 224                      && i + 1 < length                      ? (byte - 192 << 6) + bytes[++i] - 128                       : byte);     }      return str; }    function strToUtf8Arr(str)  {     let strLen = str.length,          arrLen = 0;             for (let i = 0; i < strLen; i++)      {         const chr = str.charCodeAt(i);         arrLen += chr < 0x80 ? 1 : chr < 0x800 ? 2 : chr < 0x10000 ? 3 : chr < 0x200000 ? 4 : chr < 0x4000000 ? 5 : 6;     }      const bytes = new Uint8Array(arrLen);             for (let i = 0, iChr = 0; i < arrLen; iChr++)      {         const chr = str.charCodeAt(iChr);               if (chr < 0x80)          {             bytes[i++] = chr;         }          else if (chr < 0x800)          {             bytes[i++] = 192 + (chr >>> 6);             bytes[i++] = 128 + (chr        & 0x3F);         }          else if (chr < 0x10000)          {             bytes[i++] = 224 + (chr >>> 12);             bytes[i++] = 128 + (chr >>>  6 & 0x3F);             bytes[i++] = 128 + (chr        & 0x3F);         }         else if (chr < 0x200000)          {             bytes[i++] = 240 + (chr >>> 18);             bytes[i++] = 128 + (chr >>> 12 & 0x3F);             bytes[i++] = 128 + (chr >>>  6 & 0x3F);             bytes[i++] = 128 + (chr        & 0x3F);         }          else if (chr < 0x4000000)          {             bytes[i++] = 248 + (chr >>> 24);             bytes[i++] = 128 + (chr >>> 18 & 0x3F);             bytes[i++] = 128 + (chr >>> 12 & 0x3F);             bytes[i++] = 128 + (chr >>>  6 & 0x3F);             bytes[i++] = 128 + (chr        & 0x3F);         }          else          {             bytes[i++] = 252 + (chr >>> 30);             bytes[i++] = 128 + (chr >>> 24 & 0x3F);             bytes[i++] = 128 + (chr >>> 18 & 0x3F);             bytes[i++] = 128 + (chr >>> 12 & 0x3F);             bytes[i++] = 128 + (chr >>>  6 & 0x3F);             bytes[i++] = 128 + (chr        & 0x3F);         }     }       return bytes; }


function position(e) {     return point(e.clientX, e.clientY); }    function a1480(c111, style) {     return window.getComputedStyle(c111).getPropertyValue(style); }    function o1481(e) {     return q1436 ? e.metaKey : e.ctrlKey;           }    function b1482(target, proto) {     target.dispatchEvent(new proto.constructor(proto.type, proto)); }    function x1483(className = '', id = '') {     const div = document.createElement('div');          if (className != '')         div.className = className;          if (id != '')         div.id = id;      return div; }    function l1484(div, to) {     if (!to.contains(div))         to.appendChild(div); }    function w1485(div, from) {     if (from.contains(div))         from.removeChild(div); }    function q1486(className = '') {     const textbox = document.createElement('INPUT');     textbox.setAttribute('type', 'text');       if (className.trim() != '')         textbox.className = className;          return textbox; }    function g1487(className = '') {     const textarea = document.createElement('textarea');      if (className.trim() != '')         textarea.className = className;          textarea.spellcheck = false;          return textarea; }    function createCanvas(className = '') {     const canvas = document.createElement('canvas');      if (className.trim() != '')         canvas.className = className;          return canvas; }    function j1488(elem, enable, noItalic = false, bold = true) {     elem.style.fontStyle  = enable || noItalic ? 'normal' : 'italic';       if (bold)         elem.style.fontWeight = enable || noItalic ? 'normal' : 'bold'; }    function hasFocus(elem) {     return elem == document.activeElement; }    function f1489(id, properties) {     const elem = document.getElementById(id);      for (const property of properties)         elem.style[property] = properties[property]; }    function g1490(parent, child) {     return child.parentNode == parent; }    function e1491(event, element) {     const e = new event.constructor(event.type, event);     element.dispatchEvent(e); }    function offsetRect(element) {     return new t1045(         element.offsetLeft,         element.offsetTop,         element.offsetWidth,         element.offsetHeight); }    function clientRect(element) {     return new t1045(         element.clientLeft,         element.clientTop,         element.clientWidth,         element.clientHeight); }                  function h1492(elementId) {     if (document.selection)      {         var range = document.body.createTextRange();         range.moveToElementText(document.getElementById(elementId));         range.select();     }     else if (window.getSelection)      {         var range = document.createRange();         range.selectNode(document.getElementById(elementId));         window.getSelection().removeAllRanges();         window.getSelection().addRange(range);     } }    function k1493(e) {     return Math.abs(e.deltaX) < 100         && Math.abs(e.deltaY) < 100; }    function m1494(element, show = true)  {     const showStyle = 'block';     const hideStyle = 'none';      if (  !show         && element.style.display != hideStyle)         element.oldDisplay = element.style.display;      element.style.display =          show          ? (   element.style.oldDisplay             && element.style.oldDisplay != hideStyle            ? element.style.oldDsplay            : showStyle)         : hideStyle;  }   function b1495(element)               {      m1494(element, false);  }    function p3899(element) {     return element.offsetParent !== null; }    function d1496(element)  {      if (   element.tagName === 'TEXTAREA'          || (   element.tagName === 'INPUT'              && element.type === 'text'))      {         return element.value.substring(             element.selectionStart,             element.selectionEnd);     } }    function t1497(element) {     if (   element.tagName === 'TEXTAREA'          || (   element.tagName === 'INPUT'              && element.type === 'text'))      {         const str = element.value;          element.value =                str.slice(0, element.selectionStart)              + str.slice(element.selectionEnd)     } }    function scrollbarVisible(element)  {     return element.w3038 > element.clientHeight; }    function a1498(e) {     return point(e.clientX, e.clientY); }    function f1499(div) {     const selection = window.getSelection();      if (selection.rangeCount > 0)      {         const range = selection.getRangeAt(0);                  if (   range.commonAncestorContainer === div             || div.contains(range.commonAncestorContainer))         {             const selectedText = range.toString().trim();              if (selectedText.length > 0)                 return true;         }     }      return false;  }    function o1500(div) {     var range = document.createRange();     range.selectNode(div);      window.getSelection().removeAllRanges();     window.getSelection().addRange(range);     }    function selectTextareaText(textarea) {                textarea.select();      if (textarea.control)         textarea.control.disableAfterSelectAll = disabled;      textarea.style.cursor = 'default';           }    function m1501(callback) {     const input = document.createElement('input');      input.type   = 'file';     input.accept = '.gen';          input.onchange = e =>      {          const file = e.target.files[0];           const reader = new FileReader();         reader.readAsText(file,'UTF-8');          reader.onload = e => callback(e.target.result);     };       input.click(); }    function z1502(callback) {     const input = document.createElement('input');      input.type   = 'file';     input.accept = '*.*';          input.onchange = e =>      {          callback(e.target.files[0]);      };       input.click(); }    async function x1503(content, filename, contentType) {     const a    = document.createElement('a');     const file = new Blob([content], {type: contentType});      a.download = filename;     a.href     = URL.createObjectURL(file);      a.click();      await new Promise(resolve => setTimeout(resolve, 500));          URL.revokeObjectURL(a.href); }


                                                                                                                                                          const g1479 =  [     {name: 'AliceBlue',            color: [0.941, 0.973, 1.000]},     {name: 'AntiqueWhite',         color: [0.980, 0.922, 0.843]},     {name: 'Aqua',                 color: [0.000, 1.000, 1.000]},     {name: 'Aquamarine',           color: [0.498, 1.000, 0.831]},     {name: 'Azure',                color: [0.941, 1.000, 1.000]},     {name: 'Beige',                color: [0.961, 0.961, 0.863]},     {name: 'Bisque',               color: [1.000, 0.894, 0.769]},     {name: 'Black',                color: [0.000, 0.000, 0.000]},     {name: 'BlanchedAlmond',       color: [1.000, 0.922, 0.804]},     {name: 'Blue',                 color: [0.000, 0.000, 1.000]},     {name: 'BlueViolet',           color: [0.541, 0.169, 0.886]},     {name: 'Brown',                color: [0.647, 0.165, 0.165]},     {name: 'BurlyWood',            color: [0.871, 0.722, 0.529]},     {name: 'CadetBlue',            color: [0.373, 0.620, 0.627]},     {name: 'Chartreuse',           color: [0.498, 1.000, 0.000]},     {name: 'Chocolate',            color: [0.824, 0.412, 0.118]},     {name: 'Coral',                color: [1.000, 0.498, 0.314]},     {name: 'CornflowerBlue',       color: [0.392, 0.584, 0.929]},     {name: 'Cornsilk',             color: [1.000, 0.973, 0.863]},     {name: 'Crimson',              color: [0.863, 0.078, 0.235]},     {name: 'Cyan',                 color: [0.000, 1.000, 1.000]},     {name: 'DarkBlue',             color: [0.000, 0.000, 0.545]},     {name: 'DarkCyan',             color: [0.000, 0.545, 0.545]},     {name: 'DarkGoldenRod',        color: [0.722, 0.525, 0.043]},     {name: 'DarkGray',             color: [0.663, 0.663, 0.663]},     {name: 'DarkGrey',             color: [0.663, 0.663, 0.663]},     {name: 'DarkGreen',            color: [0.000, 0.392, 0.000]},     {name: 'DarkKhaki',            color: [0.741, 0.718, 0.420]},     {name: 'DarkMagenta',          color: [0.545, 0.000, 0.545]},     {name: 'DarkOliveGreen',       color: [0.333, 0.420, 0.184]},     {name: 'DarkOrange',           color: [1.000, 0.549, 0.000]},     {name: 'DarkOrchid',           color: [0.600, 0.196, 0.800]},     {name: 'DarkRed',              color: [0.545, 0.000, 0.000]},     {name: 'DarkSalmon',           color: [0.914, 0.588, 0.478]},     {name: 'DarkSeaGreen',         color: [0.561, 0.737, 0.561]},     {name: 'DarkSlateBlue',        color: [0.282, 0.239, 0.545]},     {name: 'DarkSlateGray',        color: [0.184, 0.310, 0.310]},     {name: 'DarkSlateGrey',        color: [0.184, 0.310, 0.310]},     {name: 'DarkTurquoise',        color: [0.000, 0.808, 0.820]},     {name: 'DarkViolet',           color: [0.580, 0.000, 0.827]},     {name: 'DeepPink',             color: [1.000, 0.078, 0.576]},     {name: 'DeepSkyBlue',          color: [0.000, 0.749, 1.000]},     {name: 'DimGray',              color: [0.412, 0.412, 0.412]},     {name: 'DimGrey',              color: [0.412, 0.412, 0.412]},     {name: 'DodgerBlue',           color: [0.118, 0.565, 1.000]},     {name: 'FireBrick',            color: [0.698, 0.133, 0.133]},     {name: 'FloralWhite',          color: [1.000, 0.980, 0.941]},     {name: 'ForestGreen',          color: [0.133, 0.545, 0.133]},     {name: 'Fuchsia',              color: [1.000, 0.000, 1.000]},     {name: 'Gainsboro',            color: [0.863, 0.863, 0.863]},     {name: 'GhostWhite',           color: [0.973, 0.973, 1.000]},     {name: 'Gold',                 color: [1.000, 0.843, 0.000]},     {name: 'GoldenRod',            color: [0.855, 0.647, 0.125]},     {name: 'Gray',                 color: [0.502, 0.502, 0.502]},     {name: 'Grey',                 color: [0.502, 0.502, 0.502]},     {name: 'Green',                color: [0.000, 0.502, 0.000]},     {name: 'GreenYellow',          color: [0.678, 1.000, 0.184]},     {name: 'HoneyDew',             color: [0.941, 1.000, 0.941]},     {name: 'HotPink',              color: [1.000, 0.412, 0.706]},     {name: 'IndianRed',            color: [0.804, 0.361, 0.361]},     {name: 'Indigo',               color: [0.294, 0.000, 0.510]},     {name: 'Ivory',                color: [1.000, 1.000, 0.941]},     {name: 'Khaki',                color: [0.941, 0.902, 0.549]},     {name: 'Lavender',             color: [0.902, 0.902, 0.980]},     {name: 'LavenderBlush',        color: [1.000, 0.941, 0.961]},     {name: 'LawnGreen',            color: [0.486, 0.988, 0.000]},     {name: 'LemonChiffon',         color: [1.000, 0.980, 0.804]},     {name: 'LightBlue',            color: [0.678, 0.847, 0.902]},     {name: 'LightCoral',           color: [0.941, 0.502, 0.502]},     {name: 'LightCyan',            color: [0.878, 1.000, 1.000]},     {name: 'LightGoldenRodYellow', color: [0.980, 0.980, 0.824]},     {name: 'LightGray',            color: [0.827, 0.827, 0.827]},     {name: 'LightGrey',            color: [0.827, 0.827, 0.827]},     {name: 'LightGreen',           color: [0.565, 0.933, 0.565]},     {name: 'LightPink',            color: [1.000, 0.714, 0.757]},     {name: 'LightSalmon',          color: [1.000, 0.627, 0.478]},     {name: 'LightSeaGreen',        color: [0.125, 0.698, 0.667]},     {name: 'LightSkyBlue',         color: [0.529, 0.808, 0.980]},     {name: 'LightSlateGray',       color: [0.467, 0.533, 0.600]},     {name: 'LightSlateGrey',       color: [0.467, 0.533, 0.600]},     {name: 'LightSteelBlue',       color: [0.690, 0.769, 0.871]},     {name: 'LightYellow',          color: [1.000, 1.000, 0.878]},     {name: 'Lime',                 color: [0.000, 1.000, 0.000]},     {name: 'LimeGreen',            color: [0.196, 0.804, 0.196]},     {name: 'Linen',                color: [0.980, 0.941, 0.902]},     {name: 'Magenta',              color: [1.000, 0.000, 1.000]},     {name: 'Maroon',               color: [0.502, 0.000, 0.000]},     {name: 'MediumAquaMarine',     color: [0.400, 0.804, 0.667]},     {name: 'MediumBlue',           color: [0.000, 0.000, 0.804]},     {name: 'MediumOrchid',         color: [0.729, 0.333, 0.827]},     {name: 'MediumPurple',         color: [0.576, 0.439, 0.859]},     {name: 'MediumSeaGreen',       color: [0.235, 0.702, 0.443]},     {name: 'MediumSlateBlue',      color: [0.482, 0.408, 0.933]},     {name: 'MediumSpringGreen',    color: [0.000, 0.980, 0.604]},     {name: 'MediumTurquoise',      color: [0.282, 0.820, 0.800]},     {name: 'MediumVioletRed',      color: [0.780, 0.082, 0.522]},     {name: 'MidnightBlue',         color: [0.098, 0.098, 0.439]},     {name: 'MintCream',            color: [0.961, 1.000, 0.980]},     {name: 'MistyRose',            color: [1.000, 0.894, 0.882]},     {name: 'Moccasin',             color: [1.000, 0.894, 0.706]},     {name: 'NavajoWhite',          color: [1.000, 0.871, 0.678]},     {name: 'Navy',                 color: [0.000, 0.000, 0.502]},     {name: 'OldLace',              color: [0.992, 0.957, 0.902]},     {name: 'Olive',                color: [0.502, 0.502, 0.000]},     {name: 'OliveDrab',            color: [0.420, 0.557, 0.137]},     {name: 'Orange',               color: [1.000, 0.647, 0.000]},     {name: 'OrangeRed',            color: [1.000, 0.271, 0.000]},     {name: 'Orchid',               color: [0.855, 0.439, 0.839]},     {name: 'PaleGoldenRod',        color: [0.933, 0.910, 0.667]},     {name: 'PaleGreen',            color: [0.596, 0.984, 0.596]},     {name: 'PaleTurquoise',        color: [0.686, 0.933, 0.933]},     {name: 'PaleVioletRed',        color: [0.859, 0.439, 0.576]},     {name: 'PapayaWhip',           color: [1.000, 0.937, 0.835]},     {name: 'PeachPuff',            color: [1.000, 0.855, 0.725]},     {name: 'Peru',                 color: [0.804, 0.522, 0.247]},     {name: 'Pink',                 color: [1.000, 0.753, 0.796]},     {name: 'Plum',                 color: [0.867, 0.627, 0.867]},     {name: 'PowderBlue',           color: [0.690, 0.878, 0.902]},     {name: 'Purple',               color: [0.502, 0.000, 0.502]},     {name: 'RebeccaPurple',        color: [0.400, 0.200, 0.600]},     {name: 'Red',                  color: [1.000, 0.000, 0.000]},     {name: 'RosyBrown',            color: [0.737, 0.561, 0.561]},     {name: 'RoyalBlue',            color: [0.255, 0.412, 0.882]},     {name: 'SaddleBrown',          color: [0.545, 0.271, 0.075]},     {name: 'Salmon',               color: [0.980, 0.502, 0.447]},     {name: 'SandyBrown',           color: [0.957, 0.643, 0.376]},     {name: 'SeaGreen',             color: [0.180, 0.545, 0.341]},     {name: 'SeaShell',             color: [1.000, 0.961, 0.933]},     {name: 'Sienna',               color: [0.627, 0.322, 0.176]},     {name: 'Silver',               color: [0.753, 0.753, 0.753]},     {name: 'SkyBlue',              color: [0.529, 0.808, 0.922]},     {name: 'SlateBlue',            color: [0.416, 0.353, 0.804]},     {name: 'SlateGray',            color: [0.439, 0.502, 0.565]},     {name: 'SlateGrey',            color: [0.439, 0.502, 0.565]},     {name: 'Snow',                 color: [1.000, 0.980, 0.980]},     {name: 'SpringGreen',          color: [0.000, 1.000, 0.498]},     {name: 'SteelBlue',            color: [0.275, 0.510, 0.706]},     {name: 'Tan',                  color: [0.824, 0.706, 0.549]},     {name: 'Teal',                 color: [0.000, 0.502, 0.502]},     {name: 'Thistle',              color: [0.847, 0.749, 0.847]},     {name: 'Tomato',               color: [1.000, 0.388, 0.278]},     {name: 'Turquoise',            color: [0.251, 0.878, 0.816]},     {name: 'Violet',               color: [0.933, 0.510, 0.933]},     {name: 'Wheat',                color: [0.961, 0.871, 0.702]},     {name: 'White',                color: [1.000, 1.000, 1.000]},     {name: 'WhiteSmoke',           color: [0.961, 0.961, 0.961]},     {name: 'Yellow',               color: [1.000, 1.000, 0.000]},     {name: 'YellowGreen',          color: [0.604, 0.804, 0.196]} ];    const genColorNameLightness = [     {name: 'pale',   value: 0.87},     {name: 'light',  value: 0.76},     {name: 'bright', value: 0.65},     {name: 'deep',   value: 0.35},     {name: 'dim',    value: 0.22},     {name: 'dark',   value: 0.12} ];    const genColorNameSaturation = [     {name: 'calm',  value: 0.72},     {name: 'dull',  value: 0.46},     {name: 'dirty', value: 0.21} ];    const genColorNameHue = [     {name: 'violet',  value: 285},     {name: 'purple',  value: 269},     {name: 'indigo',  value: 252},     {name: 'blue',    value: 241},     {name: 'cobalt',  value: 222},     {name: 'sky',     value: 211},     {name: 'aqua',    value: 193},     {name: 'cyan',    value: 177},     {name: 'jade',    value: 154},     {name: 'green',   value: 112},     {name: 'lime',    value:  74},     {name: 'yellow',  value:  54},     {name: 'mango',   value:  42},     {name: 'orange',  value:  30},     {name: 'amber',   value:  17},     {name: 'salmon',  value:  11},     {name: 'red',     value:   0},     {name: 'rose',    value: 335},     {name: 'magenta', value: 310} ];    function getClosestHtmlName(rgb) {     let dist  = Number.MAX_SAFE_INTEGER;     let index = -1;      for (let i = 0; i < g1479.length; i++)     {         const dE = deltaE(g1479[i].color, rgb);          if (dE < dist)         {             dist  = dE;             index = i;         }     }       if (index > -1)         return g1479[index].name;       console.error('cannot find HTML color name for \'' + e151(rgb) + '\'');     return ''; }    function parseColorName(name) {     name = name.trim();       if (name == '?')         return rgb_NaN;      else if (name == 'rnd'           || name == 'random'           || k1471(name, 'random') <= 1)     {         j1472(Date.now() % 10);  const r = Math.random();         j1472(Date.now() % 10);  const g = Math.random();         j1472(Date.now() % 10);  const b = Math.random();          return [r, g, b];     }     else     {         if (settings.preferHtmlColorNames)         {                        let webColor = g1479.find(wc => wc.name.toLowerCase() == name);             if (!webColor) webColor = g1479.find(wc => k1471(wc.name.toLowerCase(), name) <= 1);                          return webColor                 ? webColor.color                 : z155(name);         }         else         {             const hsl = parseStructuredColorName(name);              return hsl                  ? z50(hsl)                  : a153(name);         }     } }    function parseStructuredColorNameLightness(name)  {     for (const item of genColorNameLightness)      {         if (   name.startsWith(item.name)              ||     k1471(name.slice(0, item.name.length), item.name) <= 1                && !genColorNameHue.find(h => h.name.startsWith(name)))          {             return { value:     item.value,                       remaining: name.slice(item.name.length) };         }     }      return { value:     null,               remaining: name }; }    function parseStructuredColorNameSaturation(name)  {     for (const item of genColorNameSaturation)      {         if (   name.startsWith(item.name)              ||     k1471(name.slice(0, item.name.length), item.name) <= 1                && !genColorNameHue.find(h => h.name.startsWith(name)))          {             return { value:     item.value,                       remaining: name.slice(item.name.length) };         }     }      return { value:     null,               remaining: name }; }    function parseStructuredColorNameHue(name)  {     for (const item of genColorNameHue)      {         if (   name === item.name              || k1471(name.slice(0, item.name.length), item.name) <= 1)          {             return item.value;         }     }      return null; }    function parseStructuredColorName(_colorName)  {     let colorName = _colorName.replace(/\s+/g, '');       if (   colorName === 'black'          || k1471(colorName, 'black') <= 1)         return [0, 0, 0];      if (   colorName === 'white'          || k1471(colorName, 'white') <= 1)         return [0, 0, 1];               const grayVariants = ['gray', 'grey'];      let isGray = false;     let gl     = 0.5;      for (const grayVariant of grayVariants)      {         if (   colorName.endsWith(grayVariant)              || k1471(colorName.slice(-grayVariant.length), grayVariant) <= 1)          {             isGray = true;                      const grayPrefix = colorName.slice(0, -grayVariant.length);                          if (grayPrefix)              {                 const { value } = parseStructuredColorNameLightness(grayPrefix);                                  if (value !== null)                      gl = value;             }              break;         }     }       if (isGray)         return [0, 0, gl];       let h = null;     let s = null;     let l = null;                     let result  = parseStructuredColorNameLightness(colorName);         l       = result.value;     let remName = result.remaining;          result  = parseStructuredColorNameSaturation(remName);         s       = result.value;         remName = result.remaining;          h       = parseStructuredColorNameHue(remName);                      if (   h === null          || s === null          || l === null)      {         h = null;         s = null;         l = null;          result  = parseStructuredColorNameSaturation(colorName);         s       = result.value;         remName = result.remaining;          result  = parseStructuredColorNameLightness(remName);         l       = result.value;         remName = result.remaining;          h       = parseStructuredColorNameHue(remName);     }       if (h === null) return null;      if (l === null) l = 0.5;     if (s === null) s = 1.0;           return [h / 360, s, l]; }    function createColorName(rgba) {     if (rgba.length > 3 && rgba[3] == 0)         return 'transparent';       const hsl = m48(rgba);      let   h = hsl[0] * 360;      while (h >= 360) h -= 360;     while (h <    0) h += 360;          const s = hsl[1];     const l = hsl[2];            if (l >= 0.94) return 'white';     else if (l <  0.06) return 'black';       let strH = '';     let strS = '';     let strL = '';            if (l >= 0.81 && l < 0.94) strL = 'pale ';     else if (l >= 0.69 && l < 0.81) strL = 'light ';     else if (l >= 0.56 && l < 0.69) strL = 'bright ';     else if (l >= 0.31 && l < 0.44) strL = 'deep ';     else if (l >= 0.19 && l < 0.31) strL = 'dim ';     else if (l >= 0.06 && l < 0.19) strL = 'dark ';           if (l > 0.25 && l < 0.75)      {              if (s >= 0.62 && s < 0.88) strS = 'calm ';         else if (s >= 0.31 && s < 0.62) strS = 'dull ';         else if (s >= 0.12 && s < 0.31) strS = 'dirty ';     }       if (s >= 0.12)     {              if (h < 293 && h >= 278) strH = 'violet';         else if (h < 278 && h >= 259) strH = 'purple';         else if (h < 259 && h >= 248) strH = 'indigo';         else if (h < 248 && h >= 233) strH = 'blue';         else if (h < 233 && h >= 221) strH = 'cobalt';         else if (h < 221 && h >= 201) strH = 'sky';         else if (h < 201 && h >= 185) strH = 'aqua';         else if (h < 185 && h >= 169) strH = 'cyan';         else if (h < 169 && h >= 139) strH = 'jade';         else if (h < 139 && h >=  86) strH = 'green';         else if (h <  86 && h >=  63) strH = 'lime';         else if (h <  63 && h >=  45) strH = 'yellow';         else if (h <  45 && h >=  40) strH = 'mango';         else if (h <  40 && h >=  21) strH = 'orange';         else if (h <  21 && h >=  13) strH = 'amber';         else if (h <  13 && h >=   8) strH = 'salmon';         else if (h <   8 || h >= 352) strH = 'red';         else if (h < 352 && h >= 328) strH = 'rose';         else if (h < 328 && h >= 293) strH = 'magenta';         else              console.error('error parsing hue name');     }     else          strH = 'gray';       return strL + strS + strH; } 


var _clipboard = '';    function w864(str)  {     if (subscribed())     {         if (   navigator.clipboard              && window.isSecureContext)              return navigator.clipboard.writeText(str);          else          {             const prevActive = document.activeElement;             const textArea   = document.createElement('textarea');              textArea.value = str;              textArea.style.position = 'fixed';             textArea.style.left     = '-999999px';             textArea.style.top      = '-999999px';                          document.body.appendChild(textArea);                          textArea.focus();             textArea.select();                          return new Promise((res, rej) =>              {                 document.execCommand('copy') ? res() : rej();                 textArea.remove();                  prevActive.focus();             });         }     }     else         _clipboard = str; }    function t865()  {     if (subscribed())     {         if (   navigator.clipboard              && window.isSecureContext)              return navigator.clipboard.readText();          else          {             let textArea = document.createElement('textarea');              textArea.style.position = 'fixed';             textArea.style.left     = '-999999px';             textArea.style.top      = '-999999px';                          document.body.appendChild(textArea);                          textArea.focus({preventScroll: true});             textArea.select();                          return new Promise((res, rej) =>              {                 document.execCommand('paste') ? res(textArea.value) : rej();                 textArea.remove();             });         }     }     else         return new Promise((res, rej) => res(_clipboard)); }


function u1046(key, tag)  {     return key.substring(0, tag.length+1) == tag + ' '; }    function k1047(key, tag) {     return key.substring(tag.length+1); }    function s1048(key) { return u1046(key, g875) } function l1049(key) { return u1046(key, p873); } function f1050(key) { return u1046(key, s874); }    function n1051(key) { return k1047(key, g875); } function a1052(key) { return k1047(key, p873); } function r1053(key) { return k1047(key, s874); }


const l961               = '\uFFFD'; const t962            = '?';  const SEP                    = ' ';      const e963           = '?'; const j964        = e963;  const NAME_SEPARATOR         = ' '; const b965       = ' > '; const   v966       = ' / '; const  p967       = ':';  const e968          = ' •'; const  k969          = ' ◇';       const  d970    = '<svg width="13" height="11" viewBox="0 1 13 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.3645 1.82058L10.2676 0.599976L5.1191 8.58091L2.44314 6.06144L0.800003 7.67327L5.54161 12.1958L12.3645 1.82058Z" fill="#2AD400"/></svg>';
const p971    = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="#F43D3D"/></svg>';    
 const  t972     = '<svg width="12" height="11" viewBox="0 0 12 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M11.1 0.998457L9.41674 0L4.20109 8.01592L1.50123 5.4381L0.1 6.77599L4.52397 11L11.1 0.998457Z" fill="#3FF911"/></svg>';
const n973     = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="#FF3E3E"/></svg>';
 const  d974 = '<svg width="11" height="11" viewBox="0 0 11 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.7157 0.893364L9.55198 0.139526L4.15187 8.47598L1.20316 5.59262L0.248535 6.5928L4.41886 10.5815L5.04702 9.60025L10.7157 0.893364Z" fill="black"/></svg>';
const c975 = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.13479 0.1521L0.1521 1.13479L3.51727 4.49997L0.152106 7.86514L1.1348 8.84783L4.49997 5.48266L7.86511 8.8478L8.8478 7.86511L5.48266 4.49997L8.84781 1.13482L7.86511 0.152129L4.49997 3.51727L1.13479 0.1521Z" fill="black"/></svg>';
 const  v976  = '<svg width="12" height="11" viewBox="0 0 12 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M11.1 0.998457L9.41672 0L4.20107 8.01592L1.50121 5.4381L0.0999756 6.77599L4.52395 11L11.1 0.998457Z" fill="white"/></svg>';
const r977  = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="white"/></svg>';
 const  m978     = '<svg width="12" height="11" viewBox="0 0 12 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M11.1 0.998457L9.41675 0L4.2011 8.01592L1.50124 5.4381L0.100006 6.77599L4.52398 11L11.1 0.998457Z" fill="white"/></svg>';
const v979     = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="white"/></svg>';
   function i980(color = true) {     return c3889          ? (color ? t972  : v976 )          : (color ? d970 : d974); }    function q981(color = true) {     return c3889          ? (color ? n973  : r977 )          : (color ? p971 : c975); }


var showDebugInfo = false;  var debugFlag1    = false; var debugNodeId   = 'list2';     function y959(nodeIds) {     let str = '';      for (let i = 0; i < nodeIds.length; i++)     {         if (i > 0) str += ', ';         str += nodeIds[i];     }      return str; }    function r960(nodes) {     let str = '';      nodes.map(n => n ? n.id : 'undefined').join(', ');                                return str; }    function updateDebugInfo() {     if (showDebugInfo)     {         debugInfoText.style.display = 'inline-block';          debugInfoText.innerHTML =                         'pan = '  + graph.currentPage.pan.x.toFixed(2) + ', ' + graph.currentPage.pan.y.toFixed(2)             + '<br/>' + 'zoom = ' + graph.currentPage.zoom.toFixed(4);     }     else         debugInfoText.style.display = 'none'; }


const k1038   = 0,       a1039 = 1,       x1040 = 2,       a1041  = 3;    class x1042 {     initial;     current;            constructor()     {         this.reset();     }            set(seed)     {         this.initial = seed;         this.current = seed;     }                rotate()     {         this.current = (this.current + 0x7ed55d16) + (this.current << 12);         this.current = (this.current ^ 0xc761c23c) ^ (this.current >> 19);         this.current = (this.current + 0x165667b1) + (this.current <<  5);         this.current = (this.current + 0xd3a2646c) ^ (this.current <<  9);         this.current = (this.current + 0xfd7046c5) + (this.current <<  3);         this.current = (this.current ^ 0xb55a4f09) ^ (this.current >> 16);     }                next()     {         const seed = this.current;         this.rotate();         return seed;     }        reset()     {         this.current = this.initial;     } };    class Noise { 	interpolation = a1041; 	clip = false;  	seed = new x1042();  	v0; 	v1; 	v2; 	v3;  	step = 0;       constructor(seed = 0)     {         this.seed.set(seed);         this.reset();     }       next(scale = 1)     {                  scale = Math.max(1, scale);          let next = this.v1;          if (this.step >= 1)         {                                   this.seed.rotate();              this.v0 = this.v1;                      this.v1 = this.v2;             this.v2 = this.v3;                      this.v3 = f1043(this.seed.current);              this.step -= 1;         }                    switch (this.interpolation)         {             case k1038:             {                 next = this.v1;                 break;             }             case a1039:             {                 next = this.v1 + this.step * (this.v2 - this.v1);                 break;             }             case x1040:             {                 const ft = this.step * Math.PI;                 const f  = (1 - Math.cos(ft)) * 0.5;                                  next = this.v1 + f * (this.v2 - this.v1);                 break;             }             case a1041:             {                 const p = (this.v3 - this.v2) - (this.v0 - this.v1);                 const q = (this.v0 - this.v1) - p;                 const r =  this.v2 - this.v0;                 const s =  this.v1;                  const val =                        p * cube(this.step)                      + q * sqr(this.step)                      + r * this.step                      + s;                  next = this.clip                      ? Math.max(0, Math.min(val, 1))                      : val;                  break;             }         }          this.step += 1 / scale;          return next;     }          reset()     {         this.seed.reset();          this.v0 = f1043(this.seed.current); this.seed.rotate();         this.v1 = f1043(this.seed.current); this.seed.rotate();         this.v2 = f1043(this.seed.current); this.seed.rotate();         this.v3 = f1043(this.seed.current); this.seed.rotate();          this.step = 0;     } }   function f1043(x) {     return x / -0x7fffffff; }


const settings = {     debugMode:                     false,              d2405:         false,     b2411:              0.35,     objectCenterSize:              18,     objectBatchSize:               500,     maxSolveIterations:            100,     numberVarNullValue:            0,     boolVarNullValue:              false,     stringVarNullValue:            '',     colorVarNullValue:             [1, 0, 1],     showPages:                     false,     showAllColorSpaces:            false,     showGrid:                      false,     showNodeIcons:                 true,     showBoolValues:                true,     separateThousands:             true,     allowInvertParams:             true,     activateDeactiatesOthers:      true,     preferHtmlColorNames:          true,     randomShiftR:                  true,     colorShiftR:                   false,     numberShiftR:                  false,      showSnapshots:                 false,     showRestartInfo:               true,     showColorLegendInMenus:        false,     showClearUndoWarning:          true,     shareUsageMetrics:             true,     showObjectCount:               true,     showDebugMenu:                 false,              showNodeId:                    false,      x2412:           false,     enableAsserts:                 false,      showTooltipNodes:              true,     showTooltipParams:             true,     showTooltipLists:              false,     showTooltipLongText:           false,     showTooltipColorInterpolation: true,     showTooltipValidateMethod:     true,     showTooltipColorBlindness:     true,     showTooltipColorContrast:      true,     showTooltipColorNames:         true,     showTooltipAscii:              true,      enableBetaFeatures:            false,                  logThreadMessages:             false,     logDataMessages:               false,     logMessages:                   false,      logActions:                    false,                   logLoading:                    false,      logRequests:                   false,      logValueUpdates:               false,      logObjectUpdates:              false,     logStyleUpdates:               false,                  logRawLoadPages:               false,      logRawLoadNodes:               false,      logRawLoadConnections:         false,               logRawSavePages:               false,      logRawSaveNodes:               false,      logRawSaveConnections:         false,               logRawRequests:                false,      logRawValues:                  false,      sessionId:                     '' };    function b3499(a3567, value) {     switch (a3567)     {         case 'debugMode':                     settings.debugMode                     = value;  break;                          case 'enableZoomedOutParams':         settings.d2405         = value;  break;         case 'minZoomForParams':              settings.b2411              = value;  break;         case 'objectCenterSize':              settings.objectCenterSize              = value;  break;         case 'objectBatchSize':               settings.objectBatchSize               = value;  break;         case 'maxSolveIterations':            settings.maxSolveIterations            = value;  break;         case 'numberVarNullValue':            settings.numberVarNullValue            = value;  break;         case 'boolVarNullValue':              settings.boolVarNullValue              = value;  break;         case 'stringVarNullValue':            settings.stringVarNullValue            = value;  break;         case 'colorVarNullValue':             settings.colorVarNullValue             = value;  break;         case 'showPages':                     settings.showPages                     = value;  break;         case 'showAllColorSpaces':            settings.showAllColorSpaces            = value;  break;         case 'showGrid':                      settings.showGrid                      = value;  break;         case 'showNodeIcons':                 settings.showNodeIcons                 = value;  break;         case 'showBoolValues':                settings.showBoolValues                = value;  break;         case 'separateThousands':             settings.separateThousands             = value;  break;         case 'allowInvertParams':             settings.allowInvertParams             = value;  break;         case 'activateDeactiatesOthers':      settings.activateDeactiatesOthers      = value;  break;         case 'preferHtmlColorNames':          settings.preferHtmlColorNames          = value;  break;         case 'randomShiftR':                  settings.randomShiftR                  = value;  break;         case 'colorShiftR':                   settings.colorShiftR                   = value;  break;         case 'numberShiftR':                  settings.numberShiftR                  = value;  break;                  case 'showSnapshots':                 settings.showSnapshots                 = value;  break;         case 'showRestartInfo':               settings.showRestartInfo               = value;  break;         case 'showColorLegendInMenus':        settings.showColorLegendInMenus        = value;  break;         case 'showClearUndoWarning':          settings.showClearUndoWarning          = value;  break;         case 'shareUsageMetrics':             settings.shareUsageMetrics             = value;  break;         case 'showObjectCount':               settings.showObjectCount               = value;  break;         case 'showDebugMenu':                 settings.showDebugMenu                 = value;  break;                                  case 'showNodeId':                    settings.showNodeId                    = value;  break;         case 'showTransformPoints':           settings.x2412           = value;  break;         case 'enableAsserts':                 settings.enableAsserts                 = value;  break;          case 'showTooltipNodes':              settings.showTooltipNodes              = value;  break;         case 'showTooltipParams':             settings.showTooltipParams             = value;  break;         case 'showTooltipLists':              settings.showTooltipLists              = value;  break;         case 'showTooltipLongText':           settings.showTooltipLongText           = value;  break;         case 'showTooltipColorInterpolation': settings.showTooltipColorInterpolation = value;  break;         case 'showTooltipValidateMethod':     settings.showTooltipValidateMethod     = value;  break;         case 'showTooltipColorBlindness':     settings.showTooltipColorBlindness     = value;  break;         case 'showTooltipColorContrast':      settings.showTooltipColorContrast      = value;  break;         case 'showTooltipColorNames':         settings.showTooltipColorNames         = value;  break;         case 'showTooltipAscii':              settings.showTooltipAscii              = value;  break;          case 'enableBetaFeatures':            settings.enableBetaFeatures            = value;  break;                             case 'logThreadMessages':             settings.logThreadMessages             = value;  break;         case 'logDataMessages':               settings.logDataMessages               = value;  break;         case 'logMessages':                   settings.logMessages                   = value;  break;          case 'logActions':                    settings.logActions                    = value;  break;         case 'logLoading':                    settings.logLoading                    = value;  break;         case 'logRequests':                   settings.logRequests                   = value;  break;         case 'logValueUpdates':               settings.logValueUpdates               = value;  break;         case 'logObjectUpdates':              settings.logObjectUpdates              = value;  break;         case 'logStyleUpdates':               settings.logStyleUpdates               = value;  break;                             case 'logRawLoadPages':               settings.logRawLoadPages               = value;  break;         case 'logRawLoadNodes':               settings.logRawLoadNodes               = value;  break;         case 'logRawLoadConnections':         settings.logRawLoadConnections         = value;  break;                          case 'logRawSavePages':               settings.logRawSavePages               = value;  break;         case 'logRawSaveNodes':               settings.logRawSaveNodes               = value;  break;         case 'logRawSaveConnections':         settings.logRawSaveConnections         = value;  break;                          case 'logRawRequests':                settings.logRawRequests                = value;  break;         case 'logRawValues':                  settings.logRawValues                  = value;  break;          case 'sessionId':                     settings.sessionId                     = value;  break;     }        switch (a3567)     {         case 'objectCenterSize':             f2296(             {                 cmd:             'figUpdateObjectCenterSize',                 objectCenterSize: settings.objectCenterSize             });             break;     } }    function r3424(a3567, valid, value, save = true) {     switch (a3567)     {         case 'debugMode':                     a3566(valid, a3567, value, d718                    ); break;                        case 'enableZoomedOutParams':         a3566(valid, a3567, value, g644        ); break;         case 'showPages':                     a3566(valid, a3567, value, h649                    ); break;         case 'showAllColorSpaces':            a3566(valid, a3567, value, e651           ); break;         case 'showGrid':                      a3566(valid, a3567, value, menuItemShowGrid                     ); break;         case 'showNodeIcons':                 a3566(valid, a3567, value, f652                ); break;         case 'showBoolValues':                a3566(valid, a3567, value, e654               ); break;         case 'separateThousands':             a3566(valid, a3567, value, a655            ); break;         case 'allowInvertParams':             a3566(valid, a3567, value, p656            ); break;         case 'activateDeactiatesOthers':      a3566(valid, a3567, value, menuItemActivateDeactiatesOthers     ); break;         case 'preferHtmlColorNames':          a3566(valid, a3567, value, menuItemPreferHtmlColorNames         ); break;         case 'randomShiftR':                  a3566(valid, a3567, value, menuItemRandomShiftR                 ); break;         case 'colorShiftR':                   a3566(valid, a3567, value, menuItemColorShiftR                  ); break;         case 'numberShiftR':                  a3566(valid, a3567, value, menuItemNumberShiftR                 ); break;          case 'showSnapshots':                 a3566(valid, a3567, value, menuItemShowSnapshots                ); break;         case 'showRestartInfo':               a3566(valid, a3567, value, menuItemShowRestartInfo              ); break;         case 'showColorLegendInMenus':        a3566(valid, a3567, value, o653       ); break;         case 'showClearUndoWarning':          a3566(valid, a3567, value, q657         ); break;         case 'shareUsageMetrics':             a3566(valid, a3567, value, r658            ); break;         case 'showObjectCount':               a3566(valid, a3567, value, u660              ); break;         case 'showDebugMenu':                 a3566(valid, a3567, value, l661                ); break;                                case 'showNodeId':                    a3566(valid, a3567, value, b664                   ); break;         case 'showTransformPoints':           a3566(valid, a3567, value, d665          ); break;         case 'enableAsserts':                 a3566(valid, a3567, value, u666                ); enableAsserts = value; break;                  case 'showTooltipNodes':              a3566(valid, a3567, value, menuItemShowTooltipNodes             ); break;         case 'showTooltipParams':             a3566(valid, a3567, value, menuItemShowTooltipParams            ); break;         case 'showTooltipLists':              a3566(valid, a3567, value, m639             ); break;         case 'showTooltipLongText':           a3566(valid, a3567, value, o638          ); break;         case 'showTooltipColorInterpolation': a3566(valid, a3567, value, b640); break;         case 'showTooltipValidateMethod':     a3566(valid, a3567, value, menuItemShowTooltipValidateMethod    ); break;         case 'showTooltipColorBlindness':     a3566(valid, a3567, value, b643    ); break;         case 'showTooltipColorContrast':      a3566(valid, a3567, value, t641     ); break;         case 'showTooltipColorNames':         a3566(valid, a3567, value, k642        ); break;         case 'showTooltipAscii':              a3566(valid, a3567, value, b643    ); break;          case 'enableBetaFeatures':            a3566(valid, a3567, value, menuItemEnableBetaFeatures           ); break;                                case 'logThreadMessages':             a3566(valid, a3567, value, y719            ); break;         case 'logDataMessages':               a3566(valid, a3567, value, x720              ); break;         case 'logMessages':                   a3566(valid, a3567, value, y721                  ); break;          case 'logActions':                    a3566(valid, a3567, value, o722                   ); break;         case 'logLoading':                    a3566(valid, a3567, value, n723                   ); break;         case 'logRequests':                   a3566(valid, a3567, value, o724                  ); break;         case 'logValueUpdates':               a3566(valid, a3567, value, c725              ); break;         case 'logObjectUpdates':              a3566(valid, a3567, value, j726             ); break;         case 'logStyleUpdates':               a3566(valid, a3567, value, c727              ); break;                                case 'logRawLoadPages':               a3566(valid, a3567, value, k728              ); break;         case 'logRawLoadNodes':               a3566(valid, a3567, value, g729              ); break;         case 'logRawLoadConnections':         a3566(valid, a3567, value, s730        ); break;                                case 'logRawSavePages':               a3566(valid, a3567, value, y731              ); break;         case 'logRawSaveNodes':               a3566(valid, a3567, value, a732              ); break;         case 'logRawSaveConnections':         a3566(valid, a3567, value, u733        ); break;                                case 'logRawRequests':                a3566(valid, a3567, value, w734               ); break;         case 'logRawValues':                  a3566(valid, a3567, value, i735                 ); break;     }        if (save)                  x2425(a3567, o935(value)); }    function a3566(valid, setting, value, menu) {     if (valid)          settings[setting] = value;         switch (setting)     {         case 'showNodeId':             f2296(             {                 cmd:    'figUpdateShowIds',                 i2710: settings.showNodeId             });             break;     }       if (menu)         menu.g2780(settings[setting]); }    function updateSettingsMenus() {     d718                    .e326(settings.debugMode                    );                      g644        .g2780(settings.d2405        );     h649                    .g2780(settings.showPages                    );     e651           .g2780(settings.showAllColorSpaces           );     menuItemShowGrid                     .g2780(settings.showGrid                     );     f652                .g2780(settings.showNodeIcons                );     e654               .g2780(settings.showBoolValues               );     a655            .g2780(settings.separateThousands            );     p656            .g2780(settings.allowInvertParams            );     menuItemActivateDeactiatesOthers     .g2780(settings.activateDeactiatesOthers     );     menuItemPreferHtmlColorNames         .g2780(settings.preferHtmlColorNames         );     menuItemRandomShiftR                 .g2780(settings.randomShiftR                 );     menuItemColorShiftR                  .g2780(settings. colorShiftR                 );     menuItemNumberShiftR                 .g2780(settings.numberShiftR                 );      menuItemShowSnapshots                .g2780(settings.showSnapshots                );     menuItemShowRestartInfo              .g2780(settings.showRestartInfo              );     o653       .g2780(settings.showColorLegendInMenus       );     q657         .g2780(settings.showClearUndoWarning         );     r658            .g2780(settings.shareUsageMetrics            );     u660              .g2780(settings.showObjectCount              );     l661                .g2780(settings.showDebugMenu                );                      b664                   .g2780(settings.showNodeId                   );     d665          .g2780(settings.x2412          );     u666                .g2780(settings.enableAsserts                );      menuItemShowTooltipNodes             .g2780(settings.showTooltipNodes             );     menuItemShowTooltipParams            .g2780(settings.showTooltipParam             );     m639             .g2780(settings.showTooltipLists             );     o638          .g2780(settings.showTooltipLongText          );     b640.g2780(settings.showTooltipColorInterpolation);     menuItemShowTooltipValidateMethod    .g2780(settings.showTooltipValidateMethod    );     b643    .g2780(settings.showTooltipColorBlindness    );     t641     .g2780(settings.showTooltipColorContrast     );     k642        .g2780(settings.showTooltipColorNames        );     menuItemShowTooltipAscii             .g2780(settings.showTooltipAscii             );                            y719            .g2780(settings.logThreadMessages            );     x720              .g2780(settings.logDataMessages              );     y721                  .g2780(settings.logMessages                  );      o722                   .g2780(settings.logActions                   );                        n723                   .g2780(settings.logLoading                   );     o724                  .g2780(settings.logRequests                  );     c725              .g2780(settings.logValueUpdates              );     j726             .g2780(settings.logObjectUpdates             );     c727              .g2780(settings.logStyleUpdates              );                        g729              .g2780(settings.logRawLoadPages              );     g729              .g2780(settings.logRawLoadNodes              );     s730        .g2780(settings.logRawLoadConnections        );                          y731              .g2780(settings.logRawSaveNodes              );     a732              .g2780(settings.logRawSaveNodes              );     u733        .g2780(settings.logRawSaveConnections        );                      w734               .g2780(settings.logRawRequests               );     i735                 .g2780(settings.logRawValues                 ); }    function updateMenuItemShowPages() {     p2468('showPages', o935(settings.showPages));     graph.p1901();     p186.update(); }    function updateMenuItemShowSnapshots() {     p2468('showSnapshots', o935(settings.showSnapshots));      snapshotBar.style.display = settings.showSnapshots ? 'block' : 'none';      }    function updateMenuItemShowAllColorSpaces() {     p2468('showAllColorSpaces', o935(settings.showAllColorSpaces));      graph.nodes         .filter(n => h1157.includes(n.type))         .forEach(n => n.t2941()); }    function updateMenuItemShowNodeIcons() {     graph.nodes.forEach(n => n.t2941()); }    function updateMenuItemShowBoolValues() {     graph.nodes         .filter(n => n.params.find(p => p.type == e1090) != null)         .forEach(n => n.t2941()); }    function updateMenuItemSeparateThousands() {     graph.nodes         .filter(n => n.params.find(p => p.type == e1090) != null)         .forEach(n => n.t2941()); }    function updateMenuItemAllowInvertParams() {     graph.nodes         .filter(n => n.type == b1112)         .forEach(n => n.t2941()); }    function updateMenuItemShowColorLegendInMenus() {     for (const menu of y571)         menu.items.forEach(i => i.v3361()); }    function enableFeatures(pro) {     enableMenuItem(menuItemUpgrade,            true, pro, false, pro);     enableMenuItem(menuItemSetValueNames,      true, pro);     enableMenuItem(menuItemEnableBetaFeatures, true, pro);     enableMenuItem(menuItemCopyLLMPrompt,      true, pro, true, currentUserIsDev());       enableMenuItem(menuItemShowRestartInfo,    true, pro);     enableMenuItem(menuItemGetValueName,       true, pro);     enableMenuItem(menuItemSetValueName,       true, pro);     enableMenuItem(menuItemGetValueNames,      true, pro);     enableMenuItem(menuItemSetValueNames,      true, pro);     enableMenuItem(menuItemObjectName,         true, pro);     enableMenuItem(menuItemGetParameter,       true, pro);     enableMenuItem(menuItemSetParameter,       true, pro);     enableMenuItem(f686,           true, pro, true);     enableMenuItem(v689,              true, pro);     enableMenuItem(r691,            true, pro, true);     enableMenuItem(i668,         true, pro);     enableMenuItem(menuItemSaveSelected,       true, pro);     enableMenuItem(y692,              true, pro);        enableMenuItem(l700,              true, pro);     enableMenuItem(g3382,          true, pro);     enableMenuItem(menuItemToJson,             true, pro);     enableMenuItem(b702,       true, pro);     enableMenuItem(o705,         true, pro);     enableMenuItem(menuItemColorDifference,    true, pro);     enableMenuItem(u717,            true, pro);     enableMenuItem(menuItemVectorNetwork,      true, pro, true);     enableMenuItem(menuItemVectorVertex,       true, pro, true);     enableMenuItem(menuItemVectorEdge,         true, pro, true);     enableMenuItem(menuItemVectorRegion,       true, pro, true);     enableMenuItem(menuItemVectorNetwork,      true, pro, true);     enableMenuItem(menuItemBooleanSep,         true, pro, true);     enableMenuItem(menuItemBooleanShape,       true, pro, true);     enableMenuItem(menuItemSaveTemplate,       true, pro);       updatePanelButton();       graph.nodes.forEach(n => n.j3402(pro)); }    function updatePanelButton() {     if (o567     ) o567     .div.style.display = !(settings.enableBetaFeatures && subscribed()) ? 'inline-block' : 'none';     if (btnDecoration) btnDecoration.div.style.display =  (settings.enableBetaFeatures && subscribed()) ? 'inline-block' : 'none'; }    function enableMenuItem(menuItem, enable, pro, beta = false, show = true) {     if (!menuItem) return;      menuItem.enabled = enable;     menuItem.pro     = pro;      menuItem.e326(            show          && (               !beta             ||     beta                 && !pro                 &&  settings.enableBetaFeatures));      menuItem.update(); }    function updateMenuItemShowDebugMenu() {     updateElementDisplay(c669.div, settings.showDebugMenu);      b572.update(         i993(b572.div).x + 6,         i993(b572.div).y - 4,         true); }     function updateElementDisplay(menuItem, enable) {     menuItem.style.display = enable ? 'block' : 'none'; }    function loadLocalSettings() {     b2414('debugMode'                    );              b2414('enableZoomedOutParams'        );     b2414('minZoomForParams'             );     b2414('objectCenterSize'             );     b2414('objectBatchSize'              );     b2414('maxSolveIterations'           );     b2414('numberVarNullValue'           );     b2414('boolVarNullValue'             );     b2414('stringVarNullValue'           );     b2414('colorVarNullValue'            );     b2414('showAllColorSpaces'           );     b2414('showGrid'                     );     b2414('showNodeIcons'                );     b2414('showBoolValues'               );     b2414('separateThousands'            );     b2414('allowInvertParams'   );     b2414('activateDeactiatesOthers'     );     b2414('preferHtmlColorNames'         );     b2414('randomShiftR'                 );     b2414('colorShiftR'                  );     b2414('numberShiftR'                 );      b2414('showSnapshots'                );     b2414('showRestartInfo'              );     b2414('showColorLegendInMenus'       );     b2414('showPages'                    );     b2414('showClearUndoWarning'         );     b2414('shareUsageMetrics'            );     b2414('showObjectCount'              );     b2414('showDebugMenu'                );              b2414('showNodeId'                   );     b2414('showTransformPoints'          );     b2414('enableAsserts'                );      b2414('showTooltipNodes'             );     b2414('showTooltipParams'            );     b2414('showTooltipLists'             );     b2414('showTooltipLongText'          );     b2414('showTooltipColorInterpolation');     b2414('showTooltipValidateMethod'    );     b2414('showTooltipColorBlindness'    );     b2414('showTooltipColorContrast'     );     b2414('showTooltipColorNames'        );     b2414('showTooltipAscii'             );      b2414('enableBetaFeatures'           );                  b2414('logThreadMessages'            );     b2414('logDataMessages'              );     b2414('logMessages'                  );      b2414('logActions'                   );                  b2414('logLoading'                   );     b2414('logRequests'                  );     b2414('logValueUpdates'              );     b2414('logObjectUpdates'             );     b2414('logStyleUpdates'              );                  b2414('logRawLoadPages'              );     b2414('logRawLoadNodes'              );     b2414('logRawLoadConnections'        );              b2414('logRawSavePages'              );     b2414('logRawSaveNodes'              );     b2414('logRawSaveConnections'        );              b2414('logRawRequests'               );     b2414('logRawValues'                 ); }


const q1054              = 'LIST#';  const z1055       = 'NLIST#'; const   g1056       = 'TLIST#'; const  x1057       = 'SLIST#'; const  COLOR_LIST_VALUE       = 'CLIST#'; const  FILL_LIST_VALUE        = 'FLIST#'; const  COLOR_STOP_LIST_VALUE  = 'CSLIST#';   const a1058               = 'NULL'; const d1060          = 'VARGRP'; const n1061                = 'FEEDBK'; const x1062                  = 'REPT'; const ADVANCE                 = 'ADVNC'; const m1063                   = 'CACHE'; const u1064                  = 'FRZ'; const x1065                   = 'TIMER'; const q1066          = 'GVNAME'; const k1067          = 'SVNAME'; const y1332    = 'GVNAMES'; const c1333    = 'SVNAMES'; const a1334         = 'SONAME';   const n1059                = 'VAR'; const VARIABLE_VALUE          = 'VAR#'; const VARIABLE_TYPES          = [VARIABLE_VALUE, n1059];   const l1068                    = 'LIST'; const f1069            = 'LSASIT'; const c1070                 = 'EXTR'; const g1071               = 'SETP'; const g1072               = 'GETP'; const b1073                 = 'SUBLST'; const q1074                  = 'UNIQ'; const c1329            = 'RORD'; const c1330              = 'SHFTLST'; const c1075            = 'REVLST'; const x1331             = 'BUKLST'; const d1076                    = 'SORT'; const l1077                  = 'CLMN'; const w1078                    = 'CELL'; const u1079                   = 'ITEMS'; const j1080              = 'COUNT'; const OBJECT_COUNT            = 'OBJCOUNT'; const o1081           = 'LCONT'; const LIST_FIND               = 'LFIND'; const s1082                  = 'SELECT'; const i1340        = 'LSTSEL'; const o1083                 = 'IF'; const d1084                  = 'LSTFLT';   const r1086               = 'ANY#';   const t1087 = [     q1054,     z1055,     g1056,     x1057,     COLOR_LIST_VALUE,     FILL_LIST_VALUE,     COLOR_STOP_LIST_VALUE,     l1068,     c1070,     g1071,     g1072,     b1073,     u1079,     j1080,     o1081,     LIST_FIND,     x1062,     ADVANCE ];   const d1088 = [                 q1054,          z1055,            g1056,           x1057,           COLOR_LIST_VALUE,            FILL_LIST_VALUE,      COLOR_STOP_LIST_VALUE ];   const j1085                 = 'ITER';   const z1107             = 'PROB';   const HOLD                    = 'HOLD';   const BOOLEAN_NUMBER          = 'BOOL';  const e1090            = 'NUM#';   const b1091                  = 'NUM';    const BOUNDED_NUMBER          = 'BNDNUM';    const e1335        = 'NPREC';    const h1092             = 'NSIGN';    const w1093         = 'ABS';    const p1336         = 'NEG';    const x1094            = 'ROUND';    const v1337         = 'QUANT';    const k1095    = 'SMINMAX';    const d1096           = 'MINMAX';    const l1097           = 'LIM';    const l1098            = 'NCURVE';    const u1338              = 'NMAP';    const d1339             = 'NBIAS';    const z1099           = 'ISNAN'; const d1100         = 'CONST';   const k1101         = 'DATE';   const y1102         = 'SEQ';   const n1103            = 'RANGE';   const i1104             = 'WAVE';   const z1105           = 'RAND';   const h1106            = 'NOISE';   const b1108       = 'ACCUM';   const n1109      = 'LERP';  const v1110            = 'SOLVE'; const v1111          = 'NANIM';  const b1112      = 'SMATH';   const f1113             = 'MATH';    const e1114          = 'NBOOL';    const o1115          = 'CMP';  const v1116             = 'TRIG';   const i1117            = 'ATAN2';  const i1118           = 'CNVANG';   const q1123              = 'TEXT#'; const b1124                    = 'TEXT'; const b1125             = 'TLEN'; const y1126               = 'TTRIM'; const k1127          = 'TSUB'; const e1128           = 'TCONT'; const TEXT_FIND               = 'TFIND'; const g1129               = 'TCASE'; const y1130            = 'TREPL'; const TEXT_ADD                = 'TADD'; const s1131               = 'TJOIN'; const a1132                = 'TPAD'; const x1133            = 'TCMP'; const r1134               = 'TCHAR'; const z1135            = 'TUNI'; const TEXT_ESCAPE             = 'TESC'; const TEXT_UNESCAPE           = 'TUNESC'; const q1136           = 'INDEX'; const e1137          = 'N2T'; const BOOLEAN_TO_TEXT         = 'B2T'; const g1138           = 'C2T'; const COLOR_TO_CSS            = 'C2CSS'; const e1139          = 'T2N'; const TEXT_TO_BOOLEAN         = 'T2B'; const c1140           = 'T2C'; const s1141              = 'TSPLT'; const s3412              = 'PRJSON'; const p1143               = 'PRCSV'; const z1144              = 'FETCH'; const i1145               = 'TFILE'; const TO_JSON                 = 'TOJSON';   const s1148             = 'COL#';   const j1149                   = 'COL';    const o1150             = 'CVAL';   const u1151           = 'CCOR';   const c1152          = 'CCNT';   const a1153        = 'CDLTE';   const t1154              = 'BLND';   const COLOR_SCHEME            = 'CPAL';  const g1155       = 'CLERP';  const c1156             = 'CBLND';   const m1158              = 'FILL#'; const h1159                    = 'FILL'; const a1160              = [m1158, h1159];  const x1161            = 'STRK#'; const u1162                  = 'STRK'; const v1163            = [x1161, u1162];  const x1170      = 'STRKSD#'; const q1171            = 'STRKSD'; const c1172      = [x1170, q1171];  const o1164        = 'CSTOP#'; const c1165              = 'CSTOP'; const v1166        = [o1164, c1165];  const d1167          = 'GRAD#'; const o1168                = 'GRAD'; const e1169          = [d1167, o1168];   const d1173     = 'RCRN#'; const i1174           = 'RCRN'; const m1175     = [d1173, i1174];  const f1176       = 'DRSH#'; const s1177             = 'DRSH'; const q1178       = [f1176, s1177];  const s1179      = 'INSH#'; const b1180            = 'INSH'; const w1181      = [s1179, b1180];  const r1182        = 'LBLR#'; const v1183              = 'LBLR'; const r1184        = [r1182, v1183];  const e1185         = 'BBLR#'; const q1186               = 'BBLR'; const z1187         = [e1185, q1186];  const d1188        = 'MASK#'; const l1189              = 'MASK'; const w1190        = [d1188, l1189];  const i1191       = 'BLEND#'; const s1192             = 'BLEND'; const y1193       = [i1191, s1192];   const x1196             = 'CSTL';   const w1197             = 'SHP#';   const a1198         = 'RECT#'; const x1199               = 'RECT';   const n1200         = [a1198, x1199];  const w1201              = 'LINE#'; const n1202                    = 'LINE';  const n1203              = [w1201, n1202];  const l1204           = 'ELPS#'; const y1205                 = 'ELPS';  const s1206           = [l1204, y1205];  const y1207           = 'TRPZ#'; const s1208                 = 'TRPZ'; const h1209           = [y1207, s1208];  const f1216           = 'POLY#'; const z1217                 = 'POLY';  const d1218           = [f1216, z1217];  const k1219              = 'STAR#'; const m1220                    = 'STAR';  const w1221              = [k1219, m1220];  const z1222        = 'TXTS#'; const d1223              = 'TXTS';  const h1224        = [z1222, d1223];  const p1225             = 'PT#'; const y1226                   = 'PT'; const d1227             = [p1225, y1226];  const z1228            = 'PCORN';  const c1229       = 'VPATH#'; const o1230             = 'VPATH';  const i1231       = [c1229, o1230];  const r1232     = 'VPT#'; const t1233           = 'VPT';  const f1234     = [r1232, t1233];  const e1235       = 'VEDGE#'; const i1236             = 'VEDGE';  const e1237       = [e1235, i1236];  const k1238     = 'VREG#'; const t1239           = 'VREG';  const l1240     = [k1238, t1239];  const r1241    = 'VNET#'; const h1242          = 'VNET';  const w1243    = [r1241, h1242];  const j1244       = 'SGRP#'; const m1245             = 'SGRP'; const r1246       = [j1244, m1245];  const y1247             = 'FRM#'; const s1248                   = 'FRM'; const a1249             = [y1247, s1248];   const k1211          = 'ARC#'; const b1210                = 'ARC'; const r1212          = [k1211, b1210];  const g1214         = 'WAVEP#'; const t1213               = 'WAVEP'; const d1215         = [g1214, t1213];  const a1250                    = 'MOVE'; const x1251                  = 'ROT'; const t1252                   = 'SCALE'; const p1253                    = 'SKEW';  const SHOW_CENTER             = 'SHOWCNTR'; const k1254              = 'SCENTR'; const r1255             = 'RSTX';  const x1256                   = 'PLACE'; const k1257             = 'APPLY';  const PATH_LENGTH             = 'PTHLEN'; const JOIN_PATHS              = 'JOINPTH'; const REORIENT_PATHS          = 'REORPTH'; const s1264        = 'PTALPATH'; const t1265   = 'CPTONPATH'; const g1258          = 'MESPT'; const v1259             = 'PTANGLE'; const z1260                  = 'VECLEN'; const o1261           = 'CIRCEN'; const ARC_FROM_POINTS         = 'ARCPT'; const y1262         = 'INTLIN'; const p1263       = 'PTLERP'; const REVERSE_PATH            = 'REVPTH'; const BLEND_PATH              = 'BLENDPTH';   const s1266           = 'SBOOL'; const x1267     = 'SBOOL#';  const o1268              = 'SBOOLU'; const c1269           = 'SBOOLS'; const u1270          = 'SBOOLI'; const b1271            = 'SBOOLE';   const j1273                  = 'RETAIN'; const EXPORT                  = 'EXPORT';   const t1278              = 'GROUP'; const u1279             = 'GPARAM';   const z1281                 = 'CMNT'; const l1282           = 'CMNTARR'; const z1283                   = 'PANEL';   const c1284                  = 'ACT'; const q1285           = 'BFACT'; const o1286             = 'BFLST'; const c1287                = 'DIS'; const j1288                 = 'NOC';  const PARAM                   = 'PARAM';    const o1289                     = 'LOG';   const g1290                   = 'GRAPH';    const v1089 = [     a1058,     n1059,     d1060,     ...t1087,     f1069,     c1070,     g1071,     g1072,     b1073,     q1074,     c1329,     c1330,     c1075,     l1077,     d1076,     w1078,     u1079,     s1082,     i1340,     o1083,     d1084,     n1061,     x1062,     ADVANCE,     j1085,     z1107,     HOLD,     m1063,     u1064,     s3412,     p1143,     TO_JSON,     x1065,     q1066,     k1067,     y1332,     c1333,     COLOR_SCHEME,     a1153,     g1138,     COLOR_TO_CSS,     j1273 ];   const k1119 = [     f1113,     b1112 ];   const f1120 = [     e1114 ];   const w1121 = [     o1115 ];   const h1122 = [     v1116,     i1117 ];   const a1146 = [     e1090,     z1055,     b1091,     BOUNDED_NUMBER,     BOOLEAN_NUMBER,     e1335,     h1092,     w1093,     p1336,     x1094,     v1337,     k1095,     d1096,     l1097,     l1098,     u1338,     d1339,     z1099,     d1100,     k1101,     y1102,     n1103,     i1104,     z1105,     h1106,     b1108,     n1109,     v1110,     v1111,     e1137,     BOOLEAN_TO_TEXT,     r1134,      ...k1119,     ...f1120,     ...w1121,     ...h1122,      i1118,     x1331 ];   const b1147 = [     q1123,     g1056,     b1124,     b1125,     y1126,     k1127,     e1128,     TEXT_FIND,     g1129,     TEXT_ADD,     s1131,     a1132,     y1130,     x1133,     z1135,     TEXT_ESCAPE,     TEXT_UNESCAPE,     q1136,     e1139,     TEXT_TO_BOOLEAN,     c1140,     s1141,     z1144,     i1145 ];   const h1157 = [     s1148,     j1149,     o1150,     u1151,     t1154,     c1152,     a1153,     g1155,     c1156,     g1138,     COLOR_TO_CSS ];   const COLOR_HEADER_TYPES = [     j1149,     h1159,     u1162,     c1165,     o1168                     ];   const COLOR_VALUES = [     s1148,     m1158,     x1161,     o1164,     d1167 ];   const e1194 = [     ...c1172,     ...m1175,     ...q1178,     ...w1181,     ...r1184,     ...z1187,     ...y1193,     ...w1190 ];   const f1195 = [            s1148,              m1158,          d1167,            x1161,     x1170,      f1176,     s1179,       r1182,        e1185,      i1191,       d1188 ];   const PATH_TYPES = [     o1230,      s1208,     b1210,     t1213 ];  const PATH_VALUES = [     c1229,      y1207,     k1211,     g1214 ];   const p1272 = [     s1266,     x1267,     o1268,     c1269,     u1270,     b1271 ];   const z1274 = [     w1197,     x1057,     a1198,     w1201,     l1204,     y1207,     f1216,     k1219,     z1222,     p1225,     c1229,     r1232,     e1235,     k1238,     r1241,     k1211,     g1214,     j1244,     y1247,     x1267,     f1176,     s1179,     r1182,     e1185,     i1191,     d1188 ];   const v1275 = [     x1251,     t1252,     p1253 ];   const o1276 = [     ...z1274,      ...n1200,     ...n1203,     ...s1206,     ...h1209,     ...d1218,     ...w1221,     ...h1224,     ...d1227,        z1228,     ...i1231,     ...f1234,     ...e1237,     ...l1240,     ...w1243,     ...r1212,     ...d1215,     ...r1246,     ...a1249,     ...p1272,          a1250,     ...v1275,     SHOW_CENTER,     k1254,     r1255,              x1256,     k1257,          PATH_LENGTH,     JOIN_PATHS,     REORIENT_PATHS,     s1264,     t1265,              g1258,     v1259,     z1260,     o1261,     b1210,     t1213,     ARC_FROM_POINTS,     y1262,     p1263,     REVERSE_PATH,     BLEND_PATH,      a1334,      EXPORT ];   const NUMBER_VALUES = [e1090, z1055]; const   TEXT_VALUES = [  q1123,   g1056];   const c1277 = [             q1054,      z1055,        g1056,       x1057,               VARIABLE_VALUE,                    e1090,             q1123,            s1148,               m1158,       o1164,         d1167,           x1161,         o1164,         d1167,              w1197,        a1198,             w1201,          l1204,          y1207,          f1216,             k1219,       z1222,            p1225,      c1229,    r1232,      e1235,    k1238,   r1241,      j1244,            y1247,     d1173,      f1176,     s1179,       r1182,        e1185,       i1191,       d1188 ];   const y1280 = [     t1278,     u1279 ];   const NUMBER_ADD      = '+'; const NUMBER_SUBTRACT = '-'; const NUMBER_MULTIPLY = '*'; const NUMBER_DIVIDE   = '/'; const NUMBER_MODULO   = '%'; const NUMBER_EXPONENT = '^';   const y1291 =  [        [NUMBER_MODULO,   'mod' ],     [NUMBER_DIVIDE,   '/' ],      [NUMBER_SUBTRACT, '−' ],     [NUMBER_ADD,      '+' ],     [NUMBER_MULTIPLY, '×' ],     [NUMBER_EXPONENT, 'e<sup>x']  ];   const x1292 =  [        [NUMBER_DIVIDE,   '/' ],      [NUMBER_SUBTRACT, '−' ],     [NUMBER_ADD,      '+'],     [NUMBER_MULTIPLY, '×'] ];    const o1293 = 0; const t1294 = 1; const w1295  = 2; const s1296 = 3;   const r1297 =  [        [o1293, 'not'],     [t1294, 'xor'],      [w1295,  'or' ],     [s1296, 'and'] ];    const e1298             = 0; const q1299    = 1; const u1300        = 2; const t1301            = 3; const k1302 = 4; const p1303          = 5;   const f1304 =  [        [e1298,             '<'],     [q1299,    '≤'],     [u1300,        '≠'],     [t1301,            '='],     [k1302, '≥'],     [p1303,          '>'] ];    const z1305  = 0; const i1306  = 1; const j1307  = 2; const q1308 = 3; const p1309 = 4; const c1310 = 5;   const u1311 =  [        [z1305,  'sin' ],     [i1306,  'cos' ],     [j1307,  'tan' ],     [q1308, 'asin'],     [p1309, 'acos'],     [c1310, 'atan'] ];    const r1312                = 'EMPTY'; const l1313              = 'CONNECT'; const x1314               = 'CREATE'; const z1315        = 'CREATE_INSERT'; const c1316               = 'DELETE'; const z1317           = 'DISCONNECT'; const m1318           = 'LINK_STYLE'; const b1319        = 'LINK_VARIABLE'; const e1320  = 'LINK_VARIABLE_GROUP'; const q1321          = 'MAKE_ACTIVE'; const MAKE_NOT_CONDITION_ACTION   = 'MAKE_NOT_CONDITION'; const o1322         = 'MAKE_PASSIVE'; const z1323                = 'PASTE'; const v1324            = 'RECONNECT'; const w1325               = 'REMOVE'; const d1326               = 'RENAME'; const b1327       = 'REORDER_INPUTS'; const q1328  = 'REORDER_CONNECTIONS'; const f1341               = 'SELECT'; const l1342          = 'SELECT_MOVE'; const u1343           = 'MOVE_NODES'; const m1344      = 'SET_PARAM_VALUE'; const SET_MULTIPLE_VALUES_ACTION  = 'SET_MULTIPLE_VALUES'; const SET_SHOW_VALUE_NAMES_ACTION = 'SET_SHOW_VALUE_NAMES'; const l1345    = 'SET_PARAM_SETTING'; const g1346        = 'SET_NODE_RECT'; const m1347       = 'TOGGLE_DISABLE'; const r1348  = 'TOGGLE_PARAM_HEADER'; const t1349    = 'SET_CURRENT_GRAPH'; const u1350          = 'CREATE_PAGE'; const t1351          = 'DELETE_PAGE'; const e1352          = 'GROUP_NODES'; const c1353        = 'UNGROUP_NODES'; const m1354      = 'HIGHLIGHT_NODES'; const SCROLL_LIST_NODE_ACTION     = 'SCROLL_LIST_NODE'; const SET_LIST_DIVIDER_ACTION     = 'SET_LIST_DIVIDER'; const SET_NODE_PARAM_ACTION       = 'SET_NODE_PARAM';   const d1355                = 'BNORM'; const f1356                = 'BDARK'; const l1357              = 'BMULT'; const u1358           = 'BPDRK'; const i1359            = 'BBURN'; const v1360               = 'BLITE'; const g1361                = 'BSCRN'; const t1362          = 'BPLGT'; const o1363           = 'BDODG'; const m1364               = 'BOVER'; const e1365            = 'BSOFT'; const w1366            = 'BHARD'; const p1367            = 'BDIFF'; const l1368             = 'BEXCL'; const s1369                   = 'BHUE'; const k1370            = 'BSAT'; const g1371                 = 'BCOL'; const f1372            = 'BLUM';  const BLEND_NORMAL_INDEX          =  0; const BLEND_DARKEN_INDEX          =  1; const BLEND_MULTIPLY_INDEX        =  2; const BLEND_PLUS_DARKER_INDEX     =  3; const BLEND_COLOR_BURN_INDEX      =  4; const BLEND_LIGHTEN_INDEX         =  5; const BLEND_SCREEN_INDEX          =  6; const BLEND_PLUS_LIGHTER_INDEX    =  7; const BLEND_COLOR_DODGE_INDEX     =  8; const BLEND_OVERLAY_INDEX         =  9; const BLEND_SOFT_LIGHT_INDEX      = 10; const BLEND_HARD_LIGHT_INDEX      = 11; const BLEND_DIFFERENCE_INDEX      = 12; const BLEND_EXCLUSION_INDEX       = 13; const BLEND_HUE_INDEX             = 14; const BLEND_SATURATION_INDEX      = 15; const BLEND_COLOR_INDEX           = 16; const BLEND_LUMINOSITY_INDEX      = 17;   const j1373 = [     [d1355,       'normal',       'NORMAL'      ],     [f1356,       'darken',       'DARKEN'      ],     [l1357,     'multiply',     'MULTIPLY'    ],     [u1358,  'plus darker',  'LINEAR_BURN' ],     [i1359,   'color burn',   'COLOR_BURN'  ],     [v1360,      'lighten',      'LIGHTEN'     ],     [g1361,       'screen',       'SCREEN'      ],     [t1362, 'plus lighter', 'LINEAR_DODGE'],     [o1363,  'color dodge',  'COLOR_DODGE' ],     [m1364,      'overlay',      'OVERLAY'     ],     [e1365,   'soft light',   'SOFT_LIGHT'  ],     [w1366,   'hard light',   'HARD_LIGHT'  ],     [p1367,   'difference',   'DIFFERENCE'  ],     [l1368,    'exclusion',    'EXCLUSION'   ],     [s1369,          'hue',          'HUE'         ],     [k1370,   'saturation',   'SATURATION'  ],     [g1371,        'color',        'COLOR'       ],     [f1372,   'luminosity',   'LUMINOSITY'  ] ];    const EllipsePositions = [     'top-left',     'center' ];    const TextAlignX      = ['left', 'center', 'right', 'justify']; const TextAlignY      = ['bottom', 'middle', 'top'];  const PathDegrees     = ['linear', 'quadratic', 'cubic', 'smooth', 'sine X', 'sine Y']; const PathJoinDegrees = ['linear', 'cubic', 'smooth', 'sine X', 'sine Y']; const PathWindings    = ['even-odd', 'non-zero'];  const StrokeAlign     = ['inside', 'center', 'outside']; const StrokeJoin      = ['miter', 'bevel', 'round']; const StrokeCap       = ['none', 'square', 'round'];  const LayerMaskTypes  = ['alpha', 'vector', 'luminance'];  const FramePositions  = ['relative', 'absolute'];   const s1374 = [     ['thin',        100],     ['extra light', 200],     ['light',       300],     ['regular',     400],     ['medium',      500],     ['semi bold',   600],     ['bold',        700],     ['extra bold',  800],     ['black',       900] ];    const y1375           =  0; const e1376        =  1;  const u1377      =  2;   const m1378     = 2; const j1379    =  3;   const p1380   = 3;  const r1381       =  4;   const k1382 = 4; const FO_PERSIST        =  5;   const i1384            =  6; const j1385            =  7; const s1386            =  8;  const w1387          =  9;  const p1388          = 10;   const FO_VARIABLE_TYPE     = 10; const w1389        = 11;   const FO_VARIABLE_COUNT    = 11;  const y1390  = 12;   const FO_VARIABLE_IS_ALIAS = 12; const e1391   = 13; const b1392    = 14;                                     const l1393   = 15; const i1394     = 16; const c1395  = 17;  const m1396        = 18;  const x1397           = 19; const h1398      = 20;     const h1399        = 21; const p1400          = 22; const r1401           = 23;  const a1402              = 24;                                                                         const f1433    = 24;                                                                                              const y1403 = 24; const j1404              = 25;                                                                         const u1434   = 25; const n1405          = 26;    const n1406         = 27;                                      const v1407     = 28;   const j1408   = 28;   const n1409 = 28;   const z1410    = 28;   const l1411   = 28;   const y1412  = 28;   const k1413      = 28;   const s1414    = 28;                                 const e1415   = 29;                                        const w1416 = 29;   const w1417 = 29;   const g1418 = 29;   const c1419     = 29;   const y1435     = 29;                                 const a1421   = 30;                                        const z1422   = 30;                                 const o1423 = 30;   const u1424           = 30;   const m1420 = 30;                                                                                                                                                                   const g1425   = 31;                                                                                                                                        const f1426           = 31;                                                                                                                                                                                                       const u1427      = 32;                                                                                                                                                                                                       const b1428     = 33;                                                                                                                                                                                                                                                                                                                                                                                                                                            const q1429        = 34;                                                                                                                                                                                                       const m1430        = 35;                                                                                                                                                                                                                                                                                                                                                                                                                                            const h1431    = 36;                                                                                                                                                                                                       const m1432 = 37;


class z1656 {     type;          nodeId     = '';       objectId   = NULL;     objectName = NULL;      n3717  = -1;       retain    = 0;     feedback   = false;       showCenter = false;          u4087;      xp0   = null;      xp1   = null;      xp2   = null;       sp0   = null;      sp1   = null;      sp2   = null;       e3637;     scaleStyle;        constructor(type, nodeId, objectId, objectName)     {         this.type         = type;         this.nodeId       = nodeId;         this.objectId     = objectId;         this.objectName   = objectName;          this.u4087        = clone(identity);          this.e3637 = 1;         this.scaleStyle   = 1;     }        m3266(base)     {         this.n3717    = base.n3717;                  this.feedback     = base.feedback;         this.retain      = base.retain;          this.showCenter   = base.showCenter;          this.u4087        = clone(base.u4087);          this.xp0          = clone(base.xp0);         this.xp1          = clone(base.xp1);         this.xp2          = clone(base.xp2);          this.sp0          = clone(base.sp0);         this.sp1          = clone(base.sp1);         this.sp2          = clone(base.sp2);          this.e3637 = base.e3637;         this.scaleStyle   = base.scaleStyle;     }        copy()     {         s951('invalid use of abstract method z1656.copy()');         return null;     }        getCount()     {         return 1;     }        w3639(cx = 0, cy = 0)     {         this.sp0 = point(cx,   cy  );         this.sp1 = point(cx+1, cy  );         this.sp2 = point(cx,   cy+1);     }        resetSpace(bounds, singlePoint = false, cx = 0.5, cy = 0.5, units = 0)     {         let _cx;          let _cy;           if (units == 0)         {             _cx = bounds.x + cx * bounds.width;             _cy = bounds.y + cy * bounds.height;                     }         else if (units == 1)         {             _cx = bounds.x + cx;             _cy = bounds.y + cy;         }         else          {             _cx = cx;             _cy = cy;                     }           const ds1 = j898(this.sp1, this.sp0);         const ds2 = j898(this.sp2, this.sp0);          this.sp0  = point(_cx, _cy);          this.sp1  = y893(this.sp0, ds1);         this.sp2  = y893(this.sp0, ds2);           if (PATH_TYPES.includes(this.type))             this.i3640();     }        m3977(x, y, a = 0)     {         this.u4087 =             [[Math.cos(a), -Math.sin(a), x],              [Math.sin(a),  Math.cos(a), y],              [0,            0,           1]];     }        p3627(x, y, w, h)     {         this.xp0 = point(x,     y    );         this.xp1 = point(x + w, y    );         this.xp2 = point(x,     y + h);     }        g3629()     {         let vr = point(this.sp1.x - this.sp0.x, this.sp1.y - this.sp0.y);         let vb = point(this.sp2.x - this.sp0.x, this.sp2.y - this.sp0.y);                   let sx = vr.x;         let sy = vb.y;              let kx = vr.y;         let ky = vb.x;                  let dx = this.sp0.x;         let dy = this.sp0.y;                   let u4087 = g887(             v891(dx, dy),             [[sx, ky, 0],              [kx, sy, 0],              [0,  0,  1]]);               return u4087;     }                getBounds()     {         let bounds = t1045.NaN;          const dp = j898(this.xp1, this.xp0);          bounds = b3642(bounds, this.xp0);         bounds = b3642(bounds, this.xp1);         bounds = b3642(bounds, this.xp2);         bounds = b3642(bounds, y893(this.xp2, dp));          return bounds;     }        h3978(u4087, affectSpace)     {         const space = this.g3629();           if (this.type == y1226)         {             if (affectSpace > 0)             {                 const p = n3628(point(this.x, this.y), u4087, space);                  this.x = p.x;                 this.y = p.y;             }              if (affectSpace != 1)                 this.applySpaceTransform(u4087, space);         }         else if (PATH_TYPES.includes(this.type))         {             if (affectSpace > 0)             {                 this.applyObjectTransform(u4087, space);                  this.updatePoints(u4087, space);                 this.i3640();             }              if (affectSpace != 1)                 this.applySpaceTransform(u4087, space);         }         else if (this.type == m1245)         {             for (const c111 of this.children)             {                 if (affectSpace > 0)                 {                     c111.applyObjectTransform(u4087, space);                      if (c111.type == o1230)                         c111.updatePoints(u4087, space);                 }                  if (affectSpace != 1)                     c111.applySpaceTransform(u4087, space);             }                         }         else         {             if (affectSpace > 0)                 this.applyObjectTransform(u4087, space);              if (affectSpace != 1)                 this.applySpaceTransform(u4087, space);         }     }        applyObjectTransform(u4087, space)     {         if (   this.xp0.x == this.xp1.x             && this.xp0.y == this.xp1.y)             this.xp1.x += 0.0001;          if (   this.xp0.x == this.xp2.x             && this.xp0.y == this.xp2.y)             this.xp2.y += 0.0001;          this.xp0 = n3628(this.xp0, u4087, space);         this.xp1 = n3628(this.xp1, u4087, space);         this.xp2 = n3628(this.xp2, u4087, space);     }        applySpaceTransform(u4087, space)     {         this.sp0 = n3628(this.sp0, u4087, space);         this.sp1 = n3628(this.sp1, u4087, space);         this.sp2 = n3628(this.sp2, u4087, space);     }        checkFlipped(flipX, flipY)     {         if (flipX)         {             const d1 = j898(this.xp1, this.xp0);              this.xp0 = y893(this.xp0, d1);             this.xp2 = y893(this.xp2, d1);             this.xp1 = j898(this.xp1, d1);         }                   if (flipY)         {             const d2 = j898(this.xp2, this.xp0);              this.xp0 = y893(this.xp0, d2);             this.xp1 = y893(this.xp1, d2);             this.xp2 = j898(this.xp2, d2);         }     }        e3653()     {         return {             type:       this.type,             nodeId:     this.nodeId,              objectId:   this.objectId,                objectName: this.objectName,                           feedback:   this.feedback,              xp0:        this.xp0 ? this.xp0 : null,             xp1:        this.xp1 ? this.xp1 : null,             xp2:        this.xp2 ? this.xp2 : null         };     }        p3638()     {         return [          this.type,          this.nodeId,           this.objectId,          this.objectName,                       this.feedback,          this.retain,                   this.xp0 ? this.xp0 : null,          this.xp1 ? this.xp1 : null,          this.xp2 ? this.xp2 : null,           0          ];     }        toNewValue()     {         return new p4096();     } }    function n3628(p, u4087, space) {     p = s886(p, g889(space));     p = s886(p, u4087);     p = s886(p, space);      return p; }    function g3635(c111) {     switch (c111.type)     {         case x1199:     return m1659 .prototype.copy.call(c111);         case n1202:          return u1655      .prototype.copy.call(c111);         case y1205:       return p1653   .prototype.copy.call(c111);         case s1208:       return b1664   .prototype.copy.call(c111);         case z1217:       return m1658   .prototype.copy.call(c111);         case m1220:          return a1662      .prototype.copy.call(c111);         case d1223:    return y1663      .prototype.copy.call(c111);         case y1226:         return s1657     .prototype.copy.call(c111);         case o1230:   return w1666.prototype.copy.call(c111);         case b1210:      return q2451   .prototype.copy.call(c111);         case t1213:     return s2453  .prototype.copy.call(c111);         case s1266: return e1651   .prototype.copy.call(c111);         case m1245:   return f1661.prototype.copy.call(c111);         case s1248:         return y1654     .prototype.copy.call(c111);     }      s951('invalid Figma object type \'' + c111.type + '\'');     return null; }    function getPointBounds(points) {     let minX = Number.MAX_SAFE_INTEGER;     let minY = Number.MAX_SAFE_INTEGER;     let maxX = Number.MIN_SAFE_INTEGER;     let maxY = Number.MIN_SAFE_INTEGER;      for (const p of points)     {         minX = Math.min(minX, p.x.value);         minY = Math.min(minY, p.y.value);         maxX = Math.max(maxX, p.x.value);         maxY = Math.max(maxY, p.y.value);     }      return new AbsRect(minX, minY, maxX, maxY); }    function getObjBounds(objects) {     let bounds = t1045.NaN;      for (const c111 of objects)         bounds = d3641(bounds, c111.getBounds());      return bounds; }    function q2494(node, c111) {     const sp0 = point(         c111.sp0.x ,          c111.sp0.y );      const sp1 = y893(sp0, y895(      j898(c111.sp1, c111.sp0),      settings.objectCenterSize));     const sp2 = y893(sp0, y895(y895(j898(c111.sp2, c111.sp0), -1), settings.objectCenterSize));          const center = createDecoPoly(         node.nodeId,         c111.objectId,         c111.objectName,          sp0,          [sp2, sp0, sp1],         false,         '',         [242, 72, 34],          e968,         true);      return center; }    function createDecoPoly(nodeId, objectId, objectName, center, points, closed, dashes, color, suffix, isCenter) {     const path = new w1666(         nodeId,         objectId   + suffix,         objectName + suffix,         points.map(p => r1836.fromPoint(objectId, p)),         closed ? 1 : 0,          0,          0,          0);       path.strokes.push([         'SOLID',          color[0],          color[1],          color[2],          100,          'NORMAL']);      path.strokeWeight =  1;     path.strokeAlign  = 'CENTER';     path.strokeJoin   = 'MITER';     path.strokeCap    = 'NONE';     path.strokeDashes =  dashes;     path.p3636       =  true;     path.isCenter     =  isCenter;       path.m3977(center.x, center.y);            return path; }    function w3534(value) {     return value         && value.objects         ? value.objects               .filter(o =>                       o.p3636  === false                   || o.isXform === true)               .map(o => o.copy())          : []; }


function o1636(c111, prop) {          if (prop.type ==         s1148)  y1637       (c111, prop);     else if (prop.type ==          m1158)  q1638        (c111, prop);     else if (prop.type ==      d1167)  y1639    (c111, prop);     else if (prop.type ==        x1161)  v1643      (c111, prop);     else if (prop.type ==  x1170)  addStrokeSidesProp (c111, prop);     else if (prop.type == d1173)  j1644(c111, prop);     else if (prop.type ==   f1176)  n1645  (c111, prop);     else if (prop.type ==  s1179)  u1646 (c111, prop);     else if (prop.type ==    r1182)  l1647   (c111, prop);     else if (prop.type ==     e1185)  x1648    (c111, prop);     else if (prop.type ==   i1191)  y1649  (c111, prop);     else if (prop.type ==    d1188)  s1650        (c111, prop); }    function y1637(c111, prop) {     const rgb = v4021(prop.u3150());      if (c111.type == m1245)     {         for (const _obj of c111.children)             o1636(_obj, prop);     }     else     {         c111.fills.push([             'SOLID',              rgb[0],              rgb[1],              rgb[2],              255 ]);     } }    function q1638(c111, prop, target = c111.fills) {     if (prop.color.type != s1148)         return;       const rgb = v4021(prop.color.u3150());      if (c111.type == m1245)     {         for (const _obj of c111.children)             o1636(_obj, prop);     }     else     {         target.push([             'SOLID',              rgb[0],              rgb[1],              rgb[2],              prop.opacity.toNewValue().value,             j1373[Math.min(Math.max(0, Math.round(prop.blend.value)), j1373.length-1)][2]]);     } }    function y1639(c111, prop, target = c111.fills)                 {     const gradient =      [         '',          [],          [],          '',          0                     ];       switch(prop.k3588.value)     {         case 0: gradient[0] = 'GRADIENT_LINEAR';  break;         case 1: gradient[0] = 'GRADIENT_RADIAL';  break;         case 2: gradient[0] = 'GRADIENT_ANGULAR'; break;         case 3: gradient[0] = 'GRADIENT_DIAMOND'; break;     }           let   x         =        prop.x     .value / 100;     let   y         =        prop.y     .value / 100;     let   s         = nozero(prop.size  .value / 100);     let   a         =        prop.angle .value / 360*Tau;     let   asp       = nozero(prop.aspect.value / 100);     const diag      =        prop.diagAspect;     let   sk        =        prop.skew  .value / 100;           const pos       = prop.position.value;     const isLinear  = prop.k3588.value == 0;     const isAngular = prop.k3588.value == 2;          const bounds    = c111.getBounds();                  if (pos > 0)     {         if (   pos == 1             || pos == 2)         {             x = x / 100 * bounds.width;             y = y / 100 * bounds.height;         }                   x = x * 100 / nozero(bounds.width );         y = y * 100 / nozero(bounds.height);           if (pos == 4)         {             x = x - bounds.x / nozero(bounds.width );             y = y - bounds.y / nozero(bounds.height);                          s *= 100 / nozero(bounds.width);         }     }       let   p0 = point(x, y);     let   p1 = y893(p0, vector(a, diag === true ? s : s * nozero(asp)));     let   p2 = y893(p0, vector(a + Tau/4, s));       const a1 = anglev2(p0, p1);     const a2 = anglev2(p0, p2);      if (diag === true)     {         p1 = y893(p1, vector(a1 - Tau/8, (asp-1) * Math.sqrt(sqr(distv(p0, p1))/2)));         p2 = y893(p2, vector(a2 + Tau/8, (asp-1) * Math.sqrt(sqr(distv(p0, p2))/2)));          p1 = y893(p1, vector(a2 + Tau/8, s * sk * Math.sqrt(2)/2));         p2 = y893(p2, vector(a2 + Tau/8, s * sk * Math.sqrt(2)/2));     }     else     {         p2 = j898(p2, vector(a1, s * sk));     }       if (pos > 0)     {         if (   pos == 1             || pos == 3             || pos == 4)         {             const aspect = bounds.width / nozero(bounds.height);              p1.y = p0.y + (p1.y - p0.y) * aspect;             p2.y = p0.y + (p2.y - p0.y) * aspect;         }         else if (pos == 2)         {             const aspect = bounds.height / nozero(bounds.width);                          p1.x = p0.x + (p1.x - p0.x) * aspect;             p2.x = p0.x + (p2.x - p0.x) * aspect;         }     }       if (!isLinear)     {         const dv = j898(p0, p1);          p0 = y893(p0, dv);         p2 = y893(p2, dv);     }             if (prop.stops.items.some(i =>                 i             && (   i.position.value < 0                  || i.position.value > 100)))     {         let minPos = prop.stops.items.reduce((min, stop) => Math.min(min, stop.position.value), Number.MAX_SAFE_INTEGER);         let maxPos = prop.stops.items.reduce((max, stop) => Math.max(max, stop.position.value), Number.MIN_SAFE_INTEGER);           if (!isLinear)         {             minPos = Math.max(0, minPos);              if (isAngular)                 maxPos = Math.min(maxPos, 1);         }           const dpos  = Math.min(minPos, 0) / 100;         const dsize = Math.max(100, 100 + Math.max(0, maxPos - 100) - Math.min(minPos, 0)) / 100;          const dv    = j898(p0, p1);           p0 = y893(p0, y895(dv, Math.max(0, -dpos)));         p1 = y893(p1, y895(dv, Math.max(0, -dpos)));         p2 = y893(p2, y895(dv, Math.max(0, -dpos)));           if (!isLinear)         {             const dx = y895(dv, (dsize - 1) / 2);              p0 = y893(p0, dx);             p1 = y893(p1, dx);             p2 = y893(p2, dx);         }           if (!isAngular)         {             p1 = j898(p0, y895(dv, dsize));             p2 = y893(p0, y895(j898(p2, p0), dsize));         }           const positions = prop.stops.items.map(s => s.position.value/100);                  const pos0      = minPos/100;         const pos1      = maxPos/100;                   if (positions.some(p => p < 0))         {             for (let i = 0; i < positions.length; i++)                 prop.stops.items[i].position.value = (positions[i] - pos0) / dsize * 100;         }                  if (positions.some(p => p > 1))         {             for (let i = 0; i < positions.length; i++)                 prop.stops.items[i].position.value = (1 - (pos1 - positions[i]) / dsize) * 100;         }                   for (const stop of prop.stops.items)             stop.position.value = Math.min(Math.max(0, stop.position.value), 100);     }       gradient[1] = [p0, p1, p2];           const stops = prop.stops.items;      for (let j = 0; j < stops.length; j++)     {         const stop = stops[j];          if (stop.fill)         {             const rgba = stop.fill.l99();              gradient[2].push([                 rgba[0],                  rgba[1],                  rgba[2],                  rgba[3],                 stop.position.value / 100]);         }     }       gradient[3] = j1373[prop.blend.value][2];           target.push(gradient); }    function m1640(p1641) {     const stops = [];       for (let i = 0; i < p1641.length; i++)     {         const stop = p1641[i];          if (stop.type == s1148)         {             stops.push(new l1822(                 m1826.i3670(v4021(stop.u3150()), 100),                 n1835.NaN()));         }          else if (stop.type == m1158)             stops.push(new l1822(                 stop,                 n1835.NaN()));          else if (stop.type == q1054)             stops.push(...m1640(stop.items));          else             stops.push(stop);     }       return stops; }    function w1642(stops) {     if (    stops.length > 0         && !stops[0].position.isValid())          stops[0].position = new n1835(0);      if (    stops.length > 1         && (!stops.at(-1).position.isValid()))          stops.at(-1).position = new n1835(100);           if (stops.length > 2)     {         for (let i = 1; i < stops.length-1; i++)         {             const stop = stops[i];              if (   !stop                 || !stop.position                 || !stop.position.isValid())             {                 let prevValid = i-1;                 let nextValid = i+1;                  while ( prevValid > 0                     && !stops[prevValid].position.isValid())                      prevValid--;                  while ( nextValid < stops.length-1                     && !stops[nextValid].position.isValid())                      nextValid++;                                          const pv = stops[prevValid].position.value;                 const nv = stops[nextValid].position.value;                  stop.position = new n1835((pv + (nv - pv) * ((i - prevValid) / (nextValid - prevValid))));              }         }     } }    function v1643(c111, prop) {     for (const fill of prop.fills.items)     {         if (fill.type ==     m1158) q1638    (c111, fill, c111.strokes);         if (fill.type == d1167) y1639(c111, fill, c111.strokes);     }       if (c111.type == m1245)     {         for (const _obj of c111.children)             o1636(_obj, prop);     }     else     {         c111.strokeWeight = prop.weight.toNewValue().value;          switch (prop.fit.toNewValue().value)         {             case 0: c111.strokeAlign = 'INSIDE';  break;             case 1: c111.strokeAlign = 'CENTER';  break;             case 2: c111.strokeAlign = 'OUTSIDE'; break;         }          switch (prop.join.toNewValue().value)         {             case 0: c111.strokeJoin = 'MITER'; break;             case 1: c111.strokeJoin = 'BEVEL'; break;             case 2: c111.strokeJoin = 'ROUND'; break;         }          switch (prop.cap.toNewValue().value)         {             case 0: c111.strokeCap = 'NONE';   break;             case 1: c111.strokeCap = 'SQUARE'; break;             case 2: c111.strokeCap = 'ROUND';  break;         }          c111.strokeDashes     = prop.dashes.toNewValue().value.trim();                  c111.strokeMiterLimit = prop.miter .toNewValue().value;     } }    function addStrokeSidesProp(c111, prop) {     if (c111.type == m1245)     {         for (const _obj of c111.children)             o1636(_obj, prop);     }     else     {         c111.effects.push([            'STROKE_SIDES',              prop.top   .value,             prop.left  .value,             prop.right .value,             prop.bottom.value,             prop.visible ]);     } }    function j1644(c111, prop) {     if (c111.type == m1245)     {         for (const _obj of c111.children)             o1636(_obj, prop);     }     else     {         c111.effects.push([            'ROUND_CORNERS',              prop.tl.value,             prop.tr.value,             prop.bl.value,             prop.br.value,             prop.visible ]);     } }    function n1645(c111, prop) {     const rgba = prop.fill.l99();      c111.effects.push([         'DROP_SHADOW',          rgba[0],         rgba[1],         rgba[2],         rgba[3],         prop.x     .value,          prop.y     .value,          prop.blur  .value,          prop.spread.value,          j1373[prop.blend.value][2],         prop.behind.value > 0,         prop.visible ]); }    function u1646(c111, prop) {     const rgba = prop.fill.l99();      c111.effects.push([         'INNER_SHADOW',          rgba[0],         rgba[1],         rgba[2],         rgba[3],         prop.x     .value,          prop.y     .value,          prop.blur  .value,          prop.spread.value,          j1373[prop.blend.value][2],         prop.visible ]); }    function l1647(c111, prop) {     c111.effects.push([         'LAYER_BLUR',          prop.radius.value,          prop.visible ]); }    function x1648(c111, prop) {     c111.effects.push([         'BACKGROUND_BLUR',          prop.radius.value,          prop.visible ]); }    function y1649(c111, prop) {     c111.opacity = Math.min(Math.max(0, prop.opacity.value  / 100), 1);     c111.blend   = j1373[prop.blend.value][2]; }    function s1650(c111, mask) {     c111.maskType = mask.maskType.value + 1; } 


class c1660 extends z1656 {     skewX;     skewY;      fills   = [];     strokes = [];      strokeWeight;     strokeAlign;     strokeJoin;     strokeMiterLimit;     strokeCap;     strokeDashes;      effects = [];      p3636;     isCenter;     isXform;      opacity;     blend;      maskType = 0;        constructor(type, nodeId, objectId, objectName, p3636 = false, isXform = false)     {         super(type, nodeId, objectId, objectName);          this.skewX    = 0;         this.skewY    = 0;          this.p3636   = p3636;         this.isCenter = false;         this.isXform  = isXform;          this.opacity  = 1;         this.blend    = 'PASS_THROUGH';     }        m3266(base)     {         super.m3266(base);          this.skewX            = base.skewX;         this.skewY            = base.skewY;          this.fills            = clone(base.fills);         this.strokes          = clone(base.strokes);          this.strokeWeight     = base.strokeWeight;         this.strokeAlign      = base.strokeAlign;         this.strokeJoin       = base.strokeJoin;         this.strokeMiterLimit = base.strokeMiterLimit;         this.strokeCap        = base.strokeCap;         this.strokeDashes     = base.strokeDashes;          this.effects          = clone(base.effects);          this.p3636           = base.p3636;         this.isCenter         = base.isCenter;         this.isXform          = base.isXform;          this.opacity          = base.opacity;         this.blend            = base.blend;         this.maskType         = base.maskType;     }        checkFlipped(flipX, flipY)     {         super.checkFlipped(flipX, flipY);          for (const fill   of this.fills  ) flipGradient(fill,   flipX, flipY);         for (const stroke of this.strokes) flipGradient(stroke, flipX, flipY);          const foundSides = this.effects.findIndex(e => e[0] == 'STROKE_SIDES');         if (foundSides > -1) flipStrokeSides(this.effects[foundSides], flipX, flipX);          const foundCorners = this.effects.findIndex(e => e[0] == 'ROUND_CORNERS');         if (foundCorners > -1) flipRoundCorners(this.effects[foundCorners], flipX, flipY);     }        p3638()     {         const weight = this.strokeWeight * Math.abs(this.scaleStyle);          const dashes =              this.strokeDashes             ? this.strokeDashes                 .split(',')                 .map(d => parseFloat(d.trim()) * Math.abs(this.scaleStyle))                 .join(',')             : '';                   return [             ...super.p3638(),                  this.fills,              this.strokes,               weight,              this.strokeAlign,              this.strokeJoin,              this.strokeMiterLimit,              this.strokeCap,              dashes,               this.effects,               this.p3636,              this.isCenter,               this.opacity,              this.blend,              this.maskType         ];     } }    function flipGradient(fill, flipX, flipY) {     if (   fill[0] == 'GRADIENT_LINEAR'         || fill[0] == 'GRADIENT_RADIAL'         || fill[0] == 'GRADIENT_ANGULAR'         || fill[0] == 'GRADIENT_DIAMOND')     {         const p0 = fill[1][0];         const p1 = fill[1][1];         const p2 = fill[1][2];          if (flipX)         {             p0.x = 1 - p0.x;             p1.x = 1 - p1.x;             p2.x = 1 - p2.x;         }          if (flipY)         {             p0.y = 1 - p0.y;             p1.y = 1 - p1.y;             p2.y = 1 - p2.y;         }     } }    function flipStrokeSides(sides, flipX, flipY) {     if (flipX) [sides[2], sides[3]] = [sides[3], sides[2]];     if (flipY) [sides[1], sides[4]] = [sides[4], sides[1]]; }    function flipRoundCorners(corners, flipX, flipY) {     if (flipX)     {         [corners[1], corners[2]] = [corners[2], corners[1]];         [corners[3], corners[4]] = [corners[4], corners[3]];     }      if (flipY)     {         [corners[1], corners[3]] = [corners[3], corners[1]];         [corners[2], corners[4]] = [corners[4], corners[2]];     } }


class m1659 extends c1660 {     x;     y;     width;     height;      round;            constructor(nodeId, objectId, objectName, x, y, width, height, round)     {         super(x1199, nodeId, objectId, objectName);                  this.x      = x;         this.y      = y;         this.width  = width;         this.height = height;          this.round  = round;          this.w3639(             x + width /2,              y + height/2);     }        copy()     {         const copy = new m1659(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.width,             this.height,                          this.round);           copy.m3266(this);           return copy;     }        toNewValue()     {         return d1838.fromObject(this);     }        p3638()     {         return [             ...super.p3638(),                  this.x,              this.y,              this.width,              this.height,               this.round * Math.abs(this.e3637)         ];     } } 


class u1655 extends c1660 {     x;     y;     width;        constructor(nodeId, objectId, objectName, x, y, width)     {         super(n1202, nodeId, objectId, objectName);                  this.x     = x;         this.y     = y;         this.width = width;                   this.w3639(             x + width/2,              y);     }        copy()     {         const copy = new u1655(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.width);           copy.m3266(this);           return copy;     }        toNewValue()     {         return m1833.fromObject(this);     }        p3638()     {         return [             ...super.p3638(),                  this.x,              this.y,              this.width         ];     } }


class p1653 extends c1660 {     x;     y;     width;     height;     round;      start;     sweep;     inner;            constructor(nodeId, objectId, objectName, x, y, width, height, round, start, sweep, inner)     {         super(y1205, nodeId, objectId, objectName);                  this.x      = x;         this.y      = y;         this.width  = width;         this.height = height;         this.round  = round;          this.start  = start;         this.sweep  = sweep;         this.inner  = inner;                   this.w3639(             x + width /2,              y + height/2);     }        copy()     {         const copy = new p1653(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.width,             this.height,             this.round,                          this.start,             this.sweep,             this.inner);           copy.m3266(this);           return copy;     }        toNewValue()     {         return v1825.fromObject(this);     }        p3638()     {         return [             ...super.p3638(),                  this.x,              this.y,              this.width,              this.height,              this.round,               this.start,              this.sweep,              this.inner         ];     } }


class w1666 extends c1660 {     x;     y;     width;     height;          points;      closed;     degree;     winding;       round;          z3643;     b3913;        constructor(nodeId, objectId, objectName, points, closed, degree, winding, round)     {         super(o1230, nodeId, objectId, objectName);                           this.points  = points.map(p => p.copy());             this.closed  = closed;         this.degree  = degree;         this.winding = winding;          this.round   = round;                   this.i3640();     }        copy()     {         const copy = new w1666(             this.nodeId,             this.objectId,             this.objectName,              this.points,              this.closed,             this.degree,             this.winding,              this.round);           copy.x          = this.x;         copy.y          = this.y;         copy.width      = this.width;         copy.height     = this.height;          copy.z3643 = [...this.z3643];         copy.b3913   = this.b3913;           copy.m3266(this);           return copy;     }        m3266(base)     {         super.m3266(base);          if (base.points) this.points = base.points.map(p => p.copy());     }        getBounds()     {         let bounds = t1045.NaN;           switch (this.degree)         {             case 0:                 for (const p of this.z3643)                     bounds = b3642(bounds, p);                  break;              case 1:                 {                     let i;                     for (i = 0; i < this.z3643.length-2; i += 2)                     {                         bounds = d3641(                             bounds,                              r861(                                 this.z3643[i  ],                                  this.z3643[i+1],                                 this.z3643[i+2]));                     }                      if (   this.closed                         && i < this.z3643.length-1)                     {                         bounds = d3641(                             bounds,                              r861(                                 this.z3643.at(-2),                                  this.z3643.at(-1),                                 this.z3643.at( 0)));                     }                      break;                 }             case 2:             case 3:             case 4:             case 5:                 {                     let i;                     for (i = 0; i < this.z3643.length-3; i += 3)                     {                         const b3 = b862(                             this.z3643[i  ],                              this.z3643[i+1],                             this.z3643[i+2],                             this.z3643[i+3]);                          bounds = d3641(                             bounds,                              b3);                     }                      if (   this.closed                         && i < this.z3643.length - 2)                     {                         const b3 = b862(                             this.z3643.at(-3),                              this.z3643.at(-2),                              this.z3643.at(-1),                             this.z3643.at( 0));                          bounds = d3641(                             bounds,                              b3);                     }                      break;                 }             default:                 console.error('invalid curve degree');         }           return bounds;     }        updatePoints(u4087, space)     {         for (let i = 0; i < this.points.length; i++)         {             let p      = this.points[i].n3644();             let smooth = this.points[i].smooth;              p = n3628(p, u4087, space);              this.points[i]        = r1836.fromPoint(this.nodeId, p);             this.points[i].smooth = smooth;         }     }        i3640()     {         switch (this.degree)         {         case 0: this.z3643 = this.points.map(p => p.n3644());                           break;         case 1: this.z3643 = this.points.map(p => p.n3644());                           break;         case 2: this.z3643 = this.points.map(p => p.n3644());                           break;         case 3: this.z3643 = w3650(this.points, this.closed, u4123); break;         case 4: this.z3643 = w3650(this.points, this.closed, w4124 ); break;         case 5: this.z3643 = w3650(this.points, this.closed, t4125 ); break;         }     }        a3646()     {         if (   this.type == o1230             || this.type == s1208)         {             const bounds = this.getBounds();              this.x      = bounds.x;             this.y      = bounds.y;             this.width  = bounds.width;             this.height = bounds.height;              this.p3627(this.x, this.y, this.width, this.height);         }          this.b3913 = m3645(this.z3643, this.closed, this.degree);     }        checkFlipped(flipX, flipY)     {         super.checkFlipped(flipX, flipY);           const bounds = this.getBounds();           for (const point of this.points)         {             if (flipX) point.x.value = bounds.width  - point.x.value;             if (flipY) point.y.value = bounds.height - point.y.value;         }          this.i3640();                                                   }        p3638()     {                  this.a3646();           const oldType = this.type;         this.type = o1230;          const data =          [             ...super.p3638(),                  this.x,              this.y,              this.width,              this.height,               this.b3913,              this.winding,              this.round * Math.abs(this.e3637)         ];          this.type = oldType;           return data;     }        toNewValue()     {         return n1850.fromObject(this);     } }    function m3645(points, closed, degree) {     for (const p of points)         if (   isNaN(p.x)             || isNaN(p.y))             return '';                   let b3913 = '';       switch (degree)     {     case 0: b3913 = w945   (points);         break;      case 1: b3913 = u3647(points, closed); break;      case 2:                                                              case 3:                                                              case 4:                                                              case 5: b3913 = e3648    (points, closed); break;      }       const d3649 =            degree == 0 && points.length > 2         || degree == 1 && points.length > 2         || degree == 2 && points.length > 3         || degree == 3 && points.length > 2         || degree == 4 && points.length > 2         || degree == 5 && points.length > 2;       if (   d3649         && (   closed             || q1017(points[0], points.at(-1))))         b3913 += ' Z';       return b3913; }    function u3647(points, closed) {     let b3913 = '';       if (points.length < 3)         return b3913;       b3913 += 'M';     b3913 += ' ' + d877(points[0].x);     b3913 += ' ' + d877(points[0].y);      let i;     for (i = 1; i < points.length-1; i += 2)     {         b3913 +=                ' Q'             + ' ' + d877(points[i  ].x)             + ' ' + d877(points[i  ].y)             + ' ' + d877(points[i+1].x)             + ' ' + d877(points[i+1].y);     }       if (   points.length - i == 1         && closed)     {         b3913 +=                ' Q'             + ' ' + d877(points.at(-1).x)             + ' ' + d877(points.at(-1).y)             + ' ' + d877(points.at( 0).x)             + ' ' + d877(points.at( 0).y);     }       return b3913; }    function e3648(points, closed) {     let b3913 = '';       if (points.length < 4)         return b3913;       b3913 += 'M';     b3913 += ' ' + d877(points[0].x);     b3913 += ' ' + d877(points[0].y);      let i;     for (i = 1; i < points.length-2; i += 3)     {         b3913 +=                ' C'             + ' ' + d877(points[i  ].x)             + ' ' + d877(points[i  ].y)             + ' ' + d877(points[i+1].x)             + ' ' + d877(points[i+1].y)             + ' ' + d877(points[i+2].x)             + ' ' + d877(points[i+2].y);     }       if (   points.length - i == 2         && closed)     {         b3913 +=                ' C'             + ' ' + d877(points.at(-2).x)             + ' ' + d877(points.at(-2).y)             + ' ' + d877(points.at(-1).x)             + ' ' + d877(points.at(-1).y)             + ' ' + d877(points.at( 0).x)             + ' ' + d877(points.at( 0).y);     }       return b3913; }    function w3650(points, closed, y3651) {     if (points.length < 2)         return '';       const bp = [];            let [pp, p, pn] = y3651(         closed ? points.at(-1) : points[0],          points[0],         points[1]);      bp.push(p);       let _pp = pn;            for (let i = 1; i < points.length; i++)     {         [pp, p, pn] = y3651(             points[i-1],              points[i],             i == points.length-1              ? (closed ? points[0] : points[i])             : points[i+1]);          if (points[i].smooth)             [pp, pn] = w3652(points[i], pp, p, pn);                      bp.push(_pp, pp, p);             _pp = pn;     }       if (bp.length > 3)     {         if (closed)         {             if (   equal(bp[0].x, bp.at(-1).x, 0.01)                 && equal(bp[0].y, bp.at(-1).y, 0.01))             {                                  [pp, p, pn] = y3651(                     points.at(-2),                      points.at( 0),                     points.at( 1));                  if (points[0].smooth)                     [pp, pn] = w3652(points[0], pp, p, pn);                  bp[1]           = pn;                 bp[bp.length-2] = pp;             }             else             {                                  [pp, p, pn] = y3651(                     points.at(-1),                      points.at( 0),                     points.at( 1));                  if (points[0].smooth)                     [pp, pn] = w3652(points[0], pp, p, pn);                  bp.push(_pp, pp, p);                  bp[1]           = pn;                 bp[bp.length-2] = pp;             }         }         else          {             bp[1]           = y893(bp[0],     y895(i884(j898(bp[2],     bp[0]    )), distv(bp[3],     bp[0]    )/3));             bp[bp.length-2] = y893(bp.at(-1), y895(i884(j898(bp.at(-3), bp.at(-1))), distv(bp.at(-4), bp.at(-1))/3));         }     }       return bp; }    function w3652(point, pp, p, pn) {     if (point.smooth)     {         const smooth = point.smooth.value;                  pp = y893(p, y895(j898(pp, p), smooth));         pn = y893(p, y895(j898(pn, p), smooth));     }      return [pp, pn]; }    function u4123(_pointP, _point, _pointN) {     const _pp = point(_pointP.x.value, _pointP.y.value);     let   _p  = point(_point .x.value, _point .y.value);     const _pn = point(_pointN.x.value, _pointN.y.value);       const v = j898(_pn, _pp);               let a = m885(         n881(j898(_p, _pp)),          n881(j898(_pn, _p)));               a = Math.abs(a);     while (a >= Tau/2) a -= Tau;       const k     = 4 * (Math.sqrt(2) - 1) / 3;        // or use the value 0.55191502449 from http://spencermortensen.com/articles/bezier-circle/
	const o2417 = 0.9993391093366649465402826439248;       let f =         a > Tau/4         ? 1/3 + (k*o2417 - 1/3) * Math.sin(a)         : 1/3 + (k*o2417 - 1/3) * (1 - Math.cos(a));           let pp = y893(_p, y895(i884(v), -a883(v)/2 * f));     let pn = y893(_p, y895(i884(v),  a883(v)/2 * f));      pp = c1018(pp);      _p = c1018(_p);      pn = c1018(pn);       return [pp, _p, pn]; }    function w4124(_pointP, _point, _pointN) {     const _pp = point(_pointP.x.value, _pointP.y.value);     const _p  = point(_point .x.value, _point .y.value);     const _pn = point(_pointN.x.value, _pointN.y.value);      const  pp = point(_p.x - (_p.x - _pp.x) * 0.3615, _p.y);     const  pn = point(_p.x + (_pn.x - _p.x) * 0.3615, _p.y);      return [pp, _p, pn]; }    function t4125(_pointP, _point, _pointN) {     const _pp = point(_pointP.x.value, _pointP.y.value);     const _p  = point(_point .x.value, _point .y.value);     const _pn = point(_pointN.x.value, _pointN.y.value);      const  pp = point(_p.x, _p.y - (_p.y - _pp.y) * 0.3615);     const  pn = point(_p.x, _p.y + (_pn.y - _p.y) * 0.3615);      return [pp, _p, pn]; }


class p1665 extends c1660 {     x;     y;     width;     height;          points;     edges;     regions;      networkData;        constructor(nodeId, objectId, objectName, points, edges, regions)     {         super(h1242, nodeId, objectId, objectName);                  this.points  = points .map(p => p.copy());         this.edges   = edges  .map(e => e.copy());         this.regions = regions.map(r => r.copy());           this.updateNetworkData();           let bounds = t1045.NaN;          for (let i = 0; i < this.edges.length; i++)         {             bounds = d3641(                 bounds,                  b862(                     this.edges[i].start.n3644(),                      this.edges[i].start.n3644(),                     this.edges[i].end  .n3644(),                     this.edges[i].end  .n3644()));         }          this.w3639(             bounds.x + bounds.width /2,                         bounds.y + bounds.height/2                     );     }        copy()     {         const copy = new p1665(             this.nodeId,             this.objectId,             this.objectName,              this.points,              this.edges,              this.regions);           copy.x      = this.x;         copy.y      = this.y;         copy.width  = this.width;         copy.height = this.height;           copy.m3266(this);           return copy;     }        updateNetworkData()     {         let minX = Number.MAX_SAFE_INTEGER;         let minY = Number.MAX_SAFE_INTEGER;         let maxX = Number.MIN_SAFE_INTEGER;         let maxY = Number.MIN_SAFE_INTEGER;          for (const p of this.points)         {             minX = Math.min(minX, p.x.value);             minY = Math.min(minY, p.y.value);             maxX = Math.max(maxX, p.x.value);             maxY = Math.max(maxY, p.y.value);         }           this.x      = minX;         this.y      = minY;         this.width  = maxX - minX;         this.height = maxY - minY;          this.p3627(this.x, this.y, this.width, this.height);           this.networkData = getNetworkData(this.points, this.edges, this.regions);     }        getBounds()     {         let bounds = t1045.NaN;          for (let i = 0; i < this.edges.length; i++)         {             const edge = this.edges[i];              const s  = edge.start;             const e  = edge.end;             let   st = edge.j3569;             let   et = edge.t3570;              if (!st.isValid()) st = s.copy();             if (!et.isValid()) et = e.copy();              bounds = d3641(                 bounds,                  b862(                     s .n3644(),                      st.n3644(),                     et.n3644(),                     e .n3644()));         }          return bounds;     }        toNewValue()     {         return p1665.fromObject(this);     }        p3638()     {         return [             ...super.p3638(),                  this.x,              this.y,              this.width,              this.height,               this.networkData         ];     } }    function getNetworkData(points, edges, _regions) {     const vertices = [];     const segments = [];     const regions  = [];       for (const point of points)     {         let join;         let cap;          switch (point.join.value)         {             case 0: join = 'MITER'; break;             case 1: join = 'BEVEL'; break;             case 2: join = 'ROUND'; break;         }              switch (point.cap.value)         {             case 0: cap = 'NONE';   break;             case 1: cap = 'SQUARE'; break;             case 2: cap = 'ROUND';  break;         }              vertices.push(         {             x:            point.x.value,             y:            point.y.value,             strokeJoin:   join,             strokeCap:    cap,             cornerRadius: point.round.value         });     }       for (const edge of edges)     {         segments.push(         {             start: points.findIndex(p => p.c3633 == edge.start.c3633),             end:   points.findIndex(p => p.c3633 == edge.end  .c3633)         });     }       for (const region of _regions)     {         const loops = [];          for (const _loop of region.loops.items)         {             const loop = [];              for (const _edge of _loop.items)                 loop.push(edges.findIndex(e => e.c3633 == _edge.c3633));              loops.push(loop);         }           regions.push(         {             windingRule: region.winding.value == 1 ? 'NONZERO' : 'EVENODD',             loops:       loops,             fills:       u954(region.fills)         });     }       let networkData =      {         vertices: vertices,         segments: segments,         regions:  regions     };       return networkData; }


class b1664 extends w1666 {     width;     height;      round;     bias;        constructor(nodeId, objectId, objectName, x, y, width, height, round, bias)     {         const tw = width * (1 + Math.min(0,  bias/100));         const bw = width * (1 + Math.min(0, -bias/100));                  const tx = x + (width - tw) / 2;         const bx = x + (width - bw) / 2;          const points =         [             r1836.create(nodeId, tx,      y         ),             r1836.create(nodeId, bx,      y + height),             r1836.create(nodeId, bx + bw, y + height),             r1836.create(nodeId, tx + tw, y         )         ];               super(             nodeId,              objectId,             objectName,              points,             1,              0,              0,              round);          this.type   = s1208;          this.x      = x;         this.y      = y;         this.width  = width;         this.height = height;          this.round  = round;         this.bias   = bias;                   this.w3639(             x + width /2,              y + height/2);     }        copy()     {         const copy = new b1664(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.width,             this.height,                          this.round,             this.bias);                       copy.z3643 = [...this.z3643];         copy.b3913   = this.b3913;              copy.m3266(this);                     return copy;     }        toNewValue()     {         return p1847.fromObject(this);     } } 


class m1658 extends c1660 {     x;     y;     width;     height;     round;     corners;        constructor(nodeId, objectId, objectName, x, y, width, height, round, corners)     {         super(z1217, nodeId, objectId, objectName);                  this.x       = x;         this.y       = y;         this.width   = width;         this.height  = height;          this.round   = round;         this.corners = corners;                   this.w3639(             x + width /2,              y + height/2);     }        copy()     {         const copy = new m1658(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.width,             this.height,                          this.round,             this.corners);           copy.m3266(this);           return copy;     }        toNewValue()     {         return x1837.fromObject(this);     }        p3638()     {         return [             ...super.p3638(),                  this.x,              this.y,              this.width,              this.height,               this.round * Math.abs(this.e3637),              this.corners         ];     } } 


class a1662 extends c1660 {     x;     y;     width;     height;      round;     points;     convex;        constructor(nodeId, objectId, objectName, x, y, width, height, round, points, convex)     {         super(m1220, nodeId, objectId, objectName);                  this.x      = x;         this.y      = y;         this.width  = width;         this.height = height;          this.round  = round;         this.points = points;         this.convex = convex;                   this.w3639(             x + width /2,              y + height/2);     }        copy()     {         const copy = new a1662(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.width,             this.height,              this.round,             this.points,             this.convex);          copy.m3266(this);          return copy;     }        toNewValue()     {         return a1843.fromObject(this);     }        p3638()     {         return [             ...super.p3638(),                  this.x,              this.y,              this.width,              this.height,               this.round * Math.abs(this.e3637),              this.points,              this.convex         ];     } } 


class y1663 extends c1660 {     text;          x;     y;     width;     height;          l3654;     p3655;          font;     size;     style;          alignX;     alignY;          lineHeight;     letterSpacing;        constructor(nodeId, objectId, objectName, text, x, y, width, height, font, size, style, alignX, alignY, lineHeight, letterSpacing)     {         super(d1223, nodeId, objectId, objectName);                  this.text          = text;              this.x             = x;         this.y             = y;         this.width         = width;         this.height        = height;              this.l3654      = width;         this.p3655     = height;              this.font          = font;         this.size          = size;         this.style         = style;              this.alignX        = alignX;         this.alignY        = alignY;              this.lineHeight    = lineHeight;         this.letterSpacing = letterSpacing;                   this.w3639(             x + width /2,              y + height/2);     }        copy()     {         const copy = new y1663(             this.nodeId,             this.objectId,             this.objectName,                  this.text,                  this.x,             this.y,             this.width,             this.height,                  this.font,             this.size,             this.style,                  this.alignX,             this.alignY,                  this.lineHeight,             this.letterSpacing);           copy.l3654  = this.l3654;         copy.p3655 = this.p3655;           copy.m3266(this);           return copy;     }        toNewValue()     {         return l1845.fromObject(this);     }        e3653()     {         return {             ...super.e3653(),                 x:             this.x,             y:             this.y,             width:         this.width,             height:        this.height,              l3654:      this.l3654,             p3655:     this.p3655,              text:          this.text,              font:          this.font,             size:          this.size,             style:         this.style,              alignX:        this.alignX,             alignY:        this.alignY,                          lineHeight:    this.lineHeight,             letterSpacing: this.letterSpacing         };     }        p3638()     {         return [             ...super.p3638(),                  this.x,              this.y,              this.width,              this.height,                           this.l3654,              this.p3655,                           this.text,               this.font,              this.size,              this.style,                           this.alignX,              this.alignY,                           this.lineHeight,              this.letterSpacing         ];     } } 


class s1657 extends c1660 {     x;     y;     smooth;        constructor(nodeId, objectId, objectName, x, y, smooth = 1, p3636 = false, isCenter = false, isXform = false)     {         super(y1226, nodeId, objectId, objectName, p3636, isXform);                  this.x        = x;         this.y        = y;         this.smooth   = smooth;         this.isCenter = isCenter;                   this.w3639(x, y);          this.m3977(x, y);     }        copy()     {         const copy = new s1657(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.smooth,             this.p3636,             this.isCenter);          copy.m3266(this);          return copy;     }        getBounds()     {         return new t1045(             this.x - 0.005,              this.y - 0.005,              0.01,              0.01);     }        checkFlipped(flipX, flipY)     {      }        n3644()     {         return point(this.x, this.y);     }        toNewValue()     {         return r1836.fromObject(this);     }        p3638()     {         return [             ...super.p3638(),                  this.x,              this.y         ];     } } 


class e1651 extends c1660 {     operation;      children;        constructor(nodeId, objectId, objectName, operation, children = [])     {         super(s1266, nodeId, objectId, objectName);                  this.operation = operation;                  this.children  = children.map(c => c.copy());     }        copy()     {         const copy = new e1651(             this.nodeId,             this.objectId,             this.objectName,              this.operation,             this.children);          copy.m3266(this);                  return copy;     }        getBounds()     {         return getObjBounds(this.children);     }        h3978(u4087, affectSpace)     {         for (const c111 of this.children)             c111.h3978(u4087, affectSpace);     }        e3653()     {         return {             ...super.e3653(),                 operation: this.operation,             children:  this.children         };     }        p3638()     {         return [             ...super.p3638(),                  this.children.map(o => o.p3638()),              this.operation         ];     } }


class q2451 extends w1666 {     position;                          start;     sweep;            constructor(nodeId, objectId, objectName, pos, x, y, width, height, start, sweep)     {         let points = makeArc_(             point(                 x + width /2,                  y + height/2),              width/2,               start,              start + sweep);                      points = points.map(p => r1836.fromPoint(nodeId, p));           points.forEach(p =>          {             p.y.value =                  pos > 0                 ? p.y.value * height/nozero(width)                 : height/2 + (p.y.value - height/2) * height/nozero(width);              if (   pos == 0                 && width < 0)                  p.x.value += width;         });          if (width  < 0) width  *= -1;         if (height < 0) height *= -1;           super(             nodeId,              objectId,             objectName,             points,             0,               2,               0,               0);                    this.position = pos;         this.x       = x;         this.y       = y;         this.width   = width;         this.height  = height;          this.start    = start;         this.sweep    = sweep;           this.w3639(             x + width /2,             y + height/2);     }        copy()     {         const copy = new q2451(             this.nodeId,             this.objectId,             this.objectName,              this.position,             this.x,             this.y,             this.width,             this.height,                          this.start,             this.sweep);           copy.z3643 = [...this.z3643];         copy.b3913   = this.b3913;          copy.m3266(this);           return copy;     } }


class s2453 extends w1666 {     shape;     _x;     _y;     f2981;     amplitude;     frequency;     offset;     alignX;     alignY;            constructor(nodeId, objectId, objectName, shape, x, y, width, amplitude, frequency, offset, alignX, alignY)     {         let points = makeWave(             shape,              x,             y,             width,              amplitude,              frequency,             offset,             alignX,             alignY);          points = points.map(p => r1836.fromPoint(nodeId, p));           super(             nodeId,              objectId,             objectName,             points,             0,                               shape == 4 ? 2 : 0,              0,                               0);                                    this.shape     = shape;         this._x        = x;         this._y        = y;         this.f2981    = width;         this.amplitude = amplitude;         this.frequency = frequency;         this.offset    = offset;         this.alignX    = alignX;         this.alignY    = alignY;           let height = amplitude;                  this.w3639(             x + width /2,             y + height/2);     }        copy()     {         const copy = new s2453(             this.nodeId,             this.objectId,             this.objectName,              this.shape,             this._x,             this._y,             this.f2981,             this.amplitude,             this.frequency,             this.offset,             this.alignX,             this.alignY);           copy.z3643 = [...this.z3643];         copy.b3913   = this.b3913;          copy.m3266(this);           return copy;     } }


class f1661 extends c1660 {     children;        constructor(nodeId, objectId, objectName, children = [])     {         super(m1245, nodeId, objectId, objectName);                  this.children = children.map(c => c.copy());     }        copy()     {         const copy = new f1661(             this.nodeId,             this.objectId,             this.objectName,              this.children);          copy.m3266(this);          return copy;     }        getCount()     {         let v3242 =             this.children.length > 0             ? super.getCount()             : 0;          for (const c111 of this.children)             v3242 += c111.getCount();          return v3242;     }        w3639(cx = 0, cy = 0)     {         super.w3639(cx, cy);          for (const c111 of this.children)             c111.w3639(cx, cy);     }        resetSpace(bounds, singlePoint = false, cx = 0.5, cy = 0.5, units = 0)     {         super.resetSpace(bounds, false, cx, cy, units);          for (const c111 of this.children)             c111.resetSpace(bounds, false, cx, cy, units);     }        getBounds()     {         return getObjBounds(this.children);     }        h3978(u4087, affectSpace)     {         for (const c111 of this.children)             c111.h3978(u4087, affectSpace);     }        e3653()     {         return {             ...super.e3653(),                 children: this.children         };     }        p3638()     {         return [             ...super.p3638(),                  this.children.map(o => o.p3638())         ];     } }


class y1654 extends c1660 {     x;     y;     width;     height;      round;          clip;      children;        constructor(nodeId, objectId, objectName, x, y, width, height, round, clip, children = [])     {         super(s1248, nodeId, objectId, objectName);                  this.x        = x;         this.y        = y;         this.width    = width;         this.height   = height;              this.round    = round;          this.clip     = clip;              this.children = children.map(c => c.copy());          this.w3639(             x + width /2,              y + height/2);     }        copy()     {         const copy = new y1654(             this.nodeId,             this.objectId,             this.objectName,                  this.x,             this.y,             this.width,             this.height,                  this.round,                this.clip,                  this.children);           copy.m3266(this);           return copy;     }        getCount()     {         let v3242 = super.getCount();          for (const c111 of this.children)             v3242 += c111.getCount();          return v3242;     }            checkFlipped(flipX, flipY)     {         super.checkFlipped(flipX, flipY);          for (const c111 of this.children)         {             c111.checkFlipped(flipX, flipY);              if (flipX)             {                 c111.xp0.x = this.width - c111.xp0.x;                 c111.xp1.x = this.width - c111.xp1.x;                 c111.xp2.x = this.width - c111.xp2.x;             }              if (flipY)             {                 c111.xp0.y = this.height - c111.xp0.y;                 c111.xp1.y = this.height - c111.xp1.y;                 c111.xp2.y = this.height - c111.xp2.y;             }         }     }        e3653()     {         return {             ...super.e3653(),                 x:        this.x,             y:        this.y,             width:    this.width,             height:   this.height,                      round:    this.round,              clip:     this.clip,                      children: this.children         };     }        p3638()     {         return [             ...super.p3638(),                  this.x,              this.y,              this.width,              this.height,               this.round,               this.clip,               this.children.map(o => o.p3638())         ];     } }    


class h2415 extends z1656 {     variableType;     variableValues = [];     aliasIds       = [];            constructor(nodeId, variableId, variableName, variableValues, aliasIds)     {         super(n1059, nodeId, variableId, variableName);                  this.aliasIds = aliasIds;          if (variableValues.length > 0)         {             switch (variableValues[0].type)             {                 case e1090: this.variableType = variableValues[0].isBoolean ? 'BOOLEAN' : 'FLOAT'; break;                 case q1123:   this.variableType = 'STRING'; break;                 case s1148:                  case m1158:   this.variableType = 'COLOR';  break;             }         }           for (const variableValue of variableValues)         {             switch (variableValue.type)             {                 case e1090: this.variableValues.push(variableValue.x3604());     break;                 case q1123:   this.variableValues.push(variableValue.toString());     break;                 case s1148:  this.variableValues.push(variableValue.toRgbObject());  break;                 case m1158:   this.variableValues.push(variableValue.toRgbaObject()); break;             }         }     }        copy()     {         const copy = new h2415(             this.nodeId,             this.variableId,             this.objectName,             [],             []);           copy.variableType   = this.variableType;         copy.variableValues = [...this.variableValues];         copy.aliasIds       = [...this.aliasIds];          copy.m3266(this);           return copy;     }        toNewValue()     {         return a2445.fromObject(this);     }        p3638()     {         const data =          [             ...super.p3638(),                  this.variableType,              this.variableValues.length,              this.aliasIds.map(a => a !== NULL)         ];          for (const val of this.variableValues)             data.push(val);          return data;     } } 


class o1652 {     type;          nodeId = '';      styleId;     styleName;      paints = [];          constructor(nodeId, styleId, styleName)     {         this.type      = x1196;         this.nodeId    = nodeId;          this.styleId   = styleId;         this.styleName = styleName;     }        copy()     {         const copy = new o1652(this.nodeId, this.styleId, this.styleName);            return copy;     }        p3638()     {         return [          this.type,          this.nodeId,           this.styleId,          this.styleName,                   this.paints         ];     } }


class d1855 {     static types = {};           static nextUniqueId = 0;       type;       valid;       listId           = -1;     c3633;      cached           = true;     unknown          = false;      s3718           = NULL;      currentIteration = 0;     iterated         = false;       w3004     = null;        constructor(type, options)      {         this.type    = type;          if (options && options.cached ) this.cached  = options.cached;         if (options && options.unknown) this.unknown = options.unknown;               this.c3633 = d1855.nextUniqueId++;     }        reset()     {                                                                                   this.w3004 = null;     }        copy()     {         s951('abstract type d1855 cannot be copied');         return null;     }        m3266(base)     {                  this.c3633 = base.c3633;     }        p3665()     {         if (    this.input             &&  this.input.p3665             && !this.input.notCondition)             return this.input.p3665();                  return this;     }            toNewValue()     {         return null;     }        toString()      {          return this.type;      }        c1932()     {         return this.toString();     }        isValid()      {         return false;     }            validate()     {         this.valid = true;     }        invalidate()     {         this.valid = false;     }        o3967(parse)     {      }        y3968(parse, from, force = false)     {         if (   this.unknown             || force)             this.valid = false;          return true;     }        k3535(parse, nodeId)     {      }        o3536(parse, nodeId)     {      }        l3966(parse)     {      }        p3538(parse, nodeId)     {      }     } 


class i1863 {     type;     valueId;      parent;      customParams = [];       objects      = null;       valid;         constructor(type, valueId = NULL)      {         this.type    = type;         this.parent  = null;                  this.valueId = NULL;              this.valid   = true;     }        reset() {}        copy()     {         s951('abstract class i1863 cannot be copied');         return null;     }        m3266(base)     {         this.valueId  = base.valueId;         this.c3633 = base.c3633;          this.z3532(base);          if (base.objects)             this.c3533(base.objects);     }        z3532(base)     {         for (const param of base.customParams)             this.customParams.push([param[0], param[1].copy()]);     }        c3533(objects)     {         this.objects = objects.map(o => o.copy());     }                               async eval(parse)     {         return this;     }        l3609()     {         return false;     }        p3539()      {         console.error('cannot call abstract method i1863.p3539()');         console.trace();         return null;     }        toNewValue()     {         return this.copy();     }        c1932()      {          return this.toString();      }        toJsonText(options = {})      {         let json = '';          if (options.quoteValues === true)             json += '"';          json += this.u3605();          if (options.quoteValues === true)             json += '"';          options.lastExpanded = false;                  return json;     }        toString()      {          return this.type;      }        u3605()     {         return this.toString();     }        l3606()     {         return this.toString();     }        s2757(gen)     {         s951('invalid abstract method');         return '';     }        static NaN()     {         s951('invalid abstract method');         return null;     }        isCached()     {         return this.valid;     }        o3967(parse)     {      }        y3968(parse, from, force)     {         this.valid = false;     }        l3966 (parse)     {      } }    function parseValueFromType(type, value) {     switch (type)     {         case            r1086: return p4096         .parse(value)[0];          case           q1054:          case    z1055:          case      g1056:          case     x1057: return x1834         .parse(value)[0];          case         e1090: return n1835       .parse(value)[0];         case           q1123: return e1846         .parse(value)[0];         case          s1148: return y1823        .parse(value)[0];          case           m1158: return m1826         .parse(value)[0];         case     o1164: return l1822    .parse(value)[0];         case       d1167: return e1828     .parse(value)[0];         case         x1161: return d1844       .parse(value)[0];         case    f1176: return c1824   .parse(value)[0];         case   s1179: return j1829  .parse(value)[0];         case     r1182: return a1831    .parse(value)[0];         case      e1185: return v1821     .parse(value)[0];         case    i1191: return f1830   .parse(value)[0];         case     d1188: return l1832    .parse(value)[0];          case      a1198: return d1838    .parse(value)[0];         case           w1201: return m1833         .parse(value)[0];         case        l1204: return v1825      .parse(value)[0];         case        y1207: return p1847      .parse(value)[0];         case        f1216: return x1837      .parse(value)[0];         case           k1219: return a1843         .parse(value)[0];         case     z1222: return l1845    .parse(value)[0];         case          p1225: return r1836        .parse(value)[0];         case    c1229: return n1850   .parse(value)[0];         case  r1232: return i1852 .parse(value)[0];         case    e1235: return v1848   .parse(value)[0];         case  k1238: return c1851 .parse(value)[0];         case r1241: return k1849.parse(value)[0];         case  x1267: return w1840 .parse(value)[0];         case    j1244: return s1841   .parse(value)[0];         case       k1211: return i2421      .parse(value)[0];         case      g1214: return h2418     .parse(value)[0];         case          y1247: return n1827        .parse(value)[0];          case       VARIABLE_VALUE: return a2445     .parse(value)[0];          case           NULL_VALUE: return null;                  default:              console.error('cannot parse unknown type \'' + type + '\'');             return null;     } }    function u4089(type, value) {     if (   type == e1090         && value.indexOf(',') < 0)         return value;       switch (type)     {         case            r1086: return p4096         .parse(value)[0].l3606();         case           q1054: return x1834         .parse(value)[0].l3606();          case         e1090: return n1835       .parse(value)[0].l3606();         case           q1123: const val = e1846    .parse(value)[0]; return val == '' ? '\'\'' : val.l3606();         case          s1148: return y1823        .parse(value)[0].l3606();         case           m1158: return m1826         .parse(value)[0].l3606();         case     o1164: return l1822    .parse(value)[0].l3606();         case       d1167: return e1828     .parse(value)[0].l3606();         case         x1161: return d1844       .parse(value)[0].l3606();         case    f1176: return c1824   .parse(value)[0].l3606();         case   s1179: return j1829  .parse(value)[0].l3606();         case     r1182: return a1831    .parse(value)[0].l3606();         case      e1185: return v1821     .parse(value)[0].l3606();         case    i1191: return f1830   .parse(value)[0].l3606();         case     d1188: return l1832    .parse(value)[0].l3606();          case      a1198: return d1838    .parse(value)[0].l3606();         case           w1201: return m1833         .parse(value)[0].l3606();         case        l1204: return v1825      .parse(value)[0].l3606();         case        y1207: return p1847      .parse(value)[0].l3606();         case        f1216: return x1837      .parse(value)[0].l3606();         case           k1219: return a1843         .parse(value)[0].l3606();         case     z1222: return l1845    .parse(value)[0].l3606();         case          p1225: return r1836        .parse(value)[0].l3606();         case    c1229: return n1850   .parse(value)[0].l3606();         case  r1232: return i1852 .parse(value)[0].l3606();         case    e1235: return v1848   .parse(value)[0].l3606();         case  k1238: return c1851 .parse(value)[0].l3606();         case r1241: return k1849.parse(value)[0].l3606();         case  x1267: return w1840 .parse(value)[0].l3606();         case    j1244: return s1841   .parse(value)[0].l3606();         case          y1247: return n1827        .parse(value)[0].l3606();                  case       VARIABLE_VALUE: return a2445     .parse(value)[0].l3606();          case           NULL_VALUE: return NULL_VALUE;     }       s951('cannot display value of type \'' + type + '\''); }    function nanFromType(type) {     switch (type)     {         case            q1054: return          x1834.NaN();          case          e1090: return        n1835.NaN();         case            q1123: return          e1846.NaN();         case           s1148: return         y1823.NaN();         case            m1158: return          m1826.NaN();         case      o1164: return     l1822.NaN();         case        d1167: return      e1828.NaN();         case          x1161: return        d1844.NaN();         case     f1176: return    c1824.NaN();         case    s1179: return   j1829.NaN();         case      r1182: return     a1831.NaN();         case       e1185: return      v1821.NaN();         case     i1191: return    f1830.NaN();         case      d1188: return     l1832.NaN();          case       a1198: return     d1838.NaN();         case            w1201: return          m1833.NaN();         case         l1204: return       v1825.NaN();         case         f1216: return       x1837.NaN();         case            k1219: return          a1843.NaN();         case      z1222: return     l1845.NaN();         case           p1225: return         r1836.NaN();         case     c1229: return    n1850.NaN();         case   r1232: return  i1852.NaN();         case     e1235: return    v1848.NaN();         case   k1238: return  c1851.NaN();         case  r1241: return k1849.NaN();         case   x1267: return  w1840.NaN();         case     j1244: return    s1841.NaN();         case           y1247: return         n1827.NaN();          case        VARIABLE_VALUE: return      a2445.NaN();          case            NULL_VALUE: return          new p4096();     }      s951('cannot determine null value from type \'' + type + '\''); }


class l1856 extends d1855 {     nodeId;     nodeName;      topLevel;      value;          customParams = [];      options      = {};     w3004 = [];               constructor(type, nodeId, options)     {         super(type, options);          this.nodeId   = nodeId;         this.nodeName = options.nodeName;          this.options  = clone(options);          this.valid    = false;         this.topLevel = false;          this.value    = null;     }        reset()     {         this.customParams = [];         this.options      = {};         this.w3004 = [];     }        m3266(base)     {         super.m3266(base);                  this.nodeId   = base.nodeId;         this.nodeName = base.nodeName;          this.z3532(base);          this.options  = clone(base.options);          this.valid    = base.valid;         this.topLevel = base.topLevel;          if (base.value) this.value = base.value.copy();     }        z3532(base)     {         for (const param of base.customParams)             this.customParams.push([param[0], param[1].copy()]);     }        x4121(i2902)     {         return i2902 == 'value'             ?  this.value             :  this[i2902];     }        isCached()     {         return this.options.cached             && this.valid;     }        async eval(parse)     {                   return this;     }        async q3979(parse)     {      }        evalInputOrList(input, evalFunc, nan)     {         if (l955(input.type))         {             this.value = new x1834();                  for (const item of input.items)                 this.value.items.push(evalFunc(item));         }         else             this.value = evalFunc(input);     }        c3533(value, listId = -1)     {         const objects = w3534(value);         const copies  = [];                                  for (let i = 0; i < objects.length; i++)         {             const c111 = g3635(objects[i]);                  c111.nodeId   = this.nodeId;             c111.listId   = listId;                          c111.objectId = c111.objectId + b965 + this.nodeId;                  copies.push(c111);         }          return copies;     }                outputType()     {         return this.value             ? new e1846(                 l955(this.value.type)                 ? f3386(this.value.items)                 : this.value.type)             : new e1846(r1086);     }        outputListType()     {         return this.outputType();     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.unknown)             this.valid = false;          this.iterated = false;     }        k3535(parse, nodeId)     {         this.s3718           = nodeId;         this.currentIteration = 0;     }        o3536(parse, nodeId)     {         this.valid = false;     }        l3966(parse)     {         const v3537 = parse.repeats.findIndex(r => r.repeatId == this.s3718);                  if (   (   v3537 < 0                 || v3537 == parse.repeats.length-1)             && !this.iterated)         {             this.currentIteration++;             this.iterated = true;         }     }        iterateCache(parse, from)     {      }        p3538(parse, nodeId)     {         this.valid            = false;         this.currentIteration = 0;     }            h3980(parse, values, add = false)     {         if (   (    parse.repeats.length == 0                 ||  this.unknown && parse.repeats[0].total == 0                 || !this.unknown                 ||  parse.repeats.at(-1).currentIteration == 0                 ||  parse.repeats.at(-1).currentIteration == parse.repeats.at(-1).total-1)             && parse.solvers.length == 0)         {             if (add) this.w3004.push(...values);             else     this.w3004 = [...values];         }         else if (!add)             this.w3004 = [];     }        o3967(parse)     {                 if (!this.w3004)             return;          for (const value of this.w3004)             u1875(parse, this.nodeId, value[0], value[1]);          this.w3004 = [];     }        c4095()     {         if (   !this.value             || !this.value.objects)             return;           for (let i = 0; i < this.value.objects.length; i++)         {             const c111     =  this.value.objects[i];              c111.nodeId    =  this.nodeId;             c111.objectId +=  b965 + this.nodeId;             c111.listId    = -1;         }     }        updateValueFromParam(i2902, value)     {         this[i2902] = value;             }        setConditionInput(input)     {      } }    function allInputsAreCondensedLists(inputs) {     for (const input of inputs)     {         if (   !input             ||    !isValueListOfCondensedLists(input)                && !l955(input)                &&  input.condensed !== true)              return false;     }      return true; }    async function evalValue(_value, parse, nan = () => new p4096()) {     let value =          _value              ? (await _value.eval(parse)).toNewValue()              : null;      if (   (    value              && !value.isValid())         && nan)          value = nan();      return value; }    async function evalValueOrList(_value, parse)  {      let value = await evalValue(_value, parse);      if (   value         && value.type == q1054)     {         const condensed = value.condensed;                  value = new x1834(value.items);         value.condensed = condensed;     }          return value;                 }    async function evalNumberValue(_value, parse)  {      let value = await evalValue(_value, parse, () => n1835.NaN());       if (   value         && value.type == q1123)         value = new n1835(parseFloat(value.value));      return value;                 }    async function evalBooleanNumberValue(_value, parse)  {      let value = await evalValue(_value, parse, () => n1835.NaN());       if (   value         && value.type == q1123)     {         if (stringIsNumber(value.value))              value = new i2435(parseFloat(value.value) > 0);         else                 {                  if (value.value.trim().toLowerCase() == 'true' ) value = new i2435(true);             else if (value.value.trim().toLowerCase() == 'false') value = new i2435(false);             else                                                  value = i2435.NaN();         }     }      return value;                 }    async function evalNumberOrListValue(_value, parse)  {      let value = await evalValue(_value, parse, () => n1835.NaN());       if (   value         && value.type == q1123)         value = new n1835(parseFloat(value.value));      else if (value           && value.type == q1054           && f3386(value.items) == g1056)     {         const condensed = value.condensed;          value = new x1834(value.items.map(i => new n1835(parseFloat(i.value))));         value.condensed = condensed;     }      return value;                 }    async function evalTextValue(_value, parse)  {      let value = await evalValue(_value, parse, () => new e1846());      if (   value         && value.type == e1090)         value = new e1846(s1004(value.value, value.decimals));      return value;                 }    async function evalTextOrListValue(_value, parse)  {      let value = await evalValue(_value, parse, () => new e1846());      if (   value         && value.type == e1090)         value = new e1846(s1004(value.value, value.decimals));      else if (value           && value.type == q1054           && f3386(value.items) == z1055)     {         const condensed = value.condensed;                  value = new x1834(value.items.map(i => new e1846(s1004(i.value, i.decimals))));         value.condensed = condensed;     }          return value;                 }    async function evalColorValue(_value, parse) {      let value = await evalValue(_value, parse, () => y1823.NaN());       if (   value         && value.type == m1158)         value = value.color;      else if (value           && value.type == o1164)         value = value.fill.color;      return value; }    async function evalFillValue(_value, parse) {      let value = await evalValue(_value, parse, null);           if (   value         && value.type == s1148)         value = new m1826(value);      if (   value         && value.type == o1164)         value = value.fill;      return value;  }    async function evalStrokeValue   (_value, parse) { return await evalValue(_value, parse, () => d1844   .NaN()); } async function evalColorStopValue(_value, parse) { return await evalValue(_value, parse, () => l1822.NaN()); }    async function evalColorStopOrListValue(_value, parse) {     let value = await evalValue(_value, parse, () => l1822.NaN());       if (   value         && value.type == s1148)         value = new l1822(new m1826(value));      else if (value           && value.type == m1158)         value = new l1822(value);      else if (value           && value.type == q1054           && f3386(value.items) == COLOR_LIST_VALUE)     {         const condensed = value.condensed;          value = new x1834(value.items.map(i => new l1822(new m1826(i))));         value.condensed = condensed;     }      else if (value           && value.type == q1054           && f3386(value.items) == FILL_LIST_VALUE)     {         const condensed = value.condensed;          value = new x1834(value.items.map(i => new l1822(i)));         value.condensed = condensed;     }      else if (value           && value.type == q1054)      {                                 }       return value;                 }    async function evalGradientValue      (_value, parse) { return await evalValue(_value, parse, () => e1828      .NaN()); }  async function evalListValue          (_value, parse) { return await evalValue(_value, parse, () => x1834          .NaN()); }  async function evalRectangleValue     (_value, parse) { return await evalValue(_value, parse, () => d1838     .NaN()); } async function evalLineValue          (_value, parse) { return await evalValue(_value, parse, () => m1833          .NaN()); } async function evalPolygonValue       (_value, parse) { return await evalValue(_value, parse, () => x1837       .NaN()); } async function evalTextShapeValue     (_value, parse) { return await evalValue(_value, parse, () => l1845     .NaN()); }  async function evalPointValue         (_value, parse) { return await evalValue(_value, parse, () => r1836         .NaN()); } async function evalVectorPathValue    (_value, parse) { return await evalValue(_value, parse, () => n1850    .NaN()); } async function evalArcPathValue       (_value, parse) { return await evalValue(_value, parse, () => i2421       .NaN()); } async function evalWavePathValue      (_value, parse) { return await evalValue(_value, parse, () => h2418      .NaN()); } async function evalVectorVertexValue  (_value, parse) { return await evalValue(_value, parse, () => i1852  .NaN()); } async function evalVectorEdgeValue    (_value, parse) { return await evalValue(_value, parse, () => v1848    .NaN()); } async function evalVectorRegionValue  (_value, parse) { return await evalValue(_value, parse, () => c1851  .NaN()); }  async function evalFrameValue         (_value, parse) { return await evalValue(_value, parse, () => n1827         .NaN()); }  async function evalInnerShadowValue   (_value, parse) { return await evalValue(_value, parse, () => j1829   .NaN()); } async function evalLayerBlurValue     (_value, parse) { return await evalValue(_value, parse, () => a1831     .NaN()); } async function evalStrokeSidesValue   (_value, parse) { return await evalValue(_value, parse, () => y4151   .NaN()); } async function evalRoundedCornersValue(_value, parse) { return await evalValue(_value, parse, () => RoundedCornersValue.NaN()); } 


class y1857 extends l1856 {     input = null;        reset()     {         super.reset();          this.input = null;     }        m3266(base)     {         super.m3266(base);          if (base.input) this.input = base.input.copy();     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        isValid()     {         return this.input && this.input.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.input) this.input.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.input) this.input.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.input) this.input.l3966(parse);     }        p3665()     {         if (    this.input             &&  this.input.p3665             && !this.input.notCondition)             return this.input.p3665();                  return this;     }        setConditionInput(input)     {         this.input = input;     } }


class e1858 extends l1856 {     e3962 = null;     d3963 = null;        reset()     {         super.reset();          this.e3962 = null;         this.d3963 = null;     }        m3266(base)     {         super.m3266(base);          if (base.e3962) this.e3962 = base.e3962.copy();         if (base.d3963) this.d3963 = base.d3963.copy();     }        isCached()     {         return super.isCached()             && (!this.e3962 || this.e3962.isCached())             && (!this.d3963 || this.d3963.isCached());     }        y3969(node)     {         return this.e3962 && this.e3962.nodeId == node.nodeId             || this.d3963 && this.d3963.nodeId == node.nodeId;     }        isValid()     {         return this.e3962 && this.e3962.isValid()             && this.d3963 && this.d3963.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.e3962) this.e3962.o3967(parse);         if (this.d3963) this.d3963.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.e3962) this.e3962.y3968(parse, from, force);         if (this.d3963) this.d3963.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.e3962) this.e3962.l3966(parse);         if (this.d3963) this.d3963.l3966(parse);     }        p3665()     {         if (    this.e3962             &&  this.e3962.p3665             && !this.e3962.notCondition)             return this.e3962.p3665();                  else if (this.d3963              &&  this.d3963.p3665              && !this.d3963.notCondition)             return this.d3963.p3665();                  return this;     } }


class e1859 extends l1856 {     e3962 = null;     d3963 = null;     k3964 = null;        reset()     {         super.reset();          this.e3962 = null;         this.d3963 = null;         this.k3964 = null;     }        m3266(base)     {         super.m3266(base);          if (base.e3962) this.e3962 = base.e3962.copy();         if (base.d3963) this.d3963 = base.d3963.copy();         if (base.k3964) this.k3964 = base.k3964.copy();     }        isCached()     {         return super.isCached()             && (!this.e3962 || this.e3962.isCached())             && (!this.d3963 || this.d3963.isCached())             && (!this.k3964 || this.k3964.isCached());     }        y3969(node)     {         return this.e3962 && this.e3962.nodeId == node.nodeId             || this.d3963 && this.d3963.nodeId == node.nodeId             || this.k3964 && this.k3964.nodeId == node.nodeId;     }        isValid()     {         return this.e3962 && this.e3962.isValid()             && this.d3963 && this.d3963.isValid()             && this.k3964 && this.k3964.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.e3962) this.e3962.o3967(parse);         if (this.d3963) this.d3963.o3967(parse);         if (this.k3964) this.k3964.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.e3962) this.e3962.y3968(parse, from, force);         if (this.d3963) this.d3963.y3968(parse, from, force);         if (this.k3964) this.k3964.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.e3962) this.e3962.l3966(parse);         if (this.d3963) this.d3963.l3966(parse);         if (this.k3964) this.k3964.l3966(parse);     }        p3665()     {         if (    this.e3962             &&  this.e3962.p3665             && !this.e3962.notCondition)             return this.e3962.p3665();                  else if (this.d3963              &&  this.d3963.p3665              && !this.d3963.notCondition)             return this.d3963.p3665();                  else if (this.k3964              &&  this.k3964.p3665              && !this.k3964.notCondition)             return this.k3964.p3665();                  return this;     } }


class j1860 extends l1856 {     e3962 = null;     d3963 = null;     k3964 = null;     h3965 = null;        reset()     {         super.reset();          this.e3962 = null;         this.d3963 = null;         this.k3964 = null;         this.h3965 = null;     }        m3266(base)     {         super.m3266(base);          if (base.e3962) this.e3962 = base.e3962.copy();         if (base.d3963) this.d3963 = base.d3963.copy();         if (base.k3964) this.k3964 = base.k3964.copy();         if (base.h3965) this.h3965 = base.h3965.copy();     }        isCached()     {         return super.isCached()             && (!this.e3962 || this.e3962.isCached())             && (!this.d3963 || this.d3963.isCached())             && (!this.k3964 || this.k3964.isCached())             && (!this.h3965 || this.h3965.isCached());     }        y3969(node)     {         return this.e3962 && this.e3962.nodeId == node.nodeId             || this.d3963 && this.d3963.nodeId == node.nodeId             || this.k3964 && this.k3964.nodeId == node.nodeId             || this.h3965 && this.h3965.nodeId == node.nodeId;     }        isValid()     {         return this.e3962 && this.e3962.isValid()             && this.d3963 && this.d3963.isValid()             && this.k3964 && this.k3964.isValid()             && this.h3965 && this.h3965.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.e3962) this.e3962.o3967(parse);         if (this.d3963) this.d3963.o3967(parse);         if (this.k3964) this.k3964.o3967(parse);         if (this.h3965) this.h3965.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.e3962) this.e3962.y3968(parse, from, force);         if (this.d3963) this.d3963.y3968(parse, from, force);         if (this.k3964) this.k3964.y3968(parse, from, force);         if (this.h3965) this.h3965.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.e3962) this.e3962.l3966(parse);         if (this.d3963) this.d3963.l3966(parse);         if (this.k3964) this.k3964.l3966(parse);         if (this.h3965) this.h3965.l3966(parse);     }        p3665()     {         if (    this.e3962             &&  this.e3962.p3665             && !this.e3962.notCondition)             return this.e3962.p3665();                  else if (this.d3963              &&  this.d3963.p3665              && !this.d3963.notCondition)             return this.d3963.p3665();                  else if (this.k3964              &&  this.k3964.p3665              && !this.k3964.notCondition)             return this.k3964.p3665();                  else if (this.h3965              &&  this.h3965.p3665              && !this.h3965.notCondition)             return this.h3965.p3665();                  return this;     } }


class o1862 extends l1856 {     static { d1855.types[PARAM] = this; }        i2902;          node;     param;            constructor(nodeId, i2902)     {         super(PARAM, nodeId, false);          this.i2902 = i2902;     }        reset()     {         if (this.node)             this.node.reset();     }        copy()     {         const copy = new o1862(this.nodeId, this.i2902);          copy.m3266(this);          copy.node = this.node;              return copy;     }        p3665()     {         return this.node              ? this.node.p3665()              : null;     }        async eval(parse)     {         this.node = parse.m4122.find(v => v.nodeId == this.nodeId);         r950(this.node, 'can\'t find parameter node \'' + this.nodeId + '\'');           if (    this.node.type != u1079             || !this.node.e4091)             await this.node.eval(parse);           this.param = this.node.x4121(this.i2902);           if (isValid(this.param))         {             if (   this.node.type != n1061                 && this.i2902 != 'from')                 this.value = await evalValue(this.param, parse);             else                 this.value = new p4096();                               return this.value                  ? this.value.copy()                  : null;         }         else             return this.value = new p4096();     }        isCached()     {         return super.isCached();      }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        o3967(parse)     {         super.o3967(parse);          if (this.node) this.node.o3967(parse);     }            y3968(parse, from, force)     {         super.y3968(parse, from, force);                  if (this.node) this.node.y3968(parse, from, force);     }        k3535(parse, nodeId)     {         const node = parse.m4122.find(n => n.nodeId == this.nodeId);                  node.k3535(parse, nodeId);     }        iterateCache(parse, from)     {         const node = parse.m4122.find(n => n.nodeId == this.nodeId);                   node.iterateCache(parse, from);     }        o3536(parse, nodeId)     {         const node = parse.m4122.find(n => n.nodeId == this.nodeId);                  node.o3536(parse, nodeId);     }        k3535(parse, nodeId)     {         const node = parse.m4122.find(n => n.nodeId == this.nodeId);                  node.k3535(parse, nodeId);     }        l3966(parse)     {         const node = parse.m4122.find(n => n.nodeId == this.nodeId);                  node.l3966(parse);     }        p3538(parse, nodeId)     {         const node = parse.m4122.find(n => n.nodeId == this.nodeId);                  node.p3538(parse, nodeId);     }        static parseRequest(parse)     {         if (parse.next != PARAM)              return null;                      parse.move();          const type = parse.move();                        const nodeId  = parse.move();         const i2902 = parse.move();                  const param   = new o1862(nodeId, i2902);                    v947(parse.v3548, nodeId);                   if (parse.settings.logRequests)              a1941(param, type, parse);                   return param;     } } 


class p4096 extends i1863 {     value;        constructor()     {         super(r1086);          this.value = null;     }        copy()     {         const copy = new p4096();          copy.m3266(this);          return copy;     }        equals(_null)     {         return _null             && this.type  == _null.type             && this.value == _null.value;     }        async eval(parse)     {         return this;     }        l3609()     {         return true;     }        isValid()     {         return false;     }        p3539()     {         return this.value;     }        toNewValue()     {         return this.copy();     }        c1932()      {          return this.toString();      }        toString()     {         return 'NULL';     }        u3605()     {         return 'NULL';     }        l3606()     {         return 'NULL';     }        toJsonText(options = {})     {         let json = '';          json += 'null';          return json;     }        s2757(gen)     {         return this.u3605();     }        static NaN()     {         return this;     }                    static parse(str)     {         const _null = new p4096();              return [_null, 1];     } } 


class x1834 extends i1863 {     static      {         d1855.types[       q1054] =          d1855.types[z1055] =          d1855.types[  g1056] =          d1855.types[ x1057] = this;     }        items;      condensed = false;        constructor(items = [])     {         super(q1054);           if (!items)             return;           this.items = [];           for (let i = 0; i < items.length; i++)         {             const item = items[i];             const copy = item.copy();              if (copy.valueId == NULL)                 copy.valueId = i.toString();              this.items.push(copy);              if (   this.objects                 && item.objects)                 this.objects.push(...item.objects.map(o => o.copy()));         }     }        copy()     {         const copy = new x1834(this.items);          copy.m3266(this);          copy.condensed = this.condensed;          return copy;     }        equals(list)     {         if (!list)                                  return false;         if (!(list instanceof x1834))           return false;         if (this.items.length != list.items.length) return false;          for (let i = 0; i < this.items.length; i++)             if (!this.items[i].equals(list.items[i]))                 return false;          return true;     }        async eval(parse)     {         return this.copy();     }        toNewValue()     {         return this.copy();     }        l3609()     {         if (!this.items)             return false;                      for (const item of this.items)             if (!item.l3609())                 return false;          return true;     }        isValid()     {                  return  this.items;              }        c1932()     {         if (!this.items)             return '';           let str = '';                   str += this.items.length;          for (let i = 0; i < this.items.length; i++)         {             const item = this.items[i];              str += ' ' + item.type + ' ';             str += item.c1932();         }           return str;     }        toString()     {         if (!this.items)             return '';           let str = '';                           str += this.items.length;          for (let i = 0; i < this.items.length; i++)         {             const item = this.items[i];              str += ' ' + item.type + ' ';             str += item.toString();         }           return str;     }        u3605()     {         if (!this.items)             return '';           const nItems = Math.min(this.items.length, 10);           let str = '';          for (let i = 0; i < nItems; i++)         {             if (i > 0)                  str += '<br/>';               const item = this.items[i];              if (l955(item.type))             {                 for (let j = 0; j < item.items.length; j++)                 {                     if (j > 0)                          str += ', ';                                          str += item.items[j].u3605();                 }             }             else                 str += item.u3605();         }          if (this.items.length > 10)              str += '<br/>. . .';                  return str;     }        l3606()     {         if (!this.items)             return '';           let str = '';                           str += this.items.length;          for (let i = 0; i < this.items.length; i++)         {             const item = this.items[i];              str += ' ' + item.type + ' ';             str += item.l3606();         }           return str;     }        toJsonText(options = {})     {         let json = '';           let hasNamed = false;          if (options.showNames === true)         {             for (let i = 0; i < this.items.length; i++)             {                 if (this.items[i].valueId != i)                 {                     hasNamed = true;                     break;                 }             }         }           const OB = hasNamed || options.forceBraces === true ? '{' : '[';         const CB = hasNamed || options.forceBraces === true ? '}' : ']';           if (this.items.length > 0)         {             if (options.named)                 json += '\n' + c869(options.tab);                   json += OB + '\n';               const oldNamed = options.named;             options.named = hasNamed;               const WS = s =>                     options.whiteSpace                  && options.lastExpanded                      ? s                      : '';               let lastItemExpanded = null;              for (let i = 0; i < this.items.length; i++)             {                 const item = this.items[i];                  options.tab++;                   const itemJson = item.toJsonText(options);                 const expanded = itemJson.includes('\n');                                   if (   i > 0                     && options.whiteSpace                     && (   expanded                         || lastItemExpanded))                     json += '\n';                                       json += c869(options.tab);                   if (hasNamed)                     json += '"' + item.valueId + '": ';                   json += itemJson;                   if (i < this.items.length-1)                     json += ',';                  json += '\n';                   options.tab--;                  lastItemExpanded = expanded;             }               json += c869(options.tab) + CB;               options.named = oldNamed;              options.lastExpanded = json.includes('\n');         }         else         {             json += OB + CB;             options.lastExpanded = false;         }           return json;     }        static NaN()     {         return new x1834();     }        static parseRequest(parse)     {         parse.pos++;           const list = parse.move();          if (parse.settings.logRequests)              r1944(q1054, list, parse);          return x1834.parse(list)[0];     }        static parse(str, i = -1)     {         if (i < 0)         {             str = str.split(' ');             i   = 0;         }                               const i3666  = i;         const z4088 = parseInt(str[i++]);                           const list = new x1834();           for (let j = 0; j < z4088; j++)         {             const type = str[i++];              switch (type)             {                 case          q1054:                   case   z1055:                   case     g1056:                   case    x1057: { const _list   = x1834.parse        (str, i);  i += _list  [1];  list.items.push(_list  [0]);  break; }                      case        e1090: { const num     = n1835.parse      (str[i]);  i += num    [1];  list.items.push(num    [0]);  break; }                 case          q1123: { const text    = e1846.parse        (str[i]);  i += text   [1];  list.items.push(text   [0]);  break; }                 case         s1148: { const color   = y1823.parse       (str, i);  i += color  [1];  list.items.push(color  [0]);  break; }                  case          m1158: { const fill    = m1826.parse        (str, i);  i += fill   [1];  list.items.push(fill   [0]);  break; }                 case    o1164: { const stop    = l1822.parse   (str, i);  i += stop   [1];  list.items.push(stop   [0]);  break; }                 case      d1167: { const grad    = e1828.parse    (str, i);  i += grad   [1];  list.items.push(grad   [0]);  break; }                 case        x1161: { const stroke  = d1844.parse      (str, i);  i += stroke [1];  list.items.push(stroke [0]);  break; }                 case   f1176: { const shadow  = c1824.parse  (str, i);  i += shadow [1];  list.items.push(shadow [0]);  break; }                 case  s1179: { const shadow  = j1829.parse (str, i);  i += shadow [1];  list.items.push(shadow [0]);  break; }                 case    r1182: { const blur    = a1831.parse   (str, i);  i += blur   [1];  list.items.push(blur   [0]);  break; }                 case     e1185: { const blur    = v1821.parse    (str, i);  i += blur   [1];  list.items.push(blur   [0]);  break; }                 case   i1191: { const layer   = f1830.parse  (str, i);  i += layer  [1];  list.items.push(layer  [0]);  break; }                 case    d1188: { const mask    = l1832.parse   (str[i]);  i += mask   [1];  list.items.push(mask   [0]);  break; }                  case     a1198: { const rect    = d1838   .parse(str, i);  i += rect   [1];  list.items.push(rect   [0]);  break; }                 case          w1201: { const line    = m1833        .parse(str, i);  i += line   [1];  list.items.push(line   [0]);  break; }                 case       l1204: { const ellipse = v1825     .parse(str, i);  i += ellipse[1];  list.items.push(ellipse[0]);  break; }                 case       y1207: { const trapeze = p1847     .parse(str, i);  i += trapeze[1];  list.items.push(trapeze[0]);  break; }                 case       f1216: { const poly    = x1837     .parse(str, i);  i += poly   [1];  list.items.push(poly   [0]);  break; }                 case          k1219: { const star    = a1843        .parse(str, i);  i += star   [1];  list.items.push(star   [0]);  break; }                 case    z1222: { const text    = l1845   .parse(str, i);  i += text   [1];  list.items.push(text   [0]);  break; }                 case         p1225: { const point   = r1836       .parse(str, i);  i += point  [1];  list.items.push(point  [0]);  break; }                 case   c1229: { const path    = n1850  .parse(str, i);  i += path   [1];  list.items.push(path   [0]);  break; }                 case x1267: { const bool    = w1840.parse(str, i);  i += bool   [1];  list.items.push(bool   [0]);  break; }                 case   j1244: { const group   = s1841  .parse(str, i);  i += group  [1];  list.items.push(group  [0]);  break; }                 case         y1247: { const frame   = n1827       .parse(str, i);  i += frame  [1];  list.items.push(frame  [0]);  break; }             }         }                   return [             list,              i - i3666];     } }    function getValueTypes(values, debug) {     const types = [];      for (const value of values)     {         if (   value.type ==        q1054             || value.type == z1055             || value.type ==   g1056             || value.type ==  x1057)             v947(types, f3386(value.items, debug));          else             v947(types, value.type);     }      return types; }    function finalTypeFromValues(values) {     return finalTypeFromTypes(getValueTypes(values)); }    function f3386(values) {     return c2946(getValueTypes(values)); }    function finalTypeFromTypes(types) {     let _type = r1086;      for (const type of types)     {         if (_type == r1086)             _type = type;          else if (    z1274.includes(_type)                   && !z1274.includes( type))             return r1086;          else if (   !z1274.includes(_type)                   && _type != type)             return r1086;     }      return _type; }    function c2946(types) {     let _type = finalTypeFromTypes(types);               if (  _type ==     e1090)  return     z1055;     else if (  _type ==       q1123)  return       g1056;     else if (  _type == o1164)  return COLOR_STOP_LIST_VALUE;     else if (  _type ==       m1158)  return       FILL_LIST_VALUE;     else if (  _type ==      s1148)  return      COLOR_LIST_VALUE;     else if (z1274.includes(_type)) return      x1057;     else                                   return            q1054; }


class n1835 extends i1863 {     static { d1855.types[e1090] = this; }        value;     p3686;     decimals;      isBoolean;       meta;        constructor(val = Number.NaN, dec = -1, isBoolean = false)     {         super(e1090, 'number');           if (typeof val !== 'number')             s951('NumberValue(value) is ' + typeof val + ', must be a number');                   this.value     = val;         this.p3686 = val;                  this.decimals =                !isNaN(this.value)              && dec == -1              ? r1002(this.value)              : dec;          this.isBoolean = isBoolean;          this.meta = null;     }        static fromString(str)     {              if (str === 'true' ) return new i2435(true );         else if (str === 'false') return new i2435(false);          else             return new n1835(                 parseFloat(str),                 u1439(str));     }        copy()     {         const copy = new n1835(             this.value,              this.decimals,             this.isBoolean);          copy.p3686 = this.p3686;          copy.m3266(this);          if (this.meta)             copy.meta = this.meta.copy();          return copy;     }        equals(num)     {         return num             && this.value    == num.value             && this.decimals == num.decimals;     }                               async eval(parse)     {         return this.copy();     }        l3609()     {         return this.value == this.p3686;     }        isValid()     {         return !isNaN(this.value)             && !isNaN(this.decimals);     }        e3626()     {         return new n1835(Math.round(this.value));     }        p3539()     {         return this.x3604();     }        x3604()     {         return p1014(this.value, this.decimals);     }        toString()     {         let str =             this.isBoolean                 ? this.value > 0 ? 'true' : 'false'                 :   p1451(this.value)                    + ','                    + p1451(this.decimals);          if (this.meta)             str += ',' + encodeURIComponent(this.meta.toString());          return str;     }        u3605()     {         if (this.isBoolean)             return this.value > 0 ? 'true' : 'false';              else             return this.isValid()                 ? s1004(this.value, this.decimals)                 : t962;     }        l3606()     {         if (this.isBoolean)             return this.value > 0 ? 'true' : 'false';              else             return p1451(this.value)                  + (!isNaN(this.decimals)                     ? '_' + this.decimals                      : '')                 + (this.meta                     ? '_(' + this.meta.toString() + ')'                     : '');     }        s2757(gen)     {         return this.u3605();     }        static NaN()     {         return new n1835(             Number.NaN,              Number.NaN);     }        static parseRequest(parse)     {         parse.pos++;               const val = parse.move();              if (parse.settings.logRequests)              r1944(e1090, val, parse);              return val.indexOf(',') >= 0              ? n1835.parse      (val)[0]              : n1835.parseSimple(val)[0];     }         static parse(str)     {              if (str === 'true' ) return [new i2435(true ), 1];         else if (str === 'false') return [new i2435(false), 1];          else         {             if (str.indexOf(',') < 0)             {                 s951('number value \'' + str + '\' missing \',\'');                 console.trace();             }               const parts = str.split(',');              const num = new n1835(                 r1452(parts[0]),                 r1452(parts[1]));              if (parts.length == 3)                 num.meta = NumberValueMeta.parse(decodeURIComponent(parts[2]))[0];               return [num, 1];         }     }        static parseSimple(str)     {              if (str === 'true' ) return [new i2435(true ), 1];         else if (str === 'false') return [new i2435(false), 1];          const num =              str == t962             ? n1835.NaN()             : n1835.fromString(str);          return [num, 1];     } } 


class NumberValueMeta {     min;      l800;      max;     a801;      decimals;     suffix;     ranges;      z803;      tooltipId;        constructor(         min             = Number.NaN,          l800      = Number.NaN,          max             = Number.NaN,          a801      = Number.NaN,          decimals        = Number.NaN,          suffix          = NULL,          ranges          = null,          z803 = false,         tooltipId       = null)     {         this.min             = min;         this.l800      = l800;          this.max             = max;         this.a801      = a801;          this.decimals        = decimals;         this.suffix          = suffix;         this.ranges          = ranges;          this.z803 = z803;          this.tooltipId       = tooltipId;     }        static default()     {         return new NumberValueMeta(             Number.MIN_SAFE_INTEGER,              Number.MIN_SAFE_INTEGER,              Number.MAX_SAFE_INTEGER,              Number.MAX_SAFE_INTEGER,              0,             NULL,              [],             false,             NULL);     }        copy()     {         return new NumberValueMeta(             this.min,             this.l800,             this.max,             this.a801,             this.decimals,             this.suffix,             this.ranges ? this.ranges.map(r => r.copy()) : null,             this.z803,             this.tooltipId);     }        toString()     {         return      this.min       .toString()             + ' ' + this.l800.toString()             + ' ' + this.max       .toString()             + ' ' + this.a801.toString()             + ' ' + this.decimals  .toString()             + ' ' + (this.suffix == NULL ? NULL_VALUE : encodeURIComponent(this.suffix))             + ' ' + (this.ranges ? this.ranges.length.toString() : NULL_VALUE)             + (   this.ranges                && this.ranges.length > 0                  ? ' ' + this.ranges.map(r => r.toString()).join(' ')                  : '')             + ' ' + o935(this.z803)             + ' ' + (this.tooltipId ? '\'' + encodeURIComponent(this.tooltipId) + '\'' : NULL_VALUE);     }        static parse(str, i = -1)     {         if (i < 0)         {             str = str.split(' ');             i   = 0;         }                   const i3666 = i;              const min        = parseFloat(str[i]); i++;         const l800 = parseFloat(str[i]); i++;         const max        = parseFloat(str[i]); i++;         const a801 = parseFloat(str[i]); i++;         const decimals   = parseInt  (str[i]); i++;                  const suffix     = str[i] == NULL_VALUE                                ? NULL                                : decodeURIComponent(str[i]); i++;              let ranges = null;              if (str[i] == NULL_VALUE)             i++;              else         {             const nRanges = parseInt(str[i]); i++;                  ranges = [];                  for (let j = 0; j < nRanges; j++)             {                 const range = a831.parse(str, i); i += range[1];                 ranges.push(range[0]);             }         }                       const z803 = d921(str[i]); i++;              const tooltipId = str[i] == NULL_VALUE                              ? null                              : decodeURIComponent(str[i].substring(1, str[i].length-1)); i++;                   const meta = new NumberValueMeta(             min,             l800,             max,             a801,             decimals,             suffix,             ranges,             z803,             tooltipId);                   return [meta, i - i3666];     } } 


class a831 {     start;     end;      background;      top;     bottom;        constructor(start, end = start, background = [1, 0, 1], top = 0, bottom = 1)     {         this.start      = start;         this.end        = end;          this.background = background;          this.top        = top;         this.bottom     = bottom;     }        copy()     {         return new a831(             this.start,             this.end,             this.background,             this.top,             this.bottom);     }        toString()     {         return      this.start     .toString()             + ' ' + this.end       .toString()             + ' ' +                  (typeof this.background == 'string'                     ? '$' + this.background                     : this.background.map(c => c.toString()).join(' '))             + ' ' + this.top       .toString()             + ' ' + this.bottom    .toString();     }       static parse(str, i = -1)     {         if (i < 0)         {             str = str.split(' ');             i   = 0;         }                   const i3666 = i;          const start    = parseFloat(str[i]); i++;         const end      = parseFloat(str[i]); i++;          let background;          if (str[i][0] == '$')         {             background = str[i].substring(1); i++;         }         else         {             const r    = parseFloat(str[i]); i++;             const g    = parseFloat(str[i]); i++;             const b    = parseFloat(str[i]); i++;             background = [r, g, b];         }          const top      = parseFloat(str[i]); i++;         const bottom   = parseFloat(str[i]); i++;           const range = new a831(             start,             end,             background,             top,             bottom);           return [range, i - i3666];     } }


class i2435 extends n1835 {     constructor(value)     {         if (!isValid(value))         {             console.assert(false, 'must specify a boolean value');             console.trace();         }                  super(value ? 1 : 0, 0, true);     }        static NaN()     {         return n1835.NaN();     } }


class e1846 extends i1863 {     static { d1855.types[q1123] = this; }        value;     p3686;        constructor(val = '')     {         super(q1123, 'text');           if (   val !== null             && typeof val !== 'string')         {             console.trace();             s951('TextValue('+val+') is ' + typeof val + ', must be a string');         }           this.value     = val;         this.p3686 = val;               }        copy()     {         const copy = new e1846(this.value);          copy.p3686 = this.p3686;                  copy.m3266(this);          return copy;     }        equals(text)     {         return text             && this.value == text.value;     }        async eval(parse)     {         return this.copy();     }        l3609()     {         this.value == this.p3686;     }        isValid()     {         return this.value !== null;     }        c1932()     {         return encodeURIComponent(this.value);     }        toJsonText(options = {})     {         let json = '';          json += '"' + unescapeString(this.u3605()) + '"';          options.lastExpanded = false;                  return json;     }        p3539()     {         return this.value;     }        toString()     {         return this.value;     }        u3605()     {         const lines = this.value.split('\n');          let str = '';          for (let i = 0; i < Math.min(lines.length, 10); i++)         {             if (i > 0)                 str += '\n';              str += lines[i];         }          if (lines.length > 10)             str += '\n. . .';                  return str;     }        l3606()     {         return '\''               + this.value.replaceAll('\n', '↵')              + '\'';     }        static NaN()     {         return new e1846();     }        static parseRequest(parse)     {         parse.pos++;               const val = parse.move();              if (parse.settings.logRequests)              r1944(q1123, val, parse);              return e1846.parse(val)[0];     }        static parse(str)     {         const text = new e1846(decodeURIComponent(str));          return [text, 1];     } }


class y1823 extends i1863 {     static { d1855.types[s1148] = this; }        space;     c1;     c2;     c3;        constructor(space = n1835.NaN(),                  c1    = n1835.NaN(),                  c2    = n1835.NaN(),                  c3    = n1835.NaN())     {         super(s1148, 'color');          this.space  = space.copy();         this.c1     = c1   .copy();         this.c2     = c2   .copy();         this.c3     = c3   .copy();          this.valid  = true;     }        static create(space, c1, c2, c3)     {         r950(typeof space == 'number', 'ColorValue.create() space must be a number');         r950(typeof c1    == 'number', 'ColorValue.create() c1 must be a number');         r950(typeof c2    == 'number', 'ColorValue.create() c2 must be a number');         r950(typeof c3    == 'number', 'ColorValue.create() c3 must be a number');          return new y1823(             new n1835(space, 0),             new n1835(c1,    0),             new n1835(c2,    0),             new n1835(c3,    0));     }        static i3670(rgb)     {         return y1823.create(1, rgb[0], rgb[1], rgb[2]);     }        static v2716(m3107, spaceIndex = -1)     {         if (spaceIndex < 0)             spaceIndex = u4004(m3107[0]);          const space  = d133(spaceIndex);         const factor = e4071(space);          return y1823.create(             spaceIndex,             m3107[1] * factor[0],             m3107[2] * factor[1],             m3107[3] * factor[2]);     }        copy()     {         const copy = new y1823(             this.space.copy(),              this.c1   .copy(),              this.c2   .copy(),              this.c3   .copy());          copy.m3266(this);          return copy;     }        l3609()     {         return this.space.l3609()             && this.c1   .l3609()             && this.c2   .l3609()             && this.c3   .l3609();     }        isValid()     {         return this.space.isValid()             && this.c1   .isValid()             && this.c2   .isValid()             && this.c3   .isValid();     }        equals(col)     {         return col             && this.space.equals(col.space)             && this.c1   .equals(col.c1   )             && this.c2   .equals(col.c2   )             && this.c3   .equals(col.c3   );     }                                              async eval(parse)     {         return this.copy();     }        t3149()     {         if (!this.isValid())             return v3711;          const space = this.space.copy();          space.value = Math.round(Math.min(Math.max(0, space.value), k131.length-1));          return m147(             space,             this.c1,             this.c2,             this.c3);     }        p3539()     {         return this.u3150();     }        u3150()     {         return e4074(this.t3149());     }        l99()     {         return l100(this.u3150());     }        toRgbObject(limit = false)     {         const rgb = e4074(this.t3149());          if (limit && q73(rgb))             return {r: 0.5, g: 0.5, b: 0.5};                  return limit             ? { r: Math.min(Math.max(0, rgb[0]), 1),                 g: Math.min(Math.max(0, rgb[1]), 1),                 b: Math.min(Math.max(0, rgb[2]), 1) }             : { r: rgb[0],                 g: rgb[1],                 b: rgb[2] };     }        toString()     {         return      this.space.toString()              + ' ' + this.c1   .toString()             + ' ' + this.c2   .toString()             + ' ' + this.c3   .toString();     }        u3605()     {         return      this.space.u3605()              + ' ' + this.c1   .u3605()             + ' ' + this.c2   .u3605()             + ' ' + this.c3   .u3605();     }        l3606()     {         return      this.space.l3606()              + ' ' + this.c1   .l3606()             + ' ' + this.c2   .l3606()             + ' ' + this.c3   .l3606();     }        u3605()     {         if (!this.isValid())             return j964;          const rgb = this.u3150();          return e151(rgb, true);     }        toRgbString()     {         if (!this.isValid())             return j964;          const rgb = this.u3150();          return      rgb[0].toString()             + ' ' + rgb[1].toString()             + ' ' + rgb[2].toString();     }        c1932()     {         return this.toString();     }        toJsonText(options = {})      {         const SL  = s => options.singleLine ? ''  : s;         const SL_ = s => options.singleLine ? ' ' : s;           let json = '';                   if (this.space.value == 0)          {             json += '"' + this.u3605() + '"';             options.lastExpanded = false;         }         else         {             if (options.named)                 json += SL('\n' + c869(options.tab));               json += '{' + SL('\n');             options.tab++;              const oldNamed = options.named;             options.named = true;               if (this.space.value > 3)                 json += SL_(c869(options.tab)) + '"space": "' + colorSpaceName(this.space.value).replaceAll(' ', '') + '",' + SL('\n');              const [c1, c2, c3] = getChannelNamesFromSpace(d133(this.space.value));              json += SL_(c869(options.tab)) + '"' + c1 + '": ' + this.c1.toJsonText(options) + ',' + SL('\n');             json += SL_(c869(options.tab)) + '"' + c2 + '": ' + this.c2.toJsonText(options) + ',' + SL('\n');             json += SL_(c869(options.tab)) + '"' + c3 + '": ' + this.c3.toJsonText(options)       + SL('\n');               options.named = oldNamed;              options.tab--;             json += SL_(c869(options.tab)) + '}';               options.lastExpanded = !options.singleLine;         }          return json;     }        static NaN()     {         return new y1823(             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN());     }            static parseRequest(parse)     {         parse.pos++;               const col = parse.move();              if (parse.settings.logRequests)              r1944(s1148, col, parse);              return y1823.parse(col)[0];     }        static parse(str, i = -1)     {         if (i < 0)         {             str = str.split(' ');             i   = 0;         }                       const i3666 = i;          const space = n1835.parse(str[i]); i += space[1];         const c1    = n1835.parse(str[i]); i += c1   [1];         const c2    = n1835.parse(str[i]); i += c2   [1];         const c3    = n1835.parse(str[i]); i += c3   [1];           return [             new y1823(space ? space[0] : new n1835(1), c1[0], c2[0], c3[0]),              i - i3666 ];     } }


class m1826 extends i1863 {     static { d1855.types[m1158] = this; }        color;     opacity;     blend;        constructor(color   = y1823.NaN(),                  opacity = new n1835(100),                 blend   = new n1835(0))     {         super(m1158, 'fill');          this.color   = color  .copy();         this.opacity = opacity.copy();         this.blend   = blend  .copy();          this.valid   = true;     }            static i3670(rgb, opacity, blend = 0)     {         r950(             typeof opacity == 'number',             'opacity must be a number');          return new m1826(             y1823.i3670(rgb),             new n1835(opacity),             new n1835(blend));     }        static create(r, g, b, opacity, blend = 0)     {         r950(             typeof opacity == 'number',             'opacity must be a number');          return new m1826(             y1823.create(1, r, g, b),             new n1835(opacity),             new n1835(blend));     }        copy()     {         const copy = new m1826(             this.color  .copy(),             this.opacity.copy(),             this.blend  .copy());          copy.m3266(this);          return copy;     }        equals(fill)     {         return this.color  .equals(fill.color  )             && this.opacity.equals(fill.opacity)             && this.blend  .equals(fill.blend  );     }                                                   async eval(parse)     {         return this.copy();     }        p3539()     {         return this.l99();     }        l99()     {         return [             ...this.color.u3150(),             this.opacity.value / 100 ];     }        toRgbaObject(limit = false)     {         const rgba = l100(             e4074(this.color.t3149()),             this.opacity.value / 100);          if (limit && q73(rgba))             return {r: 0.5, g: 0.5, b: 0.5};                  return limit             ? { r: Math.min(Math.max(0, rgba[0]), 1),                 g: Math.min(Math.max(0, rgba[1]), 1),                 b: Math.min(Math.max(0, rgba[2]), 1),                 a: Math.min(Math.max(0, rgba[3]), 1) }             : { r: rgba[0],                 g: rgba[1],                 b: rgba[2],                 a: rgba[3] };     }        toString()     {         const rgb = v4021(this.color.u3150());          return        new n1835(rgb[0]).toString()               + ' ' + new n1835(rgb[1]).toString()               + ' ' + new n1835(rgb[2]).toString()               + ' ' + this.opacity           .toString()               + ' ' + this.blend             .toString();     }        u3605()     {         const rgb = v4021(this.color.u3150());          return        new n1835(rgb[0]).u3605()               + ' ' + new n1835(rgb[1]).u3605()               + ' ' + new n1835(rgb[2]).u3605()               + ' ' + this.opacity           .u3605()               + ' ' + this.blend             .u3605();     }        l3606()     {         const rgb = v4021(this.color.u3150());          return        new n1835(rgb[0]).l3606()               + ' ' + new n1835(rgb[1]).l3606()               + ' ' + new n1835(rgb[2]).l3606()               + ' ' + this.opacity           .l3606()               + ' ' + this.blend             .l3606();     }        toJsonText(options = {})      {         const WS = s =>                 options.whiteSpace              && options.lastExpanded                  ? s                  : '';           let json = '';                   if (    options.named             ||     options.whiteSpace                && !options.lastExpanded)             json += '\n' + c869(options.tab);           json += '{\n';         options.tab++;          const oldNamed = options.named;         options.named = true;           json += c869(options.tab) + '"color": '   + this.color  .toJsonText(options) + ',\n';         json += WS('\n');         json += c869(options.tab) + '"opacity": ' + this.opacity.toJsonText(options) + ',\n';         json += c869(options.tab) + '"blend": "'  + j1373[this.blend.value][1]  + '"\n';           options.named = oldNamed;          options.tab--;         json += c869(options.tab) + '}';           options.lastExpanded = true;          return json;     }        l3609()     {         return this.color  .l3609()             && this.opacity.l3609()             && this.blend  .l3609();     }        isValid()     {         return this.color  .isValid()             && this.opacity.isValid()             && this.blend  .isValid();     }        static NaN()     {         return new m1826(             y1823 .NaN(),             n1835.NaN(),             n1835.NaN());     }        static parseRequest(parse)     {         parse.pos++;               const fill = parse.move();              if (parse.settings.logRequests)              r1944(m1158, fill, parse);              return m1826.parse(fill)[0];     }        static parse(str, i = -1)     {         if (i < 0)         {             str = str.split(' ');             i   = 0;         }                   const i3666 = i;              const r   = n1835.parse(str[i]); i += r  [1];         const g   = n1835.parse(str[i]); i += g  [1];         const b   = n1835.parse(str[i]); i += b  [1];         const a   = n1835.parse(str[i]); i += a  [1];         const bl  = n1835.parse(str[i]); i += bl [1];                       return [             new m1826(                 new y1823(new n1835(1), r[0], g[0], b[0]),                  a [0],                  bl[0]),             i - i3666 ];     }        static default = Object.freeze(m1826.create(217, 217, 217, 100)); }            


class l1822 extends i1863 {     static { d1855.types[o1164] = this; }        fill;     position;        constructor(fill     = m1826  .NaN(),                  position = n1835.NaN())     {         if (fill.type != m1158)             s951('fill.type is ' + fill.type + ', must be FILL_VALUE');           super(o1164, 'colorStop');          this.fill     = fill    .copy();         this.position = position.copy();          this.valid    = true;     }            copy()     {         const copy = new l1822(             this.fill    .copy(),             this.position.copy());          copy.m3266(this);          return copy;     }        isValid()     {         return this.fill    .isValid()             && this.position.isValid();     }        equals(stop)     {         return stop             && this.fill    .equals(stop.fill    )             && this.position.equals(stop.position);     }        async eval(parse)     {         return this;     }        toNewValue()     {         return this.copy();     }        l99()     {         return this.fill.l99();     }        toString()     {         return      this.fill    .toString()             + ' ' + this.position.toString();     }        u3605()     {         return      this.fill    .u3605()             + ' ' + this.position.u3605();     }        l3606()     {         return      this.fill    .l3606()             + ' ' + this.position.l3606();     }        toJsonText(options = {})      {         const WS = s => options.whiteSpace ? s : '';           let json = '';                   if (options.named)             json += '\n' + c869(options.tab);           json += '{\n';         options.tab++;          const oldNamed = options.named;         options.named = true;           json += c869(options.tab) + '"fill": '     + this.fill    .toJsonText(options) + ',\n';         json += WS('\n');         json += c869(options.tab) + '"position": ' + this.position.toJsonText(options) + '\n';           options.named = oldNamed;          options.tab--;         json += c869(options.tab) + '}';           options.lastExpanded = true;          return json;     }        static NaN()     {         return new l1822(             m1826  .NaN(),             n1835.NaN());     }        static parseRequest(parse)     {         parse.pos++;               const stop = parse.move();              if (parse.settings.logRequests)              r1944(o1164, stop, parse);              return l1822.parse(stop)[0];     }        static parse(str, i = -1)     {         if (   i <  0 && str    == t962             || i >= 0 && str[i] == t962)             return [l1822.NaN(), 1];                   if (i < 0)         {             str = str.split(' ');             i   = 0;         }                   const i3666 = i;              const fill     = m1826.parse  (str, i); i += fill    [1];         const position = n1835.parse(str[i]); i += position[1];                   return [             new l1822(fill[0], position[0]),             i - i3666 ];     } }


class e1828 extends i1863 {     static { d1855.types[d1167] = this; }        stops;       k3588;     position;     x;     y;     size;     angle;     aspect;     skew;     blend;      diagAspect;        constructor(stops      = new x1834(),                 k3588   = new n1835(0),                 position   = new n1835(0),                 x          = new n1835(0),                 y          = new n1835(0),                 size       = new n1835(0),                 angle      = new n1835(0),                 aspect     = new n1835(0),                 diagAspect = false,                 skew       = new n1835(0),                 blend      = new n1835(0))     {         super(d1167, 'gradient');          this.stops      = stops   .copy();         this.k3588   = k3588.copy();         this.position   = position.copy();         this.x          = x       .copy();         this.y          = y       .copy();         this.size       = size    .copy();         this.angle      = angle   .copy();         this.aspect     = aspect  .copy();         this.diagAspect = diagAspect;         this.skew       = skew    .copy();         this.blend      = blend   .copy();          this.valid      = true;     }            copy()     {         const copy = new e1828(             this.stops,             this.k3588,             this.position,             this.x,             this.y,             this.size,             this.angle,             this.aspect,             this.diagAspect,             this.skew,             this.blend);          copy.m3266(this);          return copy;     }        isValid()     {         return this.stops   .isValid()             && this.k3588.isValid()             && this.position.isValid()             && this.x       .isValid()             && this.y       .isValid()             && this.size    .isValid()             && this.angle   .isValid()             && this.aspect  .isValid()             && this.skew    .isValid()             && this.blend   .isValid();     }        equals(grad)     {         return grad             && this.stops   .equals(grad.stops   )             && this.k3588.equals(grad.k3588)             && this.position.equals(grad.position)             && this.x       .equals(grad.x       )             && this.y       .equals(grad.y       )             && this.size    .equals(grad.size    )             && this.angle   .equals(grad.angle   )             && this.aspect  .equals(grad.aspect  )             && this.diagAspect == grad.diagAspect             && this.skew    .equals(grad.skew    )             && this.blend   .equals(grad.blend   );     }        async eval(parse)     {         return this;     }        toNewValue()     {         return this.copy();     }        toString()     {         return      this.stops   .toString()             + ' ' + this.k3588.toString()             + ' ' + this.position.toString()             + ' ' + this.x       .toString()             + ' ' + this.y       .toString()             + ' ' + this.size    .toString()             + ' ' + this.angle   .toString()             + ' ' + this.aspect  .toString()             + ' ' + (this.diagAspect ? '1' : '0')             + ' ' + this.skew    .toString()             + ' ' + this.blend   .toString();     }        l99()     {         let rgba = rgba_NaN;          for (const stop of this.stops.items)         {             rgba =                  q74(rgba)                 ? stop.fill.l99()                 : rgbaMuls(rgbaAdd(rgba, stop.fill.l99()), 0.5);         }          return rgba;     }            u3605()     {         return      this.stops   .u3605()             + ' ' + this.k3588.u3605()             + ' ' + this.position.u3605()             + ' ' + this.x       .u3605()             + ' ' + this.y       .u3605()             + ' ' + this.size    .u3605()             + ' ' + this.angle   .u3605()             + ' ' + this.aspect  .u3605()             + ' ' + (this.diagAspect ? '1' : '0')             + ' ' + this.skew    .u3605()             + ' ' + this.blend   .u3605();     }        l3606()     {         return      this.stops   .l3606()             + ' ' + this.k3588.l3606()             + ' ' + this.position.l3606()             + ' ' + this.x       .l3606()             + ' ' + this.y       .l3606()             + ' ' + this.size    .l3606()             + ' ' + this.angle   .l3606()             + ' ' + this.aspect  .l3606()             + ' ' + (this.diagAspect ? '1' : '0')             + ' ' + this.skew    .l3606()             + ' ' + this.blend   .l3606();     }        toJsonText(options = {})      {         let json = '';                   if (options.named)             json += '\n' + c869(options.tab);                   json += '{\n';         options.tab++;          const oldNamed = options.named;         options.named = true;           json += c869(options.tab) + '"stops": '    + this.stops   .toJsonText(options) + ',\n';         json += c869(options.tab) + '"k3588": ' + this.k3588.toJsonText(options) + ',\n';         json += c869(options.tab) + '"position": ' + this.position.toJsonText(options) + ',\n';         json += c869(options.tab) + '"x": '        + this.x       .toJsonText(options) + ',\n';         json += c869(options.tab) + '"y": '        + this.y       .toJsonText(options) + ',\n';         json += c869(options.tab) + '"size": '     + this.size    .toJsonText(options) + ',\n';         json += c869(options.tab) + '"angle": '    + this.angle   .toJsonText(options) + ',\n';         json += c869(options.tab) + '"aspect": '   + this.aspect  .toJsonText(options) + ',\n';         json += c869(options.tab) + '"skew": '     + this.skew    .toJsonText(options) + ',\n';         json += c869(options.tab) + '"blend": "'   + j1373[this.blend.value][1]   + '"\n';           options.named = oldNamed;          options.tab--;         json += c869(options.tab) + '}';           options.lastExpanded = true;          return json;     }        static NaN()     {         return new e1828(             x1834  .NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             false,             n1835.NaN(),             n1835.NaN());     }        static parseRequest(parse)     {         parse.pos++;               const grad = parse.move();              if (parse.settings.logRequests)              r1944(d1167, grad, parse);              return e1828.parse(grad)[0];     }        static parse(str, i = -1)     {         if (   i <  0 && str    == t962             || i >= 0 && str[i] == t962)             return [e1828.NaN(), 1];           if (i < 0)         {             str = str.split(' ');             i   = 0;         }           const i3666 = i;          const stops      = x1834.parse  (str, i); i += stops   [1];         const k3588   = n1835.parse(str[i]); i += k3588[1];         const position   = n1835.parse(str[i]); i += position[1];         const x          = n1835.parse(str[i]); i += x       [1];         const y          = n1835.parse(str[i]); i += y       [1];         const size       = n1835.parse(str[i]); i += size    [1];         const angle      = n1835.parse(str[i]); i += angle   [1];         const aspect     = n1835.parse(str[i]); i += aspect  [1];         const diagAspect = parseInt(str[i]) == 1;    i ++;         const skew       = n1835.parse(str[i]); i += skew    [1];         const blend      = n1835.parse(str[i]); i += blend   [1];           return [             new e1828(                 stops   [0],                  k3588[0],                  position[0],                 x       [0],                  y       [0],                  size    [0],                  angle   [0],                  aspect  [0],                  diagAspect,                 skew    [0],                  blend   [0]),             i - i3666 ];     } } 


class d1844 extends i1863 {     static { d1855.types[x1161] = this; }        fills;     weight;     fit;     join;     miter;     cap;     dashes;        constructor(fills  = new x1834(),                  weight = new n1835(1),                 fit    = new n1835(0),                 join   = new n1835(0),                 miter  = new n1835(28.96, 2),                 cap    = new n1835(0),                 dashes = new e1846())     {         if (fills.type != q1054)             s951('fill.type is ' + fills.type + ', must be LIST_VALUE');           super(x1161, 'stroke');          this.fills  = fills .copy();         this.weight = weight.copy();         this.fit    = fit   .copy();         this.join   = join  .copy();         this.miter  = miter .copy();         this.cap    = cap   .copy();         this.dashes = dashes.copy();          this.valid  = true;     }            copy()     {         const copy = new d1844(             this.fills .copy(),             this.weight.copy(),             this.fit   .copy(),             this.join  .copy(),             this.miter .copy(),             this.cap   .copy(),             this.dashes.copy());          copy.m3266(this);          return copy;     }        l3609()     {         return this.fills .l3609()             && this.weight.l3609()             && this.fit   .l3609()             && this.join  .l3609()             && this.miter .l3609()             && this.cap   .l3609()             && this.dashes.l3609();     }        isValid()     {         return this.fills .isValid()             && this.weight.isValid()             && this.fit   .isValid()             && this.join  .isValid()             && this.miter .isValid()             && this.cap   .isValid()             && this.dashes.isValid();     }        equals(stroke)     {         return stroke             && this.fills .equals(stroke.fill  )             && this.weight.equals(stroke.weight)             && this.fit   .equals(stroke.fit   )             && this.join  .equals(stroke.join  )             && this.miter .equals(stroke.miter )             && this.cap   .equals(stroke.cap   )             && this.dashes.equals(stroke.dashes);     }        async eval(parse)     {         return this.copy();     }        toNewValue()     {         return this.copy();     }        l99()     {         return this.fills             && this.fills.items.length > 0              ? m84(                  this.fills.items[0]    .l99(),                  this.fills.items.at(-1).l99(),                  0.5)              : rgba_NaN;     }        toString()     {         return      this.fills .toString()             + ' ' + this.weight.toString()             + ' ' + this.fit   .toString()             + ' ' + this.join  .toString()             + ' ' + this.miter .toString()             + ' ' + this.cap   .toString()             + ' ' + this.dashes.toString();     }        u3605()     {         return      this.fills .u3605()             + ' ' + this.weight.u3605()             + ' ' + this.fit   .u3605()             + ' ' + this.join  .u3605()             + ' ' + this.miter .u3605()             + ' ' + this.cap   .u3605()             + ' ' + this.dashes.u3605();     }        l3606()     {         return      this.fills .l3606()             + ' ' + this.weight.l3606()             + ' ' + this.fit   .l3606()             + ' ' + this.join  .l3606()             + ' ' + this.miter .l3606()             + ' ' + this.cap   .l3606()             + ' ' + this.dashes.l3606();     }        toJsonText(options = {})     {         const WS = s =>                 options.whiteSpace              && options.lastExpanded                 ? s                  : '';           let json = '';                   if (options.named)             json += '\n' + c869(options.tab);           json += '{\n';         options.tab++;          const oldNamed = options.named;         options.named = true;           json += c869(options.tab) + '"fills": '   + this.fills  .toJsonText(options) + ',\n';         json += WS('\n');         json += c869(options.tab) + '"weight": ' + this.weight.toJsonText(options) + ',\n';         json += c869(options.tab) + '"align": "' + StrokeAlign[this.fit .value]    + '",\n';         json += c869(options.tab) + '"join": "'  + StrokeJoin [this.join.value]    + '",\n';         json += c869(options.tab) + '"miter": '  + this.miter .toJsonText(options) + ',\n';         json += c869(options.tab) + '"cap": "'   + StrokeCap[this.cap.value]       + '",\n';         json += c869(options.tab) + '"dashes": ' + this.dashes.toJsonText(options) + '\n';           options.named = oldNamed;          options.tab--;         json += c869(options.tab) + '}';           options.lastExpanded = true;          return json;     }        static NaN()     {         return new d1844(          new x1834(),          n1835.NaN(),          n1835.NaN(),          n1835.NaN(),          n1835.NaN(),          n1835.NaN(),          new e1846());     }        static parseRequest(parse)     {         parse.pos++;               const stroke = parse.move();              if (parse.settings.logRequests)              r1944(x1161, stroke, parse);              return d1844.parse(stroke)[0];     }        static parse(str, i = -1)     {         if (   i <  0 && str    == t962             || i >= 0 && str[i] == t962)             return [d1844.NaN(), 1];                   if (i < 0)         {             str = str.split(' ');             i   = 0;         }                   const i3666 = i;              const fills  = x1834.parse  (str, i); i += fills [1];         const weight = n1835.parse(str[i]); i += weight[1];         const fit    = n1835.parse(str[i]); i += fit   [1];         const join   = n1835.parse(str[i]); i += join  [1];         const miter  = n1835.parse(str[i]); i += miter [1];         const cap    = n1835.parse(str[i]); i += cap   [1];         const dashes = e1846.parse  (str[i]); i += dashes[1];              return [                  new d1844(                 fills [0],                  weight[0],                  fit   [0],                  join  [0],                  miter [0],                  cap   [0],                  dashes[0]),                          i - i3666 ];     }        static default = Object.freeze(new d1844(         new x1834(),         new n1835(1),         new n1835(0),         new n1835(0),         new n1835(28.96),         new n1835(0),         new e1846())); }    


class y4151 extends i1863 {     static { d1855.types[x1170] = this; }        top;     left;     right;     bottom;     visible;        constructor(top     = new n1835(0),                  left    = new n1835(0),                  right   = new n1835(0),                  bottom  = new n1835(0),                  visible = true)     {         super(x1170, 'strokeSides');          this.top     = top;         this.left    = left;         this.right   = right;         this.bottom  = bottom;         this.visible = visible;     }            copy()     {         const copy = new y4151(             this.top   .copy(),             this.left  .copy(),             this.right .copy(),             this.bottom.copy(),             this.visible);          copy.m3266(this);          return copy;     }        equals(sides)     {         return this.top   .equals(sides.tl)             && this.left  .equals(sides.tr)             && this.right .equals(sides.bl)             && this.bottom.equals(sides.br)             && this.visible === sides.visible;     }        async eval(parse)     {         return this;     }        toString()     {         return      this.top   .toString()             + ' ' + this.left  .toString()             + ' ' + this.right .toString()             + ' ' + this.bottom.toString();     }        u3605()     {         return      this.top   .u3605()             + ' ' + this.left  .u3605()             + ' ' + this.right .u3605()             + ' ' + this.bottom.u3605();     }        l3606()     {         return      this.top   .l3606()             + ' ' + this.left  .l3606()             + ' ' + this.right .l3606()             + ' ' + this.bottom.l3606();     }        isValid()     {         return this.top   .isValid()             && this.left  .isValid()             && this.right .isValid()             && this.bottom.isValid();     }        toJsonText(options = {})      {         let json = '';                   if (options.named)             json += '\n' + c869(options.tab);           json += '{\n';         options.tab++;          const oldNamed = options.named;         options.named = true;           json += c869(options.tab) + '"top": '    + this.top   .toJsonText(options) + ',\n';         json += c869(options.tab) + '"left": '   + this.left  .toJsonText(options) + ',\n';         json += c869(options.tab) + '"right": '  + this.right .toJsonText(options) + ',\n';         json += c869(options.tab) + '"bottom": ' + this.bottom.toJsonText(options) + '\n';           options.named = oldNamed;          options.tab--;         json += c869(options.tab) + '}';           return json;     }        static NaN()     {         return new y4151(             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             false);     }        static parseRequest(parse)     {         parse.pos++;               const sides = parse.move();              if (parse.settings.logRequests)              r1944(x1170, sides, parse);              return y4151.parse(sides)[0];     }        static parse(str, i = -1)     {         if (   i <  0 && str    == t962             || i >= 0 && str[i] == t962)             return [y4151.NaN(), 1];           if (i < 0)         {             str = str.split(' ');             i   = 0;         }           const i3666 = i;          const top    = n1835.parse(str[i]); i += top   [1];         const left   = n1835.parse(str[i]); i += left  [1];         const right  = n1835.parse(str[i]); i += right [1];         const bottom = n1835.parse(str[i]); i += bottom[1];           const sides = new y4151(             top   [0],             left  [0],             right [0],             bottom[0]);           return [sides, i - i3666];     } }    


class m1839 extends i1863 {     static { d1855.types[d1173] = this; }        tl;     tr;     bl;     br;     visible;        constructor(tl = new n1835(0),                  tr = new n1835(0),                  bl = new n1835(0),                  br = new n1835(0),                  visible = true)     {         super(d1173, 'roundCorners');          this.tl      = tl;         this.tr      = tr;         this.bl      = bl;         this.br      = br;         this.visible = visible;     }            copy()     {         const copy = new m1839(             this.tl.copy(),             this.tr.copy(),             this.bl.copy(),             this.br.copy(),             this.visible);          copy.m3266(this);          return copy;     }        equals(corners)     {         return this.tl.equals(corners.tl)             && this.tr.equals(corners.tr)             && this.bl.equals(corners.bl)             && this.br.equals(corners.br)             && this.visible === corners.visible;     }        async eval(parse)     {         return this;     }        toString()     {         return      this.tl.toString()             + ' ' + this.tr.toString()             + ' ' + this.bl.toString()             + ' ' + this.br.toString();     }        u3605()     {         return      this.tl.u3605()             + ' ' + this.tr.u3605()             + ' ' + this.bl.u3605()             + ' ' + this.br.u3605();     }        l3606()     {         return      this.tl.l3606()             + ' ' + this.tr.l3606()             + ' ' + this.bl.l3606()             + ' ' + this.br.l3606();     }        toJsonText(options = {})      {         let json = '';                   if (options.named)             json += '\n' + c869(options.tab);           json += '{\n';         options.tab++;          const oldNamed = options.named;         options.named = true;           json += c869(options.tab) + '"topLeft": '     + this.tl.toJsonText(options) + ',\n';         json += c869(options.tab) + '"topRight": '    + this.tr.toJsonText(options) + ',\n';         json += c869(options.tab) + '"bottomLeft": '  + this.bl.toJsonText(options) + ',\n';         json += c869(options.tab) + '"bottomRight": ' + this.br.toJsonText(options) + '\n';           options.named = oldNamed;          options.tab--;         json += c869(options.tab) + '}';           return json;     }        isValid()     {         return this.tl.isValid()             && this.tr.isValid()             && this.bl.isValid()             && this.br.isValid();     }        static NaN()     {         return new m1839(             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             false);     }        static parseRequest(parse)     {         parse.pos++;               const corners = parse.move();              if (parse.settings.logRequests)              r1944(d1173, corners, parse);              return m1839.parse(corners)[0];     }        static parse(str, i = -1)     {         if (   i <  0 && str    == t962             || i >= 0 && str[i] == t962)             return [m1839.NaN(), 1];                   if (i < 0)         {             str = str.split(' ');             i   = 0;         }                   const i3666 = i;              const tl = n1835.parse(str[i]); i += tl[1];         const tr = n1835.parse(str[i]); i += tr[1];         const bl = n1835.parse(str[i]); i += bl[1];         const br = n1835.parse(str[i]); i += br[1];                   const corners = new m1839(             tl[0],             tr[0],             bl[0],             br[0]);                   return [corners, i - i3666];     } }    


class c1824 extends i1863 {     static { d1855.types[f1176] = this; }        x;     y;     blur;     spread;     fill;     blend;     behind;     visible;        constructor(x       = new n1835(0),                  y       = new n1835(0),                  blur    = new n1835(0),                  spread  = new n1835(0),                  fill    = m1826.NaN(),                 blend   = new n1835(0),                 behind  = new n1835(0),                 visible = true)     {         super(f1176, 'dropShadow');          this.x       = x;         this.y       = y;         this.blur    = blur;         this.spread  = spread;         this.fill    = fill;         this.blend   = blend;         this.behind  = behind;         this.visible = visible;                  r950(fill.type == m1158, 'fill.type must be FILL_VALUE');     }                                             copy()     {         const copy = new c1824(             this.x     .copy(),             this.y     .copy(),             this.blur  .copy(),             this.spread.copy(),             this.fill  .copy(),             this.blend .copy(),             this.behind.copy(),             this.visible);          copy.m3266(this);          return copy;     }        equals(shadow)     {         return this.x     .equals(shadow.x     )             && this.y     .equals(shadow.y     )             && this.blur  .equals(shadow.blur  )             && this.spread.equals(shadow.spread)             && this.fill  .equals(shadow.fill  )             && this.blend .equals(shadow.blend )             && this.behind.equals(shadow.behind)             && this.visible === shadow.visible;     }        async eval(parse)     {         return this;     }        toString()     {         return      this.x     .toString()             + ' ' + this.y     .toString()             + ' ' + this.blur  .toString()             + ' ' + this.spread.toString()             + ' ' + this.fill  .toString()             + ' ' + this.blend .toString()             + ' ' + this.behind.toString();     }        u3605()     {         return      this.x     .u3605()             + ' ' + this.y     .u3605()             + ' ' + this.blur  .u3605()             + ' ' + this.spread.u3605()             + ' ' + this.fill  .u3605()             + ' ' + this.blend .u3605()             + ' ' + this.behind.u3605();     }        l3606()     {         return      this.x     .l3606()             + ' ' + this.y     .l3606()             + ' ' + this.blur  .l3606()             + ' ' + this.spread.l3606()             + ' ' + this.fill  .l3606()             + ' ' + this.blend .l3606()             + ' ' + this.behind.l3606();     }        toJsonText(options = {})      {         const WS = s => options.whiteSpace ? s : '';           let json = '';                   if (options.named)             json += '\n' + c869(options.tab);           json += '{\n';         options.tab++;          const oldNamed = options.named;         options.named = true;           json += c869(options.tab) + '"x": '      + this.x     .toJsonText(options) + ',\n';         json += c869(options.tab) + '"y": '      + this.y     .toJsonText(options) + ',\n';         json += c869(options.tab) + '"blur": '   + this.blur  .toJsonText(options) + ',\n';         json += c869(options.tab) + '"spread": ' + this.spread.toJsonText(options) + ',\n';         json += WS('\n');         json += c869(options.tab) + '"fill": '   + this.fill  .toJsonText(options) + ',\n';         json += WS('\n');         json += c869(options.tab) + '"blend": "' + j1373[this.blend.value][1] + '",\n';         json += c869(options.tab) + '"behind": ' + this.behind.toJsonText(options) + '\n';           options.named = oldNamed;          options.tab--;         json += c869(options.tab) + '}';           options.lastExpanded = true;                  return json;     }        isValid()     {         return this.x     .isValid()             && this.y     .isValid()             && this.blur  .isValid()             && this.spread.isValid()             && this.fill  .isValid()             && this.blend .isValid()             && this.behind.isValid();     }        static NaN()     {         return new c1824(             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),               m1826.NaN(),             n1835.NaN(),             n1835.NaN(),             false);     }        static parseRequest(parse)     {         parse.pos++;               const shadow = parse.move();              if (parse.settings.logRequests)              r1944(f1176, shadow, parse);              return c1824.parse(shadow)[0];     }        static parse(str, i = -1)     {         if (   i <  0 && str    == t962             || i >= 0 && str[i] == t962)             return [c1824.NaN(), 1];           if (i < 0)         {             str = str.split(' ');             i   = 0;         }           const i3666 = i;          const x      = n1835.parse(str[i]); i += x     [1];         const y      = n1835.parse(str[i]); i += y     [1];         const blur   = n1835.parse(str[i]); i += blur  [1];         const spread = n1835.parse(str[i]); i += spread[1];         const fill   = m1826.parse  (str, i); i += fill  [1];         const blend  = n1835.parse(str[i]); i += blend [1];         const behind = n1835.parse(str[i]); i += behind[1];           const shadow = new c1824(             x     [0],             y     [0],             blur  [0],             spread[0],             fill  [0],             blend [0],             behind[0]);           return [shadow, i - i3666];     } }


class j1829 extends i1863 {     static { d1855.types[s1179] = this; }        x;     y;     blur;     spread;     fill;     blend;     visible;        constructor(x       = new n1835(0),                  y       = new n1835(0),                  blur    = new n1835(0),                  spread  = new n1835(0),                  fill    = m1826.NaN(),                 blend   = new n1835(0),                 visible = true)     {         super(s1179, 'innerShadow');          this.x       = x;         this.y       = y;         this.blur    = blur;         this.spread  = spread;         this.fill    = fill;         this.blend   = blend;         this.visible = visible;     }                                             copy()     {         const copy = new j1829(             this.x     .copy(),             this.y     .copy(),             this.blur  .copy(),             this.spread.copy(),             this.fill  .copy(),             this.blend .copy(),             this.visible);          copy.m3266(this);          return copy;     }        equals(shadow)     {         return this.x     .equals(shadow.x     )             && this.y     .equals(shadow.y     )             && this.blur  .equals(shadow.blur  )             && this.spread.equals(shadow.spread)             && this.fill  .equals(shadow.fill  )             && this.blend .equals(shadow.blend )             && this.visible === shadow.visible;     }        async eval(parse)     {         return this;     }                                                                toString()     {         return      this.x     .toString()             + ' ' + this.y     .toString()             + ' ' + this.blur  .toString()             + ' ' + this.spread.toString()             + ' ' + this.fill  .toString()             + ' ' + this.blend .toString();     }        u3605()     {         return      this.x     .u3605()             + ' ' + this.y     .u3605()             + ' ' + this.blur  .u3605()             + ' ' + this.spread.u3605()             + ' ' + this.fill  .u3605()             + ' ' + this.blend .u3605();     }        l3606()     {         return      this.x     .l3606()             + ' ' + this.y     .l3606()             + ' ' + this.blur  .l3606()             + ' ' + this.spread.l3606()             + ' ' + this.fill  .l3606()             + ' ' + this.blend .l3606();     }        toJsonText(options = {})      {         let json = '';                   if (options.named)             json += '\n' + c869(options.tab);           json += '{\n';         options.tab++;          const oldNamed = options.named;         options.named = true;           json += c869(options.tab) + '"x": '      + this.x     .toJsonText(options) + ',\n';         json += c869(options.tab) + '"y": '      + this.y     .toJsonText(options) + ',\n';         json += c869(options.tab) + '"blur": '   + this.blur  .toJsonText(options) + ',\n';         json += c869(options.tab) + '"spread": ' + this.spread.toJsonText(options) + ',\n';         json += c869(options.tab) + '"fill": '   + this.fill  .toJsonText(options) + ',\n';         json += c869(options.tab) + '"blend": "' + j1373[this.blend.value][1] + '"\n';           options.named = oldNamed;          options.tab--;         json += c869(options.tab) + '}';           return json;     }        isValid()     {         return this.x     .isValid()             && this.y     .isValid()             && this.blur  .isValid()             && this.spread.isValid()             && this.fill  .isValid()             && this.blend .isValid();     }        static NaN()     {         return new j1829(             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             m1826  .NaN(),             n1835.NaN(),             false);     }        static parseRequest(parse)     {         parse.pos++;           const shadow = parse.move();          if (parse.settings.logRequests)              r1944(s1179, shadow, parse);          return j1829.parse(shadow)[0];     }       static parse(str, i = -1)     {         if (   i <  0 && str    == t962             || i >= 0 && str[i] == t962)             return [j1829.NaN(), 1];                   if (i < 0)         {             str = str.split(' ');             i   = 0;         }                   const i3666 = i;              const x      = n1835.parse(str[i]); i += x     [1];         const y      = n1835.parse(str[i]); i += y     [1];         const blur   = n1835.parse(str[i]); i += blur  [1];         const spread = n1835.parse(str[i]); i += spread[1];         const fill   = m1826.parse  (str, i); i += fill  [1];         const blend  = n1835.parse(str[i]); i += blend [1];                   const shadow = new j1829(             x     [0],             y     [0],             blur  [0],             spread[0],             fill  [0],             blend [0]);                   return [shadow, i - i3666];     }         }    


class a1831 extends i1863 {     static { d1855.types[r1182] = this; }        radius;     visible;        constructor(radius  = new n1835(0),                  visible = true)     {         super(r1182, 'layerBlur');          this.radius  = radius;         this.visible = visible;     }                                             copy()     {         const copy = new a1831(             this.radius.copy(),             this.visible);          copy.m3266(this);          return copy;     }        equals(blur)     {         return this.radius.equals(blur.radius)             && this.visible === blur.visible;     }        async eval(parse)     {         return this;     }                                                                toString()     {         return this.radius.toString();     }        u3605()     {         return this.radius.u3605();     }        l3606()     {         return this.radius.l3606();     }        toJsonText(options = {})      {         let json = '';                   const SL  = s => options.singleLine ? ''  : s;         const SL_ = s => options.singleLine ? ' ' : s;           if (options.named)         json += SL('\n' + c869(options.tab));           json += '{' + SL('\n');         options.tab++;          const oldNamed = options.named;         options.named = true;           json += SL_(c869(options.tab)) + '"radius": ' + this.radius.toJsonText(options) + SL('\n');           options.named = oldNamed;          options.tab--;         json += SL_(c869(options.tab)) + '}';           options.lastExpanded = !options.singleLine;           return json;     }        isValid()     {         return this.radius.isValid();     }        static NaN()     {         return new a1831(             n1835.NaN(),             false);     }        static parseRequest(parse)     {         parse.pos++;               const blur = parse.move();              if (parse.settings.logRequests)              r1944(r1182, blur, parse);              return a1831.parse(blur)[0];     }        static parse(str, i = -1)     {         if (   i <  0 && str    == t962             || i >= 0 && str[i] == t962)             return [a1831.NaN(), 1];                   if (i < 0)         {             str = str.split(' ');             i   = 0;         }                   const i3666 = i;              const radius = n1835.parse(str[i]); i += radius[1];                   const shadow = new a1831(             radius[0]);                   return [shadow, i - i3666];     } }    


class v1821 extends i1863 {     static { d1855.types[e1185] = this; }        radius;     visible;        constructor(radius  = new n1835(0),                 visible = true)     {         super(e1185, 'backgroundBlur');          this.radius  = radius;         this.visible = visible;     }                                             copy()     {         const copy = new v1821(             this.radius.copy(),             this.visible);          copy.m3266(this);          return copy;     }        equals(blur)     {         return this.radius.equals(blur.radius)             && this.visible === blur.visible;     }        async eval(parse)     {         return this;     }                                                                toString()     {         return this.radius.toString();     }        u3605()     {         return this.radius.u3605();     }        l3606()     {         return this.radius.l3606();     }        toJsonText(options = {})      {         let json = '';                   const SL  = s => options.singleLine ? ''  : s;         const SL_ = s => options.singleLine ? ' ' : s;           if (options.named)             json += SL('\n' + c869(options.tab));           json += '{' + SL('\n');         options.tab++;          const oldNamed = options.named;         options.named = true;           json += SL_(c869(options.tab)) + '"radius": ' + this.radius.toJsonText(options) + SL('\n');           options.named = oldNamed;          options.tab--;         json += SL_(c869(options.tab)) + '}';           options.lastExpanded = !options.singleLine;           return json;     }        isValid()     {         return this.radius.isValid();     }        static NaN()     {         return new v1821(             n1835.NaN(),             false);     }        static parseRequest(parse)     {         parse.pos++;               const blur = parse.move();              if (parse.settings.logRequests)              r1944(e1185, blur, parse);              return v1821.parse(blur)[0];     }        static parse(str, i = -1)     {         if (   i <  0 && str    == t962             || i >= 0 && str[i] == t962)             return [v1821.NaN(), 1];           if (i < 0)         {             str = str.split(' ');             i   = 0;         }           const i3666 = i;          const radius = n1835.parse(str[i]); i += radius[1];           const shadow = new v1821(             radius[0]);           return [shadow, i - i3666];     } }


class f1830 extends i1863 {     static { d1855.types[i1191] = this; }        opacity;     blend;        constructor(opacity, blend)     {         super(i1191, 'layerBlend');          this.opacity = opacity.copy();         this.blend   = blend  .copy();     }            copy()     {         const copy = new f1830(this.opacity, this.blend);          copy.m3266(this);          return copy;     }        equals(layer)     {         return this.opacity.equals(layer.opacity)             && this.blend  .equals(layer.blend  );     }        async eval(parse)     {         return this;     }        toString()     {         return      this.opacity.toString()             + ' ' + this.blend  .toString();     }        u3605()     {         return      this.opacity.u3605()             + ' ' + this.blend  .u3605();     }        l3606()     {         return      this.opacity.l3606()             + ' ' + this.blend  .l3606();     }        toJsonText(options = {})      {         let json = '';                   const SL  = s => options.singleLine ? ''  : s;         const SL_ = s => options.singleLine ? ' ' : s;           if (options.named)             json += SL('\n' + c869(options.tab));           json += '{' + SL('\n');         options.tab++;              const oldNamed = options.named;         options.named = true;           json += SL_(c869(options.tab)) + '"opacity": ' + this.opacity.toJsonText(options) + ',' + SL('\n');         json += SL_(c869(options.tab)) + '"blend": "'  + j1373[this.blend.value][1] + '"'  + SL('\n');           options.named = oldNamed;          options.tab--;         json += SL_(c869(options.tab)) + '}';           options.lastExpanded = !options.singleLine;           return json;     }        l3609()     {         return this.opacity.l3609()             && this.blend  .l3609();     }        isValid()     {         return this.opacity && this.opacity.isValid()             && this.blend   && this.blend  .isValid();     }        static NaN()     {         return new f1830(             n1835.NaN(),              n1835.NaN());     }        static parseRequest(parse)     {         parse.pos++;               const layer = parse.move();              if (parse.settings.logRequests)              r1944(i1191, layer, parse);              return f1830.parse(layer)[0];     }        static parse(str, i = -1)     {         if (   i <  0 && str    == t962             || i >= 0 && str[i] == t962)             return [f1830.NaN(), 1];           if (i < 0)         {             str = str.split(' ');             i   = 0;         }           const i3666 = i;          const opacity = n1835.parse(str[i]); i += opacity[1];         const blend   = n1835.parse(str[i]); i += blend  [1];           const layer = new f1830(             opacity[0],             blend  [0]);                       return [layer, i - i3666];     } }


class l1832 extends i1863 {     static { d1855.types[d1188] = this; }        visible;     maskType;        constructor(maskType, visible = true)     {         super(d1188, 'layerMask');          this.visible  = visible;         this.maskType = maskType.copy();     }            copy()     {         const copy = new l1832(this.maskType, this.visible);          copy.m3266(this);          return copy;     }        equals(mask)     {         return this.visible === mask.visible             && this.maskType.equals(mask.maskType);     }        async eval(parse)     {         return this;     }        toString()     {         return 'mask';     }        u3605()     {         return 'mask';     }        l3606()     {         return 'mask';     }        isValid()     {         return this.maskType.isValid();     }        toJsonText(options = {})      {         let json = '';                   const SL  = s => options.singleLine ? ''  : s;         const SL_ = s => options.singleLine ? ' ' : s;           if (options.named)             json += SL('\n' + c869(options.tab));           json += '{' + SL('\n');         options.tab++;          const oldNamed = options.named;         options.named = true;           json += SL_(c869(options.tab)) + '"type": "' + LayerMaskTypes[this.maskType.value] + '"' + SL('\n');           options.named = oldNamed;          options.tab--;         json += SL_(c869(options.tab)) + '}';           options.lastExpanded = !options.singleLine;           return json;     }        static NaN()     {         return new l1832(             n1835.NaN(),             false);     }        static parseRequest(parse)     {         parse.pos++;               const mask = parse.move();              if (parse.settings.logRequests)              r1944(d1188, mask, parse);              return l1832.parse(mask)[0];     }        static parse(str)     {         const mask =              str == t962             ? l1832.NaN()             : new l1832(new n1835(parseInt(str)), true);          return [mask, 1];     } }


class a2445 extends i1863 {     nodeId;      variableId;     variableName;     variableValues;          aliasIds;     aliasNames;      variableTemp;         constructor(nodeId,                 variableId     = NULL,                  variableName   = '',                  variableValues = [],                 aliasIds       = [],                 aliasNames     = [],                 variableTemp   = false)     {         super(VARIABLE_VALUE, nodeId, 'variable');          this.variableId     = variableId;         this.variableName   = variableName;         this.variableValues = [...variableValues];         this.aliasIds       = aliasIds.length == variableValues.length                                  ? [...aliasIds]                                 : Array(variableValues.length).fill(NULL);          this.aliasNames     = aliasNames.length == variableValues.length                                  ? [...aliasNames]                                 : Array(variableValues.length).fill(NULL);          this.variableTemp   = variableTemp;     }        static fromObject(c111)     {         return new a2445(             c111.nodeId,             c111.objectId,              c111.objectName,              [],             [],             [],             true);     }        copy()     {         const copy = new a2445(             this.nodeId,             this.variableId,              this.variableName,              this.variableValues.map(v => v.copy()),             [...this.aliasIds],             [...this.aliasNames],             this.variableTemp);          copy.m3266(this);          return copy;     }        equals(_var)     {         let result =               _var             && this.variableId   == _var.variableId               && this.variableName == _var.variableName;          for (let i = 0; i < this.variableValues.length; i++)         {             if (   !this.variableValues[i]                 || !_var.variableValues[i]                 || !this.variableValues[i].equals(_var.variableValues[i]))             {                 result = false;                 break;             }         }          return result;     }        async eval(parse)     {         return this.copy();     }        toString()     {         const varValues  = this.variableValues.map(v    => encodeURIComponent(v.toString()));         const aliasIds   = this.aliasIds      .map(id   => id   == NULL ? NULL_VALUE : id  );         const aliasNames = this.aliasNames    .map(name => name == NULL ? NULL_VALUE : encodeURIComponent(name));          return      (this.variableId   != NULL      ? this.variableId                       : NULL_VALUE)             + ' ' + (this.variableName != ''        ? encodeURIComponent(this.variableName) : NULL_VALUE)             + ' ' + (this.variableValues.length > 0 ? this.variableValues[0].type           : NULL_VALUE)             + ' ' +  this.variableValues.length                   + (varValues .length > 0 ? ' ' + varValues .join(' ') : '')             + ' ' +  this.aliasIds.length                   + (aliasIds  .length > 0 ? ' ' + aliasIds  .join(' ') : '')                   + (aliasNames.length > 0 ? ' ' + aliasNames.join(' ') : '')             + ' ' + (this.variableTemp ? 'T' : 'E');      }        u3605()     {         return 'variable';                                                         }        l3606()     {         const varValues  = this.variableValues.map(v => v.l3606());         const aliasIds   = this.aliasIds      .map(id => id == NULL ? NULL_VALUE : id);         const aliasNames = this.aliasNames    .map(name => name == NULL ? NULL_VALUE : encodeURIComponent(name));                  return        (this.variableId   != NULL      ? this.variableId             : NULL_VALUE)             + ' \'' + (this.variableName != ''        ? this.variableName           : NULL_VALUE) + '\''             + ' '   + (this.variableValues.length > 0 ? this.variableValues[0].type : NULL_VALUE)             + ' '   +  this.variableValues.length                     + (varValues .length > 0 ? ' ' + varValues .join(' ') : '')             + ' '   +  this.aliasIds.length                     + (aliasIds  .length > 0 ? ' ' + aliasIds  .join(' ') : '')                     + (aliasNames.length > 0 ? ' ' + aliasNames.join(' ') : '')             + ' '   + (this.variableTemp ? 'T' : 'E');      }        toNewValue()     {         return this.copy();     }        l3609()     {         return super.l3609()             && this.variableValues.some(v => v.l3609());     }        isValid()     {         return this.variableId   != NULL             && this.variableName != ''             && this.variableValues.every(v => v.isValid());     }            static NaN = new a2445(NULL);                    static parse(str, i = -1)     {         if (   i <  0 && str    == t962             || i >= 0 && str[i] == t962)             return [a2445.NaN(), 1];                   let h3970;              if (i < 0)         {            h3970 = str.split(' ');             i   = 0;         }         else             h3970 = str;                   const i3666 = i;         let   length = 0;              const variableId      = h3970[i] != NULL_VALUE ? h3970[i] : NULL;               length += h3970[i].length + 1;  i++;              const strName         = decodeURIComponent(h3970[i]);         const variableName    = strName != NULL_VALUE ? strName : NULL;               length += h3970[i].length + 1;  i++;              const variableType    = h3970[i] != NULL_VALUE ? h3970[i] : NULL;               length += h3970[i].length + 1;  i++;                  const nVariableValues = h3970[i] != NULL_VALUE ? parseInt(h3970[i]) : NULL;     length += h3970[i].length + 1;  i++;                       const variableValues = [];              for (let j = 0; j < nVariableValues; j++)         {             const variableValue = parseValueFromType(variableType, decodeURIComponent(h3970[i]));                  variableValues.push(variableValue);                  length += h3970[i].length + 1;             i++;         }                   const nAliases = h3970[i] != NULL_VALUE ? parseInt(h3970[i]) : NULL;     length += h3970[i].length + 1;  i++;                   const aliasIds = [];              for (let j = 0; j < nAliases; j++)         {             const aliasId =                  h3970[i] == NULL_VALUE                      ? NULL                      : h3970[i];                  aliasIds.push(aliasId);                  length += h3970[i].length + 1;             i++;         }                   const aliasNames = [];              for (let j = 0; j < nAliases; j++)         {             const aliasName =                  h3970[i] == NULL_VALUE                      ? NULL                      : decodeURIComponent(h3970[i]);                  aliasNames.push(aliasName);                  length += h3970[i].length + 1;             i++;         }                   const variableTemp = h3970[i] == 'T';  length += h3970[i].length + 1;  i++;                   const _var = new a2445(             NULL,              variableId,             variableName,             variableValues,             aliasIds,             aliasNames,             variableTemp);                   return [_var, i - i3666];     } } 


   class u1842 extends i1863 {     nodeId;      props = null;        constructor(type, nodeId, valueId)     {         super(type, valueId);          this.nodeId = nodeId;           this.objects = [];     }        m3266(base)     {         super.m3266(base);                  this.nodeId = base.nodeId;          if (base.objects) this.objects = base.objects.map(o => o.copy());          if (base.props  ) this.props   = base.props.copy();     }        l3609()     {         return !this.props             ||  this.props.l3609();     }        isValid()     {         return !this.props             ||  this.props.isValid();     }        toBaseJsonText(options = {})     {         for (const prop of this.props.items)         {             let valueId = '';              switch (prop.type)             {                 case s1148:         valueId = 'color';          break;                 case m1158:          valueId = 'fill';           break;                 case x1161:        valueId = 'stroke';         break;                 case o1164:    valueId = 'colorStop';      break;                 case d1167:      valueId = 'gradient';       break;                 case d1173: valueId = 'roundCorners';   break;                 case x1170:  valueId = 'strokeSides';    break;                 case i1191:   valueId = 'layerBlend';     break;                 case f1176:   valueId = 'dropShadow';     break;                 case s1179:  valueId = 'innerShadow';    break;                 case r1182:    valueId = 'layerBlur';      break;                 case e1185:     valueId = 'backgroundBlur'; break;                 case d1188:    valueId = 'layerMask';      break;             }                      prop.valueId = valueId;         }           const oldForceBraces = options.forceBraces;         const oldShowNames   = options.showNames;                   options.showNames   = true;           let json = '';          if (   options.whiteSpace             && this.props.items.length > 0)             json += '\n';          json += c869(options.tab) + '"props": ' + this.props.toJsonText(options) + '\n';                   options.forceBraces = oldForceBraces;         options.showNames   = oldShowNames;                  return json;     }        static parse(str, i, c111)     {         const props = x1834.parse(str, i); i += props[1];              c111.props = props[0];              return i;     } } 


class d1838 extends u1842 {     x;     y;     width;     height;     round;        constructor(nodeId,                 x      = new n1835(0),                  y      = new n1835(0),                  width  = new n1835(0),                  height = new n1835(0),                  round  = new n1835(0))     {         super(a1198, nodeId, 'rectangle');          this.x      = x;         this.y      = y;         this.width  = width;         this.height = height;         this.round  = round;     }        static fromObject(c111)     {         return new d1838(             c111.nodeId,             new n1835(c111.x     ),              new n1835(c111.y     ),              new n1835(c111.width ),              new n1835(c111.height),              new n1835(c111.round ));     }        copy()     {         const copy = new d1838(             this.nodeId,             this.x     .copy(),              this.y     .copy(),              this.width .copy(),              this.height.copy(),              this.round .copy());          copy.m3266(this);          return copy;     }        equals(rect)     {         return rect             && this.x     .equals(rect.x     )             && this.y     .equals(rect.y     )             && this.width .equals(rect.width )             && this.height.equals(rect.height)             && this.round .equals(rect.round );     }        async eval(parse)     {         return this.copy();     }        toString()     {         return      this.x     .toString()             + ' ' + this.y     .toString()             + ' ' + this.width .toString()             + ' ' + this.height.toString()             + ' ' + this.round .toString()             + ' ' + super.toString();     }        u3605()     {         return 'rectangle';                                                                      }        l3606()     {         return      this.x     .l3606()             + ' ' + this.y     .l3606()             + ' ' + this.width .l3606()             + ' ' + this.height.l3606()             + ' ' + this.round .l3606();     }        toJsonText(options = {})      {         let json = '';                   if (options.named)             json += '\n' + c869(options.tab);           json += '{\n';         options.tab++;          const oldNamed = options.named;         options.named = true;           json += c869(options.tab) + '"x": '      + this.x     .toJsonText(options) + ',\n';         json += c869(options.tab) + '"y": '      + this.y     .toJsonText(options) + ',\n';         json += c869(options.tab) + '"width": '  + this.width .toJsonText(options) + ',\n';         json += c869(options.tab) + '"height": ' + this.height.toJsonText(options) + ',\n';         json += c869(options.tab) + '"round": '  + this.round .toJsonText(options) + ',\n';           json += this.toBaseJsonText(options);           options.named = oldNamed;          options.tab--;         json += c869(options.tab) + '}';           return json;     }        toNewValue()     {         return this.copy();     }        l3609()     {         return super.l3609()             && this.x     .l3609()             && this.y     .l3609()             && this.width .l3609()             && this.height.l3609()             && this.round .l3609();     }        isValid()     {         return super.isValid()             && this.x     .isValid()             && this.y     .isValid()             && this.width .isValid()             && this.height.isValid()             && this.round .isValid();     }            static NaN()     {         return new d1838(             '',             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN());     }                    static parse(str, i = -1)     {         if (   i <  0 && str    == t962             || i >= 0 && str[i] == t962)             return [d1838.NaN(), 1];                   if (i < 0)         {             str = str.split(' ');             i   = 0;         }                   const i3666 = i;              const x      = n1835.parse(str[i]); i += x     [1];         const y      = n1835.parse(str[i]); i += y     [1];         const width  = n1835.parse(str[i]); i += width [1];         const height = n1835.parse(str[i]); i += height[1];         const round  = n1835.parse(str[i]); i += round [1];                   const rect = new d1838(             '',              x     [0],             y     [0],             width [0],             height[0],             round [0]);                   i = u1842.parse(str, i, rect);                       return [rect, i - i3666];     } } 


class m1833 extends u1842 {     x;     y;     width;        constructor(nodeId,                 x      = new n1835(0),                  y      = new n1835(0),                  width  = new n1835(0))     {         super(w1201, nodeId, 'line');          this.x     = x;         this.y     = y;         this.width = width;     }        static fromObject(c111)     {         return new m1833(             c111.nodeId,             new n1835(c111.x    ),              new n1835(c111.y    ),              new n1835(c111.width));     }        copy()     {         const copy = new m1833(             this.nodeId,             this.x    .copy(),              this.y    .copy(),              this.width.copy());          copy.m3266(this);          return copy;     }        equals(line)     {         return line             && this.x    .equals(line.x    )             && this.y    .equals(line.y    )             && this.width.equals(line.width);     }        async eval(parse)     {         return this.copy();     }        l3609()     {         return super.l3609()             && this.x     .l3609()             && this.y     .l3609()             && this.width .l3609();     }        isValid()     {         return super.isValid()             && this.x    .isValid()             && this.y    .isValid()             && this.width.isValid();     }        toNewValue()     {         return this.copy();     }        toString()     {         return      this.x    .toString()             + ' ' + this.y    .toString()             + ' ' + this.width.toString()             + ' ' + super.toString();     }        u3605()     {         return      this.x    .u3605()             + ' ' + this.y    .u3605()             + ' ' + this.width.u3605();     }        l3606()     {         return      this.x    .l3606()             + ' ' + this.y    .l3606()             + ' ' + this.width.l3606();     }        toJsonText(options = {})      {         let json = '';                   if (options.named)             json += '\n' + c869(options.tab);           json += '{\n';         options.tab++;          const oldNamed = options.named;         options.named = true;           json += c869(options.tab) + '"x": '      + this.x     .toJsonText(options) + ',\n';         json += c869(options.tab) + '"y": '      + this.y     .toJsonText(options) + ',\n';         json += c869(options.tab) + '"width": '  + this.width .toJsonText(options) + ',\n';           json += this.toBaseJsonText(options);           options.named = oldNamed;          options.tab--;         json += c869(options.tab) + '}';           return json;     }        static NaN()     {         return new m1833(             '',             n1835.NaN(),             n1835.NaN(),             n1835.NaN());     }        static parse(str, i = -1)     {         if (   i <  0 && str    == t962             || i >= 0 && str[i] == t962)             return [m1833.NaN(), 1];           if (i < 0)         {             str = str.split(' ');             i   = 0;         }           const i3666 = i;          const x     = n1835.parse(str[i]); i += x    [1];         const y     = n1835.parse(str[i]); i += y    [1];         const width = n1835.parse(str[i]); i += width[1];           const line = new m1833(             '',              x    [0],             y    [0],             width[0]);           i = u1842.parse(str, i, line);                   return [line, i - i3666];     } }


class v1825 extends u1842 {     position;     x;     y;     width;     height;     round;     start;     sweep;     inner;        constructor(nodeId,                 position = new n1835(0),                 x        = new n1835(0),                  y        = new n1835(0),                  width    = new n1835(0),                  height   = new n1835(0),                  round    = new n1835(0),                  start    = new n1835(0),                 sweep    = new n1835(0),                 inner    = new n1835(0))     {         super(l1204, nodeId, 'ellipse');          this.position = position;         this.x        = x;         this.y        = y;         this.width    = width;         this.height   = height;         this.round    = round;         this.start    = start;         this.sweep    = sweep;         this.inner    = inner;     }        static fromObject(c111)     {         return new v1825(             c111.nodeId,             new n1835(c111.position),              new n1835(c111.x       ),              new n1835(c111.y       ),              new n1835(c111.width   ),              new n1835(c111.height  ),              new n1835(c111.round   ),             new n1835(c111.start   ),             new n1835(c111.sweep   ),             new n1835(c111.inner   ));     }        copy()     {         const copy = new v1825(             this.nodeId,             this.position.copy(),              this.x       .copy(),              this.y       .copy(),              this.width   .copy(),              this.height  .copy(),              this.round   .copy(),              this.start   .copy(),             this.sweep   .copy(),             this.inner   .copy());          copy.m3266(this);          return copy;     }        equals(ellipse)     {         return ellipse             && this.position.equals(ellipse.position)             && this.x       .equals(ellipse.x       )             && this.y       .equals(ellipse.y       )             && this.width   .equals(ellipse.width   )             && this.height  .equals(ellipse.height  )             && this.round   .equals(ellipse.round   )             && this.start   .equals(ellipse.start   )             && this.sweep   .equals(ellipse.sweep   )             && this.inner   .equals(ellipse.inner   );     }        async eval(parse)     {         return this.copy();     }                    l3609()     {         return super.l3609()             && this.position.l3609()             && this.x       .l3609()             && this.y       .l3609()             && this.width   .l3609()             && this.height  .l3609()             && this.round   .l3609()             && this.start   .l3609()             && this.sweep   .l3609()             && this.inner   .l3609();     }        isValid()     {         return super.isValid()             && this.position.isValid()             && this.x       .isValid()             && this.y       .isValid()             && this.width   .isValid()             && this.height  .isValid()             && this.round   .isValid()             && this.start   .isValid()             && this.sweep   .isValid()             && this.inner   .isValid();     }        toNewValue()     {         return this.copy();     }        toString()     {         return      this.position.toString()             + ' ' + this.x       .toString()             + ' ' + this.y       .toString()             + ' ' + this.width   .toString()             + ' ' + this.height  .toString()             + ' ' + this.round   .toString()             + ' ' + this.start   .toString()             + ' ' + this.sweep   .toString()             + ' ' + this.inner   .toString()             + ' ' + super.toString();     }        u3605()     {         return 'ellipse';                                                                                                                          }        l3606()     {         return      this.position.l3606()             + ' ' + this.x       .l3606()             + ' ' + this.y       .l3606()             + ' ' + this.width   .l3606()             + ' ' + this.height  .l3606()             + ' ' + this.round   .l3606()             + ' ' + this.start   .l3606()             + ' ' + this.sweep   .l3606()             + ' ' + this.inner   .l3606();     }        toJsonText(options = {})      {         let json = '';                   if (options.named)             json += '\n' + c869(options.tab);           json += '{\n';         options.tab++;          const oldNamed = options.named;         options.named = true;           json += c869(options.tab) + '"position": "' + EllipsePositions[this.position.value] + '",\n';         json += c869(options.tab) + '"x": '         + this.x     .toJsonText(options) + ',\n';         json += c869(options.tab) + '"y": '         + this.y     .toJsonText(options) + ',\n';         json += c869(options.tab) + '"width": '     + this.width .toJsonText(options) + ',\n';         json += c869(options.tab) + '"height": '    + this.height.toJsonText(options) + ',\n';         json += c869(options.tab) + '"round": '     + this.round .toJsonText(options) + ',\n';         json += c869(options.tab) + '"start": '     + this.start .toJsonText(options) + ',\n';         json += c869(options.tab) + '"sweep": '     + this.sweep .toJsonText(options) + ',\n';         json += c869(options.tab) + '"inner": '     + this.inner .toJsonText(options) + ',\n';           json += this.toBaseJsonText(options);           options.named = oldNamed;          options.tab--;         json += c869(options.tab) + '}';           return json;     }        static NaN()     {         return new v1825(             '',             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN());     }        static parse(str, i = -1)     {         if (   i <  0 && str    == t962             || i >= 0 && str[i] == t962)             return [v1825.NaN(), 1];           if (i < 0)         {             str = str.split(' ');             i   = 0;         }           const i3666 = i;          const pos    = n1835.parse(str[i]); i += pos   [1];         const x      = n1835.parse(str[i]); i += x     [1];         const y      = n1835.parse(str[i]); i += y     [1];         const width  = n1835.parse(str[i]); i += width [1];         const height = n1835.parse(str[i]); i += height[1];         const round  = n1835.parse(str[i]); i += round [1];         const start  = n1835.parse(str[i]); i += start [1];         const sweep  = n1835.parse(str[i]); i += sweep [1];         const inner  = n1835.parse(str[i]); i += inner [1];           const ellipse = new v1825(             '',              pos   [0],             x     [0],             y     [0],             width [0],             height[0],             round [0],             start [0],             sweep [0],             inner [0]);           i = u1842.parse(str, i, ellipse);                   return [ellipse, i - i3666];     } }


class p1847 extends u1842 {     x;     y;     width;     height;     round;     bias;        constructor(nodeId,                 x      = new n1835(0),                  y      = new n1835(0),                  width  = new n1835(0),                  height = new n1835(0),                  round  = new n1835(0),                 bias   = new n1835(0))     {         super(y1207, nodeId, 'trapeze');          this.x      = x;         this.y      = y;         this.width  = width;         this.height = height;         this.round  = round;         this.bias   = bias;     }        static fromObject(c111)     {         return new p1847(             c111.nodeId,             new n1835(c111.x     ),              new n1835(c111.y     ),              new n1835(c111.width ),              new n1835(c111.height),              new n1835(c111.round ),             new n1835(c111.bias  ));     }        copy()     {         const copy = new p1847(             this.nodeId,             this.x     .copy(),              this.y     .copy(),              this.width .copy(),              this.height.copy(),              this.round .copy(),             this.bias  .copy());          copy.m3266(this);          return copy;     }        equals(rect)     {         return rect             && this.x     .equals(rect.x     )             && this.y     .equals(rect.y     )             && this.width .equals(rect.width )             && this.height.equals(rect.height)             && this.round .equals(rect.round )             && this.bias  .equals(rect.bias  );     }        async eval(parse)     {         return this.copy();     }        toString()     {         return      this.x     .toString()             + ' ' + this.y     .toString()             + ' ' + this.width .toString()             + ' ' + this.height.toString()             + ' ' + this.round .toString()             + ' ' + this.bias  .toString()             + ' ' + super.toString();     }        u3605()     {         return 'trapeze';                                                                                   }        l3606()     {         return      this.x     .l3606()             + ' ' + this.y     .l3606()             + ' ' + this.width .l3606()             + ' ' + this.height.l3606()             + ' ' + this.round .l3606()             + ' ' + this.bias  .l3606();     }        toJsonText(options = {})      {         let json = '';                   if (options.named)             json += '\n' + c869(options.tab);           json += '{\n';         options.tab++;          const oldNamed = options.named;         options.named = true;           json += c869(options.tab) + '"x": '      + this.x     .toJsonText(options) + ',\n';         json += c869(options.tab) + '"y": '      + this.y     .toJsonText(options) + ',\n';         json += c869(options.tab) + '"width": '  + this.width .toJsonText(options) + ',\n';         json += c869(options.tab) + '"height": ' + this.height.toJsonText(options) + ',\n';         json += c869(options.tab) + '"round": '  + this.round .toJsonText(options) + ',\n';         json += c869(options.tab) + '"bias": '   + this.bias  .toJsonText(options) + ',\n';           json += this.toBaseJsonText(options);           options.named = oldNamed;          options.tab--;         json += c869(options.tab) + '}';           return json;     }        toNewValue()     {         return this.copy();     }        l3609()     {         return super.l3609()             && this.x     .l3609()             && this.y     .l3609()             && this.width .l3609()             && this.height.l3609()             && this.round .l3609()             && this.bias  .l3609();     }            isValid()     {         return super.isValid()             && this.x     .isValid()             && this.y     .isValid()             && this.width .isValid()             && this.height.isValid()             && this.round .isValid()             && this.bias  .isValid();     }            static NaN()     {         return new p1847(             '',             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN());     }                    static parse(str, i = -1)     {         if (   i <  0 && str    == t962             || i >= 0 && str[i] == t962)             return [p1847.NaN(), 1];                   if (i < 0)         {             str = str.split(' ');             i   = 0;         }                   const i3666 = i;              const x      = n1835.parse(str[i]); i += x     [1];         const y      = n1835.parse(str[i]); i += y     [1];         const width  = n1835.parse(str[i]); i += width [1];         const height = n1835.parse(str[i]); i += height[1];         const round  = n1835.parse(str[i]); i += round [1];         const bias   = n1835.parse(str[i]); i += bias  [1];                   const rect = new p1847(             '',              x     [0],             y     [0],             width [0],             height[0],             round [0],             bias  [0]);                   i = u1842.parse(str, i, rect);                       return [rect, i - i3666];     } } 


class x1837 extends u1842 {     position;     x;     y;     width;     height;     round;     corners;        constructor(nodeId,                 position = new n1835(0),                 x        = new n1835(0),                  y        = new n1835(0),                  width    = new n1835(0),                  height   = new n1835(0),                  round    = new n1835(0),                  corners  = new n1835(0))     {         super(f1216, nodeId, 'polygon');          this.position = position;         this.x        = x;         this.y        = y;         this.width    = width;         this.height   = height;         this.round    = round;         this.corners  = corners;     }        static fromObject(c111)     {         return new x1837(             c111.nodeId,             new n1835(c111.position),              new n1835(c111.x       ),              new n1835(c111.y       ),              new n1835(c111.width   ),              new n1835(c111.height  ),              new n1835(c111.round   ),             new n1835(c111.corners ));     }        copy()     {         const copy = new x1837(             this.nodeId,             this.position.copy(),              this.x       .copy(),              this.y       .copy(),              this.width   .copy(),              this.height  .copy(),              this.round   .copy(),              this.corners .copy());              copy.m3266(this);          return copy;     }        equals(poly)     {         return poly             && this.position.equals(poly.position)             && this.x       .equals(poly.x       )             && this.y       .equals(poly.y       )             && this.width   .equals(poly.width   )             && this.height  .equals(poly.height  )             && this.round   .equals(poly.round   )             && this.corners .equals(poly.corners );     }        async eval(parse)     {         return this.copy();     }        l3609()     {         return super.l3609()             && this.position.l3609()             && this.x       .l3609()             && this.y       .l3609()             && this.width   .l3609()             && this.height  .l3609()             && this.round   .l3609()             && this.corners .l3609();     }        isValid()     {         return super.isValid()             && this.position.isValid()             && this.x       .isValid()             && this.y       .isValid()             && this.width   .isValid()             && this.height  .isValid()             && this.round   .isValid()             && this.corners .isValid();     }        toNewValue()     {         return this.copy();     }        toString()     {         return      this.position.toString()             + ' ' + this.x       .toString()             + ' ' + this.y       .toString()             + ' ' + this.width   .toString()             + ' ' + this.height  .toString()             + ' ' + this.round   .toString()             + ' ' + this.corners .toString()             + ' ' + super.toString();     }        u3605()     {         return      this.position.u3605()             + ' ' + this.x       .u3605()             + ' ' + this.y       .u3605()             + ' ' + this.width   .u3605()             + ' ' + this.height  .u3605()             + ' ' + this.round   .u3605()             + ' ' + this.corners .u3605();     }        l3606()     {         return      this.position.l3606()             + ' ' + this.x       .l3606()             + ' ' + this.y       .l3606()             + ' ' + this.width   .l3606()             + ' ' + this.height  .l3606()             + ' ' + this.round   .l3606()             + ' ' + this.corners .l3606();     }        toJsonText(options = {})      {         let json = '';                   if (options.named)             json += '\n' + c869(options.tab);           json += '{\n';         options.tab++;          const oldNamed = options.named;         options.named = true;           json += c869(options.tab) + '"position": "' + EllipsePositions[this.position.value] + '",\n';         json += c869(options.tab) + '"x": '         + this.x      .toJsonText(options) + ',\n';         json += c869(options.tab) + '"y": '         + this.y      .toJsonText(options) + ',\n';         json += c869(options.tab) + '"width": '     + this.width  .toJsonText(options) + ',\n';         json += c869(options.tab) + '"height": '    + this.height .toJsonText(options) + ',\n';         json += c869(options.tab) + '"round": '     + this.round  .toJsonText(options) + ',\n';         json += c869(options.tab) + '"corners": '   + this.corners.toJsonText(options) + ',\n';           json += this.toBaseJsonText(options);           options.named = oldNamed;          options.tab--;         json += c869(options.tab) + '}';           return json;     }        static NaN()     {         return new x1837(             '',             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN());     }                    static parse(str, i = -1)     {         if (   i <  0 && str    == t962             || i >= 0 && str[i] == t962)             return [x1837.NaN(), 1];                   if (i < 0)         {             str = str.split(' ');             i   = 0;         }                   const i3666 = i;              const pos     = n1835.parse(str[i]); i += pos    [1];         const x       = n1835.parse(str[i]); i += x      [1];         const y       = n1835.parse(str[i]); i += y      [1];         const width   = n1835.parse(str[i]); i += width  [1];         const height  = n1835.parse(str[i]); i += height [1];         const round   = n1835.parse(str[i]); i += round  [1];         const corners = n1835.parse(str[i]); i += corners[1];                   const poly = new x1837(             '',              pos    [0],             x      [0],             y      [0],             width  [0],             height [0],             round  [0],             corners[0]);                   i = u1842.parse(str, i, poly);                       return [poly, i - i3666];     } } 


class a1843 extends u1842 {     position;     x;     y;     width;     height;     round;     points;     convex;        constructor(nodeId,                 position = new n1835(0),                  x        = new n1835(0),                  y        = new n1835(0),                  width    = new n1835(0),                  height   = new n1835(0),                  round    = new n1835(0),                  points   = new n1835(0),                 convex   = new n1835(0))     {         super(k1219, nodeId, 'star');          this.position = position;         this.x        = x;         this.y        = y;         this.width    = width;         this.height   = height;         this.round    = round;         this.points   = points;         this.convex   = convex;     }        static fromObject(c111)     {         return new a1843(             c111.nodeId,             new n1835(c111.position),              new n1835(c111.x       ),              new n1835(c111.y       ),              new n1835(c111.width   ),              new n1835(c111.height  ),              new n1835(c111.round   ),             new n1835(c111.points  ),             new n1835(c111.convex  ));     }        copy()     {         const copy = new a1843(             this.nodeId,             this.position.copy(),              this.x       .copy(),              this.y       .copy(),              this.width   .copy(),              this.height  .copy(),              this.round   .copy(),              this.points  .copy(),             this.convex  .copy());          copy.m3266(this);          return copy;     }        equals(star)     {         return star             && this.position.equals(star.position)             && this.x       .equals(star.x       )             && this.y       .equals(star.y       )             && this.width   .equals(star.width   )             && this.height  .equals(star.height  )             && this.round   .equals(star.round   )             && this.points  .equals(star.points  )             && this.convex  .equals(star.convex  );     }        async eval(parse)     {         return this.copy();     }        l3609()     {         return super.l3609()             && this.position.l3609()             && this.x       .l3609()             && this.y       .l3609()             && this.width   .l3609()             && this.height  .l3609()             && this.round   .l3609()             && this.points  .l3609()             && this.convex  .l3609();     }            isValid()     {         return super.isValid()             && this.position.isValid()             && this.x       .isValid()             && this.y       .isValid()             && this.width   .isValid()             && this.height  .isValid()             && this.round   .isValid()             && this.points  .isValid()             && this.convex  .isValid();     }            toNewValue()     {         return this.copy();     }        toString()     {         return      this.position.toString()             + ' ' + this.x       .toString()             + ' ' + this.y       .toString()             + ' ' + this.width   .toString()             + ' ' + this.height  .toString()             + ' ' + this.round   .toString()             + ' ' + this.points  .toString()             + ' ' + this.convex  .toString()             + ' ' + super.toString();     }        u3605()     {         return      this.position.u3605()             + ' ' + this.x       .u3605()             + ' ' + this.y       .u3605()             + ' ' + this.width   .u3605()             + ' ' + this.height  .u3605()             + ' ' + this.round   .u3605()             + ' ' + this.points  .u3605()             + ' ' + this.convex  .u3605();     }        l3606()     {         return      this.position.l3606()             + ' ' + this.x       .l3606()             + ' ' + this.y       .l3606()             + ' ' + this.width   .l3606()             + ' ' + this.height  .l3606()             + ' ' + this.round   .l3606()             + ' ' + this.points  .l3606()             + ' ' + this.convex  .l3606();     }        toJsonText(options = {})      {         let json = '';                   if (options.named)             json += '\n' + c869(options.tab);           json += '{\n';         options.tab++;          const oldNamed = options.named;         options.named = true;           json += c869(options.tab) + '"position": "' + EllipsePositions[this.position.value] + '",\n';         json += c869(options.tab) + '"x": '         + this.x     .toJsonText(options) + ',\n';         json += c869(options.tab) + '"y": '         + this.y     .toJsonText(options) + ',\n';         json += c869(options.tab) + '"width": '     + this.width .toJsonText(options) + ',\n';         json += c869(options.tab) + '"height": '    + this.height.toJsonText(options) + ',\n';         json += c869(options.tab) + '"round": '     + this.round .toJsonText(options) + ',\n';         json += c869(options.tab) + '"points": '    + this.points.toJsonText(options) + ',\n';         json += c869(options.tab) + '"convex": '    + this.convex.toJsonText(options) + ',\n';           json += this.toBaseJsonText(options);           options.named = oldNamed;          options.tab--;         json += c869(options.tab) + '}';           return json;     }        static NaN()     {         return new a1843(             '',             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN());     }                    static parse(str, i = -1)     {         if (   i <  0 && str    == t962             || i >= 0 && str[i] == t962)             return [a1843.NaN(), 1];                   if (i < 0)         {             str = str.split(' ');             i   = 0;         }                   const i3666 = i;              const pos    = n1835.parse(str[i]); i += pos   [1];         const x      = n1835.parse(str[i]); i += x     [1];         const y      = n1835.parse(str[i]); i += y     [1];         const width  = n1835.parse(str[i]); i += width [1];         const height = n1835.parse(str[i]); i += height[1];         const round  = n1835.parse(str[i]); i += round [1];         const points = n1835.parse(str[i]); i += points[1];         const convex = n1835.parse(str[i]); i += convex[1];                   const star = new a1843(             '',              pos   [0],             x     [0],             y     [0],             width [0],             height[0],             round [0],             points[0],             convex[0]);                   i = u1842.parse(str, i, star);                       return [star, i - i3666];     } } 


class l1845 extends u1842 {     text;     x;     y;     width;     height;     font;     style;     size;     alignX;     alignY;     lineHeight;     letterSpacing;            constructor(nodeId,                 text          = new e1846(),                 x             = new n1835(0),                  y             = new n1835(0),                  width         = new n1835(0),                  height        = new n1835(0),                  font          = new n1835(0),                 style         = new n1835(0),                 size          = new n1835(0),                 alignX        = new n1835(0),                 alignY        = new n1835(0),                 lineHeight    = new n1835(0),                 letterSpacing = new n1835(0))     {         super(z1222, nodeId, 'text');          this.text          = text;         this.x             = x;         this.y             = y;         this.width         = width;         this.height        = height;         this.font          = font;         this.style         = style;         this.size          = size;         this.alignX        = alignX;         this.alignY        = alignY;         this.lineHeight    = lineHeight;         this.letterSpacing = letterSpacing;          this.objects       = [];     }        static fromObject(c111)     {         return new l1845(             c111.nodeId,             new n1835(c111.text         ),              new n1835(c111.x            ),              new n1835(c111.y            ),              new n1835(c111.width        ),              new n1835(c111.height       ),              new n1835(c111.font         ),             new n1835(c111.style        ),             new n1835(c111.size         ),             new n1835(c111.alignX       ),             new n1835(c111.alignY       ),             new n1835(c111.lineHeight   ),             new n1835(c111.letterSpacing));     }        copy()     {         const copy = new l1845(             this.nodeId,             this.text         .copy(),             this.x            .copy(),              this.y            .copy(),              this.width        .copy(),              this.height       .copy(),              this.font         .copy(),             this.style        .copy(),             this.size         .copy(),             this.alignX       .copy(),             this.alignY       .copy(),             this.lineHeight   .copy(),             this.letterSpacing.copy());           copy.m3266(this);          return copy;     }        equals(text)     {         return text             && this.text         .equals(text.text         )             && this.x            .equals(text.x            )             && this.y            .equals(text.y            )             && this.width        .equals(text.width        )             && this.height       .equals(text.height       )             && this.font         .equals(text.font         )             && this.style        .equals(text.style        )             && this.size         .equals(text.size         )             && this.alignX       .equals(text.alignX       )             && this.alignY       .equals(text.alignY       )             && this.lineHeight   .equals(text.lineHeight   )             && this.letterSpacing.equals(text.letterSpacing);     }        async eval(parse)     {         return this.copy();     }        l3609()     {         return super.l3609()             && this.text         .l3609()             && this.x            .l3609()             && this.y            .l3609()             && this.width        .l3609()             && this.height       .l3609()             && this.font         .l3609()             && this.style        .l3609()             && this.size         .l3609()             && this.alignX       .l3609()             && this.alignY       .l3609()             && this.lineHeight   .l3609()             && this.letterSpacing.l3609();     }            isValid()     {         return super.isValid()             && this.text         .isValid()             && this.x            .isValid()             && this.y            .isValid()             && this.width        .isValid()             && this.height       .isValid()             && this.font         .isValid()             && this.style        .isValid()             && this.size         .isValid()             && this.alignX       .isValid()             && this.alignY       .isValid()             && this.lineHeight   .isValid()             && this.letterSpacing.isValid();     }            toNewValue()     {         return this.copy();     }        toString()     {         return      this.text         .c1932()              + ' ' + this.x            .toString()             + ' ' + this.y            .toString()             + ' ' + this.width        .toString()             + ' ' + this.height       .toString()             + ' ' + this.font         .toString()             + ' ' + this.style        .toString()             + ' ' + this.size         .toString()             + ' ' + this.alignX       .toString()             + ' ' + this.alignY       .toString()             + ' ' + this.lineHeight   .toString()             + ' ' + this.letterSpacing.toString()             + ' ' + super.toString();         }        u3605()     {         return 'textShape';                                                                                                                                                                       }        l3606()     {         return      this.text         .l3606()             + ' ' + this.x            .l3606()             + ' ' + this.y            .l3606()             + ' ' + this.width        .l3606()             + ' ' + this.height       .l3606()             + ' ' + this.font         .l3606()             + ' ' + this.style        .l3606()             + ' ' + this.size         .l3606()             + ' ' + this.alignX       .l3606()             + ' ' + this.alignY       .l3606()             + ' ' + this.lineHeight   .l3606()             + ' ' + this.letterSpacing.l3606();     }        c1932()     {         return      this.text         .c1932()             + ' ' + this.x            .c1932()             + ' ' + this.y            .c1932()             + ' ' + this.width        .c1932()             + ' ' + this.height       .c1932()             + ' ' + this.font         .c1932()             + ' ' + this.style        .c1932()             + ' ' + this.size         .c1932()             + ' ' + this.alignX       .c1932()             + ' ' + this.alignY       .c1932()             + ' ' + this.lineHeight   .c1932()             + ' ' + this.letterSpacing.c1932();     }        toJsonText(options = {})      {         let json = '';                   if (options.named)             json += '\n' + c869(options.tab);           json += '{\n';         options.tab++;          const oldNamed = options.named;         options.named = true;           const fontName   = n3920[this.font.value];         const fontStyles = getFontStyles(fontName);                  json += c869(options.tab) + '"text": '          + this.text         .toJsonText(options) + ',\n';         json += c869(options.tab) + '"x": '             + this.x            .toJsonText(options) + ',\n';         json += c869(options.tab) + '"y": '             + this.y            .toJsonText(options) + ',\n';         json += c869(options.tab) + '"width": '         + this.width        .toJsonText(options) + ',\n';         json += c869(options.tab) + '"height": '        + this.height       .toJsonText(options) + ',\n';         json += c869(options.tab) + '"font": "'         + fontName                               + '",\n';         json += c869(options.tab) + '"style": "'        + fontStyles[this.style.value]           + '",\n';         json += c869(options.tab) + '"size": '          + this.size         .toJsonText(options) + ',\n';         json += c869(options.tab) + '"alignX": "'       + TextAlignX[this.alignX.value] + '",\n';         json += c869(options.tab) + '"alignY": "'       + TextAlignY[this.alignY.value] + '",\n';         json += c869(options.tab) + '"lineHeight": '    + this.lineHeight   .toJsonText(options) + ',\n';         json += c869(options.tab) + '"letterSpacing": ' + this.letterSpacing.toJsonText(options) + ',\n';           json += this.toBaseJsonText(options);           options.named = oldNamed;          options.tab--;         json += c869(options.tab) + '}';           return json;     }        static NaN()     {         return new l1845(             '',             new e1846(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN());     }                    static parse(str, i = -1)     {         if (   i <  0 && str    == t962             || i >= 0 && str[i] == t962)             return [l1845.NaN(), 1];                   if (i < 0)         {             str = str.split(' ');             i   = 0;         }                   const i3666 = i;              const text          = e1846.parse  (str[i]); i += text         [1];         const x             = n1835.parse(str[i]); i += x            [1];         const y             = n1835.parse(str[i]); i += y            [1];         const width         = n1835.parse(str[i]); i += width        [1];         const height        = n1835.parse(str[i]); i += height       [1];         const font          = n1835.parse(str[i]); i += font         [1];         const style         = n1835.parse(str[i]); i += style        [1];         const size          = n1835.parse(str[i]); i += size         [1];         const alignX        = n1835.parse(str[i]); i += alignX       [1];         const alignY        = n1835.parse(str[i]); i += alignY       [1];         const lineHeight    = n1835.parse(str[i]); i += lineHeight   [1];         const letterSpacing = n1835.parse(str[i]); i += letterSpacing[1];                   const txts = new l1845(             '',              text         [0],             x            [0],             y            [0],             width        [0],             height       [0],             font         [0],             style        [0],             size         [0],             alignX       [0],             alignY       [0],             lineHeight   [0],             letterSpacing[0]);                   i = u1842.parse(str, i, txts);                       return [txts, i - i3666];     } } 


class r1836 extends i1863 {     static { d1855.types[p1225] = this; }        nodeId;      x;     y;     smooth;       sp0 = null;      sp1 = null;      sp2 = null;         constructor(nodeId,                 x = new n1835(0),                  y = new n1835(0),                 smooth = null)     {         super(p1225, 'point');          this.nodeId  = nodeId;          this.x       = x;         this.y       = y;         this.smooth  = smooth;           this.w3639();     }        static fromObject(c111)     {         return new r1836(             c111.nodeId,             new n1835(c111.x     ),              new n1835(c111.y     ),              new n1835(c111.smooth));     }        copy()     {         const copy = new r1836(             this.nodeId,             this.x.copy(),              this.y.copy());          if (this.smooth) copy.smooth = this.smooth.copy();          copy.m3266(this);          copy.sp0 = clone(this.sp0);         copy.sp1 = clone(this.sp1);         copy.sp2 = clone(this.sp2);          return copy;     }        equals(p)     {         return p             && this.x.equals(p.x)             && this.y.equals(p.y);     }        w3639(cx = 0, cy = 0) {         this.sp0 = point(cx,   cy  );         this.sp1 = point(cx+1, cy  );         this.sp2 = point(cx,   cy+1);     }        applySpaceTransform(u4087, space)     {         this.sp0 = n3628(this.sp0, u4087, space);         this.sp1 = n3628(this.sp1, u4087, space);         this.sp2 = n3628(this.sp2, u4087, space);     }        static create(nodeId, x, y)     {         return new r1836(             nodeId,             new n1835(x),             new n1835(y));     }        static fromPoint(nodeId, p)     {         return new r1836(             nodeId,             new n1835(p.x),             new n1835(p.y));     }        async eval(parse)     {         return this.copy();     }        l3609()     {         return this.x.l3609()             && this.y.l3609()             && (  !this.smooth                 || this.smooth.l3609());     }        isValid()     {         return this.x.isValid()             && this.y.isValid()             && (  !this.smooth                 || this.smooth.isValid());     }        toString()     {         return this.x.isValid()             && this.y.isValid()             ?         this.x.toString()               + ' ' + this.y.toString()             : t962;     }        u3605()     {         return this.x.isValid()             && this.y.isValid()             ?   '(' + this.x.u3605()               + ', ' + this.y.u3605()               + ')'             : t962;     }        l3606()     {         return this.x.isValid()             && this.y.isValid()             ?         this.x.l3606()               + ' ' + this.y.l3606()             : t962;     }        toJsonText(options = {})      {         const SL  = s => options.singleLine ? ''  : s;         const SL_ = s => options.singleLine ? ' ' : s;                                                         let json = '';           if (options.named)             json += SL('\n' + c869(options.tab));           json += '{' + SL('\n');         options.tab++;          const oldNamed = options.named;         options.named = true;           json += SL_(c869(options.tab)) + '"x": ' + this.x.toJsonText(options) + ',' + SL('\n');         json += SL_(c869(options.tab)) + '"y": ' + this.y.toJsonText(options);          if (   this.smooth             && this.smooth.value != 100)             json += ',' + SL_('\n' + c869(options.tab)) + '"smooth": ' + this.smooth.toJsonText(options);           options.named = oldNamed;          options.tab--;         json += SL_('\n' + c869(options.tab)) + '}';           options.lastExpanded = !options.singleLine;          return json;     }        toNewValue()     {         return this.copy();     }        n3644()     {         return point(             this.x.value,             this.y.value);     }        s2757(gen)     {         return '';     }        static NaN()     {         return new r1836(             '',             n1835.NaN(),              n1835.NaN());     }        static parseRequest(parse)     {         parse.pos++;               const point = parse.move();              if (parse.settings.logRequests)              r1944(p1225, point, parse);              return r1836.parse(point)[0];     }        static parse(str, i = -1)     {         if (   i <  0 && str    == t962             || i >= 0 && str[i] == t962)             return [r1836.NaN(), 1];           if (i < 0)         {             str = str.split(' ');             i   = 0;         }           const i3666 = i;          const x = n1835.parse(str[i]); i += x[1];         const y = n1835.parse(str[i]); i += y[1];           const point = new r1836(             '',              x[0],             y[0]);           return [point, i - i3666];     } }


class n1850 extends u1842 {     static { d1855.types[c1229] = this; }        points;     closed;     degree;     winding;     round;        constructor(nodeId,                 points  = new x1834(),                  closed  = new n1835(0),                  degree  = new n1835(0),                  winding = new n1835(0),                  round   = new n1835(0))     {         super(c1229, nodeId, 'vectorPath');          this.valueId = 'vectorPath';          this.points  = points ?? new x1834();         this.closed  = closed;         this.degree  = degree;         this.winding = winding;         this.round   = round;     }        static fromObject(c111)     {         return new n1850(             c111.nodeId,             new x1834(c111.points.map(p => r1836.fromPoint(c111.nodeId, p))),              new n1835(c111.closed ),              new n1835(c111.degree ),              new n1835(c111.winding),              new n1835(c111.round  ));     }        copy()     {         const copy = new n1850(             this.nodeId,             this.points .copy(),              this.closed .copy(),              this.degree .copy(),              this.winding.copy(),              this.round  .copy());          copy.m3266(this);          return copy;     }        equals(rect)     {         return rect             && this.points .equals(rect.points )             && this.closed .equals(rect.closed )             && this.degree .equals(rect.degree )             && this.winding.equals(rect.winding)             && this.round  .equals(rect.round  );     }        async eval(parse)     {         return this.copy();     }        toString()     {         return      this.points .toString()             + ' ' + this.closed .toString()             + ' ' + this.degree .toString()             + ' ' + this.winding.toString()             + ' ' + this.round  .toString()             + ' ' + super.toString();     }        u3605()     {         return      this.points .u3605()             + ' ' + this.closed .u3605()             + ' ' + this.degree .u3605()             + ' ' + this.winding.u3605()             + ' ' + this.round  .u3605();     }        l3606()     {         return      this.points .l3606()             + ' ' + this.closed .l3606()             + ' ' + this.degree .l3606()             + ' ' + this.winding.l3606()             + ' ' + this.round  .l3606();     }        toNewValue()     {         return this.copy();     }        l3609()     {         return super.l3609()             && this.points .l3609()             && this.closed .l3609()             && this.degree .l3609()             && this.winding.l3609()             && this.round  .l3609();     }            isValid()     {         return super.isValid()             && this.points  && this.points .isValid()             && this.closed  && this.closed .isValid()             && this.degree  && this.degree .isValid()             && this.winding && this.winding.isValid()             && this.round   && this.round  .isValid();     }        toJsonText(options = {})      {         const WS = s =>                 options.whiteSpace              && options.lastExpanded                 ? s                  : '';           let json = '';                   if (options.named)             json += '\n' + c869(options.tab);           json += '{\n';         options.tab++;          const oldNamed     = options.named;         options.named     = true;                  const quote = options.quoteValues ? '"' : '';          const oldShowNames = options.showNames;         options.showNames = false;         json += c869(options.tab) + '"points": '   + this.points .toJsonText(options) + ',\n';         options.showNames = oldShowNames;          json += WS('\n');         json += c869(options.tab) + '"closed": '   + quote + o935(this.closed.value > 0) + quote + ',\n';         json += c869(options.tab) + '"degree": "'  + PathDegrees [this.degree .value] + '",\n';         json += c869(options.tab) + '"winding": "' + PathWindings[this.winding.value] + '",\n';         json += c869(options.tab) + '"round": '    + this.round  .toJsonText(options) + ',\n';           json += this.toBaseJsonText(options);           options.named     = oldNamed;          options.tab--;         json += c869(options.tab) + '}';           return json;     }            static NaN()     {         return new n1850(             '',             x1834  .NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN());     }        static parseRequest(parse)     {         parse.pos++;               const path = parse.move();              if (parse.settings.logRequests)              r1944(c1229, path, parse);              return n1850.parse(path)[0];     }        static parse(str, i = -1)     {         if (   i <  0 && str    == t962             || i >= 0 && str[i] == t962)             return [n1850.NaN(), 1];           if (i < 0)         {             str = str.split(' ');             i   = 0;         }           const i3666 = i;          const points  = x1834.parse  (str, i); i += points [1];         const closed  = n1835.parse(str[i]); i += closed [1];         const degree  = n1835.parse(str[i]); i += degree [1];         const winding = n1835.parse(str[i]); i += winding[1];         const round   = n1835.parse(str[i]); i += round  [1];          const path = new n1850(             '',              points [0],             closed [0],             degree [0],             winding[0],             round  [0]);           i = u1842.parse(str, i, path);                   return [path, i - i3666];     } }


class i1852 extends i1863 {     static { d1855.types[r1232] = this; }        nodeId;      x;     y;     join;     cap;     round;        constructor(nodeId,                 x     = new n1835(0),                  y     = new n1835(0),                 join  = new n1835(0),                 cap   = new n1835(0),                 round = new n1835(0))     {         super(r1232, 'vectorVertex');          this.nodeId = nodeId;          this.x      = x    .copy();         this.y      = y    .copy();         this.join   = join .copy();         this.cap    = cap  .copy();         this.round  = round.copy();     }        copy()     {         const copy = new i1852(             this.nodeId,             this.x    .copy(),              this.y    .copy(),              this.join .copy(),              this.cap  .copy(),              this.round.copy());          copy.m3266(this);          return copy;     }        equals(p)     {         return p             && this.x    .equals(p.x    )             && this.y    .equals(p.y    )             && this.join .equals(p.join )             && this.cap  .equals(p.cap  )             && this.round.equals(p.round);     }        static create(nodeId, x, y)     {         return new i1852(             nodeId,             new n1835(x    ),             new n1835(y    ),             new n1835(join ),             new n1835(cap  ),             new n1835(round));     }        static fromPoint(nodeId, p)     {         return new i1852(             nodeId,             new n1835(p.x),             new n1835(p.y),             new n1835(0),             new n1835(0),             new n1835(0));     }        async eval(parse)     {         return this;     }        l3609()     {         return this.x    .l3609()             && this.y    .l3609()             && this.join .l3609()             && this.cap  .l3609()             && this.round.l3609();     }        isValid()     {         return this.x    .isValid()             && this.y    .isValid()             && this.join .isValid()             && this.cap  .isValid()             && this.round.isValid();     }        toString()     {         return      this.x    .toString()             + ' ' + this.y    .toString()             + ' ' + this.join .toString()             + ' ' + this.cap  .toString()             + ' ' + this.round.toString();     }        u3605()     {         return      this.x    .u3605()             + ' ' + this.y    .u3605()             + ' ' + this.join .u3605()             + ' ' + this.cap  .u3605()             + ' ' + this.round.u3605();     }        l3606()     {         return      this.x    .l3606()             + ' ' + this.y    .l3606()             + ' ' + this.join .l3606()             + ' ' + this.cap  .l3606()             + ' ' + this.round.l3606();     }        toNewValue()     {         return this.copy();     }        n3644()     {         return point(             this.x.value,             this.y.value);     }        s2757(gen)     {         return '';     }        static NaN()     {         return new i1852(             '',             n1835.NaN(),              n1835.NaN(),              n1835.NaN(),              n1835.NaN(),              n1835.NaN());     }        static parseRequest(parse)     {         parse.pos++;               const point = parse.move();              if (parse.settings.logRequests)              r1944(r1232, point, parse);              return i1852.parse(point)[0];     }        static parse(str, i = -1)     {         if (   i <  0 && str    == t962             || i >= 0 && str[i] == t962)             return [i1852.NaN(), 1];           if (i < 0)         {             str = str.split(' ');             i   = 0;         }           const i3666 = i;          const x     = n1835.parse(str[i]); i += x    [1];         const y     = n1835.parse(str[i]); i += y    [1];         const join  = n1835.parse(str[i]); i += join [1];         const cap   = n1835.parse(str[i]); i += cap  [1];         const round = n1835.parse(str[i]); i += round[1];           const point = new i1852(             '',              x    [0],             y    [0],             join [0],             cap  [0],             round[0]);           return [point, i - i3666];     } }


class v1848 extends i1863 {     static { d1855.types[e1235] = this; }        nodeId;      start;     end;     j3569;     t3570;        constructor(nodeId,                 start,                  end,                 j3569 = r1836.create(nodeId, 0, 0),                 t3570   = r1836.create(nodeId, 0, 0))     {         super(e1235, 'vectorEdge');          this.nodeId = nodeId;          this.start        = start       .copy();                this.end          = end         .copy();                  this.j3569 = j3569.copy();         this.t3570   = t3570  .copy();       }        copy()     {         const copy = new v1848(             this.nodeId,             this.start       .copy(),              this.end         .copy(),              this.j3569.copy(),              this.t3570  .copy());          copy.m3266(this);          return copy;     }        equals(edge)     {         return edge             && this.start       .equals(edge.start       )             && this.end         .equals(edge.end         )             && this.j3569.equals(edge.j3569)             && this.  t3570.equals(edge.  t3570);     }        static create(nodeId, start, end, j3569, t3570)     {         return new v1848(             nodeId,             start,             end,             r1836.create(nodeId, j3569.x, j3569.y),             r1836.create(nodeId,   t3570.x,   t3570.y));     }        async eval(parse)     {         return this;     }        l3609()     {         return this.start       .l3609()             && this.end         .l3609()             && this.j3569.l3609()             && this.t3570  .l3609();     }        isValid()     {         return this.start       .isValid()             && this.end         .isValid()             && this.j3569.isValid()             && this.t3570  .isValid();     }        toString()     {         return      this.start       .toString()             + ' ' + this.end         .toString()             + ' ' + this.j3569.toString()             + ' ' + this.t3570  .toString();     }        u3605()     {         return      this.start       .toString()             + ' ' + this.end         .toString()             + ' ' + this.j3569.toString()             + ' ' + this.t3570  .toString();     }        l3606()     {         return      this.start       .l3606()             + ' ' + this.end         .l3606()             + ' ' + this.j3569.l3606()             + ' ' + this.t3570  .l3606();     }        toNewValue()     {         return this.copy();     }        s2757(gen)     {         return '';     }        static NaN()     {         return new v1848(             '',             i1852.NaN(),              i1852.NaN(),              r1836.NaN(),              r1836.NaN());     }        static parseRequest(parse)     {         parse.pos++;               const edge = parse.move();              if (parse.settings.logRequests)              r1944(e1235, edge, parse);              return v1848.parse(edge)[0];     }        static parse(str, i = -1)     {         if (   i <  0 && str    == t962             || i >= 0 && str[i] == t962)             return [v1848.NaN(), 1];           if (i < 0)         {             str = str.split(' ');             i   = 0;         }           const i3666 = i;          const start        = i1852.parse(str, i); i += start       [1];         const end          = i1852.parse(str, i); i += end         [1];         const j3569 = r1836.parse       (str, i); i += j3569[1];         const t3570   = r1836.parse       (str, i); i +=   t3570[1];           const edge = new v1848(             '',              start       [0],             end         [0],             j3569[0],             t3570[0]);           return [edge, i - i3666];     } }


class c1851 extends u1842 {     static { d1855.types[k1238] = this; }        loops;       winding;      fills = [];        constructor(nodeId,                 loops   = new x1834(),                  winding = new n1835(0))     {         super(k1238, nodeId, 'vectorRegion');          this.loops   = loops;           this.winding = winding;     }        static fromObject(c111)     {         return new c1851(             c111.nodeId,             new x1834(),               new x1834());      }        copy()     {         const copy = new c1851(             this.nodeId,             this.loops  .copy(),              this.winding.copy());          copy.fills = clone(this.fills);                  copy.m3266(this);          return copy;     }        equals(region)     {         return region             && this.loops  .equals(region.loops  )             && this.winding.equals(region.winding);     }                                              async eval(parse)     {         return this;     }        l3609()     {         return this.loops  .l3609()             && this.winding.l3609();     }        isValid()     {         return this.loops  .isValid()             && this.winding.isValid();     }        toString()     {         return      this.loops  .toString()             + ' ' + this.winding.toString();     }        u3605()     {         return      this.loops  .u3605()             + ' ' + this.winding.u3605();     }        l3606()     {         return      this.loops  .l3606()             + ' ' + this.winding.l3606();     }        toNewValue()     {         return this.copy();     }        s2757(gen)     {         return '';     }        static NaN()     {         return new c1851(             '',             x1834  .NaN(),              n1835.NaN());     }        static parseRequest(parse)     {         parse.pos++;               const region = parse.move();              if (parse.settings.logRequests)              r1944(k1238, region, parse);              return c1851.parse(region)[0];     }        static parse(str, i = -1)     {         if (   i <  0 && str    == t962             || i >= 0 && str[i] == t962)             return [c1851.NaN(), 1];           if (i < 0)         {             str = str.split(' ');             i   = 0;         }           const i3666 = i;          const loops   = x1834.parse  (str, i); i += loops  [1];         const winding = n1835.parse(str[i]); i += winding[1];           const region = new c1851(             '',              loops  [0],             winding[0]);           i = u1842.parse(str, i, region);           return [region, i - i3666];     } }


class k1849 extends i1863 {     static { d1855.types[r1241] = this; }        nodeId;      regions;        constructor(nodeId,                 regions = new x1834())     {         super(r1241, 'vectorNetwork');          this.nodeId  = nodeId;          this.regions = regions;      }        static fromObject(c111)     {         return new k1849(             c111.nodeId,             new x1834(c111.regions.map(r => c1851.fromObject(c111.nodeId, r))));     }        copy()     {         const copy = new k1849(             this.nodeId,             this.regions.copy());          copy.m3266(this);          return copy;     }        equals(other)     {         return other             && this.regions.equals(other.regions);     }        static create(nodeId, regions)     {         return new k1849(             nodeId,             regions);     }        async eval(parse)     {         return this;     }        l3609()     {         return this.regions.l3609();     }        isValid()     {         return this.regions.isValid();     }        toString()     {         return this.regions.toString();     }        u3605()     {         return this.regions.u3605();     }        l3606()     {         return this.regions.l3606();     }        toNewValue()     {         return this.copy();     }        s2757(gen)     {         return '';     }        static NaN()     {         return new k1849(             '',             x1834.NaN());     }        static parseRequest(parse)     {         parse.pos++;               const region = parse.move();              if (parse.settings.logRequests)              r1944(r1241, region, parse);              return k1849.parse(region)[0];     }        static parse(str, i = -1)     {         if (   i <  0 && str    == t962             || i >= 0 && str[i] == t962)             return [k1849.NaN(), 1];           if (i < 0)         {             str = str.split(' ');             i   = 0;         }           const i3666 = i;          const regions = x1834.parse(str, i); i += regions[1];           const net = new k1849(             '',              regions[0]);           return [net, i - i3666];     } }


class w1840 extends u1842 {     static { d1855.types[x1267] = this; }        operation;     children;        constructor(nodeId, children, operation)     {         super(x1267, nodeId, 'boolean');          this.children  = children;         this.operation = operation;          this.objects =              children.objects             ? children.objects.map(o => o.copy())             : null;     }        copy()     {         const copy = new w1840(             this.nodeId,             this.children .copy(),             this.operation.copy());          copy.m3266(this);          return copy;     }        equals(bool)     {         return bool             && this.children .equals(bool.children )             && this.operation.equals(bool.operation);     }        async eval(parse)     {         return this;     }        toString()     {         return      this.children .toString()             + ' ' + this.operation.toString();     }        u3605()     {         return      this.children .u3605()             + ' ' + this.operation.u3605();     }        l3606()     {         return      this.children .l3606()             + ' ' + this.operation.l3606();     }        toNewValue()     {         return this.copy();     }        isValid()     {         return super.isValid()             && this.children .isValid()             && this.operation.isValid();     }            static NaN()     {         return new w1840(             '',             x1834  .NaN(),             n1835.NaN());     }                    static parse(str, i = -1)     {         if (   i <  0 && str    == t962             || i >= 0 && str[i] == t962)             return [w1840.NaN(), 1];                   if (i < 0)         {             str = str.split(' ');             i   = 0;         }                   const i3666 = i;              const children  = x1834.parse  (str, i); i += children [1];         const operation = n1835.parse(str[i]); i += operation[1];              const bool = new w1840(             '',              children [0],             operation[0]);                   i = u1842.parse(str, i, bool);                       return [bool, i - i3666];     } } 


class h2418 extends u1842 {     static { d1855.types[g1214] = this; }        shape;     x;     y;     width;     amplitude;     frequency;     offset;     alignX;       alignY;        degree;        constructor(nodeId,                 shape     = new n1835(0),                 x         = new n1835(0),                  y         = new n1835(0),                  width     = new n1835(0),                  amplitude = new n1835(0),                 frequency = new n1835(0),                 offset    = new n1835(0),                 alignX    = new n1835(0),                 alignY    = new n1835(0))     {         super(g1214, nodeId, 'wavePath');          this.shape     = shape;         this.x         = x;         this.y         = y;         this.width     = width;         this.amplitude = amplitude;         this.frequency = frequency;         this.offset    = offset;         this.alignX    = alignX;         this.alignY    = alignY;          this.degree   = new n1835(2);     }        copy()     {         const copy = new h2418(             this.nodeId,             this.shape    .copy(),             this.x        .copy(),              this.y        .copy(),              this.width    .copy(),              this.amplitude.copy(),             this.frequency.copy(),             this.offset   .copy(),             this.alignX   .copy(),             this.alignY   .copy());          copy.m3266(this);          return copy;     }        equals(wave)     {         return wave             && this.shape    .equals(wave.shape    )             && this.x        .equals(wave.x        )             && this.y        .equals(wave.y        )             && this.width    .equals(wave.width    )             && this.amplitude.equals(wave.amplitude)             && this.frequency.equals(wave.frequency)             && this.offset   .equals(wave.offset   )             && this.alignX   .equals(wave.alignX   )             && this.alignY   .equals(wave.alignY   );     }        async eval(parse)     {         return this.copy();     }                    l3609()     {         return super.l3609()             && this.shape    .l3609()             && this.x        .l3609()             && this.y        .l3609()             && this.width    .l3609()             && this.amplitude.l3609()             && this.frequency.l3609()             && this.offset   .l3609()             && this.alignX   .l3609()             && this.alignY   .l3609();     }        isValid()     {         return super.isValid()             && this.shape    .isValid()             && this.x        .isValid()             && this.y        .isValid()             && this.width    .isValid()             && this.amplitude.isValid()             && this.frequency.isValid()             && this.offset   .isValid()             && this.alignX   .isValid()             && this.alignY   .isValid();     }        toNewValue()     {         return this.copy();     }        toString()     {         return      this.shape    .toString()             + ' ' + this.x        .toString()             + ' ' + this.y        .toString()             + ' ' + this.width    .toString()             + ' ' + this.amplitude.toString()             + ' ' + this.frequency.toString()             + ' ' + this.offset   .toString()             + ' ' + this.alignX   .toString()             + ' ' + this.alignY   .toString()             + ' ' + super.toString();     }        u3605()     {         return 'wave';                                                                                                                          }        l3606()     {         return      this.shape    .l3606()             + ' ' + this.x        .l3606()             + ' ' + this.y        .l3606()             + ' ' + this.width    .l3606()             + ' ' + this.amplitude.l3606()             + ' ' + this.frequency.l3606()             + ' ' + this.offset   .l3606()             + ' ' + this.alignX   .l3606()             + ' ' + this.alignY   .l3606();     }        static NaN()     {         return new h2418(             '',             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN());     }                    static parse(str, i = -1)     {         if (   i <  0 && str    == t962             || i >= 0 && str[i] == t962)             return [h2418.NaN(), 1];                   if (i < 0)         {             str = str.split(' ');             i   = 0;         }                   const i3666 = i;              const shape     = n1835.parse(str[i]); i += shape    [1];         const x         = n1835.parse(str[i]); i += x        [1];         const y         = n1835.parse(str[i]); i += y        [1];         const width     = n1835.parse(str[i]); i += width    [1];         const amplitude = n1835.parse(str[i]); i += amplitude[1];         const frequency = n1835.parse(str[i]); i += frequency[1];         const offset    = n1835.parse(str[i]); i += offset   [1];         const alignX    = n1835.parse(str[i]); i += alignX   [1];         const alignY    = n1835.parse(str[i]); i += alignY   [1];                   const wave = new h2418(             '',              shape    [0],             x        [0],             y        [0],             width    [0],             amplitude[0],             frequency[0],             offset   [0],             alignX   [0],             alignY   [0]);                   i = u1842.parse(str, i, wave);                       return [wave, i - i3666];     } } 


class i2421 extends u1842 {     static { d1855.types[k1211] = this; }        position;     x;     y;     width;     height;     start;     sweep;      degree;         constructor(nodeId,                 position = new n1835(0),                 x        = new n1835(0),                  y        = new n1835(0),                  width    = new n1835(0),                  height   = new n1835(0),                  start    = new n1835(0),                 sweep    = new n1835(0))     {         super(k1211, nodeId, 'arcPath');          this.position = position;         this.x        = x;         this.y        = y;         this.width    = width;         this.height   = height;         this.start    = start;         this.sweep    = sweep;          this.degree   = new n1835(2);     }        copy()     {         const copy = new i2421(             this.nodeId,             this.position.copy(),              this.x       .copy(),              this.y       .copy(),              this.width   .copy(),              this.height  .copy(),              this.start   .copy(),             this.sweep   .copy());          copy.m3266(this);          return copy;     }        equals(arc)     {         return arc             && this.position.equals(arc.position)             && this.x       .equals(arc.x       )             && this.y       .equals(arc.y       )             && this.width   .equals(arc.width   )             && this.height  .equals(arc.height  )             && this.start   .equals(arc.start   )             && this.sweep   .equals(arc.sweep   );     }        async eval(parse)     {         return this.copy();     }                    l3609()     {         return super.l3609()             && this.position.l3609()             && this.x       .l3609()             && this.y       .l3609()             && this.width   .l3609()             && this.height  .l3609()             && this.start   .l3609()             && this.sweep   .l3609();     }        isValid()     {         return super.isValid()             && this.position.isValid()             && this.x       .isValid()             && this.y       .isValid()             && this.width   .isValid()             && this.height  .isValid()             && this.start   .isValid()             && this.sweep   .isValid();     }        toNewValue()     {         return this.copy();     }        toString()     {         return      this.position.toString()             + ' ' + this.x       .toString()             + ' ' + this.y       .toString()             + ' ' + this.width   .toString()             + ' ' + this.height  .toString()             + ' ' + this.start   .toString()             + ' ' + this.sweep   .toString()             + ' ' + super.toString();     }        u3605()     {         return 'arc';                                                                                                }        l3606()     {         return      this.position.l3606()             + ' ' + this.x       .l3606()             + ' ' + this.y       .l3606()             + ' ' + this.width   .l3606()             + ' ' + this.height  .l3606()             + ' ' + this.start   .l3606()             + ' ' + this.sweep   .l3606();     }        static NaN()     {         return new i2421(             '',             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN());     }        static parse(str, i = -1)     {         if (   i <  0 && str    == t962             || i >= 0 && str[i] == t962)             return [i2421.NaN(), 1];                   if (i < 0)         {             str = str.split(' ');             i   = 0;         }                   const i3666 = i;              const pos    = n1835.parse(str[i]); i += pos   [1];         const x      = n1835.parse(str[i]); i += x     [1];         const y      = n1835.parse(str[i]); i += y     [1];         const width  = n1835.parse(str[i]); i += width [1];         const height = n1835.parse(str[i]); i += height[1];         const start  = n1835.parse(str[i]); i += start [1];         const sweep  = n1835.parse(str[i]); i += sweep [1];                   const arc = new i2421(             '',              pos   [0],             x     [0],             y     [0],             width [0],             height[0],             start [0],             sweep [0]);                   i = u1842.parse(str, i, arc);                       return [arc, i - i3666];     } }


class s1841 extends i1863 {     static { d1855.types[j1244] = this; }        items = [];        constructor(nodeId, items = [])     {         super(j1244, 'group');          this.items = items;               }        copy()     {         const copy = new s1841(             this.nodeId,             this.items.map(i => i.copy()));          copy.m3266(this);          return copy;     }        equals(group)     {         if (!group)                                  return false;         if (!(group instanceof s1841))     return false;         if (this.items.length != group.items.length) return false;                      for (let i = 0; i < this.items.length; i++)             if (!this.items[i].equals(group.items[i]))                 return false;          return true;     }        async eval(parse)     {         return this;     }        toString()     {         if (!this.items)             return '';           let str = '';                           str += this.items.length;          for (let i = 0; i < this.items.length; i++)         {             const item = this.items[i];              str += ' ' + item.type + ' ';             str += item.toString();         }           return str;     }        u3605()     {         if (!this.items)             return '';           let str = '';                           str += this.items.length;          for (let i = 0; i < this.items.length; i++)         {             const item = this.items[i];              str += ' ' + item.type + ' ';             str += item.u3605();         }           return str;     }        l3606()     {         if (!this.items)             return '';           let str = '';                           str += this.items.length;          for (let i = 0; i < this.items.length; i++)         {             const item = this.items[i];              str += ' ' + item.type + ' ';             str += item.l3606();         }           return str;     }        toNewValue()     {         return this.copy();     }        isValid()     {         return  this.items             && !this.items.find(i => !i.isValid());     }            toJsonText(options = {})     {         let json = '';           let hasNamed = false;          if (options.showNames === true)         {             for (let i = 0; i < this.items.length; i++)             {                 if (this.items[i].valueId != i)                 {                     hasNamed = true;                     break;                 }             }         }           const OB = hasNamed || options.forceBraces === true ? '{' : '[';         const CB = hasNamed || options.forceBraces === true ? '}' : ']';           if (this.items.length > 0)         {             if (options.named)                 json += '\n' + c869(options.tab);                   json += OB + '\n';               const oldNamed = options.named;             options.named = hasNamed;               const WS  = s => options.whiteSpace ? s : '';               let lastItemExpanded = null;              for (let i = 0; i < this.items.length; i++)             {                 const item = this.items[i];                  options.tab++;                   const itemJson = item.toJsonText(options);                 const expanded = itemJson.includes('\n');                                   if (   i > 0                     && options.whiteSpace                     && (   expanded                         || lastItemExpanded))                     json += '\n';                   json += c869(options.tab);                   if (hasNamed)                     json += '"' + item.valueId + '": ';                   json += itemJson;                   if (i < this.items.length-1)                     json += ',';                  json += '\n';                   options.tab--;                  lastItemExpanded = expanded;             }               json += c869(options.tab) + CB;               options.named = oldNamed;              options.lastExpanded = json.includes('\n');         }         else         {             json += OB + CB;             options.lastExpanded = false;         }           return json;     }        static NaN()     {         return new s1841(             '',             x1834.NaN());         }                                    static parse(str, i = -1)         {             if (i < 0)             {                 str = str.split(' ');                 i   = 0;             }                                       const i3666 = i;                      const group = new s1841();                                   const z4088 = parseInt(str[i++]);                               for (let j = 0; j < z4088; j++)             {                 const type = str[i++];                                  switch (type)                 {                     case          q1054:                       case    x1057: { const _list   = x1834.parse        (str, i);  i += _list  [1];  group.items.push(_list  [0]);  break; }                               case     a1198: { const rect    = d1838   .parse(str, i);  i += rect   [1];  group.items.push(rect   [0]);  break; }                     case          w1201: { const line    = m1833        .parse(str, i);  i += line   [1];  group.items.push(line   [0]);  break; }                     case       l1204: { const ellipse = v1825     .parse(str, i);  i += ellipse[1];  group.items.push(ellipse[0]);  break; }                     case       y1207: { const ellipse = p1847     .parse(str, i);  i += ellipse[1];  group.items.push(ellipse[0]);  break; }                     case       f1216: { const poly    = x1837     .parse(str, i);  i += poly   [1];  group.items.push(poly   [0]);  break; }                     case          k1219: { const star    = a1843        .parse(str, i);  i += star   [1];  group.items.push(star   [0]);  break; }                     case    z1222: { const text    = l1845   .parse(str, i);  i += text   [1];  group.items.push(text   [0]);  break; }                     case         p1225: { const point   = r1836       .parse(str, i);  i += point  [1];  group.items.push(point  [0]);  break; }                     case   c1229: { const path    = n1850  .parse(str, i);  i += path   [1];  group.items.push(path   [0]);  break; }                     case x1267: { const path    = w1840.parse(str, i);  i += path   [1];  group.items.push(path   [0]);  break; }                     case   j1244: { const _group  = s1841  .parse(str, i);  i += _group [1];  group.items.push(_group [0]);  break; }                     case         y1247: { const frame   = n1827       .parse(str, i);  i += frame  [1];  group.items.push(frame  [0]);  break; }                 }             }                                   return [                 group,                  i - i3666];         } } 


class n1827 extends u1842 {     static { d1855.types[y1247] = this; }        children;     position;     x;     y;     width;     height;     round;     clip;        constructor(nodeId, children, position, x, y, width, height, round, clip)     {         super(y1247, nodeId, 'frame');          this.children = children;         this.position = position;         this.x        = x;         this.y        = y;         this.width    = width;         this.height   = height;         this.round    = round;         this.clip     = clip;          this.objects =                 children             && children.objects              ? children.objects.map(o => o.copy())              : [];     }        copy()     {         const copy = new n1827(             this.nodeId,             this.children.copy(),             this.position.copy(),             this.x       .copy(),             this.y       .copy(),             this.width   .copy(),             this.height  .copy(),             this.round   .copy(),             this.clip    .copy());          copy.m3266(this);          return copy;     }        equals(frame)     {         return frame             && this.children.equals(frame.children)             && this.position.equals(frame.position)             && this.x       .equals(frame.x       )             && this.y       .equals(frame.y       )             && this.width   .equals(frame.width   )             && this.height  .equals(frame.height  )             && this.round   .equals(frame.round   )             && this.clip    .equals(frame.clip    );     }        async eval(parse)     {         return this;     }        toString()     {         return       this.children.toString()              + ' ' + this.position.toString()              + ' ' + this.x       .toString()              + ' ' + this.y       .toString()              + ' ' + this.width   .toString()              + ' ' + this.height  .toString()              + ' ' + this.round   .toString()              + ' ' + this.clip    .toString()              + ' ' + super.toString();     }        u3605()     {         return 'frame';                                                                                                             }        l3606()     {         return       this.children.l3606()              + ' ' + this.position.l3606()              + ' ' + this.x       .l3606()              + ' ' + this.y       .l3606()              + ' ' + this.width   .l3606()              + ' ' + this.height  .l3606()              + ' ' + this.clip    .l3606()              + ' ' + this.round   .l3606();     }        toNewValue()     {         return this.copy();     }        isValid()     {         return super.isValid()             && this.children.isValid()             && this.position.isValid()             && this.x       .isValid()             && this.y       .isValid()             && this.width   .isValid()             && this.height  .isValid()             && this.round   .isValid()             && this.clip    .isValid();     }            toJsonText(options = {})     {         const WS = s =>                 options.whiteSpace              && options.lastExpanded                 ? s                  : '';           let json = '';                   if (options.named)             json += '\n' + c869(options.tab);           json += '{\n';         options.tab++;          const oldNamed = options.named;         options.named = true;           json += c869(options.tab) + '"children": '  + this.children.toJsonText(options)   + ',\n';         json += WS('\n');         json += c869(options.tab) + '"position": "' + FramePositions[this.position.value] + '",\n';         json += c869(options.tab) + '"x": '         + this.x       .toJsonText(options)   + ',\n';         json += c869(options.tab) + '"y": '         + this.y       .toJsonText(options)   + ',\n';         json += c869(options.tab) + '"width": '     + this.width   .toJsonText(options)   + ',\n';         json += c869(options.tab) + '"height": '    + this.height  .toJsonText(options)   + ',\n';         json += c869(options.tab) + '"round": '     + this.round   .toJsonText(options)   + ',\n';         json += c869(options.tab) + '"clip": '      + this.clip    .toJsonText(options)   + ',\n';           json += this.toBaseJsonText(options);           options.named = oldNamed;          options.tab--;         json += c869(options.tab) + '}';           options.lastExpanded = true;          return json;     }        static NaN()     {         return new n1827(             '',             x1834  .NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN(),             n1835.NaN());     }        static parse(str, i = -1)     {         if (   i <  0 && str    == t962             || i >= 0 && str[i] == t962)             return [n1827.NaN(), 1];           if (i < 0)         {             str = str.split(' ');             i   = 0;         }           const i3666 = i;          const children = x1834.parse  (str, i); i += children[1];         const position = n1835.parse(str[i]); i += position[1];         const x        = n1835.parse(str[i]); i += x       [1];         const y        = n1835.parse(str[i]); i += y       [1];         const width    = n1835.parse(str[i]); i += width   [1];         const height   = n1835.parse(str[i]); i += height  [1];         const round    = n1835.parse(str[i]); i += round   [1];         const clip     = n1835.parse(str[i]); i += clip    [1];          const frame = new n1827(             '',              children[0],             position[0],             x       [0],             y       [0],             width   [0],             height  [0],             round   [0],             clip    [0]);           i = u1842.parse(str, i, frame);                   return [frame, i - i3666];     } }


class i1680 extends y1857 {     static { d1855.types[x1062] = this; }        count            = null;     iteration        = null;    p3581            = null;     loop             = null;      m3716 = [];      isTerminal       = false;      activeAfter      = false;      listAfter        = false;         constructor(nodeId, options)     {         super(x1062, nodeId, options);     }            reset()     {         super.reset();          this. count      = null;         this. iteration  = null;         this.p3581      = null;         this. loop       = null;          this.isTerminal  = false;         this.activeAfter = false;         this.listAfter   = false;          this.m3716 = [];     }        copy()     {         const copy = new i1680(this.nodeId, this.options);          copy.m3266(this);          if (this. value    ) copy. value     = this. value    .copy();         if (this. iteration) copy. iteration = this. iteration.copy();         if (this. count    ) copy. count     = this. count    .copy();         if (this.p3581    ) copy.p3581     = this.p3581    .copy();         if (this. loop     ) copy. loop      = this. loop     .copy();          copy.isTerminal  = this.isTerminal;         copy.activeAfter = this.activeAfter;         copy.listAfter   = this.listAfter;          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       let   count     = await evalNumberValue(this.count,     parse);         let   iteration = await evalNumberValue(this.iteration, parse);         let  p3581     = new n1835(1);           let iterations = [];          if (iteration.isValid())         {             if (iteration.type != q1123)                 iteration = new e1846(iteration.value.toString());              iterations = parseIndexRanges(iteration.value);         }           count =              count             ? new n1835(Math.floor(count.value), 0)             : new n1835(0);           if (   this.loop              && this.loop.type != e1090)              e3265(this.loop, this);           this.value = new x1834();         this.value.objects = [];           if (   count             && count.value > 0)                                                             {             if (this.input)             {                 const c3088    = Date.now();                 let   f3715 = false;                   const nRepeats =                      this.options.enabled                      ? count.value                      : 1;                    let repeat =                 {                     repeatId:         this.nodeId,                     currentIteration: 0,                     total:            nRepeats                 };                                       parse.repeats.push(repeat);                  if (parse.repeats.length == 1)                     parse.d3546 += nRepeats;                   if (   this.loop                     && this.loop.k3535)                     this.loop.k3535(parse, this.nodeId);                   if (this.loop)                 {                     parse.evalAccumulate = false;                     await this.loop.eval(parse);                      parse.evalAccumulate = true;                 }                   for (let i = 0, o = 0; i < Math.max(1, nRepeats); i++)                 {                     if (  !f3715                         && Date.now() - c3088 > 50)                     {                         b1890(this.nodeId);                         f3715 = true;                     }                       repeat.currentIteration = i;                        this.input.y3968(parse, this, false);                                           const input = await evalValue      (this.input,  parse);                          p3581 = await evalNumberValue(this.p3581, parse);                       if (   input                         && nRepeats > 0                         && (  !p3581                              || p3581.value > 0))                     {                                                                           if (l955(input.type))                         {                             if (input.condensed === true)                                 this.value.items.push(input);                             else                             {                                 for (const item of input.items)                                     this.value.items.push(item);                             }                         }                         else                             this.value.items.push(input);                                   if (   this.options.active                             || this.options.z2908                             || this.options.beforeList)                         {                             this.m3716 = [];                                                       if (input.objects)                             {                                 for (let j = 0; j < input.objects.length; j++, o++)                                 {                                     const c111 = g3635(input.objects[j]);                                       this.m3716.push(c111.copy());                                       if (  !iteration.isValid()                                         || iterations.includes(i))                                     {                                         c111.nodeId     = this.nodeId;                                         c111.listId     = i;                                          c111.objectId  += b965 + this.nodeId + ':' + (o+1).toString();                                          c111.objectName = t1463(                                             c111.objectName,                                              name =>                                              {                                                 return this.value.objects                                                     ? this.value.objects.filter(o => o.objectName == name).length                                                     : 0;                                             },                                             c111.objectName,                                             ' ');                                                  c111.n3717 = repeat.currentIteration;                                          if (this.value.objects)                                             this.value.objects.push(c111);                                     }                                 }                             }                         }                     }                       this.input.l3966(parse);                       if (   this.loop                         && this.loop.iterateCache)                         this.loop.iterateCache(parse, this);                                           if (parse.repeats.length == 1)                     {                         parse.g3545++;                          if (await n3744(parse.q1880))                         {                             t1892(this.nodeId);                             return this;                         }                     }                                           if (f3715)                         s1891(parse, this.nodeId, i / nRepeats);                 }                   if (   this.loop                     && this.loop.p3538)                     this.loop.p3538(parse, this.nodeId);                   if (this.startTimer > -1)                 {                     clearTimeout(this.startTimer);                     this.startTimer = -1;                 }                   t1892(this.nodeId);                   r950(parse.repeats.at(-1) == repeat, 'invalid nested repeat \'' + this.nodeId + '\'');                 parse.repeats.pop();             }             else if (this.input)                 await evalValue(this.input, parse);         }         else if (this.input)             await evalValue(this.input, parse);                   const type = this.outputListType();                   this.h3980(parse,         [             ['type',      type     ],             ['count',     count    ],             ['iteration', iteration]         ]);           this.validate();          return this;     }        toNewValue()     {         return this.value.copy();     }        isValid()     {         return super.isValid()             && this. count     && this. count    .isValid()             && this. iteration && this. iteration.isValid()             && (!this.p3581   || this.p3581    .isValid());     }        o3967(parse)     {         super.o3967(parse);          if (this. count    ) this. count    .o3967(parse);         if (this. iteration) this. iteration.o3967(parse);         if (this.p3581    ) this.p3581    .o3967(parse);         if (this. loop     ) this. loop     .o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this. count    ) this. count    .y3968(parse, from, force);         if (this. iteration) this. iteration.y3968(parse, from, force);         if (this.p3581    ) this.p3581    .y3968(parse, from, force);         if (this. loop     ) this. loop     .y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this. count    ) this. count    .l3966(parse);         if (this. iteration) this. iteration.l3966(parse);         if (this.p3581    ) this.p3581    .l3966(parse);         if (this. loop     ) this. loop     .l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const repeat = new i1680(nodeId, options);                   let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(repeat, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, repeat);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   repeat.isTerminal  = parseInt(parse.move()) > 0;         repeat.activeAfter = parseInt(parse.move()) > 0;         repeat.listAfter   = parseInt(parse.move()) > 0;                   parse.p3553++;                   if (z4088 == 1)             repeat.input = t1607(parse);              repeat. count     = t1607(parse);         repeat .iteration = t1607(parse);         repeat.p3581     = t1607(parse);                repeat. loop      = t1607(parse);                     parse.p3553--;                   genParseNodeEnd(parse, repeat);         return repeat;     } }    function e3265(loop, node) {     r950(            loop.type == j1085         || loop.type == u1064         || loop.type == n1103         || loop.type == i1104         || loop.type == y1102         || loop.type == z1105         || loop.type == h1106         || loop.type == z1107         || loop.type == l1068         || loop.type == PARAM,          'only volatile types can be repeated'); }


class q2437 extends y1857 {     static { d1855.types[ADVANCE] = this; }        loop             = null;                              constructor(nodeId, options)     {         super(ADVANCE, nodeId, options);     }            reset()     {         super.reset();          this.loop = null;                                           }        copy()     {         const copy = new q2437(this.nodeId, this.options);          copy.m3266(this);          if (this.loop) copy.loop = this.loop.copy();                                      return copy;     }        async eval(parse)     {                                         if (   this.loop              && this.loop.type != e1090)              e3265(this.loop, this);                                                                                      const input = await evalValue(this.input,  parse);          this.value = input ?? new x1834();           this.c4095();           if (this.options.enabled)         {                                         if (   this.loop                 && this.loop.l3966)                 this.loop.l3966(parse);                          }           this.h3980(parse,         [             ['type', this.outputListType()]         ]);           this.validate();          return this;     }        toNewValue()     {         return this.value.copy();     }        o3967(parse)     {         super.o3967(parse);          if (this.loop) this.loop.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.loop) this.loop.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.loop) this.loop.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const advance = new q2437(nodeId, options);                   let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(advance, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, advance);             return parse.m4122.find(n => n.nodeId == nodeId);         }                                                        parse.p3553++;                   if (z4088 == 1)             advance.input = t1607(parse);              advance.loop = t1607(parse);                     parse.p3553--;                   genParseNodeEnd(parse, advance);         return advance;     } }    function e3265(loop, node) {     r950(            loop.type == j1085         || loop.type == u1064         || loop.type == n1103         || loop.type == i1104         || loop.type == y1102         || loop.type == z1105         || loop.type == h1106         || loop.type == z1107         || loop.type == l1068         || loop.type == PARAM,          'only volatile types can be repeated'); }


class r1689 extends y1857 {     static { d1855.types[n1061] = this; }        from   = null;      s3718 = NULL;            constructor(nodeId, options)     {         super(n1061, nodeId, options);     }            reset()     {         super.reset();          this.from = null;     }        copy()     {         const copy = new r1689(this.nodeId, this.options);          copy.m3266(this);          if (this.value) copy.value = this.value.copy();          return copy;     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        async eval(parse)     {         if (     !parse.evalFeedback)             return this;                    const input = await evalValue(this.input, parse);                     this.h3980(parse,          [             ['type', this.outputListType()]         ]);           await this.q3979(parse, {input});                   this.validate();          return this;     }        async q3979(parse, options = {})     {         const repeat = parse.repeats.find(r => r.repeatId == this.s3718);           const feedback =                 repeat             && repeat.currentIteration > 0             && this.from;                   this.value = new x1834();          if (feedback)         {             for (const c111 of this.from.m3716)                 this.value.items.push(c111.toNewValue());              if (this.from.m3716)                 this.value.objects = this.from.m3716.map(o => o.copy());         }         else if (options.input               && options.input.isValid())         {             this.value.items.push(options.input);              if (options.input.objects)                 this.value.objects = options.input.objects.map(o => o.copy());         }           const iter =             repeat              ? NAME_SEPARATOR + repeat.currentIteration              : '';          for (const item of this.value.items)             item.nodeId = this.nodeId;          if (this.value.objects)         {             for (let i = 0; i < this.value.objects.length; i++)             {                 const c111 = this.value.objects[i];                  c111.nodeId   = this.nodeId;                 c111.objectId = this.nodeId + b965 + i + iter;             }         }           await super.q3979(parse);     }        toNewValue()     {         return this.value.copy();     }                                k3535(parse, nodeId)     {         super.k3535(parse, nodeId);          this.from = parse.m4122.find(n => n.nodeId == nodeId);     }        p3538(parse, nodeId)     {         super.p3538(parse, nodeId);          this.from = null;     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const feedback = new r1689(nodeId, options);                   let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(feedback, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, feedback);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             feedback.input = t1607(parse);                   parse.p3553--;                   genParseNodeEnd(parse, feedback);         return feedback;     } } 


class r1679 extends y1857 {     static { d1855.types[a1058] = this; }        constructor(nodeId, options)     {         super(a1058, nodeId, options);     }            copy()     {         const copy = new r1679(this.nodeId, this.options);          copy.m3266(this);          if (this.value) copy.value = this.value.copy();         if (this.input) copy.input = this.input.copy();          return copy;     }        async eval(parse)     {                             this.value =              this.input              ? (await this.input.eval(parse)).toNewValue()              : new p4096();           this.c4095();           this.h3980(parse,         [             ['type',  this.outputType()],             ['value', this.value       ]         ]);           this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const _null = new r1679(nodeId, options);                   let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(_null, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, _null);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             _null.input = t1607(parse);                   parse.p3553--;                   genParseNodeEnd(parse, _null);         return _null;     } } 


class w1694 extends y1857 {     static { d1855.types[n1059] = this; }        variableId     = NULL;     variableType   = NULL;     variableName   = '';     variableValues = [];     aliasIds       = [];     aliasNames     = [];     variableTemp   = false;      h2782    = [];        constructor(nodeId, options)     {         super(n1059, nodeId, options);     }        reset()     {         super.reset();          this.variableId     = NULL;         this.variableType   = NULL;         this.variableName   = '';         this.variableValues = [];         this.aliasIds       = [];         this.aliasNames     = [];         this.variableTemp   = false;          this.h2782    = [];     }        copy()     {         const copy = new w1694(this.nodeId, this.options);          copy.variableId     = this.variableId;         copy.variableType   = this.variableType;         copy.variableName   = this.variableName;         copy.variableValues = this.variableValues.map(v => v.copy());         copy.aliasIds       = [...this.aliasIds];         copy.aliasNames     = [...this.aliasNames];         copy.variableTemp   = this.variableTemp;          copy.h2782    = this.h2782   .map(p => p.copy());                  return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                   const input = await evalValue(this.input, parse);          let h2782 = await Promise.all(             this.h2782.map(async p =>              {                 switch (this.variableType)                 {                     case 'FLOAT':   return await evalNumberValue(p, parse);                     case 'BOOLEAN': return await evalNumberValue(p, parse);                     case 'STRING':  return await evalTextValue  (p, parse);                     case 'COLOR':   return await evalColorValue (p, parse);                 }             }));           let varValues = [];                          if (input)         {             varValues = [input];         }         else if (this.variableValues.length > 0               && this.variableValues.every(v => isValid(v)))         {             for (const varVal of this.variableValues)                 varValues.push(b2600(this.variableType, varVal, true, parse));         }         else if (h2782.length > 0)         {             for (const paramVal of h2782)                 varValues.push(b2600(this.variableType, paramVal.p3539(), false, parse));         }           for (let i = 0; i < varValues.length; i++)         {             if (  !varValues[i]                 || varValues[i].type == r1086)             {                 switch (this.variableType)                 {                     case 'FLOAT':   varValues[i] =  n1835.NaN(); break;                     case 'BOOLEAN': varValues[i] = i2435.NaN(); break;                     case 'STRING':  varValues[i] =    e1846.NaN(); break;                     case 'COLOR':   varValues[i] =    m1826.NaN(); break;                     default:                                           break;                 }             }         }           this.value = new a2445(             this.nodeId,              this.variableId,             this.variableName,             varValues,             [...this.aliasIds],             [...this.aliasNames],             this.variableTemp);           this.h3980(parse,         [             ['value', this.value]         ]);           await this.evalVariable(parse);           this.validate();          return this;     }        async evalVariable(parse, options = {})     {         if (!this.options.enabled)             return;                        this.value.objects = [];           if (this.value.variableValues.every(v => v.isValid()))         {             const _var = new h2415(                 this.nodeId,                 this.value.variableId,                 this.value.variableName,                 this.value.variableValues.map(v => v.copy()),                 [...this.value.aliasIds]);              this.value.objects.push(_var);         }                   await super.q3979(parse);     }        isValid()     {         return !this.h2782.some(p => p == NULL);      }        o3967(parse)     {         super.o3967(parse);          this.h2782.forEach(p => p.o3967(parse));     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          this.h2782.forEach(p => p.y3968(parse, from, force));     }        l3966(parse)     {         super.l3966(parse);          this.h2782.forEach(p => p.l3966(parse));     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const variable = new w1694(nodeId, options);                   let z4088 = -1;                       if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(variable, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, variable);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;         parse.f1608 = false;                   if (z4088 == 1)             variable.input = t1607(parse);                       variable.variableId   = parse.move();         variable.variableType = parse.move();         variable.variableName = decodeURIComponent(parse.move());                   const nVars = parseInt(parse.move());              for (let i = 0; i < nVars; i++)         {             switch (variable.variableType)             {                 case 'FLOAT':                        variable.variableValues.push(parseFloat(parse.move()));                     break;                                      case 'BOOLEAN':                      variable.variableValues.push(d921(parse.move()));                     break;                                      case 'STRING':                       variable.variableValues.push(decodeURIComponent(parse.move()));                     break;                                      case 'COLOR':                 {                     const color = parse.move()                         .split(' ')                         .map(s => parseFloat(s));                          variable.variableValues.push(                     {                         r: color[0],                         g: color[1],                         b: color[2],                         a: color[3]                     });                     break;                 }             }         }                   const nAliases = parseInt(parse.move());              for (let i = 0; i < nAliases; i++)             variable.aliasIds.push(parse.move());              for (let i = 0; i < nAliases; i++)             variable.aliasNames.push(parse.move());                   variable.variableTemp = d921(parse.move());                   variable.aliasIds   = variable.aliasIds  .map(id   => id   == NULL_VALUE ? NULL : id  );         variable.aliasNames = variable.aliasNames.map(name => name == NULL_VALUE ? NULL : name);                   if (parse.settings.logRequests)          {             logReqString(variable.variableId   == NULL ? NULL_VALUE : variable.variableId,   parse);             logReqString(variable.variableType == NULL ? NULL_VALUE : variable.variableType, parse);             logReqString(variable.variableName != ''   ? '\'' + variable.variableName + '\'' : '\'\'', parse);                               for (const varVal of variable.variableValues)             {                 switch (variable.variableType)                 {                     case 'FLOAT':                            logReqString(varVal ? varVal.toString() : NULL_VALUE, parse);                         break;                                              case 'BOOLEAN':                          logReqString(varVal ? o935(varVal) : NULL_VALUE, parse);                         break;                                              case 'STRING':                           logReqString(varVal ?? NULL_VALUE, parse);                         break;                                              case 'COLOR':                         logReqString(                                     varVal.r.toString()                             + ' ' + varVal.g.toString()                             + ' ' + varVal.b.toString()                             + ' ' + varVal.a.toString(),                             parse);                         break;                 }             }                       if (variable.aliasIds.length > 0)             {                 for (const aliasId of variable.aliasIds)                     logReqString(aliasId == NULL ? NULL_VALUE : aliasId, parse);             }                       if (variable.aliasNames.length > 0)             {                 for (const aliasName of variable.aliasNames)                     logReqString(aliasName == NULL ? NULL_VALUE : aliasName, parse);             }                       logReqString(variable.variableTemp ? 'temp' : 'existing', parse);         }                   const j3580 = parseInt(parse.move());              for (let i = 0; i < j3580; i++)             variable.h2782.push(variable['value'+i] = t1607(parse));                       parse.p3553--;                       genParseNodeEnd(parse, variable);         return variable;     } }    function b2600(type, value, colorFromFigma, parse) {     switch (type)     {         case 'FLOAT':         {             const _value =                     value                 && !isNaN(value)                     ? value                     : parse.settings.numberVarNullValue;                           return new n1835(                 _value,                  Math.min(r1002(p1014(_value, 2)), 2));         }          case 'BOOLEAN':          {             const _value =                     value                 && !isNaN(value)                     ? value                     : parse.settings.boolVarNullValue;              return new i2435(_value > 0);         }          case 'STRING':              return new e1846(value);          case 'COLOR':          {             let _value = value;              if (   _value                 && _value.r)             {                 _value =                  [                     _value.r,                     _value.g,                     _value.b,                     _value.a                 ];             }               if (  !_value                 || q73(_value))                 _value = parse.settings.colorVarNullValue;               if (_value.length == 3)             {                 if (colorFromFigma)                     _value.a = 1;                 else                     _value.push(1);             }               if (colorFromFigma)             {                 return _value.a == 1                     ? y1823.i3670(                         [_value.r * 0xff,                           _value.g * 0xff,                           _value.b * 0xff])                      : m1826.i3670(                         [_value.r * 0xff,                           _value.g * 0xff,                           _value.b * 0xff],                           _value.a * 100);              }             else             {                 return _value[3] == 1                     ? y1823.i3670(                         [_value[0] * 0xff,                           _value[1] * 0xff,                           _value[2] * 0xff])                      : m1826.i3670(                         [_value[0] * 0xff,                           _value[1] * 0xff,                           _value[2] * 0xff],                           _value[3] * 100);              }         }          default:             console.error('invalid variable type \'' + type + '\'');             return null;     } } 


class g1695 extends l1856 {     static { d1855.types[d1060] = this; }        input = null;        constructor(nodeId, options)     {         super(d1060, nodeId, options);     }        copy()     {         const copy = new f1677(this.nodeId, this.options);                  copy.m3266(this);          if (this.input) copy.input = this.input.copy();                  for (const key of this.keys())         {             if (this[key] instanceof i1863)                 Object.assign(copy, {[key]: this[key]});         }          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await evalListValue(this.input, parse);           this.w3004 = [];                                                                                                                                                                                                                                                  this.h3980(parse, [['', new p4096()]], true);                                        this.validate();          return this;     }                x4121(i2902)     {         return this.value             && this.value.items             && i2902 != 'value'             ? this.value.items.find(i => i.valueId == i2902)              : null;     }        toNewValue()     {         return this.value.copy();     }        isValid()     {         return this.input && this.input.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.input) this.input.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.input) this.input.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.input) this.input.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const group = new g1695(nodeId, options);                       let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(group, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, group);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             group.input = t1607(parse);                   parse.p3553--;                   genParseNodeEnd(parse, group);         return group;     } } 


class u1667 extends y1857 {     static { d1855.types[m1063] = this; }        e4091 = null;        constructor(nodeId, options)     {         super(m1063, nodeId, options);     }            reset()     {         super.reset();          this.e4091 = null;     }        copy()     {         const copy = new u1667(this.nodeId, this.options);          copy.m3266(this);          if (this.value) copy.value = this.value.copy();          return copy;     }        async eval(parse)     {         if (!this.options.enabled)             this.e4091 = null;                      if (   this.isCached()             && this.e4091)             return this;           if (this.e4091)         {             this.value = this.e4091.copy();         }         else         {             const input = await evalValue(this.input, parse);              this.value = input;              if (   this.options.enabled                 && this.value)                 this.e4091 = this.value.copy();         }           this.c4095();           this.h3980(parse,         [             ['type',  this.outputType()],             ['value', this.value       ]         ]);           this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        iterateCache(parse, from)     {         this.e4091 = null;          super.iterateCache(parse, from);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const cache = new u1667(nodeId, options);                   let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(cache, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, cache);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             cache.input = t1607(parse);                   parse.p3553--;                   genParseNodeEnd(parse, cache);         return cache;     } } 


class i1675 extends y1857 {     static { d1855.types[u1064] = this; }        frozen = false;      s3718 = NULL;        constructor(nodeId, options)     {         super(u1064, nodeId, options);     }            reset()     {         super.reset();          this.frozen = false;     }        copy()     {         const copy = new i1675(this.nodeId, this.options);          copy.m3266(this);          if (this.value) copy.value = this.value.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const repeat = parse.repeats.find(r => r.repeatId == this.s3718);           if (      repeat                && repeat.currentIteration == 0             || !this.options.enabled)             this.frozen = false;           if (!this.frozen)         {             this.value =                  this.input                  ? (await this.input.eval(parse)).toNewValue()                 : new p4096();              this.frozen = true;              this.c4095();         }           this.h3980(parse,         [             ['type',  this.outputType()],             ['value', this.value       ]         ]);           this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const freeze = new i1675(nodeId, options);                   let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(freeze, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, freeze);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             freeze.input = t1607(parse);                   parse.p3553--;                   genParseNodeEnd(parse, freeze);         return freeze;     } } 


class v1691 extends y1857 {     static { d1855.types[x1065] = this; }        interval = null;    p3581    = null;     loop     = null;        constructor(nodeId, options)     {         super(x1065, nodeId, options);     }            reset()     {         super.reset();          this. interval = null;         this.p3581    = null;         this. loop     = null;     }        copy()     {         const copy = new v1691(this.nodeId, this.options);          copy.m3266(this);          if (this. interval) copy. interval = this. interval.copy();         if (this.p3581   ) copy.p3581    = this.p3581   .copy();         if (this. loop    ) copy. loop     = this. loop    .copy();          return copy;     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;           const  interval = await evalNumberValue(this. interval, parse);         const p3581    = await evalNumberValue(this.p3581,    parse);         const  loop     = await evalNumberValue(this. loop,     parse);                       if (this.loop.type != e1090) e3265(this.loop, this);          if (p3581.value == 0)             return this;           if (this.input)         {             this.input.y3968(parse, this, true);              const input = await evalValue(this.input, parse);              this.value = input ? input : new p4096();              if (this.loop.type != e1090)                 this.loop.l3966(parse);         }         else             this.value = new p4096();                       this.h3980(parse,         [             ['value',    this.value],             ['interval', interval  ]         ]);                   this.c4095();           this.validate();          return this;     }        toNewValue()     {         return this.value.copy();     }        isValid()     {         return super.isValid()             && this.interval && this.interval.isValid()             && this.p3581   && this.p3581  .isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this. interval) this. interval.o3967(parse);         if (this.p3581   ) this.p3581   .o3967(parse);         if (this. loop    ) this. loop    .o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this. interval) this. interval.y3968(parse, from, force);         if (this.p3581   ) this.p3581   .y3968(parse, from, force);         if (this. loop    ) this. loop    .y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this. interval) this. interval.l3966(parse);         if (this.p3581   ) this.p3581   .l3966(parse);         if (this. loop    ) this. loop    .l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const timer = new v1691(nodeId, options);                   let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(timer, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, timer);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             timer.input = t1607(parse);                   timer.interval = t1607(parse);         timer.p3581   = t1607(parse);         timer. loop    = t1607(parse);                     parse.p3553--;                   genParseNodeEnd(parse, timer);         return timer;     } } 


class z2442 extends y1857 {     static { d1855.types[q1066] = this; }        constructor(nodeId, options)     {         super(q1066, nodeId, options);     }            copy()     {         const copy = new z2442(this.nodeId, this.options);          copy.m3266(this);          if (this.value) copy.value = this.value.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new e1846(             this.input              ? (await this.input.eval(parse)).toNewValue().valueId             : '');                   this.h3980(parse,         [             ['type', this.outputType()]         ]);           this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const name = new z2442(nodeId, options);                   let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(name, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, name);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             name.input = t1607(parse);              name.name = t1607(parse);                   parse.p3553--;                   genParseNodeEnd(parse, name);         return name;     } } 


class t2433 extends y1857 {     static { d1855.types[k1067] = this; }        name = null;        constructor(nodeId, options)     {         super(k1067, nodeId, options);     }            reset()     {         super.reset();          this.name = null;     }        copy()     {         const copy = new t2433(this.nodeId, this.options);          copy.m3266(this);          if (this.value) copy.value = this.value.copy();         if (this.name ) copy.name  = this.name .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalValueOrList(this.input, parse);         const name  = await evalTextValue  (this.name,  parse);           if (input)         {             if (this.options.enabled)             {                 this.evalInputOrList(                     input,                      item => evalSetValueName(item, name),                     new p4096());             }             else                 this.value = input;         }         else             this.value = new p4096();           this.c4095();           this.h3980(parse,         [             ['type',  this.outputType()],             ['value', this.value       ],             ['name',  name             ]         ]);           this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.name && this.name.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.name) this.name.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.name) this.name.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.name) this.name.l3966(parse);     }        p3538(parse, nodeId)     {         super.p3538(parse, nodeId);          if (this.name) this.name.p3538(parse, nodeId);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const name = new t2433(nodeId, options);                   let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(name, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, name);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             name.input = t1607(parse);              name.name = t1607(parse);                   parse.p3553--;                   genParseNodeEnd(parse, name);         return name;     } }    function evalSetValueName(input, name) {     input.valueId = name.value;      return input; }


class m2428 extends y1857 {     static { d1855.types[y1332] = this; }                constructor(nodeId, options)     {         super(y1332, nodeId, options);     }            reset()     {         super.reset();               }        copy()     {         const copy = new m2428(this.nodeId, this.options);          copy.m3266(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalListValue(this.input, parse);           this.counts = new x1834();           if (   input             && input.items)         {             if (this.options.enabled)             {                 this.value = new x1834();                 this.value.objects = [];                  for (let i = 0; i < input.items.length; i++)                     this.value.items.push(new e1846(input.items[i].valueId));                  if (input.objects)                 {                     for (let i = 0; i < input.objects.length; i++)                         this.value.objects.push(input.objects[i]);                 }             }             else                 this.value = input.copy();         }         else             this.value = new x1834();           this.c4095();           this.h3980(parse,          [             ['type',   new e1846(g1056)          ],             ['length', new n1835(this.value.items.length)]         ]);                           if (parse.settings.l3631)         {             this.h3980(parse,             [                 ['preview', new x1834(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const names = new m2428(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(names, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, names);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             names.input = t1607(parse);                         parse.p3553--;                   genParseNodeEnd(parse, names);         return names;     } } 


class v2436 extends e1858 {     static { d1855.types[c1333] = this; }        constructor(nodeId, options)     {         super(c1333, nodeId, options);     }            copy()     {         const copy = new v2436(this.nodeId, this.options);          copy.m3266(this);          if (this.value) copy.value = this.value.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const e3962 = await evalListValue(this.e3962, parse);         const d3963 = await evalListValue(this.d3963, parse);                   if (   e3962             && d3963             && e3962.items             && d3963.items)         {             if (this.options.enabled)             {                 for (let i = 0;                          i < e3962.items.length                       && i < d3963.items.length;                       i++)                     e3962.items[i].valueId = d3963.items[i].value;             }              this.value = e3962;         }              else if (e3962)             this.value = e3962;                  else             this.value = new x1834();           this.c4095();           this.h3980(parse,         [             ['type', this.outputListType()]         ]);           this.validate();          return this;     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const names = new v2436(nodeId, options);                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 2, 'nInputs must be [0, 2]');         }                   const n3583 =              z4088 == 1             ? parseInt(parse.move())             : -1;                   if (parse.settings.logRequests)              x1937(names, parse, ignore, z4088);                   if (ignore)         {             genParseNodeEnd(parse, names);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;              if (z4088 == 2)         {             names.e3962 = t1607(parse);             names.d3963 = t1607(parse);         }         else if (z4088 == 1)         {                  if (n3583 == 0) names.e3962 = t1607(parse);              else if (n3583 == 1) names.d3963 = t1607(parse);          }              parse.p3553--;                   genParseNodeEnd(parse, names);         return names;     } } 


class f2430 extends y1857 {     static { d1855.types[a1334] = this; }        name = null;        constructor(nodeId, options)     {         super(a1334, nodeId, options);     }            reset()     {         super.reset();          this.name = null;     }        copy()     {         const copy = new f2430(this.nodeId, this.options);          copy.m3266(this);          if (this.value) copy.value = this.value.copy();         if (this.name ) copy.name  = this.name .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalValue    (this.input, parse, () => d1838.NaN());         const name  = await evalTextValue(this.name,  parse);           if (input)         {             this.value = input;              if (   this.options.enabled                 && this.value.isValid()                 && this.value.objects)             {                 for (const c111 of this.value.objects)                 {                     c111.nodeId     = this.nodeId;                     c111.objectName = name.value;                 }             }         }         else             this.value = new p4096();           this.c4095();           this.h3980(parse,         [             ['type',  this.outputType()],             ['value', this.value       ],             ['name',  name             ]         ]);           this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.name && this.name.isValid()     }        o3967(parse)     {         super.o3967(parse);          if (this.name) this.name.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.name) this.name.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.name) this.name.l3966(parse);     }        p3538(parse, nodeId)     {         super.p3538(parse, nodeId);          if (this.name) this.name.p3538(parse, nodeId);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const name = new f2430(nodeId, options);                   let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(name, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, name);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             name.input = t1607(parse);              name.name    = t1607(parse);                         parse.p3553--;                   genParseNodeEnd(parse, name);         return name;     } } 


class l1670 extends l1856 {     static { d1855.types[l1068] = this; }        inputs = [];      value;        constructor(nodeId, options)     {         super(l1068, nodeId, options);     }            reset()     {         super.reset();          this.inputs = [];     }        copy()     {         const copy = new l1670(this.nodeId, this.options);          copy.m3266(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.value) copy.value = this.value.copy();          return copy;     }        isCached()     {         for (const input of this.inputs)             if (!input.isCached())                 return false;          return super.isCached();     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new x1834();          this.value.objects = [];           for (let i = 0; i < this.inputs.length; i++)         {             const input = await evalValue(this.inputs[i], parse);               if (   input                 && input.isValid()                 && this.options.enabled)             {                 if (l955(input.type))                 {                     if (input.condensed === true)                         this.value.items.push(input);                     else                     {                         for (const item of input.items)                             this.value.items.push(item);                     }                 }                 else                     this.value.items.push(input);             }               const inputObjects = this.c3533(input, i);                          for (const c111 of inputObjects)             {                 c111.objectId += b965 + i;                 c111.n3717 = i;             }              this.value.objects.push(...inputObjects);         }                     const bounds = getObjBounds(this.value.objects);          const singlePoint =                this.value.objects.length  == 1              && this.value.objects[0].type == y1226;          for (const c111 of this.value.objects)         {             const angle1 = k882(c111.sp0, c111.sp1);             const angle2 = k882(c111.sp0, c111.sp2);              c111.w3639(c111.sp0.x, c111.sp0.y);                          c111.sp1 = y893(c111.sp0, vector(angle1, 1));             c111.sp2 = y893(c111.sp0, vector(angle2, 1));                       }                   const length = new n1835(this.value.items.length);         const type   = new e1846(f3386(this.value.items));           this.h3980(parse,         [             ['length', length],             ['type',   type  ]         ]);           if (parse.settings.l3631)         {             this.h3980(parse,             [                 ['preview', new x1834(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        toNewValue()     {         return this.value.copy();     }        isValid()     {         return !this.inputs.find(i => !i.isValid());     }        o3967(parse)     {         super.o3967(parse);          this.inputs.forEach(i => i.o3967(parse));     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          this.inputs.forEach(i => i.y3968(parse, from, force));     }        k3535(parse, s3718)     {         this.inputs.forEach(i => i.k3535(parse, s3718));     }        o3536(parse, nodeId)     {         this.inputs.forEach(i => i.o3536(parse, nodeId));     }        l3966(parse)     {         this.inputs.forEach(i => i.l3966(parse));     }        iterateCache(parse, from)     {         for (const input of this.inputs)         {             if (   input.type == u1079                 || input.type == l1068                 || input.type == m1063)                 input.iterateCache(parse, from);         }     }        p3538(parse, nodeId)     {         this.inputs.forEach(i => i.p3538(parse, nodeId));     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const list = new l1670(nodeId, options);                       let z4088 = 0;                  if (!ignore)             z4088 = parseInt(parse.move());                   if (parse.settings.logRequests)              x1937(list, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, list);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                       for (let i = 0; i < z4088; i++)             list.inputs.push(t1607(parse));                   parse.p3553--;                           genParseNodeEnd(parse, list);         return list;     } }


class r1671 extends y1857 {     static { d1855.types[f1069] = this; }        constructor(nodeId, options)     {         super(f1069, nodeId, options);     }            reset()     {         super.reset();     }        copy()     {         const copy = new r1671(this.nodeId, this.options);          copy.m3266(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new x1834();         this.value.condensed = true;          let length = 0;           const input = await evalListValue(this.input, parse);           if (input)         {             length = input.items.length;                                           if (   l955(input.type)                 && this.options.enabled)             {                 for (const item of input.items)                 {                     const copy = item.copy();                      this.value.items.push(copy);                 }             }             else             {                 const copy = input.copy();                  this.value.items  .push(copy);                 this.value.objects.push(...copy.objects);             }         }         else             this.value = new x1834();               this.c4095();               this.h3980(parse,         [             ['length', new n1835(length)                                ],             ['type',   new e1846(f3386(this.value.items))]         ]);                   this.validate();          return this;     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const listAsItem = new r1671(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(listAsItem, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, listAsItem);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             listAsItem.input = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, listAsItem);         return listAsItem;     } } 


class a1673 extends y1857 {     static { d1855.types[c1070] = this; }        indices     = null;                  constructor(nodeId, options)     {         super(c1070, nodeId, options);     }            reset()     {         super.reset();          this.indices = null;                   }        copy()     {         const copy = new a1673(this.nodeId, this.options);          copy.m3266(this);          if (this.indices) copy.indices = this.indices.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input   = await evalListValue(this.input,   parse);         let   indices = await evalValue    (this.indices, parse, () => null);           this.value = new x1834();          let length = 0;                   if (   indices              && indices.type == q1123)             indices = new x1834(parseIndexRanges(indices.value).map(i => new n1835(i)));           if (   input             && indices             && input.items)         {             length = input.items.length;               if (this.options.enabled)             {                 for (let i = 0; i < indices.items.length; i++)                 {                     const item = input.items[Math.round(indices.items[i].value)];                      this.value.items.push(item ? item.copy() : new p4096());                                          if (   item                         && item.objects                         && this.value.objects)                          this.value.objects.push(...item.objects);                 }             }         }         else             this.value = x1834.NaN();           this.c4095();           this.h3980(parse,         [             ['type',    this.outputListType()                   ],             ['length',  new n1835(this.value.items.length)],              ['indices', indices                                 ]         ]);                   if (parse.settings.l3631)         {             this.h3980(parse,             [                 ['preview', new x1834(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.indices && this.indices.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.indices) this.indices.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.indices) this.indices.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.indices) this.indices.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const extr = new a1673(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(extr, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, extr);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             extr.input = t1607(parse);              extr.indices = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, extr);         return extr;     } } 


class h1686 extends e1858 {     static { d1855.types[g1071] = this; }        name = null;            constructor(nodeId, options)     {         super(g1071, nodeId, options);     }            reset()     {         super.reset();          this.name  = null;     }        copy()     {         const copy = new h1686(this.nodeId, this.options);          copy.m3266(this);          if (this.name) copy.name = this.name.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const e3962 = await evalValue    (this.e3962, parse);         const d3963 = await evalValue    (this.d3963, parse);         const name   = await evalTextValue(this.name,   parse);           if (   e3962             && name)         {             let nameValue = name.value.trim();               if (l955(e3962.type))             {                 this.value = new x1834();                  if (this.options.enabled)                 {                     for (let i = 0; i < e3962.items.length; i++)                     {                         const item = e3962.items[i];                          if (   d3963                             && name.value.trim() != '')                             item.customParams.push([nameValue, d3963]);                                                   if (   item                             && item[nameValue]                             && item[nameValue].objects                              && this.value.objects)                             this.value.objects.push(...item[nameValue].objects);                     }                 }                 else                     this.value = e3962;             }             else             {                 this.value = e3962;                  if (   d3963                     && nameValue != ''                     && this.options.enabled)                     this.value.customParams.push([nameValue, d3963]);             }         }         else         {             this.value = new p4096();         }           this.c4095();           this.h3980(parse,         [             ['type',  this.outputType()],             ['value', this.value       ],             ['name',  name             ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.name && this.name.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.name) this.name.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.name) this.name.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.name) this.name.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const set = new h1686(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(set, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, set);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 2)         {             set.e3962 = t1607(parse);             set.d3963 = t1607(parse);             set.name   = t1607(parse);         }         else if (z4088 == 1)         {             set.e3962 = t1607(parse);              set.name   = t1607(parse);         }         else if (z4088 == 0)         {             set.name   = t1607(parse);         }                       parse.p3553--;                   genParseNodeEnd(parse, set);         return set;     } } 


class k1687 extends y1857 {     static { d1855.types[g1072] = this; }        name = null;            constructor(nodeId, options)     {         super(g1072, nodeId, options);     }            reset()     {         super.reset();          this.name  = null;     }        copy()     {         const copy = new k1687(this.nodeId, this.options);          copy.m3266(this);          if (this.name) copy.name = this.name.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalValue    (this.input, parse);         const name  = await evalTextValue(this.name,  parse);           if (   input             && name             && name.value.trim() != '')         {             if (this.options.enabled)             {                 if (l955(input.type))                 {                     this.value = new x1834();                      for (let i = 0; i < input.items.length; i++)                         this.value.items.push(getGetParamValue(input.items[i], name));                 }                 else                     this.value = getGetParamValue(input, name);             }             else                 this.value = input.copy();         }         else         {             this.value = new p4096();         }           this.c4095();           const type = this.outputType();                  this.h3980(parse,         [             ['value', this.value],             ['type',  type      ],             ['name',  name      ]         ]);                   if (type.value == q1123 && parse.settings.n3630)         {             this.h3980(parse,             [                 ['preview', this.value]             ],             true);         }         else if (l955(type.value)   && parse.settings.l3631)         {             this.h3980(parse,             [                 ['preview', new x1834(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.name && this.name.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.name) this.name.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.name) this.name.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.name) this.name.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const extr = new k1687(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(extr, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, extr);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             extr.input = t1607(parse);              extr.name = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, extr);         return extr;     } }    function getGetParamValue(input, name) {     let nameValue = name.value.trim();       if (    input         && !input[nameValue])     {              if (input[name.value.toUpperCase()]) nameValue = name.value.toUpperCase();         else if (input[name.value.toLowerCase()]) nameValue = name.value.toLowerCase();     }       let value = null;      if (   input         && input[nameValue])     {         value = input[nameValue];     }     else     {         const customIndex = input.customParams.findIndex(p => p[0] == nameValue);          value =             customIndex > -1             ? input.customParams[customIndex][1]             : new p4096();     }       if (   input         && input[nameValue]         && input[nameValue].objects          && this.value.objects)         value.objects.push(...input[nameValue].objects);       return value; }


class a1690 extends y1857 {     static { d1855.types[b1073] = this; }        start       = null;     end         = null;                  constructor(nodeId, options)     {         super(b1073, nodeId, options);     }            reset()     {         super.reset();          this.start       = null;         this.end         = null;               }        copy()     {         const copy = new a1690(this.nodeId, this.options);          copy.m3266(this);          if (this.start) copy.start = this.start.copy();         if (this.end  ) copy.end   = this.end  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalListValue  (this.input, parse);         const start = await evalNumberValue(this.start, parse);         const end   = await evalNumberValue(this.end,   parse);           let length = 0;                       this.value = new x1834();         this.value.objects = [];           if (   input             && start             && end)         {             if (input.items)             {                 length = input.items.length;                   const _end =                     end.isValid()                     ? end                     : new n1835(input.items.length);                   if (this.options.enabled)                 {                     const endValue =                          _end.value < 0                         ? length + _end.value                         : _end.value;                      if (start.value < endValue)                     {                         for (let i = start.value, j = 0; i < endValue; i++, j++)                         {                             const item = input.items[i];                              this.value.items.push(item ? item.copy() : new p4096());                                                          if (   item                                 && this.value.objects                                 && item.objects)                             {                                 item.objects.forEach(o => o.n3717 = j);                                 this.value.objects.push(...item.objects);                             }                         }                     }                     else                         this.value = x1834.NaN();                 }                 else                     this.value = input.copy();             }             else                 this.value = x1834.NaN();         }           this.c4095();           this.h3980(parse,         [             ['type',       this.outputListType()                          ],             ['length',     new n1835(this.value.items.length)       ],              ['fullLength', new n1835(input ? input.items.length : 0)],              ['start',      start                                          ],             ['end',        end                                            ]         ]);                   if (parse.settings.l3631)         {             this.h3980(parse,             [                 ['preview', new x1834(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.start && this.start.isValid()             && this.end   && this.end  .isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.start) this.start.o3967(parse);         if (this.end  ) this.end  .o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.start) this.start.y3968(parse, from, force);         if (this.end  ) this.end  .y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.start) this.start.l3966(parse);         if (this.end  ) this.end  .l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const sub = new a1690(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(sub, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, sub);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             sub.input = t1607(parse);              sub.start = t1607(parse);         sub.end   = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, sub);         return sub;     } } 


class m1692 extends y1857 {     static { d1855.types[q1074] = this; }        counts      = null;     indices     = null;                  constructor(nodeId, options)     {         super(q1074, nodeId, options);     }            reset()     {         super.reset();          this.counts  = null;         this.indices = null;                       }        copy()     {         const copy = new m1692(this.nodeId, this.options);          copy.m3266(this);          if (this.counts ) copy.counts  = this.counts .copy();         if (this.indices) copy.indices = this.indices.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalListValue(this.input, parse);           this.counts  = new x1834();         this.indices = new x1834();                   if (input)         {             if (this.options.enabled)             {                 this.value = new x1834();                  for (let i = 0, index = 0; i < input.items.length; i++)                 {                     const item       = input.items[i];                     const foundIndex = this.value.items.findIndex(i => i.equals(item));                      if (foundIndex < 0)                     {                         const copy = item.copy();                          copy.valueId = (index++).toString();                                                  this.value.items.push(item.copy());                          if (   this.value.objects                             && item.objects)                             this.value.objects.push(...item.objects);                          this.counts .items.push(new n1835(1));                         this.indices.items.push(new x1834([new n1835(i)]));                     }                     else                     {                         this.counts .items[foundIndex].value++;                         this.indices.items[foundIndex].items.push(new n1835(i));                     }                 }             }             else                 this.value = input.copy();         }         else             this.value = new x1834();           this.c4095();           this.h3980(parse,         [             ['type',    this.outputListType()                   ],             ['length',  new n1835(this.value.items.length)],             ['counts',  this.counts                             ],             ['indices', this.indices                            ]         ]);                   if (parse.settings.l3631)         {             this.h3980(parse,             [                 ['preview', new x1834(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }                                                                                                                                               static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);           const unique = new m1692(nodeId, options);               let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(unique, parse, ignore, z4088);           if (ignore)          {             genParseNodeEnd(parse, unique);             return parse.m4122.find(n => n.nodeId == nodeId);         }           parse.p3553++;           if (z4088 == 1)             unique.input = t1607(parse);                       parse.p3553--;           genParseNodeEnd(parse, unique);         return unique;     } } 


class i1681 extends y1857 {     static { d1855.types[c1329] = this; }        indices = null;            constructor(nodeId, options)     {         super(c1329, nodeId, options);     }            reset()     {         super.reset();          this.indices = null;     }        copy()     {         const copy = new i1681(this.nodeId, this.options);          copy.m3266(this);          if (this.indices) copy.indices = this.indices.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input   = await evalListValue(this.input,   parse);         let   indices = await evalValue    (this.indices, parse, () => null);           if (   indices              && indices.type == q1123)             indices = new x1834(parseIndexRanges(indices.value).map(i => new n1835(i)));           this.value         = new x1834();         this.value.objects = [];           if (   input             && input.items)         {             if (   this.options.enabled                 && indices                 && input.items                 && indices.items                 && input.items.length == indices.items.length)             {                 this.value.items = new Array(input.items.length);                  for (let i = 0; i < input.items.length; i++)                     this.value.items[i] = input.items[indices.items[i].value];                                   for (let i = 0; i < this.value.items.length; i++)                 {                     const item      = this.value.items[i];                     const n3717 = input.items.indexOf(item);                      if (   item.objects                         && this.value.objects)                     {                         const objects = input.objects.filter(o => o.n3717 == n3717).map(o => o.copy());                         objects.forEach(o => o.n3717 = i);                          this.value.objects.push(...objects);                     }                 }             }             else                 this.value = new x1834();         }         else             this.value = new x1834();           this.c4095();           this.h3980(parse,         [             ['type',    this.outputListType()],             ['indices', indices              ]         ]);                   if (parse.settings.l3631)         {             this.h3980(parse,             [                 ['preview', new x1834(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.indices && this.indices.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.indices) this.indices.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.indices) this.indices.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.indices) this.indices.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const reorder = new i1681(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(reorder, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, reorder);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             reorder.input = t1607(parse);                   reorder.indices = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, reorder);         return reorder;     } }


class p1682 extends y1857 {     static { d1855.types[c1330] = this; }        offset = null;            constructor(nodeId, options)     {         super(c1330, nodeId, options);     }            reset()     {         super.reset();          this.offset = null;     }        copy()     {         const copy = new p1682(this.nodeId, this.options);          copy.m3266(this);          if (this.offset) copy.offset = this.offset.copy();          return copy;     }        async eval(parse)     {         if (   this.isCached())                          return this;           const input  = await evalListValue  (this.input,  parse);         const offset = await evalNumberValue(this.offset, parse);           let length = 0;                       this.value = new x1834();         this.value.objects = [];           if (   input             && offset)         {             if (input.items)             {                 length = input.items.length;                  if (this.options.enabled)                 {                     let _offset = -(offset.value % input.items.length);                     while (_offset < 0) _offset += input.items.length;                      let j = 0;                     for (let i = _offset; i < input.items.length; i++, j++)                         this.addItem(input, i, j);                      for (let i = 0; i < _offset; i++, j++)                         this.addItem(input, i, j);                 }                 else                     this.value = input.copy();             }             else                 this.value = x1834.NaN();         }           this.c4095();           this.h3980(parse,         [             ['type',       this.outputListType()                          ],             ['length',     new n1835(this.value.items.length)       ],              ['offset',     offset                                         ]         ]);                   if (parse.settings.l3631)         {             this.h3980(parse,             [                 ['preview', new x1834(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        addItem(input, i, j)     {         const item = input.items[i];          this.value.items.push(item ? item.copy() : new p4096());                  if (   item             && this.value.objects             && input.objects)         {                          item.objects.forEach(o => o.n3717 = j);              this.value.objects.push(...item.objects);         }     }        isValid()     {         return super.isValid()             && this.offset && this.offset.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.offset) this.offset.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.offset) this.offset.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.offset) this.offset.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const shift = new p1682(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(shift, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, shift);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             shift.input = t1607(parse);              shift.offset = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, shift);         return shift;     } } 


class v1683 extends y1857 {     static { d1855.types[c1075] = this; }        constructor(nodeId, options)     {         super(c1075, nodeId, options);     }            reset()     {         super.reset();     }        copy()     {         const copy = new v1683(this.nodeId, this.options);          copy.m3266(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalValue(this.input, parse);           if (input)         {             if (this.options.enabled)             {                 this.value = new x1834();                 this.value.objects = [];                  for (let i = input.items.length-1; i >= 0; i--)                     this.value.items.push(input.items[i]);                  if (input.objects)                 {                     for (let i = input.objects.length-1; i >= 0; i--)                         this.value.objects.push(input.objects[i]);                 }             }             else                 this.value = input.copy();         }         else             this.value = x1834.NaN();               this.c4095();           this.h3980(parse,          [             ['type',   this.outputListType()                   ],             ['length', new n1835(this.value.items.length)]         ]);                           if (parse.settings.l3631)         {             this.h3980(parse,             [                 ['preview', new x1834(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const reverse = new v1683(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(reverse, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, reverse);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             reverse.input = t1607(parse);                         parse.p3553--;                   genParseNodeEnd(parse, reverse);         return reverse;     } } 


class k2422 extends y1857 {     static { d1855.types[x1331] = this; }        amount;        constructor(nodeId, options)     {         super(x1331, nodeId, options);     }            reset()     {         super.reset();          this.buckle = null;     }        copy()     {         const copy = new k2422(this.nodeId, this.options);          copy.m3266(this);          if (this.amount) copy.amount = this.amount.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalListValue  (this.input,  parse);         const amount = await evalNumberValue(this.amount, parse);          amount.value = Math.round(amount.value);                           if (   input             && input.isValid())         {             const _amount = Math.min(amount.value + 1, Math.floor(input.items.length/2));              if (this.options.enabled)             {                 const temp1 =                  [                     ...input.items.slice(input.items.length - _amount).map(i => i.value),                     ...input.items.slice(0, _amount)                  .map(i => i.value).map(i => i - input.items[0].value + input.items.at(-1).value)                 ];                  const temp2 =                  [                     ...input.items.slice(input.items.length - _amount).map(i => i.value).map(i => i - input.items.at(-1).value + input.items[0].value),                     ...input.items.slice(0, _amount)                  .map(i => i.value)                 ];                  r950(                     temp1.length == temp2.length,                     'error building list edge blend');                                   const temp = [];                  for (let i = 0; i < _amount*2; i++)                     temp.push(new n1835(t1033(temp1[i], temp2[i], i/(_amount*2-1))));                   this.value = new x1834();                  for (let i = 0; i < _amount; i++)                     this.value.items.push(temp[_amount + i]);                  for (let i = _amount; i < input.items.length - _amount; i++)                     this.value.items.push(input.items[i]);                  for (let i = 0; i < _amount; i++)                     this.value.items.push(temp[i]);             }             else                 this.value = input;         }         else             this.value = x1834.NaN();               this.h3980(parse,          [             ['length', new n1835(this.value.items.length)],             ['amount', amount                                  ]         ]);                           if (parse.settings.l3631)         {             this.h3980(parse,             [                 ['preview', new x1834(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const buckle = new k2422(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(buckle, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, buckle);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             buckle.input = t1607(parse);                     buckle.amount = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, buckle);         return buckle;     } } 


class m1688 extends y1857 {     static { d1855.types[d1076] = this; }        condition     = null;     reverse       = null;     indices       = null;      s4092 = null;                   constructor(nodeId, options)     {         super(d1076, nodeId, options);     }            reset()     {         super.reset();          this.condition = null;         this.reverse   = null;         this.indices   = null;     }        copy()     {         const copy = new m1688(this.nodeId, this.options);          copy.m3266(this);          if (this.condition) copy.condition = this.condition.copy();         if (this.reverse  ) copy.reverse   = this.reverse  .copy();         if (this.indices  ) copy.indices   = this.indices  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input   = await evalListValue  (this.input,   parse);         const reverse = await evalNumberValue(this.reverse, parse);           this.value         = new x1834();         this.value.objects = [];           let maxColumns = 0;          this.indices = new x1834();           if (   input             && reverse)         {             if (this.options.enabled)             {                 if (  !this.condition                     || this.condition.p3665)                 {                     if (this.condition)                         await this.condition.eval(parse);                      const conditionNode =                          this.condition                         ? this.condition.p3665(parse)                         : null;                       if (  !this.condition                         || conditionNode)                     {                         const a4093 = reverse.value > 0 ? -1 : 1;                         const d4094          = [...input.items];                           [ input       .items,                            this.indices.items ] = await asyncSort(                             parse,                              d4094,                              this.condition                              ? conditionNode                              : null,                                      this,                             this.condition,                              a4093);                           input.items.forEach(i => maxColumns = Math.max(maxColumns, l955(i.type) ? i.items.length : 1));                                                   for (let i = 0; i < input.items.length; i++)                         {                             const row       = input   .items[i];                             const n3717 = d4094.indexOf(row);                              this.value.items.push(row.copy());                              if (   row.objects                                 && this.value.objects)                             {                                 const objects = input.objects.filter(o => o.n3717 == n3717).map(o => o.copy());                                 objects.forEach(o => o.n3717 = i);                                  this.value.objects.push(...objects);                             }                         }                     }                 }                 else                 {                     this.value   = input;                     this.indices = new x1834(Array.from(Array(input.items.length).keys()).map(i => new n1835(i)));                 }             }             else             {                 this.value   = input;                 this.indices = new x1834(Array.from(Array(input.items.length).keys()).map(i => new n1835(i)));             }         }         else         {             this.value   = new x1834();             this.indices = new x1834();         }                   this.c4095();           this.h3980(parse,         [             ['type',    this.outputListType()                   ],             ['length',  new n1835(this.value.items.length)],             ['reverse', reverse                                 ],             ['indices', this.indices                            ]         ]);                   if (parse.settings.l3631)         {             this.h3980(parse,             [                 ['preview', new x1834(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && (!this.condition || this.condition.isValid())             && this.reverse && this.reverse.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.condition) this.condition.o3967(parse);         if (this.reverse  ) this.reverse  .o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.condition) this.condition.y3968(parse, from, force);         if (this.reverse  ) this.reverse  .y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.condition) this.condition.l3966(parse);         if (this.reverse  ) this.reverse  .l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);           const sort = new m1688(nodeId, options);               let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(sort, parse, ignore, z4088);           if (ignore)          {             genParseNodeEnd(parse, sort);             return parse.m4122.find(n => n.nodeId == nodeId);         }           parse.p3553++;           if (z4088 == 1)             sort.input = t1607(parse);           const nConditions = parseInt(parse.move());          if (nConditions == 1)             sort.condition = t1607(parse);                       sort.reverse = t1607(parse);                   parse.p3553--;           genParseNodeEnd(parse, sort);         return sort;     } }    async function asyncSort(parse, d4094, conditionNode, node, condition, a4093) {     const q3475 = conditionNode ? conditionNode.input : null;       const sorted  = [];       for (let i = 0; i < d4094.length; i++)     {         const item = d4094[i];          const cond = await getSortCondition(parse, conditionNode, node, condition, item);          if (!cond)          {             return [d4094,                      d4094.keys().map(k => new n1835(k))];         }                  const condValue = cond.toNewValue();                   if (   condValue.type != e1090             && condValue.type != q1123)          {             return [ d4094,                       d4094.keys().map(k => new n1835(k))];         }          sorted.push({item, condition: condValue.value, index: i});     }       sorted.sort((a, b) =>     {         if (   typeof(a.condition) == 'number'             && typeof(b.condition) == 'number')         {             if (a.condition < b.condition) return -1*a4093;             if (a.condition > b.condition) return  1*a4093;         }         else if (typeof(a.condition) == 'string'               && typeof(b.condition) == 'string')         {             if (a.condition.localeCompare(b.condition) < 0) return -1*a4093;             if (a.condition.localeCompare(b.condition) > 0) return  1*a4093;         }          return 0;     });       if (conditionNode)         conditionNode.input = q3475;       return [ sorted.map(item => item.item),               sorted.map(item => new n1835(item.index)) ]; }    async function getSortCondition(parse, conditionNode, node, condition, item) {     if (!conditionNode)         return item;          conditionNode.reset();      conditionNode.input = item.copy();     condition.y3968(parse, node, true);       return await condition.eval(parse); }


class e1674 extends y1857 {     static { d1855.types[d1084] = this; }        condition = null;     indices   = null;                  constructor(nodeId, options)     {         super(d1084, nodeId, options);     }            reset()     {         super.reset();          this.condition = null;         this.indices   = null;     }        copy()     {         const copy = new e1674(this.nodeId, this.options);          copy.m3266(this);          if (this.condition) copy.condition = this.condition.copy();         if (this.indices  ) copy.indices   = this.indices  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalListValue(this.input, parse);           this.value         = new x1834();         this.value.objects = [];          let maxColumns = 0;                   this.indices = new x1834();           if (input)         {             if (this.options.enabled)             {                 if (  !this.condition                     || this.condition.p3665)                 {                     if (this.condition)                         await this.condition.eval(parse);                      const conditionNode =                          this.condition                         ? this.condition.p3665(parse)                         : null;                       if (  !this.condition                         || conditionNode)                     {                         const unfiltered = [...input.items];                           [input.items, this.indices.items] = await asyncFilter(                             parse,                              unfiltered,                              conditionNode,                             this,                             this.condition);                           input.items.forEach(i => maxColumns = Math.max(maxColumns, l955(i.type) ? i.items.length : 1));                                                   for (let i = 0; i < input.items.length; i++)                         {                             const row       = input   .items[i];                             const n3717 = unfiltered.indexOf(row);                              this.value.items.push(row.copy());                              if (   row.objects                                 && this.value.objects)                             {                                 const objects = input.objects.filter(o => o.n3717 == n3717).map(o => o.copy());                                 objects.forEach(o => o.n3717 = i);                                  this.value.objects.push(...objects);                             }                         }                     }                 }                 else                     this.value = await evalListValue(this.input, parse);             }             else                 this.value = input.copy();         }         else             this.value = new x1834();           this.c4095();           this.h3980(parse,         [             ['type',    this.outputListType()                   ],             ['length',  new n1835(this.value.items.length)],             ['indices', this.indices                            ]         ]);                   if (parse.settings.l3631)         {             this.h3980(parse,             [                 ['preview', new x1834(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && (!this.condition || this.condition.isValid());     }        o3967(parse)     {         super.o3967(parse);          if (this.condition) this.condition.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.condition) this.condition.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.condition) this.condition.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const filter = new e1674(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(filter, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, filter);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             filter.input = t1607(parse);              filter.condition = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, filter);         return filter;     } }    async function asyncFilter(parse, array, conditionNode, node, condition) {     const q3475 = conditionNode ? conditionNode.input : null;      const filtered = [];     const indices  = [];      for (let i = 0; i < array.length; i++)     {         const item = array[i];          const cond = await getFilterCondition(parse, conditionNode, node, condition, item);         if (!cond) return array;                  const condValue = cond.toNewValue();                   if (   condValue.type == e1090             && condValue.value > 0)         {             filtered.push(item);             indices .push(new n1835(i));         }     }      if (conditionNode)         conditionNode.input = q3475;      return [filtered, indices]; }    async function getFilterCondition(parse, conditionNode, node, condition, item) {     if (!conditionNode)         return item;          conditionNode.reset();      const value = conditionNode.toNewValue();     if (!value) return item;      if (   value.type == item.type         || value.type == r1086)     {         conditionNode.input = item.copy();         condition.y3968(parse, node, true);      }      return await condition.eval(parse); }


class e1669 extends y1857 {     static { d1855.types[l1077] = this; }        index       = null;                  constructor(nodeId, options)     {         super(l1077, nodeId, options);     }            reset()     {         super.reset();          this.index       = null;               }        copy()     {         const copy = new e1669(this.nodeId, this.options);          copy.m3266(this);          if (this.index) copy.index = this.index.copy();          return copy;     }        async eval(parse)     {         if (   this.isCached())                          return this;           const input = await evalListValue  (this.input, parse);         const index = await evalNumberValue(this.index, parse);                   this.value = new x1834();          let maxColumns = 0;                                                    if (   input                 && index)             {                 if (isTable(input))                 {                     input.items.forEach(i => maxColumns = Math.max(maxColumns, i.items.length));                      if (index.value < maxColumns)                     {                         const valueIds = [];                          for (let i = 0; i < input.items.length; i++)                         {                             const row = input.items[i];                              if (index.value < row.items.length)                             {                                 const item = row.items[index.value].copy();                                  item.valueId = t1463(                                     item.valueId,                                      id => valueIds.filter(s2819 => s2819 == id).length,                                     item.valueId,                                     '',                                     1,                                     true);                                                                 this.value.items.push(item);                                  v947(valueIds, item.valueId);                                  if (   this.value.objects                                      && row.items[index.value].objects)                                     this.value.objects.push(...row.items[index.value].objects);                             }                         }                     }                 }                 else if (l955(input.type))                 {                     this.value = input.copy();                     maxColumns = 1;                 }             }                               this.c4095();          this.h3980(parse,         [             ['type',    this.outputListType()                   ],             ['length',  new n1835(this.value.items.length)],             ['columns', new n1835(maxColumns, 0)          ],             ['index',   index                                   ]         ]);               if (parse.settings.l3631)         {             this.h3980(parse,             [                 ['preview', new x1834(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.index && this.index.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.index) this.index.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.index) this.index.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.index) this.index.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const column = new e1669(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(column, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, column);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             column.input = t1607(parse);              column.index = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, column);         return column;     } }    function isTable(value) {     if (!l955(value.type))         return false;      for (const item of value.items)     {         if (!l955(item.type))             return false;     }      return true; }


class v1668 extends y1857 {     static { d1855.types[w1078] = this; }        column;     row;            constructor(nodeId, options)     {         super(w1078, nodeId, options);     }            reset()     {         super.reset();          this.column = null;         this.row    = null;     }        copy()     {         const copy = new v1668(this.nodeId, this.options);          copy.m3266(this);          if (this.column) copy.column = this.column.copy();         if (this.row   ) copy.row    = this.row   .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalListValue  (this.input,  parse);         const column = await evalNumberValue(this.column, parse);         const row    = await evalNumberValue(this.row,    parse);           let columns = 0;         let rows    = 0;          if (   input             && column             && row)         {             if (isTable(input))             {                 rows = input.items.length;                  input.items.forEach(i => columns = Math.max(columns, i.items ? i.items.length : null));                  if (row.value < rows)                 {                     const _row = input.items[row.value];                      if (column.value < columns)                         this.value = _row.items[column.value].copy();                     else                         this.value = new p4096();                 }                 else                     this.value = new p4096();             }             else                 this.value = new p4096();         }         else             this.value = new p4096();           this.h3980(parse,         [                          ['type',    this.outputType()          ],             ['columns', new n1835(columns, 0)],             ['rows',    new n1835(rows   , 0)]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.column && this.column.isValid()             && this.row    && this.row   .isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.column) this.column.o3967(parse);         if (this.row   ) this.row   .o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.column) this.column.y3968(parse, from, force);         if (this.row   ) this.row   .y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.column) this.column.l3966(parse);         if (this.row   ) this.row   .l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const cell = new v1668(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(cell, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, cell);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             cell.input = t1607(parse);              cell.column = t1607(parse);         cell.row    = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, cell);         return cell;     } }


class f1677 extends y1857 {     static { d1855.types[u1079] = this; }        e4091 = null;        constructor(nodeId, options)     {         super(u1079, nodeId, options);     }        reset()     {         super.reset();          this.e4091 = null;     }        copy()     {         const copy = new f1677(this.nodeId, this.options);                  copy.m3266(this);          if (this.input) copy.input = this.input.copy();                  for (const key of this.keys())         {             if (this[key] instanceof i1863)                 Object.assign(copy, {[key]: this[key]});         }          return copy;     }        x4121(i2902)     {         let param =                this.value             && this.value.items             && i2902 != 'value'             ? this.value.items.find(i => i.valueId == i2902)             : null;          if (!param)             param = this[i2902];          return param;     }        async eval(parse)     {         if (   this.isCached()             && this.e4091)             return this;           const input = await evalListValue(this.input, parse);            if (this.e4091)            this.value = this.e4091.copy();          else         {             this.value       = input ?? new p4096();             this.e4091 = this.value.copy();         }           this.w3004 = [];           if (    this.value.isValid()             &&  this.value.items             && !isEmpty(this.value.items))         {             const valueIds = [];               for (let i = 0; i < this.value.items.length; i++)             {                 const item = this.value.items[i];                                  let valueId =                      item.valueId.trim() != ''                     ? item.valueId                     : i.toString();                  valueId = t1463(                     valueId,                     id => valueIds.filter(s2819 => s2819 == id).length,                     valueId,                     '',                     1,                     true);                  valueIds.push(valueId);             }               for (let i = 0; i < this.value.items.length; i++)             {                 let valueId = valueIds[i];                  const item = this.value.items[i];                                  Object.assign(this, {[valueId]: item});                 this.h3980(parse, [[valueId, item]], true);                  item.sortId = i;             }               this.w3004.sort((a, b) => a.sortId - b.sortId);               this.h3980(parse, [['-type-', this.outputType()]], true);         }         else             this.h3980(parse, [['-type-', new e1846(q1054)]], true);           this.c4095();           this.validate();          return this;     }                toNewValue()     {         return this.value.copy();     }        iterateCache(parse, from)     {         this.e4091 = null;     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const list = new f1677(nodeId, options);                       let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(list, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, list);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             list.input = t1607(parse);                   parse.p3553--;                   genParseNodeEnd(parse, list);         return list;     } }


class o1684 extends l1856 {     static { d1855.types[s1082] = this; }        inputs = [];      index = null;            constructor(nodeId, options)     {         super(s1082, nodeId, options);     }        reset()     {         super.reset();          this.inputs = [];                  this.index = null;     }           copy()     {         const copy = new o1684(this.nodeId, this.options);          copy.m3266(this);                  copy.inputs = this.inputs.map(i => i.copy());          if (this.index) copy.index = this.index.copy();         if (this.value) copy.value = this.value.copy();          return copy;     }        isCached()     {         for (const input of this.inputs)             if (!input.isCached())                 return false;          return super.isCached();     }        async eval(parse)     {         if (this.isCached())             return this;          const _inputs = await Promise.all(this.inputs.map(async i => await evalValueOrList(i, parse)));         let    index  = await evalNumberValue(this.index, parse);         let    length = 0;           const inputs = [];          for (const input of _inputs)         {             if (    l955(input.type)                 && !input.condensed)             {                 for (const item of input.items)                     inputs.push(item);             }             else                 inputs.push(input);         }           if (inputs.length > 0)         {             length = inputs.length;               index =                     index.isValid()                 && index.value >= -inputs.length                 && index.value <   inputs.length                 ? new n1835(Math.round(index.value))                 : new n1835(0);                           if (   index.isValid()                 && index.value >= -inputs.length                 && index.value <   inputs.length)             {                 this.value = inputs.at(index.value);                                   if (this.value.objects)                 {                     for (let i = 0; i < this.value.objects.length; i++)                     {                         const c111 = this.value.objects[i];                          c111.nodeId = this.nodeId;                         c111.listId = -1;                          c111.objectId = this.nodeId;                                                  if (c111.objectId != NULL)                              c111.objectId += '/';                          c111.objectId += index.value.toString();                          if (this.value.objects.length > 1)                         {                             c111.objectId += '/';                             c111.objectId += i.toString();                         }                     }                 }             }             else             {                 this.value = new p4096();             }         }         else         {             this.value = new p4096();         }                   const type = this.outputType();          this.h3980(parse,         [             ['value',      type == s1148                          || type == m1158                          ? this.value                          : new p4096()      ],             ['type',    type                   ],             ['length',  new n1835(length)],             ['index',   index                  ]         ]);           if (type.value == q1123 && parse.settings.n3630)         {             this.h3980(parse,             [                 ['preview', this.value]             ],             true);         }         else if (l955(type.value) && parse.settings.l3631)         {             this.h3980(parse,             [                 ['preview', new x1834(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return !this.inputs.find(i => !i.isValid())             &&  this.index && this.index.isValid();     }        o3967(parse)     {         super.o3967(parse);          this.inputs.forEach(i => i.o3967(parse));          if (this.index) this.index.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          this.inputs.forEach(i => i.y3968(parse, from, force));          if (this.index) this.index.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          this.inputs.forEach(i => i.l3966(parse));          if (this.index) this.index.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const sel = new o1684(nodeId, options);                       let z4088 = 0;                  if (!ignore)             z4088 = parseInt(parse.move());                   if (parse.settings.logRequests)              x1937(sel, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, sel);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                       for (let i = 0; i < z4088; i++)             sel.inputs.push(t1607(parse));              sel.index = t1607(parse);                   parse.p3553--;                           genParseNodeEnd(parse, sel);         return sel;     } }


class h1685 extends y1857 {     static { d1855.types[i1340] = this; }        index = null;        constructor(nodeId, options)     {         super(i1340, nodeId, options);     }        reset()     {         super.reset();          this.index = null;     }        copy()     {         const copy = new h1685(this.nodeId, this.options);                  copy.m3266(this);          if (this.input) copy.input = this.input.copy();         if (this.index) copy.index = this.index.copy();         if (this.value) copy.value = this.value.copy();          return copy;     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;                   const input = await evalListValue  (this.input, parse);         let   index = await evalNumberValue(this.index, parse);                  let  length = 0;                           if (   input             && input.isValid()             && l955(input.type)             && input.items             && input.items.length > 0)         {             length = input.items.length;               index =                     index.isValid()                 && index.value >= -length                 && index.value <   length                 ? new n1835(Math.round(index.value))                 : new n1835(0);                           if (   index.isValid()                 && index.value >= -length                 && index.value <   length)             {                 this.value = input.items.at(index.value);                                  if (   input.objects                     && input.objects.at(index.value))                     this.value.objects = [input.objects.at(index.value)];                   if (this.value.objects)                 {                     for (let i = 0; i < this.value.objects.length; i++)                     {                         const c111 = this.value.objects[i];                          c111.nodeId = this.nodeId;                         c111.listId = -1;                          c111.objectId = this.nodeId;                                                  if (c111.objectId != NULL)                             c111.objectId += '/';                          c111.objectId += index.value.toString();                     }                 }             }             else             {                 this.value = new p4096();             }         }         else          {             this.value = new p4096();         }           const type = this.outputType();                   this.h3980(parse,         [             ['value',      type == s1148                          || type == m1158                          ? this.value                          : new p4096()],             ['type',    type                   ],             ['length',  new n1835(length)],             ['index',   index                  ]         ]);           if (type.value == q1123 && parse.settings.n3630)         {             this.h3980(parse,             [                 ['preview', this.value]             ],             true);         }         else if (l955(type.value) && parse.settings.l3631)         {             this.h3980(parse,             [                 ['preview', new x1834(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.index && this.index.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.index) this.index.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.index) this.index.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.index) this.index.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const sel = new h1685(nodeId, options);                       let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(sel, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, sel);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             sel.input = t1607(parse);              sel.index = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, sel);         return sel;     } }


class b1678 extends y1857 {     static { d1855.types[j1080] = this; }        base = null;        constructor(nodeId, options)     {         super(j1080, nodeId, options);     }        reset()     {         super.reset();          this.base = null;     }        copy()     {         const copy = new b1678(this.nodeId, this.options);                  copy.m3266(this);          if (this.input) copy.input = this.input.copy();         if (this.base) copy.base = this.base.copy();                  if (this.count) copy.count = this.count.copy();          return copy;     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalListValue  (this.input, parse);         const base  = await evalNumberValue(this.base, parse);                   if (input)         {             const count = input.items.length;             this.value = new n1835(count - (base.value == 0 ? 1 : 0));         }         else             this.value = n1835.NaN();           this.h3980(parse,         [             ['type', this.outputType()],             ['base', base            ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.base && this.base.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.base) this.base.o3967(parse);     }            y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.base) this.base.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.base) this.base.l3966(parse);     }            static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const count = new b1678(nodeId, options);                       let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(count, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, count);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             count.input = t1607(parse);              count.base = t1607(parse);                   parse.p3553--;                   genParseNodeEnd(parse, count);         return count;     } }


class l2438 extends y1857 {     static { d1855.types[OBJECT_COUNT] = this; }        start = null;        constructor(nodeId, options)     {         super(j1080, nodeId, options);     }        reset()     {         super.reset();          this.start = null;     }        copy()     {         const copy = new b1678(this.nodeId, this.options);                  copy.m3266(this);          if (this.input) copy.input = this.input.copy();         if (this.start) copy.start = this.start.copy();                  if (this.count) copy.count = this.count.copy();          return copy;     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalValue      (this.input, parse);         const start = await evalNumberValue(this.start, parse);                   if (input)         {             const count =                  input.objects                 ? input.objects.length                 : 0;              this.value = new n1835(count - (start.value == 0 ? 1 : 0));         }         else             this.value = n1835.NaN();           this.h3980(parse,         [             ['value', this.value],             ['start', start     ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.start && this.start.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.start) this.start.o3967(parse);     }            y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.start) this.start.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.start) this.start.l3966(parse);     }            static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const count = new l2438(nodeId, options);                       let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(count, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, count);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             count.input = t1607(parse);              count.start = t1607(parse);                   parse.p3553--;                   genParseNodeEnd(parse, count);         return count;     } }


class k2434 extends e1858 {     static { d1855.types[o1081] = this; }        first;     last;     all;        constructor(nodeId, options)     {         super(o1081, nodeId, options);     }            reset()     {         super.reset();          this.first = null;         this.last  = null;         this.all   = null;     }        copy()     {         const copy = new k2434(this.nodeId, this.options);          copy.m3266(this);          if (this.first = null) copy.first = this.first.copy();         if (this.last  = null) copy.last  = this.last .copy();         if (this.all   = null) copy.all   = this.all  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const e3962 = await evalListValue(this.e3962, parse);         const d3963 = await evalValue    (this.d3963, parse);               if (   e3962 && e3962.isValid()              && d3963 && d3963.isValid())         {             if (isValueListOfLists(e3962))             {                 if (l955(d3963.type))                 {                     let result = false;                      for (const item of e3962.items)                     {                         if (item.equals(d3963))                         {                             result = true;                             break;                         }                     }                      this.value = new i2435(result);                 }                 else                  {                     this.value = new x1834();                      for (const item of e3962.items)                     {                         this.value.items.push(                             l955(item.type)                             ? new i2435(item.items.find(i => i.equals(d3963)))                             : i2435.NaN());                     }                 }             }             else             {                 this.value = new i2435(e3962.items.find(i => i.equals(d3963)));             }         }         else                           {             this.value = i2435.NaN();         }               this.h3980(parse,         [             ['type', this.outputType()]         ]);           this.validate();          return this;     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const cont = new k2434(nodeId, options);                      let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 2, 'nInputs must be [0, 2]');         }                       if (parse.settings.logRequests)              x1937(cont, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, cont);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 2)         {             cont.e3962 = t1607(parse);             cont.d3963 = t1607(parse);         }         else if (z4088 == 1)         {             cont.e3962 = t1607(parse);          }                         parse.p3553--;                   genParseNodeEnd(parse, cont);         return cont;     } }


class j1672 extends e1858 {     static { d1855.types[LIST_FIND] = j1672; }            first;     last;     all;        constructor(nodeId, options)     {         super(LIST_FIND, nodeId, options);     }            reset()     {         super.reset();          this.first = null;         this.last  = null;         this.all   = null;     }        copy()     {         const copy = new j1672(this.nodeId, this.options);          copy.m3266(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const e3962 = await evalListValue(this.e3962, parse);         const d3963 = await evalValue    (this.d3963, parse);               if (   e3962 && e3962.isValid()              && d3963 && d3963.isValid())         {             const indices = [];                           if (   d3963                 && d3963.isValid())             {                 for (let i = 0; i < e3962.items.length; i++)                 {                     if (e3962.items[i].equals(d3963))                         indices.push(i);                 }                     this.value = new n1835(indices.length > 0 ? 1 : 0);                  this.first = indices.length > 0 ? new n1835(indices.at( 0)) : n1835.NaN();                 this.last  = indices.length > 0 ? new n1835(indices.at(-1)) : n1835.NaN();                  this.all   = new x1834();                  for (const index of indices)                     this.all.items.push(new n1835(index));             }             else             {                 this.value = new n1835(1);                  this.first = n1835.NaN();                 this.last  = n1835.NaN();                 this.all   =   x1834.NaN();             }         }         else                           {             this.value = n1835.NaN();             this.first = n1835.NaN();             this.last  = n1835.NaN();             this.all   =   x1834.NaN();         }               this.h3980(parse,         [             ['value', this.value],             ['first', this.first],             ['last',  this.last ],             ['all',   this.all  ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.first && this.first.isValid()             && this.last  && this.last .isValid()             && this.all   && this.all  .isValid();     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const find = new j1672(nodeId, options);                      let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 2, 'nInputs must be [0, 2]');         }                       if (parse.settings.logRequests)              x1937(find, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, find);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 2)         {             find.e3962 = t1607(parse);             find.d3963 = t1607(parse);         }         else if (z4088 == 1)         {             find.e3962 = t1607(parse);          }                         parse.p3553--;                   genParseNodeEnd(parse, find);         return find;     } }


class x1676 extends l1856 {     static { d1855.types[o1083] = this; }                    e3962    = null;     d3963    = null;      condition = null;        constructor(nodeId, options)     {         super(o1083, nodeId, options);     }            reset()     {         super.reset();          this.e3962    = null;         this.d3963    = null;          this.condition = null;     }        copy()     {         const copy = new x1676(this.nodeId, this.options);          copy.m3266(this);          if (this.e3962   ) copy.e3962    = this.e3962   .copy();         if (this.d3963   ) copy.d3963    = this.d3963   .copy();          if (this.condition) copy.condition = this.condition.copy();          if (this.value    ) copy.value     = this.value    .copy();          return copy;     }        isCached()     {         return super.isCached()             && (!this.e3962 || this.e3962.isCached())             && (!this.d3963 || this.d3963.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;                   const inputFalse = await evalValue(this.e3962, parse);         const inputTrue  = await evalValue(this.d3963, parse);                  const cond       = await evalNumberValue(this.condition, parse);             if (   inputFalse                && inputTrue ) this.value = cond.value >  0 ? inputTrue  : inputFalse;         else if (inputFalse) this.value = cond.value == 0 ? inputFalse : nanFromType(inputFalse.type);         else if (inputTrue ) this.value = cond.value >  0 ? inputTrue  : nanFromType(inputTrue .type);         else                 this.value = new p4096();           this.c4095();           this.h3980(parse,         [             ['type',      this.outputType()],             ['value',     this.value       ],             ['condition', cond             ]         ]);                           this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()               : null;     }        isValid()     {         return this.e3962    && this.e3962   .isValid()             && this.d3963    && this.d3963   .isValid()             && this.condition && this.condition.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.e3962   ) this.e3962   .o3967(parse);         if (this.d3963   ) this.d3963   .o3967(parse);         if (this.condition) this.condition.o3967(parse);     }            y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.e3962   ) this.e3962   .y3968(parse, from, force);         if (this.d3963   ) this.d3963   .y3968(parse, from, force);         if (this.condition) this.condition.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.e3962   ) this.e3962   .l3966(parse);         if (this.d3963   ) this.d3963   .l3966(parse);         if (this.condition) this.condition.l3966(parse);     }            static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const q3582 = new x1676(nodeId, options);                   let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 2, 'nInputs must be [0, 2]');         }                   const n3583 =              z4088 == 1             ? parseInt(parse.move())             : -1;                   if (parse.settings.logRequests)              x1937(q3582, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, q3582);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;              if (z4088 == 2)         {             q3582.e3962    = t1607(parse);             q3582.d3963    = t1607(parse);             q3582.condition = t1607(parse);         }         else if (z4088 == 1)         {                  if (n3583 == 0) q3582.e3962 = t1607(parse);              else if (n3583 == 1) q3582.d3963 = t1607(parse);                   q3582.condition = t1607(parse);         }         else if (z4088 == 0)         {             q3582.condition = t1607(parse);         }              parse.p3553--;                   genParseNodeEnd(parse, q3582);         return q3582;     } } 


class q1712 extends l1856 {     inputs = [];        reset()     {         super.reset();          this.inputs = [];     }        p3665()     {         const conditionNodes = [];          for (const input of this.inputs)         {             const conditionNode = input.p3665();             if (conditionNode) conditionNodes.push(conditionNode);                     }          console.assert(conditionNodes.length < 2, 'Error: sort order requires not more than one order node');          return conditionNodes.length == 1              ? conditionNodes[0]              : null;     }        isCached()     {         for (const input of this.inputs)             if (!input.isCached())                 return false;          return super.isCached();     }        isValid()     {         return  this.inputs.length > 0             && !this.inputs.find(i => !i.isValid());     }        o3967(parse)     {         super.o3967(parse);          this.inputs.forEach(i => i.o3967(parse));     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          this.inputs.forEach(i => i.y3968(parse, from, force));     }        l3966(parse)     {         super.l3966(parse);          this.inputs.forEach(i => i.l3966(parse));     }        static parseRequest(parse, p1604)     {         const [type, nodeId, options, ignore] = genParseNodeStart(parse);                   const arith = p1604(nodeId, options);                   let z4088 = 0;                  if (!ignore)             z4088 = parseInt(parse.move());                   if (parse.settings.logRequests)              x1937(arith, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, arith);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;              for (let i = 0; i < z4088; i++)             arith.inputs.push(t1607(parse));              parse.p3553--;                           genParseNodeEnd(parse, arith);         return arith;     } } 


class b1749 extends y1857 {     static { d1855.types[b1091] = this; }        constructor(nodeId, options)     {         super(b1091, nodeId, options);     }        copy()     {         const copy = new b1749(this.nodeId, this.options);                  copy.m3266(this);          copy.value = this.value.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalNumberValue(this.input, parse);           if (input)             this.value = input;          else if (this.value)         {             await this.value.eval(parse);              this.value.meta = new NumberValueMeta(                 Number.MIN_SAFE_INTEGER,                 Number.MIN_SAFE_INTEGER,                 Number.MAX_SAFE_INTEGER,                 Number.MAX_SAFE_INTEGER,                 Number.NaN,                  NULL,                 [],                 false,                 NULL);         }                  else             this.value = n1835.NaN();           this.h3980(parse,          [             ['value', this.value]         ]);           this.validate();          return this;     }        isValid()     {         return !this.input               || this.input.isValid();     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const num = new b1749(nodeId, options);                       if (parse.settings.logRequests)              x1937(num, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, num);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;         parse.f1608 = false;                   if (parse.next == e1090) num.value = t1607(parse);         else                            num.input = t1607(parse);                   parse.p3553--;                   genParseNodeEnd(parse, num);         return num;     } } 


class b2441 extends y1857 {     static { d1855.types[BOUNDED_NUMBER] = this; }        min = null;     max = null;        constructor(nodeId, options)     {         super(BOUNDED_NUMBER, nodeId, options);     }        reset()     {         super.reset();          this.min = null;         this.max = null;     }        copy()     {         const copy = new b2441(this.nodeId, this.options);                  copy.m3266(this);          if (this.value) copy.value = this.value.copy();         if (this.min  ) copy.min   = this.min  .copy();         if (this.max  ) copy.max   = this.max  .copy();          return copy;     }        isCached()     {         return super.isCached()             && (!this.min || this.min.isCached())             && (!this.max || this.max.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalNumberValue(this.input, parse);         const min   = await evalNumberValue(this.min,   parse);         const max   = await evalNumberValue(this.max,   parse);           if (input)         {             const t3596 = Math.max(                 input.decimals,                 min  .decimals,                 max  .decimals);              this.value = new n1835(                 min.value <= max.value                     ? Math.min(Math.max(min.value, input.value), max.value)                     : Math.min(Math.max(max.value, input.value), min.value),                 t3596);         }         else if (this.value)         {             const value = await this.value.eval(parse);              const t3596 = Math.max(                 value.decimals,                 min  .decimals,                 max  .decimals);              this.value = new n1835(                 min.value <= max.value                     ? Math.min(Math.max(min.value, value.value), max.value)                     : Math.min(Math.max(max.value, value.value), min.value),                 t3596);         }         else             this.value = n1835.NaN();           this.h3980(parse,          [             ['value', this.value],             ['min',   min       ],             ['max',   max       ]         ]);           this.validate();          return this;     }        isValid()     {         return  (  !this.input                   || this.input.isValid())              && this.min && this.min.isValid()              && this.max && this.max.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.min) this.min.o3967(parse);         if (this.max) this.max.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.min) this.min.y3968(parse, from, force);         if (this.max) this.max.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.min) this.min.l3966(parse);         if (this.max) this.max.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const num = new b2441(nodeId, options);                       if (parse.settings.logRequests)              x1937(num, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, num);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;         parse.f1608 = false;                   if (parse.next == e1090) num.value = t1607(parse);         else                            num.input = t1607(parse);              num.min = t1607(parse);         num.max = t1607(parse);                   parse.p3553--;                   genParseNodeEnd(parse, num);         return num;     } }


class i2419 extends y1857 {     static { d1855.types[BOOLEAN_NUMBER] = this; }        constructor(nodeId, options)     {         super(BOOLEAN_NUMBER, nodeId, options);     }        copy()     {         const copy = new i2419(this.nodeId, this.options);                  copy.m3266(this);          copy.value = this.value;          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalBooleanNumberValue(this.input, parse);           if (input)             this.value = input;         else if (this.value)             await this.value.eval(parse);         else             this.value = n1835.NaN();                    if (this.value.isValid())         {             this.value = new n1835(                 Math.round(Math.min(Math.max(0, this.value.value), 1)),                  0,                 true);         }           this.h3980(parse,          [             ['value', this.value]         ]);           this.validate();          return this;     }        isValid()     {         return !this.input               || this.input.isValid();     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const bool = new i2419(nodeId, options);                       if (parse.settings.logRequests)              x1937(bool, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, bool);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;         parse.f1608 = false;                   if (parse.next == e1090) bool.value = t1607(parse);         else                            bool.input = t1607(parse);                   parse.p3553--;                   genParseNodeEnd(parse, bool);         return bool;     } }


class c2440 extends y1857 {     static { d1855.types[e1335] = this; }        decimals;        constructor(nodeId, options)     {         super(e1335, nodeId, options);     }            reset()     {         super.reset();          this.decimals = null;     }        copy()     {         const copy = new c2440(this.nodeId, this.options);          copy.m3266(this);          if (this.decimals) copy.decimals = this.decimals.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new n1835(0);                   const input    = await evalNumberOrListValue(this.input,    parse);         const decimals = await evalNumberValue      (this.decimals, parse);           if (input)         {             if (this.options.enabled)             {                 this.evalInputOrList(                     input,                      item => getSetPrecisionValue(item, decimals),                      n1835.NaN());              }             else                 this.value = input;         }         else             this.value = n1835.NaN();           this.h3980(parse,         [             ['type',     this.outputType()],             ['value',    this.value       ],             ['decimals', decimals         ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.decimals && this.decimals.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.decimals) this.decimals.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.decimals) this.decimals.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.decimals) this.decimals.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const prec = new c2440(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(prec, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, prec);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             prec.input = t1607(parse);              prec.decimals = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, prec);         return prec;     } }    function getSetPrecisionValue(input, decimals) {     r950(             input == e1090          || input == s1148          || input == m1158,          'input must be NUMBER_VALUE');       if (input.type == s1148)         return new y1823(             input.space,             getPrecisionValue(input.c1, decimals),             getPrecisionValue(input.c2, decimals),             getPrecisionValue(input.c3, decimals));          else if (input.type == m1158)     {         return new m1826(             new y1823(                 input.color.space,                 getPrecisionValue(input.color.c1, decimals),                 getPrecisionValue(input.color.c2, decimals),                 getPrecisionValue(input.color.c3, decimals)),             getPrecisionValue(input.opacity, decimals),             input.blend);     }     else         return getPrecisionValue(input, decimals); }    function getPrecisionValue(value, decimals) {     return new n1835(         value.value,         decimals.value); }


class r1756 extends y1857 {     static { d1855.types[h1092] = this; }        constructor(nodeId, options)     {         super(h1092, nodeId, options);     }            copy()     {         const copy = new r1756(this.nodeId, this.options);          copy.m3266(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalNumberOrListValue(this.input, parse);           if (input)         {             if (l955(input.type))             {                 this.value = new x1834();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == e1090                         ? getSignValue(item)                         : n1835.NaN());                    }             }             else                 this.value = getSignValue(input); }         else             this.value = n1835.NaN();           this.h3980(parse,          [             ['type', this.outputType()]         ]);           this.validate();          return this;     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const sign = new r1756(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(sign, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, sign);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             sign.input = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, sign);         return sign;     } }    function getSignValue(input) {     r950(          input.type == e1090,          'input.type must be NUMBER_VALUE');      return new n1835(Math.sign(input.value)); }


class w1737 extends y1857 {     static { d1855.types[w1093] = this; }        constructor(nodeId, options)     {         super(w1093, nodeId, options);     }            copy()     {         const copy = new w1737(this.nodeId, this.options);          copy.m3266(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalNumberOrListValue(this.input, parse);           if (input)         {             if (l955(input.type))             {                 this.value = new x1834();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == e1090                         ? getAbsoluteValue(item, this.options.enabled)                         : n1835.NaN());                    }             }             else                 this.value = getAbsoluteValue(input, this.options.enabled);         }         else             this.value = n1835.NaN();           this.h3980(parse,          [             ['type', this.outputType()]         ]);           this.validate();          return this;     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const abs = new w1737(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(abs, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, abs);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             abs.input = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, abs);         return abs;     } }    function getAbsoluteValue(input, enabled) {     r950(          input.type == e1090,          'input.type must be NUMBER_VALUE');      return enabled         ? new n1835(Math.abs(input.value), input.decimals)         : input; }


class b2432 extends y1857 {     static { d1855.types[p1336] = this; }        constructor(nodeId, options)     {         super(p1336, nodeId, options);     }            copy()     {         const copy = new b2432(this.nodeId, this.options);          copy.m3266(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalNumberOrListValue(this.input, parse);                       if (input)         {             if (l955(input.type))             {                 this.value = new x1834();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == e1090                         ? getNegativeValue(item, this.options.enabled)                         : n1835.NaN());                    }             }             else                 this.value = getNegativeValue(input, this.options.enabled);         }         else             this.value = n1835.NaN();           this.h3980(parse,          [             ['type', this.outputType()]         ]);           this.validate();          return this;     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const neg = new b2432(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(neg, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, neg);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             neg.input = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, neg);         return neg;     } }    function getNegativeValue(input, enabled) {     r950(          input == e1090,          'input must be NUMBER_VALUE');      return new n1835(         (enabled ? -1 : 1) * input.value,         input.decimals); }


class l1754 extends y1857 {     static { d1855.types[x1094] = this; }        type;     decimals;        constructor(nodeId, options)     {         super(x1094, nodeId, options);     }            reset()     {         super.reset();          this.type     = null;         this.decimals = null;     }        copy()     {         const copy = new l1754(this.nodeId, this.options);          copy.m3266(this);          if (this.type    ) copy.type     = this.type    .copy();         if (this.decimals) copy.decimals = this.decimals.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new n1835(0);                   const input = await evalNumberOrListValue(this.input,    parse);         const type  = await evalNumberValue      (this.type,     parse);         const dec   = await evalNumberValue      (this.decimals, parse);           if (   input             && type             && dec)         {             if (l955(input.type))             {                 this.value = new x1834();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == e1090                         ? getRoundValue(item, type, dec, this.options.enabled)                         : n1835.NaN());                    }             }             else                 this.value = getRoundValue(input, type, dec, this.options.enabled); }         else             this.value = n1835.NaN();           this.h3980(parse,         [             ['_type',    this.outputType()],             ['type',     type             ],             ['decimals', dec              ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.type     && this.type    .isValid()             && this.decimals && this.decimals.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.type    ) this.type    .o3967(parse);         if (this.decimals) this.decimals.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.type    ) this.type    .y3968(parse, from, force);         if (this.decimals) this.decimals.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.type    ) this.type    .l3966(parse);         if (this.decimals) this.decimals.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const round = new l1754(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(round, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, round);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             round.input = t1607(parse);              round.type     = t1607(parse);         round.decimals = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, round);         return round;     } }    function getRoundValue(input, type, dec, enabled) {     r950(         input.type == e1090,         'input.type must be NUMBER_VALUE');       if (!enabled)         return input;      switch (type.value)     {         case 0: return new n1835(g1013(input.value, dec.value), dec.value);         case 1: return new n1835(p1014(input.value, dec.value), dec.value);         case 2: return new n1835( b1015(input.value, dec.value), dec.value);     } }


class z2424 extends y1857 {     static { d1855.types[v1337] = this; }        type;     base;     step;     amount;        constructor(nodeId, options)     {         super(v1337, nodeId, options);     }            reset()     {         super.reset();          this.type   = null;         this.base   = null;         this.step   = null;         this.amount = null;     }        copy()     {         const copy = new z2424(this.nodeId, this.options);          copy.m3266(this);          if (this.type  ) copy.type   = this.type  .copy();         if (this.base  ) copy.base   = this.base  .copy();         if (this.step  ) copy.step   = this.step  .copy();         if (this.amount) copy.amount = this.amount.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new n1835(0);                   const input  = await evalNumberOrListValue(this.input,  parse);         const type   = await evalNumberValue      (this.type,   parse);         const base   = await evalNumberValue      (this.base,   parse);         const step   = await evalNumberValue      (this.step,   parse);         const amount = await evalNumberValue      (this.amount, parse);           if (input)         {             if (l955(input.type))             {                 this.value = new x1834();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == e1090                         ? getQuantizeValue(item, type, base, step, amount, this.options.enabled)                         : n1835.NaN());                    }             }             else                 this.value = getQuantizeValue(input, type, base, step, amount, this.options.enabled); }         else             this.value = n1835.NaN();           this.h3980(parse,         [             ['_type',  this.outputType()],             ['type',   type             ],             ['base',   base             ],             ['step',   step             ],             ['amount', amount           ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.type   && this.type  .isValid()             && this.base   && this.base  .isValid()             && this.step   && this.step  .isValid()             && this.amount && this.amount.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.type  ) this.type  .o3967(parse);         if (this.base  ) this.base  .o3967(parse);         if (this.step  ) this.step  .o3967(parse);         if (this.amount) this.amount.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.type  ) this.type  .y3968(parse, from, force);         if (this.base  ) this.base  .y3968(parse, from, force);         if (this.step  ) this.step  .y3968(parse, from, force);         if (this.amount) this.amount.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.type  ) this.type  .l3966(parse);         if (this.base  ) this.base  .l3966(parse);         if (this.step  ) this.step  .l3966(parse);         if (this.amount) this.amount.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const quant = new z2424(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(quant, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, quant);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             quant.input = t1607(parse);              quant.type   = t1607(parse);         quant.base   = t1607(parse);         quant.step   = t1607(parse);         quant.amount = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, quant);         return quant;     } }    function getQuantizeValue(input, type, base, step, amount, enabled) {     r950(          input.type == e1090,          'input.type must be NUMBER_VALUE');           if (!enabled)         return input;       let qval;      switch (type.value)     {         case 0: qval = base.value + step.value * Math.floor((input.value - base.value) / step.value); break;         case 1: qval = base.value + step.value * Math.round((input.value - base.value) / step.value); break;         case 2: qval = base.value + step.value * Math. ceil((input.value - base.value) / step.value); break;     }      return new n1835(         input.value + (qval - input.value) * amount.value/100,         Math.max(base.decimals, step.decimals)); }


class l1757 extends y1857 {     static { d1855.types[k1095] = this; }        operand;     operation;        constructor(nodeId, options)     {         super(k1095, nodeId, options);     }            reset()     {         super.reset();          this.operand   = null;         this.operation = null;     }        copy()     {         const copy = new l1757(this.nodeId, this.options);          copy.m3266(this);          if (this.operand  ) copy.operand   = this.operand  .copy();         if (this.operation) copy.operation = this.operation.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new n1835(0);                   const input   = await evalNumberOrListValue(this.input,     parse);         const operand = await evalNumberValue      (this.operand,   parse);         const op      = await evalNumberValue      (this.operation, parse);           if (input)         {             if (this.options.enabled)             {                 if (l955(input.type))                 {                     this.value = new x1834();                      for (let i = 0; i < input.items.length; i++)                     {                         const item = input.items[i];                          this.value.items.push(                             item.type == e1090                             ? getSimpleMinMaxValue(item, operand, op, this.options.enabled)                             : n1835.NaN());                        }                 }                 else                 {                     this.value = getSimpleMinMaxValue(input, operand, op, this.options.enabled);                 }             }             else                 this.value = input.copy();         }         else             this.value = n1835.NaN();           this.h3980(parse,         [             ['type',      this.outputType()],             ['operand',   operand          ],             ['operation', op               ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.operand   && this.operation.isValid()             && this.operation && this.operand  .isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.operand  ) this.operand  .o3967(parse);         if (this.operation) this.operation.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.operand  ) this.operand  .y3968(parse, from, force);         if (this.operation) this.operation.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.operand  ) this.operand  .l3966(parse);         if (this.operation) this.operation.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);           const h3574 = new l1757(nodeId, options);               let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(h3574, parse, ignore, z4088);           if (ignore)          {             genParseNodeEnd(parse, h3574);             return parse.m4122.find(n => n.nodeId == nodeId);         }           parse.p3553++;           if (z4088 == 1)             h3574.input = t1607(parse);          h3574.operand   = t1607(parse);         h3574.operation = t1607(parse);                   parse.p3553--;           genParseNodeEnd(parse, h3574);         return h3574;     } }    function getSimpleMinMaxValue(input, operand, op, enabled) {     r950(         input.type == e1090,          'input.type is ' + input.type + ', must be NUMBER_VALUE');       if (enabled)     {         op.value = Math.min(Math.max(0, Math.floor(op.value)), 1);          return new n1835(op.value == 0             ? Math.min(input.value, operand.x3604())             : Math.max(input.value, operand.x3604()));     }     else         return input; }


class f1746 extends q1712 {     static { d1855.types[d1096] = this; }        operation;        constructor(nodeId, options)     {         super(d1096, nodeId, options);     }            reset()     {         super.reset();          this.operation = null;     }        copy()     {         const copy = new f1746(this.nodeId, this.options);          copy.m3266(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.operation) copy.operation = this.operation.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const inputs = await Promise.all(this.inputs.map(async i => await evalNumberOrListValue(i, parse)));         let   op     = await evalNumberValue(this.operation, parse);           if (op) op = op.e3626();           if (this.options.enabled)             op.value = Math.min(Math.max(0, op.value), y1291.length-1);                   this.value = await evalMinMaxInputs(inputs, op, parse);                   this.h3980(parse,         [             ['type',      this.outputType()],             ['operation', op               ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.operation && this.operation.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.operation) this.operation.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.operation) this.operation.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.operation) this.operation.l3966(parse);     }        static parseRequest(parse)     {         const [type, nodeId, options, ignore] = genParseNodeStart(parse);                   const p3573 = new f1746(nodeId, options);                       let z4088 = 0;                  if (!ignore)             z4088 = parseInt(parse.move());                   if (parse.settings.logRequests)              x1937(p3573, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, p3573);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;              for (let i = 0; i < z4088; i++)             p3573.inputs.push(t1607(parse));                   p3573.operation = t1607(parse);                   parse.p3553--;                           genParseNodeEnd(parse, p3573);         return p3573;     } }    async function evalMinMaxInputs(inputs, op, parse) {     if (isEmpty(inputs))         return n1835.NaN();       const allAreLists = allInputsAreCondensedLists(inputs);      if (allAreLists) return await evalMinMaxListInputs(inputs, op, parse);     else             return await evalMinMaxItemInputs(inputs, op, parse); }    async function evalMinMaxListInputs(inputs, op, parse) {     const value = new x1834();           for (const input of inputs)     {         if (!input) continue;          console.assert(              l955(input.type),              `input is ${input.type}, must be a list`);          if (allInputsAreCondensedLists(input.items))             value.items.push(...(await evalMinMaxListInputs(input.items, op, parse)).items);         else             value.items.push(await evalMinMaxItemInputs(input.items, op, parse));     }       return value; }    async function evalMinMaxItemInputs(inputs, op, parse) {     if (isEmpty(inputs))         return n1835.NaN();       let value = new n1835(0);       const e3962 = await evalNumberOrListValue(inputs[0], parse);       if (    l955(e3962.type)         && !isEmpty(e3962.items))     {         value = e3962.items[0].copy();                  for (let i = 1; i < e3962.items.length; i++)         {             const item = e3962.items[i];              if (item.type == e1090)             {                 value = new n1835(                      op.value == 0                     ? Math.min(value.value, item.value)                     : Math.max(value.value, item.value));             }                             }     }     else     {         if (e3962.type != e1090)             return n1835.NaN();          value = e3962;     }       for (let i = 1; i < inputs.length; i++)     {         const input = await evalNumberOrListValue(inputs[i], parse);           if (l955(input.type))         {             for (const item of input.items)             {                 if (item.type == e1090)                 {                     value = new n1835(                         op.value == 0                         ? Math.min(value.value, item.value)                         : Math.max(value.value, item.value));                 }                                 }         }         else         {             r950(                 input.type == e1090,                  'val.type must be NUMBER_VALUE');                              value = new n1835(                 op.value == 0                 ? Math.min(value.value, input.value)                 : Math.max(value.value, input.value));         }     }       return value; }


class g1745 extends y1857 {     static { d1855.types[l1097] = this; }        min = null;     max = null;            constructor(nodeId, options)     {         super(l1097, nodeId, options);     }            reset()     {         super.reset();          this.min = null;         this.max = null;     }        copy()     {         const copy = new g1745(this.nodeId, this.options);          copy.m3266(this);          if (this.min) copy.min = this.min.copy();         if (this.max) copy.max = this.max.copy();          return copy;     }        isCached()     {         return super.isCached()             && (!this.min || this.min.isCached())             && (!this.max || this.max.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;                       const input = await evalNumberOrListValue(this.input, parse);         const min   = await evalNumberValue      (this.min,   parse);         const max   = await evalNumberValue      (this.max,   parse);           if (input)         {             if (l955(input.type))             {                 this.value = new x1834();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == e1090                         ? getLimitsValue(item, min, max, this.options.enabled)                         : n1835.NaN());                    }             }             else                 this.value = getLimitsValue(input, min, max, this.options.enabled);         }         else             this.value = n1835.NaN();           this.h3980(parse,         [             ['type', this.outputType()],             ['min',  min              ],             ['max',  max              ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.min && this.min.isValid()             && this.max && this.max.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.input) this.input.o3967(parse);         if (this.min  ) this.min  .o3967(parse);         if (this.max  ) this.max  .o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.input) this.input.y3968(parse, from, force);         if (this.min  ) this.min  .y3968(parse, from, force);         if (this.max  ) this.max  .y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.input) this.input.l3966(parse);         if (this.min  ) this.min  .l3966(parse);         if (this.max  ) this.max  .l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const limits = new g1745(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(limits, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, limits);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             limits.input = t1607(parse);              limits.min = t1607(parse);         limits.max = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, limits);         return limits;     } }    function getLimitsValue(input, min, max, enabled) {     r950(          input.type == e1090,          'input.type must be NUMBER_VALUE');      if (!enabled)         return input;      return new n1835(         Math.min(Math.max(             min.value,             input.value),             max.value),         input.decimals); }


class p1750 extends y1857 {     static { d1855.types[l1098] = this; }        min   = null;     max   = null;     power = null;            constructor(nodeId, options)     {         super(l1098, nodeId, options);     }            reset()     {         super.reset();          this.min   = null;         this.max   = null;         this.power = null;     }        copy()     {         const copy = new p1750(this.nodeId, this.options);          copy.m3266(this);          if (this.min  ) copy.min   = this.min  .copy();         if (this.max  ) copy.max   = this.max  .copy();         if (this.power) copy.power = this.power.copy();          return copy;     }        isCached()     {         return super.isCached()             && (!this.min   || this.min  .isCached())             && (!this.max   || this.max  .isCached())             && (!this.power || this.power.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;                       const input = await evalNumberOrListValue(this.input, parse);         const min   = await evalNumberValue      (this.min,   parse);         const max   = await evalNumberValue      (this.max,   parse);         const power = await evalNumberValue      (this.power, parse);           if (input)         {             if (l955(input.type))             {                 this.value = new x1834();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == e1090                         ? getNumberCurveValue(item, min, max, power, this.options.enabled)                         : n1835.NaN());                    }             }             else                 this.value = getNumberCurveValue(input, min, max, power, this.options.enabled);         }         else             this.value = n1835.NaN();           this.h3980(parse,         [             ['type',  this.outputType()],             ['min',   min              ],             ['max',   max              ],             ['power', power            ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.min   && this.min  .isValid()             && this.max   && this.max  .isValid()             && this.power && this.power.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.min  ) this.min  .o3967(parse);         if (this.max  ) this.max  .o3967(parse);         if (this.power) this.power.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.min  ) this.min  .y3968(parse, from, force);         if (this.max  ) this.max  .y3968(parse, from, force);         if (this.power) this.power.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.min  ) this.min  .l3966(parse);         if (this.max  ) this.max  .l3966(parse);         if (this.power) this.power.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const curve = new p1750(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(curve, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, curve);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             curve.input = t1607(parse);              curve.min   = t1607(parse);         curve.max   = t1607(parse);         curve.power = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, curve);         return curve;     } }    function getNumberCurveValue(input, min, max, power, enabled) {     r950(         input.type == e1090,         'input.type must be NUMBER_VALUE');       if (!enabled)         return input;       let f = (input.value - min.value) / (max.value - min.value);      f = Math.pow(f, power.value);     f = min.value + f * (max.value - min.value);          return new n1835(f); }


class w2416 extends y1857 {     static { d1855.types[u1338] = this; }        from = null;     to   = null;            constructor(nodeId, options)     {         super(u1338, nodeId, options);     }            reset()     {         super.reset();          this.from = null;         this.to   = null;     }        copy()     {         const copy = new w2416(this.nodeId, this.options);          copy.m3266(this);          if (from) copy.from = this.from.copy();         if (to  ) copy.to   = this.to  .copy();          return copy;     }        isCached()     {         return super.isCached()             && (!this.from  || this.from.isCached())             && (!this.to    || this.to  .isCached());     }        async eval(parse)     {         if (this.isCached())             return this;                       const input = await evalNumberOrListValue(this.input, parse);         const from  = await evalListValue        (this.from,  parse);         const to    = await evalListValue        (this.to,    parse);          let nanList = false;           if (   input              && input.isValid())         {             if (this.options.enabled)             {                 if (   from && from.isValid() && from.items.length > 0                     && to   && to  .isValid() && to  .items.length > 0)                 {                     if (l955(input.type))                     {                         this.value = new x1834();                                  for (let i = 0; i < input.items.length; i++)                         {                             const item = input.items[i];                                      this.value.items.push(                                 item.type == e1090                                 ? getNumberMapValue(item, from, to)                                 : n1835.NaN());                            }                     }                     else                         this.value = getNumberMapValue(input, from, to);                 }                 else                 {                     if (l955(input.type))                     {                         this.value = new x1834();                         nanList = true;                     }                     else                         this.value = n1835.NaN();                 }             }             else                 this.value = input;         }         else             this.value = n1835.NaN();           this.h3980(parse,         [             ['type', nanList ? new e1846(z1055) : this.outputType()],             ['from', from                                           ],             ['to',   to                                             ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.from && this.from.isValid()             && this.to   && this.to  .isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.from) this.from.o3967(parse);         if (this.to  ) this.to  .o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.from) this.from.y3968(parse, from, force);         if (this.to  ) this.to  .y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.from) this.from.l3966(parse);         if (this.to  ) this.to  .l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const map = new w2416(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(map, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, map);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             map.input = t1607(parse);              map.from = t1607(parse);         map.to   = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, map);         return map;     } }    function getNumberMapValue(input, from, to) {     r950(         input.type == e1090,         'input.type must be NUMBER_VALUE');       const maxDec = Math.max(         from.items.reduce((max, val) => Math.max(max, val.decimals), 0),         to  .items.reduce((max, val) => Math.max(max, val.decimals), 0));       if (from.items.length == 1)         return input;             const nFromSegments = Math.floor(from.items.length-1);     let   fromIndex     = 0;      while (fromIndex < nFromSegments-1)     {         if (   input.value >= from.items[fromIndex  ]             && input.value <  from.items[fromIndex+1])             break;          fromIndex++;     }               const fromLocal =              (input.value - from.items[fromIndex].value)          / (from.items[fromIndex+1].value - from.items[fromIndex].value);      const f = fromIndex/nFromSegments + fromLocal * ((fromIndex+1)/nFromSegments - fromIndex/nFromSegments);                 const nToSegments = Math.floor(to.items.length-1);     const toIndex     = Math.min(Math.max(0, Math.floor((to.items.length-1) * f)), nToSegments-1);       if (to.items.length == 1)         return to.items[0];      else if (to.items.length > 0             && toIndex < to.items.length-1)     {         const toLocal =              nToSegments > 1             ? (f - toIndex/nToSegments) * nToSegments             : f;           const o3591 = to.items[toIndex  ];         const val1 = to.items[toIndex+1];          return new n1835(             t1033(o3591.value, val1.value, toLocal),             maxDec);     } }


class l2431 extends y1857 {     static { d1855.types[d1339] = this; }        min    = null;     max    = null;     bias   = null;     spread = null;            constructor(nodeId, options)     {         super(d1339, nodeId, options);     }            reset()     {         super.reset();          this.min    = null;         this.max    = null;         this.bias   = null;         this.spread = null;     }        copy()     {         const copy = new l2431(this.nodeId, this.options);          copy.m3266(this);          if (this.min   ) copy.min    = this.min   .copy();         if (this.max   ) copy.max    = this.max   .copy();         if (this.bias  ) copy.bias   = this.bias  .copy();         if (this.spread) copy.spread = this.spread.copy();          return copy;     }        isCached()     {         return super.isCached()             && (!this.min    || this.min   .isCached())             && (!this.max    || this.max   .isCached())             && (!this.bias   || this.bias  .isCached())             && (!this.spread || this.spread.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;                       const input  = await evalNumberOrListValue(this.input,  parse);         const min    = await evalNumberValue      (this.min,    parse);         const max    = await evalNumberValue      (this.max,    parse);         const bias   = await evalNumberValue      (this.bias,   parse);         const spread = await evalNumberValue      (this.spread, parse);           if (input)         {             if (l955(input.type))             {                 this.value = new x1834();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == e1090                         ? getNumberBiasValue(item, min, max, bias, spread, this.options.enabled)                         : n1835.NaN());                    }             }             else                 this.value = getNumberBiasValue(input, min, max, bias, spread, this.options.enabled);         }         else             this.value = n1835.NaN();           this.h3980(parse,         [             ['type',   this.outputType()],             ['min',    min              ],             ['max',    max              ],             ['bias',   bias             ],             ['spread', spread           ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.min    && this.min   .isValid()             && this.max    && this.max   .isValid()             && this.bias   && this.bias  .isValid()             && this.spread && this.spread.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.min   ) this.min   .o3967(parse);         if (this.max   ) this.max   .o3967(parse);         if (this.bias  ) this.bias  .o3967(parse);         if (this.spread) this.spread.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.min   ) this.min   .y3968(parse, from, force);         if (this.max   ) this.max   .y3968(parse, from, force);         if (this.bias  ) this.bias  .y3968(parse, from, force);         if (this.spread) this.spread.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.min   ) this.min   .l3966(parse);         if (this.max   ) this.max   .l3966(parse);         if (this.bias  ) this.bias  .l3966(parse);         if (this.spread) this.spread.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const bias = new l2431(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(bias, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, bias);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             bias.input = t1607(parse);              bias.min    = t1607(parse);         bias.max    = t1607(parse);         bias.bias   = t1607(parse);         bias.spread = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, bias);         return bias;     } }    function r3632(f, bias, spread) {     const b = bias   / 50;     const s = spread / 50;       f =          b >= 0         ? 1 - Math.pow(1-f, 1+b)         :     Math.pow(  f, 1-b);            if (s >= 0 && f >= 0.5) f = 1 - Math.pow((1-f)*2, 1+s) / 2;     else if (s >= 0 && f <  0.5) f = Math.pow(f*2, 1+s) / 2;     else if (s < 0)              f = k1035(0, (1-s)/3, (2+s)/3, 1, f);       return f; }    function getNumberBiasValue(input, min, max, bias, spread, enabled) {     r950(         input.type == e1090,         'input.type must be NUMBER_VALUE');       if (!enabled)         return input;       let f = (input.value - min.value) / (max.value - min.value);      f = r3632(f, bias.value, spread.value);     f = min.value + f * (max.value - min.value);      return new n1835(         f,          Math.max(             input.decimals,             min  .decimals,             max  .decimals)); }


class r1747 extends y1857 {     static { d1855.types[z1099] = this; }        constructor(nodeId, options)     {         super(z1099, nodeId, options);     }            copy()     {         const copy = new r1747(this.nodeId, this.options);          copy.m3266(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalNumberOrListValue(this. input, parse);           if (input)         {             if (l955(input.type))             {                 this.value = new x1834();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == e1090                         ? getNumberIsNaN(item)                         : e1846.NaN());                    }             }             else             {                 this.value = getNumberIsNaN(input);             }         }          else             this.value = i2435.NaN();           this.h3980(parse,         [             ['type', this.outputType()]         ]);           this.validate();          return this;     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const u3572 = new r1747(nodeId, options);                   let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(u3572, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, u3572);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             u3572.input = t1607(parse);                   parse.p3553--;                   genParseNodeEnd(parse, u3572);         return u3572;     } }    function getNumberIsNaN(input) {     return !input.isValid()         ? new i2435(true )         : new i2435(false); }


class m1740 extends l1856 {     static { d1855.types[d1100] = this; }        constant;        constructor(nodeId, options)     {         super(d1100, nodeId, options);     }            reset()     {         super.reset();          this.constant = null;     }        copy()     {         const copy = new m1740(this.nodeId, this.options);          copy.m3266(this);          if (this.constant) copy.constant = this.constant.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                                  const constant = await evalNumberValue(this.constant, parse);                   let value;          switch (Math.min(Math.max(0, constant.x3604()), 5))         {             case 0: value = 1.4142135623; break;              case 1: value = 2.7182818284; break;              case 2: value = 0.6180339887; break;              case 3: value = 1.6180339887; break;              case 4: value = 3.1415926536; break;              case 5: value = 6.2831853072; break;          }           this.value = new n1835(value);                   this.h3980(parse,         [             ['value',   this.value],             ['constant', constant ]         ]);           this.validate();          return this;     }        isValid()     {         return this.constant && this.constant.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.constant) this.constant.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.constant) this.constant.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.constant) this.constant.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const g3575 = new m1740(nodeId, options);                   if (parse.settings.logRequests)              x1937(g3575, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, g3575);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   g3575.constant = t1607(parse);                   parse.p3553--;                   genParseNodeEnd(parse, g3575);         return g3575;     } } 


class z1742 extends l1856 {     static { d1855.types[k1101] = this; }        seconds   = null;     minutes   = null;     hours     = null;     dayOfWeek = null;     date      = null;     month     = null;     year      = null;                    constructor(nodeId, options)     {         super(k1101, nodeId, options);     }            reset()     {         super.reset();                  this.seconds   = null;         this.minutes   = null;         this.hours     = null;         this.dayOfWeek = null;         this.date      = null;         this.month     = null;         this.year      = null;     }        copy()     {         const copy = new g1745(this.nodeId, this.options);                  copy.m3266(this);                  if (this.seconds  ) copy.seconds   = this.seconds  .copy();         if (this.minutes  ) copy.minutes   = this.minutes  .copy();         if (this.hours    ) copy.hours     = this.hours    .copy();         if (this.dayOfWeek) copy.dayOfWeek = this.dayOfWeek.copy();         if (this.date     ) copy.date      = this.date     .copy();         if (this.month    ) copy.month     = this.month    .copy();         if (this.year     ) copy.year      = this.year     .copy();          return copy;     }                        isCached()     {         return super.isCached()             && (!this.year      || this.year     .isCached())             && (!this.month     || this.month    .isCached())             && (!this.date      || this.date     .isCached())             && (!this.dayOfWeek || this.dayOfWeek.isCached())             && (!this.hours     || this.hours    .isCached())             && (!this.minutes   || this.minutes  .isCached())             && (!this.seconds   || this.seconds  .isCached())     }        async eval(parse)     {         if (this.isCached())             return this;           this.w3004 = [];                   if (this.options.enabled)         {             const dateTime = new Date();              const seconds   = new n1835(dateTime.getSeconds() );             const minutes   = new n1835(dateTime.getMinutes() );             const hours     = new n1835(dateTime.getHours()   );             const dayOfWeek = new n1835(dateTime.getDay()     );             const date      = new n1835(dateTime.getDate()    );             const month     = new n1835(dateTime.getMonth()   );             const year      = new n1835(dateTime.getFullYear());               this.h3980(parse,             [                 ['seconds',   seconds  ],                 ['minutes',   minutes  ],                 ['hours',     hours    ],                 ['dayOfWeek', dayOfWeek],                 ['date',      date     ],                 ['month',     month    ],                 ['year',      year     ]             ]);             }                       this.validate();          return this;     }            isValid()     {         return this.year      && this.year     .isValid()             && this.month     && this.month    .isValid()             && this.date      && this.date     .isValid()             && this.dayOfWeek && this.dayOfWeek.isValid()             && this.hours     && this.hours    .isValid()             && this.minutes   && this.minutes  .isValid()             && this.seconds   && this.seconds  .isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.year     ) this.year     .o3967(parse);         if (this.month    ) this.month    .o3967(parse);         if (this.date     ) this.date     .o3967(parse);         if (this.dayOfWeek) this.dayOfWeek.o3967(parse);         if (this.hours    ) this.hours    .o3967(parse);         if (this.minutes  ) this.minutes  .o3967(parse);         if (this.seconds  ) this.seconds  .o3967(parse);     }            y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.year     ) this.year     .y3968(parse, from, force);         if (this.month    ) this.month    .y3968(parse, from, force);         if (this.date     ) this.date     .y3968(parse, from, force);         if (this.dayOfWeek) this.dayOfWeek.y3968(parse, from, force);         if (this.hours    ) this.hours    .y3968(parse, from, force);         if (this.minutes  ) this.minutes  .y3968(parse, from, force);         if (this.seconds  ) this.seconds  .y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.year     ) this.year     .l3966(parse);         if (this.month    ) this.month    .l3966(parse);         if (this.date     ) this.date     .l3966(parse);         if (this.dayOfWeek) this.dayOfWeek.l3966(parse);         if (this.hours    ) this.hours    .l3966(parse);         if (this.minutes  ) this.minutes  .l3966(parse);         if (this.seconds  ) this.seconds  .l3966(parse);     }            static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const dateTime = new z1742(nodeId, options);                   if (parse.settings.logRequests)              x1937(dateTime, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, dateTime);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   dateTime.seconds   = t1607(parse);         dateTime.minutes   = t1607(parse);         dateTime.hours     = t1607(parse);         dateTime.dayOfWeek = t1607(parse);         dateTime.date      = t1607(parse);         dateTime.month     = t1607(parse);         dateTime.year      = t1607(parse);                   parse.p3553--;                   genParseNodeEnd(parse, dateTime);         return dateTime;     } } 


class w1743 extends l1856 {     static { d1855.types[j1085] = this; }        inputs = [];        constructor(nodeId, options)     {         super(j1085, nodeId, options);     }            reset()     {         super.reset();          this.input = [];     }        copy()     {         const copy = new w1743(this.nodeId, this.options);          copy.m3266(this);          copy.inputs = this.inputs.map(i => i.copy());          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const _values = [];          for (let i = 0; i < this.inputs.length; i++)         {             const input = await evalValue(this.inputs[i], parse);              if (   input                 && this.options.enabled)                         {                 if (l955(input.type))                 {                     if (input.condensed === true)                         _values.push(input.copy());                     else                     {                         for (const item of input.items)                             _values.push(item.copy());                        }                 }                 else                     _values.push(input.copy());             }         }                       this.value =              _values.length > 0                 ? _values[this.currentIteration % _values.length]                 : new p4096();           if (   this.value              && this.value.objects)         {             for (let i = 0; i < this.value.objects.length; i++)             {                 const c111 = this.value.objects[i];                      c111.nodeId = this.nodeId;                 c111.listId = -1;                      c111.objectId = this.nodeId;                                  if (c111.objectId != NULL)                      c111.objectId += '/';                      c111.objectId += i.toString();             }         }           this.q3979(parse);                   const type =                _values.length > 1             && f3386(_values) == q1054                 ? new e1846(r1086)                 : this.outputType();           this.h3980(parse,         [             ['type', type]         ]);                   this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return !this.inputs.find(i => !i.isValid());     }        o3967(parse)     {         super.o3967(parse);          this.inputs.forEach(i => i.o3967(parse));     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          this.inputs.forEach(i => i.y3968(parse, from, force));     }        l3966(parse)     {         super.l3966(parse);          this.inputs.forEach(i => i.l3966(parse));     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const define = new w1743(nodeId, options);                   let z4088 = 0;                  if (!ignore)             z4088 = parseInt(parse.move());                   if (parse.settings.logRequests)              x1937(define, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, define);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                       for (let i = 0; i < z4088; i++)             define.inputs.push(t1607(parse));                   parse.p3553--;                   genParseNodeEnd(parse, define);         return define;     } } 


class e1755 extends l1856 {     static { d1855.types[y1102] = this; }        start    = null;     multiply = null;     add      = null;     end      = null;      current  = null;                    constructor(nodeId, options)     {         super(y1102, nodeId, options);     }        reset()     {         super.reset();                  this.start    = null;         this.multiply = null;         this.add      = null;         this.end      = null;              this.current  = null;     }           copy()     {         const copy = new e1755(this.nodeId, this.options);          copy.m3266(this);          if (this.start   ) copy.start    = this.start   .copy();         if (this.multiply) copy.multiply = this.multiply.copy();         if (this.add     ) copy.add      = this.add     .copy();         if (this.end     ) copy.end      = this.end     .copy();          if (this.current) copy.current = this.current.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const start = await evalNumberValue(this.start,    parse);         const mult  = await evalNumberValue(this.multiply, parse);         const add   = await evalNumberValue(this.add,      parse);         const end   = await evalNumberValue(this.end,      parse);               if (   start             && mult             && add             && end)         {             const value = start.value + (this.options.enabled ? add.value * this.currentIteration : 0);              if (!end.isValid())                 this.value = getSequenceValue(start, mult, add, this.currentIteration, this.options.enabled);              else if (   end.isValid()                         && (   add.value == 0                          || add.value >  0 && start.value < end.value                                            &&       value < end.value                          || add.value <  0 && start.value > end.value                                            &&       value > end.value))                 this.value = getSequenceValue(start, mult, add, this.currentIteration, this.options.enabled);              else                 this.value = n1835.NaN();         }         else             this.value = n1835.NaN();           this.h3980(parse,         [             ['start',    start],             ['multiply', mult ],             ['add',      add  ],             ['end',      end  ]         ]);                   this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return this.start    && this.start   .isValid()             && this.multiply && this.multiply.isValid()             && this.add      && this.add     .isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.start   ) this.start   .o3967(parse);         if (this.multiply) this.multiply.o3967(parse);         if (this.add     ) this.add     .o3967(parse);         if (this.end     ) this.end     .o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.start   ) this.start   .y3968(parse, from, force);         if (this.multiply) this.multiply.y3968(parse, from, force);         if (this.add     ) this.add     .y3968(parse, from, force);         if (this.end     ) this.end     .y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.start   ) this.start   .l3966(parse);         if (this.multiply) this.multiply.l3966(parse);         if (this.add     ) this.add     .l3966(parse);         if (this.end     ) this.end     .l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const seq = new e1755(nodeId, options);                   if (parse.settings.logRequests)              x1937(seq, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, seq);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   seq.start    = t1607(parse);         seq.multiply = t1607(parse);         seq.add      = t1607(parse);         seq.end      = t1607(parse);                   parse.p3553--;                   genParseNodeEnd(parse, seq);         return seq;     } }    function getSequenceValue(start, mult, add, iteration, enabled) {     let value = start.value;      if (enabled)     {         for (let i = 0; i < iteration; i++)         {             value *= mult.value;             value += add .value;         }     }      return new n1835(         value,          Math.max(             start.decimals,              mult .decimals,              add  .decimals)); }


class z1753 extends l1856 {     static { d1855.types[n1103] = this; }        from  = null;     start = null;     end   = null;                constructor(nodeId, options)     {         super(n1103, nodeId, options);     }            reset()     {         super.reset();          this.from  = null;         this.start = null;         this.end   = null;     }        copy()     {         const copy = new z1753(this.nodeId, this.options);          copy.m3266(this);          if (this.from   ) copy.from    = this.from   .copy();         if (this.start  ) copy.start   = this.start  .copy();         if (this.end    ) copy.end     = this.end    .copy();          if (this.current) copy.current = this.current.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const from  = await evalNumberValue(this.from,  parse);         const start = await evalNumberValue(this.start, parse);         const end   = await evalNumberValue(this.end,   parse);               const repeat    = parse.repeats.find(r => r.repeatId == this.s3718);         const iteration = repeat ? repeat.currentIteration : 0;           if (   from             && start             && end)         {             let delta = end.value - start.value;              let step =                  repeat                 && this.options.enabled                 ? delta / Math.max(1, repeat.total - (from.value == 1 ? 1 : 0))                 : 0;                               let startOffset;                   if (from  .value == 2) startOffset = step;             else if (from  .value == 1                 && repeat                 && repeat.total == 1) startOffset = delta/2;             else                        startOffset = 0;               let f;                          if (repeat)             {                      if (from.value == 2) f = iteration/repeat.total;                 else if (from.value == 1) f = (repeat.total > 1 ? iteration/(repeat.total-1) : 0);                 else if (from.value == 0) f = iteration/repeat.total;             }             else                 f = 0;               this.value = new n1835(                 start.value + startOffset + f * delta,                 Math.max(start.decimals, end.decimals));         }         else             this.value = n1835.NaN();           this.h3980(parse,         [             ['from',  from ],             ['start', start],             ['end',   end  ]         ]);           this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return this.from  && this.from .isValid()             && this.start && this.start.isValid()             && this.end   && this.end  .isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.from ) this.from .o3967(parse);         if (this.start) this.start.o3967(parse);         if (this.end  ) this.end  .o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.from ) this.from .y3968(parse, from, force);         if (this.start) this.start.y3968(parse, from, force);         if (this.end  ) this.end  .y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.from ) this.from .l3966(parse);         if (this.start) this.start.l3966(parse);         if (this.end  ) this.end  .l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const dist = new z1753(nodeId, options);                   if (parse.settings.logRequests)              x1937(dist, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, dist);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   dist.from   = t1607(parse);         dist.start  = t1607(parse);         dist.end    = t1607(parse);                   parse.p3553--;                   genParseNodeEnd(parse, dist);         return dist;     } } 


class y1759 extends l1856 {     static { d1855.types[i1104] = this; }        shape     = null;     base      = null;     amplitude = null;     frequency = null;     offset    = null;     bias      = null;          useWavelength;     offsetAbsolute;        constructor(nodeId, options)     {         super(i1104, nodeId, options);     }            reset()     {         super.reset();          this.shape     = null;         this.base      = null;         this.amplitude = null;         this.frequency = null;         this.offset    = null;         this.bias      = null;     }        copy()     {         const copy = new y1759(this.nodeId, this.options);          copy.m3266(this);          if (this.shape    ) copy.shape     = this.shape    .copy();         if (this.base     ) copy.base      = this.base     .copy();         if (this.amplitude) copy.amplitude = this.amplitude.copy();         if (this.frequency) copy.frequency = this.frequency.copy();         if (this.offset   ) copy.offset    = this.offset   .copy();         if (this.bias     ) copy.bias      = this.bias     .copy();          if (this.current) copy.current = this.current.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const shape  = await evalNumberValue(this.shape,     parse);         const base   = await evalNumberValue(this.base,      parse);         const amp    = await evalNumberValue(this.amplitude, parse);         let   freq   = await evalNumberValue(this.frequency, parse);         const offset = await evalNumberValue(this.offset,    parse);         const bias   = await evalNumberValue(this.bias,      parse);               const repeat    = parse.repeats.find(r => r.repeatId == this.s3718);         const iteration = repeat ? repeat.currentIteration : 0;            if (this.options.enabled)         {             let t;                                       if (   repeat                 && shape                 && freq                 && offset)             {                 const _freq =                     this.useWavelength                     ? repeat.total / nozero(freq.value)                     : freq.value;                  let _offset =                     this.offsetAbsolute                     ? offset.value/repeat.total                     : (offset.value/100)/_freq;                  if (shape.value == 3)                     _offset -= 0.25;                  t = (iteration/repeat.total - _offset) * _freq;                  while (t < 0) t++;                 while (t > 1) t--;                  switch (shape.value)                 {                     case 0: t = (t%1) < 0.5 ? 1 : -1;      break;                      case 1: t = (1 - (t%1)*2);             break;                      case 2: t = ((t%1)*2 - 1);             break;                      case 3: t = 1 - 2*Math.abs(2*(t%1)-1); break;                      case 4: t = Math.sin(t * Tau);         break;                  }             }             else                  t = 0;                           if (bias)             {                 const b = bias.value / 100;                  if (b >= 0) t = t / (1+b) + b/2;                 else        t = t / (1-b) + b/2;             }               if (amp ) t = t * amp .value;             if (base) t = t + base.value;               this.value = new n1835(                 t,                  Math.max(                     base  .decimals,                      amp   .decimals,                      freq  .decimals,                      offset.decimals,                      bias  .decimals));         }         else             this.value = base.copy();                   this.h3980(parse,         [             ['shape',     shape ],             ['base',      base  ],             ['amplitude', amp   ],             ['frequency', freq  ],             ['offset',    offset],             ['bias',      bias  ]         ]);           this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return this.shape     && this.shape    .isValid()             && this.base      && this.base     .isValid()             && this.amplitude && this.amplitude.isValid()             && this.frequency && this.frequency.isValid()             && this.offset    && this.offset   .isValid()             && this.bias      && this.bias     .isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.shape    ) this.shape    .o3967(parse);         if (this.base     ) this.base     .o3967(parse);         if (this.amplitude) this.amplitude.o3967(parse);         if (this.frequency) this.frequency.o3967(parse);         if (this.offset   ) this.offset   .o3967(parse);         if (this.bias     ) this.bias     .o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.shape    ) this.shape    .y3968(parse, from, force);         if (this.base     ) this.base     .y3968(parse, from, force);         if (this.amplitude) this.amplitude.y3968(parse, from, force);         if (this.frequency) this.frequency.y3968(parse, from, force);         if (this.offset   ) this.offset   .y3968(parse, from, force);         if (this.bias     ) this.bias     .y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.shape    ) this.shape    .l3966(parse);         if (this.base     ) this.base     .l3966(parse);         if (this.amplitude) this.amplitude.l3966(parse);         if (this.frequency) this.frequency.l3966(parse);         if (this.offset   ) this.offset   .l3966(parse);         if (this.bias     ) this.bias     .l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const wave = new y1759(nodeId, options);                   if (parse.settings.logRequests)              x1937(wave, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, wave);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   wave.shape     = t1607(parse);         wave.base      = t1607(parse);         wave.amplitude = t1607(parse);         wave.frequency = t1607(parse);         wave.offset    = t1607(parse);         wave.bias      = t1607(parse);                   wave.useWavelength  = parseInt(parse.move()) > 0;         wave.offsetAbsolute = parseInt(parse.move()) > 0;                   parse.p3553--;                   genParseNodeEnd(parse, wave);         return wave;     } } 


class o1752 extends l1856 {     static { d1855.types[z1105] = this; }        seed         = null;     iteration    = null;     min          = null;     max          = null;     bias         = null;     spread       = null;     unique       = null;      random       = null;     randomUnique = null;      lastValue1   = -1;     lastValue2   = -1;     uniqueOffset =  0;        constructor(nodeId, options)     {         super(z1105, nodeId, options);     }            reset()     {         super.reset();          this.seed      = null;         this.iteration = null;         this.min       = null;         this.max       = null;         this.bias      = null;         this.spread    = null;         this.unique    = null;     }        copy()     {         const copy = new o1752(this.nodeId, this.options);          copy.m3266(this);          if (this.seed     ) copy.seed      = this.seed     .copy();         if (this.iteration) copy.iteration = this.iteration.copy();         if (this.min      ) copy.min       = this.min      .copy();         if (this.max      ) copy.max       = this.max      .copy();         if (this.bias     ) copy.bias      = this.bias     .copy();         if (this.spread   ) copy.spread    = this.spread   .copy();         if (this.unique   ) copy.unique    = this.unique   .copy();          if (this.random   ) copy.random    = this.random   .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const seed      = await evalNumberValue(this.seed,      parse);         const iteration = await evalNumberValue(this.iteration, parse);         const min       = await evalNumberValue(this.min,       parse);         const max       = await evalNumberValue(this.max,       parse);         const bias      = await evalNumberValue(this.bias,      parse);         const spread    = await evalNumberValue(this.spread,    parse);         const unique    = await evalNumberValue(this.unique,    parse);               if (   this.options.enabled             && iteration             && seed             && min             && max             && bias             && spread             && unique)         {             if (  !this.random                 || this.random.seed != seed.value)             {                 this.random       = new Random(seed.value);                 this.randomUnique = new Random(seed.value+1);             }               if (iteration.isValid())                 this.currentIteration = Math.round(iteration.value);               if (this.currentIteration >= 0)             {                 let f  = this.random.get(this.currentIteration + this.uniqueOffset);                  f = r3632(f, bias.value, spread.value);                 f = min.value + f * (max.value - min.value);                                  this.value = new n1835(f, Math.max(min.decimals, max.decimals));                                       const _unique = unique.value/100;                                   if (max.value - min.value >= 1)                 {                     while (this.value.x3604() == this.lastValue1                         && this.randomUnique.get(this.currentIteration) < _unique)                         this.value = new n1835(                             min.value + this.random.get(this.currentIteration + ++this.uniqueOffset) * (max.value - min.value),                             Math.max(min.decimals, max.decimals));                 }                  if (max.value - min.value >= 2)                 {                     while ((   this.value.x3604() == this.lastValue1                             || this.value.x3604() == this.lastValue2)                         && this.randomUnique.get(this.currentIteration) < Math.max(_unique - 1))                         this.value = new n1835(                             min.value + this.random.get(this.currentIteration + ++this.uniqueOffset) * (max.value - min.value),                             Math.max(min.decimals, max.decimals));                 }                     }             else                 this.value = new n1835((min.value + max.value) / 2);         }         else             this.value = n1835.NaN();                              this.lastValue2 = this.lastValue1;         this.lastValue1 = this.value.x3604();           this.h3980(parse,         [             ['iteration', iteration],             ['seed',      seed     ],             ['min',       min      ],             ['max',       max      ],             ['bias',      bias     ],             ['spread',    spread   ],             ['unique',    unique   ]         ]);                   this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return this.seed      && this.seed     .isValid()             && this.iteration && this.iteration.isValid()             && this.min       && this.min      .isValid()             && this.max       && this.max      .isValid()             && this.bias      && this.bias     .isValid()             && this.spread    && this.spread   .isValid()             && this.unique    && this.unique   .isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.seed     ) this.seed     .o3967(parse);         if (this.iteration) this.iteration.o3967(parse);         if (this.min      ) this.min      .o3967(parse);         if (this.max      ) this.max      .o3967(parse);         if (this.bias     ) this.bias     .o3967(parse);         if (this.spread   ) this.spread   .o3967(parse);         if (this.unique   ) this.unique   .o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.seed     ) this.seed     .y3968(parse, from, force);         if (this.iteration) this.iteration.y3968(parse, from, force);         if (this.min      ) this.min      .y3968(parse, from, force);         if (this.max      ) this.max      .y3968(parse, from, force);         if (this.bias     ) this.bias     .y3968(parse, from, force);         if (this.spread   ) this.spread   .y3968(parse, from, force);         if (this.unique   ) this.unique   .y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.seed     ) this.seed     .l3966(parse);         if (this.iteration) this.iteration.l3966(parse);         if (this.min      ) this.min      .l3966(parse);         if (this.max      ) this.max      .l3966(parse);         if (this.bias     ) this.bias     .l3966(parse);         if (this.spread   ) this.spread   .l3966(parse);         if (this.unique   ) this.unique   .l3966(parse);     }        k3535(parse, nodeId)     {         super.k3535(parse, nodeId);          this.uniqueOffset = 0;     }        p3538(parse, nodeId)     {         super.p3538(parse, nodeId);          this.uniqueOffset = 0;     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const rnd = new o1752(nodeId, options);                   if (parse.settings.logRequests)              x1937(rnd, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, rnd);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   rnd.seed      = t1607(parse);         rnd.iteration = t1607(parse);         rnd.min       = t1607(parse);         rnd.max       = t1607(parse);         rnd.bias      = t1607(parse);         rnd.spread    = t1607(parse);         rnd.unique    = t1607(parse);                   parse.p3553--;                   genParseNodeEnd(parse, rnd);         return rnd;     } } 


class a1748 extends l1856 {     static { d1855.types[h1106] = this; }        seed        = null;     iteration   = null;     min         = null;     max         = null;     scale       = null;     interpolate = null;     offset      = null;     evolve      = null;     detail      = null;          randoms     = [];     offsets     = [];                    constructor(nodeId, options)     {         super(h1106, nodeId, options);     }                    reset()     {         super.reset();                  this.seed          = null;         this.iteration     = null;         this.min           = null;         this.max           = null;         this.scale         = null;         this.interpolate   = null;         this.offset        = null;         this.evolve        = null;         this.detail        = null;     }        copy()     {         const copy = new a1748(this.nodeId, this.options);          copy.m3266(this);          if (this.seed       ) copy.seed        = this.seed       .copy();         if (this.iteration  ) copy.iteration   = this.iteration  .copy();         if (this.min        ) copy.min         = this.min        .copy();         if (this.max        ) copy.max         = this.max        .copy();         if (this.scale      ) copy.scale       = this.scale      .copy();         if (this.offset     ) copy.offset      = this.offset     .copy();         if (this.evolve     ) copy.evolve      = this.evolve     .copy();         if (this.interpolate) copy.interpolate = this.interpolate.copy();         if (this.detail     ) copy.detail      = this.detail     .copy();          if (this.randoms    ) copy.randoms     = this.randoms.map(r => r.copy());         if (this.offsets    ) copy.offsets     = this.offsets.slice();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const seed        = await evalNumberValue(this.seed,        parse);         const iteration   = await evalNumberValue(this.iteration,   parse);         const min         = await evalNumberValue(this.min,         parse);         const max         = await evalNumberValue(this.max,         parse);         const scale       = await evalNumberValue(this.scale,       parse);         const offset      = await evalNumberValue(this.offset,      parse);         const evolve      = await evalNumberValue(this.evolve,      parse);         const interpolate = await evalNumberValue(this.interpolate, parse);         const detail      = await evalNumberValue(this.detail,      parse);               if (   this.options.enabled             && seed             && iteration             && min             && max             && scale             && offset             && evolve             && interpolate             && detail)         {             const _detail = Math.max(1, Math.ceil(detail.value));               if (  !this.randoms                 || this.randoms.length < _detail)             {                 const randoms = new Array(_detail);                  for (let c = 0; c < this.randoms.length; c++)                     randoms[c] = this.randoms[c];                                   let _seed = seed.value;                  for (let c = this.randoms.length; c < _detail; c++)                 {                     randoms[c] = new w375(_seed);                     _seed = seed.value;                 }                   this.randoms = randoms;                   this.updateOffsets(this.randoms[0].width * _detail);             }               let   size  = 1;             let   power = 1;                          const avg   = (min.value + max.value) / 2;             let   r;                           if (iteration.isValid())                 this.currentIteration = Math.round(iteration.value);                               if (   this.options.enabled                 && scale  && scale .isValid()                 && offset && offset.isValid()                 && evolve && evolve.isValid())             {                 scale.decimals = Math.min(scale.decimals, 4);                                  r = avg;                                  if (this.currentIteration >= 0)                 {                     for (let c = 0; c < _detail; c++)                     {                         const i  = Math.max(0, this.currentIteration / (Math.max(0.000001, scale.value) * size) + offset.value);                         const i0 = Math.floor(i);                         const i1 = Math.ceil (i);                                                   this.updateOffsets((i1 + 1) * _detail);                          const o0 = this.offsets[i0];                         const o1 = this.offsets[i1];                         let   _o;                          switch (interpolate.value)                         {                             case 0: _o = o0;                                                 break;                             case 1: _o = t1033(o0, o1, i-i0);                                 break;                             case 2: _o = (o0 + (o1 - o0) * (-Math.cos((i-i0)*Tau/2) + 1)/2); break;                         }                                                   const j   = evolve.value + _o;                         const j0  = Math.floor(j);                         const j1  = Math.ceil (j);                           const r00 = this.randoms[c].get(i0, j0);                         const r10 = this.randoms[c].get(i1, j0);                         const r01 = this.randoms[c].get(i0, j1);                         const r11 = this.randoms[c].get(i1, j1);                                       let _r, _r0, _r1;                                                  switch (interpolate.value)                         {                             case 0:                                  _r = r00;                                 break;                              case 1:                                  _r0 = t1033(r00, r10, i-i0);                                 _r1 = t1033(r01, r11, i-i0);                                 _r  = t1033(_r0, _r1, j-j0);                                 break;                              case 2:                                  _r0 = (r00 + (r10 - r00) * (-Math.cos((i-i0)*Tau/2) + 1)/2);                                  _r1 = (r01 + (r11 - r01) * (-Math.cos((i-i0)*Tau/2) + 1)/2);                                  _r  = (_r0 + (_r1 - _r0) * (-Math.cos((j-j0)*Tau/2) + 1)/2);                                  break;                         }                           const clamp =                              detail.value - c < 1                              ? detail.value - c                              : 1;                          r +=                              - power *      (avg       - min.value) * clamp                             + power * _r * (max.value - min.value) * clamp;                                                   size  /= 2;                         power /= 2;                                                   this.updateOffsets(this.randoms[0].width * _detail);                     }                 }             }             else             {                 r = min.value;             }               this.value = new n1835(r, Math.max(min.decimals, max.decimals));         }         else         {             this.value = n1835.NaN();         }           this.h3980(parse,         [             ['seed',        seed       ],             ['iteration',   iteration  ],             ['min',         min        ],             ['max',         max        ],             ['scale',       scale      ],             ['offset',      offset     ],             ['evolve',      evolve     ],             ['interpolate', interpolate],             ['detail',      detail     ]         ]);                   this.validate();          return this;     }        updateOffsets(newSize)     {         if (newSize < this.offsets.length)              return;          this.offsets = new Array(newSize);         const offsetRandom = new Random(0);          for (let o = 0; o < newSize; o++)             this.offsets[o] = offsetRandom.get(o);     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return this.seed        && this.seed       .isValid()             && this.iteration   && this.iteration  .isValid()             && this.min         && this.min        .isValid()             && this.max         && this.max        .isValid()             && this.scale       && this.scale      .isValid()             && this.offset      && this.offset     .isValid()             && this.evolve      && this.evolve     .isValid()             && this.interpolate && this.interpolate.isValid()             && this.detail      && this.detail     .isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.seed       ) this.seed       .o3967(parse);         if (this.iteration  ) this.iteration  .o3967(parse);         if (this.min        ) this.min        .o3967(parse);         if (this.max        ) this.max        .o3967(parse);         if (this.scale      ) this.scale      .o3967(parse);         if (this.offset     ) this.offset     .o3967(parse);         if (this.evolve     ) this.evolve     .o3967(parse);         if (this.interpolate) this.interpolate.o3967(parse);         if (this.detail     ) this.detail     .o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.seed       ) this.seed       .y3968(parse, from, force);         if (this.iteration  ) this.iteration  .y3968(parse, from, force);         if (this.min        ) this.min        .y3968(parse, from, force);         if (this.max        ) this.max        .y3968(parse, from, force);         if (this.scale      ) this.scale      .y3968(parse, from, force);         if (this.offset     ) this.offset     .y3968(parse, from, force);         if (this.evolve     ) this.evolve     .y3968(parse, from, force);         if (this.interpolate) this.interpolate.y3968(parse, from, force);         if (this.detail     ) this.detail     .y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.seed       ) this.seed       .l3966(parse);         if (this.iteration  ) this.iteration  .l3966(parse);         if (this.min        ) this.min        .l3966(parse);         if (this.max        ) this.max        .l3966(parse);         if (this.scale      ) this.scale      .l3966(parse);         if (this.offset     ) this.offset     .l3966(parse);         if (this.evolve     ) this.evolve     .l3966(parse);         if (this.interpolate) this.interpolate.l3966(parse);         if (this.detail     ) this.detail     .l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const noise = new a1748(nodeId, options);                   if (parse.settings.logRequests)              x1937(noise, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, noise);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   noise.seed        = t1607(parse);         noise.iteration   = t1607(parse);         noise.min         = t1607(parse);         noise.max         = t1607(parse);         noise.scale       = t1607(parse);         noise.offset      = t1607(parse);         noise.evolve      = t1607(parse);         noise.interpolate = t1607(parse);         noise.detail      = t1607(parse);                   parse.p3553--;                   genParseNodeEnd(parse, noise);         return noise;     } } 


class j1751 extends e1858 {     static { d1855.types[z1107] = this; }        seed      = null;     iteration = null;     chance    = null;     alternate = null;      random    = null;        constructor(nodeId, options)     {         super(z1107, nodeId, options);     }            reset()     {         super.reset();          this.seed      = null;         this.iteration = null;         this.chance    = null;         this.alternate = null;     }        copy()     {         const copy = new o1752(this.nodeId, this.options);          copy.m3266(this);          if (this.seed     ) copy.seed      = this.seed     .copy();         if (this.iteration) copy.iteration = this.iteration.copy();         if (this.chance   ) copy.chance    = this.chance   .copy();         if (this.alternate) copy.alternate = this.alternate.copy();          if (this.random) copy.random = this.random.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const e3962    = await evalValue      (this.e3962,    parse);         const d3963    = await evalValue      (this.d3963,    parse);         const seed      = await evalNumberValue(this.seed,      parse);         const iteration = await evalNumberValue(this.iteration, parse);         const chance    = await evalNumberValue(this.chance,    parse);         const alternate = await evalNumberValue(this.alternate, parse);               const _values = [];           if (   seed             && iteration             && chance             && alternate)         {             if (  !this.random                 || this.random.seed != seed.value)                 this.random = new Random(seed.value);               if (iteration.isValid())                 this.currentIteration = Math.round(iteration.value);               if (this.currentIteration >= 0)             {                 const calt  = this.currentIteration % 2 == 0 ? 0 : 1;                  let   cval  = chance.value/100;                       cval += alternate.value/100 * (calt - cval);                  const ch    = this.random.get(this.currentIteration) > cval ? 0 : 1;                                   if (   e3962                      && d3963)                 {                     if (   e3962.isValid()                         && d3963.isValid())                     {                         this.value =                              ch < 0.5                                  ? e3962                                  : d3963;                     }                     else                     {                         this.value =                              ch < 0.5                                  ? nanFromType(e3962.type)                                  : nanFromType(d3963.type);                     }                      _values.push(e3962, d3963);                 }                  else if (e3962)                 {                     this.value =                             e3962.isValid()                         && ch >= 0.5                             ? e3962                             : nanFromType(e3962.type);                      _values.push(e3962);                 }                                  else if (d3963)                 {                     this.value =                             d3963.isValid()                         && ch < 0.5                             ? d3963                             : nanFromType(d3963.type);                      _values.push(d3963);                 }                                  else                     this.value = new n1835(ch < 0.5 ? 0 : 1);             }             else                 this.value = new p4096();         }         else             this.value = new p4096();           const type =                _values.length > 1             && f3386(_values) == q1054             ? new e1846(r1086)             : this.outputType();           this.h3980(parse,         [             ['type',      type     ],             ['seed',      seed     ],             ['iteration', iteration],             ['chance',    chance   ],             ['alternate', alternate]         ]);                   this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return this.seed      && this.seed     .isValid()             && this.iteration && this.iteration.isValid()             && this.chance    && this.chance   .isValid()             && this.alternate && this.alternate.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.seed     ) this.seed     .o3967(parse);         if (this.iteration) this.iteration.o3967(parse);         if (this.chance   ) this.chance   .o3967(parse);         if (this.alternate) this.alternate.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.seed     ) this.seed     .y3968(parse, from, force);         if (this.iteration) this.iteration.y3968(parse, from, force);         if (this.chance   ) this.chance   .y3968(parse, from, force);         if (this.alternate) this.alternate.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.seed     ) this.seed     .l3966(parse);         if (this.iteration) this.iteration.l3966(parse);         if (this.chance   ) this.chance   .l3966(parse);         if (this.alternate) this.alternate.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const prob = new j1751(nodeId, options);                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 2, 'nInputs must be [0, 2]');         }                   const n3583 =              z4088 == 1             ? parseInt(parse.move())             : -1;                   if (parse.settings.logRequests)              x1937(prob, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, prob);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 2)         {             prob.e3962   = t1607(parse);             prob.d3963   = t1607(parse);         }         else if (z4088 == 1)         {                  if (n3583 == 0) prob.e3962 = t1607(parse);              else if (n3583 == 1) prob.d3963 = t1607(parse);          }                   prob.seed      = t1607(parse);         prob.iteration = t1607(parse);         prob.chance    = t1607(parse);         prob.alternate = t1607(parse);                   parse.p3553--;                   genParseNodeEnd(parse, prob);         return prob;     } } 


class h1738 extends y1857 {     static { d1855.types[b1108] = this; }        current;     when;        constructor(nodeId, options)     {         super(b1108, nodeId, options);          this.current = new n1835(0);     }            reset()     {         super.reset();          this.current = null;         this.when    = null;     }        copy()     {         const copy = new h1738(this.nodeId, this.options);          copy.m3266(this);          if (this.when   ) copy.when    = this.when   .copy();         if (this.current) copy.current = this.current.copy();          return copy;     }        async eval(parse)     {         if (    this.isCached()             || !parse.evalAccumulate)             return this;           const input = await evalNumberValue(this.input, parse);         const when  = await evalNumberValue(this.when,  parse);                       if (   input             && when)         {             if (when.value == 0)                 this.value = this.current.copy();              if (input)             {                 this.current.value   += input.value;                 this.current.decimals = Math.max(this.current.decimals, input.decimals);             }              if (when.value > 0)                 this.value = this.current.copy();         }         else             this.value = n1835.NaN();           this.h3980(parse,          [             ['when', when]         ]);                   this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.when && this.when.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.when) this.when.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.when) this.when.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.when) this.when.l3966(parse);     }        p3538(parse, nodeId)     {         super.p3538(parse, nodeId);          this.current = new n1835(0);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const accum = new h1738(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(accum, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, accum);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             accum.input = t1607(parse);              accum.when = t1607(parse);                           parse.p3553--;                   genParseNodeEnd(parse, accum);         return accum;     } } 


class GHold extends y1857 {     static { d1855.types[HOLD] = this; }        current;     first;        constructor(nodeId, options)     {         super(HOLD, nodeId, options);          this.current = null;     }            reset()     {         super.reset();          this.current = null;         this.first   = null;     }        copy()     {         const copy = new GHold(this.nodeId, this.options);          copy.m3266(this);          if (this.first  ) copy.first   = this.first  .copy();         if (this.current) copy.current = this.current.copy();          return copy;     }        async eval(parse)     {         if (    this.isCached()             || !parse.evalAccumulate)             return this;           const input = await evalValue(this.input, parse);         const first = await evalValue(this.first, parse);                       if (   input             && first)         {             if (this.options.enabled)             {                 this.value   = this.current ? this.current : first;                 this.current = input;             }             else                 this.value = input;         }         else             this.value = new p4096();           this.h3980(parse,          [             ['type', this.outputType()]         ]);                   this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.first && this.first.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.first) this.first.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.first) this.first.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.first) this.first.l3966(parse);     }        p3538(parse, nodeId)     {         super.p3538(parse, nodeId);          this.current = null;     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const hold = new GHold(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(hold, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, hold);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             hold.input = t1607(parse);              hold.first = t1607(parse);                           parse.p3553--;                   genParseNodeEnd(parse, hold);         return hold;     }         } 


class u1744 extends l1856 {     static { d1855.types[n1109] = this; }        inputs = [];      amount;     degree;        constructor(nodeId, options)     {         super(n1109, nodeId, options);     }            reset()     {         super.reset();          this.inputs = [];          this.amount = null;         this.degree = null;     }        copy()     {         const copy = new u1744(this.nodeId, this.options);          copy.m3266(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.amount) copy.amount = this.amount.copy();         if (this.degree) copy.degree = this.degree.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const amount = await evalNumberValue(this.amount, parse);         const degree = await evalNumberValue(this.degree, parse);           const values = [];                  for (const s3709 of this.inputs)         {             const input = await evalNumberOrListValue(s3709, parse);              if (l955(input.type))             {                 for (const item of input.items)                 {                     const value = await evalNumberValue(item, parse);                     values.push(value);                 }             }             else             {                 const value = await evalNumberValue(input, parse);                 values.push(value);             }         }                           const maxDec = values.reduce((max, v) => Math.max(max, v.decimals), 0);          const deg =             degree.value < 3             ? Math.min(degree.value, 2) + 1             : 1;          const nSegments = Math.floor((values.length-1)/deg);         const index     = Math.min(Math.floor((values.length-1)/deg * amount.value/100), nSegments-1);           if (values.length == 1)             this.value = values[0];          else if (values.length > 1               && index < values.length - deg)             this.value = interpolateNumberValue(values, index, nSegments, deg, degree, amount, maxDec);          else                               this.value = n1835.NaN();           this.h3980(parse,         [             ['value',  this.value],             ['amount', amount    ],             ['degree', degree    ]         ]);                   this.validate();          return this;     }        isValid()     {         return  super.isValid()             &&  this.inputs.length > 0             && !this.inputs.find(i => !i.isValid())             &&  this.amount && this.amount.isValid()             &&  this.degree && this.degree.isValid();     }        o3967(parse)     {         super.o3967(parse);          this.inputs.forEach(i => i.o3967(parse));          if (this.amount) this.amount.o3967(parse);         if (this.degree) this.degree.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          this.inputs.forEach(i => i.y3968(parse, from, force));          if (this.amount) this.amount.y3968(parse, from, force);         if (this.degree) this.degree.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          this.inputs.forEach(i => i.l3966(parse));          if (this.amount) this.amount.l3966(parse);         if (this.degree) this.degree.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const t1033 = new u1744(nodeId, options);                   let z4088 = 0;                  if (!ignore)             z4088 = parseInt(parse.move());                   if (parse.settings.logRequests)              x1937(t1033, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, t1033);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;              for (let i = 0; i < z4088; i++)             t1033.inputs.push(t1607(parse));                   t1033.amount = t1607(parse);         t1033.degree = t1607(parse);                   parse.p3553--;                   genParseNodeEnd(parse, t1033);         return t1033;     } }    function interpolateNumberValue(values, index, nSegments, deg, degree, amount, maxDec) {     const localAmount =          nSegments > 1             ? (amount.value/100 - index/nSegments) * nSegments             :  amount.value/100;       if (degree.value == 0)      {         const o3591 = values[index*deg  ];         const val1 = values[index*deg+1];          return new n1835(             t1033(o3591.value, val1.value, localAmount),             maxDec);     }     else if (degree.value == 1)      {         const o3591 = values[index*deg  ];         const val1 = values[index*deg+1];         const val2 = values[index*deg+2];          return new n1835(             u1034(o3591.value, val1.value, val2.value, localAmount),             maxDec);     }     else if (degree.value == 2)      {         const o3591 = values[index*deg  ];         const val1 = values[index*deg+1];         const val2 = values[index*deg+2];         const val3 = values[index*deg+3];          return new n1835(             k1035(o3591.value, val1.value, val2.value, val3.value, localAmount),             maxDec);     }     else if (degree.value == 3)      {         const o3591 = values[index*deg  ];         const val1 = values[index*deg+1];          return new n1835(             lerpCos(o3591.value, val1.value, localAmount),             maxDec);     }     else         return n1835.NaN(); }


class p1758 extends y1857 {     static { d1855.types[v1110] = this; }        current          = null;     target           = null;      currentConnected = false;      terminalIds      = [];            constructor(nodeId, options)     {         super(v1110, nodeId, options);     }            reset()     {         super.reset();          this.current          = null;         this.target           = null;          this.currentConnected = false;          this.terminalIds      = [];     }        copy()     {         const copy = new p1758(this.nodeId, this.options);          copy.m3266(this);          if (this.current) copy.current = this.current.copy();         if (this.target ) copy.target  = this.target .copy();          copy.terminalIds = [...this.terminalIds];          return copy;     }        isCached()     {         return super.isCached()             && this.current.isCached()             && this.target .isCached();     }        async eval(parse)     {         if (this.isCached())             return this;           let input   = await evalNumberValue(this.input,   parse);         let current = await evalNumberValue(this.current, parse);         let target  = await evalNumberValue(this.target,  parse);           if (   input             && this.input.type == PARAM             && target.isValid())         {             r950(                  input.type == e1090,                  'input.type must be NUMBER_VALUE');               if (this.options.enabled)             {                 let   diff     = target.value - current.value;                 let   prevDiff = 0;                   let   s3709   = current.isValid() ? input.value : 0;                 let   step     = 10;                   let   iter     = 0;                 const maxIter  = parse.settings.maxSolveIterations;                                   b1890(this.nodeId);                   parse.d3546 += maxIter;                   const inParamValue = this.input.node[this.input.i2902];                   parse.solvers.push(this);                   while (iter++ < maxIter)                 {                     s3709 += step;                       if (inParamValue)                     {                         if (inParamValue.parent)                         {                             inParamValue.parent.updateValueFromParam(                                 this.input.i2902,                                  new n1835(                                     s3709,                                      input.decimals));                         }                         else                             inParamValue.value = s3709;                                                   this.input  .y3968(parse, this, true);                         this.current.y3968(parse, this, true);                          current = await evalNumberValue(this.current, parse);                           if (   current.isValid()                             && target.isValid())                         {                             diff = target.x3604() - current.value;                              if (Math.abs(diff) < 0.00001)                                 break;                              if (   Math.abs (diff) >  Math.abs (prevDiff)                                 || Math.sign(diff) != Math.sign(prevDiff))                                 step /= -2;                              prevDiff = diff;                         }                         else                         {                             diff = 0;                             s3709 -= step;                             step /= -2;                         }                     }                                           parse.g3545++;                     s1891(parse, this.nodeId, iter / maxIter);                 }                   parse.solvers.pop();                   this.current.y3968(parse, this, true);                 current = await evalNumberValue(this.current, parse);                   if (current && target)                     current.decimals = target.decimals;                   if (   iter < maxIter                     && Math.abs(diff) < 0.0000001)                     parse.g3545 += maxIter - iter;                                                     this.value = inParamValue                     ? new n1835(current.value, target.decimals)                     : n1835.NaN();             }             else                 this.value = n1835.NaN();         }         else             this.value = n1835.NaN();           if (!this.currentConnected)             current = n1835.NaN();           this.h3980(parse,         [             ['current', current],             ['target',  target ]         ]);           this.validate();           if (this.input)             v947(parse.terminalIds, this.terminalIds);           return this;     }        isValid()     {         return super.isValid()             && this.current && this.current.isValid()             && this.target  && this.target .isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.current) this.current.o3967(parse);         if (this.target ) this.target .o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.current) this.current.y3968(parse, from, force);         if (this.target ) this.target .y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.current) this.current.l3966(parse);         if (this.target ) this.target .l3966(parse);     } } 


class n1739 extends l1856 {     static { d1855.types[v1111] = this; }        from   = null;     to     = null;     curve  = null;     repeat = null;     length = null;     time   = null;                    constructor(nodeId, options)     {         super(v1111, nodeId, options);     }                    reset()     {         super.reset();                  this.from   = null;         this.to     = null;         this.curve  = null;         this.repeat = null;         this.length = null;         this.time   = null;     }        copy()     {         const copy = new n1739(this.nodeId, this.options);          copy.m3266(this);          if (this.from  ) copy.from   = this.from  .copy();         if (this.to    ) copy.to     = this.to    .copy();         if (this.curve ) copy.curve  = this.curve .copy();         if (this.repeat) copy.repeat = this.repeat.copy();         if (this.length) copy.length = this.length.copy();         if (this.time  ) copy.time   = this.time  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const from   = await evalNumberValue(this.from,   parse);         const to     = await evalNumberValue(this.to,     parse);         const curve  = await evalNumberValue(this.curve,  parse);         const repeat = await evalNumberValue(this.repeat, parse);         const length = await evalNumberValue(this.length, parse);         const time   = await evalNumberValue(this.time,   parse);               const maxDec = Math.max(from.decimals, to.decimals);          switch (curve.value)         {             case 0:              {                 this.value = new n1835(                     time.value < length.value ? from.value : to.value,                      maxDec);                      break;             }             case 1:              {                 this.value = new n1835(                     from.value + (to.value - from.value) * time.value / length.value,                     maxDec);                  break;             }             case 2:              {                 let f = time.value / length.value;                  f = 1 - sqr(1 - f);                  this.value = new n1835(                     from.value + (to.value - from.value) * f,                     maxDec);                      break;             }             case 3:              {                 let f = time.value / length.value;                  f = sqr(f);                  this.value = new n1835(                     from.value + (to.value - from.value) * f,                     maxDec);                      break;             }             case 4:              {                 let f = time.value / length.value;                  f = 6*Math.pow(f, 5) - 15*Math.pow(f, 4) + 10*Math.pow(f, 3);                  this.value = new n1835(                     from.value + (to.value - from.value) * f,                     maxDec);                      break;             }         }                   this.h3980(parse,         [             ['from',   from  ],             ['to',     to    ],             ['curve',  curve ],             ['repeat', repeat],             ['length', length],             ['time',   time  ]         ]);                   this.validate();          return this;     }        isValid()     {         return this.from   && this.from  .isValid()             && this.to     && this.to    .isValid()             && this.curve  && this.curve .isValid()             && this.repeat && this.repeat.isValid()             && this.length && this.length.isValid()             && this.time   && this.time  .isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.from  ) this.from  .o3967(parse);         if (this.to    ) this.to    .o3967(parse);         if (this.curve ) this.curve .o3967(parse);         if (this.repeat) this.repeat.o3967(parse);         if (this.length) this.length.o3967(parse);         if (this.time  ) this.time  .o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.from  ) this.from  .y3968(parse, from, force);         if (this.to    ) this.to    .y3968(parse, from, force);         if (this.curve ) this.curve .y3968(parse, from, force);         if (this.repeat) this.repeat.y3968(parse, from, force);         if (this.length) this.length.y3968(parse, from, force);         if (this.time  ) this.time  .y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.from  ) this.from  .l3966(parse);         if (this.to    ) this.to    .l3966(parse);         if (this.curve ) this.curve .l3966(parse);         if (this.repeat) this.repeat.l3966(parse);         if (this.length) this.length.l3966(parse);         if (this.time  ) this.time  .l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const anim = new n1739(nodeId, options);                   if (parse.settings.logRequests)              x1937(anim, parse);                   if (ignore)          {             genParseNodeEnd(parse, anim);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   anim.from   = t1607(parse);         anim.to     = t1607(parse);         anim.curve  = t1607(parse);         anim.repeat = t1607(parse);         anim.length = t1607(parse);         anim.time   = t1607(parse);                   parse.p3553--;                   genParseNodeEnd(parse, anim);         return anim;     } } 


class u1715 extends q1712 {     static { d1855.types[f1113] = this; }        operation;        constructor(nodeId, options)     {         super(f1113, nodeId, options);     }       reset()     {         super.reset();          this.operation = null;     }            copy()     {         const copy = new u1715(this.nodeId, this.options);          copy.m3266(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.operation) copy.operation = this.operation.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const inputs = await Promise.all(this.inputs.map(async i => await evalNumberOrListValue(i, parse)));         let   op     = await evalNumberValue(this.operation, parse);           if (   op             && op.isValid())         {             op.value    = Math.min(Math.max(0, Math.round(op.value)), y1291.length-1);             op.decimals = 0;         }           this.value = await evalMathInputs(this, inputs, op, parse);               this.h3980(parse,         [             ['type',      this.outputType()],             ['operation', op               ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.operation && this.operation.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.operation) this.operation.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.operation) this.operation.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.operation) this.operation.l3966(parse);     }        static parseRequest(parse, p1604)     {         const [type, nodeId, options, ignore] = genParseNodeStart(parse);           const math = p1604(nodeId, options);                   let z4088 = 0;                  if (!ignore)             z4088 = parseInt(parse.move());           if (parse.settings.logRequests)              x1937(math, parse, ignore, z4088);           if (ignore)          {             genParseNodeEnd(parse, math);             return parse.m4122.find(n => n.nodeId == nodeId);         }           parse.p3553++;          for (let i = 0; i < z4088; i++)             math.inputs.push(t1607(parse));           math.operation = t1607(parse);           parse.p3553--;                       genParseNodeEnd(parse, math);         return math;     } }    async function evalMathInputs(node, inputs, op, parse) {     if (isEmpty(inputs))         return n1835.NaN();       const allAreLists = allInputsAreCondensedLists(inputs);      if (allAreLists) return await evalMathListInputs(node, inputs, op, parse);     else             return await evalMathItemInputs(node, inputs, op, parse); }    async function evalMathListInputs(node, inputs, op, parse) {     const value = new x1834();           for (const input of inputs)     {         if (!input) continue;          console.assert(              l955(input.type),              `input is ${input.type}, must be a list`);          if (allInputsAreCondensedLists(input.items))             value.items.push(...(await evalMathListInputs(node, input.items, op, parse)).items);         else             value.items.push(await evalMathItemInputs(node, input.items, op, parse));     }       return value; }    async function evalMathItemInputs(node, inputs, op, parse) {     switch (op.value)     {         case 0: return await z3602  (node, inputs, parse);         case 1: return await c3601  (node, inputs, parse);         case 2: return await i3599(node, inputs, parse);         case 3: return await h3598     (node, inputs, parse);         case 4: return await g3600(node, inputs, parse);         case 5: return await l3603(node, inputs, parse);     } }    async function h3598(node, inputs, parse) {     if (isEmpty(inputs))         return n1835.NaN();       let value = new n1835(0);               const options = { maxDec: 0 };       for (let i = 0; i < inputs.length; i++)     {         const input = inputs[i];                  if (   !input             || !input.isValid())             return n1835.NaN();           if (l955(input.type))         {             if (   isEmpty(input.items)                 || input.items[0].type != e1090)                 return n1835.NaN();              for (const item of input.items)                 evalAddStep(value, item, options);         }         else             evalAddStep(value, input, options);           value          = new n1835(value.value);         value.decimals = Math.max(value.decimals, options.maxDec);     }       return value; }    function evalAddStep(value, input, options) {     if (   !input         || !input.isValid())     {          value = n1835.NaN();         return;     }               if (input.type == e1090)     {         value.value   += input.x3604();         options.maxDec = Math.max(options.maxDec, input.decimals);     }                     }    async function i3599(node, inputs, parse) {     if (isEmpty(inputs))         return n1835.NaN();       let value;       const options = { maxDec: 0 };       const e3962 = inputs[0];      if (   !e3962         || !e3962.isValid())         return n1835.NaN();       if (    l955(e3962.type)         && !isEmpty(e3962.items))     {         const l3590 = e3962.items[0];          if (   !l3590             || !l3590.isValid())             return n1835.NaN();           value  = new n1835(l3590.x3604());         maxDec = l3590.decimals;           for (let j = 1; j < e3962.items.length; j++)             evalSubtractStep(value, e3962.items[j], options);     }     else     {         if (e3962.type != e1090)             return n1835.NaN();          value          = new n1835(e3962.x3604());         options.maxDec = e3962.decimals;     }       for (let i = 1; i < inputs.length; i++)     {         const input = inputs[i];          if (   !input             || !input.isValid())             return n1835.NaN();           if (l955(input.type))         {             for (const item of input.items)                 evalSubtractStep(value, item, options);         }         else             evalSubtractStep(value, input, options);     }               value          = new n1835(value.value);     value.decimals = Math.max(value.decimals, options.maxDec);       return value; }    function evalSubtractStep(value, input, options) {     if (   !input         || !input.isValid())     {          value = n1835.NaN();         return;     }               if (input.type == e1090)     {         value.value   -= input.x3604();         options.maxDec = Math.max(options.maxDec, input.decimals);     }                     }    async function g3600(node, inputs, parse) {     if (isEmpty(inputs))         return n1835.NaN();       let value = new n1835(1);       const options = { maxDec: 0 };       for (let i = 0; i < inputs.length; i++)     {         const input = inputs[i];          if (   !input             || !input.isValid())             return n1835.NaN();           if (l955(input.type))         {             if (   isEmpty(input.items)                 || input.items[0].type != e1090)                 return n1835.NaN();              for (const item of input.items)                 evalMultiplyStep(value, item, options);         }         else             evalMultiplyStep(value, input, options);     }       value          = new n1835(value.value);     value.decimals = Math.max(value.decimals, options.maxDec);       return value; }    function evalMultiplyStep(value, input, options) {     if (   !input         || !input.isValid())     {          value = n1835.NaN();         return;     }               if (input.type == e1090)     {         value.value   *= input.x3604();         options.maxDec = Math.max(options.maxDec, input.decimals);     }                     }    async function c3601(node, inputs, parse) {     if (isEmpty(inputs))         return n1835.NaN();               let   value;           const e3962 = inputs[0];      if (   !e3962         || !e3962.isValid())         return n1835.NaN();       const options = { maxDec: 0 };       if (l955(e3962.type))     {         if (!isEmpty(e3962.items))          {             const l3590 = e3962.items[0];              if (   !l3590                 || !l3590.isValid())                 return n1835.NaN();               value          = new n1835(l3590.x3604());             options.maxDec = l3590.decimals;               for (let j = 1; j < e3962.items.length; j++)                 evalDivideStep(value, e3962.items[j], options);         }     }     else     {         if (e3962.type != e1090)             return n1835.NaN();          value          = new n1835(e3962.x3604());         options.maxDec = e3962.decimals;     }           for (let i = 1; i < inputs.length; i++)     {         const input = inputs[i];          if (l955(input.type))         {             for (const item of input.items)                 evalDivideStep(value, item, options);         }         else             evalDivideStep(value, input, options);     }       value          = new n1835(value.value);     value.decimals = Math.max(value.decimals, options.maxDec);       return value; }    function evalDivideStep(value, input, options) {     if (   !input         || !input.isValid())     {          value = n1835.NaN();         return;     }               if (input.type == e1090)     {         if (input.value == 0)          {              value = n1835.NaN();             return;         }          value.value   /= input.x3604();         options.maxDec = Math.max(options.maxDec, input.decimals);     }                     }    async function z3602(node, inputs, parse) {     if (isEmpty(inputs))         return n1835.NaN();               let value;               const e3962 = inputs[0];      if (   !e3962         || !e3962.isValid())         return n1835.NaN();       const options = { maxDec: 0 };       if (    l955(e3962.type)         && !isEmpty(e3962.items))     {         const l3590 = e3962.items[0];          if (   !l3590             || !l3590.isValid())             return n1835.NaN();           value          = new n1835(l3590.x3604());         options.maxDec = l3590.decimals;                   for (let i = 1; i < e3962.items.length; i++)             evalModuloStep(value, e3962.items[i], options);     }     else     {         if (e3962.type != e1090)             return n1835.NaN();          value          = new n1835(e3962.x3604());         options.maxDec = e3962.decimals;     }       for (let i = 1; i < inputs.length; i++)     {         const input = inputs[i];          if (   !input             || !input.isValid())             return n1835.NaN();           if (l955(input.type))         {             for (const item of input.items)                 evalModuloStep(value, item, options);         }         else             evalModuloStep(value, input, options);     }       value          = new n1835(value.value);     value.decimals = Math.max(value.decimals, options.maxDec);       return value; }    function evalModuloStep(value, input, options) {     if (   !input         || !input.isValid())     {          value.value    = Number.NaN;          value.decimals = 0;         return;     }               if (input.type == e1090)     {         if (input.value == 0)          {              value = n1835.NaN();             return;         }          options.maxDec = Math.max(options.maxDec, input.decimals);         value.value    = g1013(value.x3604() % input.x3604(), options.maxDec);     }                     }    async function l3603(node, inputs, parse) {     if (isEmpty(inputs))         return n1835.NaN();       let value;       const e3962 = inputs[0];      if (   !e3962         || !e3962.isValid())         return n1835.NaN();       const options = { maxDec: 0 };       if (    l955(e3962.type)         && !isEmpty(e3962.items))     {         const l3590 = e3962.items[0];          if (   !l3590             || !l3590.isValid())             return n1835.NaN();           value          = new n1835(l3590.x3604());         options.maxDec = l3590.decimals;                   for (let i = 1; i < e3962.items.length; i++)             evalExponentStep(value, e3962.items[i], options);     }     else     {         if (e3962.type != e1090)             return n1835.NaN();          value          = new n1835(e3962.x3604());         options.maxDec = e3962.decimals;     }       for (let i = 1; i < inputs.length; i++)     {         const input = inputs[i];          if (   !input             || !input.isValid())             return n1835.NaN();           if (l955(input.type))         {             for (const item of input.items)                 evalExponentStep(value, item, options);         }         else             evalExponentStep(value, input, options);     }       value          = new n1835(value.value);     value.decimals = Math.max(value.decimals, options.maxDec);       return value; }    function evalExponentStep(value, input, options) {     if (   !input         || !input.isValid())     {          value = n1835.NaN();         return;     }               if (input.type == e1090)     {         value.value    = Math.pow(value.x3604(), input.x3604());         options.maxDec = Math.max(options.maxDec, input.decimals);     }                     }


class j1718 extends y1857 {     static { d1855.types[b1112] = this; }        operation;     operand;     invert;        constructor(nodeId, options)     {         super(b1112, nodeId, options);     }            reset()     {         super.reset();          this.operation = null;         this.operand   = null;         this.invert    = null;     }        copy()     {         const copy = new j1718(this.nodeId, this.options);          copy.m3266(this);          if (this.operation) copy.operation = this.operation.copy();         if (this.operand  ) copy.operand   = this.operand  .copy();         if (this.invert   ) copy.invert    = this.invert   .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input   = await evalNumberOrListValue(this.input,     parse);         const op      = await evalNumberValue      (this.operation, parse);         const operand = await evalNumberValue      (this.operand,   parse);         const invert  = await evalNumberValue      (this.invert,    parse);           if (   op             && op.isValid())         {             op.value    = Math.min(Math.max(0, Math.round(op.value)), y1291.length-1);             op.decimals = 0;         }           if (   input             && op)         {             if (this.options.enabled)             {                 if (l955(input.type))                 {                     this.value = new x1834();                      for (let i = 0; i < input.items.length; i++)                     {                         const item = input.items[i];                          this.value.items.push(                             item.type == e1090                             ? s3597(item, operand, op, invert, this.options.enabled)                             : n1835.NaN());                        }                 }                 else                 {                     this.value = s3597(input, operand, op, invert, this.options.enabled);                 }             }             else                 this.value = input.copy();         }         else             this.value = n1835.NaN();           this.h3980(parse,         [             ['type',      this.outputType()],             ['operation', op               ],             ['operand',   operand          ],             ['invert',    invert           ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.operation && this.operation.isValid()             && this.operand   && this.operand  .isValid()             && this.invert    && this.invert   .isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.operation) this.operation.o3967(parse);         if (this.operand  ) this.operand  .o3967(parse);         if (this.invert   ) this.invert   .o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.operation) this.operation.y3968(parse, from, force);         if (this.operand  ) this.operand  .y3968(parse, from, force);         if (this.invert   ) this.invert   .y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.operation) this.operation.l3966(parse);         if (this.operand  ) this.operand  .l3966(parse);         if (this.invert   ) this.invert   .l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const smath = new j1718(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(smath, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, smath);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             smath.input = t1607(parse);              smath.operation = t1607(parse);         smath.operand   = t1607(parse);         smath.invert    = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, smath);         return smath;     } }    function s3597(input, operand, op, invert, enabled) {     r950(         input.type == e1090,          'input.type is ' + input.type + ', must be NUMBER_VALUE');       if (enabled)     {         op.value = Math.min(Math.max(0, Math.floor(op.value)), y1291.length-1);           const t3596 = Math.max(input.decimals, operand.decimals);          let value;                   switch (op.value)         {             case 0:                  value = new n1835(                     invert.value == 0                         ? input.x3604() % operand.x3604()                         : operand.x3604() % input.x3604());                 break;              case 1:                  if (      operand.value == 0                        && invert .value == 0                     ||    input  .value == 0                        && invert .value == 1)                     value = n1835.NaN();                 else                     value = new n1835(                         invert.value == 0                             ? input.x3604() / operand.x3604()                             : operand.x3604() / input.x3604());                 break;              case 2:                  value = new n1835(                     invert.value == 0                         ? input.x3604() - operand.x3604()                         : operand.x3604() - input.x3604());                 break;              case 3:                  value = new n1835(                     invert.value == 0                         ? input.x3604() + operand.x3604()                         : operand.x3604() + input.x3604());                 break;              case 4:                  value = new n1835(                     invert.value == 0                         ? input.x3604() * operand.x3604()                         : operand.x3604() * input.x3604());                 break;              case 5:                  value = new n1835(                     invert.value == 0                         ? Math.pow(input.x3604(), operand.x3604())                         : Math.pow(operand.x3604(), input.x3604()));                 break;              default:                 s951('invalid math operation');         }           value.decimals = Math.max(value.decimals, t3596);          return value;     }     else         return input; }


class m1721 extends q1712 {     static { d1855.types[e1114] = this; }        operation;        constructor(nodeId, options)     {         super(e1114, nodeId, options);     }        reset()     {         super.reset();          this.operation = null;     }           copy()     {         const copy = new m1721(this.nodeId, this.options);          copy.m3266(this);          copy.inputs    = this.inputs.map(i => i.copy());          if (this.operation) copy.operation = this.operation.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           let op = await evalNumberValue(this.operation, parse);          if (op) op = op.e3626();           op.value     =          op.p3686 = Math.min(Math.max(0, op.value), r1297.length-1);                   switch (op.value)         {             case o1293: this.value = await a3595(this.inputs, parse); break;             case t1294: this.value = await p3592 (this.inputs, parse); break;             case w1295:  this.value = await f3593  (this.inputs, parse); break;             case s1296: this.value = await b3594 (this.inputs, parse); break;         }                   this.h3980(parse,         [             ['operation', op]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.operation && this.operation.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.operation) this.operation.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.operation) this.operation.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.operation) this.operation.l3966(parse);     }        static parseRequest(parse)     {         const [type, nodeId, options, ignore] = genParseNodeStart(parse);                   const bool = new m1721(nodeId, options);                       let z4088 = 0;                  if (!ignore)             z4088 = parseInt(parse.move());                   if (parse.settings.logRequests)              x1937(bool, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, bool);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;              for (let i = 0; i < z4088; i++)             bool.inputs.push(t1607(parse));                   bool.operation = t1607(parse);                   parse.p3553--;                           genParseNodeEnd(parse, bool);         return bool;     } }


class p1725 extends y1857 {     static { d1855.types[o1115] = this; }        operation;     operand;        constructor(nodeId, options)     {         super(o1115, nodeId, options);     }            reset()     {         super.reset();          this.operation = null;         this.operand   = null;     }        copy()     {         const copy = new p1725(this.nodeId, this.options);          copy.m3266(this);          if (this.operation) copy.operation = this.operation.copy();         if (this.operand  ) copy.operand   = this.operand  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input   = await evalNumberOrListValue(this.input,     parse);         const op      = await evalNumberValue      (this.operation, parse);         const operand = await evalNumberValue      (this.operand,   parse);                   if (   input             && operand             && op)         {             op.value = Math.min(Math.max(0, op.value), f1304.length-1);              if (l955(input.type))             {                 this.value = new x1834();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == e1090                         ? await getCompareValue(item, operand, op)                         : n1835.NaN());                 }             }             else             {                 this.value = await getCompareValue(input, operand, op);             }         }         else             this.value = n1835.NaN();           this.h3980(parse,         [             ['type',      this.outputType()],             ['operation', op               ],             ['operand',   operand          ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.operation && this.operation.isValid()             && this.operand   && this.operand  .isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.operation) this.operation.o3967(parse);         if (this.operand  ) this.operand  .o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.operation) this.operation.y3968(parse, from, force);         if (this.operand  ) this.operand  .y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.operation) this.operation.l3966(parse);         if (this.operand  ) this.operand  .l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const cmp = new p1725(nodeId, options);                   let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(cmp, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, cmp);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             cmp.input = t1607(parse);                         cmp.operation = t1607(parse);         cmp.operand   = t1607(parse);                   parse.p3553--;                   genParseNodeEnd(parse, cmp);         return cmp;     } }    async function getCompareValue(input, operand, op) {     switch (op.value)     {         case e1298:              return await evalCompareNumberInputs(input, operand, ((a, b) => a <  b));         case q1299:     return await evalCompareNumberInputs(input, operand, ((a, b) => a <= b));         case u1300:         return await evalCompareNumberInputs(input, operand, ((a, b) => a != b));         case t1301:             return await evalCompareNumberInputs(input, operand, ((a, b) => a == b));         case k1302:  return await evalCompareNumberInputs(input, operand, ((a, b) => a >= b));         case p1303:           return await evalCompareNumberInputs(input, operand, ((a, b) => a >  b));     } }    async function evalCompareNumberInputs(input, operand, compare)  {     if (   input   && input  .isValid()          && operand && operand.isValid())     {         return new n1835(             compare(input.x3604(), operand.x3604()) ? 1 : 0,             0,             true);     }     else     {         return n1835.NaN();     } }


class GTrigonometric extends y1857 {     static { d1855.types[v1116] = this; }        function;        constructor(nodeId, options)     {         super(v1116, nodeId, options);     }            reset()     {         super.reset();          this.function = null;     }        copy()     {         const copy = new GTrigonometric(this.nodeId, this.options);          copy.m3266(this);          if (this.function) copy.function = this.function.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalNumberOrListValue(this.input,    parse);         const func  = await evalNumberValue      (this.function, parse);          func.value = Math.min(Math.max(0, func.value), u1311.length-1);                   if (input)         {             if (l955(input.type))             {                 this.value = new x1834();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == e1090                         ? await getTrigValue(item, func, this.options.enabled)                         : n1835.NaN());                    }             }             else                 this.value = await getTrigValue(input, func, this.options.enabled); }         else             this.value = n1835.NaN();           this.h3980(parse,         [             ['type',     this.outputType()],             ['function', func             ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.function && this.function.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.function) this.function.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.function) this.function.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.function) this.function.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);           const trig = new GTrigonometric(nodeId, options);           let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(trig, parse, ignore, z4088);           if (ignore)          {             genParseNodeEnd(parse, trig);             return parse.m4122.find(n => n.nodeId == nodeId);         }           parse.p3553++;           if (z4088 == 1)             trig.input = t1607(parse);          trig.function = t1607(parse);          parse.p3553--;           genParseNodeEnd(parse, trig);         return trig;     } }    async function getTrigValue(input, func, enabled) {     r950(         input.type == e1090,         'input.type must be NUMBER_VALUE');       if (!enabled)         return input;       switch (func.value)     {         case z1305:  return await x4115   (input, false);         case i1306:  return await g4116 (input, false);         case j1307:  return await r4117(input, false);         case q1308: return await x4115   (input, true );         case p1309: return await g4116 (input, true );         case c1310: return await r4117(input, true );     } }


class m1732 extends l1856 {     static { d1855.types[i1117] = this; }        x;     y;            constructor(nodeId, options)     {         super(i1117, nodeId, options);     }            reset()     {         super.reset();          this.x = null;         this.y = null;     }        copy()     {         const copy = new m1732(this.nodeId, this.options);          copy.m3266(this);          if (this.x) copy.x = this.x.copy();         if (this.y) copy.y = this.y.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const x = await evalNumberValue(this.x, parse);         const y = await evalNumberValue(this.y, parse);           this.value = new n1835(Math.atan2(y.value, x.value));           this.h3980(parse,         [                          ['x',     x         ],             ['y',     y         ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.x && this.x.isValid()             && this.y && this.y.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.x) this.x.o3967(parse);         if (this.y) this.y.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.x) this.x.y3968(parse, from, force);         if (this.y) this.y.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.x) this.x.l3966(parse);         if (this.y) this.y.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const atan2 = new m1732(nodeId, options);                          if (parse.settings.logRequests)              x1937(atan2, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, atan2);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   atan2.x = t1607(parse);         atan2.y = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, atan2);         return atan2;     } } 


class t1741 extends y1857 {     static { d1855.types[i1118] = this; }        from;        constructor(nodeId, options)     {         super(i1118, nodeId, options);     }            reset()     {         super.reset();          this.from = null;     }        copy()     {         const copy = new t1741(this.nodeId, this.options);          copy.m3266(this);          if (this.from) copy.from = this.from.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new n1835(0);                   const input = await evalNumberOrListValue(this.input, parse);         const from  = await evalNumberValue      (this.from,  parse);           if (input)         {             if (l955(input.type))             {                 this.value = new x1834();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == e1090                         ? getConvertAngleValue(item, from, this.options.enabled)                         : n1835.NaN());                    }             }             else                 this.value = getConvertAngleValue(input, from, this.options.enabled);         }         else             this.value = n1835.NaN();           this.h3980(parse,         [             ['type',  this.outputType()],                          ['from',  from             ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.from && this.from.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.from) this.from.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.from) this.from.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.from) this.from.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const convert = new t1741(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(convert, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, convert);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             convert.input = t1607(parse);              convert.from = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, convert);         return convert;     } }    function getConvertAngleValue(input, from, enabled) {     r950(          input == e1090,          'input must be NUMBER_VALUE');               const value = input;          if (enabled)     {         switch (from.value)         {             case 0: value.value = value.value/360 * Tau; break;             case 1: value.value = value.value/Tau * 360; break;         }          value.decimals = r1002(value.value);     }       return value; }


class v1805 extends y1857 {     static { d1855.types[b1124] = this; }        constructor(nodeId, options)     {         super(b1124, nodeId, options);     }        copy()     {         const copy = new v1805(this.nodeId, this.options);                  copy.m3266(this);          copy.value = this.value;                  return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           if (this.input)             this.value = await evalTextValue(this.input, parse);         else if (this.value)             await this.value.eval(parse);         else             this.value = new e1846();           this.h3980(parse,         [             ['value', this.value]         ]);                   this.validate();          return this;     }        isValid()     {         return   !this.input                && this.value != l961              || this.input.isValid();     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const text = new v1805(nodeId, options);                       if (parse.settings.logRequests)              x1937(text, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, text);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;         parse.f1608 = false;                   if (parse.next == q1123) text.value = t1607(parse);         else                          text.input = t1607(parse);                   parse.p3553--;                   genParseNodeEnd(parse, text);         return text;     } }


class s1813 extends y1857 {     static { d1855.types[b1125] = this; }        constructor(nodeId, options)     {         super(b1125, nodeId, options);     }            copy()     {         const copy = new s1813(this.nodeId, this.options);          copy.m3266(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalTextOrListValue(this.input, parse);          if (   input             && input.isValid())         {             if (l955(input.type))             {                 this.value = new x1834();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == q1123                         ? new n1835(item.value.length)                         : n1835.NaN());                 }             }             else                 this.value = new n1835(input.value.length);         }         else             this.value = n1835.NaN();               this.h3980(parse,         [             ['type', this.outputType()]         ]);           this.validate();          return this;     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const len = new s1813(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(len, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, len);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             len.input = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, len);         return len;     } } 


class n1820 extends y1857 {     static { d1855.types[y1126] = this; }        start = null;     end   = null;            constructor(nodeId, options)     {         super(y1126, nodeId, options);     }            reset()     {         super.reset();          this.start = null;         this.end   = null;     }        copy()     {         const copy = new n1820(this.nodeId, this.options);          copy.m3266(this);          if (this.start) copy.start = this.start.copy();         if (this.end  ) copy.end   = this.end  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const start = await evalTextValue(this.start, parse);         const end   = await evalTextValue(this.end,   parse);           if (this.input)         {             const input = await evalTextOrListValue(this.input, parse);                          if (l955(input.type))             {                 this.value = new x1834();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == q1123                         ? n1820.getEvalValue(item, start, end, this.options.enabled)                         : new e1846());                    }             }             else             {                 this.value = n1820.getEvalValue(input, start, end, this.options.enabled);             }         }         else             this.value = new e1846();           this.h3980(parse,         [             ['type',  this.outputType()],             ['start', start            ],             ['end',   end              ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.start && this.start.isValid()             && this.end   && this.end  .isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.start) this.start.o3967(parse);         if (this.end  ) this.end  .o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.start) this.start.y3968(parse, from, force);         if (this.end  ) this.end  .y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.start) this.start.l3966(parse);         if (this.end  ) this.end  .l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const trim = new n1820(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(trim, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, trim);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             trim.input = t1607(parse);              trim.start = t1607(parse);         trim.end   = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, trim);         return trim;     }        static getEvalValue(input, start, end, enabled)     {         r950(input.type == q1123, 'input.type must be TEXT_VALUE');                          const value = input.copy();          if (enabled)         {             if (start.value.length > 0) value.value = k952(value.value, n1470(start.value));             if (end  .value.length > 0) value.value = z953  (value.value, n1470(end  .value));         }          return value;     } }


class h1817 extends y1857 {     static { d1855.types[k1127] = this; }        start = null;     end   = null;            constructor(nodeId, options)     {         super(k1127, nodeId, options);     }            reset()     {         super.reset();          this.start = null;         this.end   = null;     }        copy()     {         const copy = new h1817(this.nodeId, this.options);          copy.m3266(this);          if (this.start) copy.start = this.start.copy();         if (this.end  ) copy.end   = this.end  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalTextOrListValue(this.input, parse);         const start = await evalNumberValue    (this.start, parse);         const end   = await evalNumberValue    (this.end,   parse);           let length     = 0;         let fullLength = 0;           if (   input             && start             && end)         {             if (l955(input.type))             {                 this.value = new x1834();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      const sub =                         item.type == q1123                         ? h1817.getEvalValue(item, start, end, this.options.enabled)                         : new e1846();                      length     = Math.max(length,     sub.value.length);                     fullLength = Math.max(fullLength, sub.value.length);                      this.value.items.push(sub);                 }              }             else             {                 this.value = h1817.getEvalValue(input, start, end, this.options.enabled);                                  length     = this .value.length;                 fullLength = input.value.length;             }         }         else             this.value = new e1846();           this.h3980(parse,         [             ['type',       this.outputType()          ],             ['length',     new n1835(length)    ],              ['fullLength', new n1835(fullLength)],              ['start',      start                      ],             ['end',        end                        ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.start && this.start.isValid()             && this.end   && this.end  .isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.start) this.start.o3967(parse);         if (this.end  ) this.end  .o3967(parse);     }        o3967(parse)     {         super.o3967(parse);          if (this.start) this.start.o3967(parse);         if (this.end  ) this.end  .o3967(parse);     }        l3966(parse, from)     {         super.l3966(parse, from);          if (this.start) this.start.l3966(parse, from);         if (this.end  ) this.end  .l3966(parse, from);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const sub = new h1817(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(sub, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, sub);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             sub.input = t1607(parse);              sub.start = t1607(parse);         sub.end   = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, sub);         return sub;     }        static getEvalValue(input, start, end, enabled)     {         let value = new e1846();           const _end =             end.isValid()             ? end             : new n1835(input.value.length);           if (enabled)         {             const endValue =                  _end.value < 0                 ? input.value.length + _end.value                 : _end.value;              if (start.value <= endValue)                 value.value = input.value.substring(start.value, endValue);             else                 value = new e1846();         }         else             value = input.copy();                   return value;     } }


class s1808 extends y1857 {     static { d1855.types[e1128] = this; }        what;        constructor(nodeId, options)     {         super(e1128, nodeId, options);     }            reset()     {         super.reset();          this.what = null;     }        copy()     {         const copy = new s1808(this.nodeId, this.options);          copy.m3266(this);          if (this.what = null) copy.what = this.what.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalTextOrListValue(this.input, parse);         const what  = await evalTextValue      (this.what,  parse);               if (input)         {             this.evalInputOrList(                 input,                  item => s1808.getEvalValue(item, what),                  i2435.NaN());         }         else             this.value = i2435.NaN();               this.h3980(parse,         [             ['type', this.outputType()],             ['what', what             ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.what && this.what.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.what) this.what.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.what) this.what.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.what) this.what.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const contains = new s1808(nodeId, options);                      let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 2, 'nInputs must be [0, 2]');         }                       if (parse.settings.logRequests)              x1937(contains, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, contains);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             contains.input = t1607(parse);              contains.what = t1607(parse);                         parse.p3553--;                   genParseNodeEnd(parse, contains);         return contains;     }        static getEvalValue(input, what)     {         return input.type == q1123             ? new i2435(                 what.value == ''                     ? false                     : input.value.includes(what.value))             : i2435.NaN();     } }


class h2420 extends e1858 {     static { d1855.types[TEXT_FIND] = this; }        first;     last;     all;        constructor(nodeId, options)     {         super(TEXT_FIND, nodeId, options);     }            reset()     {         super.reset();          this.first = null;         this.last  = null;         this.all   = null;     }        copy()     {         const copy = new h2420(this.nodeId, this.options);          copy.m3266(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const e3962 = await evalTextValue(this.e3962, parse);         const d3963 = await evalTextValue(this.d3963, parse);               if (   e3962 && e3962.isValid()              && d3963 && d3963.isValid())         {             const indices = [];             let   index   = 0;              if (d3963.value != '')             {                 while (index != -1)                  {                     index = e3962.value.indexOf(d3963.value, index);                      if (index != -1)                      {                         indices.push(index);                         index += 1;                     }                 }                                   this.value = new n1835(indices.length > 0 ? 1 : 0);                  this.first = indices.length > 0 ? new n1835(indices.at( 0)) : n1835.NaN();                 this.last  = indices.length > 0 ? new n1835(indices.at(-1)) : n1835.NaN();                  this.all   = new x1834();                  for (const index of indices)                     this.all.items.push(new n1835(index));             }             else             {                 this.value = new n1835(1);                  this.first = n1835.NaN();                 this.last  = n1835.NaN();                 this.all   =   x1834.NaN();             }         }         else                           {             this.value = n1835.NaN();             this.first = n1835.NaN();             this.last  = n1835.NaN();             this.all   =   x1834.NaN();         }               this.h3980(parse,         [             ['value', this.value],             ['first', this.first],             ['last',  this.last ],             ['all',   this.all  ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.first && this.first.isValid()             && this.last  && this.last .isValid()             && this.all   && this.all  .isValid();     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const find = new h2420(nodeId, options);                      let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 2, 'nInputs must be [0, 2]');         }                       if (parse.settings.logRequests)              x1937(find, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, find);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 2)         {             find.e3962 = t1607(parse);             find.d3963 = t1607(parse);         }         else if (z4088 == 1)         {             find.e3962 = t1607(parse);          }                         parse.p3553--;                   genParseNodeEnd(parse, find);         return find;     } } 


class m1806 extends y1857 {     static { d1855.types[g1129] = this; }        case;            constructor(nodeId, options)     {         super(g1129, nodeId, options);     }            reset()     {         super.reset();          this.case = null;     }        copy()     {         const copy = new m1806(this.nodeId, this.options);          copy.m3266(this);          if (this.case) copy.case = this.case.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalTextOrListValue(this.input, parse);         const l3565 = await evalNumberValue    (this.case,  parse);           if (input)         {             if (this.options.enabled)             {                 if (l955(input.type))                 {                     this.value = new x1834();                      for (let i = 0; i < input.items.length; i++)                     {                         const item = input.items[i];                          this.value.items.push(                             item.type == q1123                             ? m1806.getEvalValue(item, l3565)                             : new e1846());                        }                 }                 else                 {                     this.value = m1806.getEvalValue(input, l3565);                 }             }             else                 this.value = input.copy();         }         else             this.value = new e1846();           this.h3980(parse,         [                          ['type',   this.outputType()],             ['case',  l3565             ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.case && this.case.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.case) this.case.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.case) this.case.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.case) this.case.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const l3565 = new m1806(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(l3565, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, l3565);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             l3565.input = t1607(parse);              l3565.case = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, l3565);         return l3565;     }        static getEvalValue(input, l3565)     {         r950(input.type == q1123, 'input.type must be TEXT_VALUE');          const val   = input.value;         const value = new e1846();                   if (l3565.value == 0)              value.value = val.toLowerCase();          else if (l3565.value == 1)         {             if (val.length > 0) value.value += val.substring(0, 1).toUpperCase();             if (val.length > 1) value.value += val.substring(1)   .toLowerCase();         }          else if (l3565.value == 2)         {             let i = 0;             while (i < val.length)             {                 while (i < val.length                     && /\s/.test(val.charAt(i)))                     value.value += val.charAt(i++);                  if (i < val.length)                     value.value += val.charAt(i++).toUpperCase();                  while (i < val.length                     && !/\s/.test(val.charAt(i)))                     value.value += val.charAt(i++).toLowerCase();             }         }          else if (l3565.value == 3)              value.value = val.toUpperCase();           return value;     } }


class z1804 extends y1857 {     static { d1855.types[e1137] = this; }        base;     trim;     decimals;     thousands;            constructor(nodeId, options)     {         super(e1137, nodeId, options);     }            reset()     {         super.reset();          this.base      = null;         this.trim      = null;         this.decimals  = null;         this.thousands = null;     }        copy()     {         const copy = new z1804(this.nodeId, this.options);          copy.m3266(this);          if (this.base     ) copy.base      = this.base     .copy();         if (this.trim     ) copy.trim      = this.trim     .copy();         if (this.decimals ) copy.decimals  = this.decimals .copy();         if (this.thousands) copy.thousands = this.thousands.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input     = await evalNumberValue(this.input,     parse);         const base      = await evalNumberValue(this.base,      parse);         const trim      = await evalNumberValue(this.trim,      parse);         const decimals  = await evalTextValue  (this.decimals,  parse);         const thousands = await evalTextValue  (this.thousands, parse);           if (input)         {             if (l955(input.type))             {                 this.value = new x1834();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == e1090                         ? r3338(item, base, trim, decimals, thousands)                         : e1846.NaN());                    }             }             else             {                 this.value = r3338(input, base, trim, decimals, thousands);             }         }         else             this.value = e1846.NaN();           this.h3980(parse,         [             ['type',      this.outputType()],             ['base',      base             ],             ['trim',      trim             ],             ['decimals',  decimals         ],             ['thousands', thousands        ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.base      && this.base     .isValid()             && this.trim      && this.trim     .isValid()             && this.decimals  && this.decimals .isValid()             && this.thousands && this.thousands.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.base     ) this.base     .o3967(parse);         if (this.trim     ) this.trim     .o3967(parse);         if (this.decimals ) this.decimals .o3967(parse);         if (this.thousands) this.thousands.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.base     ) this.base     .y3968(parse, from, force);         if (this.trim     ) this.trim     .y3968(parse, from, force);         if (this.decimals ) this.decimals .y3968(parse, from, force);         if (this.thousands) this.thousands.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.base     ) this.base     .l3966(parse);         if (this.trim     ) this.trim     .l3966(parse);         if (this.decimals ) this.decimals .l3966(parse);         if (this.thousands) this.thousands.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const f3558 = new z1804(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(f3558, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, f3558);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             f3558.input = t1607(parse);              f3558.base      = t1607(parse);         f3558.trim      = t1607(parse);         f3558.decimals  = t1607(parse);         f3558.thousands = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, f3558);         return f3558;     } }    function r3338(input, base, trim, decimals, thousands) {     return input.isValid()          ? new e1846(s1004(               input.value,                (trim.value > 0 ? -1 : 1) * input.decimals,                base.value == 1,                decimals.value,                thousands.value))          : new e1846('?'); }


                                                                                                                                                                      


class w1802 extends y1857 {     static { d1855.types[g1138] = this; }        format;     normalize;     trimZeros;            constructor(nodeId, options)     {         super(g1138, nodeId, options);     }       reset()     {         super.reset();          this.format    = null;         this.normalize = null;         this.trimZeros = null;     }            copy()     {         const copy = new w1802(this.nodeId, this.options);          copy.m3266(this);          if (this.format   ) copy.format    = this.format   .copy();         if (this.normalize) copy.normalize = this.normalize.copy();         if (this.trimZeros) copy.trimZeros = this.trimZeros.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input     = await evalValue      (this.input,     parse);         const format    = await evalNumberValue(this.format,    parse);         const normalize = await evalNumberValue(this.normalize, parse);         const trimZeros = await evalNumberValue(this.trimZeros, parse);           if (input)         {             if (l955(input.type))             {                 this.value = new x1834();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                            item.type == s1148                         || item.type ==  m1158                         ? getColorToTextValue(item, format, normalize, trimZeros)                         : e1846.NaN());                    }             }             else             {                 this.value = getColorToTextValue(input, format, normalize, trimZeros);             }         }          else             this.value = e1846.NaN();           this.h3980(parse,         [             ['type',      this.outputType()],             ['format',    format           ],             ['normalize', normalize        ],             ['trimZeros', trimZeros        ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.format    && this.format   .isValid()             && this.normalize && this.normalize.isValid()             && this.trimZeros && this.trimZeros.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.format   ) this.format   .o3967(parse);         if (this.normalize) this.normalize.o3967(parse);         if (this.trimZeros) this.trimZeros.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.format   ) this.format   .y3968(parse, from, force);         if (this.normalize) this.normalize.y3968(parse, from, force);         if (this.trimZeros) this.trimZeros.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.format   ) this.format   .l3966(parse);         if (this.normalize) this.normalize.l3966(parse);         if (this.trimZeros) this.trimZeros.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const z3557 = new w1802(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(z3557, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, z3557);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             z3557.input = t1607(parse);              z3557.format    = t1607(parse);         z3557.normalize = t1607(parse);         z3557.trimZeros = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, z3557);         return z3557;     } }    function getColorToTextValue(input, format, normalize, trimZeros) {     if (   input.type != s1148         && input.type != m1158)         return new e1846();       let str = l961;       const fill =          input.type == s1148         ? new m1826(input)         : input;      const rgba = fill.l99();      let dec1 = fill.color.c1.decimals;     let dec2 = fill.color.c2.decimals;     let dec3 = fill.color.c3.decimals;     let dec4 = fill.opacity .decimals;           switch (format.value)     {         case 0:              str = e151(rgba);              if (input.type == m1158)                 str += z2452(rgba[3]);              break;          case 1:          {             if (normalize.value > 0)             {                 str =                              getColorValueToText(rgba[0], Math.max(dec1, 3), trimZeros.value > 0)                      + ' ' + getColorValueToText(rgba[1], Math.max(dec2, 3), trimZeros.value > 0)                      + ' ' + getColorValueToText(rgba[2], Math.max(dec3, 3), trimZeros.value > 0);                      if (input.type == m1158)                     str += ' ' + getColorValueToText(rgba[3], Math.max(dec4, 3), trimZeros.value > 0);             }             else             {                 str =                              getColorValueToText(rgba[0] * y4006[0], dec1, trimZeros.value > 0)                      + ' ' + getColorValueToText(rgba[1] * y4006[1], dec2, trimZeros.value > 0)                      + ' ' + getColorValueToText(rgba[2] * y4006[2], dec3, trimZeros.value > 0);                      if (input.type == m1158)                     str += ' ' + getColorValueToText(rgba[3] * 255, dec4, trimZeros.value > 0);             }              break;         }         case 2:          {             const hsl = m48(rgba);              if (normalize.value > 0)             {                 str =                              getColorValueToText(hsl[0], Math.max(dec1, 3), trimZeros.value > 0)                      + ' ' + getColorValueToText(hsl[1], Math.max(dec2, 3), trimZeros.value > 0)                      + ' ' + getColorValueToText(hsl[2], Math.max(dec3, 3), trimZeros.value > 0);                  if (input.type == m1158)                     str += ' ' + getColorValueToText(rgba[3], dec4, trimZeros.value > 0);             }             else             {                 str =                              getColorValueToText(hsl[0] * p4007[0], dec1, trimZeros.value > 0)                      + ' ' + getColorValueToText(hsl[1] * p4007[1], dec2, trimZeros.value > 0)                      + ' ' + getColorValueToText(hsl[2] * p4007[2], dec3, trimZeros.value > 0);                  if (input.type == m1158)                     str += ' ' + getColorValueToText(rgba[3] * 100, dec4, trimZeros.value > 0);             }              break;         }         case 3:          {             const hsv = j52(rgba);              if (normalize.value > 0)             {                 str =                              getColorValueToText(hsv[0], Math.max(dec1, 3), trimZeros.value > 0)                      + ' ' + getColorValueToText(hsv[1], Math.max(dec2, 3), trimZeros.value > 0)                      + ' ' + getColorValueToText(hsv[2], Math.max(dec3, 3), trimZeros.value > 0);                  if (input.type == m1158)                     str += ' ' + getColorValueToText(rgba[3], dec4, trimZeros.value > 0);             }             else             {                 str =                              getColorValueToText(hsv[0] * p4007[0], dec1, trimZeros.value > 0)                      + ' ' + getColorValueToText(hsv[1] * p4007[1], dec2, trimZeros.value > 0)                      + ' ' + getColorValueToText(hsv[2] * p4007[2], dec3, trimZeros.value > 0);                  if (input.type == m1158)                     str += ' ' + getColorValueToText(rgba[3] * 100, dec4, trimZeros.value > 0);             }              break;         }         case 4:          {             const hcl = o37(rgba);              if (normalize.value > 0)             {                 str =                              getColorValueToText(hcl[0], Math.max(dec1, 3), trimZeros.value > 0)                      + ' ' + getColorValueToText(hcl[1], Math.max(dec2, 3), trimZeros.value > 0)                      + ' ' + getColorValueToText(hcl[2], Math.max(dec3, 3), trimZeros.value > 0);                  if (input.type == m1158)                     str += ' ' + getColorValueToText(rgba[3], dec4, trimZeros.value > 0);             }             else             {                 str =                              getColorValueToText(hcl[0] * m4008[0], dec1, trimZeros.value > 0)                      + ' ' + getColorValueToText(hcl[1] * m4008[1], dec2, trimZeros.value > 0)                      + ' ' + getColorValueToText(hcl[2] * m4008[2], dec3, trimZeros.value > 0);                  if (input.type == m1158)                     str += ' ' + getColorValueToText(rgba[3] * 100, dec4, trimZeros.value > 0);             }              break;         }         case 5:          {             const hcl = f42(rgba);              if (normalize.value > 0)             {                 str =                              getColorValueToText(hcl[0], Math.max(dec1, 3), trimZeros.value > 0)                      + ' ' + getColorValueToText(hcl[1], Math.max(dec2, 3), trimZeros.value > 0)                      + ' ' + getColorValueToText(hcl[2], Math.max(dec3, 3), trimZeros.value > 0);                  if (input.type == m1158)                     str += ' ' + getColorValueToText(rgba[3], dec4, trimZeros.value > 0);             }             else             {                 str =                              getColorValueToText(hcl[0] * m4008[0], dec1, trimZeros.value > 0)                      + ' ' + getColorValueToText(hcl[1] * m4008[1], dec2, trimZeros.value > 0)                      + ' ' + getColorValueToText(hcl[2] * m4008[2], dec3, trimZeros.value > 0);                  if (input.type == m1158)                     str += ' ' + getColorValueToText(rgba[3] * 100, dec4, trimZeros.value > 0);             }              break;         }         case 6:          {             const hcl = q46(rgba);              if (normalize.value > 0)             {                 str =                              getColorValueToText(hcl[0], Math.max(dec1, 3), trimZeros.value > 0)                      + ' ' + getColorValueToText(hcl[1], Math.max(dec2, 3), trimZeros.value > 0)                      + ' ' + getColorValueToText(hcl[2], Math.max(dec3, 3), trimZeros.value > 0);                  if (input.type == m1158)                     str += ' ' + getColorValueToText(rgba[3], dec4, trimZeros.value > 0);             }             else             {                 str =                              getColorValueToText(hcl[0] * m4008[0], dec1, trimZeros.value > 0)                      + ' ' + getColorValueToText(hcl[1] * m4008[1], dec2, trimZeros.value > 0)                      + ' ' + getColorValueToText(hcl[2] * m4008[2], dec3, trimZeros.value > 0);                  if (input.type == m1158)                     str += ' ' + getColorValueToText(rgba[3] * 100, dec4, trimZeros.value > 0);             }              break;         }         case 7:          {             const hsv = g3863(rgba);              if (normalize.value > 0)             {                 str =                              getColorValueToText(hsv[0], Math.max(dec1, 3), trimZeros.value > 0)                      + ' ' + getColorValueToText(hsv[1], Math.max(dec2, 3), trimZeros.value > 0)                      + ' ' + getColorValueToText(hsv[2], Math.max(dec3, 3), trimZeros.value > 0);                  if (input.type == m1158)                     str += ' ' + getColorValueToText(rgba[3], dec4, trimZeros.value > 0);             }             else             {                 str =                              getColorValueToText(hsv[0] * f4009[0], dec1, trimZeros.value > 0)                      + ' ' + getColorValueToText(hsv[1] * f4009[1], dec2, trimZeros.value > 0)                      + ' ' + getColorValueToText(hsv[2] * f4009[2], dec3, trimZeros.value > 0);                  if (input.type == m1158)                     str += ' ' + getColorValueToText(rgba[3] * 100, dec4, trimZeros.value > 0);             }              break;         }         case 8:          {             const hsv = b55(rgba);              if (normalize.value > 0)             {                 str =                              getColorValueToText(hsv[0], Math.max(dec1, 3), trimZeros.value > 0)                      + ' ' + getColorValueToText(hsv[1], Math.max(dec2, 3), trimZeros.value > 0)                      + ' ' + getColorValueToText(hsv[2], Math.max(dec3, 3), trimZeros.value > 0);                  if (input.type == m1158)                     str += ' ' + getColorValueToText(rgba[3], dec4, trimZeros.value > 0);             }             else             {                 str =                              getColorValueToText(hsv[0] * f4009[0], dec1, trimZeros.value > 0)                      + ' ' + getColorValueToText(hsv[1] * f4009[1], dec2, trimZeros.value > 0)                      + ' ' + getColorValueToText(hsv[2] * f4009[2], dec3, trimZeros.value > 0);                  if (input.type == m1158)                     str += ' ' + getColorValueToText(rgba[3] * 100, dec4, trimZeros.value > 0);             }              break;         }         case 9:          {             const hsv = v3859(rgba);              if (normalize.value > 0)             {                 str =                              getColorValueToText(hsv[0], Math.max(dec1, 3), trimZeros.value > 0)                      + ' ' + getColorValueToText(hsv[1], Math.max(dec2, 3), trimZeros.value > 0)                      + ' ' + getColorValueToText(hsv[2], Math.max(dec3, 3), trimZeros.value > 0);                  if (input.type == m1158)                     str += ' ' + getColorValueToText(rgba[3], dec4, trimZeros.value > 0);             }             else             {                 str =                              getColorValueToText(hsv[0] * f4009[0], dec1, trimZeros.value > 0)                      + ' ' + getColorValueToText(hsv[1] * f4009[1], dec2, trimZeros.value > 0)                      + ' ' + getColorValueToText(hsv[2] * f4009[2], dec3, trimZeros.value > 0);                  if (input.type == m1158)                     str += ' ' + getColorValueToText(rgba[3] * 100, dec4, trimZeros.value > 0);             }              break;         }         case 10:          {             const xyz = n69(rgba);              if (normalize.value > 0)             {                 str =                              getColorValueToText(xyz[0], Math.max(dec1, 3), trimZeros.value > 0)                      + ' ' + getColorValueToText(xyz[1], Math.max(dec2, 3), trimZeros.value > 0)                      + ' ' + getColorValueToText(xyz[2], Math.max(dec3, 3), trimZeros.value > 0);                  if (input.type == m1158)                     str += ' ' + getColorValueToText(rgba[3], dec4, trimZeros.value > 0);             }             else             {                 str =                              getColorValueToText(xyz[0] * xyzFactor[0], dec1, trimZeros.value > 0)                      + ' ' + getColorValueToText(xyz[1] * xyzFactor[1], dec2, trimZeros.value > 0)                      + ' ' + getColorValueToText(xyz[2] * xyzFactor[2], dec3, trimZeros.value > 0);                  if (input.type == m1158)                     str += ' ' + getColorValueToText(rgba[3] * 100, dec4, trimZeros.value > 0);             }              break;         }         case 11:          {             const xyz = n69(rgba, sRGB_D50);              if (normalize.value > 0)             {                 str =                              getColorValueToText(xyz[0], Math.max(dec1, 3), trimZeros.value > 0)                      + ' ' + getColorValueToText(xyz[1], Math.max(dec2, 3), trimZeros.value > 0)                      + ' ' + getColorValueToText(xyz[2], Math.max(dec3, 3), trimZeros.value > 0);                  if (input.type == m1158)                     str += ' ' + getColorValueToText(rgba[3], dec4, trimZeros.value > 0);             }             else             {                 str =                              getColorValueToText(xyz[0] * xyzFactor[0], dec1, trimZeros.value > 0)                      + ' ' + getColorValueToText(xyz[1] * xyzFactor[1], dec2, trimZeros.value > 0)                      + ' ' + getColorValueToText(xyz[2] * xyzFactor[2], dec3, trimZeros.value > 0);                  if (input.type == m1158)                     str += ' ' + getColorValueToText(rgba[3] * 100, dec4, trimZeros.value > 0);             }              break;         }         case 12:          {             const xyz = n69(rgba, sRGB_D65);              if (normalize.value > 0)             {                 str =                              getColorValueToText(xyz[0], Math.max(dec1, 3), trimZeros.value > 0)                      + ' ' + getColorValueToText(xyz[1], Math.max(dec2, 3), trimZeros.value > 0)                      + ' ' + getColorValueToText(xyz[2], Math.max(dec3, 3), trimZeros.value > 0);                  if (input.type == m1158)                     str += ' ' + getColorValueToText(rgba[3], dec4, trimZeros.value > 0);             }             else             {                 str =                              getColorValueToText(xyz[0] * xyzFactor[0], dec1, trimZeros.value > 0)                      + ' ' + getColorValueToText(xyz[1] * xyzFactor[1], dec2, trimZeros.value > 0)                      + ' ' + getColorValueToText(xyz[2] * xyzFactor[2], dec3, trimZeros.value > 0);                  if (input.type == m1158)                     str += ' ' + getColorValueToText(rgba[3] * 100, dec4, trimZeros.value > 0);             }              break;         }         case 13:              str = createColorName(rgba);             break;     }      return new e1846(str); }    function getColorValueToText(val, dec, trimZeros) {     return s1004(val, (trimZeros ? -1 : 1) * dec); }


class GColorToCss extends y1857 {     static { d1855.types[COLOR_TO_CSS] = this; }        format;     percent;     trimZeros;            constructor(nodeId, options)     {         super(COLOR_TO_CSS, nodeId, options);     }       reset()     {         super.reset();          this.format    = null;         this.percent   = null;         this.trimZeros = null;     }            copy()     {         const copy = new GColorToCss(this.nodeId, this.options);          copy.m3266(this);          if (this.format   ) copy.format    = this.format   .copy();         if (this.percent  ) copy.percent   = this.percent  .copy();         if (this.trimZeros) copy.trimZeros = this.trimZeros.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input     = await evalValue      (this.input,     parse);         const format    = await evalNumberValue(this.format,    parse);         const percent   = await evalNumberValue(this.percent,   parse);         const trimZeros = await evalNumberValue(this.trimZeros, parse);           if (input)         {             if (l955(input.type))             {                 this.value = new x1834();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                            item.type == s1148                         || item.type ==  m1158                         ? getColorToCssValue(item, format, percent, trimZeros)                         : e1846.NaN());                    }             }             else             {                 this.value = getColorToCssValue(input, format, percent, trimZeros);             }         }          else             this.value = e1846.NaN();           this.h3980(parse,         [             ['type',      this.outputType()],             ['format',    format           ],             ['percent',   percent          ],             ['trimZeros', trimZeros        ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.format    && this.format   .isValid()             && this.percent   && this.percent  .isValid()             && this.trimZeros && this.trimZeros.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.format   ) this.format   .o3967(parse);         if (this.percent  ) this.percent  .o3967(parse);         if (this.trimZeros) this.trimZeros.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.format   ) this.format   .y3968(parse, from, force);         if (this.percent  ) this.percent  .y3968(parse, from, force);         if (this.trimZeros) this.trimZeros.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.format   ) this.format   .l3966(parse);         if (this.percent  ) this.percent  .l3966(parse);         if (this.trimZeros) this.trimZeros.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const col2css = new GColorToCss(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(col2css, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, col2css);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             col2css.input = t1607(parse);              col2css.format    = t1607(parse);         col2css.percent   = t1607(parse);         col2css.trimZeros = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, col2css);         return col2css;     } }    function getColorToCssValue(input, format, percent, trimZeros) {     if (   input.type != s1148         && input.type != m1158)         return new e1846();       let str = l961;       const fill =          input.type == s1148         ? new m1826(input)         : input;      const rgba = fill.l99();      let dec1 = fill.color.c1.decimals;     let dec2 = fill.color.c2.decimals;     let dec3 = fill.color.c3.decimals;     let dec4 = fill.opacity .decimals;           switch (format.value)     {         case 0:              str = e151(rgba, true);              if (input.type == m1158)                 str += z2452(rgba[3]);              break;          case 1:              if (percent.value > 0)             {                 str =                      'rgb('                           + getColorValueToText(rgba[0] * 100, dec1, trimZeros.value > 0) + '%'                     + ' ' + getColorValueToText(rgba[1] * 100, dec2, trimZeros.value > 0) + '%'                     + ' ' + getColorValueToText(rgba[2] * 100, dec3, trimZeros.value > 0) + '%';                  if (input.type == m1158)                     str += ' / ' + getColorValueToText(rgba[3] * 100, dec4, trimZeros.value > 0) + '%';                      str += ')';             }             else             {                 str =                      'rgb('                           + getColorValueToText(rgba[0] * 255, dec1, trimZeros.value > 0)                     + ' ' + getColorValueToText(rgba[1] * 255, dec2, trimZeros.value > 0)                     + ' ' + getColorValueToText(rgba[2] * 255, dec3, trimZeros.value > 0);                  if (input.type == m1158)                     str += ' / ' + getColorValueToText(rgba[3], Math.max(dec4, 3), trimZeros.value > 0);                      str += ')';             }              break;          case 2:              const hsl = m48(rgba);              if (percent.value > 0)             {                 str =                      'hsl('                     +       getColorValueToText(hsl[0] * 360, dec1, trimZeros.value > 0) + 'deg'                     + ' ' + getColorValueToText(hsl[1] * 100, dec2, trimZeros.value > 0) + '%'                     + ' ' + getColorValueToText(hsl[2] * 100, dec3, trimZeros.value > 0) + '%';                  if (input.type == m1158)                     str += ' / ' + getColorValueToText(rgba[3] * 100, dec4, trimZeros.value > 0) + '%';                      str += ')';             }             else             {                 str =                      'hsl('                     +       getColorValueToText(hsl[0] * 360, dec1, trimZeros.value > 0)                     + ' ' + getColorValueToText(hsl[1] * 100, dec2, trimZeros.value > 0)                     + ' ' + getColorValueToText(hsl[2] * 100, dec3, trimZeros.value > 0);                  if (input.type == m1158)                     str += ' / ' + getColorValueToText(rgba[3], Math.max(dec4, 3), trimZeros.value > 0);                      str += ')';             }              break;          case 3:              const hcl = o37(rgba);              if (percent.value > 0)             {                 str =                      'oklch('                     +       getColorValueToText(hcl[2]       * 100, dec1, trimZeros.value > 0) + '%'                     + ' ' + getColorValueToText(hcl[1] / 0.4 * 100, dec2, trimZeros.value > 0) + '%'                     + ' ' + getColorValueToText(hcl[0]       * 360, dec3, trimZeros.value > 0) + 'deg';                  if (input.type == m1158)                     str += ' / ' + getColorValueToText(rgba[3] * 100, dec4, trimZeros.value > 0) + '%';                  str += ')';             }             else             {                 str =                      'oklch('                     +       getColorValueToText(hcl[2],       Math.max(dec1, 3), trimZeros.value > 0)                     + ' ' + getColorValueToText(hcl[1],       Math.max(dec2, 3), trimZeros.value > 0)                     + ' ' + getColorValueToText(hcl[0] * 360,          dec3,     trimZeros.value > 0);                  if (input.type == m1158)                     str += ' / ' + getColorValueToText(rgba[3], Math.max(dec4, 3), trimZeros.value > 0);                  str += ')';             }              break;          case 4:          {             const hcl = f42(rgba);              if (percent.value > 0)             {                 str =                      'lch('                     +       getColorValueToText(hcl[2]       * 100, dec1, trimZeros.value > 0) + '%'                     + ' ' + getColorValueToText(hcl[1] / 0.4 * 100, dec2, trimZeros.value > 0) + '%'                     + ' ' + getColorValueToText(hcl[0]       * 360, dec3, trimZeros.value > 0) + 'deg';                  if (input.type == m1158)                     str += ' / ' + getColorValueToText(rgba[3] * 100, dec4, trimZeros.value > 0) + '%';                  str += ')';             }             else             {                 str =                      'lch('                     +       getColorValueToText(hcl[2],       Math.max(dec1, 3), trimZeros.value > 0)                     + ' ' + getColorValueToText(hcl[1],       Math.max(dec2, 3), trimZeros.value > 0)                     + ' ' + getColorValueToText(hcl[0] * 360,          dec3,     trimZeros.value > 0);                  if (input.type == m1158)                     str += ' / ' + getColorValueToText(rgba[3], Math.max(dec4, 3), trimZeros.value > 0);                  str += ')';             }              break;         }         case 5:          {             const lab = g3863(rgba);              if (percent.value > 0)             {                 str =                      'oklab('                     +       getColorValueToText(lab[0]       * 100, dec1, trimZeros.value > 0) + '%'                     + ' ' + getColorValueToText(lab[1] / 0.4 * 100, dec2, trimZeros.value > 0) + '%'                     + ' ' + getColorValueToText(lab[2] / 0.4 * 100, dec3, trimZeros.value > 0) + '%';                  if (input.type == m1158)                     str += ' / ' + getColorValueToText(rgba[3] * 100, dec4, trimZeros.value > 0) + '%';                  str += ')';             }             else             {                 str =                      'oklab('                     +       getColorValueToText(lab[0], Math.max(dec1, 3), trimZeros.value > 0)                     + ' ' + getColorValueToText(lab[2], Math.max(dec3, 3), trimZeros.value > 0)                     + ' ' + getColorValueToText(lab[1], Math.max(dec2, 3), trimZeros.value > 0)                  if (input.type == m1158)                     str += ' / ' + getColorValueToText(rgba[3], Math.max(dec4, 3), trimZeros.value > 0);                  str += ')';             }              break;         }         case 6:          {             const lab = b55(rgba);              if (percent.value > 0)             {                 str =                      'lab('                     +       getColorValueToText(lab[0]       * 100, dec1, trimZeros.value > 0) + '%'                     + ' ' + getColorValueToText(lab[1] / 0.4 * 100, dec2, trimZeros.value > 0) + '%'                     + ' ' + getColorValueToText(lab[2] / 0.4 * 100, dec3, trimZeros.value > 0) + '%';                  if (input.type == m1158)                     str += ' / ' + getColorValueToText(rgba[3] * 100, dec4, trimZeros.value > 0) + '%';                  str += ')';             }             else             {                 str =                      'lab('                     +       getColorValueToText(lab[0], Math.max(dec1, 3), trimZeros.value > 0)                     + ' ' + getColorValueToText(lab[2], Math.max(dec3, 3), trimZeros.value > 0)                     + ' ' + getColorValueToText(lab[1], Math.max(dec2, 3), trimZeros.value > 0)                  if (input.type == m1158)                     str += ' / ' + getColorValueToText(rgba[3], Math.max(dec4, 3), trimZeros.value > 0);                  str += ')';             }                  break;         }         case 7:          {             let space,                  color;              const _space =                 input.type == m1158                 ? input.color.space                 : input.space;               switch (_space.value)             {                 case  0:                 case  1:                  case  2:                  case  3:                  case  9:                 case 10:                 case 11:                 case 12:                 case 13:                 case 14: space = 'srgb';         color =           rgba;  break;                  case  4: space = 'srgb-linear';  color = rgb2lin  (rgba); break;                 case  5: space = 'display-p3';   color = s61   (rgba); break;                 case  6: space = 'a98-rgb';      color = rgb2a98  (rgba); break;                 case  7: space = 'prophoto-rgb'; color = rgb2pro  (rgba); break;                 case  8: space = 'rec2020';      color = rgb2r2020(rgba); break;                  case 15: space = 'xyz';          color = n69  (rgba); break;                 case 16: space = 'xyz-d50';      color = n69  (rgba, sRGB_D50); break;                 case 17: space = 'xyz-d65';      color = n69  (rgba); break;             }               if (percent.value > 0)             {                 str =                      'color('                     +       space                     + ' ' + getColorValueToText(color[0] * 100, dec1, trimZeros.value > 0) + '%'                      + ' ' + getColorValueToText(color[1] * 100, dec2, trimZeros.value > 0) + '%'                      + ' ' + getColorValueToText(color[2] * 100, dec3, trimZeros.value > 0) + '%';                  if (input.type == m1158)                     str += ' / ' + getColorValueToText(rgba[3] * 100, dec4, trimZeros.value > 0) + '%';                  str += ')';             }             else             {                 str =                      'color('                     +       space                     + ' ' + getColorValueToText(color[0], Math.max(dec1, 3), trimZeros.value > 0)                      + ' ' + getColorValueToText(color[1], Math.max(dec3, 3), trimZeros.value > 0)                      + ' ' + getColorValueToText(color[2], Math.max(dec2, 3), trimZeros.value > 0);                  if (input.type == m1158)                     str += ' / ' + getColorValueToText(rgba[3], Math.max(dec4, 3), trimZeros.value > 0);                  str += ')';             }               break;         }         case 8:              str = getClosestHtmlName(rgba);             break;     }       return new e1846(str); }


class n1819 extends y1857 {     static { d1855.types[e1139] = this; }        base      = null;     decimals  = null;     thousands = null;            constructor(nodeId, options)     {         super(e1139, nodeId, options);     }            reset()     {         super.reset();          this.base      = null;         this.decimals  = null;         this.thousands = null;     }        copy()     {         const copy = new n1819(this.nodeId, this.options);          copy.m3266(this);          if (this.base     ) copy.base      = this.base     .copy();         if (this.decimals ) copy.decimals  = this.decimals .copy();         if (this.thousands) copy.thousands = this.thousands.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input     = await evalTextOrListValue(this.input,     parse);         const base      = await evalNumberValue    (this.base,      parse);         const decimals  = await evalTextValue      (this.decimals,  parse);         const thousands = await evalTextValue      (this.thousands, parse);           if (   input             && input.isValid())         {             if (l955(input.type))             {                 this.value = new x1834();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == q1123                         ? getTextToNumberValue(item, base, decimals, thousands)                         : n1835.NaN());                    }             }             else                 this.value = getTextToNumberValue(input, base, decimals, thousands);         }          else             this.value = n1835.NaN();           this.h3980(parse,         [             ['type',      this.outputType()],             ['base',      base             ],             ['decimals',  decimals         ],             ['thousands', thousands        ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.base      && this.base     .isValid()             && this.decimals  && this.decimals .isValid()             && this.thousands && this.thousands.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.base     ) this.base     .o3967(parse);         if (this.decimals ) this.decimals .o3967(parse);         if (this.thousands) this.thousands.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.base     ) this.base     .y3968(parse, from, force);         if (this.decimals ) this.decimals .y3968(parse, from, force);         if (this.thousands) this.thousands.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.base     ) this.base     .l3966(parse);         if (this.decimals ) this.decimals .l3966(parse);         if (this.thousands) this.thousands.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const y3556 = new n1819(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(y3556, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, y3556);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             y3556.input = t1607(parse);              y3556.base      = t1607(parse);         y3556.decimals  = t1607(parse);         y3556.thousands = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, y3556);         return y3556;     } }    function getTextToNumberValue(input, base, decimals, thousands) {     let num   = Number.NaN;     let value = input.value;      if (thousands)         value = value.replaceAll(thousands.value, '');           if (base)     {         switch (base.value)         {             case 0:              {                 if (value.lastIndexOf(decimals.value) > -1)                 {                     value = x1477(value, decimals.value, '.');                     num   = parseFloat(value);                 }                 else                     num = parseInt(value.replace(/[^\d-]/g, ''), 10);                          break;             }             case 1:              {                 const decIndex = value.lastIndexOf(decimals.value);                  if (decIndex < -1)                     num = parseInt(value, 16);                 else                 {                     const whole = value.slice(0, decIndex);                     const frac  = value.slice(decIndex + decimals.value.length);                      num =                            parseInt(whole, 16)                         + frac.split('')                             .reduce((sum, digit, index) => sum + parseInt(digit, 16) / Math.pow(16, index + 1), 0);                 }                  break;             }         }     }       return new n1835(num, r1002(num)); }


class g2423 extends y1857 {     static { d1855.types[TEXT_TO_BOOLEAN] = this; }        constructor(nodeId, options)     {         super(TEXT_TO_BOOLEAN, nodeId, options);     }            copy()     {         const copy = new g2423(this.nodeId, this.options);          copy.m3266(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalTextOrListValue(this.input, parse);           if (   input             && input.isValid())         {             if (l955(input.type))             {                 this.value = new x1834();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == q1123                         ? getTextToBooleanValue(item)                         : n1835.NaN());                    }             }             else                 this.value = getTextToBooleanValue(input);         }          else             this.value = n1835.NaN();           this.h3980(parse,         [             ['type', this.outputType()]         ]);           this.validate();          return this;     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const text2bool = new g2423(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(text2bool, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, text2bool);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             text2bool.input = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, text2bool);         return text2bool;     } }    function getTextToBooleanValue(input) {     if (stringIsNumber(input.value))          return new i2435(parseFloat(input.value) > 0);     else             {              if (input.value.trim().toLowerCase() == 'true' ) return new i2435(true);         else if (input.value.trim().toLowerCase() == 'false') return new i2435(false);         else                                                  return i2435.NaN();     } }


class e1818 extends y1857 {     static { d1855.types[c1140] = this; }        format;        constructor(nodeId, options)     {         super(c1140, nodeId, options);     }            reset()     {         super.reset();          this.format = null;     }            copy()     {         const copy = new e1818(this.nodeId, this.options);          copy.m3266(this);          if (this.format) copy.format = this.format.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalTextValue  (this.input, parse);         const format = await evalNumberValue(this.format, parse);                   if (input)         {             if (l955(input.type))             {                 this.value = new x1834();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == q1123                         ? getTextToColorValue(item.value.trim(), format)                         : n1835.NaN());                    }             }             else             {                 this.value = getTextToColorValue(input.value.trim(), format);             }         }          else             this.value = y1823.NaN();           this.h3980(parse,         [             ['value', this.value       ],             ['type',  this.outputType()],             ['format', format          ],         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.format && this.format.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.format) this.format.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.format) this.format.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.format) this.format.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const text2col = new e1818(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(text2col, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, text2col);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             text2col.input = t1607(parse);                   text2col.format = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, text2col);         return text2col;     } }    function getTextToColorValue(str, format) {     let rgb;        switch (format.value)     {         case 0:          {             rgb = a153(str);             break;         }         case 1:          {             const parts = str.split(',').map(s => s.trim());                      rgb =              [                 parseFloat(parts[0]),                 parseFloat(parts[1]),                 parseFloat(parts[2])             ];              break;         }         case 2:          {             const parts = str.split(',').map(s => s.trim());                      rgb =              [                 parseFloat(parts[0]) / 0xff,                 parseFloat(parts[1]) / 0xff,                 parseFloat(parts[2]) / 0xff             ];              break;         }         case 3:          {                        let webColor = g1479.find(wc => wc.name.toLowerCase() == str);             if (!webColor) webColor = g1479.find(wc => k1471(wc.name.toLowerCase(), str) <= 1);                          if (webColor)                 rgb = webColor.color;              break;         }         case 4:          {             const hsl = parseStructuredColorName(str);              if (hsl)                 rgb = z50(hsl);              break;         }     }           return rgb          ? y1823.i3670(v4021(rgb))          : y1823.NaN(); }


class w1801 extends y1857 {     static { d1855.types[r1134] = this; }        constructor(nodeId, options)     {         super(r1134, nodeId, options);     }            copy()     {         const copy = new w1801(this.nodeId, this.options);          copy.m3266(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalNumberValue(this.input, parse);           if (input)         {             if (l955(input.type))             {                 this.value = new x1834();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == e1090                         ? getCodeToCharacterValue(item)                         : e1846.NaN());                    }             }             else             {                 this.value = getCodeToCharacterValue(input);             }         }         else             this.value = e1846.NaN();           this.h3980(parse,         [                          ['type',  this.outputType()]         ]);           this.validate();          return this;     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const n3560 = new w1801(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(n3560, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, n3560);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             n3560.input = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, n3560);         return n3560;     } }    function getCodeToCharacterValue(input) {     return new e1846(String.fromCharCode(Math.min(Math.max(0, input.value), 0xffff))); }


class y1800 extends y1857 {     static { d1855.types[z1135] = this; }        constructor(nodeId, options)     {         super(z1135, nodeId, options);     }            copy()     {         const copy = new y1800(this.nodeId, this.options);          copy.m3266(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalTextValue(this.input, parse);           if (input)         {             if (l955(input.type))             {                 this.value = new x1834();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == q1123                         ? getCharacterToCodeValue(item)                         : n1835.NaN());                    }             }             else             {                 this.value = getCharacterToCodeValue(input);             }         }         else             this.value = n1835.NaN();           this.h3980(parse,         [                          ['type',  this.outputType()]         ]);           this.validate();          return this;     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const j3559 = new y1800(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(j3559, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, j3559);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             j3559.input = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, j3559);         return j3559;     } }    function getCharacterToCodeValue(input) {     return input.value.length > 0          ? new n1835(input.value.charCodeAt(0))          : n1835.NaN(); }


class g1803 extends l1856 {     static { d1855.types[q1136] = this; }        name;     index;            constructor(nodeId, options)     {         super(q1136, nodeId, options);     }            reset()     {         super.reset();          this.index = null;     }        copy()     {         const copy = new g1803(this.nodeId, this.options);          copy.m3266(this);          if (this.name ) copy.name  = this.name .copy();         if (this.index) copy.index = this.index.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const name  = await evalTextValue  (this.name,  parse);         const index = await evalNumberValue(this.index, parse);           switch (name.value)         {             case 0: this.value = new e1846(                 [                     'monday',                      'tuesday',                      'wednesday',                      'thursday',                      'friday',                      'saturday',                      'sunday'                 ]                  [index.value-1]);                  break;              case 1: this.value = new e1846(                 [                     'january',                      'february',                      'march',                      'april',                      'may',                      'june',                      'july',                     'august',                     'september',                     'october',                     'november',                     'december'                 ]                  [index.value-1]);                  break;              case 2:                 this.value = new e1846(n3920[index.value]);                 break;          }           this.h3980(parse,         [                          ['name',  name      ],             ['index', index     ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.index && this.index.isValid()             && this.name  && this.name .isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.index) this.index.o3967(parse);         if (this.name ) this.name .o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.index) this.index.y3968(parse, from, force);         if (this.name ) this.name .y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.index) this.index.l3966(parse);         if (this.name ) this.name .l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const index = new g1803(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(index, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, index);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   index.name  = t1607(parse);         index.index = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, index);         return index;     } } 


class h1815 extends y1857 {     static { d1855.types[y1130] = this; }        what  = null;     with  = null;     regex = null;        constructor(nodeId, options)     {         super(y1130, nodeId, options);     }            reset()     {         super.reset();          this.what  = null;         this.with  = null;         this.regex = null;     }        copy()     {         const copy = new h1815(this.nodeId, this.options);          copy.m3266(this);          if (this.what ) copy.what  = this.what .copy();         if (this.with ) copy.with  = this.with .copy();         if (this.regex) copy.regex = this.regex.copy();          if (this.value) copy.value = this.value.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const  input = await evalTextOrListValue(this.input, parse);         const _what  = await evalTextValue      (this.what,  parse);         const _with  = await evalTextValue      (this.with,  parse);         const _regex = await evalNumberValue    (this.regex, parse);           if (input)         {             if (this.options.enabled)             {                 if (l955(input.type))                 {                     this.value = new x1834();                      for (let i = 0; i < input.items.length; i++)                     {                         const item = input.items[i];                          this.value.items.push(                             item.type == q1123                             ? h1815.getEvalValue(item, _what, _with, _regex)                             : new e1846());                        }                 }                 else                 {                     this.value = h1815.getEvalValue(input, _what, _with, _regex);                 }             }             else                 this.value = input.copy();         }         else             this.value = new e1846();           this.h3980(parse,         [                          ['type',   this.outputType()],             ['what',  _what             ],             ['with',  _with             ],             ['regex', _regex            ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.what  && this.what .isValid()             && this.with  && this.with .isValid()             && this.regex && this.regex.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.what ) this.what .o3967(parse);         if (this.with ) this.with .o3967(parse);         if (this.regex) this.regex.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.what ) this.what .y3968(parse, from, force);         if (this.with ) this.with .y3968(parse, from, force);         if (this.regex) this.regex.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.what ) this.what .l3966(parse);         if (this.with ) this.with .l3966(parse);         if (this.regex) this.regex.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const replace = new h1815(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(replace, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, replace);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             replace.input = t1607(parse);              replace.what  = t1607(parse);         replace.with  = t1607(parse);         replace.regex = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, replace);         return replace;     }        static getEvalValue(input, _what, _with, _regex)     {         r950(input.type == q1123, 'input.type must be TEXT_VALUE');          const value = new e1846();                   if (_regex.value > 0)         {             try             {                 value.value = input.value.replace(                     new RegExp(unescapeRegexPattern(_what.value), 'gu'),                     unescapeRegexReplacement(_with.value));             }             catch (e)             {                 t3923(e.message, {error: true});             }         }         else if (input.value)         {             value.value = input.value.replaceAll(                 n1470(_what.value),                 n1470(_with.value));         }           return value;     } }


class b1812 extends l1856 {     static { d1855.types[s1131] = this; }        inputs = [];      with = null;            constructor(nodeId, options)     {         super(s1131, nodeId, options);     }        reset()     {         super.reset();          this.inputs = [];                  this.with = null;     }           copy()     {         const copy = new b1812(this.nodeId, this.options);         copy.m3266(this);                  copy.inputs = this.inputs.map(i => i.copy());         copy.with   = this.with;          return copy;     }        isCached()     {         for (const input of this.inputs)             if (!input.isCached())                 return false;          return super.isCached();     }        async eval(parse)     {         if (this.isCached())             return this;           const inputs = await Promise.all(this.inputs.map(async i => await evalTextOrListValue(i, parse)));         const _with  = await evalTextValue(this.with, parse);           this.value = await evalJoinInputs(inputs, _with, parse);                   this.h3980(parse,         [             ['type', this.outputType()],             ['with',  _with           ]         ]);           this.validate();          return this;     }        isValid()     {         return !this.inputs.find(i => !i.isValid())             && this.with && this.with.isValid();     }        o3967(parse)     {         super.o3967(parse);          this.inputs.forEach(i => i.o3967(parse));          if (this.with) this.with.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          this.inputs.forEach(i => i.y3968(parse, from, force));          if (this.with) this.with.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          this.inputs.forEach(i => i.l3966(parse));          if (this.with) this.with.l3966(parse);     }        static parseRequest(parse, p1604)     {         const [type, nodeId, options, ignore] = genParseNodeStart(parse);           const join = new b1812(nodeId, options);           let z4088 = 0;                  if (!ignore)             z4088 = parseInt(parse.move());           if (parse.settings.logRequests)              x1937(join, parse, ignore, z4088);           if (ignore)          {             genParseNodeEnd(parse, join);             return parse.m4122.find(n => n.nodeId == nodeId);         }           parse.p3553++;           for (let i = 0; i < z4088; i++)             join.inputs.push(t1607(parse));           join.with = t1607(parse);                   parse.p3553--;                       genParseNodeEnd(parse, join);         return join;     } }    async function evalJoinInputs(inputs, _with, parse) {     if (isEmpty(inputs))         return new e1846();       const allAreLists = allInputsAreCondensedLists(inputs);     const w           = n1470(_with.value);      if (allAreLists) return await evalJoinListInputs(inputs, w, parse);     else             return await evalJoinItemInputs(inputs, w, parse); }    async function evalJoinListInputs(inputs, _with, parse) {     const value = new x1834();           for (const input of inputs)     {         if (!input) continue;          console.assert(              l955(input.type),              `input is ${input.type}, must be a list`);          if (allInputsAreCondensedLists(input.items))             value.items.push(...(await evalJoinListInputs(input.items, _with, parse)).items);         else             value.items.push(await evalJoinItemInputs(input.items, _with, parse));     }       return value; }    async function evalJoinItemInputs(inputs, _with, parse) {     const value = new e1846();               for (let i = 0; i < inputs.length; i++)     {         const input = await evalTextOrListValue(inputs[i], parse);         if (!input) continue;           if (i > 0)             value.value += _with;           if (l955(input.type))         {             for (let j = 0; j < input.items.length; j++)             {                 if (j > 0)                     value.value += _with;                   const item = input.items[j];                  if (item.type == q1123)                     value.value += item.value;             }         }         else         {             r950(input.type == q1123, 'val.type must be TEXT_VALUE');              value.value += input.value;         }     }       return value; }


class GAddText extends y1857 {     static { d1855.types[TEXT_ADD] = this; }        text;     prefix;        constructor(nodeId, options)     {         super(TEXT_ADD, nodeId, options);     }            reset()     {         super.reset();          this.text   = null;         this.prefix = null;     }        copy()     {         const copy = new GAddText(this.nodeId, this.options);          copy.m3266(this);          if (this.text  ) copy.text   = this.text  .copy();         if (this.prefix) copy.prefix = this.prefix.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new n1835(0);           const input  = await evalTextOrListValue(this.input,  parse);         const text   = await evalTextValue      (this.text,   parse);         const prefix = await evalNumberValue    (this.prefix, parse);           if (input)         {             if (this.options.enabled)             {                 this.evalInputOrList(                     input,                      item => GAddText.getEvalValue(item, text, prefix),                      new e1846());             }             else                 this.value = input;         }         else             this.value = e1846.NaN();           this.h3980(parse,         [             ['type',   this.outputType()],             ['text',   text             ],             ['prefix', prefix           ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.text   && this.text  .isValid()             && this.prefix && this.prefix.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.text  ) this.text  .o3967(parse);         if (this.prefix) this.prefix.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.text  ) this.text  .y3968(parse, from, force);         if (this.prefix) this.prefix.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.text  ) this.text  .l3966(parse);         if (this.prefix) this.prefix.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const addText = new GAddText(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(addText, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, addText);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             addText.input = t1607(parse);              addText.text   = t1607(parse);         addText.prefix = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, addText);         return addText;     }             static getEvalValue(input, text, prefix)     {         const textValue = n1470(text.value);          return new e1846(             prefix.value > 0                 ? textValue + input.value                 : input.value + textValue);     } }


class o1814 extends y1857 {     static { d1855.types[a1132] = this; }        u3561   = null;     i3562 = null;     n3563     = null;     w3564   = null;                    constructor(nodeId, options)     {         super(a1132, nodeId, options);     }            reset()     {         super.reset();                  this.u3561   = null;         this.i3562 = null;         this.n3563     = null;         this.w3564   = null;     }        copy()     {         const copy = new o1814(this.nodeId, this.options);          copy.m3266(this);          if (this.u3561  ) copy.u3561   = this.u3561  .copy();         if (this.i3562) copy.i3562 = this.i3562.copy();         if (this.n3563    ) copy.n3563     = this.n3563    .copy();         if (this.w3564  ) copy.w3564   = this.w3564  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const u3561   = await evalTextValue  (this.u3561,   parse);         const i3562 = await evalNumberValue(this.i3562, parse);         const n3563     = await evalTextValue  (this.n3563,     parse);         const w3564   = await evalNumberValue(this.w3564,   parse);           if (this.input)         {             const input = await evalTextOrListValue(this.input, parse);                           if (l955(input.type))             {                 this.value = new x1834();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == q1123                         ? getPadValue(                             item,                              u3561,                              i3562,                              n3563,                              w3564,                              this.options.enabled)                         : new e1846());                    }             }             else             {                 this.value = getPadValue(                     input,                      u3561,                      i3562,                      n3563,                      w3564,                      this.options.enabled);             }         }         else             this.value = new e1846();           this.h3980(parse,         [             ['type',       this.outputType()],             ['startPad',   u3561         ],             ['startCount', i3562       ],             ['endPad',     n3563           ],             ['endCount',   w3564         ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.u3561   && this.u3561  .isValid()             && this.i3562 && this.i3562.isValid()             && this.n3563     && this.n3563    .isValid()             && this.w3564   && this.w3564  .isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.u3561  ) this.u3561  .o3967(parse);         if (this.i3562) this.i3562.o3967(parse);         if (this.n3563    ) this.n3563    .o3967(parse);         if (this.w3564  ) this.w3564  .o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.u3561  ) this.u3561  .y3968(parse, from, force);         if (this.i3562) this.i3562.y3968(parse, from, force);         if (this.n3563    ) this.n3563    .y3968(parse, from, force);         if (this.w3564  ) this.w3564  .y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.u3561  ) this.u3561  .l3966(parse);         if (this.i3562) this.i3562.l3966(parse);         if (this.n3563    ) this.n3563    .l3966(parse);         if (this.w3564  ) this.w3564  .l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const pad = new o1814(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(pad, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, pad);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             pad.input = t1607(parse);              pad.u3561   = t1607(parse);         pad.i3562 = t1607(parse);         pad.n3563     = t1607(parse);         pad.w3564   = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, pad);         return pad;     } }    function getPadValue(input, u3561, i3562, n3563, w3564, enabled) {     r950(input.type == q1123, 'input.type must be TEXT_VALUE');      const value = input.copy();          if (enabled)         value.value = input.value             .padStart(i3562.value, n1470(u3561.value))             .padEnd  (  w3564.value, n3563.value != '' ? n1470(n3563.value) : n1470(u3561.value));      return value; }


class c2410 extends y1857 {     static { d1855.types[TEXT_ESCAPE] = this; }        method;        constructor(nodeId, options)     {         super(TEXT_ESCAPE, nodeId, options);     }            reset()     {         super.reset();          this.method = null;     }        copy()     {         const copy = new c2410(this.nodeId, this.options);          copy.m3266(this);          if (this.method) copy.method = this.method.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalTextOrListValue(this.input,  parse);         const method = await evalNumberValue    (this.method, parse);           if (input)         {             if (this.options.enabled)             {                 if (l955(input.type))                 {                     this.value = new x1834();                      for (let i = 0; i < input.items.length; i++)                     {                         const item = input.items[i];                          this.value.items.push(                             item.type == q1123                             ? getTextEscapeValue(item, method)                             : new e1846());                        }                 }                 else                 {                     this.value = getTextEscapeValue(input, method);                 }             }             else                 this.value = input.copy();         }         else             this.value = new e1846();           this.h3980(parse,         [             ['type',   this.outputType()],             ['invert', method           ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.method && this.method.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.method) this.method.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.method) this.method.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.method) this.method.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const escape = new c2410(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(escape, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, escape);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             escape.input = t1607(parse);              escape.method = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, escape);         return escape;     } }    function getTextEscapeValue(input, method) {     r950(input.type == q1123, 'input.type must be TEXT_VALUE');      switch (method.value)     {         case 0: return new e1846(n1470(input.value));         case 1: return new e1846(decodeURIComponent(input.value));     }      r950(false, 'invalid escape method');     return input; }


class y2427 extends y1857 {     static { d1855.types[TEXT_UNESCAPE] = this; }        method;        constructor(nodeId, options)     {         super(TEXT_UNESCAPE, nodeId, options);     }            reset()     {         super.reset();          this.method = null;     }        copy()     {         const copy = new y2427(this.nodeId, this.options);          copy.m3266(this);          if (this.method) copy.method = this.method.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalTextOrListValue(this.input,  parse);         const method = await evalNumberValue    (this.method, parse);           if (input)         {             if (this.options.enabled)             {                 if (l955(input.type))                 {                     this.value = new x1834();                      for (let i = 0; i < input.items.length; i++)                     {                         const item = input.items[i];                          this.value.items.push(                             item.type == q1123                             ? getTextUnescapeValue(item, method)                             : new e1846());                        }                 }                 else                 {                     this.value = getTextUnescapeValue(input, method);                 }             }             else                 this.value = input.copy();         }         else             this.value = new e1846();           this.h3980(parse,         [             ['type',   this.outputType()],             ['invert', method           ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.method && this.method.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.method) this.method.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.method) this.method.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.method) this.method.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const unescape = new y2427(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(unescape, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, unescape);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             unescape.input = t1607(parse);              unescape.method = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, unescape);         return unescape;     } }    function getTextUnescapeValue(input, method) {     r950(input.type == q1123, 'input.type must be TEXT_VALUE');      switch (method.value)     {         case 0: return new e1846(unescapeString    (input.value));         case 1: return new e1846(encodeURIComponent(input.value));     }      r950(false, 'invalid escape method');     return input; }


class k1816 extends y1857 {     static { d1855.types[s1141] = this; }        separator;        constructor(nodeId, options)     {         super(s1141, nodeId, options);     }        reset()     {         super.reset();          this.separator = null;     }           copy()     {         const copy = new k1816(this.nodeId, this.options);          copy.m3266(this);          if (this.separator) copy.separator = this.separator.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input     = await evalTextOrListValue(this.input,     parse);         const separator = await evalTextValue      (this.separator, parse);           this.value = new x1834();           if (   input             && separator)         {             if (l955(input.type))             {                 for (const item of input.items)                 {                     const itemList = new x1834(                         item.value                             .split(n1470(separator.value))                             .map(s => new e1846(s)));                      this.value.items.push(itemList);                 }             }             else             {                 r950(input.type == q1123, 'input must be TEXT_VALUE');                  this.value.items = input.value                     .split(n1470(separator.value))                     .map(s => new e1846(s));             }         }           this.h3980(parse,         [             ['type',      this.outputType()],             ['separator', separator        ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.separator && this.separator.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.separator) this.separator.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.separator) this.separator.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.separator) this.separator.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const split = new k1816(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(split, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, split);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             split.input = t1607(parse);              split.separator = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, split);         return split;     } } 


class s1807 extends y1857 {     static { d1855.types[x1133] = this; }        operation;     operand;        constructor(nodeId, options)     {         super(x1133, nodeId, options);     }            reset()     {         super.reset();          this.operation = null;         this.operand   = null;     }        copy()     {         const copy = new s1807(this.nodeId, this.options);          copy.m3266(this);          if (this.operation) copy.operation = this.operation.copy();         if (this.operand  ) copy.operand   = this.operand  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input   = await evalTextOrListValue(this.input,     parse);         const op      = await evalNumberValue      (this.operation, parse);         const operand = await evalTextValue        (this.operand,   parse);                   if (   input             && op)         {             op.value = Math.min(Math.max(0, op.value), f1304.length-1);              if (l955(input.type))             {                 this.value = new x1834();                  for (const item of input.items)                 {                     this.value.items.push(                         item.type == q1123                         ? await evalCompareTextInputs(item, operand, op)                         : n1835.NaN());                 }             }             else             {                 this.value = await evalCompareTextInputs(input, operand, op);             }         }         else             this.value = n1835.NaN();           this.h3980(parse,         [             ['type',      this.outputType()],             ['operation', op               ],             ['operand',   operand          ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.operation && this.operation.isValid()             && this.operand   && this.operand  .isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.operation) this.operation.o3967(parse);         if (this.operand  ) this.operand  .o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.operation) this.operation.y3968(parse, from, force);         if (this.operand  ) this.operand  .y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.operation) this.operation.l3966(parse);         if (this.operand  ) this.operand  .l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);           const cmp = new s1807(nodeId, options);               let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(cmp, parse, ignore, z4088);           if (ignore)          {             genParseNodeEnd(parse, cmp);             return parse.m4122.find(n => n.nodeId == nodeId);         }           parse.p3553++;           if (z4088 == 1)             cmp.input = t1607(parse);                       cmp.operation = t1607(parse);         cmp.operand   = t1607(parse);                   parse.p3553--;           genParseNodeEnd(parse, cmp);         return cmp;     } }    async function evalCompareTextInputs(input, operand, op)  {     let opFunc = null;      switch (op.value)     {         case e1298:              opFunc = (a, b) => a <  b;  break;         case q1299:     opFunc = (a, b) => a <= b;  break;         case u1300:         opFunc = (a, b) => a != b;  break;         case t1301:             opFunc = (a, b) => a == b;  break;         case k1302:  opFunc = (a, b) => a >= b;  break;         case p1303:           opFunc = (a, b) => a >  b;  break;     }      if (   input   && input  .isValid()          && operand && operand.isValid())         return new n1835(opFunc(input.value, operand.value) ? 1 : 0, 0, true);     else                           return new p4096(); }


class w1809 extends y1857 {     static { d1855.types[p1143] = this; }        s3554;     g3555;        constructor(nodeId, options)     {         super(p1143, nodeId, options);     }            reset()     {         super.reset();          this.s3554    = null;         this.g3555 = null;     }        copy()     {         const copy = new w1809(this.nodeId, this.options);          copy.m3266(this);          if (this.s3554   ) copy.s3554    = this.s3554   .copy();         if (this.g3555) copy.g3555 = this.g3555.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const s3554    = await evalTextValue(this.s3554,    parse);         const g3555 = await evalTextValue(this.g3555, parse);           this.value = new x1834();           let maxColumns = 0;                   let nRows    = 0;         let nColumns = 0;           if (   this.input             && s3554             && g3555             && s3554.value != '')         {             const input = await evalTextValue(this.input, parse);                           const rows =                     input                 && input.value                             ? input.value.split(n1470(s3554.value))                 : [];               for (const _row of rows)             {                 const cells =                      _row                     ? _row.split(n1470(g3555.value))                     : [];                   const row = new x1834();                  for (const cell of cells)                     row.items.push(new e1846(cell));                  maxColumns = Math.max(maxColumns, row.items.length);                   this.value.items.push(row);             }               nRows    = this.value.items.length;             nColumns = maxColumns;         }               this.h3980(parse,         [             ['rowSeparator',    s3554             ],             ['columnSeparator', g3555          ],             ['rows',            new n1835(nRows   )],             ['columns',         new n1835(nColumns)]         ]);                   if (parse.settings.l3631)         {             this.h3980(parse,             [                 ['preview', new x1834(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.s3554    && this.s3554   .isValid()             && this.g3555 && this.g3555.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.s3554   ) this.s3554   .o3967(parse);         if (this.g3555) this.g3555.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.s3554   ) this.s3554   .y3968(parse, from, force);         if (this.g3555) this.g3555.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.s3554   ) this.s3554   .l3966(parse);         if (this.g3555) this.g3555.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const csv = new w1809(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(csv, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, csv);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             csv.input = t1607(parse);              csv.s3554    = t1607(parse);         csv.g3555 = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, csv);         return csv;     } } 


class t2426 extends y1857 {     static { d1855.types[s3412] = this; }        constructor(nodeId, options)     {         super(s3412, nodeId, options);     }            copy()     {         const copy = new t2426(this.nodeId, this.options);          copy.m3266(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new x1834();           if (this.input)         {             const input = await evalTextValue(this.input, parse);                          try             {                 const json = JSON.parse(input.value);                 this.value = this.evalItems(json);             }             catch (e)             {                 this.value = new x1834();             }         }               this.h3980(parse,         [             ['length',  new n1835(this.value.items.length)]                      ]);                   if (parse.settings.n3630)         {             this.h3980(parse,             [                 ['preview', this.value]             ],             true);         }           this.validate();          return this;     }        evalItems(json)     {         let list = new x1834();           for (const key in json)         {             if (   typeof json[key] === 'object'                 && json[key] !== null)             {                 const c111 = this.evalItems(json[key]);                 c111.valueId = key;                 list.items.push(c111);             }             else             {                 let value;                  if (   typeof json[key] === 'number'                     || t1467(json[key]))                     value = n1835.fromString(json[key].toString());                 else if (typeof json[key] === 'boolean')                     value = new n1835(d921(json[key].toString()) ? 1 : 0);                 else                     value = new e1846(json[key]);                                       value.valueId =                      key == 'value'                     ? '(value)'                      : key;                  list.items.push(value);             }         }                   return list;     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const json = new t2426(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(json, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, json);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             json.input = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, json);         return json;     } } 


class u2355 extends y1857 {     static { d1855.types[TO_JSON] = this; }        quoteValues = null;     snowNames   = null;     singleLine  = null;     whiteSpace  = null;        constructor(nodeId, options)     {         super(TO_JSON, nodeId, options);     }            reset()     {         super.reset();          this.quoteValues = null;         this.showNames   = null;         this.singleLine  = null;         this.whiteSpace  = null;     }        copy()     {         const copy = new u2355(this.nodeId, this.options);          copy.m3266(this);          if (this.quoteValues) copy.quoteValues = this.quoteValues.copy();         if (this.showNames  ) copy.showNames   = this.showNames  .copy();         if (this.singleLine ) copy.singleLine  = this.singleLine .copy();         if (this.whiteSpace ) copy.whiteSpace  = this.whiteSpace .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input       = await evalValue      (this.input,       parse);         const quoteValues = await evalNumberValue(this.quoteValues, parse);         const showNames   = await evalNumberValue(this.showNames,   parse);         const singleLine  = await evalNumberValue(this.singleLine,  parse);         const whiteSpace  = await evalNumberValue(this.whiteSpace,  parse);           if (input)         {             let json = '';                          json += input.toJsonText(             {                 tab:          0,                 named:        false,                 forceBraces:  false,                 lastExpanded: false,                 quoteValues:  quoteValues.value > 0,                 showNames:    showNames  .value > 0,                 singleLine:   singleLine .value > 0,                 whiteSpace:   whiteSpace .value > 0             });              this.value = new e1846(json);         }         else             this.value = new e1846('');           this.h3980(parse,         [             ['type',        this.outputType()],             ['quoteValues', quoteValues      ],             ['showNames',   showNames        ],             ['singleLine',  singleLine       ],             ['whiteSpace',  whiteSpace       ]         ]);           this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return this.quoteValues && this.quoteValues.isValid()             && this.showNames   && this.showNames  .isValid()             && this.singleLine  && this.singleLine .isValid()             && this.whiteSpace  && this.whiteSpace .isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.quoteValues) this.quoteValues.o3967(parse);         if (this.showNames  ) this.showNames  .o3967(parse);         if (this.singleLine ) this.singleLine .o3967(parse);         if (this.whiteSpace ) this.whiteSpace .o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.quoteValues) this.quoteValues.y3968(parse, from, force);         if (this.showNames  ) this.showNames  .y3968(parse, from, force);         if (this.singleLine ) this.singleLine .y3968(parse, from, force);         if (this.whiteSpace ) this.whiteSpace .y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.quoteValues) this.quoteValues.l3966(parse);         if (this.showNames  ) this.showNames  .l3966(parse);         if (this.singleLine ) this.singleLine .l3966(parse);         if (this.whiteSpace ) this.whiteSpace .l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const json = new u2355(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(json, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, json);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             json.input = t1607(parse);              json.quoteValues = t1607(parse);         json.showNames   = t1607(parse);         json.singleLine  = t1607(parse);         json.whiteSpace  = t1607(parse);                           parse.p3553--;                   genParseNodeEnd(parse, json);         return json;     } } 


class r1810 extends l1856 {     static { d1855.types[z1144] = this; }        request;     e4091;        constructor(nodeId, options)     {         super(z1144, nodeId, options);     }            reset()     {         super.reset();          this.request     = null;         this.e4091 = null;     }        copy()     {         const copy = new r1810(this.nodeId, this.options);          copy.m3266(this);          if (this.request    ) copy.request     = this.request    .copy();         if (this.e4091) copy.e4091 = this.e4091.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const request     = await evalTextValue(this.request,     parse);         const e4091 = await evalTextValue(this.e4091, parse);                   b1890(this.nodeId);           if (e4091.value == '')         {             try              {                 const response = await fetch(request.value);                 const content  = await response.text();                                  this.value = new e1846(content);             }             catch (e)             {                 this.value =                      request.value.trim() == NULL                     ? new e1846()                     : new e1846('invalid request');             }         }         else         {             this.value = this.e4091.copy();         }           this.h3980(parse,         [             ['value',   this.value],             ['request', request   ]         ]);                           if (parse.settings.n3630)         {             this.h3980(parse,             [                 ['preview', this.value]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return this.request && this.request.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.request) this.request.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.request) this.request.y3968(parse, from, force);          this.e4091 = new e1846();     }        l3966(parse)     {         super.l3966(parse);          if (this.request) this.request.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);           const fetch = new r1810(nodeId, options);               if (parse.settings.logRequests)              x1937(fetch, parse, ignore);           if (ignore)          {             genParseNodeEnd(parse, fetch);             return parse.m4122.find(n => n.nodeId == nodeId);         }           parse.p3553++;           fetch.request     = t1607(parse);         fetch.e4091 = t1607(parse);                   parse.p3553--;           genParseNodeEnd(parse, fetch);         return fetch;     } }


class g1811 extends l1856 {     static { d1855.types[i1145] = this; }                  e4091 = null;        constructor(nodeId, options)     {         super(i1145, nodeId, options);     }            reset()     {         super.reset();          this.e4091 = null;     }        copy()     {         const copy = new g1811(this.nodeId, this.options);          copy.m3266(this);          if (this.e4091) copy.e4091 = this.e4091.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const e4091 = await evalTextValue(this.e4091, parse);                          b1890(this.nodeId);           this.value = e4091 ?? new e1846();           this.h3980(parse,         [             ['', new p4096()]                      ]);                           if (parse.settings.n3630)         {             this.h3980(parse,             [                 ['preview', this.value]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return false;     }        o3967(parse)     {         super.o3967(parse);          if (this.path) this.path.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.path) this.path.y3968(parse, from, force);               }        l3966(parse)     {         super.l3966(parse);          if (this.path) this.path.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const file = new g1811(nodeId, options);                      if (parse.settings.logRequests)              x1937(file, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, file);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   file.e4091 = t1607(parse);                                parse.p3553--;                   genParseNodeEnd(parse, file);         return file;     } }


class n1609 {     name;      max;     value;          constructor(name = '', max = 0, value = 0)     {         this.name  = name;         this.max   = max;         this.value = value;     } }    async function m1610(parse,                               nodeId,                               color,                               order, t3585, p3586, k3587,                               b3610, z3611, o3612, v3613)  {     const refRgb = e4074(color);           let r1619 = [...color],         y3615   = null,          u1621 = order ? order.value : -1,         a1622     = -1,         l1623     = -1,         f1624     = -1;       let progress = 0,         total    = 6 * Math.pow(2, Tau);               const findSteps = 1024;          let d = 1;           parse.d3546 += findSteps;       dLoop:     while (d > 1/findSteps)     {         if (parse.z3547)             break dLoop;          let _closestColor = [...r1619];           for (let r3584 = 0; r3584 < 6; r3584++)         {             if (parse.z3547)                 break dLoop;              r1619 = [..._closestColor];              const [min1, min2, min3] = q1616(color[0], r3584);             const [max1, max2, max3] = a1617(color[0], r3584);              let start1 = t1033(min1, a1622, 1-d), d1625 = t1033(max1, a1622, 1-d),                 start2 = t1033(min2, l1623, 1-d), t1626 = t1033(max2, l1623, 1-d),                 start3 = t1033(min3, f1624, 1-d), m1627 = t1033(max3, f1624, 1-d);                                if (z3611) { a1622 = t3585.x3604(); start1 = a1622; d1625 = a1622+Epsilon; }             if (o3612) { l1623 = p3586.x3604(); start2 = l1623; t1626 = l1623+Epsilon; }             if (v3613) { f1624 = k3587.x3604(); start3 = f1624; m1627 = f1624+Epsilon; }                         [ r1619,             y3615,             u1621,             a1622,             l1623,             f1624,             progress ] = await findCorrectionInOrder(                 parse,                 nodeId,                 refRgb,                 r3584,                  b3610,                  z3611,  o3612,  v3613,                 a1622, l1623, f1624,                 start1,   start2,   start3,                  d1625,     t1626,     m1627,                 [...r1619],                 y3615,                  u1621,                 progress,                 total);         }           if (parse.z3547)             break;                   d /= 2;           parse.g3545++;           if (await n3744(parse.q1880))             break;     }       if (!parse.z3547)     {                   const y3615 = w1611(color, u1621, a1622, l1623, f1624)[1];          let c1 = a1622;         let c2 = l1623;         let c3 = f1624;          while (c1 >= 0 && n108(w1611(color, u1621, c1-1, l1623, f1624)[1], y3615)) c1--;         while (c2 >= 0 && n108(w1611(color, u1621, a1622, c2-1, f1624)[1], y3615)) c2--;         while (c3 >= 0 && n108(w1611(color, u1621, a1622, l1623, c3-1)[1], y3615)) c3--;          a1622 = Math.max(0, c1);         l1623 = Math.max(0, c2);         f1624 = Math.max(0, c3);     }           return [         u1621,         a1622,         l1623,         f1624 ]; }    async function findCorrectionInOrder(parse,                                      nodeId,                                      refRgb,                                      order,                                       b3610,                                       z3611,  o3612,  v3613,                                      a1622, l1623, f1624,                                      start1,   start2,   start3,                                       d1625,     t1626,     m1627,                                      r1619,                                      y3615,                                      u1621,                                      progress,                                      total) {     const color = [...r1619];          let d3616 = z3611 ? 1 : 2;     let v3617 = o3612 ? 1 : 2;     let v3618 = v3613 ? 1 : 2;       cLoop:     for (let m1 = start1; m1 < d1625; m1 += (d1625-start1)/d3616)     {         if (parse.z3547)             break cLoop;          for (let m2 = start2; m2 < t1626; m2 += (t1626-start2)/v3617)         {             if (parse.z3547)                 break cLoop;              for (let m3 = start3; m3 < m1627; m3 += (m1627-start3)/v3618)             {                 if (parse.z3547)                     break cLoop;                  const [m3107, t124] = w1611(color, order, m1, m2, m3);                  if (   p78(t124)                     && (  !y3615                         || deltaE(refRgb, t124) < deltaE(refRgb, y3615)))                 {                     r1619 = m3107;                     y3615   = t124;                                          if (!b3610)                         u1621 = order;                      a1622 = m1;                     l1623 = m2;                     f1624 = m3;                 }                  progress++;             }         }                   s1891(parse, nodeId, progress / total, false);     }           return [         r1619,         y3615,         u1621,         a1622,         l1623,         f1624,         progress ]; }    function w1611(color, order, m1, m2, m3) {     const m3107 = g1612(color, order, m1, m2, m3);     const rgb    = e4074(m3107);      return [m3107, rgb]; }    function g1612(color, order, c1, c2, c3) {     if (order < 0)         return color;       const [i1, i2, i3] = z1615(order);                                 color = i1613(color, i1, c1);     if (!z150(color)) color = i1613(color, i2, c2);     if (!z150(color)) color = i1613(color, i3, c3);                 let rgb = e4074(color);      if (p78(rgb))         rgb = p80(rgb);                   color = m4075(         e146(rgb),         color[0]);           return color; }    function i1613(color, c3619, margin) {     const factor = e4071(color[0]);      margin /= factor[c3619];       const x3624 = [...color];     const t2972 = color[c3619+1];      const d = 0.001;       let q3622  = t2972,          k3623 = t2972;      let w3620  = z150(color);     let  q3621 = w3620;       let e3625 = 1/d*2;       while (   !w3620            && ! q3621            && e3625-- > 0)     {         q3622  -= d;  w3620  = e1614(q3622 , c3619, x3624);          k3623 += d;   q3621 = e1614( k3623, c3619, x3624);     }       e3625 = 1/d*2;     color = [...x3624];       if (w3620)      {          w3620 = z150(color);         q3622     = t2972;          while (   !w3620                && margin > 0                && e3625-- > 0)         {             q3622 -= d;              w3620 = e1614(q3622, c3619, x3624);             margin -= Math.sign(margin) * d;         }          color[c3619+1] = q3622;     }     else if (q3621)     {          q3621 = z150(color);         k3623     = t2972;          while (   !q3621                && margin > 0                && e3625-- > 0)         {             k3623 += d;              q3621 = e1614(k3623, c3619, x3624);             margin -= Math.sign(margin) * d;         }          color[c3619+1] = k3623;     }       return color; }    function e1614(c, c3619, x3624) {     let color = [...x3624];     color[c3619+1] = c;      return z150(color); }    function z1615(order) {     switch (order)     {         case 0: return [0, 1, 2];         case 1: return [1, 0, 2];         case 2: return [1, 2, 0];         case 3: return [0, 2, 1];         case 4: return [2, 0, 1];         case 5: return [2, 1, 0];     }           s951('invalid correction order ' + order);     return [0, 0, 0]; }    function q1616(space, order) {     const [c1, c2, c3] = z1615(order);      let min;      switch (space)     {         case 'hex':         case 'rgb':   min = [0, 0, 0]; break;          case 'hsv':          case 'hsl':   min = [0, 0, 0]; break;          case 'hclok':         case 'hclab':         case 'hcluv': min = [0, 0, 0]; break;          case 'oklab':         case 'lab':         case 'luv':   min = [0, -f4009[1]/2, -f4009[2]/2]; break;                  default:                          s951('invalid validation order ' + order);             return [0, 0, 0];     }      return [min[c1], min[c2], min[c3]]; }    function a1617(space, order) {     const [c1, c2, c3] = z1615(order);      let max;      switch (space)     {         case 'hex':         case 'rgb':   max = [...y4006]; break;          case 'hsv':          case 'hsl':   max = [p4007[0]/2, p4007[1], p4007[2]]; break;          case 'hclok':         case 'hclab':         case 'hcluv': max = [m4008[0]/2, m4008[1], m4008[2]]; break;          case 'oklab':         case 'lab':         case 'luv':   max = [...f4009]; break;                  default:                          s951('invalid validation order ' + order);             return [0, 0, 0];     }      return [max[c1], max[c2], max[c3]]; }    function reorderCorrection(u1621,                            a1622, l1623, f1624,                            z3611,  o3612,  v3613) {     let c1 = { closest: a1622, locked: z3611 };     let c2 = { closest: l1623, locked: o3612 };     let c3 = { closest: f1624, locked: v3613 };      if (   c1.closest <  Epsilon         && c2.closest <  Epsilon         && c3.closest >= Epsilon)     {         switch (u1621)         {             case 0: u1621 = 4; break;             case 1: u1621 = 5; break;             case 2: u1621 = 0; break;             case 3: u1621 = 1; break;             case 4: u1621 = 2; break;             case 5: u1621 = 3; break;         }          const tmp = c2;         c1 = c3;         c2 = c1;         c3 = tmp;     }     else if (c1.closest >= Epsilon           && c2.closest <  Epsilon)     {         switch (u1621)         {             case 0: u1621 = 3; break;             case 1: u1621 = 2; break;             case 2: u1621 = 1; break;             case 3: u1621 = 0; break;             case 4: u1621 = 5; break;             case 5: u1621 = 4; break;         }          const tmp = c2;         c2 = c3;         c3 = tmp;     }     else if (c1.closest < Epsilon)     {         switch (u1621)         {             case 0: u1621 = 2; break;             case 1: u1621 = 3; break;             case 2: u1621 = 4; break;             case 3: u1621 = 5; break;             case 4: u1621 = 0; break;             case 5: u1621 = 1; break;         }          const tmp = c1;         c1 = c2;         c2 = c3;         c3 = tmp;     }       return [         u1621,         c1.closest, c2.closest, c3.closest,         c1.locked,  c2.locked,  c3.locked ]; }    function z1618(d133) {     switch (d133)     {     case 'hex':     case 'rgb':         return [             new n1609('R', y4006[0]),             new n1609('G', y4006[1]),             new n1609('B', y4006[2]) ];      case 'hsv':         return [             new n1609('H', p4007[0]/2),             new n1609('S', p4007[1]),             new n1609('B', p4007[2]) ];      case 'hsl':         return [             new n1609('H', p4007[0]/2),             new n1609('S', p4007[1]),             new n1609('L', p4007[2]) ];      case 'hclok':     case 'hclab':     case 'hcluv':         return [             new n1609('H', m4008[0]/2),             new n1609('C', m4008[1]),             new n1609('L', m4008[2]) ];      case 'oklab':      case 'lab':         return [             new n1609('L', f4009[0]),             new n1609('a', f4009[1]),             new n1609('b', f4009[2]) ];      case 'luv':         return [             new n1609('L', f4009[0]),             new n1609('u', f4009[1]),             new n1609('v', f4009[2]) ];     }       s951('invalid color space ' + d133);     return [         new n1609(),         new n1609(),         new n1609() ]; }


class t1628 extends y1857 {     static { d1855.types[j1149] = this; }        space   = null;         t3585      = null;    p3586      = null;    k3587      = null;          c1      = null;     c2      = null;     c3      = null;      convert = null;          y3173;        constructor(nodeId, options)     {         super(j1149, nodeId, options);     }                reset()     {         super.reset();                  this.space   = null;                  this.t3585     = null;         this.p3586     = null;         this.k3587     = null;                  this.c1      = null;         this.c2      = null;         this.c3      = null;              this.convert = null;     }        copy()     {         const copy = new t1628(this.nodeId, this.options);          copy.m3266(this);          copy.space = this.space.copy();          if (this.t3585) copy.t3585 = this.t3585.copy();         if (this.p3586) copy.p3586 = this.p3586.copy();         if (this.k3587) copy.k3587 = this.k3587.copy();          if (this. c1) copy. c1 = this. c1.copy();         if (this. c2) copy. c2 = this. c2.copy();         if (this. c3) copy. c3 = this. c3.copy();          if (this.convert)              copy.convert = this.convert.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalColorValue (this.input, parse);         let   space = await evalNumberValue(this.space, parse);          let   c1    = await evalNumberValue(this.t3585,   parse);         let   c2    = await evalNumberValue(this.p3586,   parse);         let   c3    = await evalNumberValue(this.k3587,   parse);          if (space) space = space.e3626();                   if (input)         {             if (   input.isValid()                 && input.type == s1148)             {                 if (this.options.enabled)                 {                     this.value        = input.copy();                     this.value.nodeId = this.nodeId;                      this.value.z3532(input);                                                   const fromSpaceIndex = input.space.value;                     const   toSpaceIndex = Math.min(Math.max(                         0,                         Math.round(space.value)),                          k131.length-1);                       if (toSpaceIndex != fromSpaceIndex)                     {                         this.convertColor(                             this.value,                             d133(fromSpaceIndex),                              d133(  toSpaceIndex));                          this.value.space.value = toSpaceIndex;                     }                      if (!c1) c1 = this.value.c1;                     if (!c2) c2 = this.value.c2;                     if (!c3) c3 = this.value.c3;                       if (c1) { this.value.c1 = c1; this.c1 = c1; }                     if (c2) { this.value.c2 = c2; this.c2 = c2; }                     if (c3) { this.value.c3 = c3; this.c3 = c3; }                 }                 else                     this.value = input.copy();             }             else                 this.value = y1823.NaN();                               if (!this.convert)                 this.convert = n1835.NaN();         }         else if (space               && c1               && c2               && c3)         {             this.value = new y1823(space, c1, c2, c3);               const toSpaceIndex = Math.min(Math.max(                 0,                 Math.round(this.value.space.value)),                  k131.length-1);              this.value.space.value = toSpaceIndex;               if (    this.convert                 &&  this.convert.isValid()                 &&  this.convert.value > -1                 &&  this.value.isValid()                 && !this.y3173)             {                 await this.convert.eval(parse);                  this.convertColor(                     this.value,                     d133(this.convert.value),                      d133(toSpaceIndex));             }         }         else             this.value = y1823.NaN();           if (this.value.space.isValid())         {             if (   this.value.space.value ==  2                 || this.value.space.value ==  3                 || this.value.space.value ==  9                 || this.value.space.value == 10                 || this.value.space.value == 11)             {                 while (this.value.c1.value <   0) this.value.c1.value += 360;                 while (this.value.c1.value > 360) this.value.c1.value -= 360;                  this.c1 = this.value.c1.copy();             }         }         else         {             this.value = new y1823(                 this.space ? this.space.toNewValue() : n1835.NaN(),                 n1835.NaN(),                 n1835.NaN(),                 n1835.NaN());         }                   if (this.convert) this.convert.parent = this;         if (this.space  ) this.space  .parent = this;         if (this.c1     ) this.c1     .parent = this;         if (this.c2     ) this.c2     .parent = this;         if (this.c3     ) this.c3     .parent = this;           if (this.value.isValid())             this.setValueDecorations();           this.h3980(parse,         [             ['value',   this.value      ],             ['convert', this.convert    ],             ['space',   this.value.space],             ['c1',      this.value.c1   ],             ['c2',      this.value.c2   ],             ['c3',      this.value.c3   ]         ]);           this.validate();          return this;     }        setValueDecorations()     {         const meta1 = NumberValueMeta.default();         const meta2 = NumberValueMeta.default();         const meta3 = NumberValueMeta.default();                   const space = d133(this.value.space.value);           switch (space)         {         case 'hex':            case 'rgb':         case 'lin':         case 'p3':         case 'a98':         case 'pro':         case 'r2020':             meta1.l800 = 0;             meta2.l800 = 0;             meta3.l800 = 0;              meta1.a801 = 255;             meta2.a801 = 255;             meta3.a801 = 255;              break;          case 'hsv':         case 'hsl':             meta1.suffix     = '°';              meta1.l800 = 0;             meta2.l800 = 0;             meta3.l800 = 0;              meta1.a801 = 360;             meta2.a801 = 100;             meta3.a801 = 100;              break;          case 'hclok':             meta1.suffix     = '°';              meta1.l800 = 0;             meta2.l800 = 0;             meta3.l800 = 0;              meta1.a801 = 360;             meta2.a801 =  50;             meta3.a801 = 100;              break;          case 'hclab':             meta1.suffix     = '°';              meta1.l800 = 0;             meta2.l800 = 0;             meta3.l800 = 0;              meta1.a801 = 360;             meta2.a801 = 400;             meta3.a801 = 100;              break;          case 'hcluv':             meta1.suffix     = '°';              meta1.l800 = 0;             meta2.l800 = 0;             meta3.l800 = 0;              meta1.a801 = 360;             meta2.a801 = 330;             meta3.a801 = 100;              break;          case 'oklab':             meta1.l800 =   0;             meta2.l800 = -30;             meta3.l800 = -30;              meta1.a801 = 100;             meta2.a801 =  30;             meta3.a801 =  30;              break;           case 'lab':             meta1.l800 =    0;             meta2.l800 = -100;             meta3.l800 = -100;              meta1.a801 =  100;             meta2.a801 =  100;             meta3.a801 =  100;              break;           case 'luv':             meta1.l800 =    0;             meta2.l800 = -150;             meta3.l800 = -150;              meta1.a801 =  100;             meta2.a801 =  150;             meta3.a801 =  150;              break;                       case 'xyz':         case 'xyz50':         case 'xyz65':             meta1.l800 = 0;             meta2.l800 = 0;             meta3.l800 = 0;              meta1.a801 = 100;             meta2.a801 = 100;             meta3.a801 = 100;              break;         }           this.value.c1.meta = meta1;         this.value.c2.meta = meta2;         this.value.c3.meta = meta3;     }        convertColor(color, fromSpace, k3114)     {         let col = [             fromSpace,              a4055(color.c1.value, fromSpace, 0),             a4055(color.c2.value, fromSpace, 1),             a4055(color.c3.value, fromSpace, 2) ];          col = r4066(m4075(col, k3114));          color.c1.value = col[1];         color.c2.value = col[2];         color.c3.value = col[3];     }        updateValueFromParam(i2902, value)     {              if (i2902 == 'c1') this.t3585 = value;         else if (i2902 == 'c2') this.p3586 = value;         else if (i2902 == 'c3') this.k3587 = value;         else              super.updateValueFromParam(i2902, value);     }        toNewValue()     {         return this.options.enabled              ? this.value.copy()              : y1823.NaN();     }        isValid()     {         return (!this.input || this.input.isValid())             && this.space && this.space.isValid()             && this.c1    && this.c1   .isValid()             && this.c2    && this.c2   .isValid()             && this.c3    && this.c3   .isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.space) this.space.o3967(parse);         if (this.t3585  ) this.t3585  .o3967(parse);         if (this.p3586  ) this.p3586  .o3967(parse);         if (this.k3587  ) this.k3587  .o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.space) this.space.y3968(parse, from, force);         if (this.t3585  ) this.t3585  .y3968(parse, from, force);         if (this.p3586  ) this.p3586  .y3968(parse, from, force);         if (this.k3587  ) this.k3587  .y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.space) this.space.l3966(parse);         if (this.t3585  ) this.t3585  .l3966(parse);         if (this.p3586  ) this.p3586  .l3966(parse);         if (this.k3587  ) this.k3587  .l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);           const col = new t1628(nodeId, options);          col.y3173 = options.y3173;                       let z4088 = -1;          if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 1, 'nInputs must be [0, 1]');         }           if (parse.settings.logRequests)              x1937(col, parse, ignore, z4088);           if (ignore)          {             genParseNodeEnd(parse, col);             return parse.m4122.find(n => n.nodeId == nodeId);         }           parse.p3553++;                   let r3000;          if (z4088 == 1)         {             col.input = t1607(parse);             r3000 = parse.move().split(',');         }         else             r3000 = ['space', 'convert', 'c1', 'c2', 'c3'];           parse.f1608 = false;                  for (const id of r3000)         {             switch (id)             {             case 'space':   col.space        = t1607(parse);  break;             case 'convert': col.convert      = t1607(parse);  break;             case 'c1':      col.t3585 = col.c1 = t1607(parse);  break;             case 'c2':      col.p3586 = col.c2 = t1607(parse);  break;             case 'c3':      col.k3587 = col.c3 = t1607(parse);  break;             }         }                   parse.p3553--;           genParseNodeEnd(parse, col);         return col;     } }


class a1635 extends y1857 {     static { d1855.types[o1150] = this; }                    method       = null;      corrections  = [];        constructor(nodeId, options)     {         super(o1150, nodeId, options);     }            reset()     {         super.reset();          this.method      = null;         this.corrections = [];     }        copy()     {         const copy = new a1635(this.nodeId, this.options);          copy.m3266(this);          if (this.value ) copy.value  = this.value .copy();         if (this.method) copy.method = this.method.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalColorValue (this.input,   parse);         const method = await evalNumberValue(this.method, parse);           if (input)         {             if (this.options.enabled)             {                 if (l955(input.type))                 {                     this.value = new x1834();                      for (let i = 0; i < input.items.length; i++)                         this.value.items.push(await u2715(parse, this, input.items[i], method));                 }                 else                     this.value = await u2715(parse, this, input, method);             }             else                 this.value = input.copy();         }         else             this.value = y1823.NaN();           method.meta = new NumberValueMeta();         method.meta.tooltipId = 'ttValidateMethod';                   this.h3980(parse,         [             ['value',  this.value       ],             ['type',   this.outputType()],             ['method', method           ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.method && this.method.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.method) this.method.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.method) this.method.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.method) this.method.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const valid = new a1635(nodeId, options);                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(valid, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, valid);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             valid.input = t1607(parse);                   valid.method = t1607(parse);         valid.value  = t1607(parse);                   parse.p3553--;                   genParseNodeEnd(parse, valid);         return valid;     } }    async function u2715(parse, node, input, method) {     let rgb = input.u3150();      if (method.value == 0)      {         rgb[0] = Math.round(Math.min(Math.max(0, rgb[0]), 1) * 0xff);            rgb[1] = Math.round(Math.min(Math.max(0, rgb[1]), 1) * 0xff);            rgb[2] = Math.round(Math.min(Math.max(0, rgb[2]), 1) * 0xff);                   return y1823.i3670(rgb);     }     else if (method.value == 1)      {         rgb = h129(rgb);          rgb[0] = Math.round(rgb[0] * 0xff);         rgb[1] = Math.round(rgb[1] * 0xff);         rgb[2] = Math.round(rgb[2] * 0xff);          return y1823.i3670(rgb);     }     else      {         const inputColor = input.t3149();          if (!p78(rgb))             b1890(node.nodeId);                   const       [ u1621,         a1622,         l1623,         f1624 ] = await m1610(             parse,             node.nodeId,             inputColor,             null,   null,  null,  null,             false,  false, false, false);                       if (!parse.z3547)         {             if (   u1621 >= 0                 && u1621 <  6)             {                 node.m3107 = g1612(                     inputColor,                     u1621,                     a1622,                     l1623,                     f1624);                  return y1823.v2716(node.m3107);             }             else             {                 return y1823.NaN();             }         }     }           return y1823.NaN(); }


class m1634 extends y1857 {     static { d1855.types[u1151] = this; }               r3584  = null;     t3585     = null;     p3586     = null;     k3587     = null;          order   = null;     c1      = null;     c2      = null;     c3      = null;      corrections = [];        constructor(nodeId, options)     {         super(u1151, nodeId, options);     }            reset()     {         super.reset();          this.r3584  = null;         this.t3585     = null;         this.p3586     = null;         this.k3587     = null;                  this.order   = null;         this.c1      = null;         this.c2      = null;         this.c3      = null;              this.corrections = [];     }        copy()     {         const copy = new m1634(this.nodeId, this.options);          copy.m3266(this);                  if (this.r3584) copy.r3584 = this.order .copy();         if (this.t3585   ) copy.t3585    = this.t3585   .copy();         if (this.p3586   ) copy.p3586    = this.p3586   .copy();         if (this.k3587   ) copy.k3587    = this.k3587   .copy();                  if (this. order) copy. order = this.order .copy();         if (this. c1   ) copy. c1    = this. c1   .copy();         if (this. c2   ) copy. c2    = this. c2   .copy();         if (this. c3   ) copy. c3    = this. c3   .copy();                  if (this.value ) copy. value = this. value.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           let   input = await evalColorValue (this. input, parse);         let   order = await evalNumberValue(this.r3584, parse);         let   c1    = await evalNumberValue(this.t3585,    parse);         let   c2    = await evalNumberValue(this.p3586,    parse);         let   c3    = await evalNumberValue(this.k3587,    parse);           if (order)          {             order       = order.e3626();             order.value = Math.min(Math.max(0, order.value), 5);         }           if (order && !order.isValid()) order = null;         if (c1    && !c1   .isValid()) c1    = null;         if (c2    && !c2   .isValid()) c2    = null;         if (c3    && !c3   .isValid()) c3    = null;           if (input)         {                  if (input.type == m1158      ) input = input.color;             else if (input.type == o1164) input = input.fill.color;             else if (input.type == d1167  ) input = y1823.i3670(input.l99());               if (this.options.enabled)             {                 const inputColor = input.t3149();                  if (!z150(inputColor))                     b1890(this.nodeId);                   const               [ u1621,                 a1622,                 l1623,                 f1624 ] = await m1610(                     parse,                     this.nodeId,                     inputColor,                      order, c1, c2, c3,                      order != null,                     c1    != null,                      c2    != null,                      c3    != null);                                       if (    !parse.z3547)                 {                     if (   u1621 >= 0                          && u1621 <  6)                     {                         this.m3107 = g1612(                             inputColor,                             u1621,                             a1622,                             l1623,                             f1624);                           this.order = new n1835(u1621);                         this.c1    = new n1835(a1622);                         this.c2    = new n1835(l1623);                         this.c3    = new n1835(f1624);                                                   this.value = y1823.v2716(this.m3107);                          this.value.c1.decimals = input.c1.decimals;                         this.value.c2.decimals = input.c2.decimals;                         this.value.c3.decimals = input.c3.decimals;                           this.h3980(parse,                         [                             ['order', new n1835(u1621, 0)],                             ['c1',    new n1835(a1622,     1)],                             ['c2',    new n1835(l1623,     1)],                             ['c3',    new n1835(f1624,     1)],                             ['value', this.value                      ]                         ]);                     }                     else                     {                         this.order = n1835.NaN();                         this.c1    = n1835.NaN();                         this.c2    = n1835.NaN();                         this.c3    = n1835.NaN();                         this.value = input.copy();                                  this.h3980(parse,                         [                             ['order', this.order],                             ['c1',    this.c1   ],                             ['c2',    this.c2   ],                             ['c3',    this.c3   ],                             ['value', this.value]                         ]);                     }                 }                 else                 {                     this.order = n1835.NaN();                     this.c1    = n1835.NaN();                     this.c2    = n1835.NaN();                     this.c3    = n1835.NaN();                     this.value = input.copy();                          this.h3980(parse,                     [                         ['order', this.order],                         ['c1',    this.c1   ],                         ['c2',    this.c2   ],                         ['c3',    this.c3   ],                         ['value', this.value]                     ]);                 }             }             else             {                 this.order = n1835.NaN();                 this.c1    = n1835.NaN();                 this.c2    = n1835.NaN();                 this.c3    = n1835.NaN();                 this.value = input.copy();                  this.h3980(parse,                 [                     ['order', this.order],                     ['c1',    this.c1   ],                     ['c2',    this.c2   ],                     ['c3',    this.c3   ],                     ['value', this.value]                 ]);             }         }         else         {             this.order = n1835.NaN();             this.c1    = n1835.NaN();             this.c2    = n1835.NaN();             this.c3    = n1835.NaN();             this.value = y1823 .NaN();              this.h3980(parse,             [                 ['order', n1835.NaN()],                 ['c1',    n1835.NaN()],                 ['c2',    n1835.NaN()],                 ['c3',    n1835.NaN()],                 ['value', y1823 .NaN()]             ]);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.order && this.order.isValid()             && this.c1    && this.c1   .isValid()             && this.c2    && this.c2   .isValid()             && this.c3    && this.c3   .isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.r3584) this.r3584.o3967(parse);         if (this.t3585   ) this.t3585   .o3967(parse);         if (this.p3586   ) this.p3586   .o3967(parse);         if (this.k3587   ) this.k3587   .o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.r3584) this.r3584.y3968(parse, from, force);         if (this.t3585   ) this.t3585   .y3968(parse, from, force);         if (this.p3586   ) this.p3586   .y3968(parse, from, force);         if (this.k3587   ) this.k3587   .y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.r3584) this.r3584.l3966(parse);         if (this.t3585   ) this.t3585   .l3966(parse);         if (this.p3586   ) this.p3586   .l3966(parse);         if (this.k3587   ) this.k3587   .l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const corr = new m1634(nodeId, options);              corr.y3173 = options.y3173;                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(corr, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, corr);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   let r3000;              if (z4088 == 1)             corr.input = t1607(parse);                   r3000 = parse.move().split(',');              parse.f1608 = false;                  for (const id of r3000)         {             switch (id)             {             case 'order':  corr.r3584 = corr.order = t1607(parse);  break;             case 'c1':     corr.t3585    = corr.c1    = t1607(parse);  break;             case 'c2':     corr.p3586    = corr.c2    = t1607(parse);  break;             case 'c3':     corr.k3587    = corr.c3    = t1607(parse);  break;             case 'value':  corr.value               = t1607(parse);  break;             }         }                                   parse.p3553--;                   genParseNodeEnd(parse, corr);         return corr;     } } 


class w1631 extends e1858 {     static { d1855.types[c1152] = this; }        standard = null;     contrast = null;        constructor(nodeId, options)     {         super(c1152, nodeId, options);     }        reset()     {         super.reset();          this.standard = null;         this.contrast = null;     }        copy()     {         const copy = new w1631(this.nodeId, this.options);          copy.m3266(this);          if (this.standard) copy.standard = this.standard.copy();         if (this.contrast) copy.contrast = this.contrast.copy();          return copy;     }            async eval(parse)     {         if (this.isCached())             return this;           const e3962    = await evalColorValue (this.e3962,   parse);         const d3963    = await evalColorValue (this.d3963,   parse);         const standard  = await evalNumberValue(this.standard, parse);                   if (standard.isValid())             standard.value = Math.min(Math.max(0, standard.value), 1);           if (   e3962 && e3962.type == s1148              && d3963 && d3963.type == s1148)         {             if (   e3962.isValid()                 && d3963.isValid())             {                 if (   j149(e3962.t3149())                     && j149(d3963.t3149()))                 {                     if (standard.value == 0)                     {                         const value = s157(e3962.u3150(), d3963.u3150());                         this.value = new n1835(value, 2);                     }                     else                     {                         const value = t161(e3962.u3150(), d3963.u3150());                         this.value = new n1835(value, 1);                     }                 }                 else                     this.value = n1835.NaN();             }             else                 this.value = n1835.NaN();               this.h3980(parse,             [                 ['text', e3962],                 ['back', d3963]             ]);         }          else if (e3962 && e3962.type == s1148)          {             this.h3980(parse,             [                 ['text', e3962.isValid() ? e3962 : y1823.NaN()],                 ['back', y1823.NaN()                            ]             ]);                          this.value = n1835.NaN();         }          else if (d3963 && d3963.type == s1148)          {             this.h3980(parse,             [                 ['text', y1823.NaN()                            ],                 ['back', d3963.isValid() ? d3963 : y1823.NaN()]             ]);              this.value = n1835.NaN();         }          else         {             this.value = n1835.NaN();              this.h3980(parse,             [                 ['text', y1823.NaN()],                 ['back', y1823.NaN()]             ]);         }                   if (this.value.isValid())             this.setValueDecorations(standard, parse);           this.h3980(parse,         [             ['type',     this.outputType()],             ['standard', standard         ]         ],         true);           this.validate();           return this;     }        setValueDecorations(standard, parse)     {         if (standard.value == 0)          {             let rating = i160(this.value.value);              if (rating != NULL)                 rating = '&nbsp;&nbsp;' + rating;               const cnt = Math.abs(this.value.value) / 21;              const is1 = cnt > 0  /21 && cnt <=  3  /21;             const is2 = cnt > 3  /21 && cnt <=  4.5/21;             const is3 = cnt > 4.5/21 && cnt <=  7  /21;                          const ranges =              [                  new a831(0  /21,  3  /21, is1 ? 'contrast20_vivid' : 'contrast20', 0.8),                 new a831(3  /21,  4.5/21, is2 ? 'contrast21_vivid' : 'contrast21', 0.8),                 new a831(4.5/21,  7  /21, is3 ? 'contrast22_vivid' : 'contrast22', 0.8),                 new a831(7  /21, 21  /21, 'transparent')              ];               this.value.meta = new NumberValueMeta(                 0, 0,                 21, 21,                 2,                 rating,                 ranges,                 false,                 parse.settings.showTooltipColorContrast ? 'ttWcag2' : NULL);         }         else          {             const cnt = Math.abs(this.value.value) / 100;              const is1 = cnt >=  0/100 && cnt <= 15/100;              const is2 = cnt >  15/100 && cnt <= 30/100;              const is3 = cnt >  30/100 && cnt <= 45/100;              const is4 = cnt >  45/100 && cnt <= 60/100;              const is5 = cnt >  60/100 && cnt <= 75/100;              const is6 = cnt >  75/100 && cnt <= 90/100;              const is7 = cnt >  90/100;                                const ranges =              [                  new a831( 0/105,  15/105, is1 ? 'contrast30_vivid' : 'contrast30', 0.8),                  new a831(15/105,  30/105, is2 ? 'contrast31_vivid' : 'contrast31', 0.8),                  new a831(30/105,  45/105, is3 ? 'contrast32_vivid' : 'contrast32', 0.8),                  new a831(45/105,  60/105, is4 ? 'contrast33_vivid' : 'contrast33', 0.8),                  new a831(60/105,  75/105, is5 ? 'contrast34_vivid' : 'contrast34', 0.8),                  new a831(75/105,  90/105, is6 ? 'contrast35_vivid' : 'contrast35', 0.8),                  new a831(90/105, 105/105, is7 ? 'contrast36_vivid' : 'contrast36', 0.8)               ];               this.value.meta = new NumberValueMeta(                -108, -105,                 106,  105,                 1,                 '<span style="font-size: 5; position: relative; top: -7px; left: 2px;">L</span><span style="font-size: 3; font-weight: bold; position: relative; top: -9px; left: 2px;">c</span>',                 ranges,                 true,                 parse.settings.showTooltipColorContrast ? 'ttWcag3' : NULL);         }     }        isValid()     {         return super.isValid()             && this.standard && this.standard.isValid()             && (!this.contrast || this.contrast.isValid());     }        o3967(parse)     {         super.o3967(parse);          if (this.standard) this.standard.o3967(parse);         if (this.contrast) this.contrast.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.standard) this.standard.y3968(parse, from, force);         if (this.contrast) this.contrast.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.standard) this.standard.l3966(parse);         if (this.contrast) this.contrast.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const cnt = new w1631(nodeId, options);                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 2, 'nInputs must be [0, 2]');         }                   const n3583 =              z4088 == 1             ? parseInt(parse.move())             : -1;                       if (parse.settings.logRequests)              p1943(cnt, z4088, n3583, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, cnt);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 2)         {             cnt.e3962 = t1607(parse);             cnt.d3963 = t1607(parse);         }         else if (z4088 == 1)         {                  if (n3583 == 0) cnt.e3962 = t1607(parse);              else if (n3583 == 1) cnt.d3963 = t1607(parse);          }                     cnt.standard = t1607(parse);                   parse.p3553--;                   genParseNodeEnd(parse, cnt);         return cnt;     } } 


class q2399 extends e1858 {     static { d1855.types[a1153] = this; }        deltaE = null;     space  = null;     d4048 = null;     g4049 = null;     p4050 = null;        constructor(nodeId, options)     {         super(a1153, nodeId, options);     }        reset()     {         super.reset();          this.deltaE = null;         this.space  = null;         this.d4048 = null;         this.g4049 = null;         this.p4050 = null;     }        copy()     {         const copy = new q2399(this.nodeId, this.options);          copy.m3266(this);          if (this.deltaE) copy.deltaE = this.deltaE.copy();         if (this.space ) copy.space  = this.space .copy();         if (this.d4048) copy.d4048 = this.d4048.copy();         if (this.g4049) copy.g4049 = this.g4049.copy();         if (this.p4050) copy.p4050 = this.p4050.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const e3962 = await evalColorValue(this.e3962, parse);         const d3963 = await evalColorValue(this.d3963, parse);         const deltaE = await evalColorValue(this.deltaE, parse);         const space  = await evalColorValue(this.space , parse);         const d4048 = await evalColorValue(this.d4048, parse);         const g4049 = await evalColorValue(this.g4049, parse);         const p4050 = await evalColorValue(this.p4050, parse);                   if (   e3962 && e3962.type == s1148              && d3963 && d3963.type == s1148)         {             if (   e3962.isValid()                 && d3963.isValid())             {                 let _rgb2lab, dE;                                  switch (space.value)                 {                     case 0: _rgb2lab = g3863; break;                     case 1: _rgb2lab = b55;   break;                 }                  switch (deltaE.value)                 {                     case 0:                          dE = deltaE76(                             e3962.u3150(),                              d3963.u3150(),                             _rgb2lab);                          break;                                              case 1:                          dE = deltaE94(                             e3962.u3150(),                              d3963.u3150(),                             d4048.value/100,                             g4049.value/100,                             p4050.value/100,                             _rgb2lab);                          break;                      case 2:                          dE = deltaE00(                             e3962.u3150(),                              d3963.u3150(),                             d4048.value/100,                             g4049.value/100,                             p4050.value/100,                             _rgb2lab);                          break;                      case 3:                          dE = deltaECMC(                             e3962.u3150(),                              d3963.u3150(),                             d4048.value/100,                             g4049.value/100,                             _rgb2lab);                          break;                      case 4:                          dE = deltaEITU(                             e3962.u3150(),                              d3963.u3150());                          break;                 }                  this.value = new n1835(dE * 100, 1);             }             else                 this.value = n1835.NaN();         }         else             this.value = n1835.NaN();                   this.h3980(parse,         [             ['type',   this.outputType()],             ['value',  this.value       ],             ['deltaE', deltaE           ],             ['space',  space            ],             ['param1', d4048           ],             ['param2', g4049           ],             ['param3', p4050           ]         ]);           this.validate();           return this;     }        isValid()     {         return super.isValid()             && this.deltaE && this.deltaE.isValid()             && this.space  && this.space .isValid()             && this.d4048 && this.d4048.isValid()             && this.g4049 && this.g4049.isValid()             && this.p4050 && this.p4050.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.deltaE) this.deltaE.o3967(parse);         if (this.space ) this.space .o3967(parse);         if (this.d4048) this.d4048.o3967(parse);         if (this.g4049) this.g4049.o3967(parse);         if (this.p4050) this.p4050.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.deltaE) this.deltaE.y3968(parse, from, force);         if (this.space ) this.space .y3968(parse, from, force);         if (this.d4048) this.d4048.y3968(parse, from, force);         if (this.g4049) this.g4049.y3968(parse, from, force);         if (this.p4050) this.p4050.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.deltaE) this.deltaE.l3966(parse);         if (this.space ) this.space .l3966(parse);         if (this.d4048) this.d4048.l3966(parse);         if (this.g4049) this.g4049.l3966(parse);         if (this.p4050) this.p4050.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const diff = new q2399(nodeId, options);                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 2, 'nInputs must be [0, 2]');         }                   const n3583 =              z4088 == 1             ? parseInt(parse.move())             : -1;                       if (parse.settings.logRequests)              p1943(diff, z4088, n3583, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, diff);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 2)         {             diff.e3962 = t1607(parse);             diff.d3963 = t1607(parse);         }         else if (z4088 == 1)         {                  if (n3583 == 0) diff.e3962 = t1607(parse);              else if (n3583 == 1) diff.d3963 = t1607(parse);          }                     diff.deltaE = t1607(parse);         diff.space  = t1607(parse);         diff.d4048 = t1607(parse);         diff.g4049 = t1607(parse);         diff.p4050 = t1607(parse);                   parse.p3553--;                   genParseNodeEnd(parse, diff);         return diff;     } } 


class l1630 extends y1857 {     static { d1855.types[t1154] = this; }        l;     m;     s;       constructor(nodeId, options)     {         super(t1154, nodeId, options);     }            reset()     {         super.reset();          this.l = null;         this.m = null;         this.s = null;     }        copy()     {         const copy = new l1630(this.nodeId, this.options);          copy.m3266(this);          if (this.l) copy.l = this.l.copy();         if (this.m) copy.m = this.m.copy();         if (this.s) copy.s = this.s.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           let   input = await evalColorValue (this.input, parse);         const l     = await evalNumberValue(this.l,     parse);          const m     = await evalNumberValue(this.m,     parse);         const s     = await evalNumberValue(this.s,     parse);           if (input)         {                  if (input.type == m1158      ) input = input.color;             else if (input.type == o1164) input = input.fill.color;             else if (input.type == d1167  ) input = y1823.i3670(input.l99());               if (this.options.enabled)             {                 if (l955(input.type))                 {                     this.value = new x1834();                      for (let i = 0; i < input.items.length; i++)                         this.value.items.push(getColorBlindValue(input.items[i], l, m, s));                 }                 else                     this.value = getColorBlindValue(input, l, m, s);             }             else                 this.value = input.copy();         }         else             this.value = y1823.NaN();           this.h3980(parse,         [             ['value',  this.value       ],             ['type',   this.outputType()],             ['l',      l                ],             ['m',      m                ],             ['s',      s                ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.l && this.l.isValid()             && this.m && this.m.isValid()             && this.s && this.s.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.l) this.l.o3967(parse);         if (this.m) this.m.o3967(parse);         if (this.s) this.s.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.l) this.l.y3968(parse, from, force);         if (this.m) this.m.y3968(parse, from, force);         if (this.s) this.s.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.l) this.l.l3966(parse);         if (this.m) this.m.l3966(parse);         if (this.s) this.s.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const cb = new l1630(nodeId, options);                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(cb, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, cb);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             cb.input = t1607(parse);              cb.l = t1607(parse);         cb.m = t1607(parse);         cb.s = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, cb);         return cb;     } }    function getColorBlindValue(input, l, m, s) {     const rgb   = input.u3150();      const rgbCb = j134(         rgb,         l.value,         m.value,         s.value);      if (   !q73(rgb  )         && !q73(rgbCb))     {         const validRgbCb = rgbCb;              const validCol = m4075(             e146(validRgbCb),              d133(input.space.value));          return y1823.v2716(validCol);     }     else         return y1823.NaN(); }


class z2394 extends y1857 {     static { d1855.types[COLOR_SCHEME] = this; }        schemeType = null;     space      = null;        constructor(nodeId, options)     {         super(COLOR_SCHEME, nodeId, options);     }            reset()     {         super.reset();          this.schemeType = null;         this.space      = null;     }        copy()     {         const copy = new z2394(this.nodeId, this.options);          copy.m3266(this);          if (this.value     ) copy.value      = this.value     .copy();         if (this.schemeType) copy.schemeType = this.schemeType.copy();         if (this.space     ) copy.space      = this.space     .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input      = await evalColorValue (this.input,      parse);         const schemeType = await evalNumberValue(this.schemeType, parse);         const space      = await evalNumberValue(this.space,      parse);           if (input)         {             if (this.options.enabled)             {                 this.value = new x1834();                   const rgb = input.u3150();                   let addHue;                  switch (space.value)                 {                     case 0: addHue = addHueHsl;   break;                     case 1: addHue = addHueHclok; break;                     case 2: addHue = addHueHclab; break;                     case 3: addHue = addHueHcluv; break;                 }                   function getColor(rgb)                 {                     const color = m4075(                         e146(rgb),                          d133(input.space.value));                      return y1823.v2716(color);                 }                    switch (schemeType.value)                 {                     case 0:                      {                         this.value.items.push(getColor(addHue(rgb, 10/12, 0, 1)));                         this.value.items.push(getColor(addHue(rgb,  0,    0, 1)));                         this.value.items.push(getColor(addHue(rgb,  2/12, 0, 1)));                         break;                     }                      case 1:                      {                         this.value.items.push(getColor(addHue(rgb, 11/12, 0, 1)));                         this.value.items.push(getColor(addHue(rgb,  0,    0, 1)));                         this.value.items.push(getColor(addHue(rgb,  1/12, 0, 1)));                         break;                     }                      case 2:                      {                         this.value.items.push(getColor(addHue(rgb, 11/12, 0, 1)));                         this.value.items.push(getColor(addHue(rgb,  0,    0, 1)));                         this.value.items.push(getColor(addHue(rgb,  1/12, 0, 1)));                         this.value.items.push(getColor(addHue(rgb,  6/12, 0, 1)));                         break;                     }                      case 3:                      {                         this.value.items.push(getColor(addHue(rgb,  0,    0, 1)));                         this.value.items.push(getColor(addHue(rgb,  6/12, 0, 1)));                         break;                     }                      case 4:                      {                         this.value.items.push(getColor(addHue(rgb,  0,    0, 1)));                         this.value.items.push(getColor(addHue(rgb,  5/12, 0, 1)));                         break;                     }                      case 5:                      {                         this.value.items.push(getColor(addHue(rgb,  0,    0, 1)));                         this.value.items.push(getColor(addHue(rgb,  7/12, 0, 1)));                         break;                     }                      case 6:                      {                         this.value.items.push(getColor(addHue(rgb,  0,    0, 1)));                         this.value.items.push(getColor(addHue(rgb,  5/12, 0, 1)));                         this.value.items.push(getColor(addHue(rgb,  7/12, 0, 1)));                         break;                     }                      case 7:                      {                         this.value.items.push(getColor(addHue(rgb,  0,    0, 1)));                         this.value.items.push(getColor(addHue(rgb,  4/12, 0, 1)));                         this.value.items.push(getColor(addHue(rgb,  8/12, 0, 1)));                         break;                     }                      case 8:                      {                         this.value.items.push(getColor(addHue(rgb,   0,    0, 1)));                         this.value.items.push(getColor(addHue(rgb,  11/12, 0, 1)));                         this.value.items.push(getColor(addHue(rgb,   6/12, 0, 1)));                         this.value.items.push(getColor(addHue(rgb,   5/12, 0, 1)));                         break;                     }                      case 9:                      {                         this.value.items.push(getColor(addHue(rgb,  0,    0, 1)));                         this.value.items.push(getColor(addHue(rgb, 10/12, 0, 1)));                         this.value.items.push(getColor(addHue(rgb,  6/12, 0, 1)));                         this.value.items.push(getColor(addHue(rgb,  4/12, 0, 1)));                         break;                     }                      case 10:                      {                         this.value.items.push(getColor(addHue(rgb,  0,    0, 1)));                         this.value.items.push(getColor(addHue(rgb,  2/12, 0, 1)));                         this.value.items.push(getColor(addHue(rgb,  6/12, 0, 1)));                         this.value.items.push(getColor(addHue(rgb,  8/12, 0, 1)));                         break;                     }                      case 11:                      {                         this.value.items.push(getColor(addHue(rgb,  0,    0, 1)));                         this.value.items.push(getColor(addHue(rgb,  1/12, 0, 1)));                         this.value.items.push(getColor(addHue(rgb,  6/12, 0, 1)));                         this.value.items.push(getColor(addHue(rgb,  7/12, 0, 1)));                         break;                     }                      case 12:                      {                         this.value.items.push(getColor(addHue(rgb,  0,    0, 1)));                         this.value.items.push(getColor(addHue(rgb,  3/12, 0, 1)));                         this.value.items.push(getColor(addHue(rgb,  6/12, 0, 1)));                         this.value.items.push(getColor(addHue(rgb,  9/12, 0, 1)));                         break;                     }                      case 13:                      {                         this.value.items.push(getColor(addHue(rgb,  0,    0, 1)));                         this.value.items.push(getColor(addHue(rgb,  2/12, 0, 1)));                         this.value.items.push(getColor(addHue(rgb,  4/12, 0, 1)));                         this.value.items.push(getColor(addHue(rgb,  6/12, 0, 1)));                         this.value.items.push(getColor(addHue(rgb,  8/12, 0, 1)));                         this.value.items.push(getColor(addHue(rgb, 10/12, 0, 1)));                         break;                     }                 }             }             else                 this.value = input.copy();         }         else             this.value = new x1834();           this.h3980(parse,         [             ['value',      this.value       ],             ['type',       this.outputType()],             ['schemeType', schemeType       ],             ['space',      space            ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.schemeType && this.schemeType.isValid()             && this.space      && this.space     .isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.schemeType) this.schemeType.o3967(parse);         if (this.space     ) this.space     .o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.schemeType) this.schemeType.y3968(parse, from, force);         if (this.space     ) this.space     .y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.schemeType) this.schemeType.l3966(parse);         if (this.space     ) this.space     .l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);           const scheme = new z2394(nodeId, options);           let z4088 = -1;          if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 1, 'nInputs must be [0, 1]');         }           if (parse.settings.logRequests)              x1937(scheme, parse, ignore, z4088);           if (ignore)          {             genParseNodeEnd(parse, scheme);             return parse.m4122.find(n => n.nodeId == nodeId);         }           parse.p3553++;           if (z4088 == 1)             scheme.input = t1607(parse);           scheme.schemeType = t1607(parse);         scheme.space      = t1607(parse);           parse.p3553--;           genParseNodeEnd(parse, scheme);         return scheme;     } } 


class a1632 extends l1856 {     static { d1855.types[g1155] = this; }        inputs = [];      space;     gamma;     amount;     degree;        constructor(nodeId, options)     {         super(g1155, nodeId, options);     }            reset()     {         super.reset();          this.inputs = [];          this.space  = null;         this.gamma  = null;         this.amount = null;         this.degree = null;     }        copy()     {         const copy = new a1632(this.nodeId, this.options);          copy.m3266(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.space ) copy.space  = this.space .copy();         if (this.gamma ) copy.gamma  = this.gamma .copy();         if (this.amount) copy.amount = this.amount.copy();         if (this.degree) copy.degree = this.degree.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           let   inputs = await Promise.all(this.inputs.map(async i => await evalColorStopValue(i, parse)));         let   space  = await evalNumberValue(this.space,  parse);         const gamma  = await evalNumberValue(this.gamma,  parse);         const amount = await evalNumberValue(this.amount, parse);         const degree = await evalNumberValue(this.degree, parse);          if (space) space = space.e3626();                   const _gamma = Math.max(0.0001, gamma.value);         const _space = d133(space.value);           let maxInputColorType = s1148;                  for (const input of inputs)         {             if (input.type == m1158)                 maxInputColorType = m1158;         }           inputs = m1640(inputs);          w1642(inputs);         inputs.sort((a, b) => a.position.value - b.position.value);            const opacities = inputs.map(i => i.fill.opacity);                   const nSegments = Math.floor(inputs.length-1);           let index = 0;          for (let i = 0; i < inputs.length-1; i++)         {             if (   amount.value/100 >= inputs[i  ].position.value/100                 && amount.value/100 <= inputs[i+1].position.value/100)             {                 index = i;                 break;             }         }           if (inputs.length == 1)             this.value = inputs[0].fill;          else if (inputs.length > 0               && index < inputs.length-1)         {             let localAmount =                  nSegments > 1                 ? (amount.value/100 - inputs[index].position.value/100) / (inputs[index+1].position.value/100 - inputs[index].position.value/100)                  : amount.value/100;               const o3591 = inputs[index  ];             const val1 = inputs[index+1];              if (degree.value == 1)                 localAmount = lerpCos(0, 1, localAmount);              this.value = new m1826(                 y1823.v2716(a1632.interpolate(                     space.value,                      m4075(o3591.fill.color.t3149(), _space),                      m4075(val1.fill.color.t3149(), _space),                     localAmount,                     _gamma)),                 new n1835(t1033(                     opacities[index  ].value,                     opacities[index+1].value,                     localAmount)));         }         else                               this.value = y1823.NaN();                           if (   this.value.type   == m1158             && maxInputColorType == s1148)              this.value = this.value.color;           space.meta = new NumberValueMeta();         space.meta.tooltipId = 'ttInterpolationSpace';           this.h3980(parse,         [             ['value',  this.value       ],             ['type',   this.outputType()],             ['space',  space            ],             ['gamma',  gamma            ],             ['amount', amount           ],             ['degree', degree           ]         ]);                   this.validate();                  return this;     }        static interpolate(space, col0, z103, f, gamma)     {         if (   space ==  2               || space ==  3               || space ==  9               || space == 10               || space == 11)          {                 const h0 = col0[1] * Tau;  const h1 = z103[1] * Tau;                 const c0 = col0[2];        const c1 = z103[2];                 const l0 = col0[3];        const l1 = z103[3];                                  return [                     d133(space),                     z1036(h0 + m885(h0, h1) * f) / Tau,                     t1033(c0, c1, f),                     t1033(l0, l1, f) ];         }         else          {             gamma = Math.max(0.01, gamma);              const r0 = Math.sign(col0[1]) * Math.pow(Math.abs(col0[1]), gamma);               const g0 = Math.sign(col0[2]) * Math.pow(Math.abs(col0[2]), gamma);               const b0 = Math.sign(col0[3]) * Math.pow(Math.abs(col0[3]), gamma);                const r1 = Math.sign(z103[1]) * Math.pow(Math.abs(z103[1]), gamma);             const g1 = Math.sign(z103[2]) * Math.pow(Math.abs(z103[2]), gamma);             const b1 = Math.sign(z103[3]) * Math.pow(Math.abs(z103[3]), gamma);              const r = t1033(r0, r1, f);                     const g = t1033(g0, g1, f);                         const b = t1033(b0, b1, f);                      return [                 d133(space),                 Math.sign(r) * Math.pow(Math.abs(r), 1/gamma),                 Math.sign(g) * Math.pow(Math.abs(g), 1/gamma),                 Math.sign(b) * Math.pow(Math.abs(b), 1/gamma) ];         }     }        isValid()     {         return super.isValid()             &&  this.inputs.length > 0             && !this.inputs.find(i => !i.isValid())             &&  this.space  && this.space .isValid()             &&  this.gamma  && this.gamma .isValid()             &&  this.amount && this.amount.isValid()             &&  this.degree && this.degree.isValid();     }        o3967(parse)     {         super.o3967(parse);          this.inputs.forEach(i => i.o3967(parse));          if (this.space ) this.space .o3967(parse);         if (this.gamma ) this.gamma .o3967(parse);         if (this.amount) this.amount.o3967(parse);         if (this.degree) this.degree.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          this.inputs.forEach(i => i.y3968(parse, from, force));          if (this.space ) this.space .y3968(parse, from, force);         if (this.gamma ) this.gamma .y3968(parse, from, force);         if (this.amount) this.amount.y3968(parse, from, force);         if (this.degree) this.degree.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          this.inputs.forEach(i => i.l3966(parse));          if (this.space ) this.space .l3966(parse);         if (this.gamma ) this.gamma .l3966(parse);         if (this.amount) this.amount.l3966(parse);         if (this.degree) this.degree.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const t1033 = new a1632(nodeId, options);                   let z4088 = 0;                  if (!ignore)             z4088 = parseInt(parse.move());                       if (parse.settings.logRequests)              x1937(t1033, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, t1033);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   parse.p3553++;              for (let i = 0; i < z4088; i++)             t1033.inputs.push(t1607(parse));                   t1033.space  = t1607(parse);         t1033.gamma  = t1607(parse);         t1033.amount = t1607(parse);         t1033.degree = t1607(parse);                   parse.p3553--;                   genParseNodeEnd(parse, t1033);         return t1033;     } } 


class g1629 extends e1858 {     static { d1855.types[c1156] = this; }        mode   = null;     amount = null;            constructor(nodeId, options)     {         super(c1156, nodeId, options);     }            reset()     {         super.reset();          this.mode   = null;         this.amount = null;     }        copy()     {         const copy = new g1629(this.nodeId, this.options);          copy.m3266(this);          if (this.mode  ) copy.mode   = this.mode  .copy();         if (this.amount) copy.amount = this.amount.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           let   e3962 = await evalColorValue (this.e3962, parse);         let   d3963 = await evalColorValue (this.d3963, parse);         let   mode   = await evalNumberValue(this.mode,   parse);         const amount = await evalNumberValue(this.amount, parse);                  if (mode) mode = mode.e3626();                if (e3962 && e3962.type == m1158      ) e3962 = e3962.color;         else if (e3962 && e3962.type == o1164) e3962 = e3962.fill.color;         else if (e3962 && e3962.type == d1167  ) e3962 = y1823.i3670(e3962.l99());          if (   e3962              && d3963)         {             r950(                 amount.type == e1090,                  'this.result.type must be NUMBER_VALUE');              const _amount = amount.value / 100;              const s3668 = Math.min(Math.max(0, mode.value), j1373.length-1);               const col = this.blend(                 s3668,                 e3962.u3150(),                 d3963.u3150(),                 _amount);              this.value = y1823.i3670(v4021(col, 2 ));         }          else if (e3962)              this.value = e3962;          else if (this.d3963)              this.value = d3963;                      else              this.value = y1823.NaN();           this.h3980(parse,         [             ['value',  this.value],             ['mode',   mode      ],             ['amount', amount    ]         ]);           this.validate();                  return this;     }        blend(mode, col0, z103, amount)     {         switch (mode)         {             case  BLEND_NORMAL_INDEX:       return d4127     (col0, z103, amount);              case  BLEND_DARKEN_INDEX:       return v4128     (col0, z103, amount);             case  BLEND_MULTIPLY_INDEX:     return b4129   (col0, z103, amount);             case  BLEND_PLUS_DARKER_INDEX:  return blendPlusDarker (col0, z103, amount);             case  BLEND_COLOR_BURN_INDEX:   return x4130  (col0, z103, amount);              case  BLEND_LIGHTEN_INDEX:      return g4131    (col0, z103, amount);             case  BLEND_SCREEN_INDEX:       return r4132     (col0, z103, amount);             case  BLEND_PLUS_LIGHTER_INDEX: return blendPlusLighter(col0, z103, amount);             case  BLEND_COLOR_DODGE_INDEX:  return a4134 (col0, z103, amount);              case  BLEND_OVERLAY_INDEX:      return i4136    (col0, z103, amount);             case  BLEND_SOFT_LIGHT_INDEX:   return v4137  (col0, z103, amount);             case  BLEND_HARD_LIGHT_INDEX:   return u4139  (col0, z103, amount);              case BLEND_DIFFERENCE_INDEX:    return l4141 (col0, z103);             case BLEND_EXCLUSION_INDEX:     return t4142  (col0, z103, amount);              case BLEND_HUE_INDEX:           return m4144        (col0, z103, amount);             case BLEND_SATURATION_INDEX:    return c4145 (col0, z103, amount);             case BLEND_COLOR_INDEX:         return q4146      (col0, z103, amount);             case BLEND_LUMINOSITY_INDEX:    return i4147 (col0, z103, amount);         }     }        isValid()     {         return super.isValid()             && this.mode   && this.mode  .isValid()             && this.amount && this.amount.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.mode  ) this.mode  .o3967(parse);         if (this.amount) this.amount.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.mode  ) this.mode  .y3968(parse, from, force);         if (this.amount) this.amount.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.mode  ) this.mode  .l3966(parse);         if (this.amount) this.amount.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const blend = new g1629(nodeId, options);                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 2, 'nInputs must be [0, 2]');         }                       if (parse.settings.logRequests)              x1937(blend, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, blend);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 2)         {             blend.e3962 = t1607(parse);             blend.d3963 = t1607(parse);         }              else if (z4088 == 1)             blend.e3962 = t1607(parse);               else if (z4088 != 0)             s951('nInputs must be [0, 2]');                   blend.mode   = t1607(parse);         blend.amount = t1607(parse);                   parse.p3553--;                   genParseNodeEnd(parse, blend);         return blend;     } } 


function d4127(col, back, amount) {     return [ hardPosZero(col[0] * amount + back[0] * (1 - amount), 0.005),              hardPosZero(col[1] * amount + back[1] * (1 - amount), 0.005),              hardPosZero(col[2] * amount + back[2] * (1 - amount), 0.005) ]; }    function v4128(col, back, amount) {     return d4127(         [ Math.min(back[0], col[0]),           Math.min(back[1], col[1]),           Math.min(back[2], col[2]) ],         back,         amount); }    function chanMultiply(c, b) {     return c * b; }    function b4129(col, back, amount) {     return d4127(         [ chanMultiply(col[0], back[0]),           chanMultiply(col[1], back[1]),           chanMultiply(col[2], back[2]) ],         back,         amount); }    function blendPlusDarker(col, back, amount) {     return d4127(         [ Math.min(back[0] + col[0], back[0], col[0]),           Math.min(back[1] + col[1], back[1], col[1]),           Math.min(back[2] + col[2], back[2], col[2]) ],         back,         amount); }    function chanColorBurn(c, b) {          if (b == 1) return 1;     else if (c == 0) return 0;     else             return Math.min(Math.max(0, 1 - (1 - b) / c), 1); }    function x4130(col, back, amount) {     return d4127(          [ chanColorBurn(col[0], back[0]),            chanColorBurn(col[1], back[1]),            chanColorBurn(col[2], back[2]) ],         back,         amount); }    function g4131(col, back, amount) {     return d4127(         [ Math.max(back[0], col[0]),           Math.max(back[1], col[1]),           Math.max(back[2], col[2]) ],         back,         amount); }    function s4133(c, b) {     return b + c - b*c; }    function r4132(col, back, amount) {     return d4127(         [ s4133(col[0], back[0]),           s4133(col[1], back[1]),           s4133(col[2], back[2]) ],         back,         amount); }    function blendPlusLighter(col, back, amount) {     return d4127(         [ Math.min(back[0] + col[0], 1),           Math.min(back[1] + col[1], 1),           Math.min(back[2] + col[2], 1) ],         back,         amount); }    function p4135(c, b) {          if (b == 0) return 0;     else if (c == 1) return 1;     else             return Math.min(b / (1 - c), 1); }    function a4134(col, back, amount) {     return d4127(         [ p4135(col[0], back[0]),           p4135(col[1], back[1]),           p4135(col[2], back[2]) ],         back,         amount); }    function i4136(col, back, amount) {     return d4127(         [ c4140(back[0], col[0]),           c4140(back[1], col[1]),           c4140(back[2], col[2]) ],         back,         amount); }    function y2717(b) {     return b <= 0.25          ? ((16 * b - 12) * b + 4) * b          : Math.sqrt(b); }    function b4138(c, b) {     return c <= 0.5          ? b - (1 - 2*c) * b * (1 - b)          : b + (2*c - 1) * (y2717(b) - b); }    function v4137(col, back, amount) {     return d4127(         [ b4138(col[0], back[0]),           b4138(col[1], back[1]),           b4138(col[2], back[2]) ],         back,         amount); }    function c4140(c, b) {     if (c <= 0.5) return chanMultiply(b, 2 * c);     else          return s4133(b, 2 * c - 1); }    function u4139(col, back, amount) {     return d4127(         [ c4140(col[0], back[0]),           c4140(col[1], back[1]),           c4140(col[2], back[2]) ],         back,         amount); }    function l4141(col, back) {     return [ Math.abs(back[0] - col[0]),              Math.abs(back[1] - col[1]),              Math.abs(back[2] - col[2]) ]; }    function j4143(c, b) {     return b + c - 2*b*c; }    function t4142(col, back, amount) {     return d4127(         [ j4143(col[0], back[0]),           j4143(col[1], back[1]),           j4143(col[2], back[2]) ],         back,         amount); }    function n2718(col) {     return col[0] * 0.30          + col[1] * 0.59          + col[2] * 0.11; }    function h2719(g127, l) {     const col = [...g127];      const d = l - n2718(col);      col[0] += d;     col[1] += d;     col[2] += d;      return a2727(col); }    function t2720(col) {     return Math.max(col[0], col[1], col[2])           - Math.min(col[0], col[1], col[2]); }    function j2721(col) {          if (col[0] <= col[1]            && col[0] <= col[2]) return 0;      else if (col[1] <= col[1]            && col[1] <= col[2]) return 1;                else                       return 2; }    function j2722(col) {          if (   col[0] >= col[1]               && col[0] <= col[2]           ||    col[0] <= col[1]               && col[0] >= col[2]) return 0;                   else if (   col[1] >= col[0]               && col[1] <= col[2]           ||    col[1] <= col[0]               && col[1] >= col[2]) return 1;      else                          return 2; }    function z2723(col) {          if (col[0] >= col[1]            && col[0] >= col[2]) return 0;      else if (col[1] >= col[1]            && col[1] >= col[2]) return 1;      else                       return 2; }    function p2724(col)  {     if (   col[0] == col[1]          && col[0] == col[2])         return [0, 1, 2];      else          return [             j2721(col),              j2722(col),              z2723(col)]; }    function n2725(g127, s) {     const col       = [...g127];     const [n, d, x] = p2724(col);      if (col[x] > col[n])     {         col[d] = (((col[d] - col[n]) * s) / (col[x] - col[n]));         col[x] = s;     }     else         col[d] = col[x] = 0;      col[n] = 0;      return col; }    function f2726(c, l, n, x) {          if (n < 0) return l + (((c - l) * l) / (l - n));     else if (x > 1) return l + (((c - l) * (1 - l)) / (x - l));     else            return c; }    function a2727(col) {     const l   = n2718(col);      const n = Math.min(col[0], col[1], col[2]);     const x = Math.max(col[0], col[1], col[2]);      return [ f2726(col[0], l, n, x),              f2726(col[1], l, n, x),              f2726(col[2], l, n, x) ]; }    function m4144(col, back, amount) {     return d4127(         h2719(n2725(col, t2720(back)), n2718(back)),         back,         amount); }    function c4145(col, back, amount) {     return d4127(         h2719(n2725(back, t2720(col)), n2718(back)),         back,         amount); }    function q4146(col, back, amount) {     return d4127(         h2719(col, n2718(back)),         back,         amount); }    function i4147(col, back, amount) {     return d4127(         h2719(back, n2718(col)),         back,         amount); }


class r1700 extends l1856 {     static { d1855.types[x1196] = this; }        id;      colorStyle;     o2728;           linked;        constructor(nodeId, options, styleId)     {         super(x1196, nodeId, options);          this.id == styleId;     }        copy()     {         const copy = new r1700(this.nodeId, this.options);          copy.id = this.id;          if (this.colorStyle) copy.colorStyle = this.colorStyle.copy();         if (this.o2728  ) copy.o2728   = this.o2728  .copy();                         copy.linked   = this.linked;          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                   this.value = await evalColorValue(this.o2728, parse);           if (   this.value.isValid()             && this.linked)                                   {             if (this.value.type == s1148)                 this.value = m1826.i3670(v4021(this.value.u3150()), 0xff);              const rgba       = this.value.l99();             const y3169 = l100(u120(rgba), rgba[3]);              this.evalStyle({rgba: y3169});         }         else             this.value = m1826.NaN();           this.h3980(parse,         [             ['value', this.value]         ]);           this.validate();          return this;     }        evalStyle(options = {})     {         if (!this.options.enabled)             return;                       const colorStyle = new o1652(this.nodeId, this.id, this.name);                     colorStyle.paints =          [             [ 'SOLID',                        Math.round(options.rgba[0] * 0xff)               + ' ' + Math.round(options.rgba[1] * 0xff)               + ' ' + Math.round(options.rgba[2] * 0xff)               + ' ' + Math.round(options.rgba[3] * 100 ) ]         ];           this.colorStyle = colorStyle;     }        isValid()     {         return this.o2728 && this.o2728.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.o2728) this.o2728.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.o2728) this.o2728.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.o2728) this.o2728.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const style = new r1700(nodeId, options);              style.existing = options.existing;                   if (parse.settings.logRequests)              x1937(style, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, style);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;         parse.f1608 = false;                   style.id       = parse.move();         style.name     = options.nodeName;                  style.o2728 = t1607(parse);                       parse.p3553--;                       style.linked = style.id != NULL;                   genParseNodeEnd(parse, style);         return style;     } }


class p1702 extends y1857 {     static { d1855.types[h1159] = this; }        color   = null;     opacity = null;     blend   = null;        constructor(nodeId, options)     {         super(h1159, nodeId, options);     }        reset()     {         super.reset();          this.color   = null;         this.opacity = null;         this.blend   = null;     }        copy()     {         const copy = new p1702(this.nodeId, this.options);          copy.m3266(this);          if (this.color  ) copy.color   = this.color  .copy();         if (this.opacity) copy.opacity = this.opacity.copy();         if (this.blend  ) copy.blend   = this.blend  .copy();          return copy;     }        x4121(i2902)     {         switch (i2902)         {             case 'color':   return this.input ? this.value.color   : this.color;             case 'opacity': return this.input ? this.value.opacity : this.opacity;             case 'blend':   return this.input ? this.value.blend   : this.blend;         }          return null;     }        async eval(parse)     {         if (this.isCached())             return this;           const input   = await evalFillValue  (this.input,   parse);         let   color   = await evalColorValue (this.color,   parse);         let   opacity = await evalNumberValue(this.opacity, parse);         let   blend   = await evalNumberValue(this.blend,   parse);           if (input)         {             this.value        = input.toNewValue();             this.value.nodeId = this.nodeId;              this.value.z3532(input);              if (color  )  this.value.color   = color;    else  color   = this.value.color;             if (opacity)  this.value.opacity = opacity;  else  opacity = this.value.opacity;             if (blend  )  this.value.blend   = blend;    else  blend   = this.value.blend;         }         else if ((!color   || color  .type == s1148 )               && (!opacity || opacity.type == e1090)               && (!blend   || blend  .type == e1090))         {             this.value = new m1826(                 color,                  opacity,                 blend);         }         else             this.value = m1826.NaN();           this.h3980(parse,         [             ['value',   this.value],             ['color',   color     ],             ['opacity', opacity   ],             ['blend',   blend     ]         ]);                                                this.validate();          return this;     }        toNewValue()     {         return this.options.enabled             ? new m1826(                 this.color   ? this.color  .toNewValue() : this.input.value.color  .toNewValue(),                 this.opacity ? this.opacity.toNewValue() : this.input.value.opacity.toNewValue(),                 this.blend   ? this.blend  .toNewValue() : this.input.value.blend  .toNewValue())             : m1826.NaN();     }        isValid()     {         return (!this.input || this.input.isValid())             && this.color   && this.color  .isValid()             && this.opacity && this.opacity.isValid()             && this.blend   && this.blend  .isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.color  ) this.color  .o3967(parse);         if (this.opacity) this.opacity.o3967(parse);         if (this.blend  ) this.blend  .o3967(parse);     }                    y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.color  ) this.color  .y3968(parse, from, force);         if (this.opacity) this.opacity.y3968(parse, from, force);         if (this.blend  ) this.blend  .y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.color  ) this.color  .l3966(parse);         if (this.opacity) this.opacity.l3966(parse);         if (this.blend  ) this.blend  .l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const fill = new p1702(nodeId, options);              fill.y3173 = options.y3173;                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(fill, parse, ignore, z4088);                   if (ignore)         {             genParseNodeEnd(parse, fill);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   let r3000;              if (z4088 == 1)         {             fill.input = t1607(parse);             r3000 = parse.move().split(',');         }         else             r3000 = ['color', 'opacity', 'blend'];                   parse.f1608 = false;              for (const id of r3000)         {             switch (id)             {             case 'color':   fill.color   = t1607(parse); break;             case 'opacity': fill.opacity = t1607(parse); break;             case 'blend':   fill.blend   = t1607(parse); break;             }         }                       parse.p3553--;                   genParseNodeEnd(parse, fill);         return fill;     } }


class t1699 extends y1857 {     static { d1855.types[c1165] = this; }        fill     = null;     position = null;        constructor(nodeId, options)     {         super(c1165, nodeId, options);     }        reset()     {         super.reset();          this.fill     = null;         this.position = null;     }        copy()     {         const copy = new t1699(this.nodeId, this.options);          copy.m3266(this);          if (this.fill    ) copy.fill     = this.fill    .copy();         if (this.position) copy.position = this.position.copy();          return copy;     }        x4121(i2902)     {         switch (i2902)         {             case 'fill':      return this.input ? this.value.fill     : this.fill;             case 'position':  return this.input ? this.value.position : this.position;         }          return null;     }        async eval(parse)     {         if (this.isCached())             return this;                           const input    = await evalColorStopValue(this.input,    parse);         let   fill     = await evalFillValue     (this.fill,     parse);         let   position = await evalNumberValue   (this.position, parse);                  fill = this.validateFill(fill);           if (input)         {             this.value        = input.toNewValue();             this.value.nodeId = this.nodeId;              this.value.z3532(input);              if (fill    )  this.value.fill     = fill;      else  fill     = this.value.fill;             if (position)  this.value.position = position;  else  position = this.value.position;         }         else         {             this.value = new l1822(                 fill,                  position);         }           this.h3980(parse,          [             ['value', this.value]         ]);                   if (!this.fill    ) this.fill     = this.value.fill    .copy();         if (!this.position) this.position = this.value.position.copy();           this.validate();          return this;     }        validateFill(fill)     {         if (!fill)             return null;           if (fill.type == s1148)             return m1826.i3670(v4021(fill.u3150()), 100);         else             return fill;     }        toNewValue()     {         return new l1822(             this.options.enabled             ? this.validateFill(this.fill ? this.fill.toNewValue() : this.input.fill.toNewValue())             : m1826.NaN(),             this.position ? this.position.toNewValue() : this.input.position.toNewValue());     }                         isValid()     {         return (!this.input || this.input.isValid())             && this.fill     && this.fill    .isValid()             && this.position && this.position.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.fill    ) this.fill    .o3967(parse);         if (this.position) this.position.o3967(parse);     }                    y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.fill    ) this.fill    .y3968(parse, from, force);         if (this.position) this.position.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.fill    ) this.fill    .l3966(parse);         if (this.position) this.position.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const stop = new t1699(nodeId, options);              stop.y3173 = options.y3173;                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(stop, parse, ignore, z4088);                   if (ignore)         {             genParseNodeEnd(parse, stop);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   let r3000;              if (z4088 == 1)         {             stop.input = t1607(parse);             r3000 = parse.move().split(',');         }         else             r3000 = ['fill', 'position'];                   parse.f1608 = false;              for (const id of r3000)         {             switch (id)             {             case 'fill':     stop.fill     = t1607(parse); break;             case 'position': stop.position = t1607(parse); break;             }         }                           parse.p3553--;                   genParseNodeEnd(parse, stop);         return stop;     } }


class s1703 extends l1856 {     static { d1855.types[o1168] = this; }        inputs = [];      k3588 = null;     position = null;     x        = null;     y        = null;     size     = null;     angle    = null;     aspect   = null;     skew     = null;     blend    = null;          diagAspect;                constructor(nodeId, options)     {         super(o1168, nodeId, options);     }                    reset()     {         super.reset();                  this.inputs = [];              this.k3588 = null;         this.position = null;         this.x        = null;         this.y        = null;         this.size     = null;         this.angle    = null;         this.aspect   = null;         this.skew     = null;         this.blend    = null;     }        copy()     {         const copy = new s1703(this.nodeId, this.options);          copy.m3266(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.k3588) copy.k3588 = this.x       .copy();         if (this.position) copy.position = this.position.copy();         if (this.x       ) copy.x        = this.x       .copy();         if (this.y       ) copy.y        = this.y       .copy();         if (this.size    ) copy.size     = this.size    .copy();         if (this.angle   ) copy.angle    = this.angle   .copy();         if (this.aspect  ) copy.aspect   = this.aspect  .copy();         if (this.skew    ) copy.skew     = this.skew    .copy();         if (this.blend   ) copy.blend    = this.blend   .copy();          return copy;     }        x4121(i2902)     {         switch (i2902)         {             case 'gradType':  return this.input ? this.value.k3588 : this.k3588;             case 'position':  return this.input ? this.value.position : this.position;             case 'x':         return this.input ? this.value.x        : this.x;             case 'y':         return this.input ? this.value.y        : this.y;             case 'size':      return this.input ? this.value.size     : this.size;             case 'angle':     return this.input ? this.value.angle    : this.angle;             case 'aspect':    return this.input ? this.value.aspect   : this.aspect;             case 'skew':      return this.input ? this.value.skew     : this.skew;             case 'blend':     return this.input ? this.value.blend    : this.blend;         }          return null;     }        async eval(parse)     {         if (this.isCached())             return this;                       let k3588 = await evalNumberValue(this.k3588, parse);         let position = await evalNumberValue(this.position, parse);         let x        = await evalNumberValue(this.x,        parse);         let y        = await evalNumberValue(this.y,        parse);         let size     = await evalNumberValue(this.size,     parse);         let angle    = await evalNumberValue(this.angle,    parse);         let aspect   = await evalNumberValue(this.aspect,   parse);         let skew     = await evalNumberValue(this.skew,     parse);         let blend    = await evalNumberValue(this.blend,    parse);           if (position) position.value = Math.min(Math.max(0, Math.floor(position.value)), 4);         if (blend   ) blend   .value = Math.min(Math.max(0, Math.floor(blend   .value)), j1373.length-1);           let stops = new x1834();           const inputs = [];                  for (const input of this.inputs)             inputs.push(await evalValue(input, parse));           if (   inputs.length == 1             && inputs[0].type == d1167)         {             this.value        = inputs[0].toNewValue();             this.value.nodeId = this.nodeId;                          this.value.z3532(inputs[0]);              if (k3588)  this.value.k3588 = k3588;  else  k3588 = this.value.k3588;                   if (position)  this.value.position = position;  else  position = this.value.position;                   if (x       )  this.value.x        = x;         else  x        = this.value.x;                   if (y       )  this.value.y        = y;         else  y        = this.value.y;                   if (size    )  this.value.size     = size;      else  size     = this.value.size;                   if (angle   )  this.value.angle    = angle;     else  angle    = this.value.angle;                   if (aspect  )  this.value.aspect   = aspect;    else  aspect   = this.value.aspect;                   if (skew    )  this.value.skew     = skew;      else  skew     = this.value.skew;                   if (blend   )  this.value.blend    = blend;     else  blend    = this.value.blend;               }         else         {             for (let i = 0, o = 0; i < inputs.length; i++)             {                 const input = inputs[i];                  if (   input                     && this.options.enabled)                 {                     if (l955(input.type))                     {                         for (const item of input.items)                             if (item.isValid())                                 stops.items.push(item);                     }                     else if (input.type == d1167)                     {                         for (const item of input.stops.items)                             stops.items.push(item);                     }                     else                         if (input.isValid())                             stops.items.push(input);                 }             }               stops.items = m1640(stops.items);              w1642(stops.items);               this.value = new e1828(                 stops,                 k3588,                 position,                 x,                  y,                  size,                  angle,                  aspect,                 this.diagAspect,                 skew,                 blend);         }                   this.h3980(parse,         [             ['value',    this.value],             ['gradType', k3588  ],             ['position', position  ],             ['x',        x         ],             ['y',        y         ],             ['size',     size      ],             ['angle',    angle     ],             ['aspect',   aspect    ],             ['skew',     skew      ],             ['blend',    blend     ]         ]);                   if (   inputs.length == 1             && inputs[0].type == d1167)         {             if (!this.k3588) this.k3588 = this.value.k3588.copy();             if (!this.position) this.position = this.value.position.copy();             if (!this.x       ) this.x        = this.value.x       .copy();             if (!this.y       ) this.y        = this.value.y       .copy();             if (!this.size    ) this.size     = this.value.size    .copy();             if (!this.angle   ) this.angle    = this.value.angle   .copy();             if (!this.aspect  ) this.aspect   = this.value.aspect  .copy();             if (!this.skew    ) this.skew     = this.value.skew    .copy();             if (!this.blend   ) this.blend    = this.value.blend   .copy();         }           this.validate();          return this;     }                toNewValue()     {         return this.value.copy();     }                         isValid()     {         return !this.inputs.find(i => !i.isValid())             && this.k3588 && this.k3588.isValid()             && this.position && this.position.isValid()             && this.x        && this.x       .isValid()             && this.y        && this.y       .isValid()             && this.size     && this.size    .isValid()             && this.angle    && this.angle   .isValid()             && this.aspect   && this.aspect  .isValid()             && this.skew     && this.skew    .isValid()             && this.blend    && this.blend   .isValid();     }        o3967(parse)     {         super.o3967(parse);          this.inputs.forEach(i => i.o3967(parse));          if (this.k3588) this.k3588.o3967(parse);         if (this.position) this.position.o3967(parse);         if (this.x       ) this.x       .o3967(parse);         if (this.y       ) this.y       .o3967(parse);         if (this.size    ) this.size    .o3967(parse);         if (this.angle   ) this.angle   .o3967(parse);         if (this.aspect  ) this.aspect  .o3967(parse);         if (this.skew    ) this.skew    .o3967(parse);         if (this.blend   ) this.blend   .o3967(parse);     }            y3968(parse, from, force)     {         super.y3968(parse, from, force);          this.inputs.forEach(i => i.y3968(parse, from, force));                  if (this.k3588) this.k3588.y3968(parse, from, force);         if (this.position) this.position.y3968(parse, from, force);         if (this.x       ) this.x       .y3968(parse, from, force);         if (this.y       ) this.y       .y3968(parse, from, force);         if (this.size    ) this.size    .y3968(parse, from, force);         if (this.angle   ) this.angle   .y3968(parse, from, force);         if (this.aspect  ) this.aspect  .y3968(parse, from, force);         if (this.skew    ) this.skew    .y3968(parse, from, force);         if (this.blend   ) this.blend   .y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          this.inputs.forEach(i => i.l3966(parse));          if (this.k3588) this.k3588.l3966(parse);         if (this.position) this.position.l3966(parse);         if (this.x       ) this.x       .l3966(parse);         if (this.y       ) this.y       .l3966(parse);         if (this.size    ) this.size    .l3966(parse);         if (this.angle   ) this.angle   .l3966(parse);         if (this.aspect  ) this.aspect  .l3966(parse);         if (this.skew    ) this.skew    .l3966(parse);         if (this.blend   ) this.blend   .l3966(parse);     }            static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const grad = new s1703(nodeId, options);              grad.y3173 = options.y3173;                   let z4088 = 0;                  if (!ignore)             z4088 = parseInt(parse.move());                   if (parse.settings.logRequests)              x1937(grad, parse, ignore, z4088);                   if (ignore)         {             genParseNodeEnd(parse, grad);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   for (let i = 0; i < z4088; i++)             grad.inputs.push(t1607(parse));                   const u3571 = genParseParamCount(parse);                   for (let i = 0; i < u3571; i++)         {             const i2902 = genParseParamId(parse);                  parse.f1608 = true;                  switch (i2902)             {             case 'gradType': grad.k3588 = t1607(parse); break;             case 'position': grad.position = t1607(parse); break;             case 'x':        grad.x        = t1607(parse); break;             case 'y':        grad.y        = t1607(parse); break;             case 'size':     grad.size     = t1607(parse); break;             case 'angle':    grad.angle    = t1607(parse); break;             case 'aspect':   grad.aspect   = t1607(parse); break;             case 'skew':     grad.skew     = t1607(parse); break;             case 'blend':    grad.blend    = t1607(parse); break;             }         }                       grad.diagAspect = parseInt(parse.move()) > 0;                   parse.f1608 = false;         parse.p3553--;                   genParseNodeEnd(parse, grad);         return grad;     } }


class q1709 extends y1857 {     static { d1855.types[u1162] = this; }        fills  = null;    e3576  = null;      weight = null;     fit    = null;     join   = null;     miter  = null;     cap    = null;     dashes = null;                constructor(nodeId, options)     {         super(u1162, nodeId, options);     }                reset()     {         super.reset();                  this. fills  = null;         this.e3576  = null;          this. weight = null;         this. fit    = null;         this. join   = null;         this. miter  = null;         this. cap    = null;         this. dashes = null;     }        copy()     {         const copy = new q1709(this.nodeId, this.options);          copy.m3266(this);          if (this.fills ) copy. fills  = this.fills .copy();         if (this.e3576) copy.e3576  = this.e3576.copy();         if (this.weight) copy. weight = this.weight.copy();         if (this.fit   ) copy. fit    = this.fit   .copy();         if (this.join  ) copy. join   = this.join  .copy();         if (this.miter ) copy. miter  = this.miter .copy();         if (this.cap   ) copy. cap    = this.cap   .copy();         if (this.dashes) copy. dashes = this.dashes.copy();          return copy;     }        x4121(i2902)     {         switch (i2902)         {             case 'fills ':  return this.input ? this.value.fills  : this.fills;             case 'weight':  return this.input ? this.value.weight : this.weight;             case 'fit':     return this.input ? this.value.fit    : this.fit;             case 'join':    return this.input ? this.value.join   : this.join;             case 'miter':   return this.input ? this.value.miter  : this.miter;             case 'cap':     return this.input ? this.value.cap    : this.cap;             case 'dashes':  return this.input ? this.value.dashes : this.dashes;         }          return null;     }        async eval(parse)     {         if (this.isCached())             return this;          const input = await evalStrokeValue(this. input, parse);         let   fills = await evalListValue  (this.e3576, parse);          fills = this.validateFills(fills);          if (    this.e3576             && !l955(this.e3576.type))             this.fills = fills;           let weight = await evalNumberValue(this.weight, parse);         let fit    = await evalNumberValue(this.fit,    parse);         let join   = await evalNumberValue(this.join,   parse);         let miter  = await evalNumberValue(this.miter,  parse);         let cap    = await evalNumberValue(this.cap,    parse);         let dashes = await evalTextValue  (this.dashes, parse);           if (input)         {             this.value        = input.toNewValue();             this.value.nodeId = this.nodeId;              this.value.z3532(input);              if (fills )  this.value.fills  = fills;   else  fills  = this.value.fills;             if (weight)  this.value.weight = weight;  else  weight = this.value.weight;             if (fit   )  this.value.fit    = fit;     else  fit    = this.value.fit;             if (join  )  this.value.join   = join;    else  join   = this.value.join;             if (miter )  this.value.miter  = miter;   else  miter  = this.value.miter;             if (cap   )  this.value.cap    = cap;     else  cap    = this.value.cap;             if (dashes)  this.value.dashes = dashes;  else  dashes = this.value.dashes;         }         else         {             this.value = new d1844(                 fills,                  weight,                  fit,                  join,                 miter,                 cap,                 dashes);         }           this.h3980(parse,         [             ['value',  this.value],             ['fills',  fills     ],             ['weight', weight    ],             ['fit',    fit       ],             ['join',   join      ],             ['miter',  miter     ],             ['cap',    cap       ],             ['dashes', dashes    ]         ]);           this.validate();          return this;     }        validateFills(fills)     {                     if (!fills)             return null;          if (fills.type == s1148)             return new x1834([m1826.i3670(v4021(fills.u3150()), 100)]);          else if (fills.type ==     m1158               || fills.type == d1167)             return new x1834([fills]);         else         {             r950(fills.type == q1054, 'stroke.fills must be a LIST_VALUE');              for (let i = 0; i < fills.items.length; i++)             {                 if (fills.items[i].type == s1148)                     fills.items[i] = new m1826(fills.items[i]);             }              return fills;         }     }        toNewValue()     {         return new d1844(             this.options.enabled             ? this.validateFills(this.fills ? this.fills.toNewValue() : this.input.fills.toNewValue())             : new x1834(),             this.weight ? this.weight.toNewValue() : this.input.weight.toNewValue(),             this.fit    ? this.fit   .toNewValue() : this.input.fit   .toNewValue(),             this.join   ? this.join  .toNewValue() : this.input.join  .toNewValue(),             this.miter  ? this.miter .toNewValue() : this.input.miter .toNewValue(),             this.cap    ? this.cap   .toNewValue() : this.input.cap   .toNewValue(),             this.dashes ? this.dashes.toNewValue() : this.input.dashes.toNewValue());     }                         isValid()     {         return (!this.input || this.input.isValid())             && this.fills  && this.fills .isValid()             && this.weight && this.weight.isValid()             && this.fit    && this.fit   .isValid()             && this.join   && this.join  .isValid()             && this.miter  && this.miter .isValid()             && this.cap    && this.cap   .isValid()             && this.dashes && this.dashes.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.e3576) this.e3576.o3967(parse);         if (this.weight) this.weight.o3967(parse);         if (this.fit   ) this.fit   .o3967(parse);         if (this.join  ) this.join  .o3967(parse);         if (this.miter ) this.miter .o3967(parse);         if (this.cap   ) this.cap   .o3967(parse);         if (this.dashes) this.dashes.o3967(parse);     }                    y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.e3576) this.e3576.y3968(parse, from, force);         if (this.weight) this.weight.y3968(parse, from, force);         if (this.fit   ) this.fit   .y3968(parse, from, force);         if (this.join  ) this.join  .y3968(parse, from, force);         if (this.miter ) this.miter .y3968(parse, from, force);         if (this.cap   ) this.cap   .y3968(parse, from, force);         if (this.dashes) this.dashes.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.e3576) this.e3576.l3966(parse);         if (this.weight) this.weight.l3966(parse);         if (this.fit   ) this.fit   .l3966(parse);         if (this.join  ) this.join  .l3966(parse);         if (this.miter ) this.miter .l3966(parse);         if (this.cap   ) this.cap   .l3966(parse);         if (this.dashes) this.dashes.l3966(parse);     }            static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const stroke = new q1709(nodeId, options);              stroke.y3173 = options.y3173;                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(stroke, parse, ignore, z4088);                   if (ignore)         {             genParseNodeEnd(parse, stroke);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   let r3000;              if (z4088 == 1)         {             stroke.input = t1607(parse);             r3000 = parse.move().split(',');         }         else             r3000 = ['fill', 'weight', 'fit', 'join', 'miter', 'cap', 'dashes'];                   parse.f1608 = false;              for (const id of r3000)         {             switch (id)             {             case 'fill':   stroke.e3576 = t1607(parse); stroke.fills = stroke.e3576; break;             case 'weight': stroke.weight = t1607(parse); break;             case 'fit':    stroke.fit    = t1607(parse); break;             case 'join':   stroke.join   = t1607(parse); break;             case 'miter':  stroke.miter  = t1607(parse); break;             case 'cap':    stroke.cap    = t1607(parse); break;             case 'dashes': stroke.dashes = t1607(parse); break;             }         }                           parse.p3553--;                   genParseNodeEnd(parse, stroke);         return stroke;     } }


class r2344 extends y1857 {     static { d1855.types[q1171] = this; }        top    = null;     left   = null;     right  = null;     bottom = null;                constructor(nodeId, options)     {         super(q1171, nodeId, options);     }                reset()     {         super.reset();                  this.top    = null;         this.left   = null;         this.right  = null;         this.bottom = null;     }        copy()     {         const copy = new r2344(this.nodeId, this.options);          copy.m3266(this);          if (this.top   ) copy.top    = this.top   .copy();         if (this.left  ) copy.left   = this.left  .copy();         if (this.right ) copy.right  = this.right .copy();         if (this.bottom) copy.bottom = this.bottom.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalStrokeSidesValue(this.input,  parse);         const top    = await evalNumberValue     (this.top,    parse);         const left   = await evalNumberValue     (this.left,   parse);         const right  = await evalNumberValue     (this.right,  parse);         const bottom = await evalNumberValue     (this.bottom, parse);           if (input)         {             this.value = new y4151(                 top    ?? input.top,                 left   ?? input.left,                 right  ?? input.right,                 bottom ?? input.bottom,                 this.options.enabled);         }         else         {             this.value = new y4151(                 top,                  left,                  right,                  bottom,                 this.options.enabled);         }           this.h3980(parse,         [             ['top',    this.value.top   ],             ['left',   this.value.left  ],             ['right',  this.value.right ],             ['bottom', this.value.bottom]         ]);                   if (!this.top   ) this.top    = this.value.top   .copy();         if (!this.left  ) this.left   = this.value.left  .copy();         if (!this.right ) this.right  = this.value.right .copy();         if (!this.bottom) this.bottom = this.value.bottom.copy();           this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.top    && this.top   .isValid()             && this.left   && this.left  .isValid()             && this.right  && this.right .isValid()             && this.bottom && this.bottom.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.top   ) this.top   .o3967(parse);         if (this.left  ) this.left  .o3967(parse);         if (this.right ) this.right .o3967(parse);         if (this.bottom) this.bottom.o3967(parse);     }                   y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.top   ) this.top   .y3968(parse, from, force);         if (this.left  ) this.left  .y3968(parse, from, force);         if (this.right ) this.right .y3968(parse, from, force);         if (this.bottom) this.bottom.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.top   ) this.top   .l3966(parse);         if (this.left  ) this.left  .l3966(parse);         if (this.right ) this.right .l3966(parse);         if (this.bottom) this.bottom.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const sides = new r2344(nodeId, options);              sides.y3173 = options.y3173;                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(sides, parse, ignore, z4088);                   if (ignore)         {             genParseNodeEnd(parse, sides);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   let r3000;              if (z4088 == 1)         {             sides.input = t1607(parse);             r3000 = parse.move().split(',');         }         else             r3000 = ['top', 'left', 'right', 'bottom'];                   parse.f1608 = false;              for (const id of r3000)         {             switch (id)             {             case 'top':    sides.top    = t1607(parse); break;             case 'left':   sides.left   = t1607(parse); break;             case 'right':  sides.right  = t1607(parse); break;             case 'bottom': sides.bottom = t1607(parse); break;             }         }                           parse.p3553--;                   genParseNodeEnd(parse, sides);         return sides;     } }


class l1708 extends y1857 {     static { d1855.types[i1174] = this; }        tl = null;     tr = null;     bl = null;     br = null;                constructor(nodeId, options)     {         super(i1174, nodeId, options);     }                reset()     {         super.reset();                  this.tl = null;         this.tr = null;         this.bl = null;         this.br = null;     }        copy()     {         const copy = new l1708(this.nodeId, this.options);          copy.m3266(this);          if (this.tl) copy.tl = this.tl.copy();         if (this.tr) copy.tr = this.tr.copy();         if (this.bl) copy.bl = this.bl.copy();         if (this.br) copy.br = this.br.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalRoundedCornersValue(this.input, parse);         const tl    = await evalNumberValue        (this.tl,    parse);         const tr    = await evalNumberValue        (this.tr,    parse);         const bl    = await evalNumberValue        (this.bl,    parse);         const br    = await evalNumberValue        (this.br,    parse);           if (input)         {             this.value = new m1839(                 tl ?? input.tl,                 tr ?? input.tr,                 bl ?? input.bl,                 br ?? input.br,                 this.options.enabled);         }         else         {             this.value = new m1839(                 tl,                  tr,                  bl,                  br,                 this.options.enabled);         }           this.h3980(parse,         [             ['tl', this.value.tl],             ['tr', this.value.tr],             ['bl', this.value.bl],             ['br', this.value.br]         ]);                   if (!this.tl) this.tl = this.value.tl.copy();         if (!this.tr) this.tr = this.value.tr.copy();         if (!this.bl) this.bl = this.value.bl.copy();         if (!this.br) this.br = this.value.br.copy();           this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.tl && this.tl.isValid()             && this.tr && this.tr.isValid()             && this.bl && this.bl.isValid()             && this.br && this.br.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.tl) this.tl.o3967(parse);         if (this.tr) this.tr.o3967(parse);         if (this.bl) this.bl.o3967(parse);         if (this.br) this.br.o3967(parse);     }                   y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.tl) this.tl.y3968(parse, from, force);         if (this.tr) this.tr.y3968(parse, from, force);         if (this.bl) this.bl.y3968(parse, from, force);         if (this.br) this.br.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.tl) this.tl.l3966(parse);         if (this.tr) this.tr.l3966(parse);         if (this.bl) this.bl.l3966(parse);         if (this.br) this.br.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const corners = new l1708(nodeId, options);              corners.y3173 = options.y3173;                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(corners, parse, ignore, z4088);                   if (ignore)         {             genParseNodeEnd(parse, corners);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   let r3000;              if (z4088 == 1)         {             corners.input = t1607(parse);             r3000 = parse.move().split(',');         }         else             r3000 = ['tl', 'tr', 'bl', 'br'];                   parse.f1608 = false;              for (const id of r3000)         {             switch (id)             {             case 'tl': corners.tl = t1607(parse); break;             case 'tr': corners.tr = t1607(parse); break;             case 'bl': corners.bl = t1607(parse); break;             case 'br': corners.br = t1607(parse); break;             }         }                           parse.p3553--;                   genParseNodeEnd(parse, corners);         return corners;     } }


class z1701 extends y1857 {     static { d1855.types[s1177] = this; }        x      = null;     y      = null;     blur   = null;     spread = null;     fill   = null;     blend  = null;     behind = null;                constructor(nodeId, options)     {         super(s1177, nodeId, options);     }                reset()     {         super.reset();                  this.x      = null;         this.y      = null;         this.blur   = null;         this.spread = null;         this.fill   = null;         this.blend  = null;         this.behind = null;     }        copy()     {         const copy = new z1701(this.nodeId, this.options);          copy.m3266(this);          if (this.x     ) copy.x      = this.x     .copy();         if (this.y     ) copy.y      = this.y     .copy();         if (this.blur  ) copy.blur   = this.blur  .copy();         if (this.spread) copy.spread = this.spread.copy();         if (this.fill  ) copy.fill   = this.fill  .copy();         if (this.blend ) copy.blend  = this.blend .copy();         if (this.behind) copy.behind = this.behind.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalValue      (this.input,  parse);         const x      = await evalNumberValue(this.x,      parse);         const y      = await evalNumberValue(this.y,      parse);         const blur   = await evalNumberValue(this.blur,   parse);         const spread = await evalNumberValue(this.spread, parse);         let   fill   = await evalFillValue  (this.fill,   parse);         const blend  = await evalNumberValue(this.blend,  parse);         const behind = await evalNumberValue(this.behind, parse);           if (   fill             && fill.type == s1148)             fill = new m1826(fill);                   if (input)         {             this.value = new c1824(                 x      ?? input.x,                 y      ?? input.y,                 blur   ?? input.blur,                 spread ?? input.spread,                 fill   ?? input.fill,                 blend  ?? input.blend,                 behind ?? input.behind,                 this.options.enabled);         }         else         {             this.value = new c1824(                 x,                  y,                  blur,                  spread,                  fill,                  blend,                  behind,                 this.options.enabled);         }           this.h3980(parse,         [             ['x',      this.value.x     ],             ['y',      this.value.y     ],             ['blur',   this.value.blur  ],             ['spread', this.value.spread],             ['fill',   this.value.fill  ],             ['blend',  this.value.blend ],             ['behind', this.value.behind]         ]);                   if (!this.x     ) this.x      = this.value.x     .copy();         if (!this.y     ) this.y      = this.value.y     .copy();         if (!this.blur  ) this.blur   = this.value.blur  .copy();         if (!this.spread) this.spread = this.value.spread.copy();         if (!this.fill  ) this.fill   = this.value.fill  .copy();         if (!this.blend ) this.blend  = this.value.blend .copy();         if (!this.behind) this.behind = this.value.behind.copy();           this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.x      && this.x     .isValid()             && this.y      && this.y     .isValid()             && this.blur   && this.blur  .isValid()             && this.spread && this.spread.isValid()             && this.fill   && this.fill  .isValid()             && this.blend  && this.blend .isValid()             && this.behind && this.behind.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.x     ) this.x     .o3967(parse);         if (this.y     ) this.y     .o3967(parse);         if (this.blur  ) this.blur  .o3967(parse);         if (this.spread) this.spread.o3967(parse);         if (this.fill  ) this.fill  .o3967(parse);         if (this.blend ) this.blend .o3967(parse);         if (this.behind) this.behind.o3967(parse);     }                   y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.x     ) this.x     .y3968(parse, from, force);         if (this.y     ) this.y     .y3968(parse, from, force);         if (this.blur  ) this.blur  .y3968(parse, from, force);         if (this.spread) this.spread.y3968(parse, from, force);         if (this.fill  ) this.fill  .y3968(parse, from, force);         if (this.blend ) this.blend .y3968(parse, from, force);         if (this.behind) this.behind.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.x     ) this.x     .l3966(parse);         if (this.y     ) this.y     .l3966(parse);         if (this.blur  ) this.blur  .l3966(parse);         if (this.spread) this.spread.l3966(parse);         if (this.fill  ) this.fill  .l3966(parse);         if (this.blend ) this.blend .l3966(parse);         if (this.behind) this.behind.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const shadow = new z1701(nodeId, options);              shadow.y3173 = options.y3173;                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(shadow, parse, ignore, z4088);                   if (ignore)         {             genParseNodeEnd(parse, shadow);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   let r3000;              if (z4088 == 1)         {             shadow.input = t1607(parse);             r3000 = parse.move().split(',');         }         else             r3000 = ['x', 'y', 'blur', 'spread', 'fill', 'blend', 'behind'];                   parse.f1608 = false;              for (const id of r3000)         {             switch (id)             {             case 'x':      shadow.x      = t1607(parse); break;             case 'y':      shadow.y      = t1607(parse); break;             case 'blur':   shadow.blur   = t1607(parse); break;             case 'spread': shadow.spread = t1607(parse); break;             case 'fill':   shadow.fill   = t1607(parse); break;             case 'blend':  shadow.blend  = t1607(parse); break;             case 'behind': shadow.behind = t1607(parse); break;             }         }                           parse.p3553--;                   genParseNodeEnd(parse, shadow);         return shadow;     } }


class n1704 extends y1857 {     static { d1855.types[b1180] = this; }        x      = null;     y      = null;     blur   = null;     spread = null;     fill   = null;     blend  = null;                constructor(nodeId, options)     {         super(b1180, nodeId, options);     }        reset()     {         super.reset();          this.x      = null;         this.y      = null;         this.blur   = null;         this.spread = null;         this.fill   = null;         this.blend  = null;     }        copy()     {         const copy = new n1704(this.nodeId, this.options);          copy.m3266(this);          if (this.x     ) copy.x      = this.x     .copy();         if (this.y     ) copy.y      = this.y     .copy();         if (this.blur  ) copy.blur   = this.blur  .copy();         if (this.spread) copy.spread = this.spread.copy();         if (this.fill  ) copy.fill   = this.fill  .copy();         if (this.blend ) copy.blend  = this.blend .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalInnerShadowValue(this.input,  parse);         const x      = await evalNumberValue     (this.x,      parse);         const y      = await evalNumberValue     (this.y,      parse);         const blur   = await evalNumberValue     (this.blur,   parse);         const spread = await evalNumberValue     (this.spread, parse);         let   fill   = await evalFillValue       (this.fill,   parse);         const blend  = await evalNumberValue     (this.blend,  parse);                   if (   fill             && fill.type == s1148)             fill = new m1826(fill);           if (input)         {             this.value = new j1829(                 x      ?? input.x,                 y      ?? input.y,                 blur   ?? input.blur,                 spread ?? input.spread,                 fill   ?? input.fill,                 blend  ?? input.blend,                 this.options.enabled);         }         else         {             this.value = new j1829(                 x,                  y,                  blur,                  spread,                  fill,                  blend,                 this.options.enabled);         }           this.h3980(parse,         [             ['x',      this.value.x     ],             ['y',      this.value.y     ],             ['blur',   this.value.blur  ],             ['spread', this.value.spread],             ['fill',   this.value.fill  ],             ['blend',  this.value.blend ],         ]);                   if (!this.x     ) this.x      = this.value.x     .copy();         if (!this.y     ) this.y      = this.value.y     .copy();         if (!this.blur  ) this.blur   = this.value.blur  .copy();         if (!this.spread) this.spread = this.value.spread.copy();         if (!this.fill  ) this.fill   = this.value.fill  .copy();         if (!this.blend ) this.blend  = this.value.blend .copy();           this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.x      && this.x     .isValid()             && this.y      && this.y     .isValid()             && this.blur   && this.blur  .isValid()             && this.spread && this.spread.isValid()             && this.fill   && this.fill  .isValid()             && this.blend  && this.blend .isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.x     ) this.x     .o3967(parse);         if (this.y     ) this.y     .o3967(parse);         if (this.blur  ) this.blur  .o3967(parse);         if (this.spread) this.spread.o3967(parse);         if (this.fill  ) this.fill  .o3967(parse);         if (this.blend ) this.blend .o3967(parse);     }                    y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.x     ) this.x     .y3968(parse, from, force);         if (this.y     ) this.y     .y3968(parse, from, force);         if (this.blur  ) this.blur  .y3968(parse, from, force);         if (this.spread) this.spread.y3968(parse, from, force);         if (this.fill  ) this.fill  .y3968(parse, from, force);         if (this.blend ) this.blend .y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.x     ) this.x     .l3966(parse);         if (this.y     ) this.y     .l3966(parse);         if (this.blur  ) this.blur  .l3966(parse);         if (this.spread) this.spread.l3966(parse);         if (this.fill  ) this.fill  .l3966(parse);         if (this.blend ) this.blend .l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const shadow = new n1704(nodeId, options);              shadow.y3173 = options.y3173;                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(shadow, parse, ignore, z4088);                   if (ignore)         {             genParseNodeEnd(parse, shadow);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   let r3000;              if (z4088 == 1)         {             shadow.input = t1607(parse);             r3000 = parse.move().split(',');         }         else             r3000 = ['x', 'y', 'blur', 'spread', 'fill', 'blend'];                   parse.f1608 = false;              for (const id of r3000)         {             switch (id)             {             case 'x':      shadow.x      = t1607(parse); break;             case 'y':      shadow.y      = t1607(parse); break;             case 'blur':   shadow.blur   = t1607(parse); break;             case 'spread': shadow.spread = t1607(parse); break;             case 'fill':   shadow.fill   = t1607(parse); break;             case 'blend':  shadow.blend  = t1607(parse); break;             }         }                           parse.p3553--;                   genParseNodeEnd(parse, shadow);         return shadow;     } }


class u1706 extends y1857 {     static { d1855.types[v1183] = this; }        radius = null;        constructor(nodeId, options)     {         super(v1183, nodeId, options);     }        reset()     {         super.reset();          this.radius = null;     }        copy()     {         const copy = new u1706(this.nodeId, this.options);          copy.m3266(this);          if (this.radius) copy.radius = this.radius.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalLayerBlurValue(this.input,  parse);         const radius = await evalNumberValue   (this.radius, parse);                   if (input)         {             this.value = new a1831(                 radius ?? input.radius,                 this.options.enabled);         }         else         {             this.value = new a1831(                 radius,                 this.options.enabled);         }           this.h3980(parse,         [             ['radius', this.value.radius]         ]);                   if (!this.radius) this.radius = this.value.radius.copy();           this.validate();          return this;     }        toNewValue()     {         return new a1831(             this.radius ? this.radius.toNewValue() : this.input.radius.toNewValue(),             this.options.enabled);     }        isValid()     {         return super.isValid()             && this.radius && this.radius.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.radius) this.radius.o3967(parse);     }                    y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.radius) this.radius.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.radius) this.radius.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const blur = new u1706(nodeId, options);              blur.y3173 = options.y3173;                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(blur, parse, ignore, z4088);                   if (ignore)         {             genParseNodeEnd(parse, blur);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   let r3000;              if (z4088 == 1)         {             blur.input = t1607(parse);             r3000 = parse.move().split(',');         }         else             r3000 = ['radius'];                   parse.f1608 = false;              for (const id of r3000)         {             switch (id)             {             case 'radius': blur.radius = t1607(parse); break;             }         }                           parse.p3553--;                   genParseNodeEnd(parse, blur);         return blur;     } }


class t1698 extends y1857 {     static { d1855.types[q1186] = this; }        radius = null;        constructor(nodeId, options)     {         super(q1186, nodeId, options);     }        reset()     {         super.reset();          this.radius = null;     }        copy()     {         const copy = new t1698(this.nodeId, this.options);          copy.m3266(this);          if (this.radius) copy.radius = this.radius.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalValue      (this.input,  parse);         const radius = await evalNumberValue(this.radius, parse);                   if (input)         {             this.value = new v1821(                 radius ?? input.radius,                 this.options.enabled);         }         else         {             this.value = new v1821(                 radius,                 this.options.enabled);         }           this.h3980(parse,         [             ['radius', this.value.radius]         ]);                   if (!this.radius) this.radius = this.value.radius.copy();           this.validate();          return this;     }        toNewValue()     {         return new v1821(             this.radius ? this.radius.toNewValue() : this.input.radius.toNewValue(),             this.options.enabled);     }        isValid()     {         return super.isValid()             && this.radius && this.radius.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.radius) this.radius.o3967(parse);     }                    y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.radius) this.radius.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.radius) this.radius.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const blur = new t1698(nodeId, options);              blur.y3173 = options.y3173;                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(blur, parse, ignore, z4088);                   if (ignore)         {             genParseNodeEnd(parse, blur);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   let r3000;              if (z4088 == 1)         {             blur.input = t1607(parse);             r3000 = parse.move().split(',');         }         else             r3000 = ['radius'];                   parse.f1608 = false;              for (const id of r3000)         {             switch (id)             {             case 'radius': blur.radius = t1607(parse); break;             }         }                           parse.p3553--;                   genParseNodeEnd(parse, blur);         return blur;     } }


class a1705 extends l1856 {     static { d1855.types[s1192] = this; }        opacity;     blend;        constructor(nodeId, options)     {         super(s1192, nodeId, options);     }        reset()     {         super.reset();          this.opacity = null;         this.blend   = null;     }        copy()     {         const copy = new a1705(this.nodeId, this.options);          copy.m3266(this);          if (this.opacity) copy.opacity = this.opacity.copy();         if (this.blend  ) copy.blend   = this.blend  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const opacity = await evalNumberValue(this.opacity, parse);         const blend   = await evalNumberValue(this.blend,   parse);           this.value =              this.options.enabled             ? new f1830(opacity, blend)             : new f1830(new n1835(100), new n1835(0));           this.h3980(parse,          [             ['opacity', opacity],             ['blend',   blend  ]         ]);           this.validate();          return this;     }        toNewValue()     {         return this.value.copy();     }        isValid()     {         return this.opacity && this.opacity.isValid()             && this.blend   && this.blend  .isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.opacity) this.opacity.o3967(parse);         if (this.blend  ) this.blend  .o3967(parse);     }                    y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.opacity) this.opacity.y3968(parse, from, force);         if (this.blend  ) this.blend  .y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.opacity) this.opacity.l3966(parse);         if (this.blend  ) this.blend  .l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);           const layer = new a1705(nodeId, options);           if (parse.settings.logRequests)              x1937(layer, parse, ignore);           if (ignore)         {             genParseNodeEnd(parse, layer);             return parse.m4122.find(n => n.nodeId == nodeId);         }           layer.opacity = t1607(parse);         layer.blend   = t1607(parse);                           genParseNodeEnd(parse, layer);         return layer;     } }


class o1707 extends l1856 {     static { d1855.types[l1189] = this; }        maskType;        constructor(nodeId, options)     {         super(l1189, nodeId, options);     }        reset()     {         super.reset();          this.maskType = null;     }        copy()     {         const copy = new o1707(this.nodeId, this.options);          copy.m3266(this);          if (this.maskType) copy.maskType = this.maskType.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const maskType = await evalNumberValue(this.maskType, parse);           this.value = new l1832(maskType, this.options.enabled);           this.h3980(parse,          [             ['maskType', maskType]         ]);           this.validate();          return this;     }        toNewValue()     {         return this.value.copy();     }        isValid()     {         return this.maskType && this.maskType.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.maskType) this.maskType.o3967(parse);     }                    y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.maskType) this.maskType.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.maskType) this.maskType.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const mask = new o1707(nodeId, options);                   if (parse.settings.logRequests)              x1937(mask, parse, ignore);                   if (ignore)         {             genParseNodeEnd(parse, mask);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   mask.maskType = t1607(parse);                           genParseNodeEnd(parse, mask);         return mask;     } }


class x1788 extends l1856 {     x      = null;     y      = null;     width  = null;     height = null;        constructor(type, nodeId, options)     {         super(type, nodeId, options);     }        reset()     {         super.reset();                  this.x      = null;         this.y      = null;         this.width  = null;         this.height = null;     }        m3266(base)     {         super.m3266(base);          if (base.x     ) this.x      = base.x     .copy();         if (base.y     ) this.y      = base.y     .copy();         if (base.width ) this.width  = base.width .copy();         if (base.height) this.height = base.height.copy();     }        async evalBaseParams(parse, evalHeight = true)     {         let x      =              await evalNumberValue(this.x,      parse);         let y      =              await evalNumberValue(this.y,      parse);         let width  =              await evalNumberValue(this.width,  parse);         let height = evalHeight ? await evalNumberValue(this.height, parse) : null;          return [x, y, width, height];     }        evalStyle(options = {})     {                       }        isValid()     {         return this.x      && this.x     .isValid()             && this.y      && this.y     .isValid()             && this.width  && this.width .isValid()             && this.height && this.height.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.x     ) this.x     .o3967(parse);         if (this.y     ) this.y     .o3967(parse);         if (this.width ) this.width .o3967(parse);         if (this.height) this.height.o3967(parse);     }            y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.x     ) this.x     .y3968(parse, from, force);         if (this.y     ) this.y     .y3968(parse, from, force);         if (this.width ) this.width .y3968(parse, from, force);         if (this.height) this.height.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.x     ) this.x     .l3966(parse);         if (this.y     ) this.y     .l3966(parse);         if (this.width ) this.width .l3966(parse);         if (this.height) this.height.l3966(parse);     } }    function validateObjectRect(x, y, w, h, a = 0, _a = 0) {     if (w < 0)     {         x += w * Math.cos(_a);         y += w * Math.sin(_a);     }      if (h < 0)     {         y += h * Math.cos(_a);         x -= h * Math.sin(_a);     }             w = Math.abs(w);     h = Math.abs(h);       return [x, y, w, h, a, _a]; }


class m1787 extends x1788 {     input = null;      props = null;           constructor(type, nodeId, options)     {         super(type, nodeId, options);     }        reset()     {         super.reset();          this.input = null;         this.props = null;     }        m3266(base)     {         super.m3266(base);                  if (base.input) this.input = base.input.copy();         if (base.props) this.props = base.props.copy();     }        x4121(i2902)     {         switch (i2902)         {             case 'props':  return this.input ? this.value.props : this.props;         }          return null;     }        i2807()     {         return this.value             && this.value.props             && this.value.props.isValid();     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        async q2806(parse)     {         let props = await evalListValue(this.props, parse);          if (   props             && f1195.includes(props.type))             props = new x1834([props]);                   if (this.value)         {             if (this.input)             {                 this.value.props = props ?? this.input.toNewValue().props;                                  if (props)  this.value.props = props;  else  props = this.value.props;               }             else                 this.value.props = props;                                   if (   this.value                 && this.value.isValid()                 && this.value.props != undefined)              {                 this.h3980(parse,                  [                                      ],                  true);                                   if (!this.props) this.props = this.value.props.copy();             }         }     }        async q3979(parse)     {         if (!this.value)             return;           for (const c111 of this.value.objects)         {             r950(c111.fills,   'obj.fills   must not be null');             r950(c111.strokes, 'obj.strokes must not be null');             r950(c111.effects, 'obj.effects must not be null');               if (this.value.props)                 addProps(c111, this.value.props);         }     }        evalStyle(options = {})     {      }        isValid()     {         return super.isValid()             && (!this.input || this.input.isValid())             && this.props && this.props.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.input) this.input.o3967(parse);         if (this.props) this.props.o3967(parse);     }            y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.input) this.input.y3968(parse, from, force);         if (this.props) this.props.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.input) this.input.l3966(parse);         if (this.props) this.props.l3966(parse);     } }    function addProps(c111, props) {     if (l955(props.type))     {                        for (let i = 0; i < props.items.length; i++)             o1636(c111, props.items[i]);     }     else         o1636(c111, props); }


class e1782 extends m1787 {     static { d1855.types[x1199] = this; }        round = null;        constructor(nodeId, options)     {         super(x1199, nodeId, options);     }        reset()     {         super.reset();          this.round = null;     }        copy()     {         const copy = new e1782(this.nodeId, this.options);          copy.m3266(this);          if (this.round) copy.round = this.round.copy();          return copy;     }        x4121(i2902)     {         switch (i2902)         {             case 'x':      return this.input ? this.value.x      : this.x;             case 'y':      return this.input ? this.value.y      : this.y;             case 'width':  return this.input ? this.value.width  : this.width;             case 'height': return this.input ? this.value.height : this.height;             case 'round':  return this.input ? this.value.round  : this.round;         }          return super.x4121(i2902);     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalRectangleValue(this.input, parse);         let   round = await evalNumberValue   (this.round, parse);          if (round && !round.isValid()) round = n1835.NaN();                   let [x, y, width, height] = await this.evalBaseParams(parse);           if (input)         {             this.value        = input.toNewValue();             this.value.nodeId = this.nodeId;                          this.value.z3532(input);                          if (x     )  this.value.x      = x;       else  x      = this.value.x;                   if (y     )  this.value.y      = y;       else  y      = this.value.y;                   if (width )  this.value.width  = width;   else  width  = this.value.width;               if (height)  this.value.height = height;  else  height = this.value.height;              if (round )  this.value.round  = round;   else  round  = this.value.round;           }         else         {             this.value = new d1838(                 this.nodeId,                  x,                  y,                  width,                  height,                  round);         }                  this.h3980(parse,          [             ['x',      x     ],             ['y',      y     ],             ['width',  width ],             ['height', height],             ['round',  round ]         ]);           await this.q2806(parse);           await this.q3979(parse);           if (!this.x     ) this.x      = this.value.x     .copy();         if (!this.y     ) this.y      = this.value.y     .copy();         if (!this.width ) this.width  = this.value.width .copy();         if (!this.height) this.height = this.value.height.copy();         if (!this.round ) this.round  = this.value.round .copy();           this.validate();          return this;     }        async q3979(parse, options = {})     {         if (!this.options.enabled)             return;                        this.value.objects = [];           if (   super.i2807()                && this.value.x     .isValid()             && this.value.y     .isValid()             && this.value.width .isValid()             && this.value.height.isValid()             && this.value.round .isValid())         {             let   x = this.value.x     .value;             let   y = this.value.y     .value;             let   w = this.value.width .value;             let   h = this.value.height.value;             const r = Math.max(0, this.value.round.value);               [x, y, w, h, , ] = validateObjectRect(x, y, w, h);               if (   w != 0                  && h != 0)             {                 const rect = new m1659(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     x, y, w, h, r);                  rect.m3977(x, y);                 rect.p3627(x, y, w, h);                  this.value.objects.push(rect);             }         }                   await super.q3979(parse);     }                                                                                    isValid()     {         return super.isValid()             && this.round && this.round.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.round) this.round.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.round) this.round.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.round) this.round.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const rect = new e1782(nodeId, options);                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(rect, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, rect);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             rect.input = t1607(parse);                   const u3571 = genParseParamCount(parse);              for (let i = 0; i < u3571; i++)         {             const i2902 = genParseParamId(parse);                  parse.f1608 = true;                  switch (i2902)             {             case 'x':      rect.x      = t1607(parse); break;             case 'y':      rect.y      = t1607(parse); break;             case 'width':  rect.width  = t1607(parse); break;             case 'height': rect.height = t1607(parse); break;             case 'round':  rect.round  = t1607(parse); break;             case 'props':  rect.props  = t1607(parse); break;             }         }                   parse.f1608 = false;         parse.p3553--;                   genParseNodeEnd(parse, rect);         return rect;     } }


class w1773 extends m1787 {     static { d1855.types[n1202] = this; }        constructor(nodeId, options)     {         super(n1202, nodeId, options);     }        copy()     {         const copy = new w1773(this.nodeId, this.options);          copy.m3266(this);          return copy;     }        x4121(i2902)     {         switch (i2902)         {             case 'x':     return this.input ? this.value.x     : this.x;             case 'y':     return this.input ? this.value.y     : this.y;             case 'width': return this.input ? this.value.width : this.width;         }          return super.x4121(i2902);     }        async eval(parse)     {         if (this.isCached())             return this;           let input = await evalLineValue(this.input, parse);          let [x, y, width, ] = await this.evalBaseParams(parse, false);                       if (input)         {             this.value        = input.toNewValue();             this.value.nodeId = this.nodeId;             this.value.z3532(input);              if (x    )  this.value.x     = x;      else  x     = this.value.x;                   if (y    )  this.value.y     = y;      else  y     = this.value.y;                   if (width)  this.value.width = width;  else  width = this.value.width;           }         else         {             this.value = new m1833(                 this.nodeId,                  x,                  y,                  width);         }           this.h3980(parse,          [             ['x',      x     ],             ['y',      y     ],             ['width',  width ]         ]);           await this.q2806(parse);           await this.q3979(parse);           if (!this.x    ) this.x     = this.value.x    .copy();         if (!this.y    ) this.y     = this.value.y    .copy();         if (!this.width) this.width = this.value.width.copy();           this.validate();          return this;     }        async q3979(parse, options = {})     {         if (!this.options.enabled)             return;                       this.value.objects = [];           if (   super.i2807()                && this.value.x    .isValid()             && this.value.y    .isValid()             && this.value.width.isValid())          {             let x = this.value.x    .value;             let y = this.value.y    .value;             let w = this.value.width.value;               [x, y, w, , , ] = validateObjectRect(x, y, w, 0);               if (w != 0)             {                 const line = new u1655(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     x, y, w);                  line.m3977(x, y);                 line.p3627(x, y, w, 0.01);                                  this.value.objects.push(line);             }         }                   await super.q3979(parse);     }        isValid()     {         return super.isValid()             && this.x     && this.x    .isValid()             && this.y     && this.y    .isValid()             && this.width && this.width.isValid();     }        o3967(parse)     {         super.o3967(parse);           if (this.x    ) this.x    .o3967(parse);         if (this.y    ) this.y    .o3967(parse);         if (this.width) this.width.o3967(parse);     }                   y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.x    ) this.x    .y3968(parse, from, force);         if (this.y    ) this.y    .y3968(parse, from, force);         if (this.width) this.width.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);           if (this.x    ) this.x    .l3966(parse);         if (this.y    ) this.y    .l3966(parse);         if (this.width) this.width.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                     const line = new w1773(nodeId, options);                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(line, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, line);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             line.input = t1607(parse);                   const u3571 = genParseParamCount(parse);              for (let i = 0; i < u3571; i++)         {             const i2902 = genParseParamId(parse);                  parse.f1608 = true;                  switch (i2902)             {             case 'x':     line.x     = t1607(parse); break;             case 'y':     line.y     = t1607(parse); break;             case 'width': line.width = t1607(parse); break;             case 'props': line.props = t1607(parse); break;             }         }                   parse.f1608 = false;         parse.p3553--;                   genParseNodeEnd(parse, line);         return line;     } }


class u1769 extends m1787 {     static { d1855.types[y1205] = this; }        position = null;     round    = null;     start    = null;     sweep    = null;     inner    = null;      innerAbsolute;     startInDegrees;     sweepInDegrees;        constructor(nodeId, options)     {         super(y1205, nodeId, options);     }        reset()     {         super.reset();          this.position = null;         this.round    = null;         this.start    = null;         this.sweep    = null;         this.inner    = null;     }        copy()     {         const copy = new u1769(this.nodeId, this.options);          copy.m3266(this);          if (this.position) copy.position = this.position.copy();         if (this.round   ) copy.round    = this.round   .copy();         if (this.start   ) copy.start    = this.start   .copy();         if (this.sweep   ) copy.sweep    = this.sweep   .copy();         if (this.inner   ) copy.inner    = this.inner   .copy();                  return copy;     }        x4121(i2902)     {         switch (i2902)         {             case 'position': return this.input ? this.value.position : this.position;             case 'x':        return this.input ? this.value.x        : this.x;             case 'y':        return this.input ? this.value.y        : this.y;             case 'width':    return this.input ? this.value.width    : this.width;             case 'height':   return this.input ? this.value.height   : this.height;             case 'round':    return this.input ? this.value.round    : this.round;             case 'start':    return this.input ? this.value.start    : this.start;             case 'sweep':    return this.input ? this.value.sweep    : this.sweep;             case 'inner':    return this.input ? this.value.inner    : this.inner         }          return super.x4121(i2902);     }        async eval(parse)     {         if (this.isCached())             return this;           let input = await evalValue      (this.input,    parse);          let [x, y, width, height] = await this.evalBaseParams(parse);          let pos   = await evalNumberValue(this.position, parse);         let round = await evalNumberValue(this.round,    parse);         let start = await evalNumberValue(this.start,    parse);         let sweep = await evalNumberValue(this.sweep,    parse);         let inner = await evalNumberValue(this.inner,    parse);                                                         if (input)         {             this.value        = input.copy();             this.value.nodeId = this.nodeId;             this.value.z3532(input);              if (pos   )  this.value.position = pos;     else  pos    = this.value.position;             if (x     )  this.value.x        = x;       else  x      = this.value.x;                   if (y     )  this.value.y        = y;       else  y      = this.value.y;                   if (width )  this.value.width    = width;   else  width  = this.value.width;               if (height)  this.value.height   = height;  else  height = this.value.height;              if (round )  this.value.round    = round;   else  round  = this.value.round;               if (start )  this.value.start    = start;   else  start  = this.value.start;             if (sweep )  this.value.sweep    = sweep;   else  sweep  = this.value.sweep;             if (inner )  this.value.inner    = inner;   else  inner  = this.value.inner;           }         else         {             this.value = new v1825(                 this.nodeId,                 pos,                 x,                  y,                  width,                  height,                 round,                 start,                 sweep,                 inner);         }           this.h3980(parse,          [             ['position', pos   ],             ['x',        x     ],             ['y',        y     ],             ['width',    width ],             ['height',   height],             ['round',    round ],             ['start',    start ],             ['sweep',    sweep ],             ['inner',    inner ]         ]);           await this.q2806(parse);           await this.q3979(parse);           this.validate();          return this;     }        async q3979(parse, options = {})     {        if (!this.options.enabled)            return;                                 this.value.objects = [];           if (   super.i2807()             && this.value.x     .isValid()             && this.value.y     .isValid()             && this.value.width .isValid()             && this.value.height.isValid())          {             const vpos = this.value.position;             const vx   = this.value.x;             const vy   = this.value.y;             const vw   = this.value.width;             const vh   = this.value.height;              const _x = vpos.value <= 0 ? vx : new n1835(vx.value - vw.value, Math.max(vx.decimals, vw.decimals));             const _y = vpos.value <= 0 ? vy : new n1835(vy.value - vh.value, Math.max(vy.decimals, vh.decimals));             const _w = vpos.value <= 0 ? vw : new n1835(vw.value*2, Math.max(vx.decimals, vw.decimals));             const _h = vpos.value <= 0 ? vh : new n1835(vh.value*2, Math.max(vy.decimals, vh.decimals));                          let   x  = _x.value;             let   y  = _y.value;             let   w  = _w.value;             let   h  = _h.value;             let   r  = this.value.round .value;             let   st = this.value.start .value;             let   sw = this.value.sweep .value;             let   i  = this.value.inner .value;               [x, y, w, h, , ] = validateObjectRect(x, y, w, h);               if (   w != 0                  && h != 0)             {                 if ( this.innerAbsolute ) i  /= Math.max(w, h) / 200;                 if (!this.startInDegrees) st *= 3.6;                 if ( this.sweepInDegrees) sw /= 3.6;                  const ellipse = new p1653(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     x, y, w, h, r, st, sw, i);                  ellipse.m3977(x, y);                 ellipse.p3627(x, y, w, h);                  this.value.objects.push(ellipse);             }         }           await super.q3979(parse);     }                       isValid()     {         return super.isValid()             && this.position && this.position.isValid()             && this.round    && this.round   .isValid()             && this.start    && this.start   .isValid()             && this.sweep    && this.sweep   .isValid()             && this.inner    && this.inner   .isValid();     }        o3967(parse)     {         super.o3967(parse);           if (this.position) this.position.o3967(parse);         if (this.round   ) this.round   .o3967(parse);         if (this.start   ) this.start   .o3967(parse);         if (this.sweep   ) this.sweep   .o3967(parse);         if (this.inner   ) this.inner   .o3967(parse);     }                   y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.position) this.position.y3968(parse, from, force);         if (this.round   ) this.round   .y3968(parse, from, force);         if (this.start   ) this.start   .y3968(parse, from, force);         if (this.sweep   ) this.sweep   .y3968(parse, from, force);         if (this.inner   ) this.inner   .y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);           if (this.position) this.position.l3966(parse);         if (this.round   ) this.round   .l3966(parse);         if (this.start   ) this.start   .l3966(parse);         if (this.sweep   ) this.sweep   .l3966(parse);         if (this.inner   ) this.inner   .l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const ellipse = new u1769(nodeId, options);                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(ellipse, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, ellipse);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             ellipse.input = t1607(parse);                   const u3571 = genParseParamCount(parse);              for (let i = 0; i < u3571; i++)         {             const i2902 = genParseParamId(parse);                  parse.f1608 = true;                  switch (i2902)             {             case 'position': ellipse.position = t1607(parse); break;             case 'x':        ellipse.x        = t1607(parse); break;             case 'y':        ellipse.y        = t1607(parse); break;             case 'width':    ellipse.width    = t1607(parse); break;             case 'height':   ellipse.height   = t1607(parse); break;             case 'round':    ellipse.round    = t1607(parse); break;             case 'start':    ellipse.start    = t1607(parse); break;             case 'sweep':    ellipse.sweep    = t1607(parse); break;             case 'inner':    ellipse.inner    = t1607(parse); break;             case 'props':    ellipse.props    = t1607(parse); break;             }         }                           ellipse.innerAbsolute  = parseInt(parse.move()) > 0;         ellipse.startInDegrees = parseInt(parse.move()) > 0;         ellipse.sweepInDegrees = parseInt(parse.move()) > 0;                   parse.f1608 = false;         parse.p3553--;                   genParseNodeEnd(parse, ellipse);         return ellipse;     } }


class j1793 extends m1787 {     static { d1855.types[s1208] = this; }        round = null;     bias  = null;        constructor(nodeId, options)     {         super(s1208, nodeId, options);     }        reset()     {         super.reset();          this.round = null;         this.bias  = null;     }        copy()     {         const copy = new j1793(this.nodeId, this.options);          copy.m3266(this);          if (this.round) copy.round = this.round.copy();         if (this.bias ) copy.bias  = this.bias .copy();          return copy;     }        x4121(i2902)     {         switch (i2902)         {             case 'x':      return this.input ? this.value.x      : this.x;             case 'y':      return this.input ? this.value.y      : this.y;             case 'width':  return this.input ? this.value.width  : this.width;             case 'height': return this.input ? this.value.height : this.height;             case 'round':  return this.input ? this.value.round  : this.round;             case 'bias':   return this.input ? this.value.bias   : this.bias;         }          return super.x4121(i2902);     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalValue      (this.input, parse);         let   round = await evalNumberValue(this.round, parse);         let   bias  = await evalNumberValue(this.bias,  parse);                  let [x, y, width, height] = await this.evalBaseParams(parse);           if (input)         {             this.value        = input.toNewValue();             this.value.nodeId = this.nodeId;             this.value.z3532(input);              if (x     )  this.value.x      = x;       else  x      = this.value.x;                   if (y     )  this.value.y      = y;       else  y      = this.value.y;                   if (width )  this.value.width  = width;   else  width  = this.value.width;               if (height)  this.value.height = height;  else  height = this.value.height;              if (round )  this.value.round  = round;   else  round  = this.value.round;               if (bias  )  this.value.bias   = bias;    else  bias   = this.value.bias;           }         else         {             this.value = new p1847(                 this.nodeId,                  x,                  y,                  width,                  height,                  round,                 bias);         }                  this.h3980(parse,          [             ['x',      x     ],             ['y',      y     ],             ['width',  width ],             ['height', height],             ['round',  round ],             ['bias',   bias  ]         ]);           await this.q2806(parse);           await this.q3979(parse);           if (!this.x     ) this.x      = this.value.x     .copy();         if (!this.y     ) this.y      = this.value.y     .copy();         if (!this.width ) this.width  = this.value.width .copy();         if (!this.height) this.height = this.value.height.copy();         if (!this.round ) this.round  = this.value.round .copy();         if (!this.bias  ) this.bias   = this.value.bias  .copy();           this.validate();          return this;     }        async q3979(parse, options = {})     {         if (!this.options.enabled)             return;                        this.value.objects = [];           if (   super.i2807()                && this.value.x     .isValid()                 && this.value.y     .isValid()                 && this.value.width .isValid()             && this.value.height.isValid()             && this.value.round .isValid()             && this.value.bias  .isValid())         {             let   x = this.value.x     .value;             let   y = this.value.y     .value;             let   w = this.value.width .value;             let   h = this.value.height.value;             const r = Math.max(0, this.value.round.value);             let   b = this.value.bias  .value;               [x, y, w, h, , ] = validateObjectRect(x, y, w, h);               if (   w != 0                  && h != 0)             {                 const trapeze = new b1664(                     this.nodeId,                      this.nodeId,                      this.nodeName,                      x, y, w, h, r, b);                  trapeze.m3977(x, y);                 trapeze.p3627(x, y, w, h);                  this.value.objects.push(trapeze);             }         }           await super.q3979(parse);     }        isValid()     {         return super.isValid()             && this.round && this.round.isValid()             && this.bias  && this.bias .isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.round) this.round.o3967(parse);         if (this.bias ) this.bias .o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.round) this.round.y3968(parse, from, force);         if (this.bias ) this.bias .y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.round) this.round.l3966(parse);         if (this.bias ) this.bias .l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const trapeze = new j1793(nodeId, options);                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(trapeze, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, trapeze);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             trapeze.input = t1607(parse);                   const u3571 = genParseParamCount(parse);              for (let i = 0; i < u3571; i++)         {             const i2902 = genParseParamId(parse);                  parse.f1608 = true;                  switch (i2902)             {             case 'x':      trapeze.x      = t1607(parse); break;             case 'y':      trapeze.y      = t1607(parse); break;             case 'width':  trapeze.width  = t1607(parse); break;             case 'height': trapeze.height = t1607(parse); break;             case 'round':  trapeze.round  = t1607(parse); break;             case 'bias':   trapeze.bias   = t1607(parse); break;             case 'props':  trapeze.props  = t1607(parse); break;             }         }                           parse.f1608 = false;         parse.p3553--;                   genParseNodeEnd(parse, trapeze);         return trapeze;     } }


class o1781 extends m1787 {     static { d1855.types[z1217] = this; }        position = null;     round    = null;     corners  = null;        constructor(nodeId, options)     {         super(z1217, nodeId, options);     }        reset()     {         super.reset();          this.position = null;         this.round    = null;         this.corners  = null;     }        copy()     {         const copy = new o1781(this.nodeId, this.options);          copy.m3266(this);          if (this.position) copy.position = this.position.copy();         if (this.round   ) copy.round    = this.round   .copy();         if (this.corners ) copy.corners  = this.corners .copy();          return copy;     }        x4121(i2902)     {         switch (i2902)         {             case 'position': return this.input ? this.value.position : this.position;             case 'x':        return this.input ? this.value.x        : this.x;             case 'y':        return this.input ? this.value.y        : this.y;             case 'width':    return this.input ? this.value.width    : this.width;             case 'height':   return this.input ? this.value.height   : this.height;             case 'round':    return this.input ? this.value.round    : this.round;             case 'corners':  return this.input ? this.value.corners  : this.corners;         }          return super.x4121(i2902);     }        async eval(parse)     {         if (this.isCached())             return this;                       let [x, y, width, height] = await this.evalBaseParams(parse);          let input   = await evalPolygonValue(this.input,    parse);         let pos     = await evalNumberValue (this.position, parse);         let round   = await evalNumberValue (this.round,    parse);         let corners = await evalNumberValue (this.corners,  parse);           if (input)         {             this.value        = input.toNewValue();             this.value.nodeId = this.nodeId;             this.value.z3532(input);              if (pos    )  this.value.position = pos;      else  pos     = this.value.position;             if (x      )  this.value.x        = x;        else  x       = this.value.x;                   if (y      )  this.value.y        = y;        else  y       = this.value.y;                   if (width  )  this.value.width    = width;    else  width   = this.value.width;               if (height )  this.value.height   = height;   else  height  = this.value.height;              if (round  )  this.value.round    = round;    else  round   = this.value.round;               if (corners)  this.value.corners  = corners;  else  corners = this.value.corners;           }         else         {             this.value = new x1837(                 this.nodeId,                 pos,                 x,                  y,                  width,                  height,                 round,                 corners);         }           this.h3980(parse,          [             ['position', pos    ],             ['x',        x      ],             ['y',        y      ],             ['width',    width  ],             ['height',   height ],             ['round',    round  ],             ['corners',  corners]         ]);           await this.q2806(parse);           await this.q3979(parse);           if (!this.position) this.position = this.value.position.copy();         if (!this.x       ) this.x        = this.value.x       .copy();         if (!this.y       ) this.y        = this.value.y       .copy();         if (!this.width   ) this.width    = this.value.width   .copy();         if (!this.height  ) this.height   = this.value.height  .copy();         if (!this.round   ) this.round    = this.value.round   .copy();         if (!this.corners ) this.corners  = this.value.corners .copy();           this.validate();          return this;     }        async q3979(parse, options = {})     {         if (!this.options.enabled)             return;                                   this.value.objects = [];           if (   super.i2807()                && this.value.x      .isValid()             && this.value.y      .isValid()             && this.value.width  .isValid()             && this.value.height .isValid()             && this.value.round  .isValid()             && this.value.corners.isValid())         {             const vpos = this.value.position;             const vx   = this.value.x;             const vy   = this.value.y;             const vw   = this.value.width;             const vh   = this.value.height;              const _x = vpos.value <= 0 ? vx : new n1835(vx.value - vw.value, Math.max(vx.decimals, vw.decimals));             const _y = vpos.value <= 0 ? vy : new n1835(vy.value - vh.value, Math.max(vy.decimals, vh.decimals));             const _w = vpos.value <= 0 ? vw : new n1835(vw.value*2, Math.max(vx.decimals, vw.decimals));             const _h = vpos.value <= 0 ? vh : new n1835(vh.value*2, Math.max(vy.decimals, vh.decimals));                          let   x = _x.value;             let   y = _y.value;             let   w = _w.value;             let   h = _h.value;             const r = Math.max(0, this.value.round.value);             const c = Math.max(3, Math.floor(this.value.corners.value));               [x, y, w, h, , ] = validateObjectRect(x, y, w, h);               if (   w != 0                  && h != 0)             {                 const poly = new m1658(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     x, y, w, h, r, c);                  poly.m3977(x, y);                 poly.p3627(x, y, w, h);                  this.value.objects.push(poly);             }         }                   await super.q3979(parse);     }                                                                                              isValid()     {         return super.isValid()             && this.position && this.position.isValid()             && this.round    && this.round   .isValid()             && this.corners  && this.corners .isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.position) this.position.o3967(parse);         if (this.round   ) this.round   .o3967(parse);         if (this.corners ) this.corners .o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.position) this.position.y3968(parse, from, force);         if (this.round   ) this.round   .y3968(parse, from, force);         if (this.corners ) this.corners .y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.position) this.position.l3966(parse);         if (this.round   ) this.round   .l3966(parse);         if (this.corners ) this.corners .l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const poly = new o1781(nodeId, options);                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(poly, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, poly);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             poly.input = t1607(parse);                   const u3571 = genParseParamCount(parse);              for (let i = 0; i < u3571; i++)         {             const i2902 = genParseParamId(parse);                  parse.f1608 = true;                  switch (i2902)             {             case 'position': poly.position = t1607(parse); break;             case 'x':        poly.x        = t1607(parse); break;             case 'y':        poly.y        = t1607(parse); break;             case 'width':    poly.width    = t1607(parse); break;             case 'height':   poly.height   = t1607(parse); break;             case 'round':    poly.round    = t1607(parse); break;             case 'corners':  poly.corners  = t1607(parse); break;             case 'props':    poly.props    = t1607(parse); break;             }         }                           parse.f1608 = false;         parse.p3553--;                   genParseNodeEnd(parse, poly);         return poly;     } }


 class g1791 extends m1787 {     static { d1855.types[m1220] = this; }        position = null;     round    = null;     points   = null;     convex   = null;        constructor(nodeId, options)     {         super(m1220, nodeId, options);     }        reset()     {         super.reset();          this.position = null;         this.round    = null;         this.points   = null;         this.convex   = null;     }        copy()     {         const copy = new g1791(this.nodeId, this.options);          copy.m3266(this);          if (this.position) copy.position = this.position.copy();         if (this.round   ) copy.round    = this.round   .copy();         if (this.points  ) copy.points   = this.points  .copy();         if (this.convex  ) copy.convex   = this.convex  .copy();          return copy;     }        x4121(i2902)     {         switch (i2902)         {             case 'position': return this.input ? this.value.position : this.position;             case 'x':        return this.input ? this.value.x        : this.x;             case 'y':        return this.input ? this.value.y        : this.y;             case 'width':    return this.input ? this.value.width    : this.width;             case 'height':   return this.input ? this.value.height   : this.height;             case 'round':    return this.input ? this.value.round    : this.round;             case 'points':   return this.input ? this.value.points   : this.points;             case 'convex':   return this.input ? this.value.convex   : this.convex;         }          return super.x4121(i2902);     }        async eval(parse)     {         if (this.isCached())             return this;                       let [x, y, width, height] = await this.evalBaseParams(parse);          let input  = await evalValue      (this.input,    parse);         let pos    = await evalNumberValue(this.position, parse);         let round  = await evalNumberValue(this.round,    parse);         let points = await evalNumberValue(this.points,   parse);         let convex = await evalNumberValue(this.convex,   parse);           if (input)         {             this.value        = input.toNewValue();             this.value.nodeId = this.nodeId;             this.value.z3532(input);              if (pos   )  this.value.position = pos;     else  pos    = this.value.position;             if (x     )  this.value.x        = x;       else  x      = this.value.x;                   if (y     )  this.value.y        = y;       else  y      = this.value.y;                   if (width )  this.value.width    = width;   else  width  = this.value.width;               if (height)  this.value.height   = height;  else  height = this.value.height;              if (round )  this.value.round    = round;   else  round  = this.value.round;               if (points)  this.value.points   = points;  else  points = this.value.points;               if (convex)  this.value.convex   = convex;  else  convex = this.value.convex;          }         else         {             this.value = new a1843(                 this.nodeId,                 pos,                 x,                  y,                  width,                  height,                 round,                 points,                 convex);         }           this.h3980(parse,          [             ['position', pos   ],             ['x',        x     ],             ['y',        y     ],             ['width',    width ],             ['height',   height],             ['round',    round ],             ['points',   points],             ['convex',   convex]         ]);           await this.q2806(parse);           await this.q3979(parse);           if (!this.position) this.position = this.value.position.copy();         if (!this.x       ) this.x        = this.value.x       .copy();         if (!this.y       ) this.y        = this.value.y       .copy();         if (!this.width   ) this.width    = this.value.width   .copy();         if (!this.height  ) this.height   = this.value.height  .copy();         if (!this.round   ) this.round    = this.value.round   .copy();         if (!this.points  ) this.points   = this.value.points  .copy();         if (!this.convex  ) this.convex   = this.value.convex  .copy();            this.validate();          return this;    }       async q3979(parse, options = {})    {         if (!this.options.enabled)            return;                                 this.value.objects = [];           if (   super.i2807()                && this.value.x     .isValid()             && this.value.y     .isValid()             && this.value.width .isValid()             && this.value.height.isValid()              && this.value.round .isValid()             && this.value.points.isValid()             && this.value.convex.isValid())         {             const vpos = this.value.position;             const vx   = this.value.x;             const vy   = this.value.y;             const vw   = this.value.width;             const vh   = this.value.height;              const _x = vpos.value <= 0 ? vx : new n1835(vx.value - vw.value, Math.max(vx.decimals, vw.decimals));             const _y = vpos.value <= 0 ? vy : new n1835(vy.value - vh.value, Math.max(vy.decimals, vh.decimals));             const _w = vpos.value <= 0 ? vw : new n1835(vw.value*2, Math.max(vx.decimals, vw.decimals));             const _h = vpos.value <= 0 ? vh : new n1835(vh.value*2, Math.max(vy.decimals, vh.decimals));                          let   x = _x.value;             let   y = _y.value;             let   w = _w.value;             let   h = _h.value;             const r = Math.max(0, this.value.round.value);             const p = Math.max(3, Math.floor(this.value.points.value));             const c = this.value.convex.value;               if (   w != 0                 && h != 0)             {                 const star = new a1662(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     x, y, w, h, r, p, c);                  star.m3977(x, y);                 star.p3627(x, y, w, h);                  this.value.objects.push(star);             }         }                  await super.q3979(parse);     }                                                                                                    isValid()     {         return super.isValid()             && this.position && this.position.isValid()             && this.round    && this.round   .isValid()             && this.points   && this.points  .isValid()             && this.convex   && this.convex  .isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.position) this.position.o3967(parse);         if (this.round   ) this.round   .o3967(parse);         if (this.points  ) this.points  .o3967(parse);         if (this.convex  ) this.convex  .o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.position) this.position.y3968(parse, from, force);         if (this.round   ) this.round   .y3968(parse, from, force);         if (this.points  ) this.points  .y3968(parse, from, force);         if (this.convex  ) this.convex  .y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.position) this.position.l3966(parse);         if (this.round   ) this.round   .l3966(parse);         if (this.points  ) this.points  .l3966(parse);         if (this.convex  ) this.convex  .l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const star = new g1791(nodeId, options);                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(star, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, star);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             star.input = t1607(parse);                   const u3571 = genParseParamCount(parse);              for (let i = 0; i < u3571; i++)         {             const i2902 = genParseParamId(parse);                  parse.f1608 = true;                  switch (i2902)             {             case 'position': star.position = t1607(parse); break;             case 'x':        star.x        = t1607(parse); break;             case 'y':        star.y        = t1607(parse); break;             case 'width':    star.width    = t1607(parse); break;             case 'height':   star.height   = t1607(parse); break;             case 'round':    star.round    = t1607(parse); break;             case 'points':   star.points   = t1607(parse); break;             case 'convex':   star.convex   = t1607(parse); break;             case 'props':    star.props    = t1607(parse); break;             }         }                           parse.f1608 = false;         parse.p3553--;                   genParseNodeEnd(parse, star);         return star;     } }


class h1792 extends m1787 {     static { d1855.types[d1223] = this; }        text          = null;     x             = null;     y             = null;     width         = null;     height        = null;     font          = null;     size          = null;     style         = null;     alignX        = null;     alignY        = null;     lineHeight    = null;     letterSpacing = null;                constructor(nodeId, options)     {         super(d1223, nodeId, options);     }            reset()     {         super.reset();                  this.text          = null;         this.x             = null;         this.y             = null;         this.width         = null;         this.height        = null;         this.font          = null;         this.size          = null;         this.style         = null;         this.alignX        = null;         this.alignY        = null;         this.lineHeight    = null;         this.letterSpacing = null;     }        copy()     {         const copy = new h1792(this.nodeId, this.options);          copy.m3266(this);          if (this.text         ) copy.text          = this.text         .copy();         if (this.x            ) copy.x             = this.x            .copy();         if (this.y            ) copy.y             = this.y            .copy();         if (this.width        ) copy.width         = this.width        .copy();         if (this.height       ) copy.height        = this.height       .copy();         if (this.font         ) copy.font          = this.font         .copy();         if (this.style        ) copy.style         = this.style        .copy();         if (this.size         ) copy.size          = this.size         .copy();         if (this.alignX       ) copy.alignX        = this.alignX       .copy();         if (this.alignY       ) copy.alignY        = this.alignY       .copy();         if (this.lineHeight   ) copy.lineHeight    = this.lineHeight   .copy();         if (this.letterSpacing) copy.letterSpacing = this.letterSpacing.copy();          return copy;     }        x4121(i2902)     {         switch (i2902)         {             case 'text':          return this.input ? this.value.text          : this.text;             case 'x':             return this.input ? this.value.x             : this.x;             case 'y':             return this.input ? this.value.y             : this.y;             case 'width':         return this.input ? this.value.width         : this.width;             case 'height':        return this.input ? this.value.height        : this.height;             case 'font':          return this.input ? this.value.font          : this.font;             case 'style':         return this.input ? this.value.style         : this.style;             case 'size':          return this.input ? this.value.size          : this.size;             case 'alignX':        return this.input ? this.value.alignX        : this.alignX;             case 'alignY':        return this.input ? this.value.alignY        : this.alignY;             case 'lineHeight':    return this.input ? this.value.lineHeight    : this.lineHeight;             case 'letterSpacing': return this.input ? this.value.letterSpacing : this.letterSpacing;         }          return super.x4121(i2902);     }        async eval(parse)     {         if (this.isCached())             return this;           const input         = await evalTextShapeValue(this.input,         parse);         let   text          = await evalTextValue     (this.text,          parse);         let   x             = await evalNumberValue   (this.x,             parse);         let   y             = await evalNumberValue   (this.y,             parse);         let   width         = await evalNumberValue   (this.width,         parse);         let   height        = await evalNumberValue   (this.height,        parse);         let   font          = await evalNumberValue   (this.font,          parse);         let   style         = await evalNumberValue   (this.style,         parse);         let   size          = await evalNumberValue   (this.size,          parse);         let   alignX        = await evalNumberValue   (this.alignX,        parse);         let   alignY        = await evalNumberValue   (this.alignY,        parse);         let   lineHeight    = await evalNumberValue   (this.lineHeight,    parse);         let   letterSpacing = await evalNumberValue   (this.letterSpacing, parse);           if (text          && !text         .isValid()) text          = new e1846();         if (x             && !x            .isValid()) x             = n1835.NaN();         if (y             && !y            .isValid()) y             = n1835.NaN();         if (width         && !width        .isValid()) width         = n1835.NaN();         if (height        && !height       .isValid()) height        = n1835.NaN();         if (font          && !font         .isValid()) font          = n1835.NaN();         if (style         && !style        .isValid()) style         = n1835.NaN();         if (size          && !size         .isValid()) size          = n1835.NaN();         if (alignX        && !alignX       .isValid()) alignX        = n1835.NaN();         if (alignY        && !alignY       .isValid()) alignY        = n1835.NaN();         if (lineHeight    && !lineHeight   .isValid()) lineHeight    = n1835.NaN();         if (letterSpacing && !letterSpacing.isValid()) letterSpacing = n1835.NaN();                    if (text          && text         .type !=   q1123) text          = new e1846();         if (x             && x            .type != e1090) x             = n1835.NaN();         if (y             && y            .type != e1090) y             = n1835.NaN();         if (width         && width        .type != e1090) width         = n1835.NaN();         if (height        && height       .type != e1090) height        = n1835.NaN();         if (font          && font         .type != e1090) font          = n1835.NaN();         if (style         && style        .type != e1090) style         = n1835.NaN();         if (size          && size         .type != e1090) size          = n1835.NaN();         if (alignX        && alignX       .type != e1090) alignX        = n1835.NaN();         if (alignY        && alignY       .type != e1090) alignY        = n1835.NaN();         if (lineHeight    && lineHeight   .type != e1090) lineHeight    = n1835.NaN();         if (letterSpacing && letterSpacing.type != e1090) letterSpacing = n1835.NaN();                   if (input)         {             this.value        = input.toNewValue();             this.value.nodeId = this.nodeId;             this.value.z3532(input);                          if (text         )  this.value.text          = text;           else  text          = this.value.text;             if (x            )  this.value.x             = x;              else  x             = this.value.x;             if (y            )  this.value.y             = y;              else  y             = this.value.y;             if (width        )  this.value.width         = width;          else  width         = this.value.width;             if (height       )  this.value.height        = height;         else  height        = this.value.height;             if (font         )  this.value.font          = font;           else  font          = this.value.font;             if (style        )  this.value.style         = style;          else  style         = this.value.style;             if (size         )  this.value.size          = size;           else  size          = this.value.size;             if (alignX       )  this.value.alignX        = alignX;         else  alignX        = this.value.alignX;             if (alignY       )  this.value.alignY        = alignY;         else  alignY        = this.value.alignY;             if (lineHeight   )  this.value.lineHeight    = lineHeight;     else  lineHeight    = this.value.lineHeight;             if (letterSpacing)  this.value.letterSpacing = letterSpacing;  else  letterSpacing = this.value.letterSpacing;          }         else         {             this.value = new l1845(                 this.nodeId,                  text,                  x,                  y,                  width,                  height,                  font,                  style,                 size,                 alignX,                 alignY,                 lineHeight,                 letterSpacing);         }                  this.h3980(parse,          [             ['text',          text         ],             ['x',             x            ],             ['y',             y            ],             ['width',         width        ],             ['height',        height       ],             ['font',          font         ],             ['style',         style        ],             ['size',          size         ],             ['alignX',        alignX       ],             ['alignY',        alignY       ],             ['lineHeight',    lineHeight   ],             ['letterSpacing', letterSpacing]         ]);           await this.q2806(parse);           await this.q3979(parse);           if (!this.text         ) this.text          = this.value.text         .copy();         if (!this.x            ) this.x             = this.value.x            .copy();         if (!this.y            ) this.y             = this.value.y            .copy();         if (!this.width        ) this.width         = this.value.width        .copy();         if (!this.height       ) this.height        = this.value.height       .copy();         if (!this.font         ) this.font          = this.value.font         .copy();         if (!this.style        ) this.style         = this.value.style        .copy();         if (!this.size         ) this.size          = this.value.size         .copy();         if (!this.alignX       ) this.alignX        = this.value.alignX       .copy();         if (!this.alignY       ) this.alignY        = this.value.alignY       .copy();         if (!this.lineHeight   ) this.lineHeight    = this.value.lineHeight   .copy();         if (!this.letterSpacing) this.letterSpacing = this.value.letterSpacing.copy();                   this.validate();          return this;     }        async q3979(parse, options = {})     {         if (!this.options.enabled)             return;                   this.value.objects = [];           if (   super.i2807()                && this.value.text         .isValid()             && this.value.x            .isValid()             && this.value.y            .isValid()             && this.value.width        .isValid()             && this.value.height       .isValid()             && this.value.font         .isValid()             && this.value.style        .isValid()             && this.value.size         .isValid()             && this.value.alignX       .isValid()             && this.value.alignY       .isValid()             && this.value.lineHeight   .isValid()             && this.value.letterSpacing.isValid())         {             let x = this.value.x     .value;             let y = this.value.y     .value;             let w = this.value.width .value;             let h = this.value.height.value;              const fontName   = n3920[this.value.font.value];             const fontStyles = getFontStyles(fontName);              const text = new y1663(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 this.value.text.value,                 x, y, w, h,                 fontName,                 this.value.size         .value,                 fontStyles[Math.min(this.value.style.value, fontStyles.length-1)],                 this.value.alignX       .value,                 this.value.alignY       .value,                 this.value.lineHeight   .value,                 this.value.letterSpacing.value);                               text.m3977(x, y);                                                                                                                                                                                                text.p3627(x, y, w, h);                  this.value.objects.push(text);                      }                   await super.q3979(parse);     }        isValid()     {         return super.isValid()             && this.text          && this.text         .isValid()             && this.x             && this.x            .isValid()             && this.y             && this.y            .isValid()             && this.width         && this.width        .isValid()             && this.height        && this.height       .isValid()             && this.font          && this.font         .isValid()             && this.style         && this.style        .isValid()             && this.size          && this.size         .isValid()             && this.alignX        && this.alignX       .isValid()             && this.alignY        && this.alignY       .isValid()             && this.lineHeight    && this.lineHeight   .isValid()             && this.letterSpacing && this.letterSpacing.isValid();     }        o3967(parse)     {         super.o3967(parse);                  if (this.text         ) this.text         .o3967(parse);         if (this.x            ) this.x            .o3967(parse);         if (this.y            ) this.y            .o3967(parse);         if (this.width        ) this.width        .o3967(parse);         if (this.height       ) this.height       .o3967(parse);         if (this.font         ) this.font         .o3967(parse);         if (this.style        ) this.style        .o3967(parse);         if (this.size         ) this.size         .o3967(parse);         if (this.alignX       ) this.alignX       .o3967(parse);         if (this.alignY       ) this.alignY       .o3967(parse);         if (this.lineHeight   ) this.lineHeight   .o3967(parse);         if (this.letterSpacing) this.letterSpacing.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);                  if (this.text         ) this.text         .y3968(parse, from, force);         if (this.x            ) this.x            .y3968(parse, from, force);         if (this.y            ) this.y            .y3968(parse, from, force);         if (this.width        ) this.width        .y3968(parse, from, force);         if (this.height       ) this.height       .y3968(parse, from, force);         if (this.font         ) this.font         .y3968(parse, from, force);         if (this.style        ) this.style        .y3968(parse, from, force);         if (this.size         ) this.size         .y3968(parse, from, force);         if (this.alignX       ) this.alignX       .y3968(parse, from, force);         if (this.alignY       ) this.alignY       .y3968(parse, from, force);         if (this.lineHeight   ) this.lineHeight   .y3968(parse, from, force);         if (this.letterSpacing) this.letterSpacing.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);                  if (this.text         ) this.text         .l3966(parse);         if (this.x            ) this.x            .l3966(parse);         if (this.y            ) this.y            .l3966(parse);         if (this.width        ) this.width        .l3966(parse);         if (this.height       ) this.height       .l3966(parse);         if (this.font         ) this.font         .l3966(parse);         if (this.style        ) this.style        .l3966(parse);         if (this.size         ) this.size         .l3966(parse);         if (this.alignX       ) this.alignX       .l3966(parse);         if (this.alignY       ) this.alignY       .l3966(parse);         if (this.lineHeight   ) this.lineHeight   .l3966(parse);         if (this.letterSpacing) this.letterSpacing.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const text = new h1792(nodeId, options);                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(text, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, text);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             text.input = t1607(parse);                   const u3571 = genParseParamCount(parse);              for (let i = 0; i < u3571; i++)         {             const i2902 = genParseParamId(parse);                  parse.f1608 = true;                  switch (i2902)             {                    case 'text':          text.text          = t1607(parse); break;             case 'x':             text.x             = t1607(parse); break;             case 'y':             text.y             = t1607(parse); break;             case 'width':         text.width         = t1607(parse); break;             case 'height':        text.height        = t1607(parse); break;             case 'font':          text.font          = t1607(parse); break;             case 'size':          text.size          = t1607(parse); break;             case 'style':         text.style         = t1607(parse); break;             case 'props':         text.props         = t1607(parse); break;             case 'alignX':        text.alignX        = t1607(parse); break;             case 'alignY':        text.alignY        = t1607(parse); break;             case 'lineHeight':    text.lineHeight    = t1607(parse); break;             case 'letterSpacing': text.letterSpacing = t1607(parse); break;             }         }                   parse.f1608 = false;         parse.p3553--;                   genParseNodeEnd(parse, text);         return text;     } }


class l1777 extends y1857 {     static { d1855.types[y1226] = this; }        x = null;     y = null;        constructor(nodeId, options)     {         super(y1226, nodeId, options);     }        reset()     {         super.reset();          this.x = null;         this.y = null;     }        copy()     {         const copy = new l1777(this.nodeId, this.options);          copy.m3266(this);          if (this.value) copy.value = this.value.copy();         if (this.x    ) copy.x     = this.x    .copy();         if (this.y    ) copy.y     = this.y    .copy();          return copy;     }        x4121(i2902)     {         switch (i2902)         {             case 'x': return this.input ? this.value.x : this.x;             case 'y': return this.input ? this.value.y : this.y;         }          return null;     }        async eval(parse)     {         if (this.isCached())             return this;                   let input = await evalPointValue (this.input, parse);         let x     = await evalNumberValue(this.x,     parse);         let y     = await evalNumberValue(this.y,     parse);           if (   input             && input.isValid())         {             const s3709 = input;              if (input.type == r1232)             {                 input = new r1836(input.nodeId, input.x, input.y);                 input.z3532(s3709);             }                          this.value        = input;             this.value.nodeId = this.nodeId;             this.value.z3532(input);               if (   this.value.objects                 && this.value.objects.length > 0)             {                 this.value.x = new n1835(this.value.objects[0].x);                 this.value.y = new n1835(this.value.objects[0].y);             }                          if (x)  this.value.x = x;  else  x = this.value.x;             if (y)  this.value.y = y;  else  y = this.value.y;         }         else if (x                && y)         {             this.value = new r1836(                 this.nodeId,                  x,                  y);         }         else             this.value = r1836.NaN();           this.value.c3633 = this.c3633;           await this.q3979(parse);           this.h3980(parse,          [             ['x', x],             ['y', y]         ]);               this.validate();          return this;     }        async q3979(parse, options = {})     {         if (!this.options.enabled)             return;                                   if (!this.value.objects)             this.value.objects = [];           if (   this.value.x             && this.value.y                && this.value.x.isValid()             && this.value.y.isValid())         {             const x = this.value.x.value;             const y = this.value.y.value;              const point = new s1657(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 x,                 y,                 this.smooth ? this.smooth.value/100 : 1);              point.m3977(x, y);              this.value.objects = [point];         }           await super.q3979(parse);     }        isValid()     {         return super.isValid()             && this.x && this.x.isValid()             && this.y && this.y.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.x) this.x.o3967(parse);         if (this.y) this.y.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.x) this.x.y3968(parse, from, force);         if (this.y) this.y.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.x) this.x.l3966(parse);         if (this.y) this.y.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const point = new l1777(nodeId, options);                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(point, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, point);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             point.input = t1607(parse);                   const u3571 = genParseParamCount(parse);              for (let i = 0; i < u3571; i++)         {             const i2902 = genParseParamId(parse);                  parse.f1608 = true;                  switch (i2902)             {             case 'x': point.x = t1607(parse); break;             case 'y': point.y = t1607(parse); break;             }         }                   parse.f1608 = false;         parse.p3553--;                   genParseNodeEnd(parse, point);         return point;     } }


class j1778 extends y1857 {     static { d1855.types[z1228] = this; }        smooth = null;        constructor(nodeId, options)     {         super(z1228, nodeId, options);     }        reset()     {         super.reset();          this.smooth = null;     }        copy()     {         const copy = new j1778(this.nodeId, this.options);          copy.m3266(this);          if (this.value ) copy.value  = this.value .copy();         if (this.smooth) copy.smooth = this.smooth.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                   const input  = await evalPointValue (this.input,  parse);         const smooth = await evalNumberValue(this.smooth, parse);                  if (input)         {             this.value        = input;             this.value.nodeId = this.nodeId;             this.value.z3532(input);              this.value.smooth = smooth;               if (   this.value.objects                 && this.value.objects.length > 0)             {                 this.value.x = new n1835(this.value.objects[0].x);                 this.value.y = new n1835(this.value.objects[0].y);             }         }         else             this.value = r1836.NaN();           await this.q3979(parse);           this.h3980(parse,          [             ['smooth', smooth]         ]);           this.validate();          return this;     }        async q3979(parse, options = {})     {         if (!this.options.enabled)             return;                                   this.value.objects = [];           if (   this.value.x.isValid()             && this.value.y.isValid())         {             const x      = this.value.x.value;             const y      = this.value.y.value;             const smooth = this.value.smooth ? this.value.smooth.value/100 : 1;              const point = new s1657(                 this.nodeId,                  this.nodeId,                  this.nodeName,                  x,                  y,                  smooth);              point.m3977(x, y);              this.value.objects = [point];         }           await super.q3979(parse);     }        toNewValue()     {         return this.value.copy();                                                    }        isValid()     {         return super.isValid()             && this.smooth && this.smooth.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.smooth) this.smooth.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.smooth) this.smooth.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.smooth) this.smooth.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const corner = new j1778(nodeId, options);                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(corner, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, corner);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             corner.input = t1607(parse);              corner.smooth = t1607(parse);                   parse.f1608 = false;         parse.p3553--;                   genParseNodeEnd(parse, corner);         return corner;     } }


class m1797 extends m1787 {     static { d1855.types[o1230] = this; }        points  = null;     closed  = null;     degree  = null;     winding = null;     round   = null;        constructor(nodeId, options)     {         super(o1230, nodeId, options);     }        reset()     {         super.reset();          this.points  = null;         this.closed  = null;         this.degree  = null;         this.winding = null;         this.round   = null;     }        copy()     {         const copy = new m1797(this.nodeId, this.options);          copy.m3266(this);          if (this.points ) copy.points  = this.points .copy();         if (this.closed ) copy.closed  = this.closed .copy();         if (this.degree ) copy.degree  = this.degree .copy();         if (this.winding) copy.winding = this.winding.copy();         if (this.round  ) copy.round   = this.round  .copy();          return copy;     }        x4121(i2902)     {         switch (i2902)         {             case 'points':  return this.input ? this.value.points  : this.points;             case 'closed':  return this.input ? this.value.closed  : this.closed;             case 'degree':  return this.input ? this.value.degree  : this.degree;             case 'winding': return this.input ? this.value.winding : this.winding;             case 'round':   return this.input ? this.value.round   : this.round;         }          return super.x4121(i2902);     }        async eval(parse)     {         if (this.isCached())             return this;           const input   = await evalVectorPathValue(this.input,   parse);         let   points  = await evalNumberValue    (this.points,  parse);         let   closed  = await evalNumberValue    (this.closed,  parse);         let   degree  = await evalNumberValue    (this.degree,  parse);         let   winding = await evalNumberValue    (this.winding, parse);         let   round   = await evalNumberValue    (this.round,   parse);           await this.evalBaseParams(parse);           if (input)         {                                                    if (   input.points                 && input.points.items                 && input.points.objects)             {                 r950(                      input.points.items.length == input.points.objects.length,                     'Vector path points input item count must match object count');                  for (let i = 0; i < input.points.items.length; i++)                 {                     const item = input.points.items  [i].copy();                     const c111  = input.points.objects[i].copy();                      if (item && c111)                     {                         item.x = new n1835(c111.x);                         item.y = new n1835(c111.y);                     }                 }             }               this.value = new n1850(                 this.nodeId,                    points                  && points.items.length > 0                  ? points                 : input.points,                 closed  ?? input.closed,                 degree  ?? input.degree,                 winding ?? input.winding,                 round   ?? input.round);              this.value.z3532(input);                           if (points )  this.value.points   = points;   else  points  = this.value.points;                 if (closed )  this.value.closed   = closed;   else  closed  = this.value.closed;                 if (degree )  this.value.degree   = degree;   else  degree  = this.value.degree;               if (winding)  this.value.windingt = winding;  else  winding = this.value.winding;              if (round  )  this.value.round    = round;    else  round   = this.value.round;           }         else         {             this.value = new n1850(                 this.nodeId,                  points,                  closed,                  degree,                  winding,                  round);         }                   this.h3980(parse,          [                        ['closed',  closed ],             ['degree',  degree ],             ['winding', winding],             ['round',   round  ]         ]);           await this.q2806(parse);           await this.q3979(parse);           this.validate();          return this;     }        async q3979(parse, options = {})     {         if (!this.options.enabled)             return;                       const points = [];          if (this.value.points.objects)         {             const d3981 = this.value.points.objects.filter(o => o.type == y1226);              for (const pt of d3981)             {                 const p = r1836.create(this.nodeId, pt.x, pt.y);                                  if (pt.smooth != null)                     p.smooth = new n1835(pt.smooth);                  points.push(p);             }         }           this.value.objects = [];           if (   super.i2807()                && points.length >= 2             && this.value.closed .isValid()             && this.value.degree .isValid()             && this.value.winding.isValid()             && this.value.round  .isValid())         {             const path = new w1666(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 points,                 this.value.closed .value,                 this.value.degree .value,                 this.value.winding.value,                 this.value.round  .value);                               const bounds = getObjBounds([path]);              path.w3639(                 bounds.x + bounds.width /2,                             bounds.y + bounds.height/2);               let x = bounds.x;             let y = bounds.y;             let w = bounds.w;             let h = bounds.h;                          path.m3977(x, y);             path.p3627(x, y, w, h);               this.value.objects.push(path);         }           await super.q3979(parse);     }        isValid()     {         return super.isValid()             && this.points  && this.points .isValid()             && this.closed  && this.closed .isValid()             && this.degree  && this.degree .isValid()             && this.winding && this.winding.isValid()             && this.round   && this.round  .isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.points ) this.points .o3967(parse);         if (this.closed ) this.closed .o3967(parse);         if (this.degree ) this.degree .o3967(parse);         if (this.winding) this.winding.o3967(parse);         if (this.round  ) this.round  .o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.points ) this.points .y3968(parse, from, force);         if (this.closed ) this.closed .y3968(parse, from, force);         if (this.degree ) this.degree .y3968(parse, from, force);         if (this.winding) this.winding.y3968(parse, from, force);         if (this.round  ) this.round  .y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.points ) this.points .l3966(parse);         if (this.closed ) this.closed .l3966(parse);         if (this.degree ) this.degree .l3966(parse);         if (this.winding) this.winding.l3966(parse);         if (this.round  ) this.round  .l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const path = new m1797(nodeId, options);                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(path, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, path);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             path.input = t1607(parse);                   const u3571 = genParseParamCount(parse);              for (let i = 0; i < u3571; i++)         {             const i2902 = genParseParamId(parse);                  parse.f1608 = true;                  switch (i2902)             {                    case 'points':  path.points  = t1607(parse); break;             case 'closed':  path.closed  = t1607(parse); break;             case 'degree':  path.degree  = t1607(parse); break;             case 'winding': path.winding = t1607(parse); break;             case 'round':   path.round   = t1607(parse); break;             case 'props':   path.props   = t1607(parse); break;             }         }                   parse.f1608 = false;         parse.p3553--;                   genParseNodeEnd(parse, path);         return path;     } }


class w1799 extends y1857 {     static { d1855.types[t1233] = this; }        x     = null;     y     = null;     join  = null;     cap   = null;     round = null;        constructor(nodeId, options)     {         super(t1233, nodeId, options);     }        reset()     {         super.reset();          this.x     = null;         this.y     = null;         this.join  = null;         this.cap   = null;         this.round = null;     }        copy()     {         const copy = new w1799(this.nodeId, this.options);          copy.m3266(this);          if (this.x    ) copy.x     = this.x    .copy();         if (this.y    ) copy.y     = this.y    .copy();         if (this.join ) copy.join  = this.join .copy();         if (this.cap  ) copy.cap   = this.cap  .copy();         if (this.round) copy.round = this.round.copy();          return copy;     }        x4121(i2902)     {         switch (i2902)         {             case 'x':     return this.input ? this.value.x     : this.x;             case 'y':     return this.input ? this.value.y     : this.y;             case 'join':  return this.input ? this.value.join  : this.join;             case 'cap':   return this.input ? this.value.cap   : this.cap;             case 'round': return this.input ? this.value.round : this.round;         }          return null;     }        async eval(parse)     {         if (this.isCached())             return this;                   let input = await evalVectorVertexValue(this.input, parse);         let x     = await evalNumberValue      (this.x,     parse);         let y     = await evalNumberValue      (this.y,     parse);         let join  = await evalNumberValue      (this.join,  parse);         let cap   = await evalNumberValue      (this.cap,   parse);         let round = await evalNumberValue      (this.round, parse);           if (input)         {             const s3709 = input;              if (input.type == p1225)             {                 input = new i1852(input.nodeId, input.x, input.y);                 input.z3532(s3709);             }                          this.value        = input.copy();             this.value.nodeId = this.nodeId;             this.value.z3532(input);                                                                                                                          this.value.x     = new n1835(this.value.objects[0].x    );             this.value.y     = new n1835(this.value.objects[0].y    );             this.value.join  = new n1835(this.value.objects[0].join );             this.value.cap   = new n1835(this.value.objects[0].cap  );             this.value.round = new n1835(this.value.objects[0].round);              if (x    )  this.value.x     = x;      else  x     = this.value.x;             if (y    )  this.value.y     = y;      else  y     = this.value.y;             if (join )  this.value.join  = join;   else  join  = this.value.join;             if (cap  )  this.value.cap   = cap;    else  cap   = this.value.cap;             if (round)  this.value.round = round;  else  round = this.value.round;         }         else         {             this.value = new i1852(                 this.nodeId,                  x,                  y,                  join,                  cap,                  round);         }                  this.value.c3633 = this.c3633;           await this.q3979(parse);           this.h3980(parse,          [             ['value', this.value]         ]);           this.validate();          return this;     }        async q3979(parse, options = {})     {         if (!this.options.enabled)             return;                                   this.value.objects = [];           if (   this.value.x                 && this.value.y                 && this.value.join              && this.value.cap               && this.value.round)         {             const x     = this.value.x    .value;             const y     = this.value.y    .value;                                                     const point = new s1657(this.nodeId, this.nodeId, this.nodeName, x, y);              point.m3977(x, y);              this.value.objects = [point];         }           await super.q3979(parse);     }        toNewValue()     {         const point = new i1852(             this.nodeId,             this.x    .toNewValue(),             this.y    .toNewValue(),             this.join .toNewValue(),             this.cap  .toNewValue(),             this.round.toNewValue());          point.z3532(this.value);          point.objects  = this.value.objects.map(o => o.copy());         point.c3633 = this.value.c3633;          return point;     }        isValid()     {         return super.isValid()             && this.x    .isValid()             && this.y    .isValid()             && this.join .isValid()             && this.cap  .isValid()             && this.round.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.x    ) this.x    .o3967(parse);         if (this.y    ) this.y    .o3967(parse);         if (this.join ) this.join .o3967(parse);         if (this.cap  ) this.cap  .o3967(parse);         if (this.round) this.round.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.x    ) this.x    .y3968(parse, from, force);         if (this.y    ) this.y    .y3968(parse, from, force);         if (this.join ) this.join .y3968(parse, from, force);         if (this.cap  ) this.cap  .y3968(parse, from, force);         if (this.round) this.round.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.x    ) this.x    .l3966(parse);         if (this.y    ) this.y    .l3966(parse);         if (this.join ) this.join .l3966(parse);         if (this.cap  ) this.cap  .l3966(parse);         if (this.round) this.round.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const point = new w1799(nodeId, options);                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(point, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, point);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             point.input = t1607(parse);                   const u3571 = genParseParamCount(parse);              for (let i = 0; i < u3571; i++)         {             const i2902 = genParseParamId(parse);                  parse.f1608 = true;                  switch (i2902)             {             case 'x':     point.x     = t1607(parse); break;             case 'y':     point.y     = t1607(parse); break;             case 'join':  point.join  = t1607(parse); break;             case 'cap':   point.cap   = t1607(parse); break;             case 'round': point.round = t1607(parse); break;             }         }                   parse.f1608 = false;         parse.p3553--;                   genParseNodeEnd(parse, point);         return point;     } }


class s1794 extends e1858 {     static { d1855.types[i1236] = this; }        j3569 = null;     t3570   = null;                    constructor(nodeId, options)     {         super(i1236, nodeId, options);     }        reset()     {         super.reset();                  this.j3569 = null;         this.t3570   = null;     }        copy()     {         const copy = new s1794(this.nodeId, this.options);          copy.m3266(this);          if (this.j3569) copy.j3569 = this.j3569.copy();         if (this.t3570  ) copy.t3570   = this.t3570  .copy();          return copy;     }        x4121(i2902)     {         switch (i2902)         {             case 'startTangent': return this.input ? this.value.j3569 : this.j3569;             case 'endTangent':   return this.input ? this.value.t3570   : this.t3570;         }          return null;     }        async eval(parse)     {         if (this.isCached())             return this;                   let e3962       = await evalVectorVertexValue(this.e3962,       parse);         let d3963       = await evalVectorVertexValue(this.d3963,       parse);         let j3569 = await evalNumberValue      (this.j3569, parse);         let   t3570 = await evalNumberValue      (this.  t3570, parse);          if (   e3962             && d3963             && j3569             && t3570)         {             if (e3962.type == p1225) e3962 = new i1852(e3962.nodeId, e3962.x, e3962.y);             if (d3963.type == p1225) d3963 = new i1852(d3963.nodeId, d3963.x, d3963.y);              if (j3569.type == r1232) j3569 = new r1836(j3569.nodeId, j3569.x, j3569.y);             if (  t3570.type == r1232)   t3570 = new r1836(  t3570.nodeId,   t3570.x,   t3570.y);               this.value = new v1848(                 this.nodeId,                 e3962,                 d3963,                 j3569,                 t3570);               this.value.c3633 = this.c3633;         }         else             this.value = v1848.NaN();                           await this.q3979(parse);           this.h3980(parse,          [             ['value', this.value]         ]);           this.validate();          return this;     }        async q3979(parse, options = {})     {         if (   !this.options.enabled             || !this.value.start.isValid()             || !this.value.end  .isValid())             return;                                   this.value.objects = [];           if (   this.value.start.isValid()             && this.value.end  .isValid())         {             const path = new w1666(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 [ this.value.start,                   this.value.j3569.isValid() ? this.value.j3569 : this.value.start,                   this.value.t3570  .isValid() ? this.value.  t3570 : this.value.end,                   this.value.end ],                 0,                 2,                  0,                 0);                           const bounds = getObjBounds([path]);              let x = bounds.x;             let y = bounds.y;             let w = bounds.w;             let h = bounds.h;               path.m3977(x, y);             path.p3627(x, y, w, h);              this.value.objects.push(path);         }           await super.q3979(parse);     }                                                                               isValid()     {         return super.isValid()             && this.j3569.isValid()             && this.t3570  .isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.j3569) this.j3569.o3967(parse);         if (this.t3570  ) this.t3570  .o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.j3569) this.j3569.y3968(parse, from, force);         if (this.t3570  ) this.t3570  .y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.j3569) this.j3569.l3966(parse);         if (this.t3570  ) this.t3570  .l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const edge = new s1794(nodeId, options);                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 2, 'nInputs must be [0, 2]');         }                       if (parse.settings.logRequests)              x1937(edge, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, edge);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 2)         {             edge.e3962 = t1607(parse);             edge.d3963 = t1607(parse);         }         else if (z4088 == 1)         {             edge.e3962 = t1607(parse);          }                   edge.j3569 = t1607(parse);         edge.  t3570 = t1607(parse);                   parse.f1608 = false;         parse.p3553--;                   genParseNodeEnd(parse, edge);         return edge;     } }


class a1798 extends m1787 {     static { d1855.types[t1239] = this; }        inputs  = [];      loops   = null;     winding = null;        constructor(nodeId, options)     {         super(t1239, nodeId, options);     }        reset()     {         super.reset();          this.inputs  = [];          this.loops   = null;         this.winding = null;     }        copy()     {         const copy = new a1798(this.nodeId, this.options);          copy.m3266(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.winding) copy.winding = this.winding.copy();          return copy;     }        x4121(i2902)     {         switch (i2902)         {             case 'loops':   return this.input ? this.value.loops   : this.loops;             case 'winding': return this.input ? this.value.winding : this.winding;         }          return super.x4121(i2902);     }        isCached()     {         for (const input of this.inputs)             if (!input.isCached())                 return false;          return super.isCached()             && this.winding.isCached();     }        async eval(parse)     {         if (this.isCached())             return this;                   const winding = await evalNumberValue(this.winding, parse);           this.loops = new x1834();           const loop = new x1834();          for (let i = 0; i < this.inputs.length; i++)         {             const input = await evalVectorEdgeValue(this.inputs[i], parse);              if (l955(input.type))             {                 const _loop = new x1834();                  for (let j = 0; j < input.items.length; j++)                 {                     const item = input.items[j];                      if (item.type == e1235)                     {                         const edge = item.copy();                          if (_loop.items.length > 0)                         {                             const prevEdge = _loop.items.at(-1);                              if (   edge.end.x.equals(prevEdge.end.x)                                 && edge.end.y.equals(prevEdge.end.y))                             {                                 [edge.start,        edge.end       ] = [edge.end,        edge.start       ];                                 [edge.j3569, edge.t3570] = [edge.t3570, edge.j3569];                             }                         }                          _loop.items.push(edge);                     }                 }                  if (!isEmpty(_loop.items))                     loops.items.push(_loop);             }             else             {                 r950(                      input.type == e1235,                      'input.type must be VECTOR_EDGE_VALUE');                  const edge = input.copy();                  if (loop.items.length > 0)                 {                     const prevEdge = loop.items.at(-1);                      if (   edge.end.x.equals(prevEdge.end.x)                         && edge.end.y.equals(prevEdge.end.y))                     {                         [edge.start,        edge.end       ] = [edge.end,        edge.start       ];                         [edge.j3569, edge.t3570] = [edge.t3570, edge.j3569];                     }                 }                  loop.items.push(edge);             }         }           if (!isEmpty(loop.items))             this.loops.items.push(loop);           this.value = new c1851(             this.nodeId,             this.loops,              winding);           this.value.c3633 = this.c3633;           this.h3980(parse,         [             ['value',   this.value],             ['winding', winding   ]         ]);           await this.q2806(parse);           await this.q3979(parse);           this.validate();          return this;     }        async q3979(parse, options = {})     {         if (   !this.options.enabled             || !this.value.isValid())             return;                                   this.value.objects = [];                   if (   this.loops  .isValid()             && this.winding.isValid())         {             const regions = [];               for (let i = 0; i < this.loops.items.length; i++)             {                 const loop = this.loops.items[i];                   const points = [];                      for (let j = 0; j < loop.items.length; j++)                 {                     const edge = loop.items[j];                     const next = loop.items[j == loop.items.length-1 ? 0 : j+1];                      points.push(                            edge.start.c3633 == next.start.c3633                         || edge.start.c3633 == next.end  .c3633                         ? edge.end                           : edge.start);                 }                   regions.push(new w1666(                     this.nodeId,                     this.nodeId + '/' + i,                     this.nodeName,                     points,                     1,                     0,                      this.winding.value,                     0));             }                           let bounds = getObjBounds(regions);              let x = bounds.x;             let y = bounds.y;             let w = bounds.w;             let h = bounds.h;               for (const region of regions)             {                 region.m3977(x, y);                 region.p3627(x, y, w, h);                  this.value.objects.push(region);             }         }           await super.q3979(parse);     }                                                                          isValid()     {         if (!super.isValid())             return false;                      for (const input of this.inputs)             if (!input.isCached())                 return false;                  return this.winding.isValid()             && this.props  .isValid();     }        o3967(parse)     {         super.o3967(parse);          this.inputs.forEach(i => i.o3967(parse));          if (this.winding) this.winding.o3967(parse);         if (this.props  ) this.props  .o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          this.inputs.forEach(i => i.y3968(parse, from, force));          if (this.winding) this.winding.y3968(parse, from, force);         if (this.props  ) this.props  .y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          this.inputs.forEach(i => i.l3966(parse));          if (this.winding) this.winding.l3966(parse);         if (this.props  ) this.props  .l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const region = new a1798(nodeId, options);                   let z4088 = 0;                  if (!ignore)             z4088 = parseInt(parse.move());                   if (parse.settings.logRequests)              x1937(region, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, region);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   for (let i = 0; i < z4088; i++)             region.inputs.push(t1607(parse));                   region.winding = t1607(parse);         region.props   = t1607(parse);                   parse.f1608 = false;         parse.p3553--;                   genParseNodeEnd(parse, region);         return region;     } }


class j1796 extends m1787 {     static { d1855.types[h1242] = this; }        inputs = [];        constructor(nodeId, options)     {         super(h1242, nodeId, options);     }        reset()     {         super.reset();          this.inputs = [];     }        copy()     {         const copy = new j1796(this.nodeId, this.options);          copy.m3266(this);          copy.inputs = this.inputs.map(i => i.copy());          return copy;     }        isCached()     {         for (const input of this.inputs)             if (!input.isCached())                 return false;          return super.isCached();     }        async eval(parse)     {         if (this.isCached())             return this;                   const regions = new x1834();          for (let i = 0; i < this.inputs.length; i++)         {             const input = await evalVectorRegionValue(this.inputs[i], parse);              r950(                  input.type == k1238,                  'input.type must be VECTOR_REGION_VALUE');              regions.items.push(input);         }           this.value = new k1849(             this.nodeId,             regions);           this.h3980(parse,          [             ['value', this.value]         ]);           await this.q2806(parse);                   await this.q3979(parse);           this.validate();          return this;     }        async q3979(parse, options = {})     {         if (   !this.options.enabled             || !this.value.isValid())             return;                                   this.value.objects = [];           if (!isEmpty(this.value.regions.items))         {             let points  = [];             let edges   = [];             let regions = [];               for (const region of this.value.regions.items)             {                 if (!isEmpty(region.objects))                     region.fills = region.objects[0].fills;                   if (region.loops)                 {                     for (const loop of region.loops.items)                     {                         for (const edge of loop.items)                         {                             z948(points, edge.start, p => p.c3633 == edge.start.c3633);                             z948(points, edge.end,   p => p.c3633 == edge.end  .c3633);                              z948(edges, edge, e => e.c3633 == edge.c3633);                         }                     }                      z948(regions, region, r => r.c3633 == region.c3633);                 }             }                           const network = new p1665(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 points,                 edges,                 regions);                           const bounds = getObjBounds([network]);              let x = bounds.x;             let y = bounds.y;             let w = bounds.w;             let h = bounds.h;               network.m3977(x, y);             network.p3627(x, y, w, h);              this.value.objects.push(network);         }           await super.q3979(parse);     }                                                                isValid()     {         return super.isValid()             && this.regions.isValid();     }        o3967(parse)     {         super.o3967(parse);          this.inputs.forEach(i => i.o3967(parse));     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          this.inputs.forEach(i => i.o3967(parse));     }        l3966(parse)     {         super.l3966(parse);          this.inputs.forEach(i => i.l3966(parse));     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const network = new j1796(nodeId, options);                   let z4088 = 0;                  if (!ignore)             z4088 = parseInt(parse.move());                   if (parse.settings.logRequests)              x1937(network, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, network);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   for (let i = 0; i < z4088; i++)             network.inputs.push(t1607(parse));              network.props = t1607(parse);                   parse.p3553--;                        genParseNodeEnd(parse, network);         return network;     } }


class t2348 extends m1787 {     static { d1855.types[b1210] = this; }        position = null;     start    = null;     sweep    = null;      startInDegrees;     sweepInDegrees;        constructor(nodeId, options)     {         super(b1210, nodeId, options);     }        reset()     {         super.reset();          this.position = null;         this.start    = null;         this.sweep    = null;     }        copy()     {         const copy = new t2348(this.nodeId, this.options);          copy.m3266(this);          if (this.position) copy.position = this.position.copy();         if (this.start   ) copy.start    = this.start   .copy();         if (this.sweep   ) copy.sweep    = this.sweep   .copy();                  return copy;     }        x4121(i2902)     {         switch (i2902)         {             case 'position': return this.input ? this.value.position : this.position;             case 'x':        return this.input ? this.value.x        : this.x;             case 'y':        return this.input ? this.value.y        : this.y;             case 'width':    return this.input ? this.value.width    : this.width;             case 'height':   return this.input ? this.value.height   : this.height;             case 'start':    return this.input ? this.value.start    : this.start;             case 'sweep':    return this.input ? this.value.sweep    : this.sweep;         }          return super.x4121(i2902);     }        async eval(parse)     {         if (this.isCached())             return this;           let [x, y, width, height] = await this.evalBaseParams(parse);          let input = await evalArcPathValue(this.input,    parse);         let pos   = await evalNumberValue (this.position, parse);         let start = await evalNumberValue (this.start,    parse);         let sweep = await evalNumberValue (this.sweep,    parse);           if (input)         {             this.value        = input.copy();             this.value.nodeId = this.nodeId;             this.value.z3532(input);              if (pos   )  this.value.position = pos;     else  pos    = this.value.position;             if (x     )  this.value.x        = x;       else  x      = this.value.x;                   if (y     )  this.value.y        = y;       else  y      = this.value.y;                   if (width )  this.value.width    = width;   else  width  = this.value.width;               if (height)  this.value.height   = height;  else  height = this.value.height;              if (start )  this.value.start    = start;   else  start  = this.value.start;             if (sweep )  this.value.sweep    = sweep;   else  sweep  = this.value.sweep;         }         else         {             this.value = new i2421(                 this.nodeId,                 pos,                 x,                  y,                  width,                  height,                 start,                 sweep);         }           this.h3980(parse,          [             ['position', pos   ],             ['x',        x     ],             ['y',        y     ],             ['width',    width ],             ['height',   height],             ['start',    start ],             ['sweep',    sweep ]         ]);           await this.q2806(parse);           await this.q3979(parse);           this.validate();          return this;     }        async q3979(parse, options = {})     {        if (!this.options.enabled)            return;                                 this.value.objects = [];           if (   super.i2807()             && this.value.x     .isValid()             && this.value.y     .isValid()             && this.value.width .isValid()             && this.value.height.isValid())          {             const vpos = this.value.position;             const vx   = this.value.x;             const vy   = this.value.y;             const vw   = this.value.width;             const vh   = this.value.height;              const _x   = vpos.value <= 0 ? vx : new n1835(vx.value - vw.value, Math.max(vx.decimals, vw.decimals));             const _y   = vpos.value <= 0 ? vy : new n1835(vy.value - vh.value, Math.max(vy.decimals, vh.decimals));             const _w   = vpos.value <= 0 ? vw : new n1835(vw.value*2, Math.max(vx.decimals, vw.decimals));             const _h   = vpos.value <= 0 ? vh : new n1835(vh.value*2, Math.max(vy.decimals, vh.decimals));                          let   x    = _x.value;             let   y    = _y.value;             let   w    = _w.value;             let   h    = _h.value;             let   st   = this.value.start.value/360 * Tau;             let   sw   = this.value.sweep.value/100 * Tau;               [x, , w, , , ] = validateObjectRect(x, y, w, h);                                                          if (!this.startInDegrees) st *= 3.6;                 if ( this.sweepInDegrees) sw /= 3.6;                  const arc = new q2451(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     vpos.value,                     x, y, w, h, st, sw);                   const bounds = getObjBounds([arc]);                          arc.w3639(x + w/2, y + h/2);                 arc.m3977(bounds.x, bounds.y);                 arc.p3627(bounds.x, bounds.y, bounds.w, bounds.h);                   this.value.objects.push(arc);                      }           await super.q3979(parse);     }                       isValid()     {         return super.isValid()             && this.position && this.position.isValid()             && this.start    && this.start   .isValid()             && this.sweep    && this.sweep   .isValid();     }        o3967(parse)     {         super.o3967(parse);           if (this.position) this.position.o3967(parse);         if (this.start   ) this.start   .o3967(parse);         if (this.sweep   ) this.sweep   .o3967(parse);     }                   y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.position) this.position.y3968(parse, from, force);         if (this.start   ) this.start   .y3968(parse, from, force);         if (this.sweep   ) this.sweep   .y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);           if (this.position) this.position.l3966(parse);         if (this.start   ) this.start   .l3966(parse);         if (this.sweep   ) this.sweep   .l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const arc = new t2348(nodeId, options);                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(arc, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, arc);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             arc.input = t1607(parse);                   const u3571 = genParseParamCount(parse);              for (let i = 0; i < u3571; i++)         {             const i2902 = genParseParamId(parse);                  parse.f1608 = true;                  switch (i2902)             {             case 'position': arc.position = t1607(parse); break;             case 'x':        arc.x        = t1607(parse); break;             case 'y':        arc.y        = t1607(parse); break;             case 'width':    arc.width    = t1607(parse); break;             case 'height':   arc.height   = t1607(parse); break;             case 'start':    arc.start    = t1607(parse); break;             case 'sweep':    arc.sweep    = t1607(parse); break;             case 'props':    arc.props    = t1607(parse); break;             }         }                           arc.startInDegrees = parseInt(parse.move()) > 0;         arc.sweepInDegrees = parseInt(parse.move()) > 0;                   parse.f1608 = false;         parse.p3553--;                   genParseNodeEnd(parse, arc);         return arc;     } }


class a2413 extends m1787 {     static { d1855.types[t1213] = this; }        shape     = null;     amplitude = null;     frequency = null;     offset    = null;     alignX    = null;     alignY    = null;      useWavelength;     offsetAbsolute;        constructor(nodeId, options)     {         super(t1213, nodeId, options);     }        reset()     {         super.reset();          this.shape     = null;         this.amplitude = null;         this.frequency = null;         this.offset    = null;         this.alignX    = null;         this.alignY    = null;     }        copy()     {         const copy = new a2413(this.nodeId, this.options);          copy.m3266(this);          if (this.shape    ) copy.shape     = this.shape    .copy();         if (this.amplitude) copy.amplitude = this.amplitude.copy();         if (this.frequency) copy.frequency = this.frequency.copy();         if (this.offset   ) copy.offset    = this.offset   .copy();         if (this.alignX   ) copy.alignX    = this.alignX   .copy();         if (this.alignY   ) copy.alignY    = this.alignY   .copy();                  return copy;     }        x4121(i2902)     {         switch (i2902)         {             case 'shape':     return this.input ? this.value.shape     : this.shape;             case 'x':         return this.input ? this.value.x         : this.x;             case 'y':         return this.input ? this.value.y         : this.y;             case 'width':     return this.input ? this.value.width     : this.width;             case 'amplitude': return this.input ? this.value.amplitude : this.amplitude;             case 'frequency': return this.input ? this.value.frequency : this.frequency;             case 'offset':    return this.input ? this.value.offset    : this.offset;             case 'alignX':    return this.input ? this.value.alignX    : this.alignX;             case 'alignY':    return this.input ? this.value.alignY    : this.alignY;         }          return super.x4121(i2902);     }        async eval(parse)     {         if (this.isCached())             return this;           let [x, y, width, ] = await this.evalBaseParams(parse);           let input     = await evalWavePathValue(this.input,     parse);         let shape     = await evalNumberValue  (this.shape,     parse);         let amplitude = await evalNumberValue  (this.amplitude, parse);         let frequency = await evalNumberValue  (this.frequency, parse);         let offset    = await evalNumberValue  (this.offset,    parse);         let alignX    = await evalNumberValue  (this.alignX,    parse);         let alignY    = await evalNumberValue  (this.alignY,    parse);           if (input)         {             this.value        = input.copy();             this.value.nodeId = this.nodeId;             this.value.z3532(input);              if (shape    )  this.value.shape     = shape;      else  shape      = this.value.shape;             if (x        )  this.value.x         = x;          else  x          = this.value.x;                   if (y        )  this.value.y         = y;          else  y          = this.value.y;                   if (width    )  this.value.width     = width;      else  width      = this.value.width;               if (amplitude)  this.value.amplitude = amplitude;  else  amplitude  = this.value.amplitude;             if (frequency)  this.value.frequency = frequency;  else  frequency  = this.value.frequency;             if (offset   )  this.value.offset    = offset;     else  offset     = this.value.offset;             if (alignX   )  this.value.alignX    = alignX;     else  alignX     = this.value.alignX;             if (alignY   )  this.value.alignY    = alignY;     else  alignY     = this.value.alignY;         }         else         {             this.value = new h2418(                 this.nodeId,                 shape,                 x,                  y,                  width,                  amplitude,                 frequency,                 offset,                 alignX,                 alignY);         }           this.h3980(parse,          [             ['shape',     shape    ],             ['x',         x        ],             ['y',         y        ],             ['width',     width    ],             ['amplitude', amplitude],             ['frequency', frequency],             ['offset',    offset   ],             ['alignX',    alignX   ],             ['alignY',    alignY   ]         ]);           await this.q2806(parse);           await this.q3979(parse);           this.validate();          return this;     }        async q3979(parse, options = {})     {        if (!this.options.enabled)            return;                                 this.value.objects = [];           if (   super.i2807()             && this.value.shape    .isValid()             && this.value.x        .isValid()             && this.value.y        .isValid()             && this.value.width    .isValid()             && this.value.amplitude.isValid()             && this.value.frequency.isValid()             && this.value.offset   .isValid()             && this.value.alignX   .isValid()             && this.value.alignY   .isValid())         {             const sh     = this.value.shape    .value;             let   x      = this.value.x        .value;             let   y      = this.value.y        .value;             let   w      = this.value.width    .value;             const amp    = this.value.amplitude.value;             let   freq   = this.value.frequency.value;             const off    = this.value.offset   .value;             const alignX = this.value.alignX   .value;             const alignY = this.value.alignY   .value;               [x, y, w, , ] = validateObjectRect(x, y, w, 0);               const _freq = this.useWavelength ? w/nozero(freq) : freq;             const wl    = this.useWavelength ? freq : w/nozero(freq);              const so    = this.shape.value >= 3 ? 0.25 : 0;              const _off =                 this.offsetAbsolute                 ? off - so*wl                 : (off/100 - so) * wl;                                                          const wave = new s2453(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     sh,                      x, y, w,                     amp,                     _freq,                     _off,                     alignX,                     alignY);                   const bounds = getObjBounds([wave]);                  wave.w3639(                     bounds.x + bounds.width /2,                                 bounds.y + bounds.height/2                             );                  wave.m3977(bounds.x, bounds.y);                 wave.p3627(bounds.x, bounds.y, bounds.w, bounds.h);                   this.value.objects.push(wave);                      }           await super.q3979(parse);     }                       isValid()     {         return super.isValid()             && this.shape     && this.shape    .isValid()             && this.amplitude && this.amplitude.isValid()             && this.frequency && this.frequency.isValid()             && this.offset    && this.offset   .isValid()             && this.alignX    && this.alignX   .isValid()             && this.alignY    && this.alignY   .isValid();     }        o3967(parse)     {         super.o3967(parse);           if (this.shape    ) this.shape    .o3967(parse);         if (this.amplitude) this.amplitude.o3967(parse);         if (this.frequency) this.frequency.o3967(parse);         if (this.offset   ) this.offset   .o3967(parse);         if (this.alignX   ) this.alignX   .o3967(parse);         if (this.alignY   ) this.alignY   .o3967(parse);     }                   y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.shape    ) this.shape    .y3968(parse, from, force);         if (this.amplitude) this.amplitude.y3968(parse, from, force);         if (this.frequency) this.frequency.y3968(parse, from, force);         if (this.offset   ) this.offset   .y3968(parse, from, force);         if (this.alignX   ) this.alignX   .y3968(parse, from, force);         if (this.alignY   ) this.alignY   .y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);           if (this.shape    ) this.shape    .l3966(parse);         if (this.amplitude) this.amplitude.l3966(parse);         if (this.frequency) this.frequency.l3966(parse);         if (this.offset   ) this.offset   .l3966(parse);         if (this.alignX   ) this.alignX   .l3966(parse);         if (this.alignY   ) this.alignY   .l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const wave = new a2413(nodeId, options);                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(wave, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, wave);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             wave.input = t1607(parse);                   const u3571 = genParseParamCount(parse);              for (let i = 0; i < u3571; i++)         {             const i2902 = genParseParamId(parse);                  parse.f1608 = true;                  switch (i2902)             {             case 'shape':     wave.shape     = t1607(parse); break;             case 'x':         wave.x         = t1607(parse); break;             case 'y':         wave.y         = t1607(parse); break;             case 'width':     wave.width     = t1607(parse); break;             case 'amplitude': wave.amplitude = t1607(parse); break;             case 'frequency': wave.frequency = t1607(parse); break;             case 'offset':    wave.offset    = t1607(parse); break;             case 'alignX':    wave.alignX    = t1607(parse); break;             case 'alignY':    wave.alignY    = t1607(parse); break;             case 'props':     wave.props     = t1607(parse); break;             }         }                           wave.useWavelength  = parseInt(parse.move()) > 0;         wave.offsetAbsolute = parseInt(parse.move()) > 0;                   parse.f1608 = false;         parse.p3553--;                   genParseNodeEnd(parse, wave);         return wave;     } }


class v1789 extends x1788 {     static { d1855.types[m1245] = this; }        inputs = [];        constructor(nodeId, options)     {         super(m1245, nodeId, options);     }        reset()     {         super.reset();          this.inputs = [];     }        copy()     {         const copy = new v1789(this.nodeId, this.options);          copy.m3266(this);          copy.inputs = this.inputs.map(i => i.copy());          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new s1841(this.nodeId);          this.value.objects = [];                  const inputs = [];                  if (this.options.enabled)         {             for (let i = 0; i < this.inputs.length; i++)             {                 const input = await evalValue(this.inputs[i], parse);                  if (input)                             {                     inputs.push(input);                      if (   input.type == x1057                         || input.type == q1054)                     {                         for (const item of input.items)                         {                             if (!z1274.includes(item.type))                                 continue;                              this.value.items.push(item);                                                      }                     }                     else                     {                         this.value.items.push(input);                                              }                 }             }         }           this.h3980(parse,          [             ['value', this.value]         ]);                      await this.q3979(parse, {inputs: inputs});           this.validate();          return this;     }        async q3979(parse, options = {})     {         if (!this.options.enabled)             return;                       if (this.value.items)         {             const group = new f1661(                 this.nodeId,                 this.nodeId,                 this.nodeName);               for (let i = 0; i < options.inputs.length; i++)             {                 const input = options.inputs[i];                  if (input.objects)                 {                     for (let j = 0; j < input.objects.length; j++)                         this.d3634(group.children, input.objects[j], i, j);                 }             }                                 const bounds = getObjBounds(group.children);              const singlePoint =                    group.children.length  == 1                  && group.children[0].type == y1226;              for (const c111 of group.children)             {                                                        c111.w3639(c111.sp0.x, c111.sp0.y);                                                                     c111.resetSpace(bounds, singlePoint);             }               group.x      = bounds.x;             group.y      = bounds.y;             group.width  = bounds.width;             group.height = bounds.height;                           group.w3639();             group.resetSpace(bounds);              group.m3977(bounds.x, bounds.y);             group.p3627(bounds.x, bounds.y, bounds.width, bounds.height);               this.value.objects = [group];         }         else         {             this.value.objects = [];         }           await super.q3979(parse);     }        d3634(objects, _obj, inputIndex, objIndex)     {         const c111 = g3635(_obj);          c111.nodeId    = this.nodeId;         c111.objectId += b965 + inputIndex;         c111.listId    = -1;          objects.push(c111);     }        toNewValue()     {         return this.value.copy();     }        isValid()     {         if (!super.isValid())              return false;          for (const input of this.inputs)             if (!input.isValid())                 return false;          return true;     }        o3967(parse)     {         super.o3967(parse);          this.inputs.forEach(i => i.o3967(parse));     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          this.inputs.forEach(i => i.y3968(parse, from, force));     }        l3966(parse)     {         super.l3966(parse);          this.inputs.forEach(i => i.l3966(parse));     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const group = new v1789(nodeId, options);                   let z4088 = 0;                  if (!ignore)             z4088 = parseInt(parse.move());                   if (parse.settings.logRequests)              x1937(group, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, group);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   for (let i = 0; i < z4088; i++)             group.inputs.push(t1607(parse));                   parse.p3553--;                   genParseNodeEnd(parse, group);         return group;     } }


class c1770 extends m1787 {     static { d1855.types[s1248] = this; }        children = null;     position = null;     round    = null;     clip     = null;        constructor(nodeId, options)     {         super(s1248, nodeId, options);     }        reset()     {         super.reset();          this.children = null;         this.position = null;         this.round    = null;         this.clip     = null;     }        copy()     {         const copy = new c1770(this.nodeId, this.options);          copy.m3266(this);          if (this.children) copy.children = this.children.copy();         if (this.position) copy.position = this.position.copy();         if (this.round   ) copy.round    = this.round   .copy();         if (this.clip    ) copy.clip     = this.clip    .copy();          return copy;     }        x4121(i2902)     {         switch (i2902)         {             case 'children': return this.input ? this.value.children : this.children;             case 'position': return this.input ? this.value.position : this.position;             case 'x':        return this.input ? this.value.x        : this.x;             case 'y':        return this.input ? this.value.y        : this.y;             case 'width':    return this.input ? this.value.width    : this.width;             case 'height':   return this.input ? this.value.height   : this.height;             case 'round':    return this.input ? this.value.round    : this.round;             case 'clip':     return this.input ? this.value.clip     : this.clip;         }          return super.x4121(i2902);     }        async eval(parse)     {         if (this.isCached())             return this;           const [x, y, width, height] = await this.evalBaseParams(parse);          let children = await evalListValue  (this.children, parse);         let position = await evalNumberValue(this.position, parse);         let round    = await evalNumberValue(this.round,    parse);         let clip     = await evalNumberValue(this.clip,     parse);           if (   children             && z1274.includes(children.type)             && children.type != x1057)         {             const objects    = children.objects;             children         = new x1834([children]);             children.objects = objects;         }           let input = null;          if (this.input)         {             input = await evalFrameValue(this.input, parse);              this.value = new n1827(                 this.nodeId,                 children ?? input.children,                 position ?? input.position,                 x        ?? input.x,                 y        ?? input.y,                 width    ?? input.width,                 height   ?? input.height,                 round    ?? input.round,                 clip     ?? input.clip);         }         else         {             this.value = new n1827(                 this.nodeId,                  children,                 position,                 x,                  y,                  width,                 height,                  round,                 clip);         }           const childType = new e1846(f3386(children.items));          this.h3980(parse,          [             ['childType', childType],             ['position',  position ],             ['x',         x        ],             ['y',         y        ],             ['width',     width    ],             ['height',    height   ],             ['round',     round    ],             ['clip',      clip     ]         ]);           await this.q2806(parse);           await this.q3979(parse);           if (!this.children) this.children = this.value.children.copy();         if (!this.position) this.position = this.value.position.copy();         if (!this.x       ) this.x        = this.value.x       .copy();         if (!this.y       ) this.y        = this.value.y       .copy();         if (!this.width   ) this.width    = this.value.width   .copy();         if (!this.height  ) this.height   = this.value.height  .copy();         if (!this.round   ) this.round    = this.value.round   .copy();         if (!this.clip    ) this.clip     = this.value.clip    .copy();           this.validate();          return this;     }        async q3979(parse, options = {})     {         if (!this.options.enabled)             return;                       if (   this.value.position             && this.value.x             && this.value.y             && this.value.width             && this.value.height             && this.value.round             && this.value.clip)         {             let   pos = this.value.position.value;             let   x   = this.value.x       .value;             let   y   = this.value.y       .value;             let   w   = this.value.width   .value;             let   h   = this.value.height  .value;             const r   = Math.max(0, this.value.round.value);             const c   = this.value.clip    .value;               const frame = new y1654(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 x, y, w, h, r, c);               const bounds = getObjBounds(this.value.objects);              const singlePoint =                    this.value.objects.length  == 1                  && this.value.objects[0].type == y1226;                               const xoff = v891(-x, -y);              for (let i = 0; i < this.value.objects.length; i++)             {                 const c111 = this.value.objects[i];                                                     c111.w3639();                                                                     c111.resetSpace(bounds, singlePoint);                  if (pos > 0)                     c111.h3978(xoff, 2);                  this.d3634(frame.children, c111);             }               frame.m3977(x, y);             frame.p3627(x, y, w, h);                      this.value.objects = [frame];                           this.h3980(parse,              [                 ['nChildren', new n1835(frame.children.length)]             ],              true);         }           await super.q3979(parse);     }        d3634(objects, _obj)     {         const c111 = g3635(_obj);                              c111.nodeId   = this.nodeId;         c111.objectId = c111.objectId + b965 + this.nodeId;         c111.listId   = -1;                  objects.push(c111);     }        toNewValue()     {         return this.value.copy();     }        isValid()     {         return super.isValid()             && this.children && this.children.isValid()             && this.position && this.position.isValid()             && this.round    && this.round   .isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.children) this.children.o3967(parse);         if (this.position) this.position.o3967(parse);         if (this.round   ) this.round   .o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.children) this.children.y3968(parse, from, force);         if (this.position) this.position.y3968(parse, from, force);         if (this.round   ) this.round   .y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.children) this.children.l3966(parse);         if (this.position) this.position.l3966(parse);         if (this.round   ) this.round   .l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const frame = new c1770(nodeId, options);                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(frame, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, frame);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             frame.input = t1607(parse);                   const u3571 = genParseParamCount(parse);              for (let i = 0; i < u3571; i++)         {             const i2902 = genParseParamId(parse);                  parse.f1608 = true;                  switch (i2902)             {             case 'children': frame.children = t1607(parse); break;             case 'position': frame.position = t1607(parse); break;             case 'x':        frame.x        = t1607(parse); break;             case 'y':        frame.y        = t1607(parse); break;             case 'width':    frame.width    = t1607(parse); break;             case 'height':   frame.height   = t1607(parse); break;             case 'round':    frame.round    = t1607(parse); break;             case 'clip':     frame.clip     = t1607(parse); break;             case 'props':    frame.props    = t1607(parse); break;             }         }                   parse.f1608 = false;         parse.p3553--;                   genParseNodeEnd(parse, frame);         return frame;     } }


class h1766 extends y1857 {     static { d1855.types[k1257] = this; }        props   = null;     replace = null;        constructor(nodeId, options)     {         super(k1257, nodeId, options);     }        reset()     {         super.reset();          this.props   = null;         this.replace = null;     }        copy()     {         const copy = new h1766(this.nodeId, this.options);          copy.m3266(this);          if (this.props  ) copy.props   = this.props  .copy();         if (this.replace) copy.replace = this.replace.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                   const input   = await evalValue    (this.input,   parse);         const props   = await evalListValue(this.props,   parse);         const replace = await evalValue    (this.replace, parse);            if (input)         {             this.value         = input;             this.value.props   = props;             this.value.replace = replace;         }         else         {             this.value = new p4096();         }                  await this.q3979(parse);           this.h3980(parse,          [             ['type',    this.outputType()],                          ['props',   props            ],             ['replace', replace          ]         ]);           this.validate();          return this;     }        async q3979(parse, options = {})     {         if (this.value.isValid())         {             this.value.objects =                     this.input                  && this.input.value                 ? this.input.value.objects.map(o => o.copy())                  : [];         }           if (this.value.objects)         {             for (const c111 of this.value.objects)             {                 c111.nodeId   = this.nodeId;                 c111.objectId = c111.objectId + b965 + this.nodeId;             }              this.applyProps(this.value.objects, this.value.props, this.value.replace.value);         }                   await super.q3979(parse);     }        applyProps(objects, props, replace)     {         for (const c111 of objects)         {             if (this.options.enabled)             {                                                                                                                                          {                     if (replace == 1)                     {                         c111.fills    = [];                         c111.strokes  = [];                         c111.effects  = [];                         c111.maskType = 0;                     }                       if (l955(props.type))                     {                                        for (let i = props.items.length-1; i >= 0; i--)                             o1636(c111, props.items[i]);                     }                     else                         o1636(c111, props);                 }             }         }     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }            isValid()     {         return super.isValid()             && this.props   && this.props  .isValid()             && this.replace && this.replace.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.props  ) this.props  .o3967(parse);         if (this.replace) this.replace.o3967(parse);     }       y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.props  ) this.props  .y3968(parse, from, force);         if (this.replace) this.replace.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.props  ) this.props  .l3966(parse);         if (this.replace) this.replace.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const apply = new h1766(nodeId, options);                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(apply, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, apply);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             apply.input = t1607(parse);              apply.props   = t1607(parse);         apply.replace = t1607(parse);                   parse.f1608 = false;         parse.p3553--;                   genParseNodeEnd(parse, apply);         return apply;     } }


class v1760 extends m1787 {     static { d1855.types[s1266] = this; }        children  = null;     operation = null;        constructor(nodeId, options)     {         super(s1266, nodeId, options);     }        reset()     {         super.reset();          this.children  = null;         this.operation = null;     }        copy()     {         const copy = new v1760(this.nodeId, this.options);          copy.m3266(this);          if (this.children ) copy.children  = this.children .copy();         if (this.operation) copy.operation = this.operation.copy();          return copy;     }        x4121(i2902)     {         switch (i2902)         {             case 'children':  return this.input ? this.value.children  : this.children;             case 'operation': return this.input ? this.value.operation : this.operation;         }          return super.x4121(i2902);     }        async eval(parse)     {         if (this.isCached())             return this;           await this.evalBaseParams(parse);          let   children  = await evalListValue  (this.children,  parse);         const operation = await evalNumberValue(this.operation, parse);           if (   children             && z1274.includes(children.type)             && children.type != x1057)         {             const objects    = children.objects;             children         = new x1834([children]);             children.objects = objects;         }           let input = null;          if (this.input)         {             input = await evalValue(this.input, parse);              this.value = new w1840(                 this.nodeId,                 children  ?? input.children,                 operation ?? input.operation);         }         else         {             this.value = new w1840(                 this.nodeId,                  children,                 operation);         }           this.h3980(parse,         [             ['operation', operation]         ]);           await this.q2806(parse);           await this.q3979(parse);           if (!this.children ) this.children  = this.value.children .copy();         if (!this.operation) this.operation = this.value.operation.copy();           this.validate();          return this;     }        async q3979(parse, options = {})     {         if (!this.options.enabled)             return;                       if (   this.value.objects             && this.value.operation)         {             let typeSuffix = '';              switch (this.operation.value)             {                 case 0: typeSuffix = '+'; break;                 case 1: typeSuffix = '-'; break;                 case 2: typeSuffix = '*'; break;                 case 3: typeSuffix = '/'; break;             }               const bool = new e1651(                 this.nodeId,                 this.nodeId + b965 + typeSuffix,                 this.nodeName,                 this.operation.value);               const bounds = getObjBounds(this.value.objects);              for (let i = 0; i < this.value.objects.length; i++)             {                 const c111 = this.value.objects[i];                                                     c111.w3639();                                                                     c111.resetSpace(bounds, false);                  this.d3634(bool.children, c111);             }                            bool.x      = bounds.x;             bool.y      = bounds.y;             bool.width  = bounds.width;             bool.height = bounds.height;                           bool.w3639();             bool.resetSpace(bounds);              bool.m3977(bounds.x, bounds.y);             bool.p3627(bounds.x, bounds.y, bounds.width, bounds.height);                      this.value.objects = [bool];               const nChildren = new n1835(                 this.children.objects                  ? this.children.objects.length                 : 0);               this.h3980(parse,             [                 ['nChildren', nChildren]             ],             true);         }         else         {             this.value.objects = [];                          this.h3980(parse,             [                 ['nChildren', new n1835(0)]             ],             true);         }                   await super.q3979(parse);     }        d3634(objects, _obj)     {         const c111 = g3635(_obj);          c111.nodeId   = this.nodeId;         c111.objectId = c111.objectId + b965 + this.nodeId;         c111.listId   = -1;          objects.push(c111);     }       toNewValue()     {         return this.value.copy();     }        isValid()     {         return super.isValid()             && this.children  && this.children .isValid()             && this.operation && this.operation.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.input    ) this.input    .o3967(parse);         if (this.children ) this.children .o3967(parse);         if (this.operation) this.operation.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.input    ) this.input    .y3968(parse, from, force);         if (this.children ) this.children .y3968(parse, from, force);         if (this.operation) this.operation.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.input    ) this.input    .l3966(parse);         if (this.children ) this.children .l3966(parse);         if (this.operation) this.operation.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const bool = new v1760(nodeId, options);                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(bool, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, bool);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             bool.input = t1607(parse);                   const u3571 = genParseParamCount(parse);              for (let i = 0; i < u3571; i++)         {             const i2902 = genParseParamId(parse);                  parse.f1608 = true;                  switch (i2902)             {             case 'children':  bool.children  = t1607(parse); break;             case 'operation': bool.operation = t1607(parse); break;             case 'props':     bool.props     = t1607(parse); break;             }         }                   parse.f1608 = false;         parse.p3553--;                   genParseNodeEnd(parse, bool);         return bool;     } }














class c1783 extends x1788 {     static { d1855.types[j1273] = this; }        inputs  = [];      retain = null;      finalize;        constructor(nodeId, options)     {         super(j1273, nodeId, options);     }        reset()     {         super.reset();          this.inputs  = [];         this.retain = null;     }        copy()     {         const copy = new c1783(this.nodeId, this.options);          copy.m3266(this);          copy.inputs = this.inputs.map(i => i.copy());          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;          const retain  = await evalNumberValue(this.retain, parse);         const finalize = this.finalize.value > 0;           this.value = new x1834();          this.value.objects = [];           for (let i = 0, o = 0; i < this.inputs.length; i++)         {             await this.inputs[i].eval(parse);              const objects = w3534(this.inputs[i].value);                                   if (   this.options.enabled                 && (   finalize                     || retain.value == 1))             {                 for (let j = 0; j < objects.length; j++, o++)                 {                     let c111 = objects[j];                                            c111.nodeId   = this.nodeId;                     c111.objectId = c111.objectId + b965 + this.nodeId;                     c111.listId   = -1;                      if (  (   !isEmpty(c111.fills  )                            || !isEmpty(c111.strokes))                         && !c111.p3636)                             c111.retain = finalize ? 2 : 1;                                                  this.value.objects.push(c111);                 }             }         }           this.h3980(parse, [['', new p4096()]]);           this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && !this.inputs.find(i => !i.isValid())             && this.retain && this.retain.isValid();     }        o3967(parse)     {         super.o3967(parse);          this.inputs.forEach(i => i.o3967(parse));          if (this.retain) this.retain.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          this.inputs.forEach(i => i.y3968(parse, from, force));          if (this.retain) this.retain.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          this.inputs.forEach(i => i.l3966(parse));          if (this.retain) this.retain.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const retain = new c1783(nodeId, options);                   let z4088 = 0;                  if (!ignore)             z4088 = parseInt(parse.move());                   if (parse.settings.logRequests)              x1937(retain, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, retain);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   for (let i = 0; i < z4088; i++)             retain.inputs.push(t1607(parse));              retain.retain  = t1607(parse);         retain.finalize = t1607(parse);                   parse.p3553--;                   genParseNodeEnd(parse, retain);         return retain;     } }


class t2346 extends x1788 {     static { d1855.types[EXPORT] = this; }        inputs = [];      scale;     format;         suffix;          constructor(nodeId, options)     {         super(EXPORT, nodeId, options);     }        reset()     {         super.reset();          this.inputs = [];                  this.scale    = null;         this.format   = null;                     this.suffix   = null;           }        copy()     {         const copy = new t2346(this.nodeId, this.options);          copy.m3266(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.scale   ) copy.scale    = this.scale   .copy();         if (this.format  ) copy.format   = this.format  .copy();                     if (this.suffix  ) copy.suffix   = this.suffix  .copy();                return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const scale      = await evalNumberValue(this.scale,    parse);         const format     = await evalNumberValue(this.format,   parse);                     const suffix     = await evalTextValue  (this.suffix,   parse);                 this.value = new x1834();          this.value.objects = [];           for (let i = 0, o = 0; i < this.inputs.length; i++)         {             await this.inputs[i].eval(parse);              const objects = w3534(this.inputs[i].value);                                   for (let j = 0; j < objects.length; j++, o++)             {                 let c111 = objects[j];                                    c111.nodeId   = this.nodeId;                 c111.objectId = c111.objectId + b965 + this.nodeId;                 c111.listId   = -1;                  this.value.objects.push(c111);             }         }           this.h3980(parse,          [             ['objectIds', new x1834(this.value.objects.map(o => new e1846(o.objectId)))]         ]);           this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && !this.inputs.find(i => !i.isValid())             && this.scale    && this.scale   .isValid()             && this.format   && this.format  .isValid()                                 && this.suffix   && this.suffix  .isValid();               }        o3967(parse)     {         super.o3967(parse);          this.inputs.forEach(i => i.o3967(parse));          if (this.scale   ) this.scale   .o3967(parse);         if (this.format  ) this.format  .o3967(parse);                     if (this.suffix  ) this.suffix  .o3967(parse);           }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          this.inputs.forEach(i => i.y3968(parse, from, force));          if (this.scale   ) this.scale   .y3968(parse, from, force);         if (this.format  ) this.format  .y3968(parse, from, force);                     if (this.suffix  ) this.suffix  .y3968(parse, from, force);           }        l3966(parse)     {         super.l3966(parse);          this.inputs.forEach(i => i.l3966(parse));          if (this.scale   ) this.scale   .l3966(parse);         if (this.format  ) this.format  .l3966(parse);                     if (this.suffix  ) this.suffix  .l3966(parse);           }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const _export = new t2346(nodeId, options);                   let z4088 = 0;                  if (!ignore)             z4088 = parseInt(parse.move());                   if (parse.settings.logRequests)              x1937(_export, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, _export);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   for (let i = 0; i < z4088; i++)             _export.inputs.push(t1607(parse));              _export.scale    = t1607(parse);         _export.format   = t1607(parse);                     _export.suffix   = t1607(parse);         _export.profile  = t1607(parse);                   parse.p3553--;                   genParseNodeEnd(parse, _export);         return _export;     } }


class o1775 extends y1857 {     static { d1855.types[a1250] = this; }        z3568    = null;     x           = null;     y           = null;     affectSpace = null;          _a          = 0;        constructor(nodeId, options)     {         super(a1250, nodeId, options);     }        reset()     {         super.reset();          this.z3568    = null;         this.x           = null;         this.y           = null;         this.affectSpace = null;          this._a          = 0;     }        copy()     {         const copy = new o1775(this.nodeId, this.options);          copy.m3266(this);          if (this.z3568   ) copy.z3568    = this.z3568   .copy();         if (this.x          ) copy.x           = this.x          .copy();         if (this.y          ) copy.y           = this.y          .copy();         if (this.affectSpace) copy.affectSpace = this.affectSpace.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const input       = await evalValue      (this.input,       parse);         const z3568    = await evalNumberValue(this.z3568,    parse);         const x           = await evalNumberValue(this.x,           parse);         const y           = await evalNumberValue(this.y,           parse);         const affectSpace = await evalNumberValue(this.affectSpace, parse);           if (input)         {             this.value = input.copy();              if (this.value)                 this.value.nodeId = this.nodeId;         }         else         {             this.value = new p4096();         }           await this.q3979(             parse,              {                 z3568:    z3568,                 x:           x,                  y:           y,                 affectSpace: affectSpace             });           this.h3980(parse,         [             ['type',        this.outputType()],             ['moveType',    z3568         ],             ['x',           x                ],             ['y',           y                ],             ['affectSpace', affectSpace      ]         ]);           this.validate();          return this;     }        async q3979(parse, options = {})     {         if (   this.value             && this.value.isValid()             && options.z3568             && options.x             && options.y             && options.affectSpace)         {             this.value.objects = w3534(this.input.value);               if (l955(this.value.type))             {                 for (let i = 0; i < this.value.items.length; i++)                     this.value.items[i].objects = this.value.objects.filter(o => o.n3717 == i);             }                              const z3568    = options.z3568   .value;             const x           = options.x          .value;             const y           = options.y          .value;             const affectSpace = options.affectSpace.value;               let _a = y/360*Tau;              while (_a <  0  ) _a += Tau;             while (_a >= Tau) _a -= Tau;                   const _v = vector(_a, x);                          const _x = z3568 == 0 ? x : _v.x;             const _y = z3568 == 0 ? y : _v.y;               const u4087 =                  z3568 == 0                 ? v891(_x, _y)                 : g887(                     v891(_x, _y),                     l890(-_a));                                    for (const c111 of this.value.objects)             {                 c111.nodeId    = this.nodeId;                 c111.objectId += b965 + this.nodeId;                  if (this.options.enabled)                     c111.h3978(u4087, affectSpace);             }               if (   this.value.type == c1229                 && this.value.objects                 && this.value.objects.length > 0                 && this.value.points.objects)             {                 for (let i = 0; i < this.value.objects[0].points.length; i++)                 {                     const p = this.value.objects[0].points[i].n3644();                          this.value.points.objects[i].x = p.x;                     this.value.points.objects[i].y = p.y;                 }             }         }                           await super.q3979(parse);     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }                    isValid()     {         return super.isValid()             && this.z3568    && this.z3568   .isValid()             && this.x           && this.x          .isValid()             && this.y           && this.y          .isValid()             && this.affectSpace && this.affectSpace.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.z3568   ) this.z3568   .o3967(parse);         if (this.x          ) this.x          .o3967(parse);         if (this.y          ) this.y          .o3967(parse);         if (this.affectSpace) this.affectSpace.o3967(parse);     }       y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.z3568   ) this.z3568   .y3968(parse, from, force);         if (this.x          ) this.x          .y3968(parse, from, force);         if (this.y          ) this.y          .y3968(parse, from, force);         if (this.affectSpace) this.affectSpace.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.z3568   ) this.z3568   .l3966(parse);         if (this.x          ) this.x          .l3966(parse);         if (this.y          ) this.y          .l3966(parse);         if (this.affectSpace) this.affectSpace.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const move = new o1775(nodeId, options);                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(move, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, move);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             move.input = t1607(parse);              move.z3568    = t1607(parse);         move.x           = t1607(parse);         move.y           = t1607(parse);         move.affectSpace = t1607(parse);                   parse.f1608 = false;         parse.p3553--;                   genParseNodeEnd(parse, move);         return move;     } }


class x1765 extends y1857 {     affectSpace = null;        constructor(type, nodeId, options)     {         super(type, nodeId, options);     }        reset()     {         super.reset();          this.affectSpace = null;     }        m3266(base)     {         super.m3266(base);          if (base.affectSpace) this.affectSpace = base.affectSpace.copy();     }        async evalBaseParams(parse)     {         const affectSpace = await evalNumberValue(this.affectSpace, parse);          return [affectSpace];     }        async evalAffineObjects(parse, options, e3637, scaleStyle, getXform)     {         if (   !this.value             || !this.value.isValid()             || !this.input)             return t1045.NaN;           this.value.objects = w3534(this.input.value);                  if (l955(this.value.type))         {             for (let i = 0; i < this.value.items.length; i++)                 this.value.items[i].objects = this.value.objects.filter(o => o.n3717 == i);         }           const bounds = getObjBounds(this.value.objects);         const u4087  = getXform();           for (const c111 of this.value.objects)         {             c111.nodeId   = this.nodeId;             c111.objectId = c111.objectId + b965 + this.nodeId;               if (this.options.enabled)             {                 c111.h3978(                     u4087,                      options.affectSpace ? options.affectSpace.value : 2);                  c111.checkFlipped(                     options.flipX === true && u4087[0][0] < 0,                      options.flipY === true && u4087[1][1] < 0);                                      c111.e3637 *= Math.abs(e3637);                 c111.scaleStyle   *= Math.abs(scaleStyle  );                                  if (c111.type == d1223)                 {                     const sx = Math.sqrt(sqr(u4087[0][0]) + sqr(u4087[0][1]));                     const sy = Math.sqrt(sqr(u4087[1][0]) + sqr(u4087[1][1]));                      c111.size *= Math.min(sx, sy);                 }             }         }           if (   this.value.type == c1229             && this.value.objects             && this.value.objects.length > 0             && this.value.points.objects)         {             for (let i = 0; i < this.value.objects[0].points.length; i++)             {                 const p = this.value.objects[0].points[i].n3644();                  this.value.points.objects[i].x = p.x;                 this.value.points.objects[i].y = p.y;             }         }           return bounds;     }        isValid()     {         return super.isValid()             && this.affectSpace && this.affectSpace.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.affectSpace) this.affectSpace.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.affectSpace) this.affectSpace.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.affectSpace) this.affectSpace.l3966(parse);     } }


class j1785 extends x1765 {     static { d1855.types[x1251] = this; }        angle = null;        constructor(nodeId, options)     {         super(x1251, nodeId, options);     }        reset()     {         super.reset();          this.angle = null;     }        copy()     {         const copy = new j1785(this.nodeId, this.options);          copy.m3266(this);          if (this.angle) copy.angle = this.angle.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalValue      (this.input, parse);         const angle = await evalNumberValue(this.angle, parse);           const [affectSpace] = await this.evalBaseParams(parse);           if (input)         {             this.value = input.copy();                          if (this.value)                 this.value.nodeId = this.nodeId;         }         else         {             this.value = new p4096();         }                  const _bounds = await this.q3979(             parse,              {                 angle:       angle,                  affectSpace: affectSpace             });                   const bounds = new d1838(             this.nodeId,             new n1835(_bounds.x     ),              new n1835(_bounds.y     ),              new n1835(_bounds.width ),             new n1835(_bounds.height),             new n1835(0));           this.h3980(parse,         [             ['type',        this.outputType()],             ['angle',       angle            ],             ['affectSpace', affectSpace      ],             ['bounds',      bounds           ]         ]);           this.validate();          return this;     }        async q3979(parse, options)     {         const a     = options.angle ? options.angle.value/360*Tau : 0;         const u4087 = l890(a);          options.flipX = false;         options.flipY = false;          return await this.evalAffineObjects(             parse,             options,              1,              1,             () => u4087);     }        toNewValue()     {         return this.value         ? this.value.copy()         : null;     }                    isValid()     {         return super.isValid()             && this.angle && this.angle.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.angle) this.angle.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.angle) this.angle.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.angle) this.angle.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const rotate = new j1785(nodeId, options);                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(rotate, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, rotate);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             rotate.input = t1607(parse);              rotate.angle       = t1607(parse);         rotate.affectSpace = t1607(parse);                       parse.f1608 = false;         parse.p3553--;                   genParseNodeEnd(parse, rotate);         return rotate;     } }


class k1786 extends x1765 {     static { d1855.types[t1252] = this; }        scaleX        = null;     scaleY        = null;     affectCorners = null;     affectStyle   = null;            constructor(nodeId, options)     {         super(t1252, nodeId, options);     }        reset()     {         super.reset();          this.scaleX        = null;         this.scaleY        = null;         this.affectCorners = null;         this.affectStyle   = null;     }        copy()     {         const copy = new k1786(this.nodeId, this.options);          copy.m3266(this);          if (this.scaleX       ) copy.scaleX        = this.scaleX       .copy();         if (this.scaleY       ) copy.scaleY        = this.scaleY       .copy();         if (this.affectCorners) copy.affectCorners = this.affectCorners.copy();         if (this.affectStyle  ) copy.affectStyle   = this.affectStyle  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input         = await evalValue      (this.input,         parse);         let   scaleX        = await evalNumberValue(this.scaleX,        parse);         let   scaleY        = await evalNumberValue(this.scaleY,        parse);         let   affectCorners = await evalNumberValue(this.affectCorners, parse);         let   affectStyle   = await evalNumberValue(this.affectStyle,   parse);           const [affectSpace] = await this.evalBaseParams(parse);           if (input)         {             this.value = input.copy();                          if (this.value)                 this.value.nodeId = this.nodeId;         }         else         {             this.value = new p4096();         }                  const _bounds = await this.q3979(             parse,              {                 scaleX:        scaleX,                  scaleY:        scaleY,                  affectSpace:   affectSpace,                 affectCorners: affectCorners,                 affectStyle:   affectStyle             });           const bounds = new d1838(             this.nodeId,             new n1835(_bounds.x     ),              new n1835(_bounds.y     ),              new n1835(_bounds.width ),             new n1835(_bounds.height),             new n1835(0));           this.h3980(parse,         [             ['type',          this.outputType()],             ['scaleX',        scaleX           ],             ['scaleY',        scaleY           ],             ['affectSpace',   affectSpace      ],             ['affectCorners', affectCorners    ],             ['affectStyle',   affectStyle      ],             ['bounds',        bounds           ]         ]);                   this.validate();          return this;     }        async q3979(parse, options)     {         let sx = d877(options.scaleX.value / 100);         let sy = d877(options.scaleY.value / 100);          options.flipX = sx < 0;         options.flipY = sy < 0;                  const scale = Math.min(sx, sy);          return await this.evalAffineObjects(             parse,             options,              this.affectCorners.value > 0 ? scale : 1,             this.affectStyle  .value > 0 ? scale : 1,             () => [[sx, 0,  0],                    [0,  sy, 0],                    [0,  0,  1]]);     }        isValid()     {         return super.isValid()             && this.scaleX        && this.scaleX       .isValid()             && this.scaleY        && this.scaleY       .isValid()             && this.affectCorners && this.affectCorners.isValid()             && this.affectStyle   && this.affectStyle  .isValid();     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        o3967(parse)     {         super.o3967(parse);          if (this.scaleX       ) this.scaleX       .o3967(parse);         if (this.scaleY       ) this.scaleY       .o3967(parse);         if (this.affectCorners) this.affectCorners.o3967(parse);         if (this.affectStyle  ) this.affectStyle  .o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.scaleX       ) this.scaleX       .y3968(parse, from, force);         if (this.scaleY       ) this.scaleY       .y3968(parse, from, force);         if (this.affectCorners) this.affectCorners.y3968(parse, from, force);         if (this.affectStyle  ) this.affectStyle  .y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.scaleX       ) this.scaleX       .l3966(parse);         if (this.scaleY       ) this.scaleY       .l3966(parse);         if (this.affectCorners) this.affectCorners.l3966(parse);         if (this.affectStyle  ) this.affectStyle  .l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const scale = new k1786(nodeId, options);                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(scale, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, scale);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             scale.input = t1607(parse);              scale.scaleX        = t1607(parse);         scale.scaleY        = t1607(parse);         scale.affectCorners = t1607(parse);         scale.affectStyle   = t1607(parse);         scale.affectSpace   = t1607(parse);                       parse.f1608 = false;         parse.p3553--;                   genParseNodeEnd(parse, scale);         return scale;     } }


class r1790 extends x1765 {     static { d1855.types[p1253] = this; }        skewX = null;     skewY = null;        constructor(nodeId, options)     {         super(p1253, nodeId, options);     }        reset()     {         super.reset();          this.skewX = null;         this.skewY = null;     }        copy()     {         const copy = new r1790(this.nodeId, this.options);          copy.m3266(this);          if (this.skewX) copy.skewX = this.skewX.copy();         if (this.skewY) copy.skewY = this.skewY.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const input = await evalValue      (this.input, parse);         let   skewX = await evalNumberValue(this.skewX, parse);         let   skewY = await evalNumberValue(this.skewY, parse);           const [affectSpace] = await this.evalBaseParams(parse);           if (input)         {             this.value = input;              if (this.value)                 this.value.nodeId = this.nodeId;         }         else         {             this.value = new p4096();         }                   const _bounds = await this.q3979(             parse,              {                 skewX:       skewX,                  skewY:       skewY,                  affectSpace: affectSpace             });           const bounds = new d1838(             this.nodeId,             new n1835(_bounds.x     ),              new n1835(_bounds.y     ),              new n1835(_bounds.width ),             new n1835(_bounds.height),             new n1835(0));           this.h3980(parse,         [             ['type',        this.outputType()],             ['skewX',       skewX            ],             ['skewY',       skewY            ],             ['affectSpace', affectSpace      ],             ['bounds',      bounds           ]         ]);           this.validate();          return this;     }        async q3979(parse, options)     {         const sx = -options.skewX.value / 100;         const sy = -options.skewY.value / 100;          options.flipX = false;         options.flipY = false;          return await this.evalAffineObjects(             parse,             options,              1, 1,             () => [[1,  sx, 0],                    [sy, 1,  0],                    [0,  0,  1]]);     }        isValid()     {         return super.isValid()             && this.skewX && this.skewX.isValid()             && this.skewY && this.skewY.isValid();     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        o3967(parse)     {         super.o3967(parse);          if (this.skewX) this.skewX.o3967(parse);         if (this.skewY) this.skewY.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.skewX) this.skewX.y3968(parse, from, force);         if (this.skewY) this.skewY.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.skewX) this.skewX.l3966(parse);         if (this.skewY) this.skewY.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const skew = new r1790(nodeId, options);                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(skew, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, skew);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             skew.input = t1607(parse);              skew.skewX       = t1607(parse);         skew.skewY       = t1607(parse);         skew.affectSpace = t1607(parse);                   parse.f1608 = false;         parse.p3553--;                   genParseNodeEnd(parse, skew);         return skew;     } }


class k2363 extends y1857 {     static { d1855.types[SHOW_CENTER] = this; }        show = null;        constructor(nodeId, options)     {         super(SHOW_CENTER, nodeId, options);     }        copy()     {         const copy = new k2363(this.nodeId, this.options);          copy.m3266(this);          if (this.show) copy.show = this.show.copy();                  return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalValue      (this.input, parse);         const show  = await evalNumberValue(this.show,  parse);           if (   input             && show)         {             this.value = input;              this.value.nodeId = this.nodeId;         }         else             this.value = new p4096();                   await this.q3979(parse, {show: show && show.value > 0});           const type = this.outputType();          this.h3980(parse,         [             ['type', type],             ['show', show]         ]);           this.validate();          return this;     }        async q3979(parse, options = {})     {         if (   this.value             && this.value.isValid())         {             this.value.objects = w3534(this.input.value);               for (const c111 of this.value.objects)             {                 c111.nodeId   = this.nodeId;                 c111.objectId = c111.objectId + b965 + this.nodeId;                                  if (   this.options.enabled                     && options.show)                     c111.showCenter = options.show;             }         }                           await super.q3979(parse);     }        toNewValue()     {         return this.value         ? this.value.copy()         : null;     }        isValid()     {         return super.isValid()             && this.show && this.show.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.show) this.show.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.show) this.show.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.show) this.show.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const showCenter = new k2363(nodeId, options);                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(showCenter, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, showCenter);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             showCenter.input = t1607(parse);              showCenter.show = t1607(parse);                   parse.f1608 = false;         parse.p3553--;                   genParseNodeEnd(parse, showCenter);         return showCenter;     } }


class i1767 extends y1857 {     static { d1855.types[k1254] = this; }        centerX = null;     centerY = null;     units   = null;        constructor(nodeId, options)     {         super(k1254, nodeId, options);     }        reset()     {         super.reset();          this.centerX = null;         this.centerY = null;         this.units   = null;     }        copy()     {         const copy = new i1767(this.nodeId, this.options);          copy.m3266(this);          if (this.centerX) copy.centerX = this.centerX.copy();         if (this.centerY) copy.centerY = this.centerY.copy();         if (this.units  ) copy.units   = this.units  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const input   = await evalValue      (this.input,   parse);         const centerX = await evalNumberValue(this.centerX, parse);         const centerY = await evalNumberValue(this.centerY, parse);         const units   = await evalNumberValue(this.units,   parse);           if (this.input)         {             this.value = input.copy();              if (this.value)                 this.value.nodeId = this.nodeId;         }         else         {             this.value = new p4096();         }                   await this.q3979(             parse,              {                 centerX:    centerX,                  centerY:    centerY,                 units:      units             });           const type = this.outputType();          this.h3980(parse,         [             ['type',    type   ],             ['centerX', centerX],             ['centerY', centerY],             ['units',   units  ]         ]);           this.validate();          return this;     }        async q3979(parse, options = {})     {         if (   this.value             && this.value.isValid())         {             this.value.objects = w3534(this.input.value);                           const centerX = options.centerX ? options.centerX .value : 0;             const centerY = options.centerY ? options.centerY .value : 0;             const units   = options.units   ? options.units   .value : 0;                   const cx      = units == 0 ? centerX/100 : centerX;             const cy      = units == 0 ? centerY/100 : centerY;               const bounds  = getObjBounds(this.value.objects);               const singlePoint =                      this.value.objects.length  == 1                  && this.value.objects[0].type == y1226;               for (const c111 of this.value.objects)             {                 c111.nodeId   = this.nodeId;                 c111.objectId = c111.objectId + b965 + this.nodeId;                  if (this.options.enabled)                     c111.resetSpace(bounds, singlePoint, cx, cy, units);             }         }                           await super.q3979(parse);     }        toNewValue()     {         return this.value             ? this.value.copy()             : null;     }                    isValid()     {         return super.isValid()             && this.centerX && this.centerX.isValid()             && this.centerY && this.centerY.isValid()             && this.units   && this.units  .isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.centerX) this.centerX.o3967(parse);         if (this.centerY) this.centerY.o3967(parse);         if (this.units  ) this.units  .o3967(parse);     }       y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.centerX) this.centerX.y3968(parse, from, force);         if (this.centerY) this.centerY.y3968(parse, from, force);         if (this.units  ) this.units  .y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.centerX) this.centerX.l3966(parse);         if (this.centerY) this.centerY.l3966(parse);         if (this.units  ) this.units  .l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const center = new i1767(nodeId, options);                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(center, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, center);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             center.input = t1607(parse);              center.centerX    = t1607(parse);         center.centerY    = t1607(parse);         center.units      = t1607(parse);                   parse.f1608 = false;         parse.p3553--;                   genParseNodeEnd(parse, center);         return center;     } }


class i1784 extends y1857 {     static { d1855.types[r1255] = this; }        constructor(nodeId, options)     {         super(r1255, nodeId, options);     }        copy()     {         const copy = new i1784(this.nodeId, this.options);          copy.m3266(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalValue(this.input, parse);           if (input)         {             this.value = input;              this.value.nodeId = this.nodeId;         }         else             this.value = new p4096();                   await this.q3979(parse);           const type = this.outputType();          this.h3980(parse,         [             ['type', type]         ]);           this.validate();          return this;     }        async q3979(parse, options = {})     {         if (   this.value             && this.value.isValid())         {             this.value.objects = w3534(this.input.value);               const bounds = getObjBounds(this.value.objects);              const singlePoint =                    this.value.objects.length  == 1                  && this.value.objects[0].type == y1226;               for (const c111 of this.value.objects)             {                 c111.nodeId    = this.nodeId;                 c111.objectId += b965 + this.nodeId;                  if (this.options.enabled)                 {                     c111.w3639();                     c111.resetSpace(bounds, singlePoint);                 }             }         }                           await super.q3979(parse);     }        toNewValue()     {         return this.value         ? this.value.copy()         : null;     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const reset = new i1784(nodeId, options);                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(reset, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, reset);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             reset.input = t1607(parse);                   parse.p3553--;                   genParseNodeEnd(parse, reset);         return reset;     } }


class g2357 extends m1787 {     static { d1855.types[JOIN_PATHS] = this; }        inputs  = [];      closed  = null;     degree  = null;     winding = null;     round   = null;        constructor(nodeId, options)     {         super(JOIN_PATHS, nodeId, options);     }        reset()     {         super.reset();          this.inputs  = [];          this.closed  = null;         this.degree  = null;         this.winding = null;         this.round   = null;     }        copy()     {         const copy = new g2357(this.nodeId, this.options);          copy.m3266(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.closed ) copy.closed  = this.closed .copy();         if (this.degree ) copy.degree  = this.degree .copy();         if (this.winding) copy.winding = this.winding.copy();         if (this.round  ) copy.round   = this.round  .copy();          return copy;     }        x4121(i2902)     {         switch (i2902)         {             case 'closed':  return this.input ? this.value.closed  : this.closed;             case 'degree':  return this.input ? this.value.degree  : this.degree;             case 'winding': return this.input ? this.value.winding : this.winding;             case 'round':   return this.input ? this.value.round   : this.round;         }          return super.x4121(i2902);     }        async eval(parse)     {         if (this.isCached())             return this;           const closed  = await evalNumberValue(this.closed,  parse);         const degree  = await evalNumberValue(this.degree,  parse);         const winding = await evalNumberValue(this.winding, parse);         const round   = await evalNumberValue(this.round,   parse);           if (this.inputs.length > 0)         {             const paths  = [];             const points = new x1834();              for (const s3709 of this.inputs)             {                 const input = await evalVectorPathValue(s3709, parse);                  if (l955(input.type)) paths.push(...input.items);                 else                             paths.push(input);             }                                          for (let i = 0; i < paths.length; i++)             {                 const path = paths[i];                                  if (   !path                     || !path.objects                     ||  path.objects.length == 0)                     continue;                   let _degree;                       if (path.type == c1229) _degree = path.degree.value;                 else if (path.type == k1211   ) _degree = 2;                 else if (path.type == g1214  ) _degree = path.shape.value == 4 ? 2 : 0;                   const z3643 = path.objects[0].z3643;                 const pathDegree = Math.min(_degree, 2) + 1;                                   if (z3643.length == 0) continue;                   const segment = this.makeCubic(z3643, pathDegree);                  if (   i > 0                     && points.items.length > 1                     && segment.length > 1)                     this.joinSegment(points, segment, degree);                  points.items.push(...segment.map(p => r1836.fromPoint(this.nodeId, p)));             }               if (   closed.value > 0                 && points.items.length > 1)             {                 const segment = [ points.items[0].n3644(),                                   points.items[1].n3644() ];                  this.joinSegment(points, segment, degree);                  points.items.push(points.items[0].copy());             }               this.value = new n1850(                 this.nodeId,                  points,                  closed,                  new n1835(2),                 winding,                  round);               this.value.points.objects = this.value.points.items.map(p =>             {                 return new s1657(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     p.x.value,                     p.y.value,                     p.smooth ? p.smooth.value/100 : 1);             });         }         else         {             this.value = new n1850(                 this.nodeId,                  new x1834(),                  closed,                  new n1835(2),                 winding,                  round);         }           this.h3980(parse,          [             ['closed',  closed ],             ['degree',  degree ],             ['winding', winding],             ['round',   round  ]         ]);           await this.q2806(parse);           await this.q3979(parse);           this.validate();          return this;     }        joinSegment(points, segment, degree)     {         const p_2 = points.items.at(-2).n3644();         const p_1 = points.items.at(-1).n3644();          const p0  = segment[0];         const p1  = segment[1];          if (!q1017(p_1, p0))             points.items.push(...this.getJoinPoints(p_2, p_1, p0, p1, degree).map(p => r1836.fromPoint(this.nodeId, p)));         else             points.items.pop();     }        getJoinPoints(p_2, p_1, p0, p1, degree)     {         const points = [];           switch (degree.value)         {              case 0:                  points.push(c984(p_1, p0, 1/3));                 points.push(c984(p_1, p0, 2/3));                 break;              case 1:              {                 const c = t987(p_2, p_1, p1, p0, false);                 points.push(y893(p_1, y895(i884(j898(c, p_1)), Math.min(distv(p_2, p_1), distv(p_1, c) * 2/3))));                 points.push(y893(p0,  y895(i884(j898(c, p0 )), Math.min(distv(p1,  p0),  distv(p0,  c) * 2/3))));                 break;             }             case 2:                  points.push(y893(p_2, y895(j898(p_1, p_2), 2)));                 points.push(y893(p1,  y895(j898(p0,  p1),  2)));                 break;              case 3:                  points.push(point(t1033(p_1.x, p0.x, 0.3615), p_1.y));                 points.push(point(t1033(p0.x, p_1.x, 0.3615), p0 .y));                 break;              case 4:                  points.push(point(p_1.x, t1033(p_1.y, p0.y, 0.3615)));                 points.push(point(p0 .x, t1033(p0.y, p_1.y, 0.3615)));                 break;         }                   return points;     }        makeCubic(z3643, pathDegree)     {         const points = [z3643[0]];           for (let i = 0; i < z3643.length-pathDegree; i += pathDegree)         {             let segPoints;              switch (pathDegree)             {                 case 1: segPoints = linear2cubic(z3643.slice(i, i+2)); break;                 case 2: segPoints =   quad2cubic(z3643.slice(i, i+3)); break;                 case 3: segPoints =              z3643.slice(i, i+4);  break;             }              points.push(...segPoints.slice(1));          }                  return points;     }        async q3979(parse, options = {})     {         if (!this.options.enabled)             return;                       const points = [];          for (const pt of this.value.points.items)         {             const p = r1836.create(this.nodeId, pt.x.value, pt.y.value);                          if (pt.smooth != null)                 p.smooth = new n1835(pt.smooth);              points.push(p);         }           this.value.objects = [];           if (   super.i2807()                && points.length >= 2             && this.value.closed .isValid()             && this.value.degree .isValid()             && this.value.winding.isValid()             && this.value.round  .isValid())         {             const path = new w1666(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 points,                 this.value.closed .value,                 this.value.degree .value,                 this.value.winding.value,                 this.value.round  .value);                               const bounds = getObjBounds([path]);              let x = bounds.x;             let y = bounds.y;             let w = bounds.w;             let h = bounds.h;                           path.w3639(x + w/2, y + h/2);             path.m3977(x, y);             path.p3627(x, y, w, h);              this.value.objects.push(path);         }           await super.q3979(parse);     }        isValid()     {         if (!super.isValid())              return false;          for (const input of this.inputs)             if (!input.isValid())                 return false;          return this.closed  && this.closed .isValid()             && this.degree  && this.degree .isValid()             && this.winding && this.winding.isValid()             && this.round   && this.round  .isValid();     }        o3967(parse)     {         super.o3967(parse);          this.inputs.forEach(i => i.o3967(parse));          if (this.closed ) this.closed .o3967(parse);         if (this.degree ) this.degree .o3967(parse);         if (this.winding) this.winding.o3967(parse);         if (this.round  ) this.round  .o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          this.inputs.forEach(i => i.y3968(parse, from, force));          if (this.closed ) this.closed .y3968(parse, from, force);         if (this.degree ) this.degree .y3968(parse, from, force);         if (this.winding) this.winding.y3968(parse, from, force);         if (this.round  ) this.round  .y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          this.inputs.forEach(i => i.l3966(parse));          if (this.closed ) this.closed .l3966(parse);         if (this.degree ) this.degree .l3966(parse);         if (this.winding) this.winding.l3966(parse);         if (this.round  ) this.round  .l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const join = new g2357(nodeId, options);                   let z4088 = 0;                  if (!ignore)             z4088 = parseInt(parse.move());                   if (parse.settings.logRequests)              x1937(join, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, join);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   for (let i = 0; i < z4088; i++)             join.inputs.push(t1607(parse));                   const u3571 = genParseParamCount(parse);              for (let i = 0; i < u3571; i++)         {             const i2902 = genParseParamId(parse);                  parse.f1608 = true;                  switch (i2902)             {                    case 'closed':  join.closed  = t1607(parse); break;             case 'degree':  join.degree  = t1607(parse); break;             case 'winding': join.winding = t1607(parse); break;             case 'round':   join.round   = t1607(parse); break;             case 'props':   join.props   = t1607(parse); break;             }         }                   parse.f1608 = false;         parse.p3553--;                   genParseNodeEnd(parse, join);         return join;     } }


class e2352 extends m1787 {     static { d1855.types[REORIENT_PATHS] = this; }        inputs  = [];      reverse = null;        constructor(nodeId, options)     {         super(REORIENT_PATHS, nodeId, options);     }        reset()     {         super.reset();          this.inputs  = [];          this.reverse = null;     }        copy()     {         const copy = new e2352(this.nodeId, this.options);          copy.m3266(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.reverse) copy.reverse = this.reverse.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const reverse = await evalNumberValue(this.reverse, parse);           if (this.inputs.length > 0)         {             const paths = [];              for (const s3709 of this.inputs)             {                 const input = await evalVectorPathValue(s3709, parse);                  if (l955(input.type)) paths.push(...input.items);                 else                             paths.push(input);             }               this.value = new x1834();               const reorientedPaths =                  this.options.enabled                 ? e2352.reorientPaths(paths, reverse.value > 0)                 : paths                       .filter(path => path.objects && path.objects.length > 0)                       .map   (path => path.objects[0].z3643);         ;              r950(paths.length == reorientedPaths.length, 'original path count must match reoriented path count');                                       for (let i = 0; i < reorientedPaths.length; i++)             {                 const points =                      reorientedPaths[i]                     ? reorientedPaths[i].map(p => r1836.fromPoint(this.nodeId, p))                     :    paths[i]                     && paths[i].points                     ? paths[i].points.items                     : [];                  if (points.length == 0)                     continue;                                  const path = new n1850(                     this.nodeId,                     new x1834(points),                     paths[i].closed,                     paths[i].degree,                     paths[i].winding,                     paths[i].round);                                      path.m3266(paths[i]);                                  this.value.items.push(path);             }         }         else         {             this.value = new x1834();         }           this.h3980(parse,          [             ['reverse', reverse]         ]);           await this.q2806(parse);           await this.q3979(parse);           this.validate();          return this;     }        async q3979(parse, options = {})     {         this.value.objects = [];           for (let i = 0; i < this.value.items.length; i++)         {             const _path = this.value.items[i];             if (!_path) continue;               if (   _path.points.items.length >= 2                 && _path.closed .isValid()                 && _path.degree .isValid()                 && _path.winding.isValid()                 && _path.round  .isValid())             {                 const path = new w1666(                      this.nodeId,                      this.nodeId + b965 + i,                      this.nodeName,                     _path.points.items,                     _path.closed .value,                     _path.degree .value,                     _path.winding.value,                     _path.round  .value);                   if (_path.props)                     addProps(path, _path.props);                                       _path.objects = [path];                  this.value.objects.push(path);             }         }           const bounds = getObjBounds(this.value.objects);          for (const path of this.value.objects)         {             path.w3639(                 bounds.x + bounds.width /2,                             bounds.y + bounds.height/2                         );               let x = bounds.x;             let y = bounds.y;             let w = bounds.w;             let h = bounds.h;                          path.m3977(x, y);             path.p3627(x, y, w, h);         }           await super.q3979(parse);     }        isValid()     {         if (!super.isValid())              return false;          for (const input of this.inputs)             if (!input.isValid())                 return false;          return this.reverse && this.reverse.isValid();     }        o3967(parse)     {         super.o3967(parse);          this.inputs.forEach(i => i.o3967(parse));          if (this.reverse) this.reverse.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          this.inputs.forEach(i => i.y3968(parse, from, force));              if (this.reverse) this.reverse.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          this.inputs.forEach(i => i.l3966(parse));          if (this.reverse) this.reverse.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const reorient = new e2352(nodeId, options);                   let z4088 = 0;                  if (!ignore)             z4088 = parseInt(parse.move());                   if (parse.settings.logRequests)              x1937(reorient, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, reorient);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   for (let i = 0; i < z4088; i++)             reorient.inputs.push(t1607(parse));                   reorient.reverse = t1607(parse);                               parse.f1608 = false;         parse.p3553--;                   genParseNodeEnd(parse, reorient);         return reorient;     }        static reorientPaths(paths, reverse)      {         const orderedPaths = [];          let remainingPaths = paths             .filter(path => path.objects && path.objects.length > 0)             .map   (path => path.objects[0].z3643);           orderedPaths.push(remainingPaths.shift());           while (remainingPaths.length > 0)          {             const currentPath = orderedPaths.at(-1);                          const { closestPathIndex, shouldReverse } = e2352.findNextPath(currentPath, remainingPaths);              if (closestPathIndex == -1)                  break;               let nextPath = remainingPaths.splice(closestPathIndex, 1)[0];                          if (shouldReverse)                 nextPath.reverse();              orderedPaths.push(nextPath);         }           return reverse             ? orderedPaths.reverse().map(path => path.slice().reverse())             : orderedPaths;     }        static findNextPath(currentPath, remainingPaths)     {         let minDistance      = Infinity;         let closestPathIndex = -1;         let shouldReverse    = false;           const currentEndPoint = currentPath.at(-1);          remainingPaths.forEach((path, index) =>          {             const distanceToStart = distv(currentEndPoint, path.at( 0));             const distanceToEnd   = distv(currentEndPoint, path.at(-1));              if (distanceToStart < minDistance)              {                 minDistance      = distanceToStart;                 closestPathIndex = index;                 shouldReverse    = false;             }              if (distanceToEnd < minDistance)              {                 minDistance      = distanceToEnd;                 closestPathIndex = index;                 shouldReverse    = true;             }         });           return { closestPathIndex, shouldReverse };     } }


class h1774 extends y1857 {     static { d1855.types[g1258] = this; }        length = null;     angle  = null;            constructor(nodeId, options)     {         super(g1258, nodeId, options);     }            reset()     {         super.reset();          this.length = null;         this.angle  = null;     }        copy()     {         const copy = new h1774(this.nodeId, this.options);          copy.m3266(this);          if (this.length) copy.length = this.length.copy();         if (this.angle ) copy.angle  = this.angle .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalPointValue(this.input, parse);           if (input)         {             const v   = input.n3644();              const len = a883(v);             let   ang = n881 (v);              if (ang > Tau/2) ang -= Tau;              this.length = new n1835(len, -2);              this.angle =                  len > 0                  ? new n1835(ang/Tau * 360, -2)                  : n1835.NaN();         }         else         {             this.length = n1835.NaN();             this.angle  = n1835.NaN();         }           this.h3980(parse,         [             ['length', this.length],             ['angle',  this.angle ]         ]);                   this.validate();          return this;     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const measure = new h1774(nodeId, options);                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(measure, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, measure);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                       if (z4088 == 1)             measure.input = t1607(parse);                                 parse.p3553--;                   genParseNodeEnd(parse, measure);         return measure;     } }


class t2386 extends y1857 {     static { d1855.types[v1259] = this; }        constructor(nodeId, options)     {         super(v1259, nodeId, options);     }            copy()     {         const copy = new t2386(this.nodeId, this.options);          copy.m3266(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalPointValue(this.input, parse);           if (input)         {             if (l955(input.type))             {                 this.value = new x1834();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                     const c111  = input.objects[i];                      this.value.items.push(                         item.type == p1225                         ? new n1835(anglev2(c111.sp0, c111.sp1) / Tau * 360)                         : n1835.NaN());                    }             }             else             {                 if (input.objects)                 {                     const c111 = input.objects[0];                     this.value = new n1835(anglev2(c111.sp0, c111.sp1) / Tau * 360);                 }             }         }         else             this.value = n1835.NaN();           this.h3980(parse,         [                          ['type',  this.outputType()]         ]);           this.validate();          return this;     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const angle = new t2386(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(angle, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, angle);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             angle.input = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, angle);         return angle;     } }         


class x1795 extends e1858 {     static { d1855.types[z1260] = this; }        transform = null;        constructor(nodeId, options)     {         super(z1260, nodeId, options);     }            reset()     {         super.reset();                  this.transform = null;     }        copy()     {         const copy = new x1795(this.nodeId, this.options);          copy.m3266(this);          if (this.transform) copy.transform = this.transform .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const e3962    = await evalPointValue (this.e3962,    parse);         const d3963    = await evalPointValue (this.d3963,    parse);         const transform = await evalNumberValue(this.transform, parse);           if (   e3962 && e3962.objects && e3962.objects.length > 0 && e3962.objects[0]             && d3963 && d3963.objects && d3963.objects.length > 0 && d3963.objects[0])         {             this.value = r1836.fromPoint(                 this.nodeId,                 j898(d3963.objects[0].n3644(), e3962.objects[0].n3644()));              await this.q3979(                 parse,                  {                     transform: transform,                 });         }         else         {             this.value = r1836.NaN();         }           this.h3980(parse,         [             ['transform', transform]         ]);                   this.validate();          return this;     }        async q3979(parse, options = {})     {                                                     if (!this.value.objects)             this.value.objects = [];           if (   this.value.x             && this.value.y                && this.value.x.isValid()             && this.value.y.isValid())         {             const x = this.value.x.value;             const y = this.value.y.value;              const point = new s1657(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 x,                 y,                 this.smooth ? this.smooth.value/100 : 1);               point.m3977(x, y);                           if (options.transform.value > 0)             {                 point.h3978(                     getTransformFromAngle(n881(point.n3644())),                     2);             }                       this.value.objects = [point];         }           await super.q3979(parse);     }        isValid()     {         return super.isValid()             && this.transform && this.transform.isValid(); }        o3967(parse)     {         super.o3967(parse);          if (this.transform) this.transform.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.transform) this.transform.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.transform) this.transform.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const vector = new x1795(nodeId, options);                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 2, 'nInputs must be [0, 2]');         }                       if (parse.settings.logRequests)              x1937(vector, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, vector);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                       if (z4088 == 2)         {             vector.e3962 = t1607(parse);             vector.d3963 = t1607(parse);         }         else if (z4088 == 1)         {             vector.e3962 = t1607(parse);          }                   vector.transform  = t1607(parse);                   parse.p3553--;                   genParseNodeEnd(parse, vector);         return vector;     } }    function getTransformFromAngle(a)  {     const cosa = Math.cos(a);     const sina = Math.sin(a);      return [[ cosa, -sina, 0 ],              [ sina,  cosa, 0 ],              [ 0,     0,    1 ]]; }


class u1768 extends e1859 {     static { d1855.types[o1261] = this; }        constructor(nodeId, options)     {         super(o1261, nodeId, options);     }                                   copy()     {         const copy = new u1768(this.nodeId, this.options);          copy.m3266(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const e3962 = await evalPointValue(this.e3962, parse);         const d3963 = await evalPointValue(this.d3963, parse);         const k3964 = await evalPointValue(this.k3964, parse);           if (   e3962 && e3962.isValid()             && d3963 && d3963.isValid()             && k3964 && k3964.isValid())         {             const pc = m994(                 e3962.n3644(),                 d3963.n3644(),                 k3964.n3644());              this.value = r1836.fromPoint(this.nodeId, pc);         }         else         {             this.value = r1836.NaN();         }           await this.q3979(parse);           this.h3980(parse,          [             ['', new p4096()]         ]);                   this.validate();          return this;     }        async q3979(parse, options = {})     {         if (!this.options.enabled)             return;                                   this.value.objects = [];           if (   this.value.x.isValid()             && this.value.y.isValid())         {             const x = this.value.x.value;             const y = this.value.y.value;              const point = new s1657(this.nodeId, this.nodeId, this.nodeName, x, y);              point.m3977(x, y);              this.value.objects = [point];         }           await super.q3979(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const center = new u1768(nodeId, options);                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 3, 'nInputs must be [0, 3]');         }                       if (parse.settings.logRequests)              x1937(center, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, center);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                       if (z4088 == 3)         {             center.e3962 = t1607(parse);             center.d3963 = t1607(parse);             center.k3964 = t1607(parse);         }         else if (z4088 == 2)         {             center.e3962 = t1607(parse);             center.d3963 = t1607(parse);         }         else if (z4088 == 1)         {             center.e3962 = t1607(parse);         }                   parse.p3553--;                   genParseNodeEnd(parse, center);         return center;     } }


class p2406 extends m1787 {     static { d1855.types[ARC_FROM_POINTS] = this; }        e3962  = null;     d3963  = null;     k3964  = null;            constructor(nodeId, options)     {         super(ARC_FROM_POINTS, nodeId, options);     }            reset()     {         super.reset();          this.e3962  = null;         this.d3963  = null;         this.k3964  = null;     }        copy()     {         const copy = new p2406(this.nodeId, this.options);          copy.m3266(this);          if (base.e3962 ) this.e3962  = base.e3962 .copy();         if (base.d3963 ) this.d3963  = base.d3963 .copy();         if (base.k3964 ) this.k3964  = base.k3964 .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const e3962 = await evalPointValue(this.e3962, parse);         const d3963 = await evalPointValue(this.d3963, parse);         const k3964 = await evalPointValue(this.k3964, parse);           if (   e3962 && e3962.isValid()             && d3963 && d3963.isValid()             && k3964 && k3964.isValid())         {                           const p0 = e3962.objects[0].n3644();             const p1 = d3963.objects[0].n3644();             const p2 = k3964.objects[0].n3644();              const points = makeArc(p0, p1, p2);              this.value = new n1850(                 this.nodeId,                 new x1834(points.map(p => r1836.fromPoint(this.nodeId, p))),                 new n1835(0),                 new n1835(2),                 new n1835(0),                 new n1835(0));         }         else         {             this.value = n1850.NaN();         }           this.h3980(parse,          [             ['', new p4096()]         ]);           await this.q2806(parse);           await this.q3979(parse);           this.validate();          return this;     }        async q3979(parse, options = {})     {         if (!this.options.enabled)             return;                                   const points = [];          if (this.value.points)         {             for (const pt of this.value.points.items)             {                 const p = r1836.create(this.nodeId, pt.x.value, pt.y.value);                                  if (pt.smooth != null)                     p.smooth = new n1835(pt.smooth);                  points.push(p);             }         }           this.value.objects = [];           if (   points.length >= 2             && this.value             && this.value.closed .isValid()             && this.value.degree .isValid()             && this.value.winding.isValid()             && this.value.round  .isValid())         {             const path = new w1666(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 points,                 this.value.closed .value,                 this.value.degree .value,                 this.value.winding.value,                 this.value.round  .value);                           const bounds = getObjBounds([path]);              let x = bounds.x;             let y = bounds.y;             let w = bounds.w;             let h = bounds.h;                           path.w3639(x + w/2, y + h/2);             path.m3977(x, y);             path.p3627(x, y, w, h);              this.value.objects.push(path);         }           await super.q3979(parse);     }        isValid()     {         return super.isValid()             && this.e3962 && this.e3962.isValid()             && this.d3963 && this.d3963.isValid()             && this.k3964 && this.k3964.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.e3962) this.e3962.o3967(parse);         if (this.d3963) this.d3963.o3967(parse);         if (this.k3964) this.k3964.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.e3962) this.e3962.y3968(parse, from, force);         if (this.d3963) this.d3963.y3968(parse, from, force);         if (this.k3964) this.k3964.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.e3962) this.e3962.l3966(parse);         if (this.d3963) this.d3963.l3966(parse);         if (this.k3964) this.k3964.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const arc = new p2406(nodeId, options);                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 3, 'nInputs must be [0, 3]');         }                       if (parse.settings.logRequests)              x1937(arc, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, arc);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                       if (z4088 == 3)         {             arc.e3962 = t1607(parse);             arc.d3963 = t1607(parse);             arc.k3964 = t1607(parse);         }         else if (z4088 == 2)         {             arc.e3962 = t1607(parse);             arc.d3963 = t1607(parse);         }         else if (z4088 == 1)         {             arc.e3962 = t1607(parse);         }                   const u3571 = genParseParamCount(parse);              for (let i = 0; i < u3571; i++)         {             const i2902 = genParseParamId(parse);                  parse.f1608 = true;                  switch (i2902)             {                    case 'props':   arc.props   = t1607(parse); break;             }         }                   parse.f1608 = false;         parse.p3553--;                   genParseNodeEnd(parse, arc);         return arc;     } }


class g2408 extends y1857 {     static { d1855.types[PATH_LENGTH] = this; }        constructor(nodeId, options)     {         super(PATH_LENGTH, nodeId, options);     }            copy()     {         const copy = new g2408(this.nodeId, this.options);          copy.m3266(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalVectorPathValue(this.input, parse);           if (   input             && input.objects.length > 0)         {             r950(input.type == c1229, 'input must be VECTOR_PATH_VALUE');              const degree = Math.min(input.degree.value, 2) + 1;              const points = createCcompleteCurve(                 degree,                  input.objects[0].z3643,                  input.closed.value > 0);               let length = curveLength(degree, points);               if (input.closed.value > 0)             {                 const endPoints = points.slice(points.length - degree);                 length += curveLength(degree, [...endPoints, points[0]]);             }              this.value = new n1835(length, -2);         }         else             this.value = n1835.NaN();               this.h3980(parse,         [             ['type', this.outputType()]         ]);           this.validate();          return this;     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const len = new g2408(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(len, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, len);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             len.input = t1607(parse);                       parse.p3553--;                   genParseNodeEnd(parse, len);         return len;     } } 


class w1779 extends y1857 {     static { d1855.types[s1264] = this; }        position  = null;     distance  = null;     offset    = null;     transform = null;                    constructor(nodeId, options)     {         super(s1264, nodeId, options);     }            reset()     {         super.reset();          this.position  = null;         this.distance  = null;         this.offset    = null;         this.transform = null;     }        copy()     {         const copy = new w1779(this.nodeId, this.options);          copy.m3266(this);          if (this.position ) copy.position  = this.position .copy();         if (this.distance ) copy.distance  = this.distance .copy();         if (this.offset   ) copy.offset    = this.offset   .copy();         if (this.transform) copy.transform = this.transform.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input     = await evalVectorPathValue(this.input,     parse);         const position  = await evalNumberValue    (this.position,  parse);         const distance  = await evalNumberValue    (this.distance,  parse);         const offset    = await evalNumberValue    (this.offset,    parse);         const transform = await evalNumberValue    (this.transform, parse);           let pt;         let tangent = w982;           if (   input             && input.objects.length > 0)         {             const degree = Math.min(input.degree.value, 2) + 1;              const points = createCompleteCurve(                 degree,                  input.objects[0].z3643,                  input.closed.value > 0);               let length = curveLength(degree, points);                           const dist =                  position.value > 0                  ? distance.value                                                          : Math.min(Math.max(0, distance.value/100), 1) * length;                if (   dist >= 0                  && dist <= length                 && points.length >= degree-1)             {                 pt      =   pointAlongCurve(degree, points, dist);                 tangent = tangentAlongCurve(degree, points, dist);                  this.value = r1836.fromPoint(this.nodeId, pt);             }             else                 this.value = r1836.NaN();         }         else             this.value = r1836.NaN();           this.h3980(parse,         [             ['position',  position ],             ['distance',  distance ],             ['offset',    offset   ],             ['transform', transform]         ]);                   await this.q3979(parse,         {             transform:  transform,             tangent:    tangent,             offset:     offset.value         });           this.validate();          return this;     }        async q3979(parse, options = {})     {         if (!this.options.enabled)             return;                                   if (!this.value.objects)             this.value.objects = [];           if (   this.value.x             && this.value.y                && this.value.x.isValid()             && this.value.y.isValid())         {             const x = this.value.x.value;             const y = this.value.y.value;              const point = new s1657(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 x,                 y,                 this.smooth ? this.smooth.value/100 : 1);              point.m3977(x, y);               if (   options.transform.value > 0                 && options.tangent)             {                 const a     = -n881(options.tangent);                 let   u4087 = v891();                  u4087 = g887(u4087, l890(a));                  if (options.offset)                     u4087 = g887(u4087, v891(0, options.offset));                  point.h3978(u4087, options.transform.value > 0 ? 2 : 0);             }               this.value.objects = [point];         }           await super.q3979(parse);     }        isValid()     {         return super.isValid()             && this.position  && this.position .isValid()             && this.distance  && this.distance .isValid()             && this.offset    && this.offset   .isValid()             && this.transform && this.transform.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.position ) this.position .o3967(parse);         if (this.distance ) this.distance .o3967(parse);         if (this.offset   ) this.offset   .o3967(parse);         if (this.transform) this.transform.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.position ) this.position .y3968(parse, from, force);         if (this.distance ) this.distance .y3968(parse, from, force);         if (this.offset   ) this.offset   .y3968(parse, from, force);         if (this.transform) this.transform.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.position ) this.position .l3966(parse);         if (this.distance ) this.distance .l3966(parse);         if (this.offset   ) this.offset   .l3966(parse);         if (this.transform) this.transform.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const pap = new w1779(nodeId, options);                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(pap, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, pap);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             pap.input = t1607(parse);                    pap.position   = t1607(parse);         pap.distance   = t1607(parse);         pap.offset     = t1607(parse);         pap.transform  = t1607(parse);                   parse.p3553--;                   genParseNodeEnd(parse, pap);         return pap;     } }


class k1780 extends e1858 {     static { d1855.types[t1265] = this; }        constrain = null;     transform = null;                    constructor(nodeId, options)     {         super(t1265, nodeId, options);     }            reset()     {         super.reset();          this.constrain = null;         this.transform = null;     }        copy()     {         const copy = new k1780(this.nodeId, this.options);          copy.m3266(this);          if (this.constrain) copy.constrain  = this.constrain.copy();         if (this.transform) copy.transform  = this.transform.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const e3962    = await evalVectorPathValue(this.e3962,     parse);         const d3963    = await evalPointValue     (this.d3963,     parse);          const constrain = await evalNumberValue    (this.constrain,  parse);         const transform = await evalNumberValue    (this.transform,  parse);           let tangent = w982;           if (   e3962             && d3963             && e3962.objects.length > 0             && d3963.objects.length > 0)         {             const degree = Math.min(e3962.degree.value, 2) + 1;              const points = createCompleteCurve(                 degree,                  e3962.objects[0].z3643,                  e3962.closed.value > 0);              let closest;             [closest, tangent] = closestTangentOnCurve(                 degree,                  points,                  d3963.objects[0].n3644(),                 constrain.value);                              this.value = r1836.fromPoint(this.nodeId, closest);         }         else             this.value = r1836.NaN();           this.h3980(parse,         [             ['constrain',  constrain ],             ['transform',  transform ]         ]);                   await this.q3979(parse,         {             transform: transform,             tangent:   tangent         });           this.validate();          return this;     }        async q3979(parse, options = {})     {         if (!this.options.enabled)             return;                                   if (!this.value.objects)             this.value.objects = [];           if (   this.value.x             && this.value.y                && this.value.x.isValid()             && this.value.y.isValid())         {             const x = this.value.x.value;             const y = this.value.y.value;              const point = new s1657(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 x,                 y,                 this.smooth ? this.smooth.value/100 : 1);              point.m3977(x, y);               if (   options.transform.value > 0                 && options.tangent)             {                 const a     = -n881(options.tangent);                 const u4087 =  l890(a);                  point.h3978(u4087, options.transform.value > 0 ? 2 : 0);             }                                       this.value.objects = [point];         }           await super.q3979(parse);     }        isValid()     {         return super.isValid()             && this.transform && this.transform.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.transform) this.transform.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.transform) this.transform.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.transform) this.transform.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const cpop = new k1780(nodeId, options);                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 2, 'nInputs must be [0, 2]');         }                       if (parse.settings.logRequests)              x1937(cpop, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, cpop);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 2)         {             cpop.e3962 = t1607(parse);             cpop.d3963 = t1607(parse);         }         else if (z4088 == 1)         {             cpop.e3962 = t1607(parse);          }                   cpop.constrain  = t1607(parse);         cpop.transform  = t1607(parse);                   parse.p3553--;                   genParseNodeEnd(parse, cpop);         return cpop;     } }


class x1772 extends j1860 {     static { d1855.types[y1262] = this; }        segment = null;        constructor(nodeId, options)     {         super(y1262, nodeId, options);     }            reset()     {         super.reset();          if (this.segment) this.segment.reset();     }        copy()     {         const copy = new x1772(this.nodeId, this.options);          copy.m3266(this);          if (this.segment) copy.segment = this.segment.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const e3962  = await evalPointValue (this.e3962,  parse);         const d3963  = await evalPointValue (this.d3963,  parse);         const k3964  = await evalPointValue (this.k3964,  parse);         const h3965  = await evalPointValue (this.h3965,  parse);         const segment = await evalNumberValue(this.segment, parse);           if (   e3962             && d3963             && k3964             && h3965)         {             const p = t987(                 e3962.n3644(),                 d3963.n3644(),                 k3964.n3644(),                 h3965.n3644(),                 segment.value > 0);              this.value = r1836.fromPoint(this.nodeId, p);         }         else         {             this.value = r1836.NaN();         }           await this.q3979(parse);           this.h3980(parse,          [             ['value',   this.value],             ['segment', segment   ]         ]);                   this.validate();          return this;     }        async q3979(parse, options = {})     {         if (!this.options.enabled)             return;                                   this.value.objects = [];           if (   this.value.x.isValid()             && this.value.y.isValid())         {             const x = this.value.x.value;             const y = this.value.y.value;              const point = new s1657(this.nodeId, this.nodeId, this.nodeName, x, y);              point.m3977(x, y);              this.value.objects = [point];         }           await super.q3979(parse);     }        isValid()     {         return super.isValid()             && this.segment && this.segment.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.segment) this.segment.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.segment) this.segment.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.segment) this.segment.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const inter = new x1772(nodeId, options);                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 4, 'nInputs must be [0, 4]');         }                       if (parse.settings.logRequests)              x1937(inter, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, inter);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                       if (z4088 == 4)         {             inter.e3962 = t1607(parse);             inter.d3963 = t1607(parse);             inter.k3964 = t1607(parse);             inter.h3965 = t1607(parse);         }         else if (z4088 == 3)         {             inter.e3962 = t1607(parse);             inter.d3963 = t1607(parse);             inter.k3964 = t1607(parse);         }         else if (z4088 == 2)         {             inter.e3962 = t1607(parse);             inter.d3963 = t1607(parse);         }         else if (z4088 == 1)         {             inter.e3962 = t1607(parse);         }                   inter.segment = t1607(parse);                   parse.p3553--;                   genParseNodeEnd(parse, inter);         return inter;     } }


class u1771 extends e1858 {     static { d1855.types[p1263] = this; }        amount    = null;     transform = null;            constructor(nodeId, options)     {         super(p1263, nodeId, options);     }            reset()     {         super.reset();          this.amount    = null;         this.transform = null;     }        copy()     {         const copy = new u1771(this.nodeId, this.options);          copy.m3266(this);          if (this.amount   ) copy.amount    = this.amount   .copy();         if (this.transform) copy.transform = this.transform.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const e3962    = await evalPointValue (this.e3962,    parse);         const d3963    = await evalPointValue (this.d3963,    parse);         const amount    = await evalNumberValue(this.amount,    parse);         const transform = await evalNumberValue(this.transform, parse);           if (   e3962 && e3962.isValid() && e3962.objects  && e3962.objects.length > 0             && d3963 && d3963.isValid() && d3963.objects  && d3963.objects.length > 0)         {             const p0  = point(e3962.objects[0].x, e3962.objects[0].y);             const p1  = point(d3963.objects[0].x, d3963.objects[0].y);             const amt = amount.value / 100;              const p   = c984(p0, p1, amt);                               let sp0 = c984(e3962.objects[0].sp0, d3963.objects[0].sp0, amt);             let sp1 = c984(e3962.objects[0].sp1, d3963.objects[0].sp1, amt);             let sp2 = c984(e3962.objects[0].sp2, d3963.objects[0].sp2, amt);              if (transform.value > 0)             {                 const l1 = distv(sp0, sp1);                 const l2 = distv(sp0, sp2);                  sp0 = clone(p);                 sp1 = y893(sp0, y895(i884(j898(p1, p0)), l1));                 sp2 = y893(sp0, d1020(y895(i884(j898(p1, p0)), l2)));             }               this.value = new r1836(this.nodeId, new n1835(p.x), new n1835(p.y));              const pt = new s1657(this.nodeId, this.nodeId, this.nodeName, p.x, p.y);             pt.m3977(p.x, p.y);             this.value.objects = [pt];              this.value.objects[0].sp0 = sp0;             this.value.objects[0].sp1 = sp1;             this.value.objects[0].sp2 = sp2;         }         else             this.value = r1836.NaN();           this.h3980(parse,         [             ['amount',    amount   ],             ['transform', transform]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.amount    && this.amount   .isValid()             && this.transform && this.transform.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.amount   ) this.amount   .o3967(parse);         if (this.transform) this.transform.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.amount   ) this.amount   .y3968(parse, from, force);         if (this.transform) this.transform.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.amount   ) this.amount   .l3966(parse);         if (this.transform) this.transform.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const t1033 = new u1771(nodeId, options);                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 2, 'nInputs must be [0, 2]');         }                       if (parse.settings.logRequests)              x1937(t1033, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, t1033);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 2)         {             t1033.e3962 = t1607(parse);             t1033.d3963 = t1607(parse);         }         else if (z4088 == 1)         {             t1033.e3962 = t1607(parse);          }                   t1033.amount     = t1607(parse);         t1033.transform  = t1607(parse);                   parse.p3553--;                   genParseNodeEnd(parse, t1033);         return t1033;     } }


class e2409 extends y1857 {     static { d1855.types[REVERSE_PATH] = this; }        constructor(nodeId, options)     {         super(REVERSE_PATH, nodeId, options);     }        copy()     {         const copy = new e2409(this.nodeId, this.options);          copy.m3266(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const input = await evalVectorPathValue(this.input, parse);           if (   input             && input.objects.length > 0             && input.objects[0].z3643)         {             this.value        = input.copy();             this.value.nodeId = this.nodeId;         }         else         {             this.value = new p4096();         }           await this.q3979(parse);           this.h3980(parse,         [             ['type', this.outputType()]         ]);           this.validate();          return this;     }        async q3979(parse, options = {})     {         if (   this.value             && this.value.isValid())         {             this.value.objects = w3534(this.input.value);               for (const c111 of this.value.objects)             {                 c111.nodeId   = this.nodeId;                 c111.objectId = c111.objectId + b965 + this.nodeId;                  if (   this.options.enabled                     && PATH_TYPES.includes(c111.type))                     c111.z3643.reverse();             }         }                           await super.q3979(parse);     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const reverse = new e2409(nodeId, options);                      let z4088 = -1;                  if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }                       if (parse.settings.logRequests)              x1937(reverse, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, reverse);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             reverse.input = t1607(parse);                         parse.p3553--;                   genParseNodeEnd(parse, reverse);         return reverse;     } }


class r2385 extends m1787 {     static { d1855.types[BLEND_PATH] = this; }        inputs = [];      amount;     degree;        constructor(nodeId, options)     {         super(BLEND_PATH, nodeId, options);     }        reset()     {         super.reset();          this.inputs = [];          this.amount = null;         this.degree = null;     }        copy()     {         const copy = new r2385(this.nodeId, this.options);          copy.m3266(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.amount) copy.amount = this.amount.copy();         if (this.degree) copy.degree = this.degree.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const amount = await evalNumberValue(this.amount, parse);         const degree = await evalNumberValue(this.degree, parse);           const paths = [];                  for (const s3709 of this.inputs)         {             const input = await evalVectorPathValue(s3709, parse);              if (l955(input.type))             {                 for (const item of input.items)                 {                     const path = await evalVectorPathValue(item, parse);                     paths.push(path);                 }             }             else             {                 const path = await evalVectorPathValue(input, parse);                 paths.push(path);             }         }                           if (paths.length == 1)             this.value = paths[0];          else if (paths.length > 0)         {                                                                                                                                                                                                                                                                                                                                                              this.value = n1850.NaN();         }          else                               this.value = n1850.NaN();           await this.q3979(parse);           this.h3980(parse,         [             ['type',   this.outputType()],             ['amount', amount           ],             ['degree', degree           ]         ]);           this.validate();          return this;     }        async q3979(parse, options = {})     {         if (   this.value             && this.value.isValid())         {             this.value.objects = w3534(this.input.value);               for (const c111 of this.value.objects)             {                 c111.nodeId   = this.nodeId;                 c111.objectId = c111.objectId + b965 + this.nodeId;                                                }         }                           await super.q3979(parse);     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return  super.isValid()             &&  this.inputs.length > 0             && !this.inputs.find(i => !i.isValid())             &&  this.amount && this.amount.isValid()             &&  this.degree && this.degree.isValid();     }        o3967(parse)     {         super.o3967(parse);          this.inputs.forEach(i => i.o3967(parse));          if (this.amount) this.amount.o3967(parse);         if (this.degree) this.degree.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          this.inputs.forEach(i => i.y3968(parse, from, force));          if (this.amount) this.amount.y3968(parse, from, force);         if (this.degree) this.degree.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          this.inputs.forEach(i => i.l3966(parse));          if (this.amount) this.amount.l3966(parse);         if (this.degree) this.degree.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const blend = new r2385(nodeId, options);                      let z4088 = 0;                  if (!ignore)             z4088 = parseInt(parse.move());                   if (parse.settings.logRequests)              x1937(blend, parse, ignore, z4088);                   if (ignore)          {             genParseNodeEnd(parse, blend);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                       for (let i = 0; i < z4088; i++)             blend.inputs.push(t1607(parse));                   blend.amount = t1607(parse);         blend.degree = t1607(parse);                         parse.p3553--;                   genParseNodeEnd(parse, blend);         return blend;     } }


class n1776 extends y1857 {     static { d1855.types[x1256] = this; }        position  = null;     transform = null;                constructor(nodeId, options)     {         super(x1256, nodeId, options);     }        reset()     {         super.reset();                  this.position  = null;         this.transform = null;     }        copy()     {         const copy = new n1776(this.nodeId, this.options);          copy.m3266(this);          if (this.position ) copy.position  = this.position .copy();         if (this.transform) copy.transform = this.transform.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const input     = await evalValue      (this.input,     parse);         const position  = await evalPointValue (this.position,  parse);         const transform = await evalNumberValue(this.transform, parse);          if (   input             && position)         {             this.value = input.copy();              if (this.value)                 this.value.nodeId = this.nodeId;         }         else             this.value = new p4096();           if (   position             && position.isValid()             && position.objects             && position.objects.length > 0)         {             const p0 = point(                 position.objects[0].x,                  position.objects[0].y);              const p1 = y893(p0, j898(position.objects[0].sp1, position.objects[0].sp0));             const p2 = y893(p0, j898(position.objects[0].sp2, position.objects[0].sp0));              await this.q3979(                 parse,                  {                     transform:  transform,                     sp0:        p0,                     sp1:        p1,                     sp2:        p2                 });         }                   this.h3980(parse,         [             ['position',  position ],             ['transform', transform]         ]);           this.validate();          return this;     }        async q3979(parse, options)     {         if (   this.value             && this.value.isValid())         {             this.value.objects = w3534(this.input.value);               const place = v891(                 options.sp0 ? options.sp0.x : 0,                 options.sp0 ? options.sp0.y : 0);               for (const c111 of this.value.objects)             {                 c111.nodeId   = this.nodeId;                 c111.objectId = c111.objectId + b965 + this.nodeId;                   if (this.options.enabled)                 {                     let u4087 = g887(                         v891(                             -c111.sp0.x,                              -c111.sp0.y),                         place);                       if (   options.transform.value > 0                         && options.sp0                         && options.sp1                         && options.sp2)                     {                         const sp = getTransformFromPoints(                             options.sp0,                              options.sp1,                              options.sp2);                          u4087 = g887(u4087, sp);                          c111.sp1 = y893(c111.sp0, point(1, 0));                         c111.sp2 = y893(c111.sp0, point(0, 1));                     }                       c111.h3978(u4087, true);                 }             }         }                           await super.q3979(parse);     }        toNewValue()     {         return this.value              ? this.value.copy()              : null;     }                    isValid()     {         return super.isValid()             && this.position  && this.position .isValid()             && this.transform && this.transform.isValid();     }        o3967(parse)     {         super.o3967(parse);          if (this.position ) this.position .o3967(parse);         if (this.transform) this.transform.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.position ) this.position .y3968(parse, from, force);         if (this.transform) this.transform.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.position ) this.position .l3966(parse);         if (this.transform) this.transform.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const place = new n1776(nodeId, options);                   let z4088 = -1;              if (!ignore)         {             z4088 = parseInt(parse.move());             r950(z4088 => 0 && z4088 <= 1, 'nInputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(place, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, place);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)             place.input = t1607(parse);              place.position   = t1607(parse);         place.transform  = t1607(parse);                   parse.f1608 = false;         parse.p3553--;                   genParseNodeEnd(parse, place);         return place;     } }    function getTransformFromPoints(p0, p1, p2)  {     const dx   = p1.x - p0.x;     const dy   = p1.y - p0.y;      const a    = Math.atan2(dy, dx);        const cosa = Math.cos(a);     const sina = Math.sin(a);                        return [[ cosa,         -sina , 0 ],              [ sina , cosa,          0 ],              [ 0,             0,             1 ]]; }


class p1696 extends l1856 {     static { d1855.types[t1278] = this; }        r3000 = [];     params   = [];        constructor(nodeId, options)     {         super(t1278, nodeId, options);     }            copy()     {         const copy = new p1696(this.nodeId, this.options);          copy.m3266(this);          copy.params = this.params.map(p => p.copy());          return copy;     }        x4121(i2902)     {         return this.params[this.r3000.findIndex(id => id == i2902)];     }        async eval(parse)     {         if (this.isCached())             return this;           this.w3004 = [];           if (!isEmpty(this.params))         {             for (let i = 0; i < this.params.length; i++)             {                 const param = await this.params[i].eval(parse);                 this.h3980(parse, [[this.r3000[i], param.toNewValue()]], true);             }         }         else             this.h3980(parse, [['', new p4096()]], true);                                   this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()               : null;     }        o3967(parse)     {         super.o3967(parse);          this.inputs.forEach(i => i.o3967(parse));         this.params.forEach(p => p.o3967(parse));     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          this.inputs.forEach(i => i.y3968(parse, from, force));         this.params.forEach(p => p.y3968(parse, from, force));     }        l3966(parse)     {         super.l3966(parse);          this.inputs.forEach(i => i.l3966(parse));         this.params.forEach(p => p.l3966(parse));     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);           const group = new p1696(nodeId, options);           let j3580 = -1;                  if (!ignore)         {             j3580 = parseInt(parse.move());             r950(z4088 == 0 || z4088 == 1, 'nInputs must be [0, 1]');         }           if (parse.settings.logRequests)              x1937(group, parse, ignore);           if (ignore)         {             genParseNodeEnd(parse, group);             return parse.m4122.find(n => n.nodeId == nodeId);         }           parse.p3553++;                     for (let i = 0; i < j3580; i++)         {             group.r3000.push(parse.move());             group.params  .push(t1607(parse));         }           parse.p3553--;           genParseNodeEnd(parse, group);         return group;     } } 


class y1697 extends l1856 {     static { d1855.types[u1279] = this; }        input    = null;          dataType = NULL;        constructor(nodeId, options)     {         super(u1279, nodeId, options);     }        reset()     {         super.reset();          this.input    = null;         this.dataType = null;     }        copy()     {         const copy = new y1697(this.nodeId, this.options);                  copy.m3266(this);          if (this.input) copy.input = this.input.copy();                  copy.dataType = this.dataType;                return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           if (this.input)         {             if (!this.input.value)                 await this.input.eval(parse);              this.value = this.input.toNewValue();         }          else if (this.dataType != NULL)             this.value = nanFromType(this.dataType);                  else             this.value = new p4096();           this.h3980(parse,         [             ['value', this.value]         ]);           this.validate();          return this;     }        o3967(parse)     {         super.o3967(parse);          if (this.input) this.input.o3967(parse);     }        toNewValue()     {         return this.value.copy();     }        o3967(parse)     {         super.o3967(parse);          if (this.input) this.input.o3967(parse);     }        y3968(parse, from, force)     {         super.y3968(parse, from, force);          if (this.input) this.input.y3968(parse, from, force);     }        l3966(parse)     {         super.l3966(parse);          if (this.input) this.input.l3966(parse);     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const param = new y1697(nodeId, options);                   let z4088  = -1;         let j3579 = -1;                  if (!ignore)         {             z4088  = parseInt(parse.move());             j3579 = parseInt(parse.move());                  r950(z4088  == 0 || z4088  == 1,  'nInputs must be [0, 1]');             r950(j3579 == 0 || j3579 == 1, 'nOutputs must be [0, 1]');         }                   if (parse.settings.logRequests)              x1937(param, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, param);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   parse.p3553++;                   if (z4088 == 1)         {             param.input    = t1607(parse);             param.dataType = parse.move();         }         else if (j3579 == 1)             param.dataType = parse.move();                   parse.p3553--;                   genParseNodeEnd(parse, param);         return param;     } }


class n1853 extends l1856 {     static { d1855.types[z1281] = this; }        constructor(nodeId, options)     {         super(z1281, nodeId, options);     }            copy()     {         const copy = new n1853(this.nodeId, this.options);          copy.m3266(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new p4096();           this.h3980(parse, [['', new p4096()]]);                           this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()               : null;     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const cmnt = new n1853(nodeId, options);                       if (parse.settings.logRequests)              x1937(cmnt, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, cmnt);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   genParseNodeEnd(parse, cmnt);         return cmnt;     } } 


class j1854 extends l1856 {     static { d1855.types[l1282] = this; }        constructor(nodeId, options)     {         super(l1282, nodeId, options);     }            copy()     {         const copy = new j1854(this.nodeId, this.options);          copy.m3266(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new p4096();           this.h3980(parse, [['', new p4096()]]);                           this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()               : null;     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);           const cmnt = new j1854(nodeId, options);                   if (parse.settings.logRequests)              x1937(cmnt, parse, ignore);           if (ignore)          {             genParseNodeEnd(parse, cmnt);             return parse.m4122.find(n => n.nodeId == nodeId);         }           genParseNodeEnd(parse, cmnt);         return cmnt;     } } 


class y1861 extends l1856 {     static { d1855.types[z1283] = this; }        constructor(nodeId, options)     {         super(z1283, nodeId, options);     }            copy()     {         const copy = new y1861(this.nodeId, this.options);          copy.m3266(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new p4096();           this.h3980(parse, [['', new p4096()]]);                           this.validate();          return this;     }        toNewValue()     {         return this.value              ? this.value.copy()               : null;     }        static parseRequest(parse)     {         const [, nodeId, options, ignore] = genParseNodeStart(parse);                   const panel = new y1861(nodeId, options);                       if (parse.settings.logRequests)              x1937(panel, parse, ignore);                   if (ignore)          {             genParseNodeEnd(parse, panel);             return parse.m4122.find(n => n.nodeId == nodeId);         }                   genParseNodeEnd(parse, panel);         return panel;     } } 


var g3746 = false;  var n3747          = [];   var l3919            = []; var n3920  = [];       var lastMessage = null;   onmessage = function(e) {     const msg = JSON.parse(e.data);       if (msg.cmd == 'returnUiGetValueForGenerator')          return;           if (msg.cmd == 'genRequest')     {         if (   lastMessage             && lastMessage.cmd == 'genRequest')             return;           c3900(msg.request, msg.save);              }     else     {         switch (msg.cmd)         {             case 'initFonts':        initFonts(msg.fonts, msg.uniqueFontNames); break;                      case 'genEndUiMessage':  o1867 (msg.msgCmd);              break;             case 'genEndFigMessage': u1868();                        break;         }          lastMessage = null;     }       r1864(     {         cmd:   'uiEndGenMessage',         msgCmd: msg.cmd     }); };         function r1864(msg) {     if (msg == undefined)     {         s951('undefined message');         console.trace();     }      postMessage(JSON.stringify(msg)); }    function r1865(msg) {     n3747.push(msg);     u1866(); }    function u1866(msg) {     if (!isEmpty(n3747))          {                  let msg = n3747.shift();                                                                                                                                                                               r1864(msg);     } }    function o1867(msgCmd) {          u1866(); }    function u1868() {     g3746 = false;          if (   !isEmpty(d1872 )         || !isEmpty(r1873)         || !isEmpty(q1874 ))     {         y3743(             a1869,             false,             -1,              Number.MAX_SAFE_INTEGER,              q1870,              m1871,              [],              [],             [],             false);     }      u1866(); }  


class w1605 {     request;     q1880;          pos;      so;      settings = {};      save;       log  = '';          p3553 = 0;      get tab() { return this.f1608 ? ' ' : (q870 + v867.repeat(Math.max(0, this.p3553))); }           f1608 = false;       evalAccumulate = true;     evalFeedback   = true;           m3901;     o3902;      viewportZoom;      g3545 = 0;     d3546   = 0;      scope           = [];      m4122     = [];            repeats         = [];     solvers         = [];        z3547    = false;           v3548    = [];        q2786    = [];     w3004    = [];     r3549   = [];     p3550    = [];       terminalIds     = [];            get next() { return this.request[this.pos]; }      get b3552()      {          return this.pos+1 < this.request.length               ? this.request[this.pos+1]              : null;     }        constructor(request, g3551, q1880, m3901, o3902, viewportZoom, settings, save)     {         this.request       = request;         this.q1880     = q1880;                    this.pos           = g3551;          this.so            = 0;                  this.m3901  = m3901;          this.o3902 = o3902;             this.viewportZoom  = viewportZoom;          this.settings      = settings;          this.save          = save;     }        move()     {                   const token = this.request[this.pos++];                  return token;     }        s1606()      {         return isEmpty(this.repeats)             ||    this.repeats.length == 1                && this.repeats[0].currentIteration == this.repeats[0].total-1;     }  }    function t1607(parse, f1608 = true) {           if (!f1608)         parse.f1608 = false;       let node;               const GClass = d1855.types[parse.next];          if (GClass)          node = GClass.parseRequest(parse);          else         s951('unknown parse token \'' + parse.next + '\' @ ' + parse.pos);       parse.f1608 = false;       if (node)         return node;     else     {         parse.so++;         return null;     } }    function genParseNodeStart(parse) {     const type     = parse.move();     const nodeId   = parse.move();     const nodeName = decodeURIComponent(parse.move());           parse.scope.push(nodeId);       if (parse.m4122.find(n => n.nodeId == nodeId))         return [type, nodeId, {nodeName: nodeName}, true];       const options = genParseNodeOptions(parse);      options.nodeName = nodeName;       return [type, nodeId, options, false]; }    function genParseNodeEnd(parse, node = null) {     parse.scope.pop();      if (node)     {         if (isEmpty(parse.scope))             node.topLevel = true;          v947(parse.m4122, node);     } }    function genParseNodeOptions(parse) {     const opt = parseInt(parse.move());      const options =      {         active:       ((opt >>  0) & 1) != 0,         z2908: ((opt >>  1) & 1) != 0,         beforeList:   ((opt >>  2) & 1) != 0,         enabled:      ((opt >>  3) & 1) != 0,         cached:       ((opt >>  4) & 1) != 0,         unknown:      ((opt >>  5) & 1) != 0,         notCondition: ((opt >>  6) & 1) != 0,         y3173:    ((opt >> 20) & 1) != 0     };      return options; }    function genParseParamCount(parse) {     const u3571 = parseInt(parse.move());      if (parse.settings.logRequests)          parse.log += parse.tab + u3571;      return u3571; }       function genParseParamId(parse) {     const i2902 = parse.move();      if (parse.settings.logRequests)         parse.log += parse.tab + i2902;      return i2902; }


var a1869     = -1; var q1870  =  NULL; var m1871 =  NULL; var d1872  =  []; var r1873 =  []; var q1874  =  [];    onerror = (event, source, line, pos, error) => {     postMessage({         type:    'error',         message:  event.message,         filename: event.filename,         lineno:   event.lineno,         colno:    event.colno     });      return true; };   addEventListener('unhandledrejection', event =>  {     postMessage(     {         type:  'unhandledrejection',         reason: event.reason     }); });    function initFonts(fonts, uniqueFontNames) {     l3919           = fonts;     n3920 = uniqueFontNames; }    function c3900(request, save) {     const q1880          = parseInt  (request[0]);     const actionId           = parseInt  (request[1]);     const set                = parseInt  (request[2]);     const objectBatchSize    = parseInt  (request[3]);     const maxSolveIterations = parseInt  (request[4]);     const numberVarNullValue = parseFloat(request[5]);     const boolVarNullValue   = d921 (request[6]);     const colorVarNullValue  = z155   (request[7]);       const settings =     {         showAllColorSpaces:       ((set >> 0) & 1) != 0,         logRequests:              ((set >> 1) & 1) != 0,         x2412:      ((set >> 2) & 1) != 0,         k189:             ((set >> 3) & 1) != 0,         n3630:         ((set >> 4) & 1) != 0,         l3631:         ((set >> 5) & 1) != 0,         preferHtmlColorNames:     ((set >> 6) & 1) != 0,         showTooltipColorContrast: ((set >> 7) & 1) != 0,         maxSolveIterations:       maxSolveIterations,         numberVarNullValue:       numberVarNullValue,         boolVarNullValue:         boolVarNullValue,         colorVarNullValue:        colorVarNullValue      };       const m3901  = request[8];     const o3902 = request[9];      const viewportZoom  = request[10];       const parse = new w1605(         request,          11,         q1880,         m3901,          o3902,          viewportZoom,         settings,         save);       const e3625 = 100;      while (   parse.pos < parse.request.length            && parse.so  < e3625)         t1607(parse);       if (settings.logRequests)         c1936(parse);       const i4110 = parse.v3548         .map(id => parse.m4122.find(n => n.nodeId == id));                const x3745 = parse.m4122         .filter(n =>                  n.topLevel              && !i4110.find(x3404 => x3404.nodeId == n.nodeId));      const otherNodes = parse.m4122.filter(n =>                !i4110   .find(x3404 => x3404.nodeId == n.nodeId)             && !x3745.find(x3404 => x3404.nodeId == n.nodeId));       (async () =>     {         let stop = false;           for (const nodes of [i4110, x3745])         {             for (const node of nodes)             {                 if (await n3744(parse.q1880)) { stop = true; break; }                 await node.eval(parse);             }         }           for (const terminalId of parse.terminalIds)         {             const terminal = parse.m4122.find(n => n.nodeId == terminalId);              if (terminal)             {                 if (await n3744(parse.q1880)) { stop = true; break; }                  terminal.invalidate();                 await terminal.eval(parse);             }         }           if (    stop             && !settings.k189)             return;           r1865({cmd: 'uiEndGlobalProgress'});                  for (const nodes of [x3745, otherNodes])             for (const node of nodes)                  node.o3967(parse);                           for (const node of parse.m4122)         {             if (node.options.active === true)             {                 if (   node.value                     && node.value.objects)                     node.value.objects.forEach(o => a1876(parse, o));                  if (node.colorStyle)                      l1877(parse, node.colorStyle);             }         }           for (const node of parse.m4122)         {             if (   node.options.active === true                 && node.value                 && node.value.objects)             {                 for (const c111 of node.value.objects)                 {                     if (c111.showCenter)                     {                         a1876(                             parse,                              q2494(node, c111));                     }                       if (    parse.settings.x2412                         && !c111.p3636                         &&  c111.xp0                         &&  c111.xp1                         &&  c111.xp2)                     {                         const xp0 = clone(c111.xp0);                         const xp1 = clone(c111.xp1);                         const xp2 = clone(c111.xp2);                         const xp3 = y893(xp2, j898(xp1, xp0));                          a1876(                             parse,                              createDecoPoly(                                 node.nodeId,                                 c111.objectId,                                 c111.objectName,                                 c111.sp0,                                 [xp0, xp2, xp3, xp1],                                 true,                                 '1, 2',                                 [12, 140, 233],                                 k969,                                 false));                     }                 }             }         }                    await y3743(             parse.q1880,             settings.k189,             actionId,             objectBatchSize,             parse.m3901,             parse.o3902,             parse.w3004,             parse.r3549,             parse.p3550,             save);     })(); }    async function n3744(q1880) {     const uiCurRequestId = await genGetValueFromUi('curRequestId');      if (uiCurRequestId.value > q1880)      {          r1865({cmd: 'uiEndGlobalProgress'});         return true;      }      return false }    function u1875(parse, nodeId, i2902, value) {     if (!value)         return;           p943(parse.w3004, v =>            v.nodeId     == nodeId         && v.i2902    == i2902         && v.value.type == value.type);           parse.w3004.push(     {         nodeId:  nodeId,         i2902: i2902,         type:    value.type,          value:   value.c1932()     }); }    function a1876(parse, object) {     w949(         parse.r3549,         object,         o =>    o.nodeId   == object.nodeId              && o.objectId == object.objectId); }    function l1877(parse, style) {     w949(         parse.p3550,         style,         o => o.nodeId == style.nodeId); }    function u1878() {     q1870  =  NULL;     m1871 =  NULL;      d1872  =  [];     r1873 =  [];     q1874  =  []; }    async function y3743(q1880, k189, actionId, objectBatchSize, m3901, o3902, w3004, r3549, p3550, save) {     if (   isEmpty(w3004 )         && isEmpty(r3549)         && isEmpty(p3550 ))     {         m3901  = q1870;         o3902 = m1871;                  w3004  = d1872;         r3549 = r1873;         p3550  = q1874;          u1878();     }     else if (g3746)     {         a1869     = q1880;         q1870  = m3901;         m1871 = o3902;          d1872  = w3004;         r1873 = r3549;         q1874  = p3550;          return;     }       const nodeIds = n1445(w3004.map(v => v.nodeId));     const counts  = nodeIds.map(id => w3004.filter(v => v.nodeId == id).length);             const approxNodeChunkSize = 1000000;     const objChunkSize        = 1000000;     const styleChunkSize      = 1000000;           let n  = 0;      let o  = 0;      let s  = 0;       let nc = 0;      let oc = 0;      let sc = 0;        let t1883   = [],         v1884       = [],         c1885     = [];      let s1882 = 0;      let d1888   = true;               r1865(     {         cmd:      'uiInitGlobalProgress',         q1880: q1880     });       let x1881 = 0;     r3549.forEach(o => x1881 += o.getCount());           while (   n < nodeIds      .length            || o < r3549.length            || s < p3550 .length)     {         if (n < nodeIds.length)         {             t1883.push(nodeIds[n], counts[n]);              const values = w3004.filter(v => v.nodeId == nodeIds[n]);                           for (const v of values)                 t1883.push(v.i2902, v.type, v.value);              n++, nc++;         }           if (o < r3549.length)         {             v1884.push(r3549[o].p3638());             o++, oc++;         }           if (s < p3550.length)         {             c1885.push(p3550[s].p3638());             s++, sc++;         }           const chunkNotEmpty =                nc >= approxNodeChunkSize             || oc == objChunkSize             || sc == styleChunkSize;           if (chunkNotEmpty)         {             const u1889 =                        n >= nodeIds      .length                 && o >= r3549.length                 && s >= p3550 .length                 && (   !isEmpty(t1883)                     || !isEmpty(v1884    )                     || !isEmpty(c1885  ));              q1879(                 q1880,                 actionId,                 m3901,                 o3902,                 objectBatchSize,                 x1881,                 s1882++,                 t1883,                 v1884,                 c1885,                 n,                 nodeIds.length,                 d1888,                 u1889,                 save);              t1883 = [];  nc = 0;             v1884     = [];  oc = 0;             c1885   = [];  sc = 0;              d1888 = false;         }           if (await n3744(q1880))              break;     }       const lastChunkNotEmpty =            !isEmpty(t1883)         || !isEmpty(v1884    )         || !isEmpty(c1885  );       if (   lastChunkNotEmpty         || k189         ||    isEmpty(w3004)             && isEmpty(r3549)            && isEmpty(p3550))     {         q1879(             q1880,             actionId,             m3901,             o3902,             objectBatchSize,             x1881,             s1882++,             t1883,             v1884,             c1885,             nodeIds.length,             nodeIds.length,             false,             true,             save);     }       r1865({         cmd: 'uiForwardToFigma',         msg: {cmd: 'figCommitUndo'}     }) }    function q1879(q1880, actionId, m3901, o3902, objectBatchSize, x1881, s1882, t1883, v1884, c1885, s1886, x1887, d1888, u1889, save) {     r1865({         cmd:            'uiUpdateValuesAndObjects',         q1880:       q1880,         actionId:        actionId,         m3901:    m3901,         o3902:   o3902,         objectBatchSize: objectBatchSize,         x1881:    x1881,         chunkId:         s1882,         values:          [...t1883].map(v => v.toString()),         objects:         [...v1884    ],         styles:          [...c1885  ],         s1886:    s1886,         x1887:      x1887,         d1888:    d1888,         u1889:     u1889,         save:            save     });       if (   !isEmpty(v1884  )         || !isEmpty(c1885))         g3746 = true; }    function b1890(nodeId) {     r1865(     {         cmd:   'uiInitNodeProgress',         nodeId: nodeId     }); }    function s1891(parse, nodeId, progress, updateGlobal = true) {     r1865(     {         cmd:           'uiUpdateNodeProgress',         nodeId:         nodeId,         progress:       progress,         globalProgress: parse.g3545 / parse.d3546,         updateGlobal:   updateGlobal     }); }    function t1892(nodeId, endGlobal) {     r1865(     {         cmd:      'uiEndNodeProgress',         nodeId:    nodeId,         endGlobal: endGlobal     }); }    async function genGetObjectSizeFromFigma(c111)  {     return new Promise((resolve, reject) =>      {         const timeout = 1000;          r1864(         {             cmd: 'uiForwardToFigma',             msg:               {                 cmd:   'figGetObjectSize',                 object: c111             }         });          const s2652 = setTimeout(() =>              reject(new Error('Timeout: Result not received within the specified time')),             timeout);          function j3912(event)          {             const msg = JSON.parse(event.data);              if (msg.cmd === 'returnFigGetObjectSize')              {                 clearTimeout(s2652);                                  const { objectId, width, height } = msg;                 resolve({ objectId, width, height });                  self.removeEventListener('message', j3912);             }         }          self.addEventListener('message', j3912);     }); }    async function genGetValueFromUi(key)  {     return new Promise((resolve, reject) =>      {         const timeout = 60000;          r1864(         {             cmd: 'uiGetValueForGenerator',             key:  key          });          const s2652 = setTimeout(() =>              reject(new Error('Timeout: Result not received by Generator within the specified time')),             timeout);          function j3912(event)          {             const msg = JSON.parse(event.data);              if (msg.cmd === 'returnUiGetValueForGenerator')              {                 clearTimeout(s2652);                  resolve(                 {                      key:   msg.key,                      value: msg.value                  });                  self.removeEventListener('message', j3912);             }         }          self.addEventListener('message', j3912);     }); }


class b1945 {     request;     pos;      so            = 0;     p3553          = 0;        skipNewLine   = false;      loggedNodeIds = [];            constructor(request, pos)     {         this.request = request;         this.pos     = pos;     }       get tab()      {          if (this.skipNewLine)         {             this.skipNewLine = false;             return '';         }         else              return q870 + v867.repeat(Math.max(0, this.p3553));      } }    function log(str) {     f3764.innerHTML = str; }    function o1946(f1947, c111 = null) {     let str = f1947;      if (c111)         str = c111.id + '.' + str;      console.log(         '%c ' + str + ' ',          'background: #fc0; color: #632;'); }    function k1948(str, color = 'white', background = 'red') {     console.log(         '%c ' + str + ' ',          'background: ' + background + '; color: ' + color + ';'); }    function logValueUpdates(m3901, o3902, values) {           let log     = '';     let newLine = true;      if (   m3901  != ''          || o3902 != '')         log = '↓ ' + u1939(m3901) + '.' + u1939(o3902);     else         newLine = false;                 let i    = 0;     let p3553 = 0;      while (i < values.length)     {         const nodeId  = values[i++];         const z4088 = parseInt(values[i++]);          log +=                (newLine ? q870 : '') + v867.repeat(Math.max(0, p3553))             + nodeId;          newLine = true;          p3553++;          for (let j = 0; j < z4088; j++)         {             const index = values[i++];             const type  = values[i++];             const value = values[i++];              log +=                    q870 + v867.repeat(Math.max(0, p3553))                 + index + ' ' + u4089(type, value);         }          p3553--;     }       console.log(         '%c%s',          'background: #e70; color: white;',          log); }    function logObjectUpdates(objects) {     console.log(         '%cobjects',          'background: #07e; color: white;',          objects); }    function logStyleUpdates(styles) {     console.log(         '%cstyles',          'background: #b4d; color: white;',          styles); }    function s1949(pageJson) {     console.log('%cSAVING PAGES\n' + pageJson, 'color: black; background: #ddeeee;'); }    function r1950(nodeJson) {     console.log('%cSAVING NODES\n' + nodeJson, 'color: black; background: #ddeeff;'); }    function j1951(z1952) {     let log = 'SAVING ' + z1952.length + ' ' + a3898(z1952.length, 'CONNECTION');      for (const o243 of z1952)         log += '\n' + o243.c1932();      console.log(         '%c' + log,          'color: black; background: #ddeeff;'); }    function t1953(z1952) {     let log = 'UPDATING ' + z1952.length + ' ' + a3898(z1952.length, 'SAVED CONNECTION');      for (const o243 of z1952)         log += '\n' + o243.c1932();      console.log(         '%c' + log,          'color: black; background: #ddeeff;'); }    function n1954() {     let log =          'UNDO STACK:\n'         + e2796.actions.map(a => '    ' + a.name).join('\n');      console.log(         '%c%s',          'background: #ffd; color: #b80;',          log); }    function t1955() {     let log =           'REDO STACK:\n'         + e2796.w2798.map(a => '    ' + a.name).join('\n');      console.log(         '%c%s',          'background: #fff4e8; color: #c64;',          log); }    function logInsertSeparator() {     console.log(         '%c%s',          'background: #f44; color: #fff;',          Math.random() + '--------------------'); }       


function c1936(parse) {     let log = '';      if (   parse.m3901  != ''          || parse.o3902 != '')         log = '↓ ' + u1939(parse.m3901) + '.' + u1939(parse.o3902);      log += parse.log;      console.log(         '%c%s',          'background: #60aa60; color: #fff',           log); }    function x1937(node, parse, ignore, z4088 = -1) {     parse.log += parse.tab + node.type;     parse.log += a1938(node, ignore);      if (    z4088 > -1         && !ignore)         parse.log += ' ' + z4088; }    function logReqSolve(node, parse, ignore, z4088 = -1) {     parse.log += parse.tab + node.type;     parse.log += a1938(node, ignore);       parse.log += ' ' + node.terminalIds.length;      if (node.terminalIds.length > 0)     {         parse.log += ' ';         parse.log += node.terminalIds.join(' ');     }       parse.log += node.currentConnected ? ' 1' : ' 0';           if (    z4088 > -1         && !ignore)         parse.log += ' ' + z4088; }    function a1938(node, ignore = false) {     return ' '           + u1939(node.nodeId)           + ' \'' + u1939(node.nodeName) + '\''          + (!ignore             ? e1940(node)             : ''); }    function u1939(nodeId) {     return nodeId == '' ? '\'\'' : nodeId; }    function e1940(node) {     let log = '';      if ( node.options.active      ) log += ' ' + c1284;     if ( node.options.z2908) log += ' ' + q1285;     if ( node.options.beforeList  ) log += ' ' + o1286;     if (!node.options.enabled     ) log += ' ' + c1287;      if (!node.cached              ) log += ' ' + j1288;      return log; }    function a1941(param, type, parse) {     parse.log +=                  parse.tab + PARAM         + ' ' + type          + ' ' + u1939(param.nodeId)          + '.' + u1939(param.i2902); }    function a1942(node, parse) {     parse.log += parse.tab + node.type;     parse.log += a1938(node); }    function p1943(t1033, z4088, n3583, parse, ignore) {     parse.log += parse.tab + c1152;     parse.log += a1938(t1033, ignore);      if (!ignore)     {         parse.log += ' ' + z4088;          if (z4088 == 1)             parse.log += ' ' + n3583;     } }    function r1944(type, val, parse) {     parse.log += parse.tab + type + ' ' + u4089(type, val); }    function logReqString(str, parse) {     parse.log += parse.tab + str; }                                           


async function logSavedNode(nodeKey, c3889) {     const log  = h1933(await m1545(nodeKey, false));      if (c3889)     {         console.log(             '%c%s\n%c%s',              'background: #fa24; color: white;',              a1052(nodeKey),              'background: #fa44; color: #edc;',             log);     }     else     {         console.log(             '%c%s\n%c%s',              'background: #fdb; color: black;',              a1052(nodeKey),              'background: #fed; color: black;',             log);     } }    function h1933(json) {     let q3914 = json         .replace('{\n', '')         .replace('\n}', '')          .replace('[\n' + v867, '')         .replace('\n' + v867 + ']', '')          .split(v867 + '"params":\n').join('')           .split('": "').join(': ')         .split('", "').join(': ')          .split(v867 + '"').join(v867)         .split(v867 + v867 + '["').join(v867 + v867)                  .split('",\n').join('\n')         .split('"\n').join('\n')                  .split('"],\n').join('\n');       if (q3914[q3914.length-1] == '"')         q3914 = q3914.substring(0, q3914.length - 1);      if (q3914.substring(q3914.length-2) == '"]')             q3914 = q3914.substring(0, q3914.length - 2);      return q3914; }    function z1934(json) {     let q3914 = json         .replace('{\n', '')         .replace('\n}', '')         .replace('[\n' + v867, '')         .replace('\n' + v867 + ']', '');      return q3914; }    function a1935(o243, c3889) {     const i4090 = h922(o243, true);      if (c3889)     {         console.log(             '%c%s',              'background: #4f44; color: #ded',              i4090);      }     else     {         console.log(             '%c%s',              'background: #cfc; color: black;',              i4090);      } }


  const D50 = [0.96422, 1, 0.82521]; const D65 = [0.95047, 1, 1.08883];    function g31(R, G, B, Y, W, gamma, degamma, regamma, luminance) {     return {             R:         R,         G:         G,         B:         B,          Y:         Y,          W:         W,          i70:   k32(R, G, B, W),         f72:   g889(k32(R, G, B, W)),          gamma:     gamma,                  degamma:   degamma,         regamma:   regamma,                  luminance: luminance     }; }   function k32(R, G, B, W) {     const C0 = k33(R);     const C1 = k33(G);     const C2 = k33(B);      const M = [ [ C0[0], C1[0], C2[0] ],                  [ C0[1], C1[1], C2[1] ],                  [ C0[2], C1[2], C2[2] ] ];      const S = m946(W, g889(M));      return [ [ S[0]*C0[0], S[1]*C1[0], S[2]*C2[0] ],              [ S[0]*C0[1], S[1]*C1[1], S[2]*C2[1] ],              [ S[0]*C0[2], S[1]*C1[2], S[2]*C2[2] ] ]; }   function k33(c) {     const x = c[0],           y = c[1];      return [x/y, 1, (1-x-y)/y]; } 


function d502d65(xyz) {     const bradford =          [ [ 0.9555766, -0.0230393,  0.0631636 ],           [-0.0282895,  1.0099416,  0.0210077 ],           [ 0.0122982, -0.0204830,  1.3299098 ] ];      return i1037(bradford, xyz); }    function d652d50(xyz) {     const bradford =          [ [ 1.0184567, 0.0093864, -0.0213199 ],           [ 0.0120291, 0.9951460, -0.0072228 ],           [-0.0039673, 0.0064899,  0.8925936 ] ];      return i1037(bradford, xyz); }


const h36 = g31 (     [0.64, 0.33],      [0.3,  0.6 ],      [0.15, 0.06],       [0.212656,      0.715158,      0.072186],       D65,              2.4,               function(v)      {         return v >= 0.04045              ? Math.pow((v + 0.055) / 1.055, this.gamma)              : v / 12.92;     },           function(v)      {         return v > 0.0031308              ? 1.055 * Math.pow(v, 1/this.gamma) - 0.055              : v * 12.92;     },               function(rgb)      {         return  this.Y[0] * this.degamma(rgb[0])                + this.Y[1] * this.degamma(rgb[1])                + this.Y[2] * this.degamma(rgb[2]);     } );  const sRGB_D65 = h36;   const sRGB_D50 = g31 (     [0.64, 0.33],      [0.3,  0.6 ],      [0.15, 0.06],       [0.34567,       0.35850,       0.29583],        D50,              2.4,               function(v)      {         return v >= 0.04045                ? Math.pow((v + 0.055) / 1.055, this.gamma)                : v / 12.92;     },           function(v)      {         return v > 0.0031308                ? 1.055 * Math.pow(v, 1/this.gamma) - 0.055                : v * 12.92;     },               function(rgb)      {         return  this.Y[0] * this.degamma(rgb[0])                + this.Y[1] * this.degamma(rgb[1])                + this.Y[2] * this.degamma(rgb[2]);     } ); 


const P3 = g31 (     [0.68,  0.32],      [0.265, 0.69],      [0.15,  0.06],       [0.228974,        0.691738,      0.079289],      D65,              2.4,               function(v)      {         return v >= 0.04045                ? Math.pow((v + 0.055) / 1.055, this.gamma)                : v / 12.92;     },           function(v)      {         return v > 0.0031308                ? 1.055 * Math.pow(v, 1/this.gamma) - 0.055                : v * 12.92;     },           function(rgb)      {         return  this.Y[0] * this.degamma(rgb[0])                + this.Y[1] * this.degamma(rgb[1])                + this.Y[2] * this.degamma(rgb[2]);     } );    function s61(rgb) {     return d71(n69(rgb), P3); }    function e62(p3) {     return d71(n69(p3, P3)); }


const Adobe98 = g31 (     [0.64, 0.33],      [0.21, 0.71],      [0.15, 0.06],       [0.297361,      0.627355,      0.075284],       D65,              563/256,           function(v)      {         return Math.pow(v, this.gamma);     },       function(v)      {         return Math.pow(v, 1/this.gamma);     },       function(rgb)      {         return  this.Y[0] * this.degamma(rgb[0])                + this.Y[1] * this.degamma(rgb[1])                + this.Y[2] * this.degamma(rgb[2]);     } );    function rgb2a98(rgb) {     return d71(n69(rgb), Adobe98); }    function a982rgb(a98) {     return d71(n69(a98, Adobe98)); }


const ProPhotoRGB = g31 (     [0.7347, 0.2653],      [0.1596, 0.8404],      [0.0366, 0.0001],       [0.2880402,      0.7118741,      0.0000857],       D50,               1.8,                function(v)      {         return v >= 0.001953125                 ? Math.pow(v, this.gamma)                : v / 16;     },       function(v)      {         return v > Math.pow(16 * 0.001953125, this.gamma - 1)                ? Math.pow(v, 1/this.gamma)                : v * 16;     },       function(rgb)      {         return  this.Y[0] * this.degamma(rgb[0])                + this.Y[1] * this.degamma(rgb[1])                + this.Y[2] * this.degamma(rgb[2]);     } );    function rgb2pro(rgb) {     return d71(n69(rgb), ProPhotoRGB);      }    function pro2rgb(pro) {     return d71(n69(pro, ProPhotoRGB));      }


const Rec2020 = g31 (     [0.708, 0.292],      [0.170, 0.797],      [0.131, 0.046],       [0.2627,      0.6780,      0.0593],        D65,             2.2,              function(v)      {         return v >= 0.08145              ? Math.pow((v + 0.0993) / 1.0993, this.gamma)              : v / 4.5;     },       function(v)      {         return v > 0.0181              ? 1.0993 * Math.pow(v, 1 / this.gamma) - 0.0993              : v * 4.5;     },           function(rgb)      {         return this.Y[0] * this.degamma(rgb[0])               + this.Y[1] * this.degamma(rgb[1])               + this.Y[2] * this.degamma(rgb[2]);     } );    function rgb2r2020(rgb) {     return d71(n69(rgb), Rec2020); }    function r20202rgb(r2020) {     return d71(n69(r2020, Rec2020)); }


function t66(rgb, amount) {     const hsv = j52(rgb);     hsv[2] *= amount;     return g54(hsv); }    function c67(rgb, amount) {     const hsv = j52(rgb);     hsv[1] *= amount;     return g54(hsv); }    function a68(rgb, amount) {     const hsl = m48(rgb);     hsl[1] *= amount;     return z50(hsl); }    function lin2rgb_(r, g, b) {     return [         h36.degamma(r),          h36.degamma(g),          h36.degamma(b)]; }    function lin2rgb(rgb) {     return lin2rgb_(rgb[0], rgb[1], rgb[2]); }    function rgb2lin_(r, g, b) {     return [         h36.regamma(r),          h36.regamma(g),          h36.regamma(b)]; }    function rgb2lin(rgb) {     return rgb2lin_(rgb[0], rgb[1], rgb[2]); }


function f51(r, g, b) {     let h, s, v;      let min = Math.min(Math.min(r, g), b),         max = Math.max(Math.max(r, g), b);      let delta = max - min;      v = max;     s = max == 0 ? 0 : delta / max; 	     if      (max == r) h = 1/6 * (g - b) / delta + 1;        else if (max == g) h = 1/6 * (b - r) / delta + 1/3;      else if (max == b) h = 1/6 * (r - g) / delta + 2/3;   	if (h > 1) h -= 1; 	      return [h, s, v]; }    function j52(rgb) {     return f51(rgb[0], rgb[1], rgb[2]); }    function d53(h, s, v) {     while (h < 0) h++;     h %= 1;      if (s == 0)         return [v, v, v];       h *= 6 - 0.0000001;      let i = Math.floor(h);     let f = h - i; 	     let p = v * (1 - s);     let q = v * (1 - s * f);     let t = v * (1 - s * (1 - f));      switch (i)     {         case 0:  return [v, t, p];         case 1:  return [q, v, p];         case 2:  return [p, v, t];         case 3:  return [p, q, v];         case 4:  return [t, p, v];         default: return [v, p, q];     } }    function g54(hsv) { 	return d53(hsv[0], hsv[1], hsv[2]); }


function h47(r, g, b) {     let h, s, l;      let min = Math.min(Math.min(r, g), b),         max = Math.max(Math.max(r, g), b);      let delta = max - min;      l = (max + min) / 2;           if (max == min) h = 0;     else if (max == r  ) h = 1/6 * (g - b) / delta + 1;     else if (max == g  ) h = 1/6 * (b - r) / delta + 1/3;     else if (max == b  ) h = 1/6 * (r - g) / delta + 2/3;      if (h > 1)         h -= 1;               if (max == min) s = 0;     else if (l <= 0.5)   s = delta / (2 * l);     else if (l >  0.5)   s = delta / (2 - 2 * l);      return [h, s, l]; }    function m48(rgb) {     return h47(rgb[0], rgb[1], rgb[2]); }    function n49(h, s, l) {     while (h < 0) h++;     h %= 1;      let q =         l < 0.5         ? l * (1 + s)         : l + s - l * s;      let p = 2 * l - q;      let tr = h + 1/3;     let tg = h;     let tb = h - 1/3;      if (tr < 0) tr += 1; if (tr > 1) tr -= 1;     if (tg < 0) tg += 1; if (tg > 1) tg -= 1;     if (tb < 0) tb += 1; if (tb > 1) tb -= 1;      let r, g, b;      let qp6 = (q - p) * 6;            if (tr <  1/6)				r = p + qp6 * tr;     else if (tr >= 1/6 && tr < 0.5)	r = q;     else if (tr >= 0.5 && tr < 2/3)	r = p + qp6 * (2/3 - tr);     else							r = p; 	          if (tg <  1/6)				g = p + qp6 * tg;     else if (tg >= 1/6 && tg < 0.5)	g = q;     else if (tg >= 0.5 && tg < 2/3) g = p + qp6 * (2/3 - tg);     else							g = p;           if (tb <  1/6)				b = p + qp6 * tb;     else if (tb >= 1/6 && tb < 0.5) b = q;     else if (tb >= 0.5 && tb < 2/3) b = p + qp6 * (2/3 - tb);     else							b = p;      return [r, g, b]; }    function z50(hsl) {     return n49(hsl[0], hsl[1], hsl[2]); }


function a59(xyz) {     return m946(xyz, CAT); }    function q60(lms) {     return m946(lms, invCAT); }    function v3865(r, g, b, cs = h36)  {     r = cs.degamma(r);     g = cs.degamma(g);     b = cs.degamma(b);      return [         0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b, 	    0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b, 	    0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b ]; }            function u3871(lms, cs = h36)  {     const l = cube(lms[0]);     const m = cube(lms[1]);     const s = cube(lms[2]);  	const r =  4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s; 	const g = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s; 	const b = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s;      return [         cs.regamma(r),         cs.regamma(g),         cs.regamma(b) ]; }    function v3866(lms)  {     const l = Math.cbrt(lms[0]);     const m = Math.cbrt(lms[1]);     const s = Math.cbrt(lms[2]);      const l_ = 0.2104542553 * l + 0.7936177850 * m - 0.0040720468 * s;     const a_ = 1.9779984951 * l - 2.4285922050 * m + 0.4505937099 * s;     const b_ = 0.0259040371 * l + 0.7827717662 * m - 0.8086757660 * s;      return [         l_,         a_,          b_ ]; }    function u3869(lab) {     return p3870(lab[0], lab[1], lab[2]); }    function p3870(l, a, b)  {     return [         l + 0.3963377774 * a + 0.2158037573 * b,         l - 0.1055613458 * a - 0.0638541728 * b,         l - 0.0894841775 * a - 1.2914855480 * b ]; }


function n69(rgb, cs = h36) {      return i70(degamma(rgb, cs), cs); }        function i70(rgb, cs = h36) {     return m946(rgb, cs.i70); }            function d71(xyz, cs = h36) {     return regamma(f72(xyz, cs), cs); }    function f72(xyz, cs = h36) {     return m946(xyz, cs.f72); }


function v3859(rgb, cs = h36) {     return x3861(n69(rgb, cs), cs.W); }    function q3860(luv, cs = h36) {     return d71(s3862(luv, cs.W), cs); }    function x3861(xyz, W = h36.W) {     const x = xyz[0],            y = xyz[1],            z = xyz[2];      const e = cube(6/29);     const k = cube(29/3);      const yw = y / W[1];      let l =          yw > e         ? 116 * Math.cbrt(yw) - 16         : k * yw;      const u_ = 4*x / (x + 15*y + 3*z);     const v_ = 9*y / (x + 15*y + 3*z);          const uw = 4*W[0] / (W[0] + 15*W[1] + 3*W[2]);     const vw = 9*W[1] / (W[0] + 15*W[1] + 3*W[2]);          const u = 13*l * (u_ - uw);     const v = 13*l * (v_ - vw);      return [         l / 100,          u / 100,          v / 100]; }    function s3862(luv, W = h36.W) {     let l = luv[0] * 100,          u = luv[1] * 100,          v = luv[2] * 100;      const e = cube(6/29);         const k = cube(29/3);      const uw = 4*W[0] / (W[0] + 15*W[1] + 3*W[2]);     const vw = 9*W[1] / (W[0] + 15*W[1] + 3*W[2]);          const y =          l > e*k         ? cube((l + 16) / 116)         : l / k;          const a = (52*l / nozero(u + 13*l*uw) - 1) / 3;     const b = -5 * y;     const c = -1/3;     const d =  y * (39*l / nozero(v + 13*l*vw) - 5);      const x = (d - b) / nozero(a - c);      const z = x*a + b;      return [x, y, z]; }


function b55(rgb, cs = h36) {     return i57(n69(rgb, cs), cs.W); }    function k56(lab, cs = h36) {     return d71(z58(lab, cs.W), cs); }    function i57(xyz, W = h36.W) {     const x = xyz[0],            y = xyz[1],            z = xyz[2];      const e = 0.008856;      const k = 903.3;          let xw = x / W[0];     let yw = y / W[1];     let zw = z / W[2];      xw = xw > e ? Math.cbrt(xw) : (k / 100 * xw + 0.16) / 1.16;     yw = yw > e ? Math.cbrt(yw) : (k / 100 * yw + 0.16) / 1.16;     zw = zw > e ? Math.cbrt(zw) : (k / 100 * zw + 0.16) / 1.16;       const l = (1.16 * yw) - 0.16;     const a = 5 * (xw - yw);     const b = 2 * (yw - zw);      return [l, a, b]; }    function z58(lab, W = h36.W) {     const l = lab[0],            a = lab[1],            b = lab[2];      const e = 0.008856 / 100;      const k = 903.3    / 100;       const yw = (l + 0.16)/1.16;     const xw = a/5 + yw;     const zw = yw - b/2;      let x = cube(xw) > e ? cube(xw) : (1.16*xw - 0.16) / k;     let y = cube(yw) > e ? cube(yw) : (1.16*yw - 0.16) / k;     let z = cube(zw) > e ? cube(zw) : (1.16*zw - 0.16) / k;      x *= W[0];     y *= W[1];     z *= W[2];       return [x, y, z]; }


function g3863(rgb, cs = h36) {     return o3864(rgb[0], rgb[1], rgb[2], cs); }    function o3864(r, g, b, cs = h36)  {     return v3866(v3865(r, g, b, cs)); }        function t3867(lab, cs = h36) {     return u3871(u3869(lab), cs); }    function v3868(l, a, b, cs = h36)  {     return t3867([l, a, b], cs); }


const r65 = 0.89;   function y63(opp)  {                const l = opp[0],            a = opp[1],            b = opp[2];      const h = Math.atan2(b, a);     const c = Math.sqrt(a*a + b*b);      return [h, c, l]; }    function e64(pol)  {                const h = pol[0],            c = pol[1],            l = pol[2];      const a = c * Math.cos(h);     const b = c * Math.sin(h);      return [l, a, b]; }


function m34(hcl, cs = h36) {     hcl = [...hcl];      hcl[0] *= Tau;     hcl[1] *= hcl[2];       return t3867(e64(hcl), cs); }        function d35(h, c, l, cs = h36) {     return m34([h, c, l], cs); }                    function o37(rgb, cs = h36) {     const hcl = y63(g3863(rgb, cs));      hcl[0] /= Tau;     hcl[1] /= nozero(hcl[2]);      while (hcl[0] < 0) hcl[0] += 1;     while (hcl[0] > 1) hcl[0] -= 1;      return hcl; }    function z38(r, g, b, cs = h36) {     return o37([r, g, b], cs); }    function x39(hcl) {     hcl = [...hcl];      hcl[0] *= Tau;     hcl[1] *= hcl[2];      return e64(hcl); }    function b40(hcl, cs = h36) {     return k56(x39(hcl), cs); }    function hclab2rgb_(h, c, l, cs = h36) {     return b40([h, c, l], cs); }    function z41(lab) {     let hcl = y63(lab);      hcl[0] /= Tau;     hcl[1] /= hcl[2];      while (hcl[0] < 0) hcl[0] += 1;     while (hcl[0] > 1) hcl[0] -= 1;      return hcl; }    function f42(rgb, cs = h36) {     return z41(b55(rgb, cs)); }    function d43(hcl) {     hcl = [...hcl];      hcl[0] *= Tau;     hcl[1] *= hcl[2];      return e64(hcl); }    function c44(hcl, cs = h36) {     return q3860(d43(hcl), cs); }    function hcluv2rgb_(h, c, l, cs = h36) {     return c44([h, c, l], cs); }    function f45(luv) {     let hcl = y63(luv);      hcl[0] /= Tau;     hcl[1] /= hcl[2];      while (hcl[0] < 0) hcl[0] += 1;     while (hcl[0] > 1) hcl[0] -= 1;      return hcl; }    function q46(rgb, cs = h36) {     return f45(v3859(rgb, cs)); }


function k2448(xyz)  {     const [l, a, b] = xyzToLab(xyz);                    const hue = Math.atan2(b, a) * (180 / Math.PI);     const chroma = Math.sqrt(a * a + b * b);     const tone = l;            return { hue, chroma, tone }; }


const k131 =  [     ['hex',   'Hex'           ],     ['rgb',   'RGB'           ],      ['hsl',   'HSL'           ],      ['hsv',   'HSB'           ],      ['lin',   'RGB / Linear'  ],      ['p3',    'RGB / P3'      ],      ['a98',   'RGB / Adobe98' ],      ['pro',   'RGB / ProPhoto'],      ['r2020', 'RGB / Rec.2020'],      ['hclok', 'HCL / ok'      ],     ['hclab', 'HCL / ab'      ],     ['hcluv', 'HCL / uv'      ],     ['oklab', 'okLab'         ],     ['lab',   'Lab'           ],     ['luv',   'Luv'           ],     ['xyz',   'XYZ'           ],     ['xyz50', 'XYZ / D50'     ],     ['xyz65', 'XYZ / D65'     ] ];    function d133     (index) { return k131[index][0]; } function colorSpaceName (index) { return k131[index][1]; } function u4004(space) { return k131.findIndex(s => s[0] == space); }    class i132 {     hex   = Object.freeze( 0);     rgb   = Object.freeze( 1);     hsl   = Object.freeze( 2);     hsv   = Object.freeze( 3);     lin   = Object.freeze( 4);     p3    = Object.freeze( 5);     a98   = Object.freeze( 6);     pro   = Object.freeze( 7);     r2020 = Object.freeze( 8);     hclok = Object.freeze( 9);     hclab = Object.freeze(10);     hcluv = Object.freeze(11);     oklab = Object.freeze(12);     lab   = Object.freeze(13);     luv   = Object.freeze(14);     xyz   = Object.freeze(15);     xyz50 = Object.freeze(16);     xyz65 = Object.freeze(17); }    class Color extends Float32Array {     get r() { return this[0]; }     get g() { return this[1]; }     get b() { return this[2]; }     get a() { return this[3]; }     get s() { return this[4]; }      set r(r) { this[0] = r; }     set g(g) { this[1] = g; }     set b(b) { this[2] = b; }     set a(a) { this[3] = a; }     set s(s) { this[4] = s; }        constructor(c = null)     {         super(5);           if (c)         {             this.r = c.r;             this.g = c.g;             this.b = c.b;             this.a = c.a;             this.s = c.s;         }         else         {             this.r = 0;             this.g = 0;             this.b = 0;             this.a = 0;             this.s = i132.rgb;         }     } }


const r76 = 0.001;    function e146(rgb) {     const _space = 'rgb';      return [         _space,          a4055(rgb[0], _space, 0),          a4055(rgb[1], _space, 1),          a4055(rgb[2], _space, 2) ];  }    function m147(space, c1, c2, c3) {     const _space = d133(space.value);      return [         _space,          a4055(c1.value, _space, 0),          a4055(c2.value, _space, 1),          a4055(c3.value, _space, 2) ];  }    function o148(c) {     return isNaN(c[1])         || isNaN(c[2])         || isNaN(c[3]); }    function j149(col, lim = r76) {     return c75(e4074(col), lim); }    function z150(col, lim = r76) {     return p78(e4074(col), lim); }


const rgb_NaN = [     Number.NaN,     Number.NaN,     Number.NaN ];  const rgba_NaN = [     Number.NaN,     Number.NaN,     Number.NaN,     Number.NaN ];   const rgb_display_NaN  = [1, 0, 1]; const rgba_display_NaN = [1, 0, 1, 1];  const rgbInvalid  = [0xff, 0, 0xff]; const rgbaInvalid = [0xff, 0, 0xff, 0xff];   const v3711 = Object.freeze([     'rgb',     Number.NaN,     Number.NaN,     Number.NaN ]);   const transparent = [0, 0, 0, 0];   const TRANSPARENT_THRESHOLD_DARK  = 0.45; const TRANSPARENT_THRESHOLD_LIGHT = 0.45;  const getTransparentThreshold = () =>      c3889     ? TRANSPARENT_THRESHOLD_DARK     : TRANSPARENT_THRESHOLD_LIGHT;            const CAT = [[ 0.7328, 0.4296, -0.1624],              [-0.7036, 1.6975,  0.0061],              [ 0.0030, 0.0136,  0.9834]];  const invCAT = g889(CAT);   const M1 = [[ 0.8189330101, 0.3618667424, -0.1288597137 ],             [ 0.0329845436, 0.9293118715,  0.0361456387 ],             [ 0.0482003018, 0.2643662691,  0.6338517070 ]];  const invM1 = g889(M1);    function xy2xyz(x, y, Y = 1)  {     let X = (x / y) * Y;     let Z = ((1 - x - y) / y) * Y;          let N = X + Y + Z;      return [X / N,              Y / N,              Z / N]; }    function q73(rgb)  {     return isNaN(rgb[0])         || isNaN(rgb[1])         || isNaN(rgb[2]); }    function q74(rgba)  {     return isNaN(rgba[0])         || isNaN(rgba[1])         || isNaN(rgba[2])         || isNaN(rgba[3]); }    function c75(rgb, lim = r76) {     return rgb[0] > -lim && rgb[0] < 1 + lim          && rgb[1] > -lim && rgb[1] < 1 + lim          && rgb[2] > -lim && rgb[2] < 1 + lim; }    function h77(rgba, lim = r76) {     return rgba[0] > -lim && rgba[0] < 1 + lim          && rgba[1] > -lim && rgba[1] < 1 + lim          && rgba[2] > -lim && rgba[2] < 1 + lim         && rgba[3] > -lim && rgba[3] < 1 + lim; }    function p78(rgb, lim = r76) {     return !q73  (rgb)         &&  c75(rgb, lim); }    function v79(rgba, lim = r76) {     return !q74  (rgba)         &&  h77(rgba, lim); }    function p80(rgb) {     return [         Math.min(Math.max(0, rgb[0]), 1),         Math.min(Math.max(0, rgb[1]), 1),         Math.min(Math.max(0, rgb[2]), 1) ]; }    function t81(j82, n83, t) {     return [ t1033(j82[0], n83[0], t),              t1033(j82[1], n83[1], t),              t1033(j82[2], n83[2], t) ]; }    function m84(x3699, rgba2, t) {     return [ t1033(x3699[0], rgba2[0], t),              t1033(x3699[1], rgba2[1], t),              t1033(x3699[2], rgba2[2], t),              t1033(x3699[3], rgba2[3], t) ]; }    function g85(j82, n83) {     return [ j82[0] + n83[0],              j82[1] + n83[1],              j82[2] + n83[2] ]; }    function rgbaAdd(x3699, rgba2) {     return [ x3699[0] + rgba2[0],              x3699[1] + rgba2[1],              x3699[2] + rgba2[2],              x3699[3] + rgba2[3] ]; }    function w86(j82, n83) {     return [ j82[0] - n83[0],              j82[1] - n83[1],              j82[2] - n83[2] ]; }    function g87(rgb, s) {     return [ rgb[0] * s,              rgb[1] * s,              rgb[2] * s ]; }    function rgbaMuls(rgba, s) {     return [ rgba[0] * s,              rgba[1] * s,              rgba[2] * s,              rgba[3] * s ]; }    function e88(j82, n83) {     return [ (j82[0] + n83[0]) / 2,              (j82[1] + n83[1]) / 2,              (j82[2] + n83[2]) / 2 ]; }    function l89(j82, n83) {     return [ Math.max(j82[0], n83[0]),              Math.max(j82[1], n83[1]),              Math.max(j82[2], n83[2]) ]; }    function t90(col, p) {     return [         Math.pow(col[0], p),          Math.pow(col[1], p),          Math.pow(col[2], p) ] }    function y91(cones) {     return cones.l == 1          && cones.m == 1          && cones.s == 1; }    function p92(rgb) {     return '{' + Math.round(rgb[0] * 255) + ', '                + Math.round(rgb[1] * 255) + ', '                + Math.round(rgb[2] * 255) + '}'; }    function z93(r, g, b, a) {     if (a !== undefined)     {         return 'rgba('             + Math.round(r * 0xff) + ', '             + Math.round(g * 0xff) + ', '             + Math.round(b * 0xff) + ', '             + a + ')';     }     else     {         return 'rgb('             + Math.round(r * 0xff) + ', '             + Math.round(g * 0xff) + ', '             + Math.round(b * 0xff) + ')';     } }    function g94(r, g, b) {     return z93(r, g, b, 1); }    function i95(rgb) {     return z93(rgb[0], rgb[1], rgb[2], 1); }    function v96(r, g, b, a) {     return z93(r, g, b, a); }    function h97(rgba) {     return z93(rgba[0], rgba[1], rgba[2], rgba[3]); }    function y98(rgb, a = 1) {     return z93(rgb[0], rgb[1], rgb[2], a); }    function l99(rgb_) {     return rgb_.length == 3          ? [...rgb_, 1]          : rgb_; }    function l100(rgb, a = 1) {     return [rgb[0], rgb[1], rgb[2], a]; }    function o101(rgb, threshold = 0.71) {     return o37(rgb)[2] < threshold; }    function isLight(rgb, threshold = 0.71) {     return !o101(rgb, threshold); }    function w105(rgba, v) {     return [         rgba[0] * v,         rgba[1] * v,         rgba[2] * v,         rgba[3] * v ]; }    function z106(rgba, v) {     return [         rgba[0] / v,         rgba[1] / v,         rgba[2] / v,         rgba[3] / v ]; }    function t107(z103, f104) {     return Math.max(Math.max(Math.max(         Math.abs(f104[0] - z103[0]),         Math.abs(f104[1] - z103[1])),         Math.abs(f104[2] - z103[2]))); }    function n108(j82, n83) {     return Math.abs(j82[0] - n83[0]) < r76         && Math.abs(j82[1] - n83[1]) < r76         && Math.abs(j82[2] - n83[2]) < r76;         }    function d109(style)  {     k3897.fillStyle = style;     k3897.fillRect(0, 0, 1, 1);      return z106(k3897.getImageData(0, 0, 1, 1).data, 0xFF); }    function k110(c111, style)  {     k3897.fillStyle = a1480(c111, style);     k3897.fillRect(0, 0, 1, 1);      return z106(k3897.getImageData(0, 0, 1, 1).data, 0xFF); }    function t112(rgb, opacity = 1) {     return !q73(rgb)            ? (opacity < getTransparentThreshold()               ? (c3889    ? [1, 1, 1, 0.75] : [0, 0, 0, 0.75])               : (o101(rgb) ? [1, 1, 1, 0.75] : [0, 0, 0, 0.75]))            : (c3889 ? y2241 : u2240); }    function d113(rgb) {     return !q73(rgb)          ? (o101(rgb)  ? [1, 1, 1, 0.133] : [0, 0, 0, 0.161])            : (c3889 ? [1, 1, 1, 0.031] : [0, 0, 0, 0.031]);   }    function k114(x115) {     let q3731,          p3732;                   const y3733 = d113(x115);            if (!q73(x115))     {         const h3734 = o37(x115);          const p3735 = [...h3734];         const j3736 = [...h3734];          p3735[0] += 1/12;  if (p3735[0] > 1) p3735[0] -= 1;         j3736[0] -= 1/12;  if (j3736[0] < 0) j3736[0] += 1;           const z3737 = l100(o123(m34(p3735)), 0.35);         const p3738 = l100(o123(m34(j3736)), 0.35);          const factor   = y119(x115);          const colWarn1 = m84(y3733, z3737, factor);         const colWarn2 = m84(y3733, p3738, factor);                  q3731     = h97(colWarn1);         p3732     = h97(colWarn2);     }     else     {         q3731 = h97(y3733);         p3732 = h97(y3733);     }       return [q3731,              p3732]; }    function i116(i, q117, m118) {     return 'repeating-linear-gradient('             + '-45deg, '             + 'transparent 0 ' + i   + 'px,'              +  q117 + ' '    + i   + 'px ' + i*2 +'px,'             + 'transparent '   + i*2 + 'px ' + i*3 +'px,'             +  m118 + ' '    + i*3 + 'px ' + i*4 +'px)'; }    function y119(x115) {     let dr, dg, db;      if (x115[0] < 0) dr = -x115[0]; else if (x115[0] > 1) dr = x115[0] - 1; else dr = 0;     if (x115[1] < 0) dg = -x115[1]; else if (x115[1] > 1) dg = x115[1] - 1; else dg = 0;     if (x115[2] < 0) db = -x115[2]; else if (x115[2] > 1) db = x115[2] - 1; else db = 0;          const d   = [dr, dg, db].sort()[1];     const avg = (dr + dg + db) / 3;      const factor = Math.min((d + avg) / 2, 1);                                                              return factor; }    function u120(m121) {     let m3739 = [...m121];              const factor = y119(m121);      if (factor > 0)     {         const hcl = o37(o123(m121));         hcl[1] /= 2;                   m3739 = t81(m121, h129(m34(hcl)), factor);     }      return m3739; }    function x122(rgba) {     return !q74(rgba)          ? (o101(rgba)  ? '#ffffff29' : '#00000022')          : (c3889 ? '#ffffff08' : '#00000006');  }    function o123(t124) {     const rgb = [...t124];      rgb[0] = Math.min(Math.max(0, rgb[0]), 1);        rgb[1] = Math.min(Math.max(0, rgb[1]), 1);        rgb[2] = Math.min(Math.max(0, rgb[2]), 1);       return rgb; }    function j125(val) {     return Math.min(Math.max(0, val), 1); }    function n126(g127, j128, val) {     const col = [...g127];     col[j128] = val;     return col; }    function h129(rgb) {     let hcl = o37(rgb);      let w3740 = 10000;      while (!c75(m34(hcl))          && hcl[1] > 0.001          && w3740-- > 0)         hcl[1] -= 0.001;      rgb = m34(hcl);      rgb[0] = Math.min(Math.max(0, rgb[0]), 1);        rgb[1] = Math.min(Math.max(0, rgb[1]), 1);        rgb[2] = Math.min(Math.max(0, rgb[2]), 1);       return rgb; }    function h130(rgba) {     if (!q74(rgba))         return 'transparent';     else     {         return c3889             ? 'rgba(56, 56, 56, 0.95)'             : 'rgba(255, 255, 255, 0.95)';     } }    function addHueHsl(rgb, d, min = 0, max = Tau) {     const hsl = m48(rgb);      return n49(         trimAngle(hsl[0] + d, min, max),         hsl[1],          hsl[2]); }    function addHueHclok(rgb, d, min = 0, max = Tau) {     const hcl = o37(rgb);      return d35(         trimAngle(hcl[0] + d, min, max),         hcl[1],          hcl[2]); }    function addHueHclab(rgb, d, min = 0, max = Tau) {     const hcl = f42(rgb);      return hclab2rgb_(         trimAngle(hcl[0] + d, min, max),         hcl[1],          hcl[2]); }    function addHueHcluv(rgb, d, min = 0, max = Tau) {     const hcl = q46(rgb);      return hcluv2rgb_(         trimAngle(hcl[0] + d, min, max),         hcl[1],          hcl[2]); }    function addHclok(rgb, hcl_chan, d) {     const hcl = o37(rgb);      if (hcl_chan == 0)         hcl[0] = trimAngle(hcl[0] + d, 0, Tau);     else         hcl[hcl_chan] += d;      return m34(hcl); }    function multHclok(rgb, hcl_chan, f) {     const hcl = o37(rgb);      if (hcl_chan == 0)         hcl[0] = trimAngle(hcl[0] * f, 0, Tau);     else         hcl[hcl_chan] *= f;      return m34(hcl); }    function rgbSaturate(rgb, l) { return multHclok(rgb, 1, l); } function rgbLighten (rgb, l) { return multHclok(rgb, 2, l); }    function g102(z103, f104) {     return Math.sqrt(         sqr(f104[0] - z103[0])       + sqr(f104[1] - z103[1])       + sqr(f104[2] - z103[2])); }    function deltaE(j82, n83) {     return deltaE00(j82, n83); }    function deltaE76(j82, n83, _rgb2lab = g3863)  {     const lab1 = _rgb2lab(j82);     const lab2 = _rgb2lab(n83);      return g102(lab1, lab2); }    function deltaE94(j82, n83, kH = 1, kC = 1, kL = 1, _rgb2lab = g3863)  {     const [L1, a1, b1] = _rgb2lab(j82);     const [L2, a2, b2] = _rgb2lab(n83);          const C1 = Math.sqrt(a1*a1 + b1*b1);     const C2 = Math.sqrt(a2*a2 + b2*b2);     const dL = L2 - L1;     const dC = C2 - C1;     const da = a2 - a1;     const db = b2 - b1;     const dH = Math.sqrt(da*da + db*db - dC*dC);          const SL = 1;     const SC = 1 + 0.045 * C1;     const SH = 1 + 0.015 * C1;          const deltaE = Math.sqrt(         sqr(dL / (kL * SL)) +         sqr(dC / (kC * SC)) +         sqr(dH / (kH * SH)));          return deltaE; }    function deltaE00(j82, n83, kH = 1, kC = 1, kL = 1, _rgb2lab = g3863) {     const lab1        = _rgb2lab(j82);     const lab2        = _rgb2lab(n83);      const L1          = lab1[0], a1 = lab1[1], b1 = lab1[2];     const L2          = lab2[0], a2 = lab2[1], b2 = lab2[2];      const avgLPrime   = (L1 + L2) / 2;     const C1          = Math.sqrt(a1 * a1 + b1 * b1);     const C2          = Math.sqrt(a2 * a2 + b2 * b2);     const avgC        = (C1 + C2) / 2;     const G           = 0.5 * (1 - Math.sqrt(Math.pow(avgC, 7) / (Math.pow(avgC, 7) + Math.pow(25, 7))));          const a1Prime     = a1 * (1 + G);     const a2Prime     = a2 * (1 + G);     const C1Prime     = Math.sqrt(a1Prime * a1Prime + b1 * b1);     const C2Prime     = Math.sqrt(a2Prime * a2Prime + b2 * b2);          const h1Prime     = Math.atan2(b1, a1Prime) * (180 / Math.PI);     const h2Prime     = Math.atan2(b2, a2Prime) * (180 / Math.PI);          const deltaLPrime = L2 - L1;     const deltaCPrime = C2Prime - C1Prime;     const deltahPrime = 2 * Math.sqrt(C1Prime * C2Prime) * Math.sin(((h2Prime - h1Prime) / 2) * (Math.PI / 180));      const avgCPrime = (C1Prime + C2Prime) / 2;     const avghPrime =         Math.abs(h1Prime - h2Prime) > 180             ? (h1Prime + h2Prime + 360) / 2             : (h1Prime + h2Prime) / 2;           const SL = 1 + (0.015 * sqr(avgLPrime - 50)) / Math.sqrt(20 + sqr(avgLPrime - 50));     const SC = 1 + 0.045 * avgCPrime;     const SH = 1 + 0.015 * avgCPrime * (1 - 0.17 * Math.cos(avghPrime - 30) + 0.24 * Math.cos(2 * avghPrime) + 0.32 * Math.cos(3 * avghPrime + 6) - 0.20 * Math.cos(4 * avghPrime - 63));      const RT = -2 * Math.sqrt(Math.pow(avgCPrime, 7) / (Math.pow(avgCPrime, 7) + Math.pow(25, 7))) * Math.sin(60 * Math.exp(-sqr((avghPrime - 275) / 25)) * (Math.PI / 180));          const deltaE = Math.sqrt(           sqr(deltaLPrime / (kL * SL)) +           sqr(deltaCPrime / (kC * SC)) +           sqr(deltahPrime / (kH * SH)) +         RT * (deltaCPrime / (kC * SC)) * (deltahPrime / (kH * SH)));          return deltaE; }    function deltaECMC(j82, n83, kC = 1, kL = 2, _rgb2lab = g3863)  {     const [L1, a1, b1] = _rgb2lab(j82);     const [L2, a2, b2] = _rgb2lab(n83);          const C1     = Math.sqrt(a1*a1 + b1*b1);     const C2     = Math.sqrt(a2*a2 + b2*b2);     const deltaL = L2 - L1;     const deltaC = C2 - C1;     const da     = a2 - a1;     const db     = b2 - b1;     const deltaH = Math.sqrt(da*da + db*db - deltaC*deltaC);      const SL     = L1 < 16 ? 0.511 : (0.040975 * L1) / (1 + 0.01765 * L1);     const SC     = 0.0638 * C1 / (1 + 0.0131 * C1) + 0.638;     const SH     = SC * (1 + 0.0131 * C1);      return Math.sqrt(           sqr(deltaL / (kL * SL))         + sqr(deltaC / (kC * SC))         + sqr(deltaH / SH)); }    function deltaEITU(j82, n83)  {     const linear1 = j82.map(v => h36.degamma(v));     const linear2 = n83.map(v => h36.degamma(v));      return g102(linear1, linear2); }    function isColorType(type) {     return COLOR_VALUES.includes(type); }    function isColorTypeOnHeader(type, node) {     return isColorType(type)         && COLOR_HEADER_TYPES.includes(node.type); }    function rgbFromColorValue(value) {     r950(          value,          'rgbFromColorValue() requires a valid value');       if (    value.type == s1148          && !q73(value.u3150()))          return value.u3150();      else if ( value.type == m1158            && !q73(value.color.u3150()))          return value.color.u3150();      else if ( value.type == x1161            &&  value.fills.items.length > 0           && !q73(value.fills.items.at(-1).color.u3150()))          return value.fills.items.at(-1).color.u3150();      else if ( value.type == d1167            && !q74(value.l99()))          return l100(value.l99());      else if ( value.type == o1164            && !q73(value.fill.color.u3150()))          return l100(value.fill.color.u3150());       return rgb_NaN; }    function setSvgLinearGradientStroke(svg, target, color1, color2, x1, y1, x2, y2, contrast = 0)  {     if (!(svg instanceof SVGElement))         throw new Error('\'svg\' must be an SVG element');           let defs = svg.querySelector('defs');      if (!defs)      {         defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        svg.insertBefore(defs, svg.firstChild);     }       const existingGradients = defs.querySelectorAll('linearGradient');     const gradientId        = `svgLinearGradient-${target.curveId}`;          existingGradients.forEach(gradient =>      {         if (gradient.id == gradientId)             gradient.remove();     });       const linearGradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
     linearGradient.setAttribute('id', gradientId);      linearGradient.setAttribute('x1', x1 + '%');     linearGradient.setAttribute('y1', y1 + '%');     linearGradient.setAttribute('x2', x2 + '%');     linearGradient.setAttribute('y2', y2 + '%');           const contrastDist = 35;      const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
    stop1.setAttribute('offset', '0%');     stop1.setAttribute('stop-color', color1);      // const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
               // const stop3 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
               const stop4 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
    stop4.setAttribute('offset', '100%');     stop4.setAttribute('stop-color', color2);        linearGradient.appendChild(stop1);               linearGradient.appendChild(stop4);      defs.appendChild(linearGradient);       target.style.stroke = `url(#${gradientId})`;       return gradientId; }    function getChannelNamesFromSpace(space) {     switch (space)     {     case 'hex':   return ['r', 'g', 'b'];     case 'rgb':   return ['r', 'g', 'b'];     case 'lin':   return ['r', 'g', 'b'];     case 'p3':    return ['r', 'g', 'b'];     case 'a98':   return ['r', 'g', 'b'];     case 'pro':   return ['r', 'g', 'b'];     case 'r2020': return ['r', 'g', 'b'];     case 'hsl':   return ['h', 's', 'l'];     case 'hsv':   return ['h', 's', 'b'];     case 'hclok': return ['h', 'c', 'l'];     case 'hclab': return ['h', 'c', 'l'];     case 'hcluv': return ['h', 'c', 'l'];     case 'oklab': return ['l', 'a', 'b'];     case 'lab':   return ['l', 'a', 'b'];     case 'luv':   return ['l', 'u', 'v'];     case 'xyz':   return ['x', 'y', 'z'];     case 'xyz50': return ['x', 'y', 'z'];     case 'xyz65': return ['x', 'y', 'z'];     }      console.error('invalid color space \'' + space + '\'');     return ['c1', 'c2', 'c3']; }


// https://ixora.io/projects/colorblindness/color-blindness-simulation-research/
  const a135 = a59(i70([1, 1, 1])); const m136 = a59(i70([0, 0, 1])); const k137 = a59(i70([1, 0, 0]));  const h138 = (a135[2]*m136[0] - m136[2]*a135[0]) / (a135[2]*m136[1] - m136[2]*a135[1]); const q139 = (a135[1]*m136[0] - m136[1]*a135[0]) / (a135[1]*m136[2] - m136[1]*a135[2]);  const g140 = (a135[2]*m136[1] - m136[2]*a135[1]) / (a135[2]*m136[0] - m136[2]*a135[0]); const c141 = (a135[0]*m136[1] - m136[0]*a135[1]) / (a135[0]*m136[2] - m136[0]*a135[2]);  const t142 = (a135[1]*k137[2] - k137[1]*a135[2]) / (a135[1]*k137[0] - k137[1]*a135[0]); const b143 = (a135[0]*k137[2] - k137[0]*a135[2]) / (a135[0]*k137[1] - k137[0]*a135[1]);  const b144 = a135[0] / a135[2]; const q145 = a135[1] / a135[2];   // this is a number I made up following the information here: https://www.color-blindness.com/2007/07/20/monochromacy-complete-color-blindness/
    const r3741 = 0.88;   function j134(rgb, l, m, s, cs = h36) {     if (   l == 0         && m == 0         && s == 0)     {                   const a =                cs.Y[0] * rgb[0]             + cs.Y[1] * rgb[1]             + cs.Y[2] * rgb[2];          rgb = [a, a, a];     }     else     {         const xyz = n69(rgb, cs);         const lms = a59(xyz);          const a =                cs.Y[0] * rgb[0]             + cs.Y[1] * rgb[1]             + cs.Y[2] * rgb[2];          const lm = Math.min(l + m, 1);           const lms_ = [             lms[0] + t1033(r3741 * (b144*lms[2] - lms[0]), (1 - l) * ((h138*lms[1] + q139*lms[2]) - lms[0]), lm),             lms[1] + t1033(r3741 * (q145*lms[2] - lms[1]), (1 - m) * ((g140*lms[0] + c141*lms[2]) - lms[1]), lm),             lms[2] + t1033(0,                     t1033(s, 1 - s, lm) * ((t142*lms[0] + b143*lms[1]) - lms[2]), lm) ];          const xyz_ = q60(lms_);               rgb  = d71(xyz_, cs);           let bm_ = b55(rgb, cs);         bm_[0] = t1033(a, bm_[0], lm);         rgb = k56(bm_, cs);                   rgb = t81(             [a, a, a],              rgb,              Math.min(s + lm, 1));     }           return rgb; }


function z2452(c) {     return Math.round(c * 0xff)         .toString(16)         .padStart(2, '0')         .toUpperCase();     }    function e151(rgb, hash = false) {     let hex =           z2452(rgb[0])         + z2452(rgb[1])         + z2452(rgb[2]);      return (hash ? '#' : '') + hex; }    function u152(rgba, hash = false) {     let hex =           z2452(rgba[0])         + z2452(rgba[1])         + z2452(rgba[2])         + z2452(rgba[3]);      return (hash ? '#' : '') + hex; }    function a153(hex)  {     return hex.indexOf(t962) > -1             ? rgb_NaN             : z155(hex); }    function q154(hex)  {     return hex.indexOf(t962) > -1             ? rgba_NaN             : r156(hex); }    function z155(hex) {     if (hex[0] == '#')         hex = hex.substring(1);               let rgb = [];      if (hex.length >= 6)     {         rgb[0] = parseInt(hex.slice(0, 2), 16);          rgb[1] = parseInt(hex.slice(2, 4), 16);          rgb[2] = parseInt(hex.slice(4, 6), 16);      }     else if (hex.length >= 3)     {         rgb[0] = parseInt(hex[0], 16) * 0x11;          rgb[1] = parseInt(hex[1], 16) * 0x11;          rgb[2] = parseInt(hex[2], 16) * 0x11;      }     else if (hex.length == 2)     {         let v = parseInt(hex, 16);                  rgb[0] = v;          rgb[1] = v;          rgb[2] = v;      }     else if (hex.length == 1)     {         let v = parseInt(hex, 16);                  rgb[0] = v * 0x11;          rgb[1] = v * 0x11;          rgb[2] = v * 0x11;      }     else if (hex.length == 0)     {         rgb = null;                                 }       if (rgb)     {         rgb[0] /= 0xff;         rgb[1] /= 0xff;         rgb[2] /= 0xff;     }           return rgb; }    function r156(hex) {     if (hex[0] == '#')         hex = hex.substring(1);               let rgba = [];      if (hex.length >= 8)     {         rgba[0] = parseInt(hex.slice(0, 2), 16);          rgba[1] = parseInt(hex.slice(2, 4), 16);          rgba[2] = parseInt(hex.slice(4, 6), 16);          rgba[3] = parseInt(hex.slice(6, 8), 16);      }     else if (hex.length >= 6)     {         rgba[0] = parseInt(hex.slice(0, 2), 16);          rgba[1] = parseInt(hex.slice(2, 4), 16);          rgba[2] = parseInt(hex.slice(4, 6), 16);          rgba[3] = 0xff;      }     else if (hex.length >= 4)     {         rgba[0] = parseInt(hex[0], 16) * 0x11;          rgba[1] = parseInt(hex[1], 16) * 0x11;          rgba[2] = parseInt(hex[2], 16) * 0x11;          rgba[3] = parseInt(hex[3], 16) * 0x11;      }     else if (hex.length == 3)     {         rgba[0] = parseInt(hex[0], 16) * 0x11;          rgba[1] = parseInt(hex[1], 16) * 0x11;          rgba[2] = parseInt(hex[2], 16) * 0x11;          rgba[3] = 0xff;      }     else if (hex.length == 2)     {         let v = parseInt(hex, 16);                  rgba[0] = v;          rgba[1] = v;          rgba[2] = v;          rgba[3] = 0xff;      }     else if (hex.length == 1)     {         let v = parseInt(hex, 16);                  rgba[0] = v * 0x11;          rgba[1] = v * 0x11;          rgba[2] = v * 0x11;          rgba[3] = 0xff;      }     else if (hex.length == 0)     {         rgba = null;                                          }       if (rgba)     {         rgba[0] /= 0xff;         rgba[1] /= 0xff;         rgba[2] /= 0xff;         rgba[3] /= 0xff;     }       return rgba; }


function s157(f158, v159) {     if (    q73  (f158)         || !c75(f158))         return Number.NaN;      const w164 = h36.luminance(f158);     const  a165 = h36.luminance(v159);      return (         a165 > w164         ? ( a165 + 0.05) / (w164 + 0.05)         : (w164 + 0.05) / ( a165 + 0.05)); }    function i160(ratio) {          if (ratio >= 7  ) return 'AAA';     else if (ratio >= 4.5) return 'AA';     else if (ratio >= 3  ) return 'AA<sub>L</sub>';     else                   return ''; }    function t161(f158, v159) {     if (!p78(f158))         return Number.NaN;      return f163(         j162(f158),         j162(v159)); }    // I copied the code below from https://github.com/Myndex/j4002-APCA/blob/master/WEBTOOLS/APCA/JS/DEV.0.1.2.G_SAPCsRGB.js
  const d2443     = 2.4;          const k3983        = 0.2126729,        n3984        = 0.7151522,        b3985        = 0.0721750;      const normBg      = 0.56,        normTxt     = 0.57,       revTxt      = 0.62,       revBg       = 0.65;      const p3990     = 0.022,       blkClip     = 1.414,        e3992    = 1.14,       e3993    = 1.14,       x3994 = 0.035991,       g3995 = 0.035991,       m3996 = 27.7847239587675,       l3997 = 27.7847239587675,       n3998 = 0.027,       e3999 = 0.027,       v4000      = 0.001,       k4001   = 0.0005;    function j162(rgb)  {                     return k3983 * Math.pow(rgb[0], d2443)           + n3984 * Math.pow(rgb[1], d2443)          + b3985 * Math.pow(rgb[2], d2443); }    function f163(w164, a165) {     let sapc           = 0;      let b4003 = 0;       w164 =          w164 > p3990          ? w164          : w164 + Math.pow(p3990 - w164, blkClip);              a165 =          a165 > p3990          ? a165          : a165 + Math.pow(p3990 - a165, blkClip);      if (Math.abs(a165 - w164) < k4001)           return 0;        if (a165 > w164)      {           sapc = (Math.pow(a165, normBg) - Math.pow(w164, normTxt)) * e3992;          b4003 =              sapc < v4000              ? 0              : sapc < x3994               ? sapc - sapc * m3996 * n3998                : sapc - n3998;     }      else      {           sapc = (Math.pow(a165, revBg) - Math.pow(w164, revTxt)) * e3993;          b4003 =              sapc > -v4000              ? 0              : sapc > -g3995                ? sapc - sapc * l3997 * e3999                : sapc + e3999;     }       return b4003 * 100; }


const y4006  = [255, 255, 255]; const p4007  = [360, 100, 100]; const m4008  = [360, 100, 100]; const f4009  = [100, 100, 100]; const xyzFactor  = [100, 100, 100];      const l4010   = [255, 255, 255];    const q4011   = [360, 100, 100];   const o4012 = [360,  50, 100]; const j4013 = [360, 400, 100]; const b4014 = [360, 330, 100];   const r4015 = [100,  30,  30]; const q4016   = [100, 100, 100]; const t4017   = [100, 150, 150];   const xyzScale   = [100, 100, 100];     function q4018(space) {     switch (space)     {         case 'hex':         case 'rgb':         case 'lin':         case 'p3':         case 'a98':         case 'pro':         case 'r2020':  return y4006;          case 'hsv':         case 'hsl':    return p4007;          case 'hclok':         case 'hclab':         case 'hcluv':  return m4008;          case 'oklab':         case 'lab':         case 'luv':    return f4009;          case 'xyz':         case 'xyz50':         case 'xyz65':  return xyzFactor;                  default:       s951('invalid color factor from space \''+space+'\''); break;     } }    function colorScale(space) {     switch (space)     {         case 'hex':         case 'rgb':         case 'lin':         case 'p3':         case 'a98':         case 'pro':         case 'r2020': return l4010;          case 'hsv':         case 'hsl':   return q4011;          case 'hclok': return o4012;         case 'hclab': return j4013;         case 'hcluv': return b4014;          case 'oklab': return r4015;         case 'lab':   return q4016;         case 'luv':   return t4017;          case 'xyz':         case 'xyz50':         case 'xyz65': return xyzScale;     }      console.error('invalid color space \'' + space + '\'');     return [1, 1, 1]; }    function i4019(col, space) {     let scale = colorScale(space);      return [         col[0] * scale[0],         col[1] * scale[1],         col[2] * scale[2] ]; }    function b4020(rgb) {     return [ rgb[0] / 255,              rgb[1] / 255,              rgb[2] / 255 ]; }    function v4021(rgb, dec = 0) {     return [ p1014(rgb[0] * 255, dec),              p1014(rgb[1] * 255, dec),              p1014(rgb[2] * 255, dec) ]; }    function v4022(node, space) {     switch (space)     {         case 'hex':   i4024   (node); break;          case 'rgb':         case 'lin':         case 'p3':         case 'a98':         case 'pro':         case 'r2020': f4025   (node); break;          case 'hsv':   k4026   (node); break;         case 'hsl':   x4027   (node); break;          case 'hclok': p4028 (node); break;         case 'hclab': v4029 (node); break;         case 'hcluv': k4030 (node); break;          case 'oklab': c4031 (node); break;         case 'lab':   y4032   (node); break;         case 'luv':   c4033   (node); break;          case 'xyz':             case 'xyz50':          case 'xyz65': switchToXyz   (node); break;     }       }    function i4024  (node) { u4034   (node); s4044(node); } function f4025  (node) { u4034   (node);                        }  function k4026  (node) { w4035   (node, 'B');                   } function x4027  (node) { w4035   (node, 'L');                   }               function p4028(node) { t4036(node);                        } function v4029(node) { m4037(node);                        } function k4030(node) { p4038(node);                        }               function c4031(node) { q4039 (node, 'a', 'b');              } function y4032  (node) { d4040   (node, 'a', 'b');              } function c4033  (node) { p4041   (node, 'u', 'v');              }  function switchToXyz  (node) { switchToXyzControls   (node);                        }       function u4034(node) {     m4043(node,          'R', 0, l4010[0], '', false,          'G', 0, l4010[1],          'B', 0, l4010[2]);                                        showRgbControlHex(node, false);     }    function w4035(node, v_or_l)  {      m4043(node,          'H',    0, q4011[0], '°', true,           'S',    0, q4011[1],          v_or_l, 0, q4011[2]);                                    showRgbControlHex(node, false);  }    function switchToHclControls(node, scale)  {      m4043(node,          'H', 0, scale[0], '°', true,           'C', 0, scale[1],          'L', 0, scale[2]);                                    showRgbControlHex(node, false);  }    function t4036(node) { switchToHclControls(node, o4012); } function m4037(node) { switchToHclControls(node, j4013); } function p4038(node) { switchToHclControls(node, b4014); }    function d4042(node, c2, c3, scale) {      m4043(node,          'L', 0,        scale[0], '', false,           c2, -scale[1], scale[1],          c3, -scale[2], scale[2]);        showRgbControlHex(node, false);  }    function q4039(node) { d4042(node, 'a', 'b', r4015); } function d4040  (node) { d4042(node, 'a', 'b', q4016  ); } function p4041  (node) { d4042(node, 'u', 'v', t4017  ); }    function switchToXyzControls(node)  {      m4043(node,          'X', 0, xyzScale[0], '', false,         'Y', 0, xyzScale[1],          'Z', 0, xyzScale[2]);                                   }    function showRgbControlHex(node, show) {     node.d4048.g4149[0].d3883 = show;     node.g4049.g4149[0].d3883 = show;     node.p4050.g4149[0].d3883 = show; }    function m4043(node, c1, c1min, c1max, c1suffix, c1wrap, c2, c2min, c2max, c3, c3min, c3max) {     z4045(node);      node.d4048.y2865(c1, false);      node.g4049.y2865(c2, false);      node.p4050.y2865(c3, false);                                                                          }    function s4044(node) {     v4047(node);      w1485(node.d4048.div, node.s4051);     w1485(node.g4049.div, node.s4051);     w1485(node.p4050.div, node.s4051);              l1484(node.v4052.div, node.s4051); }    function n4046(node) {     v4047(node);      w1485(node.d4048.div,     node.s4051);     w1485(node.g4049.div,     node.s4051);     w1485(node.p4050.div,     node.s4051);          w1485(node.v4052.div, node.s4051); }    function v4047(node) {     for (let i = node.inputs.length-1; i >= 2; i--)         if (node.inputs[i].connected)             n2508(node.inputs[i]);      for (let i = node.outputs.length-1; i >= 2; i--)         for (const input of node.outputs[i].e4053)             n2508(input); }    function z4045(node) {     w1485(node.v4052.div, node.s4051);      l1484(node.d4048.div, node.s4051);     l1484(node.g4049.div, node.s4051);     l1484(node.p4050.div, node.s4051); }    function e146(rgb, space = 'rgb') {     return [         space,         rgb[0],         rgb[1],         rgb[2] ]; }    function a4055(value, space, j128) {     switch (space)     {         case 'hex':         case 'rgb':         case 'lin':         case 'p3':         case 'a98':         case 'pro':         case 'r2020': return o4056(value, j128);          case 'hsv':         case 'hsl':   return p4057 (value, j128);          case 'hclok':         case 'hclab':         case 'hcluv': return p4059 (value, j128);          case 'oklab':         case 'lab':         case 'luv':   return t4058 (value, j128);          case 'xyz':         case 'xyz50':         case 'xyz65': return getNormalValueXyz (value, j128);     } }    function o4056(value, j128) {     switch (j128)     {         case 0: return value / y4006[0];         case 1: return value / y4006[1];          case 2: return value / y4006[2];     } }    function p4057(value, j128) {     switch (j128)     {         case 0: return value / p4007[0];         case 1: return value / p4007[1];          case 2: return value / p4007[2];     } }    function t4058(value, j128) {     switch (j128)     {         case 0: return value / f4009[0];         case 1: return value / f4009[1];          case 2: return value / f4009[2];     } }    function p4059(value, j128) {     switch (j128)     {         case 0: return value / m4008[0];         case 1: return value / m4008[1];          case 2: return value / m4008[2];     } }    function getNormalValueXyz(value, j128) {     switch (j128)     {         case 0: return value / xyzFactor[0];         case 1: return value / xyzFactor[1];          case 2: return value / xyzFactor[2];     } }    function m4060(color) {     return a4061(         color[0],          color[1],          color[2],          color[3]) }    function a4061(space, c1, c2, c3) {     switch (space)     {         case 'hex':         case 'rgb':         case 'lin':         case 'p3':         case 'a98':         case 'pro':         case 'r2020': return a4062(c1, c2, c3);          case 'hsv':         case 'hsl':   return r4063(c1, c2, c3);          case 'hclok':         case 'hclab':         case 'hcluv': return v4064(c1, c2, c3);          case 'oklab':         case 'lab':         case 'luv':   return j4065(c1, c2, c3);          case 'xyz':         case 'xyz50':         case 'xyz65': return getNormalColorXyz(c1, c2, c3);     } }    function a4062(c1, c2, c3) {     return [         c1 / y4006[0],          c2 / y4006[1],          c3 / y4006[2]]; }    function r4063(c1, c2, c3) {     return [         c1 / p4007[0],          c2 / p4007[1],          c3 / p4007[2]]; }    function v4064(c1, c2, c3) {     return [         c1 / m4008[0],          c2 / m4008[1],          c3 / m4008[2]]; }    function j4065(c1, c2, c3) {     return [         c1 / f4009[0],          c2 / f4009[1],          c3 / f4009[2]]; }    function getNormalColorXyz(c1, c2, c3) {     return [         c1 / xyzFactor[0],          c2 / xyzFactor[1],          c3 / xyzFactor[2]]; }    function r4066(color) {     switch (color[0])     {         case 'hex':         case 'rgb':   return l4067('rgb',    color[1], color[2], color[3]);         case 'lin':   return l4067('lin',    color[1], color[2], color[3]);         case 'p3':    return l4067('p3',     color[1], color[2], color[3]);         case 'a98':   return l4067('a98',    color[1], color[2], color[3]);         case 'pro':   return l4067('pro',    color[1], color[2], color[3]);         case 'r2020':  return l4067('r2020', color[1], color[2], color[3]);          case 'hsv':   return o4068('hsv',    color[1], color[2], color[3]);         case 'hsl':   return o4068('hsl',    color[1], color[2], color[3]);          case 'hclok': return e4069('hclok',  color[1], color[2], color[3]);         case 'hclab': return e4069('hclab',  color[1], color[2], color[3]);         case 'hcluv': return e4069('hcluv',  color[1], color[2], color[3]);          case 'oklab': return y4070('oklab',  color[1], color[2], color[3]);         case 'lab':   return y4070('lab',    color[1], color[2], color[3]);         case 'luv':   return y4070('luv',    color[1], color[2], color[3]);          case 'xyz':   return getScaledDataColorXyz('xyz',    color[1], color[2], color[3]);         case 'xyz50': return getScaledDataColorXyz('xyz50',  color[1], color[2], color[3]);         case 'xyz65': return getScaledDataColorXyz('xyzd60', color[1], color[2], color[3]);     } }    function l4067(space, c1, c2, c3) {     return [         space,         c1 * y4006[0],          c2 * y4006[1],          c3 * y4006[2] ]; }    function o4068(space, c1, c2, c3) {     return [         space,         c1 * p4007[0],          c2 * p4007[1],          c3 * p4007[2] ]; }    function e4069(space, c1, c2, c3) {     return [         space,         c1 * m4008[0],          c2 * m4008[1],          c3 * m4008[2] ]; }    function y4070(space, c1, c2, c3) {     return [         space,         c1 * f4009[0],          c2 * f4009[1],          c3 * f4009[2] ]; }    function getScaledDataColorXyz(space, c1, c2, c3) {     return [         space,         c1 * xyzFactor[0],          c2 * xyzFactor[1],          c3 * xyzFactor[2] ]; }    function j3113(node, color) {     const k3114 = d133(node.n3109.value);     node.m3107   = m4075(color, k3114);      node.d3392(node.m3107); }    function e4071(space) {     switch (space)     {         case 'hex':         case 'rgb':            case 'lin':         case 'p3':         case 'a98':         case 'pro':         case 'r2020': return y4006;          case 'hsv':            case 'hsl':   return p4007;          case 'hclok':          case 'hclab':          case 'hcluv': return m4008;          case 'oklab':          case 'lab':          case 'luv':   return f4009;          case 'xyz':          case 'xyz50':          case 'xyz65': return xyzFactor;     }     }    function d4072(space) {     switch (space)     {         case 'hex':         case 'rgb':            case 'lin':         case 'p3':         case 'a98':         case 'pro':         case 'r2020': return l4010;          case 'hsv':            case 'hsl':   return q4011;          case 'hclok': return o4012;         case 'hclab': return j4013;         case 'hcluv': return b4014;          case 'oklab': return r4015;         case 'lab':   return q4016;         case 'luv':   return t4017;          case 'xyz':         case 'xyz50':         case 'xyz65': return xyzScale;     }     }


function z4073(color) {     return [         color[1],          color[2],          color[3]]; }    function e4074(color) {     const col = z4073(color);      switch (color[0])     {         case 'hex':         case 'rgb':   return           col;          case 'lin':   return lin2rgb  (col);         case 'p3':    return e62   (col);         case 'a98':   return a982rgb  (col);         case 'pro':   return pro2rgb  (col);         case 'r2020': return r20202rgb(col);          case 'hsv':   return g54  (col);         case 'hsl':   return z50  (col);          case 'hclok': return m34(col);         case 'hclab': return b40(col);         case 'hcluv': return c44(col);          case 'oklab': return t3867(col);         case 'lab':   return k56  (col);         case 'luv':   return q3860  (col);          case 'xyz':   return d71  (col);         case 'xyz50': return d71  (col, sRGB_D50);         case 'xyz65': return d71  (col);     } }    function m4075(color, k3114) {     switch (k3114)     {         case 'hex':   return s4076    (color, true);          case 'rgb':   return s4076    (color);          case 'lin':   return convert2lin    (color);         case 'p3':    return convert2p3     (color);         case 'a98':   return convert2a98    (color);         case 'pro':   return convert2pro    (color);         case 'r2020': return convert2r2020  (color);          case 'hsv':   return j4077    (color);         case 'hsl':   return b4078    (color);          case 'hclok': return u4082  (color);         case 'hclab': return j4083  (color);         case 'hcluv': return f4084  (color);          case 'oklab': return i4079(color);         case 'lab':   return r4080    (color);         case 'luv':   return p4081    (color);          case 'xyz':   return convert2xyz    (color);         case 'xyz50': return convert2xyz50  (color);         case 'xyz65': return convert2xyz65  (color);     } }    function s4076(r4085, allowHex = false) {     const col = z4073(r4085);      let rgb;      switch (r4085[0])     {         case 'hex':         case 'rgb':   rgb =           col ; break;          case 'lin':   rgb = lin2rgb  (col); break;         case 'p3':    rgb = e62   (col); break;         case 'a98':   rgb = a982rgb  (col); break;         case 'pro':   rgb = pro2rgb  (col); break;         case 'r2020': rgb = r20202rgb(col); break;          case 'hsv':   rgb = g54  (col); break;         case 'hsl':   rgb = z50  (col); break;          case 'hclok': rgb = m34(col); break;         case 'hclab': rgb = b40(col); break;         case 'hcluv': rgb = c44(col); break;          case 'oklab': rgb = t3867(col); break;         case 'lab':   rgb = k56  (col); break;         case 'luv':   rgb = q3860  (col); break;          case 'xyz':   rgb = d71  (col);           break;         case 'xyz50': rgb = d71  (col, sRGB_D50); break;         case 'xyz65': rgb = d71  (col, sRGB_D65); break;     }       let color = e146(rgb);      if (allowHex)         color[0] = 'hex';       return color; }    function convert2lin(r4085) {     const col = z4073(r4085);      let lin;      switch (r4085[0])     {         case 'hex':         case 'rgb':   lin = rgb2lin          (col) ; break;          case 'lin':   lin =                   col  ; break;         case 'p3':    lin = rgb2lin(e62   (col)); break;         case 'a98':   lin = rgb2lin(a982rgb  (col)); break;         case 'pro':   lin = rgb2lin(pro2rgb  (col)); break;         case 'r2020': lin = rgb2lin(r20202rgb(col)); break;          case 'hsv':   lin = rgb2lin(g54  (col)); break;         case 'hsl':   lin = rgb2lin(z50  (col)); break;          case 'hclok': lin = rgb2lin(m34(col)); break;         case 'hclab': lin = rgb2lin(b40(col)); break;         case 'hcluv': lin = rgb2lin(c44(col)); break;          case 'oklab': lin = rgb2lin(t3867(col)); break;         case 'lab':   lin = rgb2lin(k56  (col)); break;         case 'luv':   lin = rgb2lin(q3860  (col)); break;          case 'xyz':   lin = f72          (col);           break;         case 'xyz50': lin = f72          (col, sRGB_D50); break;         case 'xyz65': lin = f72          (col, sRGB_D65); break;     }      return [        'lin',         lin[0],         lin[1],         lin[2] ]; }    function convert2p3(r4085) {     const col = z4073(r4085);      let p3;      switch (r4085[0])     {         case 'hex':         case 'rgb':   p3 = s61          (col) ; break;          case 'lin':   p3 = s61(lin2rgb  (col)); break;         case 'p3':    p3 =                  col  ; break;         case 'a98':   p3 = s61(a982rgb  (col)); break;         case 'pro':   p3 = s61(pro2rgb  (col)); break;         case 'r2020': p3 = s61(r20202rgb(col)); break;          case 'hsv':   p3 = s61(g54  (col)); break;         case 'hsl':   p3 = s61(z50  (col)); break;          case 'hclok': p3 = s61(m34(col)); break;         case 'hclab': p3 = s61(b40(col)); break;         case 'hcluv': p3 = s61(c44(col)); break;          case 'oklab': p3 = s61(t3867(col)); break;         case 'lab':   p3 = s61(k56  (col)); break;         case 'luv':   p3 = s61(q3860  (col)); break;          case 'xyz':   p3 = s61(d71  (col));           break;         case 'xyz50': p3 = s61(d71  (col, sRGB_D50)); break;         case 'xyz65': p3 = s61(d71  (col, sRGB_D65)); break;     }      return [         'p3',          p3[0],          p3[1],          p3[2] ];  }    function convert2a98(r4085) {     const col = z4073(r4085);      let a98;      switch (r4085[0])     {         case 'hex':         case 'rgb':   a98 = rgb2a98          (col) ; break;          case 'lin':   a98 = rgb2a98(lin2rgb  (col)); break;         case 'p3':    a98 = rgb2a98(e62   (col)); break;         case 'a98':   a98 =                   col  ; break;         case 'pro':   a98 = rgb2a98(pro2rgb  (col)); break;         case 'r2020': a98 = rgb2a98(r20202rgb(col)); break;          case 'hsv':   a98 = rgb2a98(g54  (col)); break;         case 'hsl':   a98 = rgb2a98(z50  (col)); break;          case 'hclok': a98 = rgb2a98(m34(col)); break;         case 'hclab': a98 = rgb2a98(b40(col)); break;         case 'hcluv': a98 = rgb2a98(c44(col)); break;          case 'oklab': a98 = rgb2a98(t3867(col)); break;         case 'lab':   a98 = rgb2a98(k56  (col)); break;         case 'luv':   a98 = rgb2a98(q3860  (col)); break;          case 'xyz':   a98 = rgb2a98(d71  (col));           break;         case 'xyz50': a98 = rgb2a98(d71  (col, sRGB_D50)); break;         case 'xyz65': a98 = rgb2a98(d71  (col, sRGB_D65)); break;     }      return [         'a98',          a98[0],          a98[1],          a98[2] ];  }    function convert2pro(r4085) {     const col = z4073(r4085);      let pro;      switch (r4085[0])     {         case 'hex':         case 'rgb':   pro = rgb2pro          (col) ; break;          case 'lin':   pro = rgb2pro(lin2rgb  (col)); break;         case 'p3':    pro = rgb2pro(e62   (col)); break;         case 'a98':   pro = rgb2pro(a982rgb  (col)); break;         case 'pro':   pro =                   col  ; break;         case 'r2020': pro = rgb2pro(r20202rgb(col)); break;          case 'hsv':   pro = rgb2pro(g54  (col)); break;         case 'hsl':   pro = rgb2pro(z50  (col)); break;          case 'hclok': pro = rgb2pro(m34(col)); break;         case 'hclab': pro = rgb2pro(b40(col)); break;         case 'hcluv': pro = rgb2pro(c44(col)); break;          case 'oklab': pro = rgb2pro(t3867(col)); break;         case 'lab':   pro = rgb2pro(k56  (col)); break;         case 'luv':   pro = rgb2pro(q3860  (col)); break;          case 'xyz':   pro = rgb2pro(d71  (col));           break;         case 'xyz50': pro = rgb2pro(d71  (col, sRGB_D50)); break;         case 'xyz65': pro = rgb2pro(d71  (col, sRGB_D65)); break;     }      return [         'pro',          pro[0],          pro[1],          pro[2] ]; }    function convert2r2020(r4085) {     const col = z4073(r4085);      let r2020;      switch (r4085[0])     {         case 'hex':         case 'rgb':   r2020 = rgb2r2020          (col) ; break;          case 'lin':   r2020 = rgb2r2020(lin2rgb  (col)); break;         case 'p3':    r2020 = rgb2r2020(e62   (col)); break;         case 'a98':   r2020 = rgb2r2020(a982rgb  (col)); break;         case 'pro':   r2020 = rgb2r2020(pro2rgb  (col)); break;         case 'r2020': r2020 =                     col  ; break;          case 'hsv':   r2020 = rgb2r2020(g54  (col)); break;         case 'hsl':   r2020 = rgb2r2020(z50  (col)); break;          case 'hclok': r2020 = rgb2r2020(m34(col)); break;         case 'hclab': r2020 = rgb2r2020(b40(col)); break;         case 'hcluv': r2020 = rgb2r2020(c44(col)); break;          case 'oklab': r2020 = rgb2r2020(t3867(col)); break;         case 'lab':   r2020 = rgb2r2020(k56  (col)); break;         case 'luv':   r2020 = rgb2r2020(q3860  (col)); break;          case 'xyz':   r2020 = rgb2r2020(d71  (col));           break;         case 'xyz50': r2020 = rgb2r2020(d71  (col, sRGB_D50)); break;         case 'xyz65': r2020 = rgb2r2020(d71  (col, sRGB_D65)); break;     }      return [         'r2020',          r2020[0],          r2020[1],          r2020[2] ]; }    function j4077(r4085) {     const col = z4073(r4085);          let hsv;          switch (r4085[0])     {         case 'hex':         case 'rgb':   hsv = j52(          col ); break;          case 'lin':   hsv = j52(lin2rgb  (col)); break;                  col  ; break;         case 'p3':    hsv = j52(e62   (col)); break;         case 'a98':   hsv = j52(a982rgb  (col)); break;         case 'pro':   hsv = j52(pro2rgb  (col)); break;         case 'r2020': hsv = j52(r20202rgb(col)); break;          case 'hsv':   hsv =                   col;   break;         case 'hsl':   hsv = j52(z50  (col)); break;          case 'hclok': hsv = j52(m34(col)); break;         case 'hclab': hsv = j52(b40(col)); break;         case 'hcluv': hsv = j52(c44(col)); break;          case 'oklab': hsv = j52(t3867(col)); break;         case 'lab':   hsv = j52(k56  (col)); break;         case 'luv':   hsv = j52(q3860  (col)); break;          case 'xyz':   hsv = j52(d71  (col));           break;         case 'xyz50': hsv = j52(d71  (col, sRGB_D50)); break;         case 'xyz65': hsv = j52(d71  (col, sRGB_D65)); break;     }          if (isNaN(hsv[0]))         hsv[0] = 5/6;          return [        'hsv',         hsv[0],         hsv[1],         hsv[2] ]; }    function b4078(r4085) {     const col = z4073(r4085);      let hsl;      switch (r4085[0])     {         case 'hex':         case 'rgb':   hsl = m48(          col ); break;          case 'lin':   hsl = m48(lin2rgb  (col)); break;                  col  ; break;         case 'p3':    hsl = m48(e62   (col)); break;         case 'a98':   hsl = m48(a982rgb  (col)); break;         case 'pro':   hsl = m48(pro2rgb  (col)); break;         case 'r2020': hsl = m48(r20202rgb(col)); break;          case 'hsv':   hsl = m48(g54  (col)); break;         case 'hsl':   hsl =                   col;   break;          case 'hclok': hsl = m48(m34(col)); break;         case 'hclab': hsl = m48(b40(col)); break;         case 'hcluv': hsl = m48(c44(col)); break;          case 'oklab': hsl = m48(t3867(col)); break;         case 'lab':   hsl = m48(k56  (col)); break;         case 'luv':   hsl = m48(q3860  (col)); break;          case 'xyz':   hsl = m48(d71  (col));           break;         case 'xyz50': hsl = m48(d71  (col, sRGB_D50)); break;         case 'xyz65': hsl = m48(d71  (col, sRGB_D65)); break;     }      return [        'hsl',         hsl[0],         hsl[1],         hsl[2] ]; }    function i4079(r4085) {     const col = z4073(r4085);      let lab;      switch (r4085[0])     {         case 'hex':         case 'rgb':   lab = g3863(          col ); break;          case 'lin':   lab = g3863(lin2rgb  (col)); break;                  col  ; break;         case 'p3':    lab = g3863(e62   (col)); break;         case 'a98':   lab = g3863(a982rgb  (col)); break;         case 'pro':   lab = g3863(pro2rgb  (col)); break;         case 'r2020': lab = g3863(r20202rgb(col)); break;          case 'hsv':   lab = g3863(g54  (col)); break;         case 'hsl':   lab = g3863(z50  (col)); break;          case 'hclok': lab = g3863(m34(col)); break;         case 'hclab': lab = g3863(b40(col)); break;         case 'hcluv': lab = g3863(c44(col)); break;          case 'oklab': lab =                     col;   break;         case 'lab':   lab = g3863(k56  (col)); break;         case 'luv':   lab = g3863(q3860  (col)); break;          case 'xyz':   lab = g3863(d71  (col));           break;         case 'xyz50': lab = g3863(d71  (col, sRGB_D50)); break;         case 'xyz65': lab = g3863(d71  (col, sRGB_D65)); break;     }      return [        'oklab',         lab[0],         lab[1],         lab[2] ]; }    function r4080(r4085) {     const col = z4073(r4085);      let lab;      switch (r4085[0])     {         case 'hex':         case 'rgb':   lab = b55(          col ); break;          case 'lin':   lab = b55(lin2rgb  (col)); break;                  col  ; break;         case 'p3':    lab = b55(e62   (col)); break;         case 'a98':   lab = b55(a982rgb  (col)); break;         case 'pro':   lab = b55(pro2rgb  (col)); break;         case 'r2020': lab = b55(r20202rgb(col)); break;         case 'hsv':   lab = b55(g54  (col)); break;          case 'hsl':   lab = b55(z50  (col)); break;          case 'hclok': lab = b55(m34(col)); break;         case 'hclab': lab =         x39(col);  break;         case 'hcluv': lab = b55(c44(col)); break;          case 'oklab': lab = b55(t3867(col)); break;         case 'lab':   lab =                   col;   break;         case 'luv':   lab = b55(q3860  (col)); break;          case 'xyz':   lab = i57          (col, h36.W);     break;         case 'xyz50': lab = i57          (col, sRGB_D50.W); break;         case 'xyz65': lab = i57          (col, sRGB_D65.W); break;     }      return [        'lab',         lab[0],         lab[1],         lab[2] ]; }    function p4081(r4085) {     const col = z4073(r4085);      let luv;      switch (r4085[0])     {         case 'hex':         case 'rgb':   luv = v3859(          col ); break;          case 'lin':   luv = v3859(lin2rgb  (col)); break;                  col  ; break;         case 'p3':    luv = v3859(e62   (col)); break;         case 'a98':   luv = v3859(a982rgb  (col)); break;         case 'pro':   luv = v3859(pro2rgb  (col)); break;         case 'r2020': luv = v3859(r20202rgb(col)); break;          case 'hsv':   luv = v3859(g54  (col)); break;         case 'hsl':   luv = v3859(z50  (col)); break;          case 'hclok': luv = v3859(m34(col)); break;         case 'hclab': luv = v3859(b40(col)); break;         case 'hcluv': luv =         d43(col);  break;          case 'oklab': luv = v3859(t3867(col)); break;         case 'lab':   luv = v3859(k56  (col)); break;         case 'luv':   luv =                   col;   break;          case 'xyz':   luv = x3861          (col, h36.W);     break;         case 'xyz50': luv = x3861          (col, sRGB_D50.W); break;         case 'xyz65': luv = x3861          (col, sRGB_D65.W); break;     }      return [        'luv',         luv[0],         luv[1],         luv[2] ]; }    function u4082(r4085) {     const col = z4073(r4085);      let hcl;      switch (r4085[0])     {         case 'hex':         case 'rgb':   hcl = o37(          col);  break;          case 'lin':   hcl = o37(lin2rgb  (col)); break;                  col  ; break;         case 'p3':    hcl = o37(e62   (col)); break;         case 'a98':   hcl = o37(a982rgb  (col)); break;         case 'pro':   hcl = o37(pro2rgb  (col)); break;         case 'r2020': hcl = o37(r20202rgb(col)); break;          case 'hsv':   hcl = o37(g54  (col)); break;         case 'hsl':   hcl = o37(z50  (col)); break;          case 'hclok': hcl =                     col;   break;         case 'hclab': hcl = o37(b40(col)); break;         case 'hcluv': hcl = o37(c44(col)); break;          case 'oklab': hcl = o37(t3867(col)); break;         case 'lab':   hcl = o37(k56  (col)); break;         case 'luv':   hcl = o37(q3860  (col)); break;          case 'xyz':   hcl = o37(d71  (col));           break;         case 'xyz50': hcl = o37(d71  (col, sRGB_D50)); break;         case 'xyz65': hcl = o37(d71  (col, sRGB_D65)); break;     }      return [        'hclok',         hcl[0],         hcl[1],         hcl[2] ]; }    function j4083(r4085) {     const col = z4073(r4085);      let lab;      switch (r4085[0])     {         case 'hex':         case 'rgb':   lab = f42(          col) ; break;                  case 'lin':   lab = f42(lin2rgb  (col)); break;                  col  ; break;         case 'p3':    lab = f42(e62   (col)); break;         case 'a98':   lab = f42(a982rgb  (col)); break;         case 'pro':   lab = f42(pro2rgb  (col)); break;         case 'r2020': lab = f42(r20202rgb(col)); break;          case 'hsv':   lab = f42(g54  (col)); break;         case 'hsl':   lab = f42(z50  (col)); break;                  case 'hclok': lab = f42(m34(col)); break;         case 'hclab': lab =                     col;   break;         case 'hcluv': lab = f42(c44(col)); break;                  case 'oklab': lab = f42(t3867(col)); break;         case 'lab':   lab = z41(          col ); break;         case 'luv':   lab = f42(q3860  (col)); break;          case 'xyz':   lab = f42(d71  (col));           break;         case 'xyz50': lab = f42(d71  (col, sRGB_D50)); break;         case 'xyz65': lab = f42(d71  (col, sRGB_D65)); break;     }      return [        'hclab',         lab[0],         lab[1],         lab[2] ]; }    function f4084(r4085) {     const col = z4073(r4085);      let hcl;      switch (r4085[0])     {         case 'hex':         case 'rgb':   hcl = q46(          col ); break;          case 'lin':   hcl = q46(lin2rgb  (col)); break;                  col  ; break;         case 'p3':    hcl = q46(e62   (col)); break;         case 'a98':   hcl = q46(a982rgb  (col)); break;         case 'pro':   hcl = q46(pro2rgb  (col)); break;         case 'r2020': hcl = q46(r20202rgb(col)); break;          case 'hsv':   hcl = q46(g54  (col)); break;         case 'hsl':   hcl = q46(z50  (col)); break;          case 'hclab': hcl = q46(b40(col)); break;         case 'hcluv': hcl =                     col;   break;         case 'hclok': hcl = q46(m34(col)); break;          case 'oklab': hcl = q46(t3867(col)); break;         case 'lab':   hcl = q46(k56  (col)); break;         case 'luv':   hcl = f45(          col ); break;          case 'xyz':   hcl = q46(d71  (col));           break;         case 'xyz50': hcl = q46(d71  (col, sRGB_D50)); break;         case 'xyz65': hcl = q46(d71  (col, sRGB_D65)); break;     }      return [        'hcluv',         hcl[0],         hcl[1],         hcl[2] ]; }    function convert2xyz(r4085) {     const col = z4073(r4085);      let xyz;      switch (r4085[0])     {         case 'hex':         case 'rgb':   xyz = n69(          col ); break;          case 'lin':   xyz = n69(lin2rgb  (col)); break;                  col  ; break;         case 'p3':    xyz = n69(e62   (col)); break;         case 'a98':   xyz = n69(a982rgb  (col)); break;         case 'pro':   xyz = n69(pro2rgb  (col)); break;         case 'r2020': xyz = n69(r20202rgb(col)); break;          case 'hsv':   xyz = n69(g54  (col)); break;         case 'hsl':   xyz = n69(z50  (col)); break;          case 'hclab': xyz = n69(b40(col)); break;         case 'hcluv': xyz = n69(b40(col)); break;         case 'hclok': xyz = n69(m34(col)); break;          case 'oklab': xyz = n69(t3867(col)); break;         case 'lab':   xyz = z58(          col, h36.W); break;         case 'luv':   xyz = s3862(          col, h36.W); break;          case 'xyz':   xyz =                   col;             break;         case 'xyz50': xyz = n69(d71  (col, sRGB_D50)); break;         case 'xyz65': xyz = n69(d71  (col, sRGB_D65)); break;     }      return [        'xyz',         xyz[0],         xyz[1],         xyz[2] ]; }    function convert2xyz50(r4085) {     const col = z4073(r4085);      let xyz;      switch (r4085[0])     {         case 'hex':         case 'rgb':   xyz = n69(          col,  sRGB_D50);    break;          case 'lin':   xyz = n69(lin2rgb  (col), sRGB_D50);   break;                  col  ; break;         case 'p3':    xyz = n69(e62   (col), sRGB_D50);   break;         case 'a98':   xyz = n69(a982rgb  (col), sRGB_D50);   break;         case 'pro':   xyz = n69(pro2rgb  (col), sRGB_D50);   break;         case 'r2020': xyz = n69(r20202rgb(col), sRGB_D50);   break;          case 'hsv':   xyz = n69(g54  (col), sRGB_D50);   break;         case 'hsl':   xyz = n69(z50  (col), sRGB_D50);   break;          case 'hclab': xyz = n69(b40(col), sRGB_D50);   break;         case 'hcluv': xyz = n69(b40(col), sRGB_D50);   break;         case 'hclok': xyz = n69(m34(col), sRGB_D50);   break;          case 'oklab': xyz = n69(t3867(col), sRGB_D50);   break;         case 'lab':   xyz = z58(          col,  sRGB_D50.W); break;         case 'luv':   xyz = s3862(          col,  sRGB_D50.W); break;          case 'xyz':   xyz = n69(d71  (col), sRGB_D50);   break;         case 'xyz50': xyz =                   col;               break;         case 'xyz65': xyz = n69(d71  (col), sRGB_D50);   break;     }      return [        'xyz50',         xyz[0],         xyz[1],         xyz[2] ]; }    function convert2xyz65(r4085) {     const col = z4073(r4085);      let xyz;      switch (r4085[0])     {         case 'hex':         case 'rgb':   xyz = n69(          col,  sRGB_D65);    break;          case 'lin':   xyz = n69(lin2rgb  (col), sRGB_D65);   break;                  col  ; break;         case 'p3':    xyz = n69(e62   (col), sRGB_D65);   break;         case 'a98':   xyz = n69(a982rgb  (col), sRGB_D65);   break;         case 'pro':   xyz = n69(pro2rgb  (col), sRGB_D65);   break;         case 'r2020': xyz = n69(r20202rgb(col), sRGB_D65);   break;          case 'hsv':   xyz = n69(g54  (col), sRGB_D65);   break;         case 'hsl':   xyz = n69(z50  (col), sRGB_D65);   break;          case 'hclab': xyz = n69(b40(col), sRGB_D65);   break;         case 'hcluv': xyz = n69(b40(col), sRGB_D65);   break;         case 'hclok': xyz = n69(m34(col), sRGB_D65);   break;          case 'oklab': xyz = n69(t3867(col), sRGB_D65);   break;         case 'lab':   xyz = z58(          col,  sRGB_D65.W); break;         case 'luv':   xyz = s3862(          col,  sRGB_D65.W); break;          case 'xyz':   xyz = n69(d71  (col), sRGB_D65);   break;         case 'xyz50': xyz = n69(d71  (col, sRGB_D50), sRGB_D65);   break;         case 'xyz65': xyz =                   col;               break;     }      return [        'xyz65',         xyz[0],         xyz[1],         xyz[2] ]; }


</script>