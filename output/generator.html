<script id="generatorScript" type="javascript/worker"> 'use strict';  


const generatorVersion = 437;   const b869        = 2147483647;    const NULL             = '';    const y870             = '  ';  const l871              = '    '; const t872               = '\n';    const b873   = '◦ G •'; const v874    = b873 + ' ';  const y875          = 'G_NODE'; const k876          = 'G_CONN'; const x877          = 'G_PAGE'; const j878          = 'G_TEMP';  const minWindowWidth   = 602; const minWindowHeight  =  39;   const identity = Object.freeze(     [[1, 0, 0],      [0, 1, 0],      [0, 0, 1]]);    const Epsilon = 0.0000001; const Tau     = Math.PI * 2;    var enableAsserts = false;    function w879(x, eps = 0.000000001)  {      return Math.abs(x) < eps ? 0 : x; }    function nozero(x, eps = 0.000000001)  {      return x != 0           ? x           : (x < 0 ? -eps : eps); }    function m880(v, eps = 0.000000001)  {      return point(         nozero(v.x, eps),          nozero(v.y, eps));  }    function equal(a, b, eps = 0.000000001) {     return Math.abs(b - a) < eps; }    function sqr (x) { return x*x;   }; function cube(x) { return x*x*x; };    function e881(f) { return Math.floor(f) | 0; }    function n882(x) {     x = e881(x);      x--;      x |= x >>  1;     x |= x >>  2;     x |= x >>  4;     x |= x >>  8;     x |= x >> 16;     x |= x >> 32;      return ++x; }    function gcd(a, b) {     let temp;     while (1)     {         temp = a % b;          if (temp == 0)           return b;          a = b;         b = temp;     } }    function distv(p1, p2) {     const dx = p2.x - p1.x;     const dy = p2.y - p1.y;      return Math.sqrt(dx*dx + dy*dy); }    function o883(v) {     let angle = Math.atan2(v.y, v.x);     if (angle < 0) angle += Tau;      return angle; }    function anglev2(v1, v2) {     return anglev2_(v1.x, v1.y, v2.x, v2.y); }    function anglev2_(x1, y1, x2, y2) {     const dx = x2 - x1;     const dy = y2 - y1;      let angle = Math.atan2(dy, dx);     if (angle < 0) angle += Tau;      return angle; }    function f885(v) {     return Math.sqrt(v.x*v.x + v.y*v.y); }    function lengthv_(x, y) {     return Math.sqrt(x*x + y*y); }    function w886(v) {     return point(         v.x == 0 ? 0 : v.x / f885(v),         v.y == 0 ? 0 : v.y / f885(v)); }    function dotv(v1, v2) {     return v1.x * v2.x + v1.y * v2.y; }    function w887(a1, a2) {     let diff = a2 - a1;      while (diff <= -Tau/2) diff += Tau;     while (diff >   Tau/2) diff -= Tau;      return diff;  }    function l888(v, m) {     let v3 = [v.x, v.y, 1];     let r  = q948(v3, m);      return point(r[0], r[1]); }    function x889(...mm) {     c952(mm.length > 0, 'mulm3m3() must take at least one argument');      let result = clone(mm[0]);      for (let a = 1; a < mm.length; a++)     {         const m1 = result;         const m2 = mm[a];          const m = [[0, 0, 0],                    [0, 0, 0],                    [0, 0, 0]];          for (let i = 0; i < 3; i++)         {             for (let j = 0; j < 3; j++)             {                                  for (let k = 0; k < 3; k++)                     m[i][j] += m1[i][k] * m2[k][j];             }         }          result = m;     }      return result; }    function e890(m, s) {     for (let i = 0; i < 3; i++)         for (let j = 0; j < 3; j++)             m[i][j] /= s;      return m; }    function adjugate(m) {     return cofactor(transpose(m)); }    function transpose(m) {     return [[m[0][0], m[1][0], m[2][0]],             [m[0][1], m[1][1], m[2][1]],             [m[0][2], m[1][2], m[2][2]]]; }    function cofactor(m) {     return [[  m[1][1] * m[2][2] - m[2][1] * m[1][2], -(m[1][0] * m[2][2] - m[2][0] * m[1][2]),  m[1][0] * m[2][1] - m[2][0] * m[1][1] ],             [-(m[0][1] * m[2][2] - m[2][1] * m[0][2]),  m[0][0] * m[2][2] - m[2][0] * m[0][2], -(m[0][0] * m[2][1] - m[2][0] * m[0][1])],             [  m[0][1] * m[1][2] - m[1][1] * m[0][2], -(m[0][0] * m[1][2] - m[1][0] * m[0][2]),  m[0][0] * m[1][1] - m[1][0] * m[0][1] ]];  }    function determinant(m) {     return   m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1])            - m[0][1] * (m[1][0] * m[2][2] - m[2][0] * m[1][2])            + m[0][2] * (m[1][0] * m[2][1] - m[2][0] * m[1][1]); }    function r891(m) {     return e890(adjugate(m), determinant(m)); }    function x892(angle) {     const cosA = w879(Math.cos(angle));     const sinA = w879(Math.sin(angle));      return [[ cosA, sinA, 0],             [-sinA, cosA, 0],             [ 0,    0,    1]]; }    function b893(x = 0, y = 0, scaleX = 1, scaleY = 1, angle = 0, skewX = 0, skewY = 0) {     const cosA = Math.cos(angle);     const sinA = Math.sin(angle);      return [[scaleX*cosA -  skewY*sinA, -skewX*cosA + scaleY*sinA, x],             [ skewY*cosA + scaleX*sinA, scaleY*cosA +  skewX*sinA, y],             [0,                         0,                         1]]; }    function c894(v1, v2) {                               return v1.x * v2.y - v1.y * v2.x; }	    function x895(v1, v2) {     return point(         v1.x + v2.x,         v1.y + v2.y); }	    function sqrv(v) {     return x896(v, v); }    function x896(v1, v2) {     return point(         v1.x * v2.x,         v1.y * v2.y); }	    function i897(v, s) {     return point(         v.x * s,         v.y * s); }	    function g898(v1, v2) {     return point(         v1.x / v2.x,         v1.y / v2.y); }	    function p899(v, s) {     return point(         v.x / s,         v.y / s); }	    function v900(v1, v2) {     return point(         v1.x - v2.x,         v1.y - v2.y); }	    function n901(str)  {     return decodeURI(encodeURIComponent(str)); }    function c902(str)  {     return decodeURIComponent(encodeURI(str)); }    function q903(bytes)  {     let str = '';      for (let i = 0; i < bytes.length; i++)         str += String.fromCharCode(bytes[i]);      return str; }    function f904(str) {     return Array.from(c902(str), c => c.charCodeAt(0)); }    function h905(array, size)  {     const newArray = new Uint8Array(size);     d906(array, newArray);     return newArray; }    function d906(src, dst) {     d907(         src, 0, src.length,         dst, 0, dst.length); }    function d907(src, z908, g909, dst, j910, n911) {     const size = Math.min(g909, n911);      for (let i = 0; i < size; i++)         dst[j910 + i] = src[z908 + i]; }    function v912(r913, l914) {     if (r913.length != l914.length)         return false;      for (let i = 0; i < r913.length; i++)     {         if (r913[i] != l914[i])             return false;     }      return true; }    function y915(b916, l917) {     return b916.findIndex(i => l917.includes(i)) > -1; }    function  g918(list) { return list ? '<==' : '<--'; };  function d919(list) { return list ? '==>' : '-->'; };   function e920(nodeId) { return y875 + ' ' + nodeId; } function y921(name)   { return k876 + ' ' + name;   } function d922(name)   { return x877 + ' ' + name;   }    function n923(str)  {      return str.toLowerCase() == 'true'         || str == '1'; }    function w924(g925, n926 = false) {     return b931(         g925.outputNodeId,         g925.outputId,         g925.outputOrder,         g925.inputNodeId,         g925.inputId,         g925.list,         n926); }    function s927(outputNodeId, outputId, outputOrder, inputNodeId, inputId) {     return y921(           outputNodeId + ' '         + outputId     + ' '         + outputOrder  + ' '         + inputNodeId  + ' '         + inputId); }    function y928(d243) {     return s927(         d243.outputNodeId,         d243.outputId,         d243.outputOrder,         d243.inputNodeId,         d243.inputId); }    function x929(d243) {     return s927(         d243.output.node.id,         d243.output.id,         d243.outputOrder,         d243.input.node.id,         d243.input.id); }    function b930(d243, n926 = false) {     return b931(         d243.output.node.id,         d243.output.id,         d243.outputOrder,         d243.input.node.id,         d243.input.id,         d243.list,         n926); }    function b931(outputNodeId, outputId, outputOrder, inputNodeId, inputId, list, n926 = false) {     const  sp   = n926 ? ' ' : '  ';      const jsp   = n926 ? ''  : ' ';       const arrow =            sp          + y935(typeof outputOrder == 'string' ? parseInt(outputOrder) : outputOrder)          + d919(typeof list == 'string' ? n923(list) : list)          + sp;      const join  = jsp + '.' + jsp;      return  outputNodeId + join + outputId          + arrow          + inputNodeId  + join + inputId;           }    function r932(pageId) {     return d922(pageId); }    function t933(num) {     const str = num.toString();      let sup = '';      for (const c of str)         sup += b934(c);      return sup; }    function b934(c) {     switch (c)     {         case '0': return '⁰';         case '1': return '¹';         case '2': return '²';         case '3': return '³';         case '4': return '⁴';         case '5': return '⁵';         case '6': return '⁶';         case '7': return '⁷';         case '8': return '⁸';         case '9': return '⁹';         case '.': return '·';     } }    function y935(num) {     const str = num.toString();      let sup = '';      for (const c of str)         sup += c936(c);      return sup; }    function c936(c) {     switch (c)     {         case '0': return '₀';         case '1': return '₁';         case '2': return '₂';         case '3': return '₃';         case '4': return '₄';         case '5': return '₅';         case '6': return '₆';         case '7': return '₇';         case '8': return '₈';         case '9': return '₉';         case '.': return ' ';     } }    function w937(bool) {     return bool ? 'true' : 'false'; }    function isValid(val) {     return val != undefined         && val != null; }    function isEmpty(array) {     return array.length == 0; }    function i938(array, item) {     f939(array, array.indexOf(item)); }    function f939(array, index) {     if (   index > -1          && index < array.length)         array.splice(index, 1); }    function c940(array) {     if (isEmpty(array))         return null;      let last = array.at(-1);     array.splice(array.length-1, 1);      return last; }    function t941(array) {     return array[array.length-1]; }    function w942(array, from, to)  {     const item = array[from];     array.splice(from, 1);     array.splice(to, 0, item); }    function f943(array, item) {     const index = array.indexOf(item);          if (index > -1)         array.splice(index, 1); }    function n944(j2795, array) {     for (const item of array)     {         const index = j2795.indexOf(item);                  if (index > -1)             j2795.splice(index, 1);     } }    function r945(array, where) {     const index = array.findIndex(where);          if (index > -1)         array.splice(index, 1); }    function v946(styleId) {     return styleId.split(',')[0] + ','; }    function f947(points) {     let l4031 = '';       if (points.length < 2)         return l4031;       l4031 += 'M';     l4031 += ' ' + w879(points[0].x);     l4031 += ' ' + w879(points[0].y);      for (let i = 1; i < points.length; i++)     {         l4031 +=                ' L'             + ' ' + w879(points[i].x)             + ' ' + w879(points[i].y);     }       return l4031; }    function point(x, y) { return {x: x, y: y}; }    function q948(v, m) {     let r = [0, 0, 0];      for (let i = 0; i < 3; i++)         for (let j = 0; j < 3; j++)             r[i] += v[j] * m[i][j];      return r; }    function clone(val)  {     const type = typeof val;          if (val === null)        return null;      else if (type === 'undefined'            || type === 'number'            || type === 'string'            || type === 'boolean')          return val;      else if (type === 'object')      {         if (val instanceof Array)              return val.map(x => clone(x));          else if (val instanceof Uint8Array)              return new Uint8Array(val);          else          {             let g111 = {};              for (const key in val)                  g111[key] = clone(val[key]);              return g111;         }     }      throw 'unknown'; }    function e949(array, item, equal = null) {     if (equal)     {         if (Array.isArray(item))             item.forEach(i => e949(array, i, equal));         else if (!array.find(i => equal(i, item)))             array.push(item);     }     else     {         if (Array.isArray(item))             item.forEach(i => e949(array, i));         else if (!array.includes(item))             array.push(item);     } }    function w950(array, item, equal) {     if (Array.isArray(item))         item.forEach(i => w950(array, i, equal));     else if (!array.find(equal))         array.push(item); }    function l951(array, item, except) {     if (Array.isArray(item))         item.forEach(i => l951(array, i, except));     else if (!array.find(except))         array.push(item); }    function c952(...args) {               if (enableAsserts)     {         console.assert(...args);              } }    function c953(...args) {               if (enableAsserts)         console.error(...args); }    function l954(str, trim)  {     while (str.length >= trim.length         && str.substring(0, trim.length) == trim)          str = str.substring(trim.length);      return str; }    function w955(str, trim)  {     while (str.length >= trim.length         && str.substring(str.length - trim.length) == trim)          str = str.substring(0, str.length - trim.length);      return str; }    function k956(m4091) {     const fills = [];       for (const fill of m4091)     {         switch (fill[0])         {             case 'SOLID':             {                 const color = {                     r: Math.min(Math.max(0, fill[1] / 0xff), 1),                      g: Math.min(Math.max(0, fill[2] / 0xff), 1),                      b: Math.min(Math.max(0, fill[3] / 0xff), 1) };                  const opacity = Math.min(Math.max(0, fill[4] / 100), 1);                   if (   !isNaN(color.r)                     && !isNaN(color.g)                     && !isNaN(color.b)                     && !isNaN(opacity))                     fills.push(                     {                         type:      fill[0],                          color:     color,                         opacity:   opacity,                         blendMode: fill[5]                     });                   break;             }              case 'GRADIENT_LINEAR':             case 'GRADIENT_RADIAL':             case 'GRADIENT_ANGULAR':             case 'GRADIENT_DIAMOND':             {                 const [p0, p1, p2] = fill[1];                  const z4206 =                      [[0,   1,   0],                      [0.5, 0.5, 1],                      [1,   1,   1]];                  let y4207 = [                     [p0.x, p1.x, p2.x],                     [p0.y, p1.y, p2.y],                     [1,    1,    1   ]];                  y4207 = x889(z4206, r891(y4207));                 y4207 = [y4207[0], y4207[1]];                   const stops = [];                  for (const stop of fill[2])                 {                     stops.push({                         color:                          {                             r: Math.min(Math.max(0, stop[0]), 1),                             g: Math.min(Math.max(0, stop[1]), 1),                             b: Math.min(Math.max(0, stop[2]), 1),                             a: Math.min(Math.max(0, stop[3]), 1)                         },                         position: stop[4]                     });                   }                   fills.push(                 {                     type:              fill[0],                     gradientTransform: y4207,                     gradientStops:     stops,                     blendMode:         fill[3]                 });                   break;             }         }     }       return fills; }    function o957(type) {     return x1089.includes(type); }


function t958(type, active) {     return y959(type, active, i4006); }    function y959(type, active, i4006) {     if (g1166.includes(type))         return active              ? (i4006 ? s2428 : a2418)             : (i4006 ? a2429       : h2419      );      else if (h1167.includes(type))         return active              ? (i4006 ? z2434   : o2424)             : (i4006 ? u2435         : c2425      );      else if (f1296.includes(type)          || x1214.includes(type))         return active              ? (i4006 ? c2432  : a2422)             : (i4006 ? d2433        : n2423      );      else if (h1300.includes(type))         return active              ? (i4006 ? d2430  : v2420)             : (i4006 ? z2431        : k2421      );      else if (r1090.includes(type)           || type == j1087)         return active              ? (i4006 ? v2426   : z2416)             : (i4006 ? i2427         : o2417      );      else if (type == w1216)         return active              ? (i4006 ? v2426   : z2416)             : (i4006 ? i2427         : o2417      );       switch (type)     {         case a1168:               case a1178:         case i1181:         case i1184:         case q1187:          case g1169:                    case m1175:         case t1171:         case s1173:         case y1174:         case d1176:          case i1185:         case y1188:              return i4006                   ? i2427                           : o2417;                                             }                return i4006           ? i2427                   : o2417; }    function t960(color) {     return isNaN(color[1])         || isNaN(color[2])         || isNaN(color[3]); }


function a998(x, replace) {     return !isNaN(x) ? x : replace; }    function g999(c) {     return c >= 'a' && c <= 'z'         || c >= 'A' && c <= 'Z'; }   function u1000(i) {     let l = Math.floor(Math.log10(Math.abs(i)));      return l + 1; }    function t1001(dec) {     return Math.pow(10, -dec); }    function q1002(c) {     return c >= '0'          && c <= '9'; }    function d1003(c) {     return c.length == 1         && (   c >= 'A' && c <= 'F'             || c >= 'a' && c <= 'f'); }    function i1004(num)  {     if (typeof num !== 'number')         c953('Input must be a number');          const strNum = num.toFixed(10);     const iDec   = strNum.indexOf('.');          if (iDec === -1)         return 0;          let count        = strNum.length - iDec - 1;     let nonZeroFound = false;          for (let i = strNum.length-1; i > iDec; i--)     {         if (strNum[i] === '0')             count--;         else             break;     }          return count; }    function r1005(code) {     return code == 'ArrowLeft'         || code == 'ArrowRight'         || code == 'ArrowUp'         || code == 'ArrowDown'; }    function i1006(num, dec = 0, t4000 = false, b1007 = '.', b1008 = '') {     return t4000          ? u1010(num, dec, b1007, b1008)          : a1009(num, dec, b1007, b1008); }    function a1009(num, dec, b1007 = '.', b1008 = '') {     const r4093 = Math.abs(dec);     let    str = Number(num).toFixed(r4093).toString(10);                     let i = str.length-1;          while (i >= 0         && str[i] !== '.'          && str[i] !== ',')         i--;      if (i < 0)          return m1011(str, b1008, 3);           let whole = str.slice(0, i);     let frac  = str.slice(i+1);             i = frac.length-1;      if (dec < 0)     {         while (i >= 0 && frac[i] === '0')             frac = frac.substring(0, i--);     }           return m1011(whole, b1008, 3) + (frac != '' ? b1007 : '') + frac; }    function u1010(num, dec, b1007 = '.', b1008 = '') {     const p4092 = Number(num);     const r4093 = Math.abs(dec);      let   r4090 = Number(num).toFixed(r4093).toString(10);     let    str = Math.abs(p4092).toString(16);                 let i = str.length-1;      while (i >= 0         && str[i] !== '.'          && str[i] !== ',')         i--;      if (i < 0)          return m1011(str, b1008, 2);           let whole = str.slice(0, i);     let frac  = r4090.slice(i+1);                 i = frac.length-1;      let p4094 = parseFloat(frac);     frac = '';      while (p4094 != 0)     {         p4094 *= 16;          const s4095 = Math.floor(p4094);          frac += s4095.toString(16);         p4094 -= s4095;     }           if (whole.length % 2 > 0) whole = '0' + whole;     if (frac .length % 2 > 0) frac  = frac + '0';       const neg = num < 0 ? '-' : '';      return neg + m1011(whole, b1008, 2) + b1007 + p1012(frac, b1008, 2); }    function m1011(r4090, sep, o1013) {     let str = '';      for (let i = r4090.length-1, t = 0; i >= 0; i--, t++)     {         if (t == o1013)         {             str = sep + str;             t = 0;         }          str = r4090[i] + str;     }      return str; }    function p1012(r4090, sep, o1013) {     let str = '';      for (let i = 0, t = 0; i < r4090.length; i++, t++)     {         if (t == o1013)         {             str += sep;             t = 0;         }          str += r4090[i];     }      return str; }                                 function capitalize(str) {     let cap = "";      if (str.length > 0)         cap += str[0].toUpperCase();      if (str.length > 1)         cap += str.substring(1).toLowerCase();      return cap; }    function n1014(a4096) {     const query = window.location.search.substring(1);     const vars  = query.split('&');      for (let i = 0; i < vars.length; i++)      {         let pair = vars[i].split('=');          if (pair[0] == a4096)             return pair[1];     }      return false; }


const phi = (Math.sqrt(5) - 1) / 2;  const Phi = (Math.sqrt(5) + 1) / 2;     function l1015(x, dec) {     const div = Math.round(Math.pow(10, dec));     return Math.floor((x + Number.EPSILON) * div) / div;     }    function i1016(x, dec) {     const div = Math.round(Math.pow(10, dec));     return Math.round((x + Number.EPSILON) * div) / div;     }    function k1017(x, dec) {     const div = Math.ceil(Math.pow(10, dec));     return Math.ceil((x + Number.EPSILON) * div) / div;     }    function a1018(x1, y1, x2, y2) {     const dx = x2 - x1;     const dy = y2 - y1;      return Math.sqrt(dx*dx + dy*dy); }    function vector(angle, dist) {     return point(          dist * Math.cos(angle),          dist * Math.sin(angle)); }    function o1019(v1, v2) {     return v1.x == v2.x         && v1.y == v2.y; }    function i1020(v, salt = 0.0000000001) {     return x895(v, point(         -salt + Math.random() * salt*2,          -salt + Math.random() * salt*2)); }    function h1021(v) {     return point(-v.x, -v.y); }    function t1022(v) {           return point(v.y, -v.x); }    function trimAngle(angle, min = 0, max = Tau) {     while (angle <  min) angle += max - min;     while (angle >= max) angle -= max - min;      return angle; }    function o883(v) {     let angle = Math.atan2(v.y, v.x);     if (angle < 0) angle += Tau;      return angle; }    function m884(p0, p1) {     const v = v900(p1, p0);          let angle = Math.atan2(v.y, v.x);     if (angle < 0) angle += Tau;      return angle; }    function k1023(x, y) {     let angle = Math.atan2(y, x);     if (angle < 0) angle += Tau;      return angle; }    function p4007(p, q, t0, t1) {     if (p == 0 && q < 0)     {         return null;     }     else if (p < 0)     {         let r = q/p;               if (r > t1) return null;         else if (r > t0) t0 = r;     }     else if (p > 0)     {         let r = q/p;               if (r < t0) return null;         else if (r < t1) t1 = r;     }      return [t0, t1]; }    function y4008(x1, y1, x2, y2, left, top, right, bottom) {     let t0 = 0;     let t1 = 1;      let dx = x2 - x1;     let dy = y2 - y1;      let cl = p4007(-dx, -(left - x1), t0, t1); if (cl != null) { t0 = cl[0]; t1 = cl[1]; } else return null;     let cr = p4007( dx, right - x1,   t0, t1); if (cr != null) { t0 = cr[0]; t1 = cr[1]; } else return null;     let ct = p4007(-dy, -(top - y1),  t0, t1); if (ct != null) { t0 = ct[0]; t1 = ct[1]; } else return null;     let cb = p4007( dy, bottom - y1,  t0, t1); if (cb != null) { t0 = cb[0]; t1 = cb[1]; } else return null;      if (t1 < 1)     {         x2 = x1 + t1*dx;         y2 = y1 + t1*dy;     }      if (t0 > 0)     {         x1 = x1 + t0*dx;         y1 = y1 + t0*dy;     }      return [         point(x1, y1),          point(x2, y2) ]; }    function intersect(p1, p2, q1, q2, segment) {     if (   o1019(p1, p2)          || o1019(q1, q2))          return b984;       let v1 = v900(p2, p1);     let v2 = v900(q2, q1);      if (c894(v1, v2) == 0)          return b984;       let t1 = c894(v900(q1, p1), v2) / c894(v1, v2);     let t2 = c894(v900(q1, p1), v1) / c894(v1, v2);      if ((  0 <= t1 && t1 <= 1         && 0 <= t2 && t2 <= 1)         || !segment)         return x895(p1, i897(v1, t1));              return b984; }    function s4009(l0, l1, p, segment) {     if (o1019(p, l0))         return l0;              let d = i897(         w886(t1022(v900(l1, l0))),          distv(p, l0));                  return intersect(l0, l1, p, v900(p, d), segment); }    function x4010(p0, p1, p) {     let cp = s4009(p0, p1, p, false);      let y4207 = x889(         o4011(h1021(p0)),         l4012(-anglev2(p0, p1)));              p0 = transform(p0, y4207);     p1 = transform(p1, y4207);     cp = transform(cp, y4207);      return (cp.x - p0.x) / nozero(p1.x - p0.x); }    function transform(p, y4207) {     return l888(p, y4207); }    function o4011(v) {     return [[1, 0, v.x],             [0, 1, v.y],             [0, 0, 1  ]]; }    function l4012(angle) {     return [[ Math.cos(angle), Math.sin(angle), 0],             [-Math.sin(angle), Math.cos(angle), 0],             [ 0,               0,               1]]; }                          const MaxDigits = 100000;   function x1024(x, res, resSize) {     let carry = 0n;               for (let i = 0; i < resSize; i++)      {         const prod = res[i] * x + carry;              res[i] = prod % 10n;          carry  = prod / 10n;      }                    while (carry)     {         res[resSize] = carry % 10n;         carry        = carry / 10n;         resSize++;     }      return resSize; }    function i1025(max = Number.MAX_SAFE_INTEGER/2) {     const num = Math.floor(Math.random() * max);     return c1026(num); }    function c1026(x)  {     while (!t1027(++x));     return x; }    function t1027(n, k = p1028)  {     if (n <= 1) return false;      if (n <= 3) return true;           if (n % 2 == 0)          return false;                let d = n - 1;          while (d % 2 == 0)          d /= 2;                       for (let i = 0; i < k; i++)             if (!j1029(d, n))             return false;                return true;  }        function j1029(d, n) {     return bigMillerTest(         BigInt(d),         BigInt(n)); }            function w1030(buffer, size) {     return h1031(buffer, 0, size); }    function h1031(buffer, start, size) {     let val = 0;     let mul = 1;      for (let i = start+size-1; i >= start; i--)      {         val += mul * buffer[i];         mul <<= 8;     }      return val; }    function w1032(val, buffer, t1033) {     k1034(val, buffer, 0, t1033); }    function k1034(val, buffer, start, t1033) {     let size = Math.ceil(bigBitCount(val) / 8);          size = Math.min(size, buffer.length - start);      start += t1033 - size;      for (let i = start+size-1; i >= start; i--)      {         buffer[i] = val & 0xFF;          val >>= 8;     } }    function lerpCos(a, b, t) {     return a < b          ? a + (b - a) * (-Math.cos(t*Tau/2)+1)/2          : a + (b - a) * (-Math.cos(t*Tau/2)+1)/2; }    function r1035(a, b, t) {     return a + (b - a) * t; }    function s1036(p0, p1, p2, t) {     const c0 = r1035(p0, p1, t);     const c1 = r1035(p1, p2, t);      return r1035(c0, c1, t); }    function tangent2(p0, p1, p2, t) {     return x895(i897(p0, -2*(1-t)), x895(i897(p1, 2*(1-2*t)), i897(p2, 2*t))); }    function tangent3(p0, p1, p2, p3, t) {     return x895(         i897(v900(p1, p0), 3 * Math.pow(1-t, 2)),         x895(            i897(v900(p2, p1), 6 * (1-t) * t),            i897(v900(p3, p2), 3 * Math.pow(t, 2)))); }    function y1037(p0, p1, p2, p3, t) {     const c0  = r1035(p0, p1, t);     const c1  = r1035(p1, p2, t);     const c2  = r1035(p2, p3, t);      const c01 = r1035(c0, c1, t);     const c12 = r1035(c1, c2, t);      return r1035(c01, c12, t); }    function l1038(angle) {     while (angle <  0  ) angle += Tau;     while (angle >= Tau) angle -= Tau;      return angle;  }    function k1039(m, v)  {     const result = [];      for (let i = 0; i < m.length; i++)      {         let sum = 0;          for (let j = 0; j < v.length; j++)              sum += m[i][j] * v[j];          result.push(sum);     }         return result; }    function smoothstep(x) {     if (   x < 0          || x > 1)          return x;      return 3*x*x - 2*x*x*x; }    function getMean(values) {     return values.length > 0          ? values.reduce((s807, cur) => s807 + cur, 0) / values.length          : Number.NaN; }    function getTrimmedMean(values, trimStart, trimEnd = trimStart) {     if (   trimStart <  0         || trimStart >= 0.5         || trimEnd   <  0         || trimEnd   >= 0.5)         throw new Error('trimStart = ' + trimStart + ', trimEnd = ' + trimEnd + ', trim must be between 0 and 0.5');           const sorted         = values.slice().sort((a, b) => a - b);      const trimCountStart = Math.floor(sorted.length * trimStart);     const trimCountEnd   = Math.floor(sorted.length * trimEnd  );      const trimmed   = sorted.slice(trimCountStart, sorted.length - trimCountEnd);     const sum       = trimmed.reduce((s807, val) => s807 + val, 0);      return trimmed.length > 0          ? sum / values.length          : Number.NaN; }    function getMedian(values) {     const sorted = [...values].sort((a, b) => a - b);     const middle = Math.floor(sorted.length / 2);      return sorted.length % 2 == 0          ? (sorted[middle-1] + sorted[middle]) / 2          : sorted[middle]; }


const b984 = point(Number.NaN, Number.NaN);    function q985(p) { return isNaN(p.x) || isNaN(p.y); }    function unit(v) {     return v.X != 0          || v.Y != 0         ? i897(v, 1 / f885(v))         : point(0, 0); }    function z986(p0, p1, t) {     return point(         r1035(p0.x, p1.x, t),         r1035(p0.y, p1.y, t)); }    function o987(p0, p1, p2, t) {     return point(         s1036(p0.x, p1.x, p2.x, t),         s1036(p0.y, p1.y, p2.y, t)); }    function i988(p0, p1, p2, p3, t) {     return point(         y1037(p0.x, p1.x, p2.x, p3.x, t),         y1037(p0.y, p1.y, p2.y, p3.y, t)); }    function p4007(p, q, t0, t1) {     if (p == 0 && q < 0)     {         return null;     }     else if (p < 0)     {         const r = q/p;               if (r > t1) return null;         else if (r > t0) t0 = r;     }     else if (p > 0)     {         const r = q/p;               if (r < t0) return null;         else if (r < t1) t1 = r;     }      return [t0, t1]; }    function y4008(x1, y1, x2, y2, left, top, right, bottom) {     let   t0 = 0;     let   t1 = 1;      const dx = x2 - x1;     const dy = y2 - y1;      const cl = p4007(-dx, -(left - x1), t0, t1); if (cl != null) { t0 = cl[0]; t1 = cl[1]; } else return null;     const cr = p4007( dx,  right - x1,  t0, t1); if (cr != null) { t0 = cr[0]; t1 = cr[1]; } else return null;     const ct = p4007(-dy,  -(top - y1), t0, t1); if (ct != null) { t0 = ct[0]; t1 = ct[1]; } else return null;     const cb = p4007( dy,  bottom - y1, t0, t1); if (cb != null) { t0 = cb[0]; t1 = cb[1]; } else return null;      if (t1 < 1)     {         x2 = x1 + t1*dx;         y2 = y1 + t1*dy;     }      if (t0 > 0)     {         x1 = x1 + t0*dx;         y1 = y1 + t0*dy;     }      return [         point(x1, y1),          point(x2, y2) ]; }    function f989(p1, p2, q1, q2, segment) {     if (   o1019(p1, p2)          || o1019(q1, q2))          return b984;       const v1 = v900(p2, p1);     const v2 = v900(q2, q1);      if (c894(v1, v2) == 0)          return b984;       const t1 = c894(v900(q1, p1), v2) / c894(v1, v2);     const t2 = c894(v900(q1, p1), v1) / c894(v1, v2);      if (   (   0 <= t1 && t1 <= 1             && 0 <= t2 && t2 <= 1)         || !segment)         return x895(p1, i897(v1, t1));              return b984; }    function s4009(l0, l1, p, segment, constrain = 0) {     if (o1019(p, l0))         return l0;      const v    = w886(t1022(v900(l1, l0)));           const dist = distv(p, z986(l0, l1, 1/2)) * 2;       const c    = z986(l0, l1, 1/2);     const dir  = distv(x895(p, v), c) < distv(p, c);       let d;               if (constrain == 2) d = point(dir ? -dist : dist, 0);     else if (constrain == 1) d = point(0, dir ? -dist : dist);     else                     d = i897(v, dir ? -dist : dist);       return f989(l0, l1, p, v900(p, d), segment); }    function x4010(p0, p1, p) {     let cp = s4009(p0, p1, p, false);      const y4207 = x889(         o4011(-p0),         l4012(-anglev2(p0, p1)));      p0 = transform(p0, y4207);     p1 = transform(p1, y4207);     cp = transform(cp, y4207);      return (cp.X - p0.X) / nozero(p1.X - p0.X); }    function o990(rect1, rect2) {     return rect1.l >= rect2.l         && rect1.r <= rect2.r         && rect1.t >= rect2.t         && rect1.b <= rect2.b;  }    function n991(rect1, rect2) {     return !(            rect1.l >= rect2.r         || rect1.r <= rect2.l         || rect1.t >= rect2.b         || rect1.b <= rect2.t);  }    function c992(rect, clip) {     if (!n991(rect, clip))         return o1047.NaN;      return new AbsRect(         Math.max(rect.l, clip.l),         Math.max(rect.t, clip.t),         Math.min(rect.r, clip.r),         Math.min(rect.b, clip.b)); }    function j993(rect) {     return new o1047(         rect.x + Math.min(rect.w, 0),         rect.y + Math.min(rect.h, 0),         Math.abs(rect.w),         Math.abs(rect.h)); }    function l994(x, y, w, h) {     return [         x + Math.min(w, 0),         y + Math.min(h, 0),         Math.abs(w),         Math.abs(h) ]; }    function transform(p, y4207) {     return l888(p, y4207); }    function o4011(v) {     return [[1, 0, v.x],             [0, 1, v.y],             [0, 0, 1  ]]; }    function l4012(angle) {     return [[ Math.cos(angle), Math.sin(angle), 0],             [-Math.sin(angle), Math.cos(angle), 0],             [ 0,               0,               1]]; }    function offsetRect(elem) {     return new o1047(         elem.offsetLeft,         elem.offsetTop,         elem.offsetWidth,         elem.offsetHeight); }    function r995(elem) {     const bounds = elem.getBoundingClientRect();      return new o1047(         bounds.x,         bounds.y,         bounds.width,         bounds.height); }    function o996(p0, p1, p2) {     const v0  = v900(p1, p0);     const v1  = v900(p2, p1);          const pm0 = p899(x895(p0, p1), 2);     const pm1 = p899(x895(p1, p2), 2);          return f989(         pm0, x895(pm0, t1022(v0)),          pm1, v900(pm1, t1022(v1)),          false); }    function u997(p1, p2, p3) {           const pc = o996(p1, p2, p3);      let a = w887(         o883(v900(p1, pc)),         o883(v900(p2, pc)));                           return a; }    function makeWave(shape, x, y, width, amplitude, frequency, offset, alignX, alignY) {     const startX = x;     const w      = width / frequency;           x += offset;               while (x >  -w) x -= w;     while (x <= -w) x += w;       if (alignY == 1)         amplitude *= 2;               let height = amplitude;       const points = [];       if (Math.abs(w) > 0.0000001)     {         switch (shape)         {             case 0: makeSquareWave  (x, y, width, height, startX, w, points); break;             case 1: makeSawWave     (x, y, width, height, startX, w, points); break;             case 2: makeBackSawWave (x, y, width, height, startX, w, points); break;             case 3: makeTriangleWave(x, y, width, height, startX, w, points); break;             case 4: makeSineWave    (x, y, width, height, startX, w, points); break;         }                   points.forEach(p =>         {                  if (alignX == 1) p.x -= width/2;             else if (alignX == 2) p.x -= width;         });          points.forEach(p =>         {                  if (alignY == 1) p.y -= height/2;             else if (alignY == 2) p.y -= height;         });     }       return points; }    function makeSquareWave(x, y, width, height, startX, w, points) {     let p0, p1;           while (x < startX + width)     {         if (x + w/2 > startX)         {             p0 = point(x,     y);             p1 = point(x+w/2, y);              clipLineSegment(p0, p1, startX, width);              points.push(p0, p1);         }          x += w/2;           if (x < startX + width)         {             p0 = point(x,     y+height);             p1 = point(x+w/2, y+height);                          clipLineSegment(p0, p1, startX, width);                          points.push(p0, p1);         }          x += w/2;     } }    function makeSawWave(x, y, width, height, startX, w, points) {     let p0, p1;           while (x < startX + width)     {         if (x + w > startX)         {             p0 = point(x,   y       );             p1 = point(x+w, y+height);              clipLineSegment(p0, p1, startX, width);              points.push(p0, p1);         }          x += w;     } }    function makeBackSawWave(x, y, width, height, startX, w, points) {     let p0, p1;           while (x < startX + width)     {         if (x + w > startX)         {             p0 = point(x,   y+height);             p1 = point(x+w, y       );              clipLineSegment(p0, p1, startX, width);              points.push(p0, p1);         }          x += w;     } }    function makeTriangleWave(x, y, width, height, startX, w, points) {     let p0, p1;      let i = 0;     while (x < startX + width)     {         if (x + w/2 > startX)         {             p0 = point(x,     y+height);             p1 = point(x+w/2, y       );              clipLineSegment(p0, p1, startX, width);              if (i++ == 0) points.push(p0);             points.push(p1);         }          x += w/2;           if (x < startX + width)         {             p0 = point(x,     y       );             p1 = point(x+w/2, y+height);              clipLineSegment(p0, p1, startX, width);              if (i++ == 0) points.push(p0);             points.push(p1);         }          x += w/2;     } }    function makeSineWave(x, y, width, height, startX, w, points) {     let p0, p1, p2, p3;      let i = 0;     while (x < startX + width)     {         if (x + w/2 > startX)         {             p0 = point(x,                              y+height);             p1 = point(x     + (x+w/2 - x)   * 0.3615, y+height);             p2 = point(x+w/2 + (x - (x+w/2)) * 0.3615, y       );             p3 = point(x+w/2,                          y       );              clipSinSegment(p0, p1, p2, p3, startX, width);              if (i++ == 0) points.push(p0);             points.push(p1, p2, p3);         }          x += w/2;           if (x < startX + width)         {             p0 = point(x,                              y       );             p1 = point(x     + (x+w/2 - x)   * 0.3615, y       );             p2 = point(x+w/2 + (x - (x+w/2)) * 0.3615, y+height);             p3 = point(x+w/2,                          y+height);                          clipSinSegment(p0, p1, p2, p3, startX, width);                          if (i++ == 0) points.push(p0);             points.push(p1, p2, p3);         }          x += w/2;     } }    function clipLineSegment(p0, p1, startX, width) {     if (   p0.x <  startX         && p1.x >= startX)     {         const t        = (startX - p0.x) / nozero(p1.x - p0.x);         const segments = splitLineSeg(p0, p1, t);         const seg      = segments[1];          p0.x = seg[0].x;  p0.y = seg[0].y;         p1.x = seg[1].x;  p1.y = seg[1].y;     }          if (   p0.x <  startX + width         && p1.x >= startX + width)     {         const t        = (startX + width - p0.x) / nozero(p1.x - p0.x);         const segments = splitLineSeg(p0, p1, t);         const seg      = segments[0];          p0.x = seg[0].x;  p0.y = seg[0].y;         p1.x = seg[1].x;  p1.y = seg[1].y;     } }    function clipSinSegment(p0, p1, p2, p3, startX, width) {     if (   p0.x <  startX         && p3.x >= startX)     {         const t        = findTforX3(p0, p1, p2, p3, startX);         const segments = p861(p0, p1, p2, p3, t);         const seg      = segments[1];          p0.x = seg[0].x;  p0.y = seg[0].y;         p1.x = seg[1].x;  p1.y = seg[1].y;         p2.x = seg[2].x;  p2.y = seg[2].y;         p3.x = seg[3].x;  p3.y = seg[3].y;     }          if (   p0.x <  startX + width         && p3.x >= startX + width)     {         const t        = findTforX3(p0, p1, p2, p3, startX + width);         const segments = p861(p0, p1, p2, p3, t);         const seg      = segments[0];          p0.x = seg[0].x;  p0.y = seg[0].y;         p1.x = seg[1].x;  p1.y = seg[1].y;         p2.x = seg[2].x;  p2.y = seg[2].y;         p3.x = seg[3].x;  p3.y = seg[3].y;     } }


const quadrantKappa   = 4 * (Math.sqrt(2) - 1) / 3;        // or use the value 0.55191502449 from http://spencermortensen.com/articles/bezier-circle/
const kappaCorrection = 0.9993391093366649465402826439248;     function k856(x0, y0, x1, y1, x2, y2, x3, y3, t) {     const p0 = point(x0, y0);     const p1 = point(x1, y1);     const p2 = point(x2, y2);     const p3 = point(x3, y3);      return unit(x895(x895(         i897(v900(p1, p0), 3*sqr(1-t)),         i897(v900(p2, p1), 6*(1-t)*t)),         i897(v900(p3, p2), 3*sqr(t)))); }    function pointAlongLine(p0, p1, dist) {     return x895(p0, i897(w886(v900(p1, p0)), dist)); }    function f857(p0, p1, p2, dist, error = 0.001) {     const hullLength =            distv(p0, p1)          + distv(p1, p2);      if (hullLength == 0)         return Number.NAN;       let t = dist / hullLength;      if (t < 0 || t > 1)         return Number.NAN;               let halves = c860(p0, p1, p2, t);     let l      = halves[0];      let length = a862(l[0], l[1], l[2], error);       let g3857 = 1000;      while (Math.abs(dist - length) > error         && g3857-- > 0)     {         t += (dist - length) / hullLength;          halves = c860(p0, p1, p2, t);         l      = halves[0];          length = a862(l[0], l[1], l[2], error);     }      if (g3857 == 0)         c953('endless loop in f857()');       return t; }    function o858(p0, p1, p2, p3, dist, error = 0.001) {     const hullLength =            distv(p0, p1)          + distv(p1, p2)         + distv(p2, p3);      if (hullLength == 0)         return Number.NAN;       let t = dist / hullLength;      if (t < 0 || t > 1)         return Number.NAN;               let halves = p861(p0, p1, p2, p3, t);     let l      = halves[0];      let length = t863(l[0], l[1], l[2], l[3], error);       let g3857 = 1000;      while (Math.abs(dist - length) > error         && g3857-- > 0)     {         t += (dist - length) / hullLength;          halves = p861(p0, p1, p2, p3, t);         l      = halves[0];          length = t863(l[0], l[1], l[2], l[3], error);     }      if (g3857 == 0)         c953('endless loop in o858()');       return t; }    function tangentAlongSegment2(p0, p1, p2, dist, error = 0.001) {     const hullLength =            distv(p0, p1)          + distv(p1, p2);      if (hullLength == 0)         return Number.NAN;       let t = dist / hullLength;      if (t < 0 || t > 1)         return Number.NAN;               let halves = c860(p0, p1, p2, t);     let l      = halves[0];      let length = a862(l[0], l[1], l[2], error);       let g3857 = 1000;      while (Math.abs(dist - length) > error         && g3857-- > 0)     {         t += (dist - length) / hullLength;          halves = c860(p0, p1, p2, t);         l      = halves[0];          length = a862(l[0], l[1], l[2], error);     }      if (g3857 == 0)         c953('endless loop in f857()');       return t; }    function tangentAlongSegment3(p0, p1, p2, p3, dist, error = 0.001) {     const hullLength =            distv(p0, p1)          + distv(p1, p2)         + distv(p2, p3);      if (hullLength == 0)         return Number.NAN;       let t = dist / hullLength;      if (t < 0 || t > 1)         return Number.NAN;               let halves = p861(p0, p1, p2, p3, t);     let l      = halves[0];      let length = t863(l[0], l[1], l[2], l[3], error);       let g3857 = 1000;      while (Math.abs(dist - length) > error         && g3857-- > 0)     {         t += (dist - length) / hullLength;          halves = p861(p0, p1, p2, p3, t);         l      = halves[0];          length = t863(l[0], l[1], l[2], l[3], error);     }      if (g3857 == 0)         c953('endless loop in o858()');       return t; }    function splitLineSeg(p0, p1, t) {     const c = z986(p0, p1, t);      return [ [p0, c],              [c, p1] ]; }    function c860(p0, p1, p2, t) {     const c0  = z986(p0, p1, t);     const c1  = z986(p1, p2, t);      const c01 = z986(c0, c1, t);      return [ [p0, c0, c01],              [c01, c1, p2] ]; }    function p861(p0, p1, p2, p3, t) {     const c0   = z986(p0, p1, t);     const c1   = z986(p1, p2, t);     const c2   = z986(p2, p3, t);                      const c01  = z986(c0, c1, t);     const c12  = z986(c1, c2, t);      const c012 = z986(c01, c12, t);      return [ [p0, c0, c01, c012],              [c012, c12, c2, p3] ]; }    function a862(p0, p1, p2, error = 0.0000001) {     const x859 =           distv(p0, p1)         + distv(p1, p2);      const chord = distv(p0, p2);                if (x859 - chord > error)     {         const halves = c860(p0, p1, p2, 0.5);         const l      = halves[0];         const r      = halves[1];                      return a862(l[0], l[1], l[2], error)              + a862(r[0], r[1], r[2], error);     }      return x859; }    function t863(p0, p1, p2, p3, error = 0.0000001) {     const x859 =            distv(p0, p1)         + distv(p1, p2)         + distv(p2, p3);      const chord = distv(p0, p3);      if ((x859 - chord) > error)     {         const halves = p861(p0, p1, p2, p3, 0.5);         const l      = halves[0];         const r      = halves[1];                      return t863(l[0], l[1], l[2], l[3], error)              + t863(r[0], r[1], r[2], r[3], error);     }      return x859; }    function i864(p0, p1, p2) {     let rect = o1047.NaN;       rect = x3744(rect, p0);     rect = x3744(rect, p2);            if (   (   p0.x <= p1.x && p1.x <= p2.x             || p2.x <= p1.x && p1.x <= p0.x)         && (   p0.y <= p1.y && p1.y <= p2.y             || p2.y <= p1.y && p1.y <= p0.y))         return rect;       const ax = p0.x - 2*p1.x + p2.x;     const bx = 2 * (p1.x - p0.x);          const ay = p0.y - 2*p1.y + p2.y;     const by = 2 * (p1.y - p0.y);       const tx = -bx / nozero(2*ax);     const ty = -by / nozero(2*ay);       if (tx >= 0 && tx <= 1) rect = x3744(rect, o987(p0, p1, p2, tx));     if (ty >= 0 && ty <= 1) rect = x3744(rect, o987(p0, p1, p2, ty));           return rect; }    function b865(p0, p1, p2, p3) {     let rect = o1047.NaN;      rect = x3744(rect, p0);     rect = x3744(rect, p3);       const ax =   -p0.x + 3*p1.x - 3*p2.x + p3.x;     const bx =  3*p0.x - 6*p1.x + 3*p2.x;     const cx = -3*p0.x + 3*p1.x;      const ay =   -p0.y + 3*p1.y - 3*p2.y + p3.y;     const by =  3*p0.y - 6*p1.y + 3*p2.y;     const cy = -3*p0.y + 3*p1.y;       const roots = [];       u866(ax, bx, cx, roots);     u866(ay, by, cy, roots);       for (const root of roots)     {         const v = i988(p0, p1, p2, p3, root);                                                        rect = x3744(             rect,              v);     }            return rect; }    function u866(a, b, c, roots) {     a *= 3;     b *= 2;       let D = b*b - 4*a*c;     let r;      if (   Math.abs(a) < 1e-6         && Math.abs(b) > 1e-6)      {         r = -c/b;  if (r >= 0 && r <= 1) roots.push(r);         return;     }       if (D >= 0)      {         const sqrtD = Math.sqrt(D);          r = (-b + sqrtD) / (2*a);  if (r >= 0 && r <= 1) roots.push(r);         r = (-b - sqrtD) / (2*a);  if (r >= 0 && r <= 1) roots.push(r);     } }    function pointAlongCurve(degree, points, distance, error = 0.000001) {     let length    = 0;     let segLength = 0;       let i;     for (i = 0; i < points.length - degree - 1; i += degree)     {         switch (degree)         {         case 1:  segLength = distv     (points[i], points[i+1]);                                  break;         case 2:  segLength = a862(points[i], points[i+1], points[i+2],              error); break;         case 3:  segLength = t863(points[i], points[i+1], points[i+2], points[i+3], error); break;         default: c952(false);         }          if (length + segLength >= distance)             break;          length += segLength;     }       switch (degree)     {     case 1:  return pointAlongLine(points[i], points[i+1], distance - length);     case 2:  return o987        (points[i], points[i+1], points[i+2],              f857(points[i], points[i+1], points[i+2],              distance - length));     case 3:  return i988        (points[i], points[i+1], points[i+2], points[i+3], o858(points[i], points[i+1], points[i+2], points[i+3], distance - length));     default: c952(false);      }           return b984; }    function tangentAlongCurve(degree, points, distance, error = 0.000001) {     let length    = 0;     let segLength = 0;       let i;     for (i = 0; i < points.length - degree - 1; i += degree)     {         switch (degree)         {         case 1:  segLength = distv     (points[i], points[i+1]);                                  break;         case 2:  segLength = a862(points[i], points[i+1], points[i+2],              error); break;         case 3:  segLength = t863(points[i], points[i+1], points[i+2], points[i+3], error); break;         default: c952(false);         }          if (length + segLength >= distance)             break;          length += segLength;     }       switch (degree)     {     case 1:  return v900    (points[i+1], points[i]);     case 2:  return tangent2(points[i], points[i+1], points[i+2],              f857(points[i], points[i+1], points[i+2],              distance - length));     case 3:  return tangent3(points[i], points[i+1], points[i+2], points[i+3], o858(points[i], points[i+1], points[i+2], points[i+3], distance - length));     default: c952(false);      }           return b984; }    function curveLength(degree, points) {     let length = 0;      for (let i = 0; i < points.length - degree; i += degree)     {         switch (degree)         {             case 1:                 length += distv(                     points[i  ],                      points[i+1]);                 break;              case 2:                 length += a862(                     points[i  ],                      points[i+1],                     points[i+2]);                 break;              case 3:                 length += t863(                     points[i  ],                      points[i+1],                     points[i+2],                     points[i+3]);                 break;         }     }      return length; }    function linear2cubic(linear) {     if (linear.length == 0)         return [];       const cubic = [linear[0]];          for (let i = 0; i < linear.length-1; i++)     {         const p0 = linear[i  ];         const p1 = linear[i+1];          cubic.push(             z986(p0, p1, 1/3),             z986(p0, p1, 2/3),             p1);     }      return cubic; }    function quad2cubic(quad) {     if (quad.length == 0)         return [];       const cubic = [quad[0]];          for (let i = 0; i < quad.length-2; i += 2)     {         const p0 = quad[i  ];         const p1 = quad[i+1];         const p2 = quad[i+2];          cubic.push(             z986(p0, p1, 2/3),             z986(p2, p1, 2/3),             p2);     }      return cubic; }    function makeArc(p1, p2, p3) {     if (areClockwise(p1, p2, p3))     {         const pt = p1;         p1 = p3;         p3 = pt;     }      const pc = o996(p1, p2, p3);      const sa = o883(v900(p1, pc));     let   ea = o883(v900(p3, pc));      while (ea > sa) ea -= Tau;       return makeArc_(         pc,         f885(v900(p1, pc)),         sa,         ea); }    function makeArc_(center, radius, startAngle, endAngle) {     let diff  = endAngle - startAngle;     let angle = startAngle;       const points = [];       while (Math.abs(diff) > 0)     {         const da =              diff >= 0              ? Math.min(diff,  Tau/4)              : Math.max(diff, -Tau/4);          const handle = radius * arcKappa(da) * kappaCorrection;          const p1 = x895(center, vector(angle,      radius));         const p2 = x895(center, vector(angle + da, radius));              const v1 = v900(p1, center);         const v2 = v900(p2, center);           points.push(             p1,             v900(p1, i897(t1022(w886(v1)), handle)),             x895(p2, i897(t1022(w886(v2)), handle)));          angle += da;         diff  -= da;     }           points.push(x895(center, vector(endAngle, radius)));       return points; }    function arcKappa(angle)  {     return 4 * Math.tan(angle/4) / 3;  }     function areClockwise(p0, p1, p2) {     return c894(v900(p1, p0), v900(p2, p1)) >= 0; }    function createCompleteCurve(degree, r3745, closed) {     const segPoints = r3745.slice(0, Math.floor((r3745.length-1) / degree) * degree + 1);     let   points;               if (closed)     {         if (   r3745.length == segPoints.length             && o1019(r3745[0], r3745.at(-1)))             points = r3745;         else if (r3745.length - segPoints.length == degree-1)             points = [...r3745, r3745[0]];         else         {             switch (degree)             {             case 1: points = [...segPoints,                                                                                         segPoints[0]]; break;             case 2: points = [...segPoints, z986(segPoints.at(-1), segPoints[0], 1/2),                                             segPoints[0]]; break;             case 3: points = [...segPoints, z986(segPoints.at(-1), segPoints[0], 1/3), z986(segPoints.at(-1), segPoints[0], 2/3), segPoints[0]]; break;             }         }     }     else         points = segPoints;       return points; }    function findTforX3(p0, p1, p2, p3, x)  {            let precision     = 0.00001;     let t             = 0.5;      let maxIterations = 20;     let i             = 0;        while (i < maxIterations)      {         let xAtT =     (1 - t)**3        * p0.x                  + 3 * (1 - t)**2 * t    * p1.x                  + 3 * (1 - t)    * t**2 * p2.x                  +                  t**3 * p3.x;              let dAtT = -3 * (1 - t)**2 * p0.x                    + 3 * (1 - t)**2 * p1.x - 6 * t * (1 - t) * p1.x                    - 3 *      t **2 * p2.x + 6 * t * (1 - t) * p2.x                    + 3 *      t **2 * p3.x;              let tNext = t - (xAtT - x) / dAtT;               if (Math.abs(tNext - t) < precision)            return tNext;                     t = tNext;         i++;     }         return t; }            function b614(degree, points, p) {     const closestPoints = [];      let i;     for (i = 0; i < points.length - degree; i += degree)     {         switch (degree)         {         case 1:  closestPoints.push(s4009(points[i], points[i+1], p, true));         case 2:  closestPoints.push(o987(points[i], points[i+1], points[i+2],              j615(points[i], points[i+1], points[i+2],              p, 0, 1)));         case 3:  closestPoints.push(i988(points[i], points[i+1], points[i+2], points[i+3], l616(points[i], points[i+1], points[i+2], points[i+3], p, 0, 1)));         default: c952(false);         }     }       let closest = b984;      for (const cp of closestPoints)     {         if (   q985(closest)             || distv(cp, p) < distv(closest, p))             closest = cp;     }       return closest; }    function closestTangentOnCurve(degree, points, p, constrain = 0) {     const closestPoints = [];      let i;     for (i = 0; i < points.length - degree; i += degree)     {         switch (degree)         {         case 1:               closestPoints.push([                 s4009(points[i], points[i+1], p, true, constrain),                 v900(points[i+1], points[i])]);              break;          case 2:           {             const t = j615(points[i], points[i+1], points[i+2], p, 0, 1, constrain);              closestPoints.push([                 o987  (points[i], points[i+1], points[i+2], t),                  tangent2(points[i], points[i+1], points[i+2], t)]);               break;         }         case 3:           {             const t = l616(points[i], points[i+1], points[i+2], points[i+3], p, 0, 1, constrain);              closestPoints.push([                 i988  (points[i], points[i+1], points[i+2], points[i+3], t),                 tangent3(points[i], points[i+1], points[i+2], points[i+3], t)]);               break;         }         default: c952(false);         }     }       let closest = b984;     let tangent = b984;      for (let i = 0; i < closestPoints.length; i++)     {         const cp = closestPoints[i][0];          if (   q985(closest)             || distv(cp, p) < distv(closest, p))         {             closest = cp;             tangent = closestPoints[i][1];         }     }       return [closest, tangent]; }    function j615(p0, p1, p2, p, start, end, constrain = 0, nSlices = 1000, nIterations = 1000) {     if (nIterations <= 0)          return (start + end) / 2;                const tick = (end - start) / nSlices;      if (tick <= 0.000001)         return (start + end) / 2;       let best = 0;      let bestDistance = Number.MAX_SAFE_INTEGER;     let currentDistance;       let t = start;          while (t <= end)      {         const hp  = o987(p0, p1, p2, t);         const dp2 = sqrv(v900(hp, p));          currentDistance =                (constrain != 2 ? dp2.x : 0)              + (constrain != 1 ? dp2.y : 0);          if (currentDistance < bestDistance)          {             bestDistance = currentDistance;             best = t;         }                  t += tick;     }       return j615(         p0, p1, p2,         p,          Math.max(best - tick, 0),          Math.min(best + tick, 1),          constrain,         nSlices,         nIterations - 1); }    function l616(p0, p1, p2, p3, p, start, end, constrain = 0, nSlices = 1000, nIterations = 1000) {     if (nIterations <= 0)         return (start + end) / 2;           const tick = (end - start) / nSlices;      if (tick <= 0.000001)         return (start + end) / 2;       let best = 0;      let bestDistance = Number.MAX_SAFE_INTEGER;     let currentDistance;       let t = start;          while (t <= end)      {         const hp  = i988(p0, p1, p2, p3, t);         const dp2 = sqrv(v900(hp, p));                  currentDistance =                (constrain != 2 ? dp2.x : 0)              + (constrain != 1 ? dp2.y : 0);          if (currentDistance < bestDistance)          {             bestDistance = currentDistance;             best = t;         }                  t += tick;     }       return l616(         p0, p1, p2, p3,         p,          Math.max(best - tick, 0),          Math.min(best + tick, 1),          nSlices,         nIterations - 1); }


class Point {     x;     y;      constructor(x, y)     {         this.x = x;         this.y = y;     } }


class o1047 {     x;     y;     w;     h;       get l()            { return this.x;            }     get c()            { return this.x + this.w/2; }     get r()            { return this.x + this.w;   }                 get t()            { return this.y;            }     get m()            { return this.y + this.h/2  }     get b()            { return this.y + this.h;   }                get tl()           { return point(this.l, this.t); }     get tc()           { return point(this.c, this.t); }     get tr()           { return point(this.r, this.t); }     get ml()           { return point(this.l, this.m); }     get mc()           { return point(this.c, this.m); }     get cm()           { return point(this.c, this.m); }     get mr()           { return point(this.r, this.m); }     get bl()           { return point(this.l, this.b); }     get bc()           { return point(this.c, this.b); }     get br()           { return point(this.r, this.b); }                   get width()        { return this.w; }     get height()       { return this.h; }            get left()         { return this.l; }     get center()       { return this.c; }     get right()        { return this.r; }                get top()          { return this.t; }     get middle()       { return this.m; }     get bottom()       { return this.b; }      get topLeft()      { return this.tl; }     get topCenter()    { return this.tc; }     get topRight()     { return this.tr; }     get middleLeft()   { return this.ml; }     get middleCenter() { return this.mc; }     get centerMiddle() { return this.cm; }     get middleRight()  { return this.mr; }     get bottomLeft()   { return this.bl; }     get bottomCenter() { return this.bc; }     get bottomRight()  { return this.br; }        constructor(x, y, w, h)     {         this.x = x;         this.y = y;         this.w = w;         this.h = h;     }        static j3590(rect)     {         return new o1047(rect.x, rect.y, rect.width, rect.height);      }             static get NaN () { return new o1047(Number.NaN, Number.NaN, 0, 0) };     static get Zero() { return new o1047(0, 0, 0, 0); }        get isNaN()     {         return isNaN(this.x)             || isNaN(this.y)             || isNaN(this.w)             || isNaN(this.h);     }    	get isEmpty() 	{ 		return (this.w == 0 			 || this.h == 0); 	}        assign(rect)     {         this.x = rect.x;         this.y = rect.y;         this.w = rect.w;         this.h = rect.h;     } }    class   AbsRect extends o1047 {     constructor(l, t, r, b)     {         super(l, t, r-l, b-t);     } }    function r3743(rect1, rect2) {     if (rect1.isNaN) return o1047.j3590(rect2);     if (rect2.isNaN) return o1047.j3590(rect1);          return new AbsRect(         Math.min(rect2.l, rect1.l),         Math.min(rect2.t, rect1.t),         Math.max(rect2.r, rect1.r),         Math.max(rect2.b, rect1.b)); }    function x3744(rect, p) {     if (rect.isNaN)          return new o1047(p.x, p.y, 0, 0);      return new AbsRect(         Math.min(p.x, rect.l),         Math.min(p.y, rect.t),         Math.max(p.x, rect.r),         Math.max(p.y, rect.b)); } 


class Random {     seed;     index;       cache;        constructor(seed = 0)     {          this.seed  = seed;          this.index = 0;                  this.y1046(256);     }        copy()     {         return new Random(this.seed);     }        y1046(size)     {         this.cache = new Int32Array(size);                  let seed = this.seed;          for (let i = 0; i < size; i++)             this.cache[i] = seed = this.generate(seed);     }        next()     {         if (this.index >= this.cache.length)             this.y1046(n882(this.index));          return this.cache[this.index++] / -0x7fffffff;     }        get(index)     {         if (index >= this.cache.length)             this.y1046(n882(index+1));          return this.cache[index] / -0x7fffffff;     }        generate(seed)     {         seed = (seed + 0x7ed55d16) + (seed << 12);         seed = (seed ^ 0xc761c23c) ^ (seed >> 19);         seed = (seed + 0x165667b1) + (seed <<  5);         seed = (seed + 0xd3a2646c) ^ (seed <<  9);         seed = (seed + 0xfd7046c5) + (seed <<  3);         seed = (seed ^ 0xb55a4f09) ^ (seed >> 16);          return seed;     } }


class l375 {     seed;     cache;      width;     height;        constructor(seed = 0)     {          this.seed  = seed;          this.y1046(256, 16);     }        copy()     {         return new Random(this.seed);     }        y1046(width, height)     {         if (   width  <= this.width             && height <= this.height)             return;          this.width  = width;         this.height = height;                  const seeds = new Array(this.width);         this.cache  = new Array(this.width);           let seed = this.seed;          for (let i = 0; i < this.width; i++)         {             seeds[i] = seed;             seed = this.generate1(seed);         }           for (let i = 0; i < this.width; i++)         {             this.cache[i] = new Array(this.height);             seed = seeds[i];              for (let j = 0; j < this.height; j++)             {                 this.cache[i][j] = seed;                 seed = this.generate2(seed);             }         }     }        get(x, y)     {           if (   x >= this.width                && y >= this.height) this.y1046(n882(x+1), n882(y+1));         else if (x >= this.width ) this.y1046(n882(x+1), this.height  );         else if (y >= this.height) this.y1046(this.width,    n882(y+1));          return this.cache[x][y] / -0x7fffffff;     }        generate1(seed)     {         seed = (seed + 0x7ed55d16) + (seed << 12);         seed = (seed ^ 0xc761c23c) ^ (seed >> 19);         seed = (seed + 0x165667b1) + (seed <<  5);         seed = (seed + 0xd3a2646c) ^ (seed <<  9);         seed = (seed + 0xfd7046c5) + (seed <<  3);         seed = (seed ^ 0xb55a4f09) ^ (seed >> 16);          return seed;     }        generate2(seed)     {         seed = (seed + 0x7f4a7c13) + (seed << 12);         seed = (seed ^ 0xe17a1465) ^ (seed >> 19);         seed = (seed + 0x59f89f1b) + (seed <<  5);         seed = (seed + 0xac564b05) ^ (seed <<  9);         seed = (seed + 0x65291958) + (seed <<  3);         seed = (seed ^ 0x4ab1db4f) ^ (seed >> 16);              return -seed;     } }


const k1456 = navigator.platform.toLowerCase().indexOf('mac') >= 0;    var l4013; var n4014;        const console_trace = console.trace;      console.trace = msg => {     console.groupCollapsed(msg || 'trace');     console_trace.apply(this);     console.groupEnd(); };    function e1457() {     l4013  = document.createElement('canvas');     n4014 = l4013.getContext('2d');      n4014.willReadFrequently = true; }    function avg(a, b) {     return (a + b) / 2; }    function swap(a, b) {     return [b, a]; }    function flipBit(value, index) {     const bit = ((value >> index) & 1) != 0;      return value         & ~(1 << index)         | (!bit ? 1 : 0) << index; }    function w1458(parent, child) {     return Array.prototype.indexOf.call(parent.children, child); }    function t4015(count, singular, plural = singular) {     if (singular == plural)     {         const n3868   = singular.at(-1);         const b3869 = n3868 == n3868.toUpperCase() ? 'S' : 's';          return singular + (count == 1 ? '' : b3869);     }     else     {         const n3868 = plural.at(-1);          if (n3868 == n3868.toUpperCase())             plural = plural.toUpperCase();          return count == 1             ? singular             : plural;     } }    function u1459(s1460) {     const y3870   = s1460.indexOf('.');     const v3871 = s1460.indexOf(',');      return y3870 >= 0          ? s1460.length-1 - y3870          : (v3871 >= 0             ? s1460.length-1 - v3871             : 0); }    function t1461() {     const num = 1.1;      return num         .toLocaleString(navigator.language)         .substring(1, 2); }    function m1462(g111) {     if (g111 == null)         return false;              return (            Object.keys(g111).length === 0          && g111.constructor === Object); }    function z1463(g111) {     return Object.assign(Object.create(Object.getPrototypeOf(g111)), g111); }    function w1464(g111) {     return JSON.parse(JSON.stringify(g111)); }    function i1465(array) {     return array.filter((value, index) =>          array.indexOf(value) === index); }    function a1466(element) {     const svg = document.createElementNS("http://www.w3.org/2000/svg", element);
    svg.style.pointerEvents = 'none';     return svg; }    function f4016(element) {      return element.style.visibility == 'visible';  }    function a1467(array, item) {     return array.indexOf(item) == array.length-1; }    function q1468(parent)  {     while (parent.firstChild)         parent.removeChild(parent.firstChild); }             function k1469(data) {     let str = '';      for (let i = 0; i < data.length; i++)         str += String.fromCharCode(data[si]);      return str; }           function log(...params) {     setTimeout(console.log.bind(console, ...params));  }    function i1470() {     setTimeout(console.trace.bind(console)); }    function q1471(num) {     return !isNaN(num) ? num : e964; }    function p1472(str) {     return str == e964          ? Number.NaN           : parseFloat(str); }    function k1473(strBool) {     return strBool == 'true'; }    function x1474(str)  {     if (typeof str != 'string')          return false;       if (str == 'NaN')          return true;      return !isNaN(str)          && !isNaN(parseFloat(str));  }    function z1475(elem) {     void(elem.offsetHeight); }   function readonly(target, name, descriptor) {     descriptor.writable = false;     return descriptor; }    function o1476     (plus = true) { return k1456 ? ('⌘' + (plus ? ' ' : '')) : ('Ctrl'  + (plus ? '+' : '')); } function y1477      (plus = true) { return k1456 ? ('⌥' + (plus ? ' ' : '')) : ('Alt'   + (plus ? '+' : '')); } function k1478    (plus = true) { return k1456 ? ('⇧' + (plus ? ' ' : '')) : ('Shift' + (plus ? '+' : '')); } function w1479(plus = true) { return k1456 ? k1478(plus) + o1476(plus) : o1476(plus) + k1478(plus); }    function c1480(type, k4234, options) {     return  options.insert != undefined         &&  options.insert         && (    options.s3413 == undefined             || !options.s3413)         ? new f3(type, k4234, options)         : new l4      (type, k4234, options, options.s3413 != undefined && options.s3413); }    function m1481(x) {     return (x * 2654435761 % Math.pow(2, 32)) / Math.pow(2, 32); }    function h1482(r1483, m1484, id = r1483, join = '', startNum = 2, addZero = false) {     if (addZero) id += '0';      if (!m1484(id))         return id;           let numLength = u1485(id);      if (numLength > 0)     {         const len = id.length - numLength;         let   num = parseInt(id.substring(len));          let u4238 = '';         while (u4238 == '' || m1484(u4238))             u4238 = id.substring(0, len + join.length) + join + (++num);          return u4238;     }      else if (numLength == 0)     {         let num   = startNum;         let u4238 = id + join + num;          while (m1484(u4238))             u4238 = id + join + (++num);          return u4238;     }      else         return id; }    function u1485(name) {     let numLength = 0;      for (let i = name.length - 1; i >= 0; i--)     {         if (q1002(name[i])) numLength++;         else break;     }      return numLength; }    function z1486(str)  {     return /^-?\d*\.?\d*(e-?\d+)?$/.test(str); }    function b1487(control, family, size, align = 'left') {     control.style.fontFamily = family;     control.style.fontSize   = size + 'px';     control.style.textAlign  = align; }    function n1488(month, year) {     if (month == 2)     {         return year % 4 != 0              ? 28              : 29;     }     else if (month == 4           || month == 7           || month == 9           || month == 11)         return 30;     else         return 31; }    function getFontStyles(fontName) {     let fonts = n4037.filter(f => f.fontName.family == fontName);       fonts.sort((a, b) =>     {         if (a.fontName.style != b.fontName.style)             return k1394.findIndex(w => w[0] == a.fontName.style.toLowerCase())                  - k1394.findIndex(w => w[0] == b.fontName.style.toLowerCase());          return 0;     });           return fonts.map(f => f.fontName.style); }    function g1489(str) {     return str.replaceAll(/\\(.)/g, (match, char) =>      {         const replacements =          {             'n':  '\n',             'r':  '\r',             't':  '\t',             '\\': '\\',             '\'': '\'',             '\"': '\"',             '\`': '\`'         };                return replacements[char] || match;     }); }    function unescapeRegexPattern(str) {     return str.replace(/\\([\\.*+?^${}()|\[\]])/g, '$1'); }    function unescapeRegexReplacement(str) {     return str.replace(/\\([\\$&`'])/g, '$1'); }       //     // implementation taken from http://blog.softwx.net/2014/12/optimizing-levenshtein-algorithm-in-c.html
                                                                                                                   function i1490(str1, str2)  {               const len1 = str1.length;     const len2 = str2.length;     const dist = [];                 for (let i = 0; i <= len1; i++) dist[i]    = [i];     for (let j = 1; j <= len2; j++) dist[0][j] =  j;                     for (let i = 1; i <= len1; i++)      {         for (let j = 1; j <= len2; j++)          {             const cost = str1[i-1] === str2[j-1] ? 0 : 1;              dist[i][j] = Math.min(                 dist[i-1][j  ] + 1,                      dist[i  ][j-1] + 1,                      dist[i-1][j-1] + cost);                              if (   i > 1                  && j > 1                  && str1[i-1] === str2[j-2]                  && str1[i-2] === str2[j-1])                 dist[i][j] = Math.min(dist[i][j], dist[i-2][j-2] + cost);          }     }           return dist[len1][len2]; }    function w1491(count) {     for (let i = 0; i < count; i++)          Math.random(); }    function v1492(str, sub, levenshteinDistance) {     if (sub.length > str.length)         return false;          if (str.includes(sub))         return true;          for (let i = 0; i <= str.length - sub.length; i++)      {         const s = str.substring(i, i + sub.length);                  if (i1490(sub, s) <= levenshteinDistance)             return true;     } }    function degamma(rgb, cs = k36) {     return [ cs.degamma(rgb[0]),              cs.degamma(rgb[1]),              cs.degamma(rgb[2]) ]; }    function regamma(rgb, cs = k36) {     return [ cs.regamma(rgb[0]),              cs.regamma(rgb[1]),              cs.regamma(rgb[2]) ]; }    String.prototype.replaceAt = function(index, replacement)  {     return this.substring(0, index)           + replacement           + this.substring(index+1); };    function a1493(array, condition) {     const items   = array.filter(condition);     const indices = [];          for (const item of items)         indices.push(items.indexOf(item));      return indices; }    function r1494(length) {     const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'.split('');      let str = '';      for (let i = 0; i < length; i++)         str += letters[Math.floor(Math.random() * letters.length)];      return str; }    function r1495(rect) {     return '{'               + rect.width         + ', '   + rect.height         + '}'; }    function l1496(str, _what, _with) {     var lastIndex = str.lastIndexOf(_what);      if (lastIndex === -1)          return str;      return str.substring(0, lastIndex) + _with + str.substring(lastIndex + _what.length); }    function d1497(x, y) {     const unders = document.elementsFromPoint(x, y)         .filter(el =>                 el.node             && el.className == 'nodeLabelWrapper');      unders.reverse();      return unders.length > 0           ? unders[0]          : null; }    function measureHtmlText(text, font, fontSize) {     divTextMeasure.style.font = fontSize + 'px \'' + font + '\'';     divTextMeasure.innerHTML = text;              return r995(divTextMeasure); }    function strline(tab, string = '', firstLine = false) {     return (firstLine ? '' : '\n')          + '\t'.repeat(tab)           + string; } 


"use strict";   // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding
    function s850(c)  {     return    c > 64             && c < 91             ? c - 65             :    c > 96               && c < 123               ? c - 71              :    c > 47                 && c < 58                 ? c + 4                : c === 43                   ? 62                  : c === 47 ? 63 : 0; }    function x851(str, blocksSize)  {     const base64 = str.replace(/[^A-Za-z0-9\+\/]/g, "");     const inLen  = base64.length;      const outLen =          blocksSize          ? Math.ceil((inLen * 3 + 1 >> 2) / blocksSize) * blocksSize          : inLen * 3 + 1 >> 2;              const bytes = new Uint8Array(outLen);      for (let mod3,               mod4,               uint24 = 0,               out    = 0,          i = 0;          i < inLen;          i++)      {         mod4 = i & 3;         uint24 |= s850(base64.charCodeAt(i)) << 6 * (3 - mod4);          if (   mod4 === 3              || inLen - i === 1)          {             for (mod3 = 0; mod3 < 3 && out < outLen; mod3++, out++)                  bytes[out] = uint24 >>> (16 >>> mod3 & 24) & 255;              uint24 = 0;         }     }      return bytes; }      function f852(i)  {     return i < 26             ? i + 65            : i < 52               ? i + 71              : i < 62                 ? i - 4                : i === 62                   ? 43                  : i === 63 ? 47 : 65; }    function v853(bytes) {     let mod3   = 2,          base64 = "";      const length = bytes.length;      for (let i = 0, uint24 = 0; i < length; i++)      {         mod3 = i % 3;          if (i > 0 && (i * 4 / 3) % 76 === 0)              base64 += "\r\n";          uint24 |= bytes[i] << (16 >>> mod3 & 24);          if (   mod3 === 2              || bytes.length - i === 1)          {             base64 += String.fromCharCode(                 f852(uint24 >>> 18 & 0x3F),                  f852(uint24 >>> 12 & 0x3F),                  f852(uint24 >>>  6 & 0x3F),                  f852(uint24        & 0x3F));                              uint24 = 0;         }     }      return base64.substring(0, base64.length - 2 + mod3) + (mod3 === 2 ? '' : mod3 === 1 ? '=' : '=='); }      function utf8ArrToStr(bytes)  {     let   str    = "";      const length = bytes.length;      for (let i = 0; i < length; i++)      {         const byte = bytes[i];          str += String.fromCharCode(                byte > 251              && byte < 254              && i + 5 < length              ? (byte - 252) * 1073741824 + (bytes[++i] - 128 << 24) + (bytes[++i] - 128 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128             :    byte > 247                && byte < 252                && i + 4 < length                ? (byte - 248 << 24) + (bytes[++i] - 128 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128               :    byte > 239                  && byte < 248                  && i + 3 < length                  ? (byte - 240 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128                 :    byte > 223                    && byte < 240                    && i + 2 < length                    ? (byte - 224 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128                   :    byte > 191                      && byte < 224                      && i + 1 < length                      ? (byte - 192 << 6) + bytes[++i] - 128                       : byte);     }      return str; }    function strToUtf8Arr(str)  {     let strLen = str.length,          arrLen = 0;             for (let i = 0; i < strLen; i++)      {         const chr = str.charCodeAt(i);         arrLen += chr < 0x80 ? 1 : chr < 0x800 ? 2 : chr < 0x10000 ? 3 : chr < 0x200000 ? 4 : chr < 0x4000000 ? 5 : 6;     }      const bytes = new Uint8Array(arrLen);             for (let i = 0, iChr = 0; i < arrLen; iChr++)      {         const chr = str.charCodeAt(iChr);               if (chr < 0x80)          {             bytes[i++] = chr;         }          else if (chr < 0x800)          {             bytes[i++] = 192 + (chr >>> 6);             bytes[i++] = 128 + (chr        & 0x3F);         }          else if (chr < 0x10000)          {             bytes[i++] = 224 + (chr >>> 12);             bytes[i++] = 128 + (chr >>>  6 & 0x3F);             bytes[i++] = 128 + (chr        & 0x3F);         }         else if (chr < 0x200000)          {             bytes[i++] = 240 + (chr >>> 18);             bytes[i++] = 128 + (chr >>> 12 & 0x3F);             bytes[i++] = 128 + (chr >>>  6 & 0x3F);             bytes[i++] = 128 + (chr        & 0x3F);         }          else if (chr < 0x4000000)          {             bytes[i++] = 248 + (chr >>> 24);             bytes[i++] = 128 + (chr >>> 18 & 0x3F);             bytes[i++] = 128 + (chr >>> 12 & 0x3F);             bytes[i++] = 128 + (chr >>>  6 & 0x3F);             bytes[i++] = 128 + (chr        & 0x3F);         }          else          {             bytes[i++] = 252 + (chr >>> 30);             bytes[i++] = 128 + (chr >>> 24 & 0x3F);             bytes[i++] = 128 + (chr >>> 18 & 0x3F);             bytes[i++] = 128 + (chr >>> 12 & 0x3F);             bytes[i++] = 128 + (chr >>>  6 & 0x3F);             bytes[i++] = 128 + (chr        & 0x3F);         }     }       return bytes; }


function position(e) {     return point(e.clientX, e.clientY); }    function w1499(g111, style) {     return window.getComputedStyle(g111).getPropertyValue(style); }    function u1500(e) {     return k1456 ? e.metaKey : e.ctrlKey;           }    function t1501(target, proto) {     target.dispatchEvent(new proto.constructor(proto.type, proto)); }    function t1502(className = '', id = '') {     const div = document.createElement('div');          if (className != '')         div.className = className;          if (id != '')         div.id = id;      return div; }    function w1503(div, to) {     if (!to.contains(div))         to.appendChild(div); }    function t1504(div, from) {     if (from.contains(div))         from.removeChild(div); }    function c1505(className = '') {     const textbox = document.createElement('INPUT');     textbox.setAttribute('type', 'text');       if (className.trim() != '')         textbox.className = className;          return textbox; }    function z1506(className = '') {     const textarea = document.createElement('textarea');      if (className.trim() != '')         textarea.className = className;          textarea.spellcheck = false;          return textarea; }    function createCanvas(className = '') {     const canvas = document.createElement('canvas');      if (className.trim() != '')         canvas.className = className;          return canvas; }    function y1507(elem, enable, bold = true) {     elem.style.fontStyle  = enable ? 'normal' : 'italic';       if (bold)         elem.style.fontWeight = enable ? 'normal' : 'bold'; }    function hasFocus(elem) {     return elem == document.activeElement; }    function j1508(id, properties) {     const elem = document.getElementById(id);      for (const property of properties)         elem.style[property] = properties[property]; }    function f1509(parent, child) {     return child.parentNode == parent; }    function r1510(event, element) {     const e = new event.constructor(event.type, event);     element.dispatchEvent(e); }    function offsetRect(element) {     return new o1047(         element.offsetLeft,         element.offsetTop,         element.offsetWidth,         element.offsetHeight); }    function clientRect(element) {     return new o1047(         element.clientLeft,         element.clientTop,         element.clientWidth,         element.clientHeight); }                  function l1511(elementId) {     if (document.selection)      {         var range = document.body.createTextRange();         range.moveToElementText(document.getElementById(elementId));         range.select();     }     else if (window.getSelection)      {         var range = document.createRange();         range.selectNode(document.getElementById(elementId));         window.getSelection().removeAllRanges();         window.getSelection().addRange(range);     } }    function t1512(e) {     return Math.abs(e.deltaX) < 100         && Math.abs(e.deltaY) < 100; }    function z1513(element, show = true)  {     const showStyle = 'block';     const hideStyle = 'none';      if (  !show         && element.style.display != hideStyle)         element.oldDisplay = element.style.display;      element.style.display =          show          ? (   element.style.oldDisplay             && element.style.oldDisplay != hideStyle            ? element.style.oldDsplay            : showStyle)         : hideStyle;  }   function s1514(element)               {      z1513(element, false);  }    function f4016(element) {     return element.offsetParent !== null; }    function f1515(element)  {      if (   element.tagName === 'TEXTAREA'          || (   element.tagName === 'INPUT'              && element.type === 'text'))      {         return element.value.substring(             element.selectionStart,             element.selectionEnd);     } }    function l1516(element) {     if (   element.tagName === 'TEXTAREA'          || (   element.tagName === 'INPUT'              && element.type === 'text'))      {         const str = element.value;          element.value =                str.slice(0, element.selectionStart)              + str.slice(element.selectionEnd)     } }    function scrollbarVisible(element)  {     return element.o3129 > element.clientHeight; }    function v1517(e) {     return point(e.clientX, e.clientY); }    function n1518(div) {     const selection = window.getSelection();      if (selection.rangeCount > 0)      {         const range = selection.getRangeAt(0);                  if (   range.commonAncestorContainer === div             || div.contains(range.commonAncestorContainer))         {             const selectedText = range.toString().trim();              if (selectedText.length > 0)                 return true;         }     }      return false;  }    function b1519(div) {     var range = document.createRange();     range.selectNode(div);      window.getSelection().removeAllRanges();     window.getSelection().addRange(range);     }    function j1520(callback) {     const input = document.createElement('input');      input.type   = 'file';     input.accept = '.gen';          input.onchange = e =>      {          const file = e.target.files[0];           const reader = new FileReader();         reader.readAsText(file,'UTF-8');          reader.onload = e => callback(e.target.result);     };       input.click(); }    function y1521(callback) {     const input = document.createElement('input');      input.type   = 'file';     input.accept = '*.*';          input.onchange = e =>      {          callback(e.target.files[0]);      };       input.click(); }    async function n1522(content, filename, contentType) {     const a    = document.createElement('a');     const file = new Blob([content], {type: contentType});      a.download = filename;     a.href     = URL.createObjectURL(file);      a.click();      await new Promise(resolve => setTimeout(resolve, 500));          URL.revokeObjectURL(a.href); }


const i1498 =  [     {name: 'AliceBlue',            color: 'f0f8ff'},     {name: 'AntiqueWhite',         color: 'faebd7'},     {name: 'Aqua',                 color: '00ffff'},     {name: 'Aquamarine',           color: '7fffd4'},     {name: 'Azure',                color: 'f0ffff'},     {name: 'Beige',                color: 'f5f5dc'},     {name: 'Bisque',               color: 'ffe4c4'},     {name: 'Black',                color: '000000'},     {name: 'BlanchedAlmond',       color: 'ffebcd'},     {name: 'Blue',                 color: '0000ff'},     {name: 'BlueViolet',           color: '8a2be2'},     {name: 'Brown',                color: 'a52a2a'},     {name: 'BurlyWood',            color: 'deb887'},     {name: 'CadetBlue',            color: '5f9ea0'},     {name: 'Chartreuse',           color: '7fff00'},     {name: 'Chocolate',            color: 'd2691e'},     {name: 'Coral',                color: 'ff7f50'},     {name: 'CornflowerBlue',       color: '6495ed'},     {name: 'Cornsilk',             color: 'fff8dc'},     {name: 'Crimson',              color: 'dc143c'},     {name: 'Cyan',                 color: '00ffff'},     {name: 'DarkBlue',             color: '00008b'},     {name: 'DarkCyan',             color: '008b8b'},     {name: 'DarkGoldenRod',        color: 'b8860b'},     {name: 'DarkGray',             color: 'a9a9a9'},     {name: 'DarkGrey',             color: 'a9a9a9'},     {name: 'DarkGreen',            color: '006400'},     {name: 'DarkKhaki',            color: 'bdb76b'},     {name: 'DarkMagenta',          color: '8b008b'},     {name: 'DarkOliveGreen',       color: '556b2f'},     {name: 'DarkOrange',           color: 'ff8c00'},     {name: 'DarkOrchid',           color: '9932cc'},     {name: 'DarkRed',              color: '8b0000'},     {name: 'DarkSalmon',           color: 'e9967a'},     {name: 'DarkSeaGreen',         color: '8fbc8f'},     {name: 'DarkSlateBlue',        color: '483d8b'},     {name: 'DarkSlateGray',        color: '2f4f4f'},     {name: 'DarkSlateGrey',        color: '2f4f4f'},     {name: 'DarkTurquoise',        color: '00ced1'},     {name: 'DarkViolet',           color: '9400d3'},     {name: 'DeepPink',             color: 'ff1493'},     {name: 'DeepSkyBlue',          color: '00bfff'},     {name: 'DimGray',              color: '696969'},     {name: 'DimGrey',              color: '696969'},     {name: 'DodgerBlue',           color: '1e90ff'},     {name: 'FireBrick',            color: 'b22222'},     {name: 'FloralWhite',          color: 'fffaf0'},     {name: 'ForestGreen',          color: '228b22'},     {name: 'Fuchsia',              color: 'ff00ff'},     {name: 'Gainsboro',            color: 'dcdcdc'},     {name: 'GhostWhite',           color: 'f8f8ff'},     {name: 'Gold',                 color: 'ffd700'},     {name: 'GoldenRod',            color: 'daa520'},     {name: 'Gray',                 color: '808080'},     {name: 'Grey',                 color: '808080'},     {name: 'Green',                color: '008000'},     {name: 'GreenYellow',          color: 'adff2f'},     {name: 'HoneyDew',             color: 'f0fff0'},     {name: 'HotPink',              color: 'ff69b4'},     {name: 'IndianRed',            color: 'cd5c5c'},     {name: 'Indigo',               color: '4b0082'},     {name: 'Ivory',                color: 'fffff0'},     {name: 'Khaki',                color: 'f0e68c'},     {name: 'Lavender',             color: 'e6e6fa'},     {name: 'LavenderBlush',        color: 'fff0f5'},     {name: 'LawnGreen',            color: '7cfc00'},     {name: 'LemonChiffon',         color: 'fffacd'},     {name: 'LightBlue',            color: 'add8e6'},     {name: 'LightCoral',           color: 'f08080'},     {name: 'LightCyan',            color: 'e0ffff'},     {name: 'LightGoldenRodYellow', color: 'fafad2'},     {name: 'LightGray',            color: 'd3d3d3'},     {name: 'LightGrey',            color: 'd3d3d3'},     {name: 'LightGreen',           color: '90ee90'},     {name: 'LightPink',            color: 'ffb6c1'},     {name: 'LightSalmon',          color: 'ffa07a'},     {name: 'LightSeaGreen',        color: '20b2aa'},     {name: 'LightSkyBlue',         color: '87cefa'},     {name: 'LightSlateGray',       color: '778899'},     {name: 'LightSlateGrey',       color: '778899'},     {name: 'LightSteelBlue',       color: 'b0c4de'},     {name: 'LightYellow',          color: 'ffffe0'},     {name: 'Lime',                 color: '00ff00'},     {name: 'LimeGreen',            color: '32cd32'},     {name: 'Linen',                color: 'faf0e6'},     {name: 'Magenta',              color: 'ff00ff'},     {name: 'Maroon',               color: '800000'},     {name: 'MediumAquaMarine',     color: '66cdaa'},     {name: 'MediumBlue',           color: '0000cd'},     {name: 'MediumOrchid',         color: 'ba55d3'},     {name: 'MediumPurple',         color: '9370db'},     {name: 'MediumSeaGreen',       color: '3cb371'},     {name: 'MediumSlateBlue',      color: '7b68ee'},     {name: 'MediumSpringGreen',    color: '00fa9a'},     {name: 'MediumTurquoise',      color: '48d1cc'},     {name: 'MediumVioletRed',      color: 'c71585'},     {name: 'MidnightBlue',         color: '191970'},     {name: 'MintCream',            color: 'f5fffa'},     {name: 'MistyRose',            color: 'ffe4e1'},     {name: 'Moccasin',             color: 'ffe4b5'},     {name: 'NavajoWhite',          color: 'ffdead'},     {name: 'Navy',                 color: '000080'},     {name: 'OldLace',              color: 'fdf5e6'},     {name: 'Olive',                color: '808000'},     {name: 'OliveDrab',            color: '6b8e23'},     {name: 'Orange',               color: 'ffa500'},     {name: 'OrangeRed',            color: 'ff4500'},     {name: 'Orchid',               color: 'da70d6'},     {name: 'PaleGoldenRod',        color: 'eee8aa'},     {name: 'PaleGreen',            color: '98fb98'},     {name: 'PaleTurquoise',        color: 'afeeee'},     {name: 'PaleVioletRed',        color: 'db7093'},     {name: 'PapayaWhip',           color: 'ffefd5'},     {name: 'PeachPuff',            color: 'ffdab9'},     {name: 'Peru',                 color: 'cd853f'},     {name: 'Pink',                 color: 'ffc0cb'},     {name: 'Plum',                 color: 'dda0dd'},     {name: 'PowderBlue',           color: 'b0e0e6'},     {name: 'Purple',               color: '800080'},     {name: 'RebeccaPurple',        color: '663399'},     {name: 'Red',                  color: 'ff0000'},     {name: 'RosyBrown',            color: 'bc8f8f'},     {name: 'RoyalBlue',            color: '4169e1'},     {name: 'SaddleBrown',          color: '8b4513'},     {name: 'Salmon',               color: 'fa8072'},     {name: 'SandyBrown',           color: 'f4a460'},     {name: 'SeaGreen',             color: '2e8b57'},     {name: 'SeaShell',             color: 'fff5ee'},     {name: 'Sienna',               color: 'a0522d'},     {name: 'Silver',               color: 'c0c0c0'},     {name: 'SkyBlue',              color: '87ceeb'},     {name: 'SlateBlue',            color: '6a5acd'},     {name: 'SlateGray',            color: '708090'},     {name: 'SlateGrey',            color: '708090'},     {name: 'Snow',                 color: 'fffafa'},     {name: 'SpringGreen',          color: '00ff7f'},     {name: 'SteelBlue',            color: '4682b4'},     {name: 'Tan',                  color: 'd2b48c'},     {name: 'Teal',                 color: '008080'},     {name: 'Thistle',              color: 'd8bfd8'},     {name: 'Tomato',               color: 'ff6347'},     {name: 'Turquoise',            color: '40e0d0'},     {name: 'Violet',               color: 'ee82ee'},     {name: 'Wheat',                color: 'f5deb3'},     {name: 'White',                color: 'ffffff'},     {name: 'WhiteSmoke',           color: 'f5f5f5'},     {name: 'Yellow',               color: 'ffff00'},     {name: 'YellowGreen',          color: '9acd32'} ];    const genColorNameLightness = [     {name: 'pale',   value: 0.87},     {name: 'light',  value: 0.76},     {name: 'bright', value: 0.65},     {name: 'deep',   value: 0.35},     {name: 'dim',    value: 0.22},     {name: 'dark',   value: 0.12} ];    const genColorNameSaturation = [     {name: 'calm',  value: 0.72},     {name: 'dull',  value: 0.46},     {name: 'dirty', value: 0.21} ];    const genColorNameHue = [     {name: 'violet',  value: 285},     {name: 'purple',  value: 269},     {name: 'indigo',  value: 252},     {name: 'blue',    value: 241},     {name: 'cobalt',  value: 222},     {name: 'sky',     value: 211},     {name: 'aqua',    value: 193},     {name: 'cyan',    value: 177},     {name: 'jade',    value: 154},     {name: 'green',   value: 112},     {name: 'lime',    value:  74},     {name: 'yellow',  value:  54},     {name: 'mango',   value:  42},     {name: 'orange',  value:  30},     {name: 'amber',   value:  17},     {name: 'salmon',  value:  11},     {name: 'red',     value:   0},     {name: 'rose',    value: 335},     {name: 'magenta', value: 310} ];    function parseColorNameLightness(name)  {     for (const item of genColorNameLightness)      {         if (   name.startsWith(item.name)              ||     i1490(name.slice(0, item.name.length), item.name) <= 1                && !genColorNameHue.find(h => h.name.startsWith(name)))          {             return { value:     item.value,                       remaining: name.slice(item.name.length) };         }     }      return { value:     null,               remaining: name }; }    function parseColorNameSaturation(name)  {     for (const item of genColorNameSaturation)      {         if (   name.startsWith(item.name)              ||     i1490(name.slice(0, item.name.length), item.name) <= 1                && !genColorNameHue.find(h => h.name.startsWith(name)))          {             return { value:     item.value,                       remaining: name.slice(item.name.length) };         }     }      return { value:     null,               remaining: name }; }    function parseColorNameHue(name)  {     for (const item of genColorNameHue)      {         if (   name === item.name              || i1490(name.slice(0, item.name.length), item.name) <= 1)          {             return item.value;         }     }      return null; }    function parseColorName(_colorName)  {     let colorName = _colorName.replace(/\s+/g, '');       if (   colorName === 'black'          || i1490(colorName, 'black') <= 1)         return [0, 0, 0];      if (   colorName === 'white'          || i1490(colorName, 'white') <= 1)         return [0, 0, 1];               const grayVariants = ['gray', 'grey'];      let isGray = false;     let gl     = 0.5;      for (const grayVariant of grayVariants)      {         if (   colorName.endsWith(grayVariant)              || i1490(colorName.slice(-grayVariant.length), grayVariant) <= 1)          {             isGray = true;                      const grayPrefix = colorName.slice(0, -grayVariant.length);                          if (grayPrefix)              {                 const { value } = parseColorNameLightness(grayPrefix);                                  if (value !== null)                      gl = value;             }              break;         }     }       if (isGray)         return [0, 0, gl];       let h = null;     let s = null;     let l = null;                     let result  = parseColorNameLightness(colorName);         l       = result.value;     let remName = result.remaining;          result  = parseColorNameSaturation(remName);         s       = result.value;         remName = result.remaining;          h       = parseColorNameHue(remName);                      if (   h === null          || s === null          || l === null)      {         h = null;         s = null;         l = null;          result  = parseColorNameSaturation(colorName);         s       = result.value;         remName = result.remaining;          result  = parseColorNameLightness(remName);         l       = result.value;         remName = result.remaining;          h       = parseColorNameHue(remName);     }       if (h === null) return null;      if (l === null) l = 0.5;     if (s === null) s = 1.0;           return [h / 360, s, l]; }    function createColorName(rgb) {     if (rgb.length > 3 && rgba[3] == 0)         return 'transparent';       const hsl = e48(rgb);      let   h = hsl[0] * 360;      while (h >= 360) h -= 360;     while (h <    0) h += 360;          const s = hsl[1];     const l = hsl[2];            if (l >= 0.94) return 'white';     else if (l <  0.06) return 'black';       let strH = '';     let strS = '';     let strL = '';            if (l >= 0.81 && l < 0.94) strL = 'pale ';     else if (l >= 0.69 && l < 0.81) strL = 'light ';     else if (l >= 0.56 && l < 0.69) strL = 'bright ';     else if (l >= 0.31 && l < 0.44) strL = 'deep ';     else if (l >= 0.19 && l < 0.31) strL = 'dim ';     else if (l >= 0.06 && l < 0.19) strL = 'dark ';           if (l > 0.25 && l < 0.75)      {              if (s >= 0.62 && s < 0.88) strS = 'calm ';         else if (s >= 0.31 && s < 0.62) strS = 'dull ';         else if (s >= 0.12 && s < 0.31) strS = 'dirty ';     }       if (s >= 0.12)     {              if (h < 293 && h >= 278) strH = 'violet';         else if (h < 278 && h >= 259) strH = 'purple';         else if (h < 259 && h >= 248) strH = 'indigo';         else if (h < 248 && h >= 233) strH = 'blue';         else if (h < 233 && h >= 221) strH = 'cobalt';         else if (h < 221 && h >= 201) strH = 'sky';         else if (h < 201 && h >= 185) strH = 'aqua';         else if (h < 185 && h >= 169) strH = 'cyan';         else if (h < 169 && h >= 139) strH = 'jade';         else if (h < 139 && h >=  86) strH = 'green';         else if (h <  86 && h >=  63) strH = 'lime';         else if (h <  63 && h >=  45) strH = 'yellow';         else if (h <  45 && h >=  40) strH = 'mango';         else if (h <  40 && h >=  21) strH = 'orange';         else if (h <  21 && h >=  13) strH = 'amber';         else if (h <  13 && h >=   8) strH = 'salmon';         else if (h <   8 || h >= 352) strH = 'red';         else if (h < 352 && h >= 328) strH = 'rose';         else if (h < 328 && h >= 293) strH = 'magenta';         else              console.error('error parsing hue name');     }     else          strH = 'gray';       return strL + strS + strH; } 


var _clipboard = '';    function p867(str)  {     if (subscribed())     {         if (   navigator.clipboard              && window.isSecureContext)              return navigator.clipboard.writeText(str);          else          {             const prevActive = document.activeElement;             const textArea   = document.createElement('textarea');              textArea.value = str;              textArea.style.position = 'fixed';             textArea.style.left     = '-999999px';             textArea.style.top      = '-999999px';                          document.body.appendChild(textArea);                          textArea.focus();             textArea.select();                          return new Promise((res, rej) =>              {                 document.execCommand('copy') ? res() : rej();                 textArea.remove();                  prevActive.focus();             });         }     }     else         _clipboard = str; }    function k868()  {     if (subscribed())     {         if (   navigator.clipboard              && window.isSecureContext)              return navigator.clipboard.readText();          else          {             let textArea = document.createElement('textarea');              textArea.style.position = 'fixed';             textArea.style.left     = '-999999px';             textArea.style.top      = '-999999px';                          document.body.appendChild(textArea);                          textArea.focus({preventScroll: true});             textArea.select();                          return new Promise((res, rej) =>              {                 document.execCommand('paste') ? res(textArea.value) : rej();                 textArea.remove();             });         }     }     else         return new Promise((res, rej) => res(_clipboard)); }


function v1048(key, tag)  {     return key.substring(0, tag.length+1) == tag + ' '; }    function a1049(key, tag) {     return key.substring(tag.length+1); }    function j1050(key) { return v1048(key, x877); } function d1051(key) { return v1048(key, y875); } function t1052(key) { return v1048(key, k876); }    function m1053(key) { return a1049(key, x877); } function x1054(key) { return a1049(key, y875); } function n1055(key) { return a1049(key, k876); }


const c963               = '\uFFFD'; const e964            = '?';      const h965           = '?'; const w966        = h965;  const NAME_SEPARATOR         = ' '; const c967       = ' > '; const   p968       = ' / '; const  m969       = ':';  const w970          = ' •'; const  e971          = ' ◇';       const  d972    = '<svg width="13" height="11" viewBox="0 1 13 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.3645 1.82058L10.2676 0.599976L5.1191 8.58091L2.44314 6.06144L0.800003 7.67327L5.54161 12.1958L12.3645 1.82058Z" fill="#2AD400"/></svg>';
const b973    = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="#F43D3D"/></svg>';    
 const  b974     = '<svg width="12" height="11" viewBox="0 0 12 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M11.1 0.998457L9.41674 0L4.20109 8.01592L1.50123 5.4381L0.1 6.77599L4.52397 11L11.1 0.998457Z" fill="#3FF911"/></svg>';
const k975     = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="#FF3E3E"/></svg>';
 const  c976 = '<svg width="11" height="11" viewBox="0 0 11 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.7157 0.893364L9.55198 0.139526L4.15187 8.47598L1.20316 5.59262L0.248535 6.5928L4.41886 10.5815L5.04702 9.60025L10.7157 0.893364Z" fill="black"/></svg>';
const x977 = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.13479 0.1521L0.1521 1.13479L3.51727 4.49997L0.152106 7.86514L1.1348 8.84783L4.49997 5.48266L7.86511 8.8478L8.8478 7.86511L5.48266 4.49997L8.84781 1.13482L7.86511 0.152129L4.49997 3.51727L1.13479 0.1521Z" fill="black"/></svg>';
 const  z978  = '<svg width="12" height="11" viewBox="0 0 12 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M11.1 0.998457L9.41672 0L4.20107 8.01592L1.50121 5.4381L0.0999756 6.77599L4.52395 11L11.1 0.998457Z" fill="white"/></svg>';
const f979  = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="white"/></svg>';
 const  l980     = '<svg width="12" height="11" viewBox="0 0 12 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M11.1 0.998457L9.41675 0L4.2011 8.01592L1.50124 5.4381L0.100006 6.77599L4.52398 11L11.1 0.998457Z" fill="white"/></svg>';
const i981     = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="white"/></svg>';
   function c982(color = true) {     return i4006          ? (color ? b974  : z978 )          : (color ? d972 : c976); }    function t983(color = true) {     return i4006          ? (color ? k975  : f979 )          : (color ? b973 : x977); }


var showDebugInfo = false;  var debugFlag1    = false;    function k961(nodeIds) {     let str = '';      for (let i = 0; i < nodeIds.length; i++)     {         if (i > 0) str += ', ';         str += nodeIds[i];     }      return str; }    function e962(nodes) {     let str = '';      nodes.map(n => n ? n.id : 'undefined').join(', ');                                return str; }    function updateDebugInfo() {     if (showDebugInfo)     {         debugInfoText.style.display = 'inline-block';          debugInfoText.innerHTML =                         'pan = '  + graph.currentPage.pan.x.toFixed(2) + ', ' + graph.currentPage.pan.y.toFixed(2)             + '<br/>' + 'zoom = ' + graph.currentPage.zoom.toFixed(4);     }     else         debugInfoText.style.display = 'none'; }


const i1040   = 0,       x1041 = 1,       n1042 = 2,       h1043  = 3;    class l1044 {     initial;     current;            constructor()     {         this.reset();     }            set(seed)     {         this.initial = seed;         this.current = seed;     }                rotate()     {         this.current = (this.current + 0x7ed55d16) + (this.current << 12);         this.current = (this.current ^ 0xc761c23c) ^ (this.current >> 19);         this.current = (this.current + 0x165667b1) + (this.current <<  5);         this.current = (this.current + 0xd3a2646c) ^ (this.current <<  9);         this.current = (this.current + 0xfd7046c5) + (this.current <<  3);         this.current = (this.current ^ 0xb55a4f09) ^ (this.current >> 16);     }                next()     {         const seed = this.current;         this.rotate();         return seed;     }        reset()     {         this.current = this.initial;     } };    class Noise { 	interpolation = h1043; 	clip = false;  	seed = new l1044();  	v0; 	v1; 	v2; 	v3;  	step = 0;       constructor(seed = 0)     {         this.seed.set(seed);         this.reset();     }       next(scale = 1)     {                  scale = Math.max(1, scale);          let next = this.v1;          if (this.step >= 1)         {                                   this.seed.rotate();              this.v0 = this.v1;                      this.v1 = this.v2;             this.v2 = this.v3;                      this.v3 = b1045(this.seed.current);              this.step -= 1;         }                    switch (this.interpolation)         {             case i1040:             {                 next = this.v1;                 break;             }             case x1041:             {                 next = this.v1 + this.step * (this.v2 - this.v1);                 break;             }             case n1042:             {                 const ft = this.step * Math.PI;                 const f  = (1 - Math.cos(ft)) * 0.5;                                  next = this.v1 + f * (this.v2 - this.v1);                 break;             }             case h1043:             {                 const p = (this.v3 - this.v2) - (this.v0 - this.v1);                 const q = (this.v0 - this.v1) - p;                 const r =  this.v2 - this.v0;                 const s =  this.v1;                  const val =                        p * cube(this.step)                      + q * sqr(this.step)                      + r * this.step                      + s;                  next = this.clip                      ? Math.max(0, Math.min(val, 1))                      : val;                  break;             }         }          this.step += 1 / scale;          return next;     }          reset()     {         this.seed.reset();          this.v0 = b1045(this.seed.current); this.seed.rotate();         this.v1 = b1045(this.seed.current); this.seed.rotate();         this.v2 = b1045(this.seed.current); this.seed.rotate();         this.v3 = b1045(this.seed.current); this.seed.rotate();          this.step = 0;     } }   function b1045(x) {     return x / -0x7fffffff; }


const settings = {     debugMode:                     false,              f2551:         false,     e2552:              0.35,     objectCenterSize:              18,     w4020:               500,     showPages:                     false,     showAllColorSpaces:            false,     showNodeIcons:                 true,     showBoolValues:                true,     separateThousands:             true,     invertSimpleMathParamOrder:    true,     activateDeactiatesOthers:      true,     preferHtmlColorNames:          false,     randomShiftR:                  true,     colorShiftR:                   true,      showSnapshots:                 false,     showRestartInfo:               true,     showColorLegendInMenus:        false,     showClearUndoWarning:          true,     shareUsageMetrics:             true,     showObjectCount:               true,     showDebugMenu:                 false,              showNodeId:                    false,      s2553:           false,     enableAsserts:                 false,      showTooltipLongText:           false,     showTooltipLists:              false,     showTooltipColorInterpolation: true,     showTooltipColorBlindness:     true,     showTooltipColorContrast:      true,     showTooltipColorNames:         true,     showTooltipAscii:              true,      enableBetaFeatures:            false,                  logThreadMessages:             false,     logDataMessages:               false,     logMessages:                   false,      logActions:                    false,                   logLoading:                    false,      logRequests:                   false,      logValueUpdates:               false,      logObjectUpdates:              false,     logStyleUpdates:               false,                  logRawLoadPages:               false,      logRawLoadNodes:               false,      logRawLoadConnections:         false,               logRawSavePages:               false,      logRawSaveNodes:               false,      logRawSaveConnections:         false,               logRawRequests:                false,      logRawValues:                  false,      sessionId:                     '' };    function t3592(l3660, value) {     switch (l3660)     {         case 'debugMode':                     settings.debugMode                     = value;  break;                          case 'enableZoomedOutParams':         settings.f2551         = value;  break;         case 'minZoomForParams':              settings.e2552              = value;  break;         case 'objectCenterSize':              settings.objectCenterSize              = value;  break;         case 'objectBatchSize':               settings.w4020               = value;  break;         case 'showPages':                     settings.showPages                     = value;  break;         case 'showAllColorSpaces':            settings.showAllColorSpaces            = value;  break;         case 'showNodeIcons':                 settings.showNodeIcons                 = value;  break;         case 'showBoolValues':                settings.showBoolValues                = value;  break;         case 'separateThousands':             settings.separateThousands             = value;  break;         case 'invertSimpleMathParamOrder':    settings.invertSimpleMathParamOrder    = value;  break;         case 'activateDeactiatesOthers':      settings.activateDeactiatesOthers      = value;  break;         case 'preferHtmlColorNames':          settings.preferHtmlColorNames          = value;  break;         case 'randomShiftR':                  settings.randomShiftR                  = value;  break;         case 'colorShiftR':                   settings.colorShiftR                   = value;  break;                  case 'showSnapshots':                 settings.showSnapshots                 = value;  break;         case 'showRestartInfo':               settings.showRestartInfo               = value;  break;         case 'showColorLegendInMenus':        settings.showColorLegendInMenus        = value;  break;         case 'showClearUndoWarning':          settings.showClearUndoWarning          = value;  break;         case 'shareUsageMetrics':             settings.shareUsageMetrics             = value;  break;         case 'showObjectCount':               settings.showObjectCount               = value;  break;         case 'showDebugMenu':                 settings.showDebugMenu                 = value;  break;                                  case 'showNodeId':                    settings.showNodeId                    = value;  break;         case 'showTransformPoints':           settings.s2553           = value;  break;         case 'enableAsserts':                 settings.enableAsserts                 = value;  break;          case 'showTooltipLists':              settings.showTooltipLists              = value;  break;         case 'showTooltipLongText':           settings.showTooltipLongText           = value;  break;         case 'showTooltipColorInterpolation': settings.showTooltipColorInterpolation = value;  break;         case 'showTooltipColorBlindness':     settings.showTooltipColorBlindness     = value;  break;         case 'showTooltipColorContrast':      settings.showTooltipColorContrast      = value;  break;         case 'showTooltipColorNames':         settings.showTooltipColorNames         = value;  break;         case 'showTooltipAscii':              settings.showTooltipAscii              = value;  break;          case 'enableBetaFeatures':            settings.enableBetaFeatures            = value;  break;                             case 'logThreadMessages':             settings.logThreadMessages             = value;  break;         case 'logDataMessages':               settings.logDataMessages               = value;  break;         case 'logMessages':                   settings.logMessages                   = value;  break;          case 'logActions':                    settings.logActions                    = value;  break;         case 'logLoading':                    settings.logLoading                    = value;  break;         case 'logRequests':                   settings.logRequests                   = value;  break;         case 'logValueUpdates':               settings.logValueUpdates               = value;  break;         case 'logObjectUpdates':              settings.logObjectUpdates              = value;  break;         case 'logStyleUpdates':               settings.logStyleUpdates               = value;  break;                             case 'logRawLoadPages':               settings.logRawLoadPages               = value;  break;         case 'logRawLoadNodes':               settings.logRawLoadNodes               = value;  break;         case 'logRawLoadConnections':         settings.logRawLoadConnections         = value;  break;                          case 'logRawSavePages':               settings.logRawSavePages               = value;  break;         case 'logRawSaveNodes':               settings.logRawSaveNodes               = value;  break;         case 'logRawSaveConnections':         settings.logRawSaveConnections         = value;  break;                          case 'logRawRequests':                settings.logRawRequests                = value;  break;         case 'logRawValues':                  settings.logRawValues                  = value;  break;          case 'sessionId':                     settings.sessionId                     = value;  break;     }        switch (l3660)     {         case 'objectCenterSize':             k2496(             {                 cmd:             'figUpdateObjectCenterSize',                 objectCenterSize: settings.objectCenterSize             });             break;     } }    function c3516(l3660, valid, value, save = true) {     switch (l3660)     {         case 'debugMode':                     t3659(valid, l3660, value, q722                    ); break;                        case 'enableZoomedOutParams':         t3659(valid, l3660, value, h648        ); break;         case 'showPages':                     t3659(valid, l3660, value, k652                    ); break;         case 'showAllColorSpaces':            t3659(valid, l3660, value, t654           ); break;         case 'showNodeIcons':                 t3659(valid, l3660, value, f655                ); break;         case 'showBoolValues':                t3659(valid, l3660, value, l657               ); break;         case 'separateThousands':             t3659(valid, l3660, value, o658            ); break;         case 'invertSimpleMathParamOrder':    t3659(valid, l3660, value, i659   ); break;         case 'activateDeactiatesOthers':      t3659(valid, l3660, value, menuItemActivateDeactiatesOthers     ); break;         case 'preferHtmlColorNames':          t3659(valid, l3660, value, menuItemPreferHtmlColorNames         ); break;         case 'randomShiftR':                  t3659(valid, l3660, value, menuItemRandomShiftR                 ); break;         case 'colorShiftR':                   t3659(valid, l3660, value, menuItemColorShiftR                  ); break;          case 'showSnapshots':                 t3659(valid, l3660, value, menuItemShowSnapshots                ); break;         case 'showRestartInfo':               t3659(valid, l3660, value, menuItemShowRestartInfo              ); break;         case 'showColorLegendInMenus':        t3659(valid, l3660, value, m656       ); break;         case 'showClearUndoWarning':          t3659(valid, l3660, value, s660         ); break;         case 'shareUsageMetrics':             t3659(valid, l3660, value, c661            ); break;         case 'showObjectCount':               t3659(valid, l3660, value, m663              ); break;         case 'showDebugMenu':                 t3659(valid, l3660, value, g664                ); break;                                case 'showNodeId':                    t3659(valid, l3660, value, v667                   ); break;         case 'showTransformPoints':           t3659(valid, l3660, value, c668          ); break;         case 'enableAsserts':                 t3659(valid, l3660, value, q669                ); enableAsserts = value; break;                  case 'showTooltipLists':              t3659(valid, l3660, value, u643             ); break;         case 'showTooltipLongText':           t3659(valid, l3660, value, j642          ); break;         case 'showTooltipColorInterpolation': t3659(valid, l3660, value, u644); break;         case 'showTooltipColorBlindness':     t3659(valid, l3660, value, g647    ); break;         case 'showTooltipColorContrast':      t3659(valid, l3660, value, r645     ); break;         case 'showTooltipColorNames':         t3659(valid, l3660, value, u646        ); break;         case 'showTooltipAscii':              t3659(valid, l3660, value, g647    ); break;          case 'enableBetaFeatures':            t3659(valid, l3660, value, menuItemEnableBetaFeatures           ); break;                                case 'logThreadMessages':             t3659(valid, l3660, value, f723            ); break;         case 'logDataMessages':               t3659(valid, l3660, value, q724              ); break;         case 'logMessages':                   t3659(valid, l3660, value, w725                  ); break;          case 'logActions':                    t3659(valid, l3660, value, e726                   ); break;         case 'logLoading':                    t3659(valid, l3660, value, d727                   ); break;         case 'logRequests':                   t3659(valid, l3660, value, v728                  ); break;         case 'logValueUpdates':               t3659(valid, l3660, value, x729              ); break;         case 'logObjectUpdates':              t3659(valid, l3660, value, t730             ); break;         case 'logStyleUpdates':               t3659(valid, l3660, value, y731              ); break;                                case 'logRawLoadPages':               t3659(valid, l3660, value, t732              ); break;         case 'logRawLoadNodes':               t3659(valid, l3660, value, e733              ); break;         case 'logRawLoadConnections':         t3659(valid, l3660, value, l734        ); break;                                case 'logRawSavePages':               t3659(valid, l3660, value, k735              ); break;         case 'logRawSaveNodes':               t3659(valid, l3660, value, i736              ); break;         case 'logRawSaveConnections':         t3659(valid, l3660, value, p737        ); break;                                case 'logRawRequests':                t3659(valid, l3660, value, o738               ); break;         case 'logRawValues':                  t3659(valid, l3660, value, w739                 ); break;     }        if (   save         && l3660 != 'showAllColorSpaces')         t2555(l3660, w937(value)); }    function t3659(valid, setting, value, menu) {     if (valid)          settings[setting] = value;         switch (setting)     {         case 'showNodeId':             k2496(             {                 cmd:    'figUpdateShowIds',                 f2799: settings.showNodeId             });             break;     }       if (menu)         menu.a2870(settings[setting]); }    function updateSettingsMenus() {     q722                    .c326(settings.debugMode                    );                      h648        .a2870(settings.f2551        );     k652                    .a2870(settings.showPages                    );     t654           .a2870(settings.showAllColorSpaces           );     f655                .a2870(settings.showNodeIcons                );     l657               .a2870(settings.showBoolValues               );     o658            .a2870(settings.separateThousands            );     i659   .a2870(settings.invertSimpleMathParamOrder   );     menuItemActivateDeactiatesOthers     .a2870(settings.activateDeactiatesOthers     );     menuItemPreferHtmlColorNames         .a2870(settings.preferHtmlColorNames         );     menuItemRandomShiftR                 .a2870(settings.randomShiftR                 );     menuItemColorShiftR                  .a2870(settings. colorShiftR                 );      menuItemShowSnapshots                .a2870(settings.showSnapshots                );     menuItemShowRestartInfo              .a2870(settings.showRestartInfo              );     m656       .a2870(settings.showColorLegendInMenus       );     s660         .a2870(settings.showClearUndoWarning         );     c661            .a2870(settings.shareUsageMetrics            );     m663              .a2870(settings.showObjectCount              );     g664                .a2870(settings.showDebugMenu                );                      v667                   .a2870(settings.showNodeId                   );     c668          .a2870(settings.s2553          );     q669                .a2870(settings.enableAsserts                );      u643             .a2870(settings.showTooltipLists             );     j642          .a2870(settings.showTooltipLongText          );     u644.a2870(settings.showTooltipColorInterpolation);     g647    .a2870(settings.showTooltipColorBlindness    );     r645     .a2870(settings.showTooltipColorContrast     );     u646        .a2870(settings.showTooltipColorNames        );     menuItemShowTooltipAscii             .a2870(settings.showTooltipAscii             );                            f723            .a2870(settings.logThreadMessages            );     q724              .a2870(settings.logDataMessages              );     w725                  .a2870(settings.logMessages                  );      e726                   .a2870(settings.logActions                   );                        d727                   .a2870(settings.logLoading                   );     v728                  .a2870(settings.logRequests                  );     x729              .a2870(settings.logValueUpdates              );     t730             .a2870(settings.logObjectUpdates             );     y731              .a2870(settings.logStyleUpdates              );                        e733              .a2870(settings.logRawLoadPages              );     e733              .a2870(settings.logRawLoadNodes              );     l734        .a2870(settings.logRawLoadConnections        );                          k735              .a2870(settings.logRawSaveNodes              );     i736              .a2870(settings.logRawSaveNodes              );     p737        .a2870(settings.logRawSaveConnections        );                      o738               .a2870(settings.logRawRequests               );     w739                 .a2870(settings.logRawValues                 ); }    function updateMenuItemShowPages() {     r2559('showPages', w937(settings.showPages));     graph.s2087();     y186.update(); }    function updateMenuItemShowSnapshots() {     r2559('showSnapshots', w937(settings.showSnapshots));      snapshotBar.style.display = settings.showSnapshots ? 'block' : 'none';      }    function updateMenuItemShowAllColorSpaces() {     r2559('showAllColorSpaces', w937(settings.showAllColorSpaces));      graph.nodes         .filter(n => r1177.includes(n.type))         .forEach(n => n.o3030()); }    function updateMenuItemShowNodeIcons() {     graph.nodes.forEach(n => n.o3030()); }    function updateMenuItemShowBoolValues() {     graph.nodes         .filter(n => n.params.find(p => p.type == m1091) != null)         .forEach(n => n.o3030()); }    function updateMenuItemSeparateThousands() {     graph.nodes         .filter(n => n.params.find(p => p.type == m1091) != null)         .forEach(n => n.o3030()); }    function updateMenuItemInvertSimpleMathParamOrder() {     graph.nodes         .filter(n => n.type == k1113)         .forEach(n => n.o3030()); }    function updateMenuItemShowColorLegendInMenus() {     for (const menu of u575)         menu.items.forEach(i => i.l3453()); }    function enableFeatures(sub) {     enableMenuItem(menuItemSetValueNames,      true, sub);     enableMenuItem(menuItemEnableBetaFeatures, true, sub);       enableMenuItem(menuItemShowRestartInfo,    true, sub);     enableMenuItem(menuItemValueName,          true, sub);     enableMenuItem(menuItemObjectName,         true, sub);        enableMenuItem(j692,              true, sub);           enableMenuItem(q694,            true, sub);     enableMenuItem(o671,         true, sub);     enableMenuItem(menuItemSaveSelected,       true, sub);     enableMenuItem(u695,              true, sub);       enableMenuItem(y701,           true, sub);     enableMenuItem(r703,              true, sub);     enableMenuItem(x3474,           true, sub);          enableMenuItem(c705,       true, sub);     enableMenuItem(n706,        true, sub);          enableMenuItem(m720,        true, sub);       enableMenuItem(menuItemVectorSep1,         true, sub, true);     enableMenuItem(menuItemVectorVertex,       true, sub, true);     enableMenuItem(menuItemVectorEdge,         true, sub, true);     enableMenuItem(menuItemVectorRegion,       true, sub, true);     enableMenuItem(menuItemVectorNetwork,      true, sub, true);     enableMenuItem(menuItemBooleanShape,       true, sub, true);     enableMenuItem(menuItemSaveTemplate,       true, sub);     enableMenuItem(d721,    true, sub);       updatePanelButton();       graph.nodes.forEach(n => n.q3494(sub)); }    function updatePanelButton() {     if (w567     ) w567     .div.style.display = !(settings.enableBetaFeatures && subscribed()) ? 'inline-block' : 'none';     if (btnDecoration) btnDecoration.div.style.display =  (settings.enableBetaFeatures && subscribed()) ? 'inline-block' : 'none'; }    function enableMenuItem(menuItem, enable, sub, beta = false) {     if (!menuItem) return;      menuItem.enabled = enable;     menuItem.sub     = sub;      menuItem.c326(           !beta         || beta && settings.enableBetaFeatures);      menuItem.update(); }    function updateMenuItemShowDebugMenu() {     updateElementDisplay(t672.div, settings.showDebugMenu);      h576.update(         r995(h576.div).x + 6,         r995(h576.div).y - 4,         true); }     function updateElementDisplay(menuItem, enable) {     menuItem.style.display = enable ? 'block' : 'none'; }    function loadLocalSettings() {     g2554('debugMode'                    );              g2554('enableZoomedOutParams'        );     g2554('minZoomForParams'             );     g2554('objectCenterSize'             );     g2554('objectBatchSize'              );     g2554('showNodeIcons'                );     g2554('showBoolValues'               );     g2554('separateThousands'            );     g2554('invertSimpleMathParamOrder'   );     g2554('activateDeactiatesOthers'     );     g2554('preferHtmlColorNames'         );     g2554('randomShiftR'                 );     g2554('colorShiftR'                  );      g2554('showSnapshots'                );     g2554('showRestartInfo'              );     g2554('showColorLegendInMenus'       );     g2554('showPages'                    );     g2554('showClearUndoWarning'         );     g2554('shareUsageMetrics'            );     g2554('showObjectCount'              );     g2554('showDebugMenu'                );              g2554('showNodeId'                   );     g2554('showTransformPoints'          );     g2554('enableAsserts'                );      g2554('showTooltipLists'             );     g2554('showTooltipLongText'          );     g2554('showTooltipColorInterpolation');     g2554('showTooltipColorBlindness'    );     g2554('showTooltipColorContrast'     );     g2554('showTooltipColorNames'        );     g2554('showTooltipAscii'             );      g2554('enableBetaFeatures'           );                  g2554('logThreadMessages'            );     g2554('logDataMessages'              );     g2554('logMessages'                  );      g2554('logActions'                   );                  g2554('logLoading'                   );     g2554('logRequests'                  );     g2554('logValueUpdates'              );     g2554('logObjectUpdates'             );     g2554('logStyleUpdates'              );                  g2554('logRawLoadPages'              );     g2554('logRawLoadNodes'              );     g2554('logRawLoadConnections'        );              g2554('logRawSavePages'              );     g2554('logRawSaveNodes'              );     g2554('logRawSaveConnections'        );              g2554('logRawRequests'               );     g2554('logRawValues'                 ); }


const z1056           = 'LIST#';  const f1057    = 'NLIST#'; const   g1058    = 'TLIST#'; const  a1059    = 'SLIST#';   const o1060            = 'NULL'; const o1061             = 'VAR'; const l1062       = 'VARGRP'; const s1063             = 'FEEDBK'; const e1064               = 'REPT'; const m1065                = 'CACHE'; const p1066               = 'FRZ'; const v1067                = 'TIMER'; const d1068           = 'VNAME'; const j1352 = 'GVNAMES'; const l1353     = 'VNAMES'; const p1354          = 'ONAME';  const v1069              = 'CMB'; const t1070         = 'LSASIT'; const j1071              = 'EXTR'; const z1072            = 'SETP'; const q1073            = 'GETP'; const f1074              = 'SUBLST'; const k1075               = 'UNIQ'; const y1349         = 'RORD'; const x1350           = 'SHFTLST'; const u1076         = 'REVLST'; const j1351          = 'BUKLST'; const l1077                 = 'SORT'; const y1078               = 'CLMN'; const v1079                 = 'CELL'; const k1080                 = 'LIST'; const n1081           = 'COUNT'; const OBJECT_COUNT         = 'OBJCOUNT'; const x1082             = 'LCONT'; const p1083               = 'SELECT'; const f1360     = 'LSTSEL'; const z1084              = 'IF'; const s1085               = 'LSTFLT';   const j1087            = 'ANY#';   const v1088 = [     z1056,     f1057,     g1058,     a1059,     v1069,     j1071,     z1072,     q1073,     f1074,     k1080,     n1081,     x1082,     e1064 ];   const x1089 = [            z1056,     f1057,       g1058,      a1059 ];   const o1086                 = 'ITER';   const h1108             = 'PROB';   const HOLD                    = 'HOLD';   const m1091            = 'NUM#';   const s1092                  = 'NUM';    const b1355        = 'NPREC';    const l1093             = 'NSIGN';    const v1094         = 'ABS';    const i1356         = 'NEG';    const t1095            = 'ROUND';    const n1357         = 'QUANT';    const m1096    = 'SMINMAX';    const u1097           = 'MINMAX';    const d1098           = 'LIM';    const z1099            = 'NCURVE';    const m1358              = 'NMAP';    const j1359             = 'NBIAS';    const l1100              = 'NANISNUM'; const c1101         = 'CONST';   const l1102         = 'DATE';   const a1103         = 'SEQ';   const g1104            = 'RANGE';   const a1105             = 'WAVE';   const e1106           = 'RAND';   const d1107            = 'NOISE';   const m1109       = 'ACCUM';   const s1110      = 'LERP';  const o1111            = 'SOLVE'; const g1112          = 'NANIM';  const k1113      = 'SMATH';   const p1114             = 'MATH';   const b1115              = 'ADD';    const q1116         = 'SUB';    const w1117         = 'MUL';    const s1118           = 'DIV';    const m1119           = 'MOD';    const x1120         = 'EXP';  const g1121          = 'NBOOL';   const a1122              = 'NOT'; const f1123              = 'AND'; const d1124               = 'OR'; const h1125              = 'XOR';  const q1126        = 'COND'; const o1127            = 'EQ'; const v1128        = 'NE'; const l1129             = 'LT'; const y1130    = 'LE'; const z1131          = 'GT'; const i1132 = 'GE';  const z1133             = 'TRIG';   const j1134              = 'SIN';    const i1135              = 'COS';    const c1136              = 'TAN'; const x1137            = 'ATAN2';  const j1138           = 'CNVANG';   const r1090 = [     o1060,     o1061,     l1062,     ...v1088,     t1070,     j1071,     z1072,     q1073,     f1074,     k1075,     y1349,     x1350,     u1076,     j1351,     y1078,     l1077,     v1079,     k1080,     p1083,     f1360,     z1084,     s1085,     s1063,     e1064,          o1086,     h1108,     HOLD,     m1065,     p1066,     v1067,     d1068,     j1352,     l1353,     p1354 ];   const z1139 = [     p1114,     k1113,     b1115,     q1116,     w1117,     s1118,     m1119,     x1120 ];   const n1140 = [     g1121,     a1122,     f1123,     d1124,     h1125 ];   const l1141 = [     q1126,     o1127,     v1128,     l1129,     y1130,     z1131,     i1132 ];   const c1142 = [     z1133,     j1134,     i1135,     c1136,     x1137 ];   const i1143     = 'TEXT#'; const e1144           = 'TEXT'; const d1145    = 'TLEN'; const f1146      = 'TTRIM'; const i1147 = 'TSUB'; const v1148  = 'TCONT'; const t1149      = 'TCASE'; const d1150   = 'TREPL'; const q1151      = 'TJOIN'; const c1152       = 'TPAD'; const r1153   = 'TCMP'; const b1154      = 'TCHAR'; const f1155   = 'TUNI'; const c1156  = 'INDEX'; const g1157 = 'N2T'; const w1158  = 'C2T'; const z1159 = 'T2N'; const j1160  = 'T2C'; const p1161     = 'TSPLT'; const z3504      = 'TJSON'; const v1163       = 'TCSV'; const o1164     = 'FETCH'; const t1165      = 'TFILE';   const g1166 = [     m1091,     f1057,     s1092,     b1355,     l1093,     v1094,     i1356,     t1095,     n1357,     m1096,     u1097,     d1098,     z1099,     m1358,     j1359,     l1100,     c1101,     l1102,     a1103,     g1104,     a1105,     e1106,     d1107,     m1109,     s1110,     o1111,     g1112,     g1157,     b1154,      ...z1139,     ...n1140,     ...l1141,     ...c1142,      j1138,     j1351 ];   const h1167 = [     i1143,     g1058,     e1144,     d1145,     f1146,     i1147,     v1148,     t1149,     q1151,     c1152,     d1150,     r1153,     f1155,     c1156,     z1159,     j1160,     p1161,     z3504,     v1163,     o1164,     t1165 ];   const a1168        = 'COL#';   const g1169              = 'COL';    const y1170        = 'CVAL';   const t1171      = 'CCOR';   const n1172   = 'COLP3'; const s1173     = 'CCNT';   const y1174         = 'BLND';   const m1175  = 'CLERP';  const d1176        = 'CBLND';   const r1177 = [     a1168,     g1169,     t1171,     n1172,     y1174,     m1175,     d1176,     w1158 ];   const a1178          = 'FILL#'; const a1179                = 'FILL'; const b1180          = [a1178, a1179];    const i1181        = 'STRK#'; const s1182              = 'STRK'; const b1183        = [i1181, s1182];    const g1190  = 'STRKSD#'; const w1191        = 'STRKSD'; const b1192  = [g1190, w1191];  const i1184    = 'CSTOP#'; const i1185          = 'CSTOP'; const x1186    = [i1184, i1185];    const q1187      = 'GRAD#'; const y1188            = 'GRAD'; const d1189      = [q1187, y1188];    const j1193 = 'RCRN#'; const q1194       = 'RCRN'; const y1195 = [j1193, q1194];  const d1196   = 'DRSH#'; const h1197         = 'DRSH'; const u1198   = [d1196, h1197];   const l1199  = 'INSH#'; const x1200        = 'INSH'; const y1201  = [l1199, x1200];   const h1202    = 'LBLR#'; const o1203          = 'LBLR'; const v1204    = [h1202, o1203];   const k1205     = 'BBLR#'; const d1206           = 'BBLR'; const j1207     = [k1205, d1206];   const t1208    = 'MASK#'; const o1209          = 'MASK'; const c1210    = [t1208, o1209];   const k1211   = 'BLEND#'; const f1212         = 'BLEND'; const v1213   = [k1211, f1212];   const x1214 = [     ...b1192,     ...y1195,     ...u1198,     ...y1201,     ...v1204,     ...j1207,     ...v1213,     ...c1210 ];   const a1215 = [            a1168,              a1178,          q1187,            i1181,     g1190,      d1196,     l1199,       h1202,        k1205,      k1211,       t1208 ];   const w1216           = 'CSTL';     const g1217           = 'SHP#';    const m1218       = 'RECT#'; const g1219             = 'RECT';   const w1220       = [m1218, g1219];   const p1221            = 'LINE#'; const i1222                  = 'LINE';  const w1223            = [p1221, i1222];     const a1224         = 'ELPS#'; const c1225               = 'ELPS';  const r1226         = [a1224, c1225];   const d1227         = 'TRPZ#'; const c1228               = 'TRPZ'; const a1229         = [d1227, c1228];   const b1236         = 'POLY#'; const e1237               = 'POLY';  const g1238         = [b1236, e1237];     const y1239            = 'STAR#'; const f1240                  = 'STAR';  const n1241            = [y1239, f1240];     const x1242      = 'TXTS#'; const k1243            = 'TXTS';  const b1244      = [x1242, k1243];    const v1245           = 'PT#'; const q1246                 = 'PT'; const f1247           = [v1245, q1246];  const m1248          = 'PCORN';  const q1249     = 'VPATH#'; const b1250           = 'VPATH';  const x1251     = [q1249, b1250];   const u1252   = 'VPT#'; const o1253         = 'VPT';  const p1254   = [u1252, o1253];  const i1255     = 'VEDGE#'; const p1256           = 'VEDGE';  const k1257     = [i1255, p1256];  const o1258   = 'VREG#'; const s1259         = 'VREG';  const s1260   = [o1258, s1259];  const z1261  = 'VNET#'; const h1262        = 'VNET';  const t1263  = [z1261, h1262];  const f1264     = 'SGRP#'; const g1265           = 'SGRP'; const o1266     = [f1264, g1265];  const q1267           = 'FRM#'; const t1268                 = 'FRM'; const t1269           = [q1267, t1268];   const v1231        = 'ARC#'; const j1230              = 'ARC'; const w1232        = [v1231, j1230];  const c1234       = 'WAVEP#'; const o1233             = 'WAVEP'; const d1235       = [c1234, o1233];  const y1270                  = 'MOVE'; const s1271                = 'ROT'; const z1272                 = 'SCALE'; const o1273                  = 'SKEW';  const SHOW_CENTER           = 'SHOWCNTR'; const a1274            = 'SCENTR'; const j1275           = 'RSTX';  const s1276                 = 'PLACE'; const x1277           = 'APPLY';    const PATH_LENGTH           = 'PTHLEN'; const JOIN_PATHS            = 'JOINPTH'; const REORIENT_PATHS        = 'REORPTH'; const y1284      = 'PTALPATH'; const l1285 = 'CPTONPATH'; const v1278        = 'MESPT'; const e1279           = 'PTANGLE'; const l1280                = 'VECLEN'; const l1281         = 'CIRCEN'; const ARC_FROM_POINTS       = 'ARCPT'; const r1282       = 'INTLIN'; const m1283     = 'PTLERP'; const REVERSE_PATH          = 'REVPTH'; const BLEND_PATH            = 'BLENDPTH';   const PATH_TYPES = [     b1250,      c1228,     j1230,     o1233 ];  const PATH_VALUES = [     q1249,      d1227,     v1231,     c1234 ];   const b1286         = 'SBOOL'; const i1287   = 'SBOOL#';  const z1288            = 'SBOOLU'; const u1289         = 'SBOOLS'; const o1290        = 'SBOOLI'; const q1291          = 'SBOOLE';   const p1292 = [     b1286,     i1287,     z1288,     u1289,     o1290,     q1291 ];   const n1293               = 'RENDER'; const EXPORT               = 'EXPORT';   const f1294 = [     g1217,     a1059,     m1218,     p1221,     a1224,     d1227,     b1236,     y1239,     x1242,     v1245,     q1249,     u1252,     i1255,     o1258,     z1261,     v1231,     c1234,     f1264,     q1267,     i1287,     d1196,     l1199,     h1202,     k1205,     k1211,     t1208 ];   const f1295 = [     s1271,     z1272,     o1273 ];   const f1296 = [     ...f1294,      ...w1220,     ...w1223,     ...r1226,     ...a1229,     ...g1238,     ...n1241,     ...b1244,     ...f1247,        m1248,     ...x1251,     ...p1254,     ...k1257,     ...s1260,     ...t1263,     ...w1232,     ...d1235,     ...o1266,     ...t1269,     ...p1292,          y1270,     ...f1295,     SHOW_CENTER,     a1274,     j1275,              s1276,     x1277,          PATH_LENGTH,     JOIN_PATHS,     REORIENT_PATHS,     y1284,     l1285,              v1278,     e1279,     l1280,     l1281,     j1230,     o1233,     ARC_FROM_POINTS,     r1282,     m1283,     REVERSE_PATH,     BLEND_PATH,      n1293,     EXPORT ];   const e1297 = [             z1056,      f1057,        g1058,       a1059,                 m1091,             i1143,            a1168,               a1178,       i1184,         q1187,           i1181,         i1184,         q1187,              g1217,        m1218,             p1221,          a1224,          d1227,          b1236,             y1239,       x1242,            v1245,      q1249,    u1252,      i1255,    o1258,   z1261,      f1264,            q1267,     j1193,      d1196,     l1199,       h1202,        k1205,       k1211,       t1208 ];   const f1298    = 'GROUP'; const u1299   = 'GPARAM';   const h1300 = [     f1298,     u1299 ];   const z1301       = 'CMNT'; const m1302 = 'CMNTARR'; const s1303         = 'PANEL';   const r1304        = 'ACT'; const i1305 = 'BFACT'; const x1306   = 'BFLST'; const f1307      = 'DIS'; const n1308       = 'NOC';   const PARAM         = 'PARAM';     const g1309           = 'LOG';   const p1310         = 'GRAPH';   const r1311 =  [        [m1119,   '%' ],     [s1118,   '/' ],      [q1116, '−' ],     [b1115,      '+' ],     [w1117, '×' ],     [x1120, 'e<sup>x']  ];   const p1312 =  [        [s1118,   '/' ],      [q1116, '−' ],     [b1115,      '+'],     [w1117, '×'] ];    const j1313 = 0; const g1314 = 1; const h1315  = 2; const i1316 = 3;   const v1317 =  [        [j1313, 'not'],     [g1314, 'xor'],      [h1315,  'or' ],     [i1316, 'and'] ];    const u1318             = 0; const t1319    = 1; const f1320        = 2; const f1321            = 3; const r1322 = 4; const z1323          = 5;   const f1324 =  [        [u1318,             '<'],     [t1319,    '≤'],     [f1320,        '≠'],     [f1321,            '='],     [r1322, '≥'],     [z1323,          '>'] ];    const h1325  = 0; const c1326  = 1; const l1327  = 2; const j1328 = 3; const v1329 = 4; const d1330 = 5;   const o1331 =  [        [h1325,  'sin' ],     [c1326,  'cos' ],     [l1327,  'tan' ],     [j1328, 'asin'],     [v1329, 'acos'],     [d1330, 'atan'] ];    const s1332               = 'EMPTY'; const a1333             = 'CONNECT'; const x1334              = 'CREATE'; const m1335       = 'CREATE_INSERT'; const z1336              = 'DELETE'; const z1337          = 'DISCONNECT'; const u1338          = 'LINK_STYLE'; const q1339       = 'LINK_VARIABLE'; const n1340 = 'LINK_VARIABLE_GROUP'; const v1341         = 'MAKE_ACTIVE'; const MAKE_NOT_CONDITION_ACTION  = 'MAKE_NOT_CONDITION'; const u1342        = 'MAKE_PASSIVE'; const s1343               = 'PASTE'; const e1344           = 'RECONNECT'; const w1345              = 'REMOVE'; const b1346              = 'RENAME'; const g1347      = 'REORDER_INPUTS'; const h1348 = 'REORDER_CONNECTIONS'; const m1361              = 'SELECT'; const w1362         = 'SELECT_MOVE'; const s1363          = 'MOVE_NODES'; const c1364     = 'SET_PARAM_VALUE'; const SET_MULTIPLE_VALUES_ACTION = 'SET_MULTIPLE_VALUES'; const b1365   = 'SET_PARAM_SETTING'; const z1366       = 'SET_NODE_RECT'; const o1367      = 'TOGGLE_DISABLE'; const l1368 = 'TOGGLE_PARAM_HEADER'; const u1369   = 'SET_CURRENT_GRAPH'; const h1370         = 'CREATE_PAGE'; const i1371         = 'DELETE_PAGE'; const a1372         = 'GROUP_NODES'; const d1373       = 'UNGROUP_NODES'; const g1374     = 'HIGHLIGHT_NODES'; const SCROLL_LIST_NODE_ACTION    = 'SCROLL_LIST_NODE'; const SET_LIST_DIVIDER_ACTION    = 'SET_LIST_DIVIDER'; const SET_NODE_PARAM_ACTION      = 'SET_NODE_PARAM';   const j1375               = 'BNORM'; const k1376               = 'BDARK'; const y1377             = 'BMULT'; const u1378          = 'BPDRK'; const j1379           = 'BBURN'; const f1380              = 'BLITE'; const w1381               = 'BSCRN'; const e1382         = 'BPLGT'; const l1383          = 'BDODG'; const y1384              = 'BOVER'; const u1385           = 'BSOFT'; const e1386           = 'BHARD'; const h1387           = 'BDIFF'; const l1388            = 'BEXCL'; const v1389                  = 'BHUE'; const d1390           = 'BSAT'; const m1391                = 'BCOL'; const m1392           = 'BLUM';   const l1393 = [     [j1375,       'normal',       'NORMAL'      ],     [k1376,       'darken',       'DARKEN'      ],     [y1377,     'multiply',     'MULTIPLY'    ],     [u1378,  'plus darker',  'LINEAR_BURN' ],     [j1379,   'color burn',   'COLOR_BURN'  ],     [f1380,      'lighten',      'LIGHTEN'     ],     [w1381,       'screen',       'SCREEN'      ],     [e1382, 'plus lighter', 'LINEAR_DODGE'],     [l1383,  'color dodge',  'COLOR_DODGE' ],     [y1384,      'overlay',      'OVERLAY'     ],     [u1385,   'soft light',   'SOFT_LIGHT'  ],     [e1386,   'hard light',   'HARD_LIGHT'  ],     [h1387,   'difference',   'DIFFERENCE'  ],     [l1388,    'exclusion',    'EXCLUSION'   ],     [v1389,          'hue',          'HUE'         ],     [d1390,   'saturation',   'SATURATION'  ],     [m1391,        'color',        'COLOR'       ],     [m1392,   'luminosity',   'LUMINOSITY'  ] ];    const k1394 = [     ['thin',        100],     ['extra light', 200],     ['light',       300],     ['regular',     400],     ['medium',      500],     ['semi bold',   600],     ['bold',        700],     ['extra bold',  800],     ['black',       900] ];    const b1395           =  0; const z1396        =  1;  const c1397      =  2;   const p1398     = 2; const c1399    =  3;   const x1400   = 3;  const n1401       =  4;   const u1402 = 4; const m1403         =  5;   const q1404            =  6; const o1405            =  7; const i1406            =  8;  const f1407          =  9;  const e1408          = 10; const g1409        = 11;   const q1410  = 12; const j1411   = 13; const s1412    = 14;                                     const d1413   = 15; const d1414     = 16; const j1415  = 17;  const i1416        = 18;  const k1417           = 19; const u1418      = 20;     const i1419        = 21; const x1420          = 22; const r1421           = 23;  const d1422              = 24;                                                                         const h1453    = 24;                                                                                              const q1423 = 24; const q1424              = 25;                                                                         const e1454   = 25; const v1425          = 26;    const w1426         = 27;                                      const p1427     = 28;   const t1428   = 28;   const f1429 = 28;   const j1430    = 28;   const i1431   = 28;   const j1432  = 28;   const s1433      = 28;   const m1434    = 28;                                 const s1435   = 29;                                        const b1436 = 29;   const r1437 = 29;   const v1438 = 29;   const j1439     = 29;   const f1455     = 29;                                 const y1441   = 30;                                        const c1442   = 30;                                 const f1443 = 30;   const f1444           = 30;   const l1440 = 30;                                                                                                                                                                   const u1445   = 31;                                                                                                                                        const t1446           = 31;                                                                                                                                                                                                       const j1447      = 32;                                                                                                                                                                                                       const h1448     = 33;                                                                                                                                                                                                                                                                                                                                                                                                                                            const b1449        = 34;                                                                                                                                                                                                       const t1450        = 35;                                                                                                                                                                                                                                                                                                                                                                                                                                            const p1451    = 36;                                                                                                                                                                                                       const i1452 = 37;


class u1842 {     type;          nodeId     = '';       objectId   = NULL;     objectName = NULL;      y3819  = -1;       retain     = 0;     feedback   = false;       showCenter = false;          y4207;      xp0   = null;      xp1   = null;      xp2   = null;       sp0   = null;      sp1   = null;      sp2   = null;       i3739;     scaleStyle;        constructor(type, nodeId, objectId, objectName)     {         this.type         = type;         this.nodeId       = nodeId;         this.objectId     = objectId;         this.objectName   = objectName;          this.y4207        = clone(identity);          this.i3739 = 1;         this.scaleStyle   = 1;     }        o3358(base)     {         this.y3819    = base.y3819;                  this.feedback     = base.feedback;         this.retain       = base.retain;          this.showCenter   = base.showCenter;          this.y4207        = clone(base.y4207);          this.xp0          = clone(base.xp0);         this.xp1          = clone(base.xp1);         this.xp2          = clone(base.xp2);          this.sp0          = clone(base.sp0);         this.sp1          = clone(base.sp1);         this.sp2          = clone(base.sp2);          this.i3739 = base.i3739;         this.scaleStyle   = base.scaleStyle;     }        copy()     {         c953('invalid use of abstract method u1842.copy()');         return null;     }        getCount()     {         return 1;     }        f3741(cx = 0, cy = 0)     {         this.sp0 = point(cx,   cy  );         this.sp1 = point(cx+1, cy  );         this.sp2 = point(cx,   cy+1);     }        resetSpace(bounds, singlePoint = false, cx = 0.5, cy = 0.5, units = 0)     {         let _cx;          let _cy;           if (units == 0)         {             _cx = bounds.x + cx * bounds.width;             _cy = bounds.y + cy * bounds.height;                     }         else if (units == 1)         {             _cx = bounds.x + cx;             _cy = bounds.y + cy;         }         else          {             _cx = cx;             _cy = cy;                     }           const ds1 = v900(this.sp1, this.sp0);         const ds2 = v900(this.sp2, this.sp0);          this.sp0  = point(_cx, _cy);          this.sp1  = x895(this.sp0, ds1);         this.sp2  = x895(this.sp0, ds2);           if (PATH_TYPES.includes(this.type))             this.a3742();     }        s4097(x, y, a = 0)     {         this.y4207 =             [[Math.cos(a), -Math.sin(a), x],              [Math.sin(a),  Math.cos(a), y],              [0,            0,           1]];     }        l3729(x, y, w, h)     {         this.xp0 = point(x,     y    );         this.xp1 = point(x + w, y    );         this.xp2 = point(x,     y + h);     }        p3731()     {         let vr = point(this.sp1.x - this.sp0.x, this.sp1.y - this.sp0.y);         let vb = point(this.sp2.x - this.sp0.x, this.sp2.y - this.sp0.y);                   let sx = vr.x;         let sy = vb.y;              let kx = vr.y;         let ky = vb.x;                  let dx = this.sp0.x;         let dy = this.sp0.y;                   let y4207 = x889(             b893(dx, dy),             [[sx, ky, 0],              [kx, sy, 0],              [0,  0,  1]]);               return y4207;     }                getBounds()     {         let bounds = o1047.NaN;          const dp = v900(this.xp1, this.xp0);          bounds = x3744(bounds, this.xp0);         bounds = x3744(bounds, this.xp1);         bounds = x3744(bounds, this.xp2);         bounds = x3744(bounds, x895(this.xp2, dp));          return bounds;     }        r4098(y4207, affectSpace)     {         const space = this.p3731();           if (this.type == q1246)         {             if (affectSpace > 0)             {                 const p = f3730(point(this.x, this.y), y4207, space);                  this.x = p.x;                 this.y = p.y;             }              if (affectSpace != 1)                 this.applySpaceTransform(y4207, space);         }         else if (PATH_TYPES.includes(this.type))         {             if (affectSpace > 0)             {                 this.applyObjectTransform(y4207, space);                  this.updatePoints(y4207, space);                 this.a3742();                              }              if (affectSpace != 1)                 this.applySpaceTransform(y4207, space);         }         else if (this.type == g1265)         {             for (const g111 of this.children)             {                 if (affectSpace > 0)                 {                     g111.applyObjectTransform(y4207, space);                      if (g111.type == b1250)                         g111.updatePoints(y4207, space);                 }                  if (affectSpace != 1)                     g111.applySpaceTransform(y4207, space);             }                         }         else         {             if (affectSpace > 0)                 this.applyObjectTransform(y4207, space);              if (affectSpace != 1)                 this.applySpaceTransform(y4207, space);         }     }        applyObjectTransform(y4207, space)     {         if (   this.xp0.x == this.xp1.x             && this.xp0.y == this.xp1.y)             this.xp1.x += 0.0001;          if (   this.xp0.x == this.xp2.x             && this.xp0.y == this.xp2.y)             this.xp2.y += 0.0001;          this.xp0 = f3730(this.xp0, y4207, space);         this.xp1 = f3730(this.xp1, y4207, space);         this.xp2 = f3730(this.xp2, y4207, space);     }        applySpaceTransform(y4207, space)     {         this.sp0 = f3730(this.sp0, y4207, space);         this.sp1 = f3730(this.sp1, y4207, space);         this.sp2 = f3730(this.sp2, y4207, space);     }        checkFlipped(flipX, flipY)     {         if (flipX)         {             const d1 = v900(this.xp1, this.xp0);              this.xp0 = x895(this.xp0, d1);             this.xp2 = x895(this.xp2, d1);             this.xp1 = v900(this.xp1, d1);         }                   if (flipY)         {             const d2 = v900(this.xp2, this.xp0);              this.xp0 = x895(this.xp0, d2);             this.xp1 = x895(this.xp1, d2);             this.xp2 = v900(this.xp2, d2);         }     }        z3755()     {         return {             type:       this.type,             nodeId:     this.nodeId,              objectId:   this.objectId,             objectName: this.objectName,                          feedback:   this.feedback,              xp0:        this.xp0 ? this.xp0 : null,             xp1:        this.xp1 ? this.xp1 : null,             xp2:        this.xp2 ? this.xp2 : null         };     }        t3740()     {         return [          this.type,          this.nodeId,           this.objectId,          this.objectName,                       this.feedback,          this.retain,                   this.xp0 ? this.xp0 : null,          this.xp1 ? this.xp1 : null,          this.xp2 ? this.xp2 : null,           0          ];     }        q3632()     {         return new x4216();     } }    function f3730(p, y4207, space) {     p = l888(p, r891(space));     p = l888(p, y4207);     p = l888(p, space);      return p; }    function w3737(g111) {     switch (g111.type)     {         case g1219:     return a1845 .prototype.copy.call(g111);         case i1222:          return q1841      .prototype.copy.call(g111);         case c1225:       return e1839   .prototype.copy.call(g111);         case c1228:       return b1850   .prototype.copy.call(g111);         case e1237:       return m1844   .prototype.copy.call(g111);         case f1240:          return i1848      .prototype.copy.call(g111);         case k1243:    return o1849      .prototype.copy.call(g111);         case q1246:         return d1843     .prototype.copy.call(g111);         case b1250:   return h1852.prototype.copy.call(g111);         case j1230:      return FigmaArcPath   .prototype.copy.call(g111);         case o1233:     return FigmaWavePath  .prototype.copy.call(g111);         case b1286: return y1837   .prototype.copy.call(g111);         case g1265:   return v1847.prototype.copy.call(g111);         case t1268:         return l1840     .prototype.copy.call(g111);     }      c953('invalid Figma object type \'' + g111.type + '\'');     return null; }    function getPointBounds(points) {     let minX = Number.MAX_SAFE_INTEGER;     let minY = Number.MAX_SAFE_INTEGER;     let maxX = Number.MIN_SAFE_INTEGER;     let maxY = Number.MIN_SAFE_INTEGER;      for (const p of points)     {         minX = Math.min(minX, p.x.value);         minY = Math.min(minY, p.y.value);         maxX = Math.max(maxX, p.x.value);         maxY = Math.max(maxY, p.y.value);     }      return new AbsRect(minX, minY, maxX, maxY); }    function getObjBounds(objects) {     let bounds = o1047.NaN;      for (const g111 of objects)         bounds = r3743(bounds, g111.getBounds());      return bounds; }    function y2585(node, g111) {     const sp0 = point(         g111.sp0.x ,          g111.sp0.y );      const sp1 = x895(sp0, i897(      v900(g111.sp1, g111.sp0),      settings.objectCenterSize));     const sp2 = x895(sp0, i897(i897(v900(g111.sp2, g111.sp0), -1), settings.objectCenterSize));          const center = createDecoPoly(         node.nodeId,         g111.objectId,         g111.objectName,          sp0,          [sp2, sp0, sp1],         false,         '',         [242, 72, 34],          w970,         true);      return center; }    function createDecoPoly(nodeId, objectId, objectName, center, points, closed, dashes, color, suffix, isCenter) {     const path = new h1852(         nodeId,         objectId   + suffix,         objectName + suffix,         points.map(p => t2022.fromPoint(objectId, p)),         closed ? 1 : 0,          0,          0,          0);       path.strokes.push([         'SOLID',          color[0],          color[1],          color[2],          100,          'NORMAL']);      path.strokeWeight =  1;     path.strokeAlign  = 'CENTER';     path.strokeJoin   = 'MITER';     path.strokeCap    = 'NONE';     path.strokeDashes =  dashes;     path.q3738       =  true;     path.isCenter     =  isCenter;       path.s4097(center.x, center.y);            return path; }    function t3627(value) {     return value         && value.objects         ? value.objects               .filter(o =>                       o.q3738  === false                   || o.isXform === true)               .map(o => o.copy())          : []; }


function k1822(g111, prop) {          if (prop.type ==         a1168)  h1823       (g111, prop);     else if (prop.type ==          a1178)  d1824        (g111, prop);     else if (prop.type ==      q1187)  r1825    (g111, prop);     else if (prop.type ==        i1181)  x1829      (g111, prop);     else if (prop.type ==  g1190)  addStrokeSidesProp (g111, prop);     else if (prop.type == j1193)  f1830(g111, prop);     else if (prop.type ==   d1196)  a1831  (g111, prop);     else if (prop.type ==  l1199)  y1832 (g111, prop);     else if (prop.type ==    h1202)  t1833   (g111, prop);     else if (prop.type ==     k1205)  b1834    (g111, prop);     else if (prop.type ==   k1211)  t1835  (g111, prop);     else if (prop.type ==    t1208)  z1836        (g111, prop); }    function h1823(g111, prop) {     const rgb = p4141(prop.c3241());      if (g111.type == g1265)     {         for (const _obj of g111.children)             k1822(_obj, prop);     }     else     {         g111.fills.push([             'SOLID',              rgb[0],              rgb[1],              rgb[2],              255 ]);     } }    function d1824(g111, prop, target = g111.fills) {     if (prop.color.type != a1168)         return;       const rgb = p4141(prop.color.c3241());      if (g111.type == g1265)     {         for (const _obj of g111.children)             k1822(_obj, prop);     }     else     {         target.push([             'SOLID',              rgb[0],              rgb[1],              rgb[2],              prop.opacity.q3632().value,             l1393[Math.min(Math.max(0, Math.round(prop.blend.value)), l1393.length-1)][2]]);     } }    function r1825(g111, prop, target = g111.fills)                 {     const gradient =      [         '',          [],          [],          '',          0                     ];       switch(prop.k3686.value)     {         case 0: gradient[0] = 'GRADIENT_LINEAR';  break;         case 1: gradient[0] = 'GRADIENT_RADIAL';  break;         case 2: gradient[0] = 'GRADIENT_ANGULAR'; break;         case 3: gradient[0] = 'GRADIENT_DIAMOND'; break;     }           let   x        =        prop.x     .value / 100;     let   y        =        prop.y     .value / 100;     let   s        = nozero(prop.size  .value / 100);     let   a        =        prop.angle .value / 360*Tau;     let   asp      = nozero(prop.aspect.value / 100);     const diag     =        prop.diagAspect;     let   sk       =        prop.skew  .value / 100;           const pos      = prop.position.value;     const isLinear = prop.k3686.value == 0;          const bounds   = g111.getBounds();       if (pos > 0)     {         if (   pos == 1             || pos == 2)          {             x = x / 100 * bounds.width;             y = y / 100 * bounds.height;         }                   x = x * 100 / nozero(bounds.width );         y = y * 100 / nozero(bounds.height);           if (pos == 4)         {             x = x - bounds.x / nozero(bounds.width );             y = y - bounds.y / nozero(bounds.height);                          s *= 100 / nozero(bounds.width);         }     }       let   p0 = point(x, y);     let   p1 = x895(p0, vector(a, diag === true ? s : s * nozero(asp)));     let   p2 = x895(p0, vector(a + Tau/4, s));      const a1 = anglev2(p0, p1);     const a2 = anglev2(p0, p2);           if (diag === true)     {         p1 = x895(p1, vector(a1 - Tau/8, (asp-1) * Math.sqrt(sqr(distv(p0, p1))/2)));         p2 = x895(p2, vector(a2 + Tau/8, (asp-1) * Math.sqrt(sqr(distv(p0, p2))/2)));          p1 = x895(p1, vector(a2 + Tau/8, s * sk * Math.sqrt(2)/2));         p2 = x895(p2, vector(a2 + Tau/8, s * sk * Math.sqrt(2)/2));     }     else     {         p2 = v900(p2, vector(a1, s * sk));     }       if (pos > 0)     {         if (   pos == 1             || pos == 3             || pos == 4)         {             const aspect = bounds.width / nozero(bounds.height);                          p1.y = p0.y + (p1.y - p0.y) * aspect;             p2.y = p0.y + (p2.y - p0.y) * aspect;         }         else if (pos == 2)         {             const aspect = bounds.height / nozero(bounds.width);                          p1.x = p0.x + (p1.x - p0.x) * aspect;             p2.x = p0.x + (p2.x - p0.x) * aspect;         }     }       if (!isLinear)     {         const dv = v900(p0, p1);          p0 = x895(p0, dv);         p2 = x895(p2, dv);     }             if (prop.stops.items.some(i =>                 i             && (   i.position.value < 0                  || i.position.value > 100)))     {         let minPos = Number.MAX_SAFE_INTEGER;         let maxPos = Number.MIN_SAFE_INTEGER;          for (const stop of prop.stops.items)         {             minPos = Math.min(minPos, stop.position.value);             maxPos = Math.max(maxPos, stop.position.value);         }          if (!isLinear)             minPos = Math.max(0, minPos);           const dpos  = Math.min(0, minPos) / 100;         const dsize = Math.max(100, maxPos - Math.min(minPos, 0)) / 100;          const dv    = v900(p0, p1);          p0 = x895(p0, i897(dv, Math.max(0, -dpos)));         p1 = x895(p1, i897(dv, Math.max(0, -dpos)));         p2 = x895(p2, i897(dv, Math.max(0, -dpos)));          if (prop.k3686.value != 2)          {             p1 = v900(p0, i897(dv, dsize));             p2 = x895(p0, i897(v900(p2, p0), dsize));         }           for (const stop of prop.stops.items)             stop.position.value = stop.position.value * 100 / maxPos;     }       gradient[1] = [p0, p1, p2];           const stops = prop.stops.items;      for (let j = 0; j < stops.length; j++)     {         const stop = stops[j];          if (stop.fill)         {             const rgba = stop.fill.y99();              gradient[2].push([                 rgba[0],                  rgba[1],                  rgba[2],                  rgba[3],                 Math.min(Math.max(0, stop.position.value / 100), 1)]);         }     }       gradient[3] = l1393[prop.blend.value][2];           target.push(gradient); }    function s1826(e1827) {     const stops = [];       for (let i = 0; i < e1827.length; i++)     {         const stop = e1827[i];          if (stop.type == a1168)         {             stops.push(new a2008(                 e2012.g3772(p4141(stop.c3241()), 100),                 z2021.NaN));         }          else if (stop.type == a1178)             stops.push(new a2008(                 stop,                 z2021.NaN));          else if (stop.type == z1056)             stops.push(...s1826(stop.items));          else             stops.push(stop);     }       return stops; }    function d1828(stops) {     if (    stops.length > 0         && !stops[0].position.isValid())          stops[0].position = new z2021(0);      if (    stops.length > 1         && (!stops.at(-1).position.isValid()))          stops.at(-1).position = new z2021(100);           if (stops.length > 2)     {         for (let i = 1; i < stops.length-1; i++)         {             const stop = stops[i];              if (   !stop                 || !stop.position                 || !stop.position.isValid())             {                 let prevValid = i-1;                 let nextValid = i+1;                  while ( prevValid > 0                     && !stops[prevValid].position.isValid())                      prevValid--;                  while ( nextValid < stops.length-1                     && !stops[nextValid].position.isValid())                      nextValid++;                                          const pv = stops[prevValid].position.value;                 const nv = stops[nextValid].position.value;                  stop.position = new z2021((pv + (nv - pv) * ((i - prevValid) / (nextValid - prevValid))));              }         }     } }    function x1829(g111, prop) {     for (const fill of prop.fills.items)     {         if (fill.type ==     a1178) d1824    (g111, fill, g111.strokes);         if (fill.type == q1187) r1825(g111, fill, g111.strokes);     }       if (g111.type == g1265)     {         for (const _obj of g111.children)             k1822(_obj, prop);     }     else     {         g111.strokeWeight = prop.weight.q3632().value;          switch (prop.fit.q3632().value)         {             case 0: g111.strokeAlign = 'INSIDE';  break;             case 1: g111.strokeAlign = 'CENTER';  break;             case 2: g111.strokeAlign = 'OUTSIDE'; break;         }          switch (prop.join.q3632().value)         {             case 0: g111.strokeJoin = 'MITER'; break;             case 1: g111.strokeJoin = 'BEVEL'; break;             case 2: g111.strokeJoin = 'ROUND'; break;         }          switch (prop.cap.q3632().value)         {             case 0: g111.strokeCap = 'NONE';   break;             case 1: g111.strokeCap = 'SQUARE'; break;             case 2: g111.strokeCap = 'ROUND';  break;         }          g111.strokeDashes     = prop.dashes.q3632().value.trim();                  g111.strokeMiterLimit = prop.miter .q3632().value;     } }    function addStrokeSidesProp(g111, prop) {     if (g111.type == g1265)     {         for (const _obj of g111.children)             k1822(_obj, prop);     }     else     {         g111.effects.push([            'STROKE_SIDES',              prop.top   .value,             prop.left  .value,             prop.right .value,             prop.bottom.value,             prop.visible ]);     } }    function f1830(g111, prop) {     if (g111.type == g1265)     {         for (const _obj of g111.children)             k1822(_obj, prop);     }     else     {         g111.effects.push([            'ROUND_CORNERS',              prop.tl.value,             prop.tr.value,             prop.bl.value,             prop.br.value,             prop.visible ]);     } }    function a1831(g111, prop) {     const rgba = prop.fill.y99();      g111.effects.push([         'DROP_SHADOW',          rgba[0],         rgba[1],         rgba[2],         rgba[3],         prop.x     .value,          prop.y     .value,          prop.blur  .value,          prop.spread.value,          l1393[prop.blend.value][2],         prop.behind.value > 0,         prop.visible ]); }    function y1832(g111, prop) {     const rgba = prop.fill.y99();      g111.effects.push([         'INNER_SHADOW',          rgba[0],         rgba[1],         rgba[2],         rgba[3],         prop.x     .value,          prop.y     .value,          prop.blur  .value,          prop.spread.value,          l1393[prop.blend.value][2],         prop.visible ]); }    function t1833(g111, prop) {     g111.effects.push([         'LAYER_BLUR',          prop.radius.value,          prop.visible ]); }    function b1834(g111, prop) {     g111.effects.push([         'BACKGROUND_BLUR',          prop.radius.value,          prop.visible ]); }    function t1835(g111, prop) {     g111.opacity = Math.min(Math.max(0, prop.opacity.value  / 100), 1);     g111.blend   = l1393[prop.blend.value][2]; }    function z1836(g111, mask) {     g111.maskType = mask.maskType.value + 1; } 


class m1846 extends u1842 {     skewX;     skewY;      fills   = [];     strokes = [];      strokeWeight;     strokeAlign;     strokeJoin;     strokeMiterLimit;     strokeCap;     strokeDashes;      effects = [];      q3738;     isCenter;     isXform;      opacity;     blend;      maskType = 0;        constructor(type, nodeId, objectId, objectName, q3738 = false, isXform = false)     {         super(type, nodeId, objectId, objectName);          this.skewX    = 0;         this.skewY    = 0;          this.q3738   = q3738;         this.isCenter = false;         this.isXform  = isXform;          this.opacity  = 1;         this.blend    = 'PASS_THROUGH';     }        o3358(base)     {         super.o3358(base);          this.skewX            = base.skewX;         this.skewY            = base.skewY;          this.fills            = clone(base.fills);         this.strokes          = clone(base.strokes);          this.strokeWeight     = base.strokeWeight;         this.strokeAlign      = base.strokeAlign;         this.strokeJoin       = base.strokeJoin;         this.strokeMiterLimit = base.strokeMiterLimit;         this.strokeCap        = base.strokeCap;         this.strokeDashes     = base.strokeDashes;          this.effects          = clone(base.effects);          this.q3738           = base.q3738;         this.isCenter         = base.isCenter;         this.isXform          = base.isXform;          this.opacity          = base.opacity;         this.blend            = base.blend;         this.maskType         = base.maskType;     }        checkFlipped(flipX, flipY)     {         super.checkFlipped(flipX, flipY);          for (const fill   of this.fills  ) flipGradient(fill,   flipX, flipY);         for (const stroke of this.strokes) flipGradient(stroke, flipX, flipY);          const foundSides = this.effects.findIndex(e => e[0] == 'STROKE_SIDES');         if (foundSides > -1) flipStrokeSides(this.effects[foundSides], flipX, flipX);          const foundCorners = this.effects.findIndex(e => e[0] == 'ROUND_CORNERS');         if (foundCorners > -1) flipRoundCorners(this.effects[foundCorners], flipX, flipY);     }        t3740()     {         const weight = this.strokeWeight * Math.abs(this.scaleStyle);          const dashes =              this.strokeDashes             ? this.strokeDashes                 .split(',')                 .map(d => parseFloat(d.trim()) * Math.abs(this.scaleStyle))                 .join(',')             : '';                   return [             ...super.t3740(),                  this.fills,              this.strokes,               weight,              this.strokeAlign,              this.strokeJoin,              this.strokeMiterLimit,              this.strokeCap,              dashes,               this.effects,               this.q3738,              this.isCenter,               this.opacity,              this.blend,              this.maskType         ];     } }    function flipGradient(fill, flipX, flipY) {     if (   fill[0] == 'GRADIENT_LINEAR'         || fill[0] == 'GRADIENT_RADIAL'         || fill[0] == 'GRADIENT_ANGULAR'         || fill[0] == 'GRADIENT_DIAMOND')     {         const p0 = fill[1][0];         const p1 = fill[1][1];         const p2 = fill[1][2];          if (flipX)         {             p0.x = 1 - p0.x;             p1.x = 1 - p1.x;             p2.x = 1 - p2.x;         }          if (flipY)         {             p0.y = 1 - p0.y;             p1.y = 1 - p1.y;             p2.y = 1 - p2.y;         }     } }    function flipStrokeSides(sides, flipX, flipY) {     if (flipX) [sides[2], sides[3]] = [sides[3], sides[2]];     if (flipY) [sides[1], sides[4]] = [sides[4], sides[1]]; }    function flipRoundCorners(corners, flipX, flipY) {     if (flipX)     {         [corners[1], corners[2]] = [corners[2], corners[1]];         [corners[3], corners[4]] = [corners[4], corners[3]];     }      if (flipY)     {         [corners[1], corners[3]] = [corners[3], corners[1]];         [corners[2], corners[4]] = [corners[4], corners[2]];     } }


class a1845 extends m1846 {     x;     y;     width;     height;      round;            constructor(nodeId, objectId, objectName, x, y, width, height, round)     {         super(g1219, nodeId, objectId, objectName);                  this.x      = x;         this.y      = y;         this.width  = width;         this.height = height;          this.round  = round;          this.f3741(             x + width /2,              y + height/2);     }        copy()     {         const copy = new a1845(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.width,             this.height,                          this.round);           copy.o3358(this);           return copy;     }        q3632()     {         return k2024.fromObject(this);     }        t3740()     {         return [             ...super.t3740(),                  this.x,              this.y,              this.width,              this.height,               this.round * Math.abs(this.i3739)         ];     } } 


class q1841 extends m1846 {     x;     y;     width;        constructor(nodeId, objectId, objectName, x, y, width)     {         super(i1222, nodeId, objectId, objectName);                  this.x     = x;         this.y     = y;         this.width = width;                   this.f3741(             x + width/2,              y);     }        copy()     {         const copy = new q1841(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.width);           copy.o3358(this);           return copy;     }        q3632()     {         return l2019.fromObject(this);     }        t3740()     {         return [             ...super.t3740(),                  this.x,              this.y,              this.width         ];     } }


class e1839 extends m1846 {     x;     y;     width;     height;     round;      start;     sweep;     inner;            constructor(nodeId, objectId, objectName, x, y, width, height, round, start, sweep, inner)     {         super(c1225, nodeId, objectId, objectName);                  this.x      = x;         this.y      = y;         this.width  = width;         this.height = height;         this.round  = round;          this.start  = start;         this.sweep  = sweep;         this.inner  = inner;                   this.f3741(             x + width /2,              y + height/2);     }        copy()     {         const copy = new e1839(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.width,             this.height,             this.round,                          this.start,             this.sweep,             this.inner);           copy.o3358(this);           return copy;     }        q3632()     {         return g2011.fromObject(this);     }        t3740()     {         return [             ...super.t3740(),                  this.x,              this.y,              this.width,              this.height,              this.round,               this.start,              this.sweep,              this.inner         ];     } }


class h1852 extends m1846 {     x;     y;     width;     height;          points;      closed;     degree;     winding;       round;          r3745;     l4031;        constructor(nodeId, objectId, objectName, points, closed, degree, winding, round)     {         super(b1250, nodeId, objectId, objectName);                           this.points  = points.map(p => p.copy());             this.closed  = closed;         this.degree  = degree;         this.winding = winding;          this.round   = round;                   this.a3742();     }        copy()     {         const copy = new h1852(             this.nodeId,             this.objectId,             this.objectName,              this.points,              this.closed,             this.degree,             this.winding,              this.round);           copy.x          = this.x;         copy.y          = this.y;         copy.width      = this.width;         copy.height     = this.height;          copy.r3745 = [...this.r3745];         copy.l4031   = this.l4031;           copy.o3358(this);           return copy;     }        o3358(base)     {         super.o3358(base);          if (base.points) this.points = base.points.map(p => p.copy());     }        getBounds()     {         let bounds = o1047.NaN;           switch (this.degree)         {             case 0:                 for (const p of this.r3745)                     bounds = x3744(bounds, p);                  break;              case 1:                 {                     let i;                     for (i = 0; i < this.r3745.length-2; i += 2)                     {                         bounds = r3743(                             bounds,                              i864(                                 this.r3745[i  ],                                  this.r3745[i+1],                                 this.r3745[i+2]));                     }                      if (   this.closed                         && i < this.r3745.length-1)                     {                         bounds = r3743(                             bounds,                              i864(                                 this.r3745.at(-2),                                  this.r3745.at(-1),                                 this.r3745.at( 0)));                     }                      break;                 }             case 2:             case 3:             case 4:             case 5:                 {                     let i;                     for (i = 0; i < this.r3745.length-3; i += 3)                     {                         const b3 = b865(                             this.r3745[i  ],                              this.r3745[i+1],                             this.r3745[i+2],                             this.r3745[i+3]);                          bounds = r3743(                             bounds,                              b3);                     }                      if (   this.closed                         && i < this.r3745.length - 2)                     {                         const b3 = b865(                             this.r3745.at(-3),                              this.r3745.at(-2),                              this.r3745.at(-1),                             this.r3745.at( 0));                          bounds = r3743(                             bounds,                              b3);                     }                      break;                 }             default:                 console.error('invalid curve degree');         }           return bounds;     }        updatePoints(y4207, space)     {         for (let i = 0; i < this.points.length; i++)         {             let p      = this.points[i].y3746();             let smooth = this.points[i].smooth;              p = f3730(p, y4207, space);              this.points[i]        = t2022.fromPoint(this.nodeId, p);             this.points[i].smooth = smooth;         }     }        a3742()     {         switch (this.degree)         {         case 0: this.r3745 = this.points.map(p => p.y3746());                           break;         case 1: this.r3745 = this.points.map(p => p.y3746());                           break;         case 2: this.r3745 = this.points.map(p => p.y3746());                           break;         case 3: this.r3745 = v3752(this.points, this.closed, q4243); break;         case 4: this.r3745 = v3752(this.points, this.closed, t4244 ); break;         case 5: this.r3745 = v3752(this.points, this.closed, s4245 ); break;         }     }        v3748()     {         if (this.type == b1250)         {             const bounds = this.getBounds();              this.x      = bounds.x;             this.y      = bounds.y;             this.width  = bounds.width;             this.height = bounds.height;              this.l3729(this.x, this.y, this.width, this.height);         }          this.l4031 = w3747(this.r3745, this.closed, this.degree);     }        checkFlipped(flipX, flipY)     {         super.checkFlipped(flipX, flipY);           const bounds = this.getBounds();           for (const point of this.points)         {             if (flipX) point.x.value = bounds.width  - point.x.value;             if (flipY) point.y.value = bounds.height - point.y.value;         }          this.a3742();                                                   }        t3740()     {                  this.v3748();           const oldType = this.type;         this.type = b1250;          const data =          [             ...super.t3740(),                  this.x,              this.y,              this.width,              this.height,               this.l4031,              this.winding,              this.round * Math.abs(this.i3739)         ];          this.type = oldType;           return data;     }        q3632()     {         return y2036.fromObject(this);     } }    function w3747(points, closed, degree) {     for (const p of points)         if (   isNaN(p.x)             || isNaN(p.y))             return '';                   let l4031 = '';       switch (degree)     {     case 0: l4031 = f947   (points);         break;      case 1: l4031 = r3749(points, closed); break;      case 2:                                                              case 3:                                                              case 4:                                                              case 5: l4031 = w3750    (points, closed); break;      }       const b3751 =            degree == 0 && points.length > 2         || degree == 1 && points.length > 2         || degree == 2 && points.length > 3         || degree == 3 && points.length > 2         || degree == 4 && points.length > 2         || degree == 5 && points.length > 2;       if (   b3751         && (   closed             || o1019(points[0], points.at(-1))))         l4031 += ' Z';       return l4031; }    function r3749(points, closed) {     let l4031 = '';       if (points.length < 3)         return l4031;       l4031 += 'M';     l4031 += ' ' + w879(points[0].x);     l4031 += ' ' + w879(points[0].y);      let i;     for (i = 1; i < points.length-1; i += 2)     {         l4031 +=                ' Q'             + ' ' + w879(points[i  ].x)             + ' ' + w879(points[i  ].y)             + ' ' + w879(points[i+1].x)             + ' ' + w879(points[i+1].y);     }       if (   points.length - i == 1         && closed)     {         l4031 +=                ' Q'             + ' ' + w879(points.at(-1).x)             + ' ' + w879(points.at(-1).y)             + ' ' + w879(points.at( 0).x)             + ' ' + w879(points.at( 0).y);     }       return l4031; }    function w3750(points, closed) {     let l4031 = '';       if (points.length < 4)         return l4031;       l4031 += 'M';     l4031 += ' ' + w879(points[0].x);     l4031 += ' ' + w879(points[0].y);      let i;     for (i = 1; i < points.length-2; i += 3)     {         l4031 +=                ' C'             + ' ' + w879(points[i  ].x)             + ' ' + w879(points[i  ].y)             + ' ' + w879(points[i+1].x)             + ' ' + w879(points[i+1].y)             + ' ' + w879(points[i+2].x)             + ' ' + w879(points[i+2].y);     }       if (   points.length - i == 2         && closed)     {         l4031 +=                ' C'             + ' ' + w879(points.at(-2).x)             + ' ' + w879(points.at(-2).y)             + ' ' + w879(points.at(-1).x)             + ' ' + w879(points.at(-1).y)             + ' ' + w879(points.at( 0).x)             + ' ' + w879(points.at( 0).y);     }       return l4031; }    function v3752(points, closed, a3753) {     if (points.length < 2)         return '';       const bp = [];            let [pp, p, pn] = a3753(         closed ? points.at(-1) : points[0],          points[0],         points[1]);      bp.push(p);       let _pp = pn;            for (let i = 1; i < points.length; i++)     {         [pp, p, pn] = a3753(             points[i-1],              points[i],             i == points.length-1              ? (closed ? points[0] : points[i])             : points[i+1]);          if (points[i].smooth)             [pp, pn] = f3754(points[i], pp, p, pn);                      bp.push(_pp, pp, p);             _pp = pn;     }       if (bp.length > 3)     {         if (closed)         {             if (   equal(bp[0].x, bp.at(-1).x, 0.01)                 && equal(bp[0].y, bp.at(-1).y, 0.01))             {                                  [pp, p, pn] = a3753(                     points.at(-2),                      points.at( 0),                     points.at( 1));                  if (points[0].smooth)                     [pp, pn] = f3754(points[0], pp, p, pn);                  bp[1]           = pn;                 bp[bp.length-2] = pp;             }             else             {                                  [pp, p, pn] = a3753(                     points.at(-1),                      points.at( 0),                     points.at( 1));                  if (points[0].smooth)                     [pp, pn] = f3754(points[0], pp, p, pn);                  bp.push(_pp, pp, p);                  bp[1]           = pn;                 bp[bp.length-2] = pp;             }         }         else          {             bp[1]           = x895(bp[0],     i897(w886(v900(bp[2],     bp[0]    )), distv(bp[3],     bp[0]    )/3));             bp[bp.length-2] = x895(bp.at(-1), i897(w886(v900(bp.at(-3), bp.at(-1))), distv(bp.at(-4), bp.at(-1))/3));         }     }       return bp; }    function f3754(point, pp, p, pn) {     if (point.smooth)     {         const smooth = point.smooth.value;                  pp = x895(p, i897(v900(pp, p), smooth));         pn = x895(p, i897(v900(pn, p), smooth));     }      return [pp, pn]; }    function q4243(_pointP, _point, _pointN) {     const _pp = point(_pointP.x.value, _pointP.y.value);     let   _p  = point(_point .x.value, _point .y.value);     const _pn = point(_pointN.x.value, _pointN.y.value);       const v = v900(_pn, _pp);               let a = w887(         o883(v900(_p, _pp)),          o883(v900(_pn, _p)));               a = Math.abs(a);     while (a >= Tau/2) a -= Tau;       const k     = 4 * (Math.sqrt(2) - 1) / 3;        // or use the value 0.55191502449 from http://spencermortensen.com/articles/bezier-circle/
	const kCorr = 0.9993391093366649465402826439248;       let f =         a > Tau/4         ? 1/3 + (k*kCorr - 1/3) * Math.sin(a)         : 1/3 + (k*kCorr - 1/3) * (1 - Math.cos(a));           let pp = x895(_p, i897(w886(v), -f885(v)/2 * f));     let pn = x895(_p, i897(w886(v),  f885(v)/2 * f));      pp = i1020(pp);      _p = i1020(_p);      pn = i1020(pn);       return [pp, _p, pn]; }    function t4244(_pointP, _point, _pointN) {     const _pp = point(_pointP.x.value, _pointP.y.value);     const _p  = point(_point .x.value, _point .y.value);     const _pn = point(_pointN.x.value, _pointN.y.value);      const  pp = point(_p.x - (_p.x - _pp.x) * 0.3615, _p.y);     const  pn = point(_p.x + (_pn.x - _p.x) * 0.3615, _p.y);      return [pp, _p, pn]; }    function s4245(_pointP, _point, _pointN) {     const _pp = point(_pointP.x.value, _pointP.y.value);     const _p  = point(_point .x.value, _point .y.value);     const _pn = point(_pointN.x.value, _pointN.y.value);      const  pp = point(_p.x, _p.y - (_p.y - _pp.y) * 0.3615);     const  pn = point(_p.x, _p.y + (_pn.y - _p.y) * 0.3615);      return [pp, _p, pn]; }


class y1851 extends m1846 {     x;     y;     width;     height;          points;     edges;     regions;      networkData;        constructor(nodeId, objectId, objectName, points, edges, regions)     {         super(h1262, nodeId, objectId, objectName);                  this.points  = points .map(p => p.copy());         this.edges   = edges  .map(e => e.copy());         this.regions = regions.map(r => r.copy());           this.updateNetworkData();           let bounds = o1047.NaN;          for (let i = 0; i < this.edges.length; i++)         {             bounds = r3743(                 bounds,                  b865(                     this.edges[i].start.y3746(),                      this.edges[i].start.y3746(),                     this.edges[i].end  .y3746(),                     this.edges[i].end  .y3746()));         }          this.f3741(             bounds.x + bounds.width /2,                         bounds.y + bounds.height/2                     );     }        copy()     {         const copy = new y1851(             this.nodeId,             this.objectId,             this.objectName,              this.points,              this.edges,              this.regions);           copy.x      = this.x;         copy.y      = this.y;         copy.width  = this.width;         copy.height = this.height;           copy.o3358(this);           return copy;     }        updateNetworkData()     {         let minX = Number.MAX_SAFE_INTEGER;         let minY = Number.MAX_SAFE_INTEGER;         let maxX = Number.MIN_SAFE_INTEGER;         let maxY = Number.MIN_SAFE_INTEGER;          for (const p of this.points)         {             minX = Math.min(minX, p.x.value);             minY = Math.min(minY, p.y.value);             maxX = Math.max(maxX, p.x.value);             maxY = Math.max(maxY, p.y.value);         }           this.x      = minX;         this.y      = minY;         this.width  = maxX - minX;         this.height = maxY - minY;          this.l3729(this.x, this.y, this.width, this.height);           this.networkData = getNetworkData(this.points, this.edges, this.regions);     }        getBounds()     {         let bounds = o1047.NaN;          for (let i = 0; i < this.edges.length; i++)         {             const edge = this.edges[i];              const s  = edge.start;             const e  = edge.end;             let   st = edge.l3664;             let   et = edge.f3665;              if (!st.isValid()) st = s.copy();             if (!et.isValid()) et = e.copy();              bounds = r3743(                 bounds,                  b865(                     s .y3746(),                      st.y3746(),                     et.y3746(),                     e .y3746()));         }          return bounds;     }        q3632()     {         return y1851.fromObject(this);     }        t3740()     {         return [             ...super.t3740(),                  this.x,              this.y,              this.width,              this.height,               this.networkData         ];     } }    function getNetworkData(points, edges, _regions) {     const vertices = [];     const segments = [];     const regions  = [];       for (const point of points)     {         let join;         let cap;          switch (point.join.value)         {             case 0: join = 'MITER'; break;             case 1: join = 'BEVEL'; break;             case 2: join = 'ROUND'; break;         }              switch (point.cap.value)         {             case 0: cap = 'NONE';   break;             case 1: cap = 'SQUARE'; break;             case 2: cap = 'ROUND';  break;         }              vertices.push(         {             x:            point.x.value,             y:            point.y.value,             strokeJoin:   join,             strokeCap:    cap,             cornerRadius: point.round.value         });     }       for (const edge of edges)     {         segments.push(         {             start: points.findIndex(p => p.u3735 == edge.start.u3735),             end:   points.findIndex(p => p.u3735 == edge.end  .u3735)         });     }       for (const region of _regions)     {         const loops = [];          for (const _loop of region.loops.items)         {             const loop = [];              for (const _edge of _loop.items)                 loop.push(edges.findIndex(e => e.u3735 == _edge.u3735));              loops.push(loop);         }           regions.push(         {             windingRule: region.winding.value == 1 ? 'NONZERO' : 'EVENODD',             loops:       loops,             fills:       k956(region.fills)         });     }       let networkData =      {         vertices: vertices,         segments: segments,         regions:  regions     };       return networkData; }


class b1850 extends h1852 {     width;     height;      round;     bias;        constructor(nodeId, objectId, objectName, x, y, width, height, round, bias)     {         const tw = width * (1 + Math.min(0,  bias/100));         const bw = width * (1 + Math.min(0, -bias/100));                  const tx = x + (width - tw) / 2;         const bx = x + (width - bw) / 2;          const points =         [             t2022.create(nodeId, tx,      y         ),             t2022.create(nodeId, bx,      y + height),             t2022.create(nodeId, bx + bw, y + height),             t2022.create(nodeId, tx + tw, y         )         ];               super(             nodeId,              objectId,             objectName,              points,             1,              0,              0,              round);          this.type   = c1228;          this.x      = x;         this.y      = y;         this.width  = width;         this.height = height;          this.round  = round;         this.bias   = bias;                   this.f3741(             x + width /2,              y + height/2);     }        copy()     {         const copy = new b1850(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.width,             this.height,                          this.round,             this.bias);           copy.o3358(this);          copy.a3742();           return copy;     }        q3632()     {         return s2033.fromObject(this);     } } 


class m1844 extends m1846 {     x;     y;     width;     height;     round;     corners;        constructor(nodeId, objectId, objectName, x, y, width, height, round, corners)     {         super(e1237, nodeId, objectId, objectName);                  this.x       = x;         this.y       = y;         this.width   = width;         this.height  = height;          this.round   = round;         this.corners = corners;                   this.f3741(             x + width /2,              y + height/2);     }        copy()     {         const copy = new m1844(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.width,             this.height,                          this.round,             this.corners);           copy.o3358(this);           return copy;     }        q3632()     {         return u2023.fromObject(this);     }        t3740()     {         return [             ...super.t3740(),                  this.x,              this.y,              this.width,              this.height,               this.round * Math.abs(this.i3739),              this.corners         ];     } } 


class i1848 extends m1846 {     x;     y;     width;     height;      round;     points;     convex;        constructor(nodeId, objectId, objectName, x, y, width, height, round, points, convex)     {         super(f1240, nodeId, objectId, objectName);                  this.x      = x;         this.y      = y;         this.width  = width;         this.height = height;          this.round  = round;         this.points = points;         this.convex = convex;                   this.f3741(             x + width /2,              y + height/2);     }        copy()     {         const copy = new i1848(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.width,             this.height,              this.round,             this.points,             this.convex);          copy.o3358(this);          return copy;     }        q3632()     {         return q2029.fromObject(this);     }        t3740()     {         return [             ...super.t3740(),                  this.x,              this.y,              this.width,              this.height,               this.round * Math.abs(this.i3739),              this.points,              this.convex         ];     } } 


class o1849 extends m1846 {     text;          x;     y;     width;     height;          t3756;     y3757;          font;     size;     style;          alignX;     alignY;          lineHeight;     letterSpacing;        constructor(nodeId, objectId, objectName, text, x, y, width, height, font, size, style, alignX, alignY, lineHeight, letterSpacing)     {         super(k1243, nodeId, objectId, objectName);                  this.text          = text;              this.x             = x;         this.y             = y;         this.width         = width;         this.height        = height;              this.t3756      = width;         this.y3757     = height;              this.font          = font;         this.size          = size;         this.style         = style;              this.alignX        = alignX;         this.alignY        = alignY;              this.lineHeight    = lineHeight;         this.letterSpacing = letterSpacing;                   this.f3741(             x + width /2,              y + height/2);     }        copy()     {         const copy = new o1849(             this.nodeId,             this.objectId,             this.objectName,                  this.text,                  this.x,             this.y,             this.width,             this.height,                  this.font,             this.size,             this.style,                  this.alignX,             this.alignY,                  this.lineHeight,             this.letterSpacing);           copy.t3756  = this.t3756;         copy.y3757 = this.y3757;           copy.o3358(this);           return copy;     }        q3632()     {         return p2031.fromObject(this);     }        z3755()     {         return {             ...super.z3755(),                 x:             this.x,             y:             this.y,             width:         this.width,             height:        this.height,              t3756:      this.t3756,             y3757:     this.y3757,              text:          this.text,              font:          this.font,             size:          this.size,             style:         this.style,              alignX:        this.alignX,             alignY:        this.alignY,                          lineHeight:    this.lineHeight,             letterSpacing: this.letterSpacing         };     }        t3740()     {         return [             ...super.t3740(),                  this.x,              this.y,              this.width,              this.height,                           this.t3756,              this.y3757,                           this.text,               this.font,              this.size,              this.style,                           this.alignX,              this.alignY,                           this.lineHeight,              this.letterSpacing         ];     } } 


class d1843 extends m1846 {     x;     y;     smooth;        constructor(nodeId, objectId, objectName, x, y, smooth = 1, q3738 = false, isCenter = false, isXform = false)     {         super(q1246, nodeId, objectId, objectName, q3738, isXform);                  this.x        = x;         this.y        = y;         this.smooth   = smooth;         this.isCenter = isCenter;                   this.f3741(x, y);          this.s4097(x, y);     }        copy()     {         const copy = new d1843(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.smooth,             this.q3738,             this.isCenter);          copy.o3358(this);          return copy;     }        getBounds()     {         return new o1047(             this.x - 0.005,              this.y - 0.005,              0.01,              0.01);     }        checkFlipped(flipX, flipY)     {      }        y3746()     {         return point(this.x, this.y);     }        q3632()     {         return t2022.fromObject(this);     }        t3740()     {         return [             ...super.t3740(),                  this.x,              this.y         ];     } } 


class y1837 extends m1846 {     operation;      children;        constructor(nodeId, objectId, objectName, operation, children = [])     {         super(b1286, nodeId, objectId, objectName);                  this.operation = operation;                  this.children  = children.map(c => c.copy());     }        copy()     {         const copy = new y1837(             this.nodeId,             this.objectId,             this.objectName,              this.operation,             this.children);          copy.o3358(this);                  return copy;     }        getBounds()     {         return getObjBounds(this.children);     }        r4098(y4207, affectSpace)     {         for (const g111 of this.children)             g111.r4098(y4207, affectSpace);     }        z3755()     {         return {             ...super.z3755(),                 operation: this.operation,             children:  this.children         };     }        t3740()     {         return [             ...super.t3740(),                  this.children.map(o => o.t3740()),              this.operation         ];     } }


class FigmaArcPath extends h1852 {     position;                          start;     sweep;            constructor(nodeId, objectId, objectName, pos, x, y, width, height, start, sweep)     {         let points = makeArc_(             point(                 x + width /2,                  y + height/2),              width/2,               start,              start + sweep);                      points = points.map(p => t2022.fromPoint(nodeId, p));           points.forEach(p =>          {             p.y.value =                  pos > 0                 ? p.y.value * height/nozero(width)                 : height/2 + (p.y.value - height/2) * height/nozero(width);              if (   pos == 0                 && width < 0)                  p.x.value += width;         });          if (width  < 0) width  *= -1;         if (height < 0) height *= -1;           super(             nodeId,              objectId,             objectName,             points,             0,               2,               0,               0);                    this.position = pos;         this.x       = x;         this.y       = y;         this.width   = width;         this.height  = height;          this.start    = start;         this.sweep    = sweep;           this.f3741(             x + width /2,             y + height/2);     }        copy()     {         const copy = new FigmaArcPath(             this.nodeId,             this.objectId,             this.objectName,              this.position,             this.x,             this.y,             this.width,             this.height,                          this.start,             this.sweep);           copy.r3745 = [...this.r3745];         copy.l4031   = this.l4031;          copy.o3358(this);           return copy;     } }


class FigmaWavePath extends h1852 {     shape;     _x;     _y;     i3072;     amplitude;     frequency;     offset;     alignX;     alignY;            constructor(nodeId, objectId, objectName, shape, x, y, width, amplitude, frequency, offset, alignX, alignY)     {         let points = makeWave(             shape,              x,             y,             width,              amplitude,              frequency,             offset,             alignX,             alignY);          points = points.map(p => t2022.fromPoint(nodeId, p));           super(             nodeId,              objectId,             objectName,             points,             0,                               shape == 4 ? 2 : 0,              0,                               0);                                    this.shape     = shape;         this._x        = x;         this._y        = y;         this.i3072    = width;         this.amplitude = amplitude;         this.frequency = frequency;         this.offset    = offset;         this.alignX    = alignX;         this.alignY    = alignY;           let height = amplitude;                  this.f3741(             x + width /2,             y + height/2);     }        copy()     {         const copy = new FigmaWavePath(             this.nodeId,             this.objectId,             this.objectName,              this.shape,             this._x,             this._y,             this.i3072,             this.amplitude,             this.frequency,             this.offset,             this.alignX,             this.alignY);           copy.r3745 = [...this.r3745];         copy.l4031   = this.l4031;          copy.o3358(this);           return copy;     } }


class v1847 extends m1846 {     children;        constructor(nodeId, objectId, objectName, children = [])     {         super(g1265, nodeId, objectId, objectName);                  this.children = children.map(c => c.copy());     }        copy()     {         const copy = new v1847(             this.nodeId,             this.objectId,             this.objectName,              this.children);          copy.o3358(this);          return copy;     }        getCount()     {         let v3333 =             this.children.length > 0             ? super.getCount()             : 0;          for (const g111 of this.children)             v3333 += g111.getCount();          return v3333;     }        f3741(cx = 0, cy = 0)     {         super.f3741(cx, cy);          for (const g111 of this.children)             g111.f3741(cx, cy);     }        resetSpace(bounds, singlePoint = false, cx = 0.5, cy = 0.5, units = 0)     {         super.resetSpace(bounds, false, cx, cy, units);          for (const g111 of this.children)             g111.resetSpace(bounds, false, cx, cy, units);     }        getBounds()     {         return getObjBounds(this.children);     }        r4098(y4207, affectSpace)     {         for (const g111 of this.children)             g111.r4098(y4207, affectSpace);     }        z3755()     {         return {             ...super.z3755(),                 children: this.children         };     }        t3740()     {         return [             ...super.t3740(),                  this.children.map(o => o.t3740())         ];     } }


class l1840 extends m1846 {     x;     y;     width;     height;      round;          clip;      children;        constructor(nodeId, objectId, objectName, x, y, width, height, round, clip, children = [])     {         super(t1268, nodeId, objectId, objectName);                  this.x        = x;         this.y        = y;         this.width    = width;         this.height   = height;              this.round    = round;          this.clip     = clip;              this.children = children.map(c => c.copy());          this.f3741(             x + width /2,              y + height/2);     }        copy()     {         const copy = new l1840(             this.nodeId,             this.objectId,             this.objectName,                  this.x,             this.y,             this.width,             this.height,                  this.round,                this.clip,                  this.children);           copy.o3358(this);           return copy;     }        getCount()     {         let v3333 = super.getCount();          for (const g111 of this.children)             v3333 += g111.getCount();          return v3333;     }            checkFlipped(flipX, flipY)     {         super.checkFlipped(flipX, flipY);          for (const g111 of this.children)         {             g111.checkFlipped(flipX, flipY);              if (flipX)             {                 g111.xp0.x = this.width - g111.xp0.x;                 g111.xp1.x = this.width - g111.xp1.x;                 g111.xp2.x = this.width - g111.xp2.x;             }              if (flipY)             {                 g111.xp0.y = this.height - g111.xp0.y;                 g111.xp1.y = this.height - g111.xp1.y;                 g111.xp2.y = this.height - g111.xp2.y;             }         }     }        z3755()     {         return {             ...super.z3755(),                 x:        this.x,             y:        this.y,             width:    this.width,             height:   this.height,                      round:    this.round,              clip:     this.clip,                      children: this.children         };     }        t3740()     {         return [             ...super.t3740(),                  this.x,              this.y,              this.width,              this.height,               this.round,               this.clip,               this.children.map(o => o.t3740())         ];     } }    


class k1838 {     type;          nodeId = '';      styleId;     styleName;      paints = [];          constructor(nodeId, styleId, styleName)     {         this.type      = w1216;         this.nodeId    = nodeId;          this.styleId   = styleId;         this.styleName = styleName;     }        copy()     {         const copy = new k1838(this.nodeId, this.styleId, this.styleName);            return copy;     }        t3740()     {         return [          this.type,          this.nodeId,           this.styleId,          this.styleName,                   this.paints         ];     } }


class q2041 {     static nextUniqueId = 0;      type;       valid;       listId           = -1;     u3735;      cached           = true;     unknown          = false;      q3820           = NULL;      currentIteration = 0;     iterated         = false;       c3095     = null;        constructor(type, options)      {         this.type    = type;          if (options && options.cached ) this.cached  = options.cached;         if (options && options.unknown) this.unknown = options.unknown;               this.u3735 = q2041.nextUniqueId++;     }        reset()     {                                                                                   this.c3095 = null;     }        copy()     {         c953('abstract type q2041 cannot be copied');         return null;     }        o3358(base)     {                  this.u3735 = base.u3735;     }        y3767()     {         if (    this.input             &&  this.input.y3767             && !this.input.notCondition)             return this.input.y3767();                  return this;     }            q3632()     {         return null;     }        toString()      {          return this.type;      }        n2118()     {         return this.toString();     }        isValid()      {         return false;     }            validate()     {         this.valid = true;     }        invalidate()     {         this.valid = false;     }        g4087(parse)     {      }        e4088(parse, from, force = false)     {         if (   this.unknown             || force)             this.valid = false;          return true;     }        y3628(parse, nodeId)     {      }        i3629(parse, nodeId)     {      }        q4086(parse)     {      }        z3631(parse, nodeId)     {      }     } 


class d2049  {     type;     valueId;      customParams = [];       objects      = null;        constructor(type)      {                   this.type    = type;          this.valueId = '';     }        reset() {}        copy()     {         c953('abstract class d2049 cannot be copied');         return null;     }        o3358(base)     {                           this.valueId  = base.valueId;         this.u3735 = base.u3735;          this.v3625(base);          if (base.objects)             this.g3626(base.objects);     }        v3625(base)     {         for (const param of base.customParams)             this.customParams.push([param[0], param[1].copy()]);     }        g3626(objects)     {         this.objects = objects.map(o => o.copy());     }                               t3711()     {         return false;     }        q3632()     {         return this.copy();     }        n2118()      {          return this.toString();      }        toString()      {          return this.type;      }        k3705()     {         return this.toString();     }        r2846(gen)     {         c953('invalid abstract method');         return '';     }        p3357()     {         c953('invalid abstract method');         return null;     }        isCached()     {         return true;     }        g4087(parse)              {}     e4088(parse, from, force) {}     q4086     (parse)              {} }    function a3836(type, value) {     switch (type)     {         case            j1087: return parseNullValue         (value)[0];          case           z1056:          case    f1057:          case      g1058:          case     a1059: return u3481         (value)[0];          case         m1091: return h2849       (value)[0];         case           i1143: return k2864         (value)[0];         case          a1168: return r2865        (value)[0];          case           a1178: return g3676         (value)[0];         case     i1184: return u2866    (value)[0];         case       q1187: return d3675     (value)[0];         case         i1181: return d3831       (value)[0];         case    d1196: return y3832   (value)[0];         case   l1199: return x3833  (value)[0];         case     h1202: return c3834    (value)[0];         case      k1205: return r3706     (value)[0];         case    k1211: return f3707   (value)[0];         case     t1208: return h3708    (value)[0];          case      m1218: return a3710    (value)[0];         case           p1221: return u3821         (value)[0];         case        a1224: return s3822      (value)[0];         case        d1227: return a3823      (value)[0];         case        b1236: return f3824      (value)[0];         case           y1239: return f3825         (value)[0];         case     x1242: return q3826    (value)[0];         case          v1245: return c3827        (value)[0];         case    q1249: return d3669   (value)[0];         case  u1252: return e3668 (value)[0];         case    i1255: return s3666   (value)[0];         case  o1258: return n3663 (value)[0];         case z1261: return r3662(value)[0];         case  i1287: return k3828 (value)[0];         case    f1264: return u3829   (value)[0];         case       v1231: return parseArcPathValue      (value)[0];         case      c1234: return parseWavePathValue     (value)[0];         case          q1267: return m3830        (value)[0];                  default:              console.error('unknown type \'' + type + '\'');             console.log('value =', value);             return null;     } }    function q4209(type, value) {     if (   type == m1091         && value.indexOf(',') < 0)         return value;       switch (type)     {         case            j1087: return parseNullValue         (value)[0].k3705();         case           z1056: return u3481         (value)[0].k3705();          case         m1091: return h2849       (value)[0].k3705();         case           i1143: const val = k2864    (value)[0]; return val == '' ? '\'\'' : val.k3705();         case          a1168: return r2865        (value)[0].k3705();         case           a1178: return g3676         (value)[0].k3705();         case     i1184: return u2866    (value)[0].k3705();         case       q1187: return d3675     (value)[0].k3705();         case         i1181: return d3831       (value)[0].k3705();         case    d1196: return y3832   (value)[0].k3705();         case   l1199: return x3833  (value)[0].k3705();         case     h1202: return c3834    (value)[0].k3705();         case      k1205: return r3706     (value)[0].k3705();         case    k1211: return f3707   (value)[0].k3705();         case     t1208: return h3708    (value)[0].k3705();          case      m1218: return a3710    (value)[0].k3705();         case           p1221: return u3821         (value)[0].k3705();         case        a1224: return s3822      (value)[0].k3705();         case        d1227: return a3823      (value)[0].k3705();         case        b1236: return f3824      (value)[0].k3705();         case           y1239: return f3825         (value)[0].k3705();         case     x1242: return q3826    (value)[0].k3705();         case          v1245: return c3827        (value)[0].k3705();         case    q1249: return d3669   (value)[0].k3705();         case  u1252: return e3668 (value)[0].k3705();         case    i1255: return s3666   (value)[0].k3705();         case  o1258: return n3663 (value)[0].k3705();         case z1261: return r3662(value)[0].k3705();         case  i1287: return k3828 (value)[0].k3705();         case    f1264: return u3829   (value)[0].k3705();         case          q1267: return m3830        (value)[0].k3705();     }       c953('cannot display value of type \'' + type + '\''); }    function nanFromType(type) {     switch (type)     {         case            z1056: return          u2020.NaN;          case          m1091: return        z2021.NaN;         case            i1143: return        new b2032();         case           a1168: return         a2009.NaN;         case            a1178: return          e2012.NaN;         case      i1184: return     a2008.NaN;         case        q1187: return      m2014.NaN;         case          i1181: return        o2030.NaN;         case     d1196: return    s2010.NaN;         case    l1199: return   x2015.NaN;         case      h1202: return     z2017.NaN;         case       k1205: return      p2007.NaN;         case     k1211: return    f2016.NaN;         case      t1208: return     c2018.NaN;          case       m1218: return     k2024.NaN;         case            p1221: return          l2019.NaN;         case         a1224: return       g2011.NaN;         case         b1236: return       u2023.NaN;         case            y1239: return          q2029.NaN;         case      x1242: return     p2031.NaN;         case           v1245: return         t2022.NaN;         case     q1249: return    y2036.NaN;         case   u1252: return  z2038.NaN;         case     i1255: return    t2034.NaN;         case   o1258: return  v2037.NaN;         case  z1261: return q2035.NaN;         case   i1287: return  s2026.NaN;         case     f1264: return    f2027.NaN;         case           q1267: return         j2013.NaN;     }      c953('cannot determine null value from type \'' + type + '\''); }


class z2042 extends q2041 {     nodeId;     nodeName;      topLevel;      value;          customParams = [];      options      = {};     c3095 = [];               constructor(type, nodeId, options)     {         super(type, options);          this.nodeId   = nodeId;         this.nodeName = options.nodeName;          this.options  = clone(options);          this.valid    = false;         this.topLevel = false;          this.value    = null;     }        reset()     {         this.customParams = [];         this.options      = {};         this.c3095 = [];     }        o3358(base)     {         super.o3358(base);                  this.nodeId   = base.nodeId;         this.nodeName = base.nodeName;          this.v3625(base);          this.options  = clone(base.options);          this.valid    = base.valid;         this.topLevel = base.topLevel;          if (base.value) this.value = base.value.copy();     }        v3625(base)     {         for (const param of base.customParams)             this.customParams.push([param[0], param[1].copy()]);     }        u4241(v2991)     {         return v2991 == 'value'             ?  this.value             :  this[v2991];     }        isCached()     {         return this.options.cached             && this.valid;     }        async eval(parse)     {                   return this;     }        async t4099(parse)     {      }        g3626(value, listId = -1)     {         const objects = t3627(value);         const copies  = [];                                  for (let i = 0; i < objects.length; i++)         {             const g111 = w3737(objects[i]);                  g111.nodeId   = this.nodeId;             g111.listId   = listId;                          g111.objectId = g111.objectId + c967 + this.nodeId;                  copies.push(g111);         }          return copies;     }                outputType()     {         return this.value             ? new b2032(                 o957(this.value.type)                 ? s3478(this.value.items)                 : this.value.type)             : new b2032(j1087);     }        outputListType()     {         return this.outputType();                                }        q3632()     {         return this.value              ? this.value.copy()              : null;     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.unknown)             this.valid = false;          this.iterated = false;     }        y3628(parse, nodeId)     {         this.q3820           = nodeId;         this.currentIteration = 0;     }        i3629(parse, nodeId)     {         this.valid = false;     }        q4086(parse)     {         const h3630 = parse.repeats.findIndex(r => r.repeatId == this.q3820);                                                                if (   (   h3630 < 0                 || h3630 == parse.repeats.length-1)             && !this.iterated)         {                          this.currentIteration++;             this.iterated = true;         }     }        iterateCache(parse, from)     {      }        z3631(parse, nodeId)     {         this.valid            = false;         this.currentIteration = 0;     }            l4100(parse, values, add = false)     {         if (    parse.repeats.length == 0             ||  this.unknown && parse.repeats[0].total == 0             || !this.unknown             ||  parse.repeats.at(-1).currentIteration == 0             ||  parse.repeats.at(-1).currentIteration == parse.repeats.at(-1).total-1)         {             if (add) this.c3095.push(...values);             else     this.c3095 = [...values];         }         else if (!add)             this.c3095 = [];     }        g4087(parse)     {                 if (!this.c3095)             return;          for (const value of this.c3095)             z2061(parse, this.nodeId, value[0], value[1]);                   this.c3095 = [];     }        g4215()     {         if (   !this.value             || !this.value.objects)             return;           for (let i = 0; i < this.value.objects.length; i++)         {             const g111     = this.value.objects[i];              g111.nodeId    = this.nodeId;             g111.objectId += c967 + this.nodeId;             g111.listId    = -1;         }     }                                                                           setConditionInput(input)     {      } }    async function evalValue(_value, parse, nan = () => new x4216()) {     let value =          _value          ? (await _value.eval(parse)).q3632()          : null;      if (    value          && !value.isValid()         && nan)          value = nan();      return value; }    async function evalNumberValue        (_value, parse) { return await evalValue(_value, parse, () => z2021        .NaN.copy()); } async function evalTextValue          (_value, parse) { return await evalValue(_value, parse, () => new b2032());                }  async function evalColorValue         (_value, parse) { return await evalValue(_value, parse, () => a2009         .NaN.copy()); } async function evalFillValue          (_value, parse) { return await evalValue(_value, parse, () => e2012          .NaN.copy()); } async function evalStrokeValue        (_value, parse) { return await evalValue(_value, parse, () => o2030        .NaN.copy()); } async function evalColorStopValue     (_value, parse) { return await evalValue(_value, parse, () => a2008     .NaN.copy()); } async function evalGradientValue      (_value, parse) { return await evalValue(_value, parse, () => m2014      .NaN.copy()); }  async function evalListValue          (_value, parse) { return await evalValue(_value, parse, () => u2020          .NaN.copy()); }  async function evalRectangleValue     (_value, parse) { return await evalValue(_value, parse, () => k2024     .NaN.copy()); } async function evalLineValue          (_value, parse) { return await evalValue(_value, parse, () => l2019          .NaN.copy()); } async function evalPolygonValue       (_value, parse) { return await evalValue(_value, parse, () => u2023       .NaN.copy()); } async function evalTextShapeValue     (_value, parse) { return await evalValue(_value, parse, () => p2031     .NaN.copy()); }  async function evalPointValue         (_value, parse) { return await evalValue(_value, parse, () => t2022         .NaN.copy()); } async function evalVectorPathValue    (_value, parse) { return await evalValue(_value, parse, () => y2036    .NaN.copy()); } async function evalArcPathValue       (_value, parse) { return await evalValue(_value, parse, () => ArcPathValue       .NaN.copy()); } async function evalWavePathValue      (_value, parse) { return await evalValue(_value, parse, () => WavePathValue      .NaN.copy()); } async function evalVectorVertexValue  (_value, parse) { return await evalValue(_value, parse, () => z2038  .NaN.copy()); } async function evalVectorEdgeValue    (_value, parse) { return await evalValue(_value, parse, () => t2034    .NaN.copy()); } async function evalVectorRegionValue  (_value, parse) { return await evalValue(_value, parse, () => v2037  .NaN.copy()); }  async function evalFrameValue         (_value, parse) { return await evalValue(_value, parse, () => j2013         .NaN.copy()); }  async function evalInnerShadowValue   (_value, parse) { return await evalValue(_value, parse, () => x2015   .NaN.copy()); } async function evalLayerBlurValue     (_value, parse) { return await evalValue(_value, parse, () => z2017     .NaN.copy()); } async function evalStrokeSidesValue   (_value, parse) { return await evalValue(_value, parse, () => n4271   .NaN.copy()); } async function evalRoundedCornersValue(_value, parse) { return await evalValue(_value, parse, () => RoundedCornersValue.NaN.copy()); } 


class u2043 extends z2042 {     input = null;        reset()     {         super.reset();          this.input = null;     }        o3358(base)     {         super.o3358(base);          if (base.input) this.input = base.input.copy();     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        isValid()     {         return this.input && this.input.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.input) this.input.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.input) this.input.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.input) this.input.q4086(parse);     }        y3767()     {         if (    this.input             &&  this.input.y3767             && !this.input.notCondition)             return this.input.y3767();                  return this;     }        setConditionInput(input)     {         this.input = input;     } }


class z2044 extends z2042 {     z4082 = null;     z4083 = null;        reset()     {         super.reset();          this.z4082 = null;         this.z4083 = null;     }        o3358(base)     {         super.o3358(base);          if (base.z4082) this.z4082 = base.z4082.copy();         if (base.z4083) this.z4083 = base.z4083.copy();     }        isCached()     {         return super.isCached()             && (!this.z4082 || this.z4082.isCached())             && (!this.z4083 || this.z4083.isCached());     }        e4089(node)     {         return this.z4082 && this.z4082.nodeId == node.nodeId             || this.z4083 && this.z4083.nodeId == node.nodeId;     }        isValid()     {         return this.z4082 && this.z4082.isValid()             && this.z4083 && this.z4083.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.z4082) this.z4082.g4087(parse);         if (this.z4083) this.z4083.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.z4082) this.z4082.e4088(parse, from, force);         if (this.z4083) this.z4083.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.z4082) this.z4082.q4086(parse);         if (this.z4083) this.z4083.q4086(parse);     }        y3767()     {         if (    this.z4082             &&  this.z4082.y3767             && !this.z4082.notCondition)             return this.z4082.y3767();                  else if (this.z4083              &&  this.z4083.y3767              && !this.z4083.notCondition)             return this.z4083.y3767();                  return this;     } }


class p2045 extends z2042 {     z4082 = null;     z4083 = null;     n4084 = null;        reset()     {         super.reset();          this.z4082 = null;         this.z4083 = null;         this.n4084 = null;     }        o3358(base)     {         super.o3358(base);          if (base.z4082) this.z4082 = base.z4082.copy();         if (base.z4083) this.z4083 = base.z4083.copy();         if (base.n4084) this.n4084 = base.n4084.copy();     }        isCached()     {         return super.isCached()             && (!this.z4082 || this.z4082.isCached())             && (!this.z4083 || this.z4083.isCached())             && (!this.n4084 || this.n4084.isCached());     }        e4089(node)     {         return this.z4082 && this.z4082.nodeId == node.nodeId             || this.z4083 && this.z4083.nodeId == node.nodeId             || this.n4084 && this.n4084.nodeId == node.nodeId;     }        isValid()     {         return this.z4082 && this.z4082.isValid()             && this.z4083 && this.z4083.isValid()             && this.n4084 && this.n4084.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.z4082) this.z4082.g4087(parse);         if (this.z4083) this.z4083.g4087(parse);         if (this.n4084) this.n4084.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.z4082) this.z4082.e4088(parse, from, force);         if (this.z4083) this.z4083.e4088(parse, from, force);         if (this.n4084) this.n4084.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.z4082) this.z4082.q4086(parse);         if (this.z4083) this.z4083.q4086(parse);         if (this.n4084) this.n4084.q4086(parse);     }        y3767()     {         if (    this.z4082             &&  this.z4082.y3767             && !this.z4082.notCondition)             return this.z4082.y3767();                  else if (this.z4083              &&  this.z4083.y3767              && !this.z4083.notCondition)             return this.z4083.y3767();                  else if (this.n4084              &&  this.n4084.y3767              && !this.n4084.notCondition)             return this.n4084.y3767();                  return this;     } }


class n2046 extends z2042 {     z4082 = null;     z4083 = null;     n4084 = null;     l4085 = null;        reset()     {         super.reset();          this.z4082 = null;         this.z4083 = null;         this.n4084 = null;         this.l4085 = null;     }        o3358(base)     {         super.o3358(base);          if (base.z4082) this.z4082 = base.z4082.copy();         if (base.z4083) this.z4083 = base.z4083.copy();         if (base.n4084) this.n4084 = base.n4084.copy();         if (base.l4085) this.l4085 = base.l4085.copy();     }        isCached()     {         return super.isCached()             && (!this.z4082 || this.z4082.isCached())             && (!this.z4083 || this.z4083.isCached())             && (!this.n4084 || this.n4084.isCached())             && (!this.l4085 || this.l4085.isCached());     }        e4089(node)     {         return this.z4082 && this.z4082.nodeId == node.nodeId             || this.z4083 && this.z4083.nodeId == node.nodeId             || this.n4084 && this.n4084.nodeId == node.nodeId             || this.l4085 && this.l4085.nodeId == node.nodeId;     }        isValid()     {         return this.z4082 && this.z4082.isValid()             && this.z4083 && this.z4083.isValid()             && this.n4084 && this.n4084.isValid()             && this.l4085 && this.l4085.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.z4082) this.z4082.g4087(parse);         if (this.z4083) this.z4083.g4087(parse);         if (this.n4084) this.n4084.g4087(parse);         if (this.l4085) this.l4085.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.z4082) this.z4082.e4088(parse, from, force);         if (this.z4083) this.z4083.e4088(parse, from, force);         if (this.n4084) this.n4084.e4088(parse, from, force);         if (this.l4085) this.l4085.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.z4082) this.z4082.q4086(parse);         if (this.z4083) this.z4083.q4086(parse);         if (this.n4084) this.n4084.q4086(parse);         if (this.l4085) this.l4085.q4086(parse);     }        y3767()     {         if (    this.z4082             &&  this.z4082.y3767             && !this.z4082.notCondition)             return this.z4082.y3767();                  else if (this.z4083              &&  this.z4083.y3767              && !this.z4083.notCondition)             return this.z4083.y3767();                  else if (this.n4084              &&  this.n4084.y3767              && !this.n4084.notCondition)             return this.n4084.y3767();                  else if (this.l4085              &&  this.l4085.y3767              && !this.l4085.notCondition)             return this.l4085.y3767();                  return this;     } }


class b2048 extends z2042 {     v2991;          node;     param;            constructor(nodeId, v2991)     {         super(PARAM, nodeId, false);          this.v2991 = v2991;     }        reset()     {         if (this.node)             this.node.reset();     }        copy()     {         const copy = new b2048(this.nodeId, this.v2991);          copy.o3358(this);          copy.node = this.node;              return copy;     }        y3767()     {         return this.node              ? this.node.y3767()              : null;     }        async eval(parse)     {         this.node = parse.c4242.find(v => v.nodeId == this.nodeId);         c952(this.node, 'can\'t find parameter node \'' + this.nodeId + '\'');           if (    this.node.type != k1080             || !this.node.a4211)             await this.node.eval(parse);           this.param = this.node.u4241(this.v2991);           if (isValid(this.param))         {             if (   this.node.type != s1063                 && this.v2991 != 'from')                 this.value = await evalValue(this.param, parse);             else                 this.value = new x4216();                               return this.value                  ? this.value.copy()                  : null;         }         else             return this.value = new x4216();     }        isCached()     {         return super.isCached();      }        q3632()     {         return this.value.copy();     }        g4087(parse)     {         super.g4087(parse);          if (this.node) this.node.g4087(parse);     }            e4088(parse, from, force)     {         super.e4088(parse, from, force);                  if (this.node) this.node.e4088(parse, from, force);     }        y3628(parse, nodeId)     {         const node = parse.c4242.find(n => n.nodeId == this.nodeId);                  node.y3628(parse, nodeId);     }        iterateCache(parse, from)     {         const node = parse.c4242.find(n => n.nodeId == this.nodeId);                   node.iterateCache(parse, from);     }        i3629(parse, nodeId)     {         const node = parse.c4242.find(n => n.nodeId == this.nodeId);                  node.i3629(parse, nodeId);     }        y3628(parse, nodeId)     {         const node = parse.c4242.find(n => n.nodeId == this.nodeId);                  node.y3628(parse, nodeId);     }        q4086(parse)     {         const node = parse.c4242.find(n => n.nodeId == this.nodeId);                  node.q4086(parse);     }        z3631(parse, nodeId)     {         const node = parse.c4242.find(n => n.nodeId == this.nodeId);                  node.z3631(parse, nodeId);     }                                                                                                                                                                                                 }


class x4216 extends d2049 {     value;        constructor()     {         super(j1087);          this.value = null;     }        copy()     {         const copy = new x4216();          copy.o3358(this);          return copy;     }        equals(_null)     {         return _null             && this.type  == _null.type             && this.value == _null.value;     }        async eval(parse)     {         return this;     }        t3711()     {         return true;     }        isValid()     {         return false;     }        q3632()     {         return this.copy();     }        n2118()      {          return this.toString();      }        toString()     {         return '';     }        d3704()     {         return 'NULL';     }        k3705()     {         return 'NULL';     }        r2846(gen)     {         return this.d3704();     }        p3357()     {         return this;     } }    function parseNullValue(str) {     const _null = new x4216();      return [_null, 1]; } 


class u2020 extends d2049 {     items;      condensed = false;        constructor(items = [])     {         super(z1056);          if (items)         {             this.items = [];              for (const item of items)             {                 this.items.push(item.copy());                  if (   this.objects                     && item.objects)                     this.objects.push(...item.objects.map(o => o.copy()));             }         }     }        copy()     {         const copy = new u2020(this.items);          copy.o3358(this);          copy.condensed = this.condensed;          return copy;     }        equals(list)     {         if (!list)                                  return false;         if (!(list instanceof u2020))           return false;         if (this.items.length != list.items.length) return false;                      for (let i = 0; i < this.items.length; i++)             if (!this.items[i].equals(list.items[i]))                 return false;          return true;     }        async eval(parse)     {         return this.copy();     }        q3632()     {         return this.copy();     }        t3711()     {         if (!this.items)             return false;                      for (const item of this.items)             if (!item.t3711())                 return false;          return true;     }        isValid()     {                  return  this.items;              }        n2118()     {         if (!this.items)             return '';           let str = '';                           str += this.items.length;          for (let i = 0; i < this.items.length; i++)         {             const item = this.items[i];              str += ' ' + item.type + ' ';             str += item.n2118();         }           return str;     }        toString()     {         if (!this.items)             return '';           let str = '';                           str += this.items.length;          for (let i = 0; i < this.items.length; i++)         {             const item = this.items[i];              str += ' ' + item.type + ' ';             str += item.toString();         }           return str;     }        d3704()     {         if (!this.items)             return '';           const nItems = Math.min(this.items.length, 10);           let str = '';          for (let i = 0; i < nItems; i++)         {             if (i > 0)                  str += '<br/>';               const item = this.items[i];              if (o957(item.type))                              {                 for (let j = 0; j < item.items.length; j++)                 {                     if (j > 0)                          str += ', ';                                          str += item.items[j].d3704();                 }             }             else                 str += item.d3704();         }          if (this.items.length > 10)              str += '<br/>. . .';                  return str;     }        k3705()     {         if (!this.items)             return '';           let str = '';                           str += this.items.length;          for (let i = 0; i < this.items.length; i++)         {             const item = this.items[i];              str += ' ' + item.type + ' ';             str += item.k3705();         }           return str;     }        p3357()     {         return u2020.NaN.copy();     }        static NaN = Object.freeze(new u2020(null)); }    function u3481(str, i = -1) {     if (i < 0)     {         str = str.split(' ');         i   = 0;     }                   const p3768  = i;     const r4208 = parseInt(str[i++]);               const list = new u2020();       for (let j = 0; j < r4208; j++)     {         const type = str[i++];          switch (type)         {             case          z1056:               case   f1057:               case     g1058:               case    a1059: { const _list   = u3481        (str, i);  i += _list  [1];  list.items.push(_list  [0]);  break; }               case        m1091: { const num     = h2849      (str[i]);  i += num    [1];  list.items.push(num    [0]);  break; }             case          i1143: { const text    = k2864        (str[i]);  i += text   [1];  list.items.push(text   [0]);  break; }             case         a1168: { const color   = r2865       (str, i);  i += color  [1];  list.items.push(color  [0]);  break; }              case          a1178: { const fill    = g3676        (str, i);  i += fill   [1];  list.items.push(fill   [0]);  break; }             case    i1184: { const stop    = u2866   (str, i);  i += stop   [1];  list.items.push(stop   [0]);  break; }             case      q1187: { const grad    = d3675    (str, i);  i += grad   [1];  list.items.push(grad   [0]);  break; }             case        i1181: { const stroke  = d3831      (str, i);  i += stroke [1];  list.items.push(stroke [0]);  break; }             case   d1196: { const shadow  = y3832  (str, i);  i += shadow [1];  list.items.push(shadow [0]);  break; }             case  l1199: { const shadow  = x3833 (str, i);  i += shadow [1];  list.items.push(shadow [0]);  break; }             case    h1202: { const blur    = c3834   (str, i);  i += blur   [1];  list.items.push(blur   [0]);  break; }             case     k1205: { const blur    = r3706    (str, i);  i += blur   [1];  list.items.push(blur   [0]);  break; }             case   k1211: { const layer   = f3707  (str, i);  i += layer  [1];  list.items.push(layer  [0]);  break; }             case    t1208: { const mask    = h3708   (str[i]);  i += mask   [1];  list.items.push(mask   [0]);  break; }              case     m1218: { const rect    = a3710   (str, i);  i += rect   [1];  list.items.push(rect   [0]);  break; }             case          p1221: { const line    = u3821        (str, i);  i += line   [1];  list.items.push(line   [0]);  break; }             case       a1224: { const ellipse = s3822     (str, i);  i += ellipse[1];  list.items.push(ellipse[0]);  break; }             case       d1227: { const trapeze = a3823     (str, i);  i += trapeze[1];  list.items.push(trapeze[0]);  break; }             case       b1236: { const poly    = f3824     (str, i);  i += poly   [1];  list.items.push(poly   [0]);  break; }             case          y1239: { const star    = f3825        (str, i);  i += star   [1];  list.items.push(star   [0]);  break; }             case    x1242: { const text    = q3826   (str, i);  i += text   [1];  list.items.push(text   [0]);  break; }             case         v1245: { const point   = c3827       (str, i);  i += point  [1];  list.items.push(point  [0]);  break; }             case   q1249: { const path    = d3669  (str, i);  i += path   [1];  list.items.push(path   [0]);  break; }             case i1287: { const bool    = k3828(str, i);  i += bool   [1];  list.items.push(bool   [0]);  break; }             case   f1264: { const group   = u3829  (str, i);  i += group  [1];  list.items.push(group  [0]);  break; }             case         q1267: { const frame   = m3830       (str, i);  i += frame  [1];  list.items.push(frame  [0]);  break; }         }     }           return [         list,          i - p3768]; }    function getItemTypes(items, debug) {     const types = [];      for (const item of items)     {         if (   item.type ==        z1056             || item.type == f1057             || item.type ==   g1058             || item.type ==  a1059)             e949(types, s3478(item.items, debug));          else             e949(types, item.type);     }      return types; }    function finalTypeFromItems(items) {     return finalTypeFromTypes(getItemTypes(items)); }    function s3478(items) {     return v3035(getItemTypes(items)); }    function finalTypeFromTypes(types) {     let _type = j1087;      for (const type of types)     {         if (_type == j1087)             _type = type;          else if (    f1294.includes(_type)                   && !f1294.includes( type))         {             _type = j1087;             break;          }         else if (   !f1294.includes(_type)                   && _type != type)         {             _type = j1087;             break;          }     }      return _type; }    function v3035(types) {     let _type = finalTypeFromTypes(types);               if (  _type == m1091)      return f1057;     else if (  _type ==   i1143)      return   g1058;     else if (f1294.includes(_type)) return  a1059;     else                                   return        z1056; }


class z2021 extends d2049 {     value;     g3788;     decimals;        constructor(val = Number.NaN, dec = -1)     {         super(m1091);          if (typeof val !== 'number')             c953('NumberValue(value) is ' + typeof val + ', must be a number');           this.value     = val;         this.g3788 = val;                  this.decimals =                !isNaN(this.value)              && dec == -1              ? i1004(this.value)              : dec;     }        static fromString(str)     {         return new z2021(             parseFloat(str),             u1459(str));     }        copy()     {         const copy = new z2021(             this.value,              this.decimals);          copy.g3788 = this.g3788;          copy.o3358(this);          return copy;     }        equals(num)     {         return num             && this.value    == num.value             && this.decimals == num.decimals;     }        async eval(parse)     {         return this.copy();     }        t3711()     {         return this.value == this.g3788;     }        isValid()     {         return !isNaN(this.value)             && !isNaN(this.decimals);     }        c3728()     {         return new z2021(Math.round(this.value));     }        f3702()     {         return i1016(this.value, this.decimals);     }        toString()     {         return q1471(this.value)               + ','               + q1471(this.decimals);     }        d3704()     {         return this.isValid()              ? i1006(this.value, this.decimals)              : e964;     }        k3705()     {         return q1471(this.value)               + (!isNaN(this.decimals)                 ? '_' + this.decimals                  : '');     }        r2846(gen)     {         return this.d3704();     }        p3357()     {         return z2021.NaN.copy();     }        static NaN = Object.freeze(new z2021(         Number.NaN,          Number.NaN)); }    function h2849(str) {     if (str.indexOf(',') < 0)     {         c953('number value \'' + str + '\' missing \',\'');         console.trace();     }           const parts = str.split(',');      const num = new z2021(         p1472(parts[0]),         p1472(parts[1]));      return [num, 1]; }    function s3835(str) {     const num =          str == e964         ? z2021.NaN.copy()         : z2021.fromString(str);      return [num, 1]; }


class b2032 extends d2049 {     value;     g3788;        constructor(val = '')     {         super(i1143);           if (   val !== null             && typeof val !== 'string')         {             console.trace();             c953('TextValue('+val+') is ' + typeof val + ', must be a string');         }                   this.value        = val;         this.g3788    = val;               }        copy()     {         const copy = new b2032(this.value);          copy.g3788 = this.g3788;                  copy.o3358(this);          return copy;     }        equals(text)     {         return text             && this.value == text.value;     }        async eval(parse)     {         return this.copy();     }        t3711()     {         this.value == this.g3788;     }        isValid()     {         return this.value !== null;     }        n2118()     {         return encodeURIComponent(this.value);     }        toString()     {         return this.value;     }        d3704()     {         const lines = this.value.split('\n');          let str = '';          for (let i = 0; i < Math.min(lines.length, 10); i++)         {             if (i > 0)                 str += '\n';              str += lines[i];         }          if (lines.length > 10)             str += '\n. . .';                  return str;     }        k3705()     {         return '\''               + this.value.replaceAll('\n', '↵')              + '\'';     }        p3357()     {         return b2032.NaN.copy();     }        static NaN = Object.freeze(new b2032()); }    function k2864(str) {     const text = new b2032(decodeURIComponent(str));      return [text, 1]; }


class a2009 extends d2049 {     space;     c1;     c2;     c3;        constructor(space = z2021.NaN,                  c1    = z2021.NaN,                  c2    = z2021.NaN,                  c3    = z2021.NaN)     {         super(a1168);          this.space  = space.copy();         this.c1     = c1   .copy();         this.c2     = c2   .copy();         this.c3     = c3   .copy();          this.valid  = true;     }        static create(space, c1, c2, c3)     {         c952(typeof space == 'number', 'ColorValue.create() space must be a number');         c952(typeof c1    == 'number', 'ColorValue.create() c1 must be a number');         c952(typeof c2    == 'number', 'ColorValue.create() c2 must be a number');         c952(typeof c3    == 'number', 'ColorValue.create() c3 must be a number');          return new a2009(             new z2021(space, 0),             new z2021(c1,    0),             new z2021(c2,    0),             new z2021(c3,    0));     }        static g3772(rgb)     {         return a2009.create(1, rgb[0], rgb[1], rgb[2]);     }        static p2805(c3198, spaceIndex = -1)     {         if (spaceIndex < 0)             spaceIndex = i4124 (c3198[0]);          const space  = l133(spaceIndex);         const factor = r4191(space);          return a2009.create(             spaceIndex,             c3198[1] * factor[0],             c3198[2] * factor[1],             c3198[3] * factor[2]);     }        copy()     {         const copy = new a2009(             this.space.copy(),              this.c1   .copy(),              this.c2   .copy(),              this.c3   .copy());          copy.o3358(this);          return copy;     }        t3711()     {         return this.space.t3711()             && this.c1   .t3711()             && this.c2   .t3711()             && this.c3   .t3711();     }        isValid()     {         return this.space.isValid()             && this.c1   .isValid()             && this.c2   .isValid()             && this.c3   .isValid();     }        equals(col)     {         return col             && this.space.equals(col.space)             && this.c1   .equals(col.c1   )             && this.c2   .equals(col.c2   )             && this.c3   .equals(col.c3   );     }        async eval(parse)     {         return this.copy();     }        c3240()     {         if (!this.isValid())             return q3813;          const space = this.space.copy();          space.value = Math.round(Math.min(Math.max(0, space.value), t131.length-1));          return r147(             space,             this.c1,             this.c2,             this.c3);     }        c3241()     {         return f4194(this.c3240());     }        y99()     {         return s100(this.c3241());     }        toRgbObject(limit = false)     {         const rgb = f4194(this.c3240());          if (limit && g73(rgb))             return {r: 0.5, g: 0.5, b: 0.5};                  return limit             ? { r: Math.min(Math.max(0, rgb[0]), 1),                 g: Math.min(Math.max(0, rgb[1]), 1),                 b: Math.min(Math.max(0, rgb[2]), 1) }             : { r: rgb[0],                 g: rgb[1],                 b: rgb[2] };     }        toString()     {         return      this.space.toString()             + ' ' + this.c1   .toString()             + ' ' + this.c2   .toString()             + ' ' + this.c3   .toString();     }        d3704()     {         return      this.space.d3704()             + ' ' + this.c1   .d3704()             + ' ' + this.c2   .d3704()             + ' ' + this.c3   .d3704();     }        k3705()     {         return      this.space.k3705()             + ' ' + this.c1   .k3705()             + ' ' + this.c2   .k3705()             + ' ' + this.c3   .k3705();     }        d3704()     {         if (!this.isValid())             return w966;          const rgb = this.c3241();          return '#' + c151(rgb);     }        toRgbString()     {         if (!this.isValid())             return w966;          const rgb = this.c3241();          return      rgb[0].toString()             + ' ' + rgb[1].toString()             + ' ' + rgb[2].toString();     }        p3357()     {         return a2009.NaN.copy();     }        static NaN = Object.freeze(new a2009(         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN)); }    function r2865(str, i = -1) {     if (i < 0)     {         str = str.split(' ');         i   = 0;     }               const p3768 = i;      const space = h2849(str[i]); i += space[1];     const c1    = h2849(str[i]); i += c1   [1];     const c2    = h2849(str[i]); i += c2   [1];     const c3    = h2849(str[i]); i += c3   [1];       return [         new a2009(space[0], c1[0], c2[0], c3[0]),          i - p3768 ]; }


class e2012 extends d2049 {     color;     opacity;     blend;        constructor(color   = a2009.NaN,                  opacity = new z2021(100),                 blend   = new z2021(0))     {         super(a1178);          this.color   = color  .copy();         this.opacity = opacity.copy();         this.blend   = blend  .copy();          this.valid   = true;     }            static create(r, g, b, opacity, blend = 0)     {         c952(             typeof opacity == 'number',             'opacity must be a number');          return new e2012(             a2009.create(1, r, g, b),             new z2021(opacity),             new z2021(blend));     }        static g3772(rgb, opacity, blend = 0)     {         c952(             typeof opacity == 'number',             'opacity must be a number');          return new e2012(             a2009.g3772(rgb),             new z2021(opacity),             new z2021(blend));     }        copy()     {         const copy = new e2012(             this.color  .copy(),             this.opacity.copy(),             this.blend  .copy());          copy.o3358(this);          return copy;     }        equals(fill)     {         return this.color  .equals(fill.color  )             && this.opacity.equals(fill.opacity)             && this.blend  .equals(fill.blend  );     }        async eval(parse)     {         return this.copy();     }        y99()     {         return [             ...this.color.c3241(),             this.opacity.value / 100 ];     }                               toString()     {         const rgb = p4141(this.color.c3241());          return        new z2021(rgb[0]).toString()               + ' ' + new z2021(rgb[1]).toString()               + ' ' + new z2021(rgb[2]).toString()               + ' ' + this.opacity           .toString()               + ' ' + this.blend             .toString();     }        d3704()     {         const rgb = p4141(this.color.c3241());          return        new z2021(rgb[0]).d3704()               + ' ' + new z2021(rgb[1]).d3704()               + ' ' + new z2021(rgb[2]).d3704()               + ' ' + this.opacity           .d3704()               + ' ' + this.blend             .d3704();     }        k3705()     {         const rgb = p4141(this.color.c3241());          return        new z2021(rgb[0]).k3705()               + ' ' + new z2021(rgb[1]).k3705()               + ' ' + new z2021(rgb[2]).k3705()               + ' ' + this.opacity           .k3705()               + ' ' + this.blend             .k3705();     }        t3711()     {         return this.color  .t3711()             && this.opacity.t3711()             && this.blend  .t3711();     }        isValid()     {         return this.color  .isValid()             && this.opacity.isValid()             && this.blend  .isValid();     }        p3357()     {         return e2012.NaN.copy();     }        static NaN = Object.freeze(new e2012(         a2009 .NaN,         z2021.NaN,         z2021.NaN));        static default = Object.freeze(e2012.create(217, 217, 217, 100)); }    function g3676(str, i = -1) {     if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const p3768 = i;      const r  = h2849(str[i]); i += r [1];     const g  = h2849(str[i]); i += g [1];     const b  = h2849(str[i]); i += b [1];     const a  = h2849(str[i]); i += a [1];     const bl = h2849(str[i]); i += bl[1];      const color = new a2009(new z2021(1), r[0], g[0], b[0]);           return [         new e2012(color, a[0], bl[0]),         i - p3768 ]; }               


class a2008 extends d2049 {     fill;     position;        constructor(fill     = e2012.NaN,                  position = new z2021(1))     {         if (fill.type != a1178)             c953('fill.type is ' + fill.type + ', must be FILL_VALUE');           super(i1184);          this.fill     = fill    .copy();         this.position = position.copy();          this.valid    = true;     }            copy()     {         const copy = new a2008(             this.fill    .copy(),             this.position.copy());          copy.o3358(this);          return copy;     }        isValid()     {         return this.fill    .isValid()             && this.position.isValid();     }        equals(stop)     {         return stop             && this.fill    .equals(stop.fill    )             && this.position.equals(stop.position);     }        async eval(parse)     {         return this;     }        q3632()     {         return this.copy();     }        toString()     {         return      this.fill    .toString()             + ' ' + this.position.toString();     }        d3704()     {         return      this.fill    .d3704()             + ' ' + this.position.d3704();     }        k3705()     {         return      this.fill    .k3705()             + ' ' + this.position.k3705();     }        p3357()     {         return a2008.NaN.copy();     }        static NaN = Object.freeze(new a2008(         e2012  .NaN,         z2021.NaN)); }    function u2866(str, i = -1) {     if (   i <  0 && str    == e964         || i >= 0 && str[i] == e964)         return [a2008.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const p3768 = i;      const fill     = g3676  (str, i); i += fill    [1];     const position = h2849(str[i]); i += position[1];       return [         new a2008(fill[0], position[0]),         i - p3768 ]; }


class m2014 extends d2049 {     stops;     k3686;     position;     x;     y;     size;     angle;     aspect;     skew;     blend;      diagAspect;        constructor(stops      = new u2020(),                 k3686   = new z2021(0),                 position   = new z2021(0),                 x          = new z2021(0),                 y          = new z2021(0),                 size       = new z2021(0),                 angle      = new z2021(0),                 aspect     = new z2021(0),                 diagAspect = false,                 skew       = new z2021(0),                 blend      = new z2021(0))     {         super(q1187);          this.stops      = stops   .copy();         this.k3686   = k3686.copy();         this.position   = position.copy();         this.x          = x       .copy();         this.y          = y       .copy();         this.size       = size    .copy();         this.angle      = angle   .copy();         this.aspect     = aspect  .copy();         this.diagAspect = diagAspect;         this.skew       = skew    .copy();         this.blend      = blend   .copy();          this.valid      = true;     }            copy()     {         const copy = new m2014(             this.stops,             this.k3686,             this.position,             this.x,             this.y,             this.size,             this.angle,             this.aspect,             this.diagAspect,             this.skew,             this.blend);          copy.o3358(this);          return copy;     }        isValid()     {         return this.stops   .isValid()             && this.k3686.isValid()             && this.position.isValid()             && this.x       .isValid()             && this.y       .isValid()             && this.size    .isValid()             && this.angle   .isValid()             && this.aspect  .isValid()             && this.skew    .isValid()             && this.blend   .isValid();     }        equals(grad)     {         return grad             && this.stops   .equals(grad.stops   )             && this.k3686.equals(grad.k3686)             && this.position.equals(grad.position)             && this.x       .equals(grad.x       )             && this.y       .equals(grad.y       )             && this.size    .equals(grad.size    )             && this.angle   .equals(grad.angle   )             && this.aspect  .equals(grad.aspect  )             && this.diagAspect == grad.diagAspect             && this.skew    .equals(grad.skew    )             && this.blend   .equals(grad.blend   );     }        async eval(parse)     {         return this;     }        q3632()     {         return this.copy();     }        toString()     {         return      this.stops   .toString()             + ' ' + this.k3686.toString()             + ' ' + this.position.toString()             + ' ' + this.x       .toString()             + ' ' + this.y       .toString()             + ' ' + this.size    .toString()             + ' ' + this.angle   .toString()             + ' ' + this.aspect  .toString()             + ' ' + (this.diagAspect ? '1' : '0')             + ' ' + this.skew    .toString()             + ' ' + this.blend   .toString();     }        y99()     {         return this.stops.length > 0              ? this.stops[0].fill.y99()              : rgba_NaN;     }            d3704()     {         return      this.stops   .d3704()             + ' ' + this.k3686.d3704()             + ' ' + this.position.d3704()             + ' ' + this.x       .d3704()             + ' ' + this.y       .d3704()             + ' ' + this.size    .d3704()             + ' ' + this.angle   .d3704()             + ' ' + this.aspect  .d3704()             + ' ' + (this.diagAspect ? '1' : '0')             + ' ' + this.skew    .d3704()             + ' ' + this.blend   .d3704();     }        k3705()     {         return      this.stops   .k3705()             + ' ' + this.k3686.k3705()             + ' ' + this.position.k3705()             + ' ' + this.x       .k3705()             + ' ' + this.y       .k3705()             + ' ' + this.size    .k3705()             + ' ' + this.angle   .k3705()             + ' ' + this.aspect  .k3705()             + ' ' + (this.diagAspect ? '1' : '0')             + ' ' + this.skew    .k3705()             + ' ' + this.blend   .k3705();     }        p3357()     {         return m2014.NaN.copy();     }        static NaN = Object.freeze(new m2014(         u2020  .NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN,         false,         z2021.NaN,         z2021.NaN)); }    function d3675(str, i = -1) {     if (   i <  0 && str    == e964         || i >= 0 && str[i] == e964)         return [m2014.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const p3768 = i;      const stops      = u3481  (str, i); i += stops   [1];     const k3686   = h2849(str[i]); i += k3686[1];     const position   = h2849(str[i]); i += position[1];     const x          = h2849(str[i]); i += x       [1];     const y          = h2849(str[i]); i += y       [1];     const size       = h2849(str[i]); i += size    [1];     const angle      = h2849(str[i]); i += angle   [1];     const aspect     = h2849(str[i]); i += aspect  [1];     const diagAspect = parseInt(str[i]) == 1;    i ++;     const skew       = h2849(str[i]); i += skew    [1];     const blend      = h2849(str[i]); i += blend   [1];       return [         new m2014(             stops   [0],              k3686[0],              position[0],             x       [0],              y       [0],              size    [0],              angle   [0],              aspect  [0],              diagAspect,             skew    [0],              blend   [0]),         i - p3768 ]; }


class o2030 extends d2049 {     fills;     weight;     fit;     join;     miter;     cap;     dashes;        constructor(fills  = new u2020(),                  weight = new z2021(1),                 fit    = new z2021(0),                 join   = new z2021(0),                 miter  = new z2021(28.96, 2),                 cap    = new z2021(0),                 dashes = new b2032())     {         if (fills.type != z1056)             c953('fill.type is ' + fills.type + ', must be LIST_VALUE');           super(i1181);          this.fills  = fills .copy();         this.weight = weight.copy();         this.fit    = fit   .copy();         this.join   = join  .copy();         this.miter  = miter .copy();         this.cap    = cap   .copy();         this.dashes = dashes.copy();          this.valid  = true;     }            copy()     {         const copy = new o2030(             this.fills .copy(),             this.weight.copy(),             this.fit   .copy(),             this.join  .copy(),             this.miter .copy(),             this.cap   .copy(),             this.dashes.copy());          copy.o3358(this);          return copy;     }        t3711()     {         return this.fills .t3711()             && this.weight.t3711()             && this.fit   .t3711()             && this.join  .t3711()             && this.miter .t3711()             && this.cap   .t3711()             && this.dashes.t3711();     }        isValid()     {         return this.fills .isValid()             && this.weight.isValid()             && this.fit   .isValid()             && this.join  .isValid()             && this.miter .isValid()             && this.cap   .isValid()             && this.dashes.isValid();     }        equals(stroke)     {         return stroke             && this.fills .equals(stroke.fill  )             && this.weight.equals(stroke.weight)             && this.fit   .equals(stroke.fit   )             && this.join  .equals(stroke.join  )             && this.miter .equals(stroke.miter )             && this.cap   .equals(stroke.cap   )             && this.dashes.equals(stroke.dashes);     }        async eval(parse)     {         return this.copy();     }        q3632()     {         return this.copy();     }        toString()     {         return      this.fills .toString()             + ' ' + this.weight.toString()             + ' ' + this.fit   .toString()             + ' ' + this.join  .toString()             + ' ' + this.miter .toString()             + ' ' + this.cap   .toString()             + ' ' + this.dashes.toString();     }        d3704()     {         return      this.fills .d3704()             + ' ' + this.weight.d3704()             + ' ' + this.fit   .d3704()             + ' ' + this.join  .d3704()             + ' ' + this.miter .d3704()             + ' ' + this.cap   .d3704()             + ' ' + this.dashes.d3704();     }        k3705()     {         return      this.fills .k3705()             + ' ' + this.weight.k3705()             + ' ' + this.fit   .k3705()             + ' ' + this.join  .k3705()             + ' ' + this.miter .k3705()             + ' ' + this.cap   .k3705()             + ' ' + this.dashes.k3705();     }        p3357()     {         return o2030.NaN.copy();     }        static NaN = Object.freeze(new o2030(         new u2020(),         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN,         new b2032()));        static default = Object.freeze(new o2030(         new u2020(),         new z2021(1),         new z2021(0),         new z2021(0),         new z2021(28.96),         new z2021(0),         new b2032())); }    function d3831(str, i = -1) {     if (   i <  0 && str    == e964         || i >= 0 && str[i] == e964)         return [o2030.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const p3768 = i;      const fills  = u3481  (str, i); i += fills [1];     const weight = h2849(str[i]); i += weight[1];     const fit    = h2849(str[i]); i += fit   [1];     const join   = h2849(str[i]); i += join  [1];     const miter  = h2849(str[i]); i += miter [1];     const cap    = h2849(str[i]); i += cap   [1];     const dashes = k2864  (str[i]); i += dashes[1];      return [          new o2030(             fills [0],              weight[0],              fit   [0],              join  [0],              miter [0],              cap   [0],              dashes[0]),                  i - p3768 ]; } 


class n4271 extends d2049 {     top;     left;     right;     bottom;     visible;        constructor(top     = new z2021(0),                  left    = new z2021(0),                  right   = new z2021(0),                  bottom  = new z2021(0),                  visible = true)     {         super(g1190);          this.top     = top;         this.left    = left;         this.right   = right;         this.bottom  = bottom;         this.visible = visible;     }            copy()     {         const copy = new n4271(             this.top   .copy(),             this.left  .copy(),             this.right .copy(),             this.bottom.copy(),             this.visible);          copy.o3358(this);          return copy;     }        equals(sides)     {         return this.top   .equals(sides.tl)             && this.left  .equals(sides.tr)             && this.right .equals(sides.bl)             && this.bottom.equals(sides.br)             && this.visible === sides.visible;     }        async eval(parse)     {         return this;     }        toString()     {         return      this.top   .toString()             + ' ' + this.left  .toString()             + ' ' + this.right .toString()             + ' ' + this.bottom.toString();     }        d3704()     {         return      this.top   .d3704()             + ' ' + this.left  .d3704()             + ' ' + this.right .d3704()             + ' ' + this.bottom.d3704();     }        k3705()     {         return      this.top   .k3705()             + ' ' + this.left  .k3705()             + ' ' + this.right .k3705()             + ' ' + this.bottom.k3705();     }        isValid()     {         return this.top   .isValid()             && this.left  .isValid()             && this.right .isValid()             && this.bottom.isValid();     }        p3357()     {         return n4271.NaN.copy();     }        static NaN = Object.freeze(new n4271(         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN,         false)); }    function parseStrokeSidesValue(str, i = -1) {     if (   i <  0 && str    == e964         || i >= 0 && str[i] == e964)         return [n4271.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const p3768 = i;      const top    = h2849(str[i]); i += top   [1];     const left   = h2849(str[i]); i += left  [1];     const right  = h2849(str[i]); i += right [1];     const bottom = h2849(str[i]); i += bottom[1];       const sides = new n4271(         top   [0],         left  [0],         right [0],         bottom[0]);       return [sides, i - p3768]; } 


class q2025 extends d2049 {     tl;     tr;     bl;     br;     visible;        constructor(tl = new z2021(0),                  tr = new z2021(0),                  bl = new z2021(0),                  br = new z2021(0),                  visible = true)     {         super(j1193);          this.tl      = tl;         this.tr      = tr;         this.bl      = bl;         this.br      = br;         this.visible = visible;     }            copy()     {         const copy = new q2025(             this.tl.copy(),             this.tr.copy(),             this.bl.copy(),             this.br.copy(),             this.visible);          copy.o3358(this);          return copy;     }        equals(corners)     {         return this.tl.equals(corners.tl)             && this.tr.equals(corners.tr)             && this.bl.equals(corners.bl)             && this.br.equals(corners.br)             && this.visible === corners.visible;     }        async eval(parse)     {         return this;     }        toString()     {         return      this.tl.toString()             + ' ' + this.tr.toString()             + ' ' + this.bl.toString()             + ' ' + this.br.toString();     }        d3704()     {         return      this.tl.d3704()             + ' ' + this.tr.d3704()             + ' ' + this.bl.d3704()             + ' ' + this.br.d3704();     }        k3705()     {         return      this.tl.k3705()             + ' ' + this.tr.k3705()             + ' ' + this.bl.k3705()             + ' ' + this.br.k3705();     }        isValid()     {         return this.tl.isValid()             && this.tr.isValid()             && this.bl.isValid()             && this.br.isValid();     }        p3357()     {         return q2025.NaN.copy();     }        static NaN = Object.freeze(new q2025(         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN,         false)); }    function y3837(str, i = -1) {     if (   i <  0 && str    == e964         || i >= 0 && str[i] == e964)         return [q2025.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const p3768 = i;      const tl = h2849(str[i]); i += tl[1];     const tr = h2849(str[i]); i += tr[1];     const bl = h2849(str[i]); i += bl[1];     const br = h2849(str[i]); i += br[1];       const corners = new q2025(         tl[0],         tr[0],         bl[0],         br[0]);       return [corners, i - p3768]; } 


class s2010 extends d2049 {     x;     y;     blur;     spread;     fill;     blend;     behind;     visible;        constructor(x       = new z2021(0),                  y       = new z2021(0),                  blur    = new z2021(0),                  spread  = new z2021(0),                  fill    = e2012.NaN,                 blend   = new z2021(0),                 behind  = new z2021(0),                 visible = true)     {         super(d1196);          this.x       = x;         this.y       = y;         this.blur    = blur;         this.spread  = spread;         this.fill    = fill;         this.blend   = blend;         this.behind  = behind;         this.visible = visible;                  c952(fill.type == a1178, 'fill.type must be FILL_VALUE');     }                                             copy()     {         const copy = new s2010(             this.x     .copy(),             this.y     .copy(),             this.blur  .copy(),             this.spread.copy(),             this.fill  .copy(),             this.blend .copy(),             this.behind.copy(),             this.visible);          copy.o3358(this);          return copy;     }        equals(shadow)     {         return this.x     .equals(shadow.x     )             && this.y     .equals(shadow.y     )             && this.blur  .equals(shadow.blur  )             && this.spread.equals(shadow.spread)             && this.fill  .equals(shadow.fill  )             && this.blend .equals(shadow.blend )             && this.behind.equals(shadow.behind)             && this.visible === shadow.visible;     }        async eval(parse)     {         return this;     }        toString()     {         return      this.x     .toString()             + ' ' + this.y     .toString()             + ' ' + this.blur  .toString()             + ' ' + this.spread.toString()             + ' ' + this.fill  .toString()             + ' ' + this.blend .toString()             + ' ' + this.behind.toString();     }        d3704()     {         return      this.x     .d3704()             + ' ' + this.y     .d3704()             + ' ' + this.blur  .d3704()             + ' ' + this.spread.d3704()             + ' ' + this.fill  .d3704()             + ' ' + this.blend .d3704()             + ' ' + this.behind.d3704();     }        k3705()     {         return      this.x     .k3705()             + ' ' + this.y     .k3705()             + ' ' + this.blur  .k3705()             + ' ' + this.spread.k3705()             + ' ' + this.fill  .k3705()             + ' ' + this.blend .k3705()             + ' ' + this.behind.k3705();     }        isValid()     {         return this.x     .isValid()             && this.y     .isValid()             && this.blur  .isValid()             && this.spread.isValid()             && this.fill  .isValid()             && this.blend .isValid()             && this.behind.isValid();     }        p3357()     {         return s2010.NaN.copy();     }        static NaN = Object.freeze(new s2010(         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN,         e2012 .NaN,         z2021.NaN,         z2021.NaN,         false));        }    function y3832(str, i = -1) {     if (   i <  0 && str    == e964         || i >= 0 && str[i] == e964)         return [s2010.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const p3768 = i;      const x      = h2849(str[i]); i += x     [1];     const y      = h2849(str[i]); i += y     [1];     const blur   = h2849(str[i]); i += blur  [1];     const spread = h2849(str[i]); i += spread[1];     const fill   = g3676  (str, i); i += fill  [1];     const blend  = h2849(str[i]); i += blend [1];     const behind = h2849(str[i]); i += behind[1];       const shadow = new s2010(         x     [0],         y     [0],         blur  [0],         spread[0],         fill  [0],         blend [0],         behind[0]);       return [shadow, i - p3768]; } 


class x2015 extends d2049 {     x;     y;     blur;     spread;     fill;     blend;     visible;        constructor(x       = new z2021(0),                  y       = new z2021(0),                  blur    = new z2021(0),                  spread  = new z2021(0),                  fill    = e2012.NaN,                 blend   = new z2021(0),                 visible = true)     {         super(l1199);          this.x       = x;         this.y       = y;         this.blur    = blur;         this.spread  = spread;         this.fill    = fill;         this.blend   = blend;         this.visible = visible;     }                                             copy()     {         const copy = new x2015(             this.x     .copy(),             this.y     .copy(),             this.blur  .copy(),             this.spread.copy(),             this.fill  .copy(),             this.blend .copy(),             this.visible);          copy.o3358(this);          return copy;     }        equals(shadow)     {         return this.x     .equals(shadow.x     )             && this.y     .equals(shadow.y     )             && this.blur  .equals(shadow.blur  )             && this.spread.equals(shadow.spread)             && this.fill  .equals(shadow.fill  )             && this.blend .equals(shadow.blend )             && this.visible === shadow.visible;     }        async eval(parse)     {         return this;     }                                                                toString()     {         return      this.x     .toString()             + ' ' + this.y     .toString()             + ' ' + this.blur  .toString()             + ' ' + this.spread.toString()             + ' ' + this.fill  .toString()             + ' ' + this.blend .toString();     }        d3704()     {         return      this.x     .d3704()             + ' ' + this.y     .d3704()             + ' ' + this.blur  .d3704()             + ' ' + this.spread.d3704()             + ' ' + this.fill  .d3704()             + ' ' + this.blend .d3704();     }        k3705()     {         return      this.x     .k3705()             + ' ' + this.y     .k3705()             + ' ' + this.blur  .k3705()             + ' ' + this.spread.k3705()             + ' ' + this.fill  .k3705()             + ' ' + this.blend .k3705();     }        isValid()     {         return this.x     .isValid()             && this.y     .isValid()             && this.blur  .isValid()             && this.spread.isValid()             && this.fill  .isValid()             && this.blend .isValid();     }        p3357()     {         return x2015.NaN.copy();     }        static NaN = Object.freeze(new x2015(         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN,         e2012 .NaN,         z2021.NaN,         false));         }    function x3833(str, i = -1) {     if (   i <  0 && str    == e964         || i >= 0 && str[i] == e964)         return [x2015.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const p3768 = i;      const x      = h2849(str[i]); i += x     [1];     const y      = h2849(str[i]); i += y     [1];     const blur   = h2849(str[i]); i += blur  [1];     const spread = h2849(str[i]); i += spread[1];     const fill   = g3676  (str, i); i += fill  [1];     const blend  = h2849(str[i]); i += blend [1];       const shadow = new x2015(         x     [0],         y     [0],         blur  [0],         spread[0],         fill  [0],         blend [0]);       return [shadow, i - p3768]; } 


class z2017 extends d2049 {     radius;     visible;        constructor(radius  = new z2021(0),                  visible = true)     {         super(h1202);          this.radius  = radius;         this.visible = visible;     }                                             copy()     {         const copy = new z2017(             this.radius.copy(),             this.visible);          copy.o3358(this);          return copy;     }        equals(blur)     {         return this.radius.equals(blur.radius)             && this.visible === blur.visible;     }        async eval(parse)     {         return this;     }                                                                toString()     {         return this.radius.toString();     }        d3704()     {         return this.radius.d3704();     }        k3705()     {         return this.radius.k3705();     }        isValid()     {         return this.radius.isValid();     }        p3357()     {         return z2017.NaN.copy();     }        static NaN = Object.freeze(new z2017(         z2021.NaN,         false));         }    function c3834(str, i = -1) {     if (   i <  0 && str    == e964         || i >= 0 && str[i] == e964)         return [z2017.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const p3768 = i;      const radius = h2849(str[i]); i += radius[1];       const shadow = new z2017(         radius[0]);       return [shadow, i - p3768]; } 


class p2007 extends d2049 {     radius;     visible;        constructor(radius  = new z2021(0),                 visible = true)     {         super(k1205);          this.radius  = radius;         this.visible = visible;     }                                             copy()     {         const copy = new p2007(             this.radius.copy(),             this.visible);          copy.o3358(this);          return copy;     }        equals(blur)     {         return this.radius.equals(blur.radius)             && this.visible === blur.visible;     }        async eval(parse)     {         return this;     }                                                                toString()     {         return this.radius.toString();     }        d3704()     {         return this.radius.d3704();     }        k3705()     {         return this.radius.k3705();     }        isValid()     {         return this.radius.isValid();     }        p3357()     {         return p2007.NaN.copy();     }        static NaN = Object.freeze(new p2007(         z2021.NaN,         false));         }    function r3706(str, i = -1) {     if (   i <  0 && str    == e964         || i >= 0 && str[i] == e964)         return [p2007.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const p3768 = i;      const radius = h2849(str[i]); i += radius[1];       const shadow = new p2007(         radius[0]);       return [shadow, i - p3768]; } 


class f2016 extends d2049 {     opacity;     blend;        constructor(opacity, blend)     {         super(k1211);          this.opacity = opacity.copy();         this.blend   = blend  .copy();     }            copy()     {         const copy = new f2016(this.opacity, this.blend);          copy.o3358(this);          return copy;     }        equals(layer)     {         return this.opacity.equals(layer.opacity)             && this.blend  .equals(layer.blend  );     }        async eval(parse)     {         return this;     }        toString()     {         return      this.opacity.toString()             + ' ' + this.blend  .toString();     }        d3704()     {         return      this.opacity.d3704()             + ' ' + this.blend  .d3704();     }        k3705()     {         return      this.opacity.k3705()             + ' ' + this.blend  .k3705();     }        t3711()     {         return this.opacity.t3711()             && this.blend  .t3711();     }        isValid()     {         return this.opacity && this.opacity.isValid()             && this.blend   && this.blend  .isValid();     }        p3357()     {         return f2016.NaN.copy();     }        static NaN = Object.freeze(new f2016(z2021.NaN, z2021.NaN)); }    function f3707(str, i = -1) {     if (   i <  0 && str    == e964         || i >= 0 && str[i] == e964)         return [f2016.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const p3768 = i;      const opacity = h2849(str[i]); i += opacity[1];     const blend   = h2849(str[i]); i += blend  [1];       const layer = new f2016(         opacity[0],         blend  [0]);               return [layer, i - p3768]; } 


class c2018 extends d2049 {     visible;     maskType;        constructor(maskType, visible = true)     {         super(t1208);          this.visible  = visible;         this.maskType = maskType.copy();     }            copy()     {         const copy = new c2018(this.maskType, this.visible);          copy.o3358(this);          return copy;     }        equals(mask)     {         return this.visible === mask.visible             && this.maskType.equals(mask.maskType);     }        async eval(parse)     {         return this;     }        toString()     {         return 'mask';     }        d3704()     {         return 'mask';     }        k3705()     {         return 'mask';     }        isValid()     {         return this.maskType.isValid();     }        p3357()     {         return c2018.NaN.copy();     }        static NaN = Object.freeze(new c2018(z2021.NaN, false)); }    function h3708(str) {     const mask =          str == e964         ? c2018.NaN         : new c2018(new z2021(parseInt(str)), true);      return [mask, 1]; } 


   class b2028 extends d2049 {     nodeId;      props = null;        constructor(type, nodeId)     {         super(type);          this.nodeId = nodeId;           this.objects = [];     }        o3358(base)     {         super.o3358(base);                  this.nodeId = base.nodeId;          if (base.objects) this.objects = base.objects.map(o => o.copy());          if (base.props  ) this.props   = base.props.copy();     }        t3711()     {         return !this.props             ||  this.props.t3711();     }        isValid()     {         return !this.props             ||  this.props.isValid();     } }    function g3709(str, i, g111) {     const props = u3481(str, i); i += props[1];      g111.props = props[0];      return i; }


class k2024 extends b2028 {     x;     y;     width;     height;     round;        constructor(nodeId,                 x      = new z2021(0),                  y      = new z2021(0),                  width  = new z2021(0),                  height = new z2021(0),                  round  = new z2021(0))     {         super(m1218, nodeId);          this.x      = x;         this.y      = y;         this.width  = width;         this.height = height;         this.round  = round;     }        static fromObject(g111)     {         return new k2024(             g111.nodeId,             new z2021(g111.x     ),              new z2021(g111.y     ),              new z2021(g111.width ),              new z2021(g111.height),              new z2021(g111.round ));     }        copy()     {         const copy = new k2024(             this.nodeId,             this.x     .copy(),              this.y     .copy(),              this.width .copy(),              this.height.copy(),              this.round .copy());          copy.o3358(this);          return copy;     }        equals(rect)     {         return rect             && this.x     .equals(rect.x     )             && this.y     .equals(rect.y     )             && this.width .equals(rect.width )             && this.height.equals(rect.height)             && this.round .equals(rect.round );     }        async eval(parse)     {         return this.copy();     }        toString()     {         return      this.x     .toString()             + ' ' + this.y     .toString()             + ' ' + this.width .toString()             + ' ' + this.height.toString()             + ' ' + this.round .toString()             + ' ' + super.toString();     }        d3704()     {         return 'rectangle';                                                                      }        k3705()     {         return      this.x     .k3705()             + ' ' + this.y     .k3705()             + ' ' + this.width .k3705()             + ' ' + this.height.k3705()             + ' ' + this.round .k3705();     }        q3632()     {         return this.copy();     }        t3711()     {         return super.t3711()             && this.x     .t3711()             && this.y     .t3711()             && this.width .t3711()             && this.height.t3711()             && this.round .t3711();     }        isValid()     {         return super.isValid()             && this.x     .isValid()             && this.y     .isValid()             && this.width .isValid()             && this.height.isValid()             && this.round .isValid();     }            static NaN = new k2024(         '',         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN); }    function a3710(str, i = -1) {     if (   i <  0 && str    == e964         || i >= 0 && str[i] == e964)         return [k2024.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const p3768 = i;      const x      = h2849(str[i]); i += x     [1];     const y      = h2849(str[i]); i += y     [1];     const width  = h2849(str[i]); i += width [1];     const height = h2849(str[i]); i += height[1];     const round  = h2849(str[i]); i += round [1];       const rect = new k2024(         '',          x     [0],         y     [0],         width [0],         height[0],         round [0]);       i = g3709(str, i, rect);           return [rect, i - p3768]; } 


class l2019 extends b2028 {     x;     y;     width;        constructor(nodeId,                 x      = new z2021(0),                  y      = new z2021(0),                  width  = new z2021(0))     {         super(p1221, nodeId);          this.x     = x;         this.y     = y;         this.width = width;     }        static fromObject(g111)     {         return new l2019(             g111.nodeId,             new z2021(g111.x    ),              new z2021(g111.y    ),              new z2021(g111.width));     }        copy()     {         const copy = new l2019(             this.nodeId,             this.x    .copy(),              this.y    .copy(),              this.width.copy());          copy.o3358(this);          return copy;     }        equals(line)     {         return line             && this.x    .equals(line.x    )             && this.y    .equals(line.y    )             && this.width.equals(line.width);     }        async eval(parse)     {         return this.copy();     }        t3711()     {         return super.t3711()             && this.x     .t3711()             && this.y     .t3711()             && this.width .t3711();     }        isValid()     {         return super.isValid()             && this.x    .isValid()             && this.y    .isValid()             && this.width.isValid();     }        q3632()     {         return this.copy();     }        toString()     {         return      this.x    .toString()             + ' ' + this.y    .toString()             + ' ' + this.width.toString()             + ' ' + super.toString();     }        d3704()     {         return      this.x    .d3704()             + ' ' + this.y    .d3704()             + ' ' + this.width.d3704();     }        k3705()     {         return      this.x    .k3705()             + ' ' + this.y    .k3705()             + ' ' + this.width.k3705();     }        static NaN = new l2019(         '',         z2021.NaN,         z2021.NaN,         z2021.NaN); }    function u3821(str, i = -1) {     if (   i <  0 && str    == e964         || i >= 0 && str[i] == e964)         return [l2019.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const p3768 = i;      const x     = h2849(str[i]); i += x    [1];     const y     = h2849(str[i]); i += y    [1];     const width = h2849(str[i]); i += width[1];       const line = new l2019(         '',          x    [0],         y    [0],         width[0]);       i = g3709(str, i, line);           return [line, i - p3768]; } 


class g2011 extends b2028 {     position;     x;     y;     width;     height;     round;     start;     sweep;     inner;        constructor(nodeId,                 position = new z2021(0),                 x        = new z2021(0),                  y        = new z2021(0),                  width    = new z2021(0),                  height   = new z2021(0),                  round    = new z2021(0),                  start    = new z2021(0),                 sweep    = new z2021(0),                 inner    = new z2021(0))     {         super(a1224, nodeId);          this.position = position;         this.x        = x;         this.y        = y;         this.width    = width;         this.height   = height;         this.round    = round;         this.start    = start;         this.sweep    = sweep;         this.inner    = inner;     }        static fromObject(g111)     {         return new g2011(             g111.nodeId,             new z2021(g111.position),              new z2021(g111.x       ),              new z2021(g111.y       ),              new z2021(g111.width   ),              new z2021(g111.height  ),              new z2021(g111.round   ),             new z2021(g111.start   ),             new z2021(g111.sweep   ),             new z2021(g111.inner   ));     }        copy()     {         const copy = new g2011(             this.nodeId,             this.position.copy(),              this.x       .copy(),              this.y       .copy(),              this.width   .copy(),              this.height  .copy(),              this.round   .copy(),              this.start   .copy(),             this.sweep   .copy(),             this.inner   .copy());          copy.o3358(this);          return copy;     }        equals(ellipse)     {         return ellipse             && this.position.equals(ellipse.position)             && this.x       .equals(ellipse.x       )             && this.y       .equals(ellipse.y       )             && this.width   .equals(ellipse.width   )             && this.height  .equals(ellipse.height  )             && this.round   .equals(ellipse.round   )             && this.start   .equals(ellipse.start   )             && this.sweep   .equals(ellipse.sweep   )             && this.inner   .equals(ellipse.inner   );     }        async eval(parse)     {         return this.copy();     }                    t3711()     {         return super.t3711()             && this.position.t3711()             && this.x       .t3711()             && this.y       .t3711()             && this.width   .t3711()             && this.height  .t3711()             && this.round   .t3711()             && this.start   .t3711()             && this.sweep   .t3711()             && this.inner   .t3711();     }        isValid()     {         return super.isValid()             && this.position.isValid()             && this.x       .isValid()             && this.y       .isValid()             && this.width   .isValid()             && this.height  .isValid()             && this.round   .isValid()             && this.start   .isValid()             && this.sweep   .isValid()             && this.inner   .isValid();     }        q3632()     {         return this.copy();     }        toString()     {         return      this.position.toString()             + ' ' + this.x       .toString()             + ' ' + this.y       .toString()             + ' ' + this.width   .toString()             + ' ' + this.height  .toString()             + ' ' + this.round   .toString()             + ' ' + this.start   .toString()             + ' ' + this.sweep   .toString()             + ' ' + this.inner   .toString()             + ' ' + super.toString();     }        d3704()     {         return 'ellipse';                                                                                                                          }        k3705()     {         return      this.position.k3705()             + ' ' + this.x       .k3705()             + ' ' + this.y       .k3705()             + ' ' + this.width   .k3705()             + ' ' + this.height  .k3705()             + ' ' + this.round   .k3705()             + ' ' + this.start   .k3705()             + ' ' + this.sweep   .k3705()             + ' ' + this.inner   .k3705();     }        static NaN = new g2011(         '',         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN); }    function s3822(str, i = -1) {     if (   i <  0 && str    == e964         || i >= 0 && str[i] == e964)         return [g2011.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const p3768 = i;      const pos    = h2849(str[i]); i += pos   [1];     const x      = h2849(str[i]); i += x     [1];     const y      = h2849(str[i]); i += y     [1];     const width  = h2849(str[i]); i += width [1];     const height = h2849(str[i]); i += height[1];     const round  = h2849(str[i]); i += round [1];     const start  = h2849(str[i]); i += start [1];     const sweep  = h2849(str[i]); i += sweep [1];     const inner  = h2849(str[i]); i += inner [1];       const ellipse = new g2011(         '',          pos   [0],         x     [0],         y     [0],         width [0],         height[0],         round [0],         start [0],         sweep [0],         inner [0]);       i = g3709(str, i, ellipse);           return [ellipse, i - p3768]; } 


class s2033 extends b2028 {     x;     y;     width;     height;     round;     bias;        constructor(nodeId,                 x      = new z2021(0),                  y      = new z2021(0),                  width  = new z2021(0),                  height = new z2021(0),                  round  = new z2021(0),                 bias   = new z2021(0))     {         super(d1227, nodeId);          this.x      = x;         this.y      = y;         this.width  = width;         this.height = height;         this.round  = round;         this.bias   = bias;     }        static fromObject(g111)     {         return new s2033(             g111.nodeId,             new z2021(g111.x     ),              new z2021(g111.y     ),              new z2021(g111.width ),              new z2021(g111.height),              new z2021(g111.round ),             new z2021(g111.bias  ));     }        copy()     {         const copy = new s2033(             this.nodeId,             this.x     .copy(),              this.y     .copy(),              this.width .copy(),              this.height.copy(),              this.round .copy(),             this.bias  .copy());          copy.o3358(this);          return copy;     }        equals(rect)     {         return rect             && this.x     .equals(rect.x     )             && this.y     .equals(rect.y     )             && this.width .equals(rect.width )             && this.height.equals(rect.height)             && this.round .equals(rect.round )             && this.bias  .equals(rect.bias  );     }        async eval(parse)     {         return this.copy();     }        toString()     {         return      this.x     .toString()             + ' ' + this.y     .toString()             + ' ' + this.width .toString()             + ' ' + this.height.toString()             + ' ' + this.round .toString()             + ' ' + this.bias  .toString()             + ' ' + super.toString();     }        d3704()     {         return 'trapeze';                                                                                   }        k3705()     {         return      this.x     .k3705()             + ' ' + this.y     .k3705()             + ' ' + this.width .k3705()             + ' ' + this.height.k3705()             + ' ' + this.round .k3705()             + ' ' + this.bias  .k3705();     }        q3632()     {         return this.copy();     }        t3711()     {         return super.t3711()             && this.x     .t3711()             && this.y     .t3711()             && this.width .t3711()             && this.height.t3711()             && this.round .t3711()             && this.bias  .t3711();     }            isValid()     {         return super.isValid()             && this.x     .isValid()             && this.y     .isValid()             && this.width .isValid()             && this.height.isValid()             && this.round .isValid()             && this.bias  .isValid();     }            static NaN = new s2033(         '',         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN); }    function a3823(str, i = -1) {     if (   i <  0 && str    == e964         || i >= 0 && str[i] == e964)         return [s2033.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const p3768 = i;      const x      = h2849(str[i]); i += x     [1];     const y      = h2849(str[i]); i += y     [1];     const width  = h2849(str[i]); i += width [1];     const height = h2849(str[i]); i += height[1];     const round  = h2849(str[i]); i += round [1];     const bias   = h2849(str[i]); i += bias  [1];       const rect = new s2033(         '',          x     [0],         y     [0],         width [0],         height[0],         round [0],         bias  [0]);       i = g3709(str, i, rect);           return [rect, i - p3768]; } 


class u2023 extends b2028 {     position;     x;     y;     width;     height;     round;     corners;        constructor(nodeId,                 position = new z2021(0),                 x        = new z2021(0),                  y        = new z2021(0),                  width    = new z2021(0),                  height   = new z2021(0),                  round    = new z2021(0),                  corners  = new z2021(0))     {         super(b1236, nodeId);          this.position = position;         this.x        = x;         this.y        = y;         this.width    = width;         this.height   = height;         this.round    = round;         this.corners  = corners;     }        static fromObject(g111)     {         return new u2023(             g111.nodeId,             new z2021(g111.position),              new z2021(g111.x       ),              new z2021(g111.y       ),              new z2021(g111.width   ),              new z2021(g111.height  ),              new z2021(g111.round   ),             new z2021(g111.corners ));     }        copy()     {         const copy = new u2023(             this.nodeId,             this.position.copy(),              this.x       .copy(),              this.y       .copy(),              this.width   .copy(),              this.height  .copy(),              this.round   .copy(),              this.corners .copy());              copy.o3358(this);          return copy;     }        equals(poly)     {         return poly             && this.position.equals(poly.position)             && this.x       .equals(poly.x       )             && this.y       .equals(poly.y       )             && this.width   .equals(poly.width   )             && this.height  .equals(poly.height  )             && this.round   .equals(poly.round   )             && this.corners .equals(poly.corners );     }        async eval(parse)     {         return this.copy();     }        t3711()     {         return super.t3711()             && this.position.t3711()             && this.x       .t3711()             && this.y       .t3711()             && this.width   .t3711()             && this.height  .t3711()             && this.round   .t3711()             && this.corners .t3711();     }        isValid()     {         return super.isValid()             && this.position.isValid()             && this.x       .isValid()             && this.y       .isValid()             && this.width   .isValid()             && this.height  .isValid()             && this.round   .isValid()             && this.corners .isValid();     }        q3632()     {         return this.copy();     }        toString()     {         return      this.position.toString()             + ' ' + this.x       .toString()             + ' ' + this.y       .toString()             + ' ' + this.width   .toString()             + ' ' + this.height  .toString()             + ' ' + this.round   .toString()             + ' ' + this.corners .toString()             + ' ' + super.toString();     }        d3704()     {         return      this.position.d3704()             + ' ' + this.x       .d3704()             + ' ' + this.y       .d3704()             + ' ' + this.width   .d3704()             + ' ' + this.height  .d3704()             + ' ' + this.round   .d3704()             + ' ' + this.corners .d3704();     }        k3705()     {         return      this.position.k3705()             + ' ' + this.x       .k3705()             + ' ' + this.y       .k3705()             + ' ' + this.width   .k3705()             + ' ' + this.height  .k3705()             + ' ' + this.round   .k3705()             + ' ' + this.corners .k3705();     }        static NaN = new u2023(         '',         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN); }    function f3824(str, i = -1) {     if (   i <  0 && str    == e964         || i >= 0 && str[i] == e964)         return [u2023.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const p3768 = i;      const pos     = h2849(str[i]); i += pos    [1];     const x       = h2849(str[i]); i += x      [1];     const y       = h2849(str[i]); i += y      [1];     const width   = h2849(str[i]); i += width  [1];     const height  = h2849(str[i]); i += height [1];     const round   = h2849(str[i]); i += round  [1];     const corners = h2849(str[i]); i += corners[1];       const poly = new u2023(         '',          pos    [0],         x      [0],         y      [0],         width  [0],         height [0],         round  [0],         corners[0]);       i = g3709(str, i, poly);           return [poly, i - p3768]; } 


class q2029 extends b2028 {     position;     x;     y;     width;     height;     round;     points;     convex;        constructor(nodeId,                 position = new z2021(0),                  x        = new z2021(0),                  y        = new z2021(0),                  width    = new z2021(0),                  height   = new z2021(0),                  round    = new z2021(0),                  points   = new z2021(0),                 convex   = new z2021(0))     {         super(y1239, nodeId);          this.position = position;         this.x        = x;         this.y        = y;         this.width    = width;         this.height   = height;         this.round    = round;         this.points   = points;         this.convex   = convex;     }        static fromObject(g111)     {         return new q2029(             g111.nodeId,             new z2021(g111.position),              new z2021(g111.x       ),              new z2021(g111.y       ),              new z2021(g111.width   ),              new z2021(g111.height  ),              new z2021(g111.round   ),             new z2021(g111.points  ),             new z2021(g111.convex  ));     }        copy()     {         const copy = new q2029(             this.nodeId,             this.position.copy(),              this.x       .copy(),              this.y       .copy(),              this.width   .copy(),              this.height  .copy(),              this.round   .copy(),              this.points  .copy(),             this.convex  .copy());          copy.o3358(this);          return copy;     }        equals(star)     {         return star             && this.position.equals(star.position)             && this.x       .equals(star.x       )             && this.y       .equals(star.y       )             && this.width   .equals(star.width   )             && this.height  .equals(star.height  )             && this.round   .equals(star.round   )             && this.points  .equals(star.points  )             && this.convex  .equals(star.convex  );     }        async eval(parse)     {         return this.copy();     }        t3711()     {         return super.t3711()             && this.position.t3711()             && this.x       .t3711()             && this.y       .t3711()             && this.width   .t3711()             && this.height  .t3711()             && this.round   .t3711()             && this.points  .t3711()             && this.convex  .t3711();     }            isValid()     {         return super.isValid()             && this.position.isValid()             && this.x       .isValid()             && this.y       .isValid()             && this.width   .isValid()             && this.height  .isValid()             && this.round   .isValid()             && this.points  .isValid()             && this.convex  .isValid();     }            q3632()     {         return this.copy();     }        toString()     {         return      this.position.toString()             + ' ' + this.x       .toString()             + ' ' + this.y       .toString()             + ' ' + this.width   .toString()             + ' ' + this.height  .toString()             + ' ' + this.round   .toString()             + ' ' + this.points  .toString()             + ' ' + this.convex  .toString()             + ' ' + super.toString();     }        d3704()     {         return      this.position.d3704()             + ' ' + this.x       .d3704()             + ' ' + this.y       .d3704()             + ' ' + this.width   .d3704()             + ' ' + this.height  .d3704()             + ' ' + this.round   .d3704()             + ' ' + this.points  .d3704()             + ' ' + this.convex  .d3704();     }        k3705()     {         return      this.position.k3705()             + ' ' + this.x       .k3705()             + ' ' + this.y       .k3705()             + ' ' + this.width   .k3705()             + ' ' + this.height  .k3705()             + ' ' + this.round   .k3705()             + ' ' + this.points  .k3705()             + ' ' + this.convex  .k3705();     }        static NaN = new q2029(         '',         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN); }    function f3825(str, i = -1) {     if (   i <  0 && str    == e964         || i >= 0 && str[i] == e964)         return [q2029.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const p3768 = i;      const pos    = h2849(str[i]); i += pos   [1];     const x      = h2849(str[i]); i += x     [1];     const y      = h2849(str[i]); i += y     [1];     const width  = h2849(str[i]); i += width [1];     const height = h2849(str[i]); i += height[1];     const round  = h2849(str[i]); i += round [1];     const points = h2849(str[i]); i += points[1];     const convex = h2849(str[i]); i += convex[1];       const star = new q2029(         '',          pos   [0],         x     [0],         y     [0],         width [0],         height[0],         round [0],         points[0],         convex[0]);       i = g3709(str, i, star);           return [star, i - p3768]; } 


class p2031 extends b2028 {     text;     x;     y;     width;     height;     font;     style;     size;     alignX;     alignY;     lineHeight;     letterSpacing;            constructor(nodeId,                 text          = new b2032(),                 x             = new z2021(0),                  y             = new z2021(0),                  width         = new z2021(0),                  height        = new z2021(0),                  font          = new z2021(0),                 style         = new z2021(0),                 size          = new z2021(0),                 alignX        = new z2021(0),                 alignY        = new z2021(0),                 lineHeight    = new z2021(0),                 letterSpacing = new z2021(0))     {         super(x1242, nodeId);          this.text          = text;         this.x             = x;         this.y             = y;         this.width         = width;         this.height        = height;         this.font          = font;         this.style         = style;         this.size          = size;         this.alignX        = alignX;         this.alignY        = alignY;         this.lineHeight    = lineHeight;         this.letterSpacing = letterSpacing;          this.objects       = [];     }        static fromObject(g111)     {         return new p2031(             g111.nodeId,             new z2021(g111.text         ),              new z2021(g111.x            ),              new z2021(g111.y            ),              new z2021(g111.width        ),              new z2021(g111.height       ),              new z2021(g111.font         ),             new z2021(g111.style        ),             new z2021(g111.size         ),             new z2021(g111.alignX       ),             new z2021(g111.alignY       ),             new z2021(g111.lineHeight   ),             new z2021(g111.letterSpacing));     }        copy()     {         const copy = new p2031(             this.nodeId,             this.text         .copy(),             this.x            .copy(),              this.y            .copy(),              this.width        .copy(),              this.height       .copy(),              this.font         .copy(),             this.style        .copy(),             this.size         .copy(),             this.alignX       .copy(),             this.alignY       .copy(),             this.lineHeight   .copy(),             this.letterSpacing.copy());           copy.o3358(this);          return copy;     }        equals(text)     {         return text             && this.text         .equals(text.text         )             && this.x            .equals(text.x            )             && this.y            .equals(text.y            )             && this.width        .equals(text.width        )             && this.height       .equals(text.height       )             && this.font         .equals(text.font         )             && this.style        .equals(text.style        )             && this.size         .equals(text.size         )             && this.alignX       .equals(text.alignX       )             && this.alignY       .equals(text.alignY       )             && this.lineHeight   .equals(text.lineHeight   )             && this.letterSpacing.equals(text.letterSpacing);     }        async eval(parse)     {         return this.copy();     }        t3711()     {         return super.t3711()             && this.text         .t3711()             && this.x            .t3711()             && this.y            .t3711()             && this.width        .t3711()             && this.height       .t3711()             && this.font         .t3711()             && this.style        .t3711()             && this.size         .t3711()             && this.alignX       .t3711()             && this.alignY       .t3711()             && this.lineHeight   .t3711()             && this.letterSpacing.t3711();     }            isValid()     {         return super.isValid()             && this.text         .isValid()             && this.x            .isValid()             && this.y            .isValid()             && this.width        .isValid()             && this.height       .isValid()             && this.font         .isValid()             && this.style        .isValid()             && this.size         .isValid()             && this.alignX       .isValid()             && this.alignY       .isValid()             && this.lineHeight   .isValid()             && this.letterSpacing.isValid();     }            q3632()     {         return this.copy();     }        toString()     {         return      this.text         .n2118()              + ' ' + this.x            .toString()             + ' ' + this.y            .toString()             + ' ' + this.width        .toString()             + ' ' + this.height       .toString()             + ' ' + this.font         .toString()             + ' ' + this.style        .toString()             + ' ' + this.size         .toString()             + ' ' + this.alignX       .toString()             + ' ' + this.alignY       .toString()             + ' ' + this.lineHeight   .toString()             + ' ' + this.letterSpacing.toString()             + ' ' + super.toString();         }        d3704()     {         return 'textShape';                                                                                                                                                                       }        k3705()     {         return      this.text         .k3705()             + ' ' + this.x            .k3705()             + ' ' + this.y            .k3705()             + ' ' + this.width        .k3705()             + ' ' + this.height       .k3705()             + ' ' + this.font         .k3705()             + ' ' + this.style        .k3705()             + ' ' + this.size         .k3705()             + ' ' + this.alignX       .k3705()             + ' ' + this.alignY       .k3705()             + ' ' + this.lineHeight   .k3705()             + ' ' + this.letterSpacing.k3705();     }        n2118()     {         return      this.text         .n2118()             + ' ' + this.x            .n2118()             + ' ' + this.y            .n2118()             + ' ' + this.width        .n2118()             + ' ' + this.height       .n2118()             + ' ' + this.font         .n2118()             + ' ' + this.style        .n2118()             + ' ' + this.size         .n2118()             + ' ' + this.alignX       .n2118()             + ' ' + this.alignY       .n2118()             + ' ' + this.lineHeight   .n2118()             + ' ' + this.letterSpacing.n2118();     }        static NaN = new p2031(         '',         b2032.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN); }    function q3826(str, i = -1) {     if (   i <  0 && str    == e964         || i >= 0 && str[i] == e964)         return [p2031.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const p3768 = i;      const text          = k2864  (str[i]); i += text         [1];     const x             = h2849(str[i]); i += x            [1];     const y             = h2849(str[i]); i += y            [1];     const width         = h2849(str[i]); i += width        [1];     const height        = h2849(str[i]); i += height       [1];     const font          = h2849(str[i]); i += font         [1];     const style         = h2849(str[i]); i += style        [1];     const size          = h2849(str[i]); i += size         [1];     const alignX        = h2849(str[i]); i += alignX       [1];     const alignY        = h2849(str[i]); i += alignY       [1];     const lineHeight    = h2849(str[i]); i += lineHeight   [1];     const letterSpacing = h2849(str[i]); i += letterSpacing[1];       const txts = new p2031(         '',          text         [0],         x            [0],         y            [0],         width        [0],         height       [0],         font         [0],         style        [0],         size         [0],         alignX       [0],         alignY       [0],         lineHeight   [0],         letterSpacing[0]);       i = g3709(str, i, txts);           return [txts, i - p3768]; } 


class t2022 extends d2049 {     nodeId;      x;     y;     smooth;       sp0 = null;      sp1 = null;      sp2 = null;         constructor(nodeId,                 x = new z2021(0),                  y = new z2021(0),                 smooth = null)     {         super(v1245);          this.nodeId  = nodeId;          this.x       = x;         this.y       = y;         this.smooth  = smooth;           this.f3741();     }        static fromObject(g111)     {         return new t2022(             g111.nodeId,             new z2021(g111.x     ),              new z2021(g111.y     ),              new z2021(g111.smooth));     }        copy()     {         const copy = new t2022(             this.nodeId,             this.x.copy(),              this.y.copy());          if (this.smooth) copy.smooth = this.smooth.copy();          copy.o3358(this);          copy.sp0 = clone(this.sp0);         copy.sp1 = clone(this.sp1);         copy.sp2 = clone(this.sp2);          return copy;     }        equals(p)     {         return p             && this.x.equals(p.x)             && this.y.equals(p.y);     }        f3741(cx = 0, cy = 0) {         this.sp0 = point(cx,   cy  );         this.sp1 = point(cx+1, cy  );         this.sp2 = point(cx,   cy+1);     }        applySpaceTransform(y4207, space)     {         this.sp0 = f3730(this.sp0, y4207, space);         this.sp1 = f3730(this.sp1, y4207, space);         this.sp2 = f3730(this.sp2, y4207, space);     }        static create(nodeId, x, y)     {         return new t2022(             nodeId,             new z2021(x),             new z2021(y));     }        static fromPoint(nodeId, p)     {         return new t2022(             nodeId,             new z2021(p.x),             new z2021(p.y));     }        async eval(parse)     {         return this.copy();     }        t3711()     {         return this.x.t3711()             && this.y.t3711()             && (  !this.smooth                 || this.smooth.t3711());     }        isValid()     {         return this.x.isValid()             && this.y.isValid()             && (  !this.smooth                 || this.smooth.isValid());     }        toString()     {         return this.x.isValid()             && this.y.isValid()             ?         this.x.toString()               + ' ' + this.y.toString()             : e964;     }        d3704()     {         return this.x.isValid()             && this.y.isValid()             ?   '(' + this.x.d3704()               + ', ' + this.y.d3704()               + ')'             : e964;     }        k3705()     {         return this.x.isValid()             && this.y.isValid()             ?         this.x.k3705()               + ' ' + this.y.k3705()             : e964;     }        q3632()     {         return this.copy();     }        y3746()     {         return point(             this.x.value,             this.y.value);     }        r2846(gen)     {         return '';     }        p3357()     {         return t2022.NaN.copy();     }        static NaN = Object.freeze(new t2022(         '',         z2021.NaN,          z2021.NaN)); }    function c3827(str, i = -1) {     if (   i <  0 && str    == e964         || i >= 0 && str[i] == e964)         return [t2022.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const p3768 = i;      const x = h2849(str[i]); i += x[1];     const y = h2849(str[i]); i += y[1];       const point = new t2022(         '',          x[0],         y[0]);       return [point, i - p3768]; } 


class y2036 extends b2028 {     points;     closed;     degree;     winding;     round;        constructor(nodeId,                 points  = new u2020(),                  closed  = new z2021(0),                  degree  = new z2021(0),                  winding = new z2021(0),                  round   = new z2021(0))     {         super(q1249, nodeId);          this.points  = points ?? new u2020();         this.closed  = closed;         this.degree  = degree;         this.winding = winding;         this.round   = round;     }        static fromObject(g111)     {         return new y2036(             g111.nodeId,             new u2020(g111.points.map(p => t2022.fromPoint(g111.nodeId, p))),              new z2021(g111.closed ),              new z2021(g111.degree ),              new z2021(g111.winding),              new z2021(g111.round  ));     }        copy()     {         const copy = new y2036(             this.nodeId,             this.points .copy(),              this.closed .copy(),              this.degree .copy(),              this.winding.copy(),              this.round  .copy());          copy.o3358(this);          return copy;     }        equals(rect)     {         return rect             && this.points .equals(rect.points )             && this.closed .equals(rect.closed )             && this.degree .equals(rect.degree )             && this.winding.equals(rect.winding)             && this.round  .equals(rect.round  );     }        async eval(parse)     {         return this.copy();     }        toString()     {         return      this.points .toString()             + ' ' + this.closed .toString()             + ' ' + this.degree .toString()             + ' ' + this.winding.toString()             + ' ' + this.round  .toString()             + ' ' + super.toString();     }        d3704()     {         return      this.points .d3704()             + ' ' + this.closed .d3704()             + ' ' + this.degree .d3704()             + ' ' + this.winding.d3704()             + ' ' + this.round  .d3704();     }        k3705()     {         return      this.points .k3705()             + ' ' + this.closed .k3705()             + ' ' + this.degree .k3705()             + ' ' + this.winding.k3705()             + ' ' + this.round  .k3705();     }        q3632()     {         return this.copy();     }        t3711()     {         return super.t3711()             && this.points .t3711()             && this.closed .t3711()             && this.degree .t3711()             && this.winding.t3711()             && this.round  .t3711();     }            isValid()     {         return super.isValid()             && this.points  && this.points .isValid()             && this.closed  && this.closed .isValid()             && this.degree  && this.degree .isValid()             && this.winding && this.winding.isValid()             && this.round   && this.round  .isValid();     }            static NaN = new y2036(         '',         u2020  .NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN); }    function d3669(str, i = -1) {     if (   i <  0 && str    == e964         || i >= 0 && str[i] == e964)         return [y2036.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const p3768 = i;      const points  = u3481  (str, i); i += points [1];     const closed  = h2849(str[i]); i += closed [1];     const degree  = h2849(str[i]); i += degree [1];     const winding = h2849(str[i]); i += winding[1];     const round   = h2849(str[i]); i += round  [1];      const path = new y2036(         '',          points [0],         closed [0],         degree [0],         winding[0],         round  [0]);       i = g3709(str, i, path);           return [path, i - p3768]; } 


class z2038 extends d2049 {     nodeId;      x;     y;     join;     cap;     round;        constructor(nodeId,                 x     = new z2021(0),                  y     = new z2021(0),                 join  = new z2021(0),                 cap   = new z2021(0),                 round = new z2021(0))     {         super(u1252);          this.nodeId = nodeId;          this.x      = x    .copy();         this.y      = y    .copy();         this.join   = join .copy();         this.cap    = cap  .copy();         this.round  = round.copy();     }        copy()     {         const copy = new z2038(             this.nodeId,             this.x    .copy(),              this.y    .copy(),              this.join .copy(),              this.cap  .copy(),              this.round.copy());          copy.o3358(this);          return copy;     }        equals(p)     {         return p             && this.x    .equals(p.x    )             && this.y    .equals(p.y    )             && this.join .equals(p.join )             && this.cap  .equals(p.cap  )             && this.round.equals(p.round);     }        static create(nodeId, x, y)     {         return new z2038(             nodeId,             new z2021(x    ),             new z2021(y    ),             new z2021(join ),             new z2021(cap  ),             new z2021(round));     }        static fromPoint(nodeId, p)     {         return new z2038(             nodeId,             new z2021(p.x),             new z2021(p.y),             new z2021(0),             new z2021(0),             new z2021(0));     }        async eval(parse)     {         return this;     }        t3711()     {         return this.x    .t3711()             && this.y    .t3711()             && this.join .t3711()             && this.cap  .t3711()             && this.round.t3711();     }        isValid()     {         return this.x    .isValid()             && this.y    .isValid()             && this.join .isValid()             && this.cap  .isValid()             && this.round.isValid();     }        toString()     {         return      this.x    .toString()             + ' ' + this.y    .toString()             + ' ' + this.join .toString()             + ' ' + this.cap  .toString()             + ' ' + this.round.toString();     }        d3704()     {         return      this.x    .d3704()             + ' ' + this.y    .d3704()             + ' ' + this.join .d3704()             + ' ' + this.cap  .d3704()             + ' ' + this.round.d3704();     }        k3705()     {         return      this.x    .k3705()             + ' ' + this.y    .k3705()             + ' ' + this.join .k3705()             + ' ' + this.cap  .k3705()             + ' ' + this.round.k3705();     }        q3632()     {         return this.copy();     }        y3746()     {         return point(             this.x.value,             this.y.value);     }        r2846(gen)     {         return '';     }        p3357()     {         return z2038.NaN.copy();     }        static NaN = Object.freeze(new z2038(         '',         z2021.NaN,          z2021.NaN,          z2021.NaN,          z2021.NaN,          z2021.NaN)); }    function e3668(str, i = -1) {     if (   i <  0 && str    == e964         || i >= 0 && str[i] == e964)         return [z2038.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const p3768 = i;      const x     = h2849(str[i]); i += x    [1];     const y     = h2849(str[i]); i += y    [1];     const join  = h2849(str[i]); i += join [1];     const cap   = h2849(str[i]); i += cap  [1];     const round = h2849(str[i]); i += round[1];       const point = new z2038(         '',          x    [0],         y    [0],         join [0],         cap  [0],         round[0]);       return [point, i - p3768]; } 


class t2034 extends d2049 {     nodeId;      start;     end;     l3664;     f3665;        constructor(nodeId,                 start,                  end,                 l3664 = t2022.create(nodeId, 0, 0),                 f3665   = t2022.create(nodeId, 0, 0))     {         super(i1255);          this.nodeId = nodeId;          this.start        = start       .copy();                this.end          = end         .copy();                  this.l3664 = l3664.copy();         this.f3665   = f3665  .copy();       }        copy()     {         const copy = new t2034(             this.nodeId,             this.start       .copy(),              this.end         .copy(),              this.l3664.copy(),              this.f3665  .copy());          copy.o3358(this);          return copy;     }        equals(edge)     {         return edge             && this.start       .equals(edge.start       )             && this.end         .equals(edge.end         )             && this.l3664.equals(edge.l3664)             && this.  f3665.equals(edge.  f3665);     }        static create(nodeId, start, end, l3664, f3665)     {         return new t2034(             nodeId,             start,             end,             t2022.create(nodeId, l3664.x, l3664.y),             t2022.create(nodeId,   f3665.x,   f3665.y));     }        async eval(parse)     {         return this;     }        t3711()     {         return this.start       .t3711()             && this.end         .t3711()             && this.l3664.t3711()             && this.f3665  .t3711();     }        isValid()     {         return this.start       .isValid()             && this.end         .isValid()             && this.l3664.isValid()             && this.f3665  .isValid();     }        toString()     {         return      this.start       .toString()             + ' ' + this.end         .toString()             + ' ' + this.l3664.toString()             + ' ' + this.f3665  .toString();     }        d3704()     {         return      this.start       .toString()             + ' ' + this.end         .toString()             + ' ' + this.l3664.toString()             + ' ' + this.f3665  .toString();     }        k3705()     {         return      this.start       .k3705()             + ' ' + this.end         .k3705()             + ' ' + this.l3664.k3705()             + ' ' + this.f3665  .k3705();     }        q3632()     {         return this.copy();     }        r2846(gen)     {         return '';     }        p3357()     {         return t2034.NaN.copy();     }        static NaN = Object.freeze(new t2034(         '',         z2038.NaN,          z2038.NaN,          t2022.NaN,          t2022.NaN)); }    function s3666(str, i = -1) {     if (   i <  0 && str    == e964         || i >= 0 && str[i] == e964)         return [t2034.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const p3768 = i;      const start        = e3668(str, i); i += start       [1];     const end          = e3668(str, i); i += end         [1];     const l3664 = c3827       (str, i); i += l3664[1];     const f3665   = c3827       (str, i); i +=   f3665[1];       const edge = new t2034(         '',          start       [0],         end         [0],         l3664[0],           f3665[0]);       return [edge, i - p3768]; } 


class v2037 extends b2028 {     loops;       winding;      fills = [];        constructor(nodeId,                 loops   = new u2020(),                  winding = new z2021(0))     {         super(o1258, nodeId);          this.loops   = loops;           this.winding = winding;     }        static fromObject(g111)     {         return new v2037(             g111.nodeId,             new u2020(),               new u2020());      }        copy()     {         const copy = new v2037(             this.nodeId,             this.loops  .copy(),              this.winding.copy());          copy.fills = clone(this.fills);                  copy.o3358(this);          return copy;     }        equals(region)     {         return region             && this.loops  .equals(region.loops  )             && this.winding.equals(region.winding);     }                                              async eval(parse)     {         return this;     }        t3711()     {         return this.loops  .t3711()             && this.winding.t3711();     }        isValid()     {         return this.loops  .isValid()             && this.winding.isValid();     }        toString()     {         return      this.loops  .toString()             + ' ' + this.winding.toString();     }        d3704()     {         return      this.loops  .d3704()             + ' ' + this.winding.d3704();     }        k3705()     {         return      this.loops  .k3705()             + ' ' + this.winding.k3705();     }        q3632()     {         return this.copy();     }        r2846(gen)     {         return '';     }        p3357()     {         return t2034.NaN.copy();     }        static NaN = Object.freeze(new v2037(         '',         u2020  .NaN,          z2021.NaN)); }    function n3663(str, i = -1) {     if (   i <  0 && str    == e964         || i >= 0 && str[i] == e964)         return [v2037.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const p3768 = i;      const loops   = u3481  (str, i); i += loops  [1];     const winding = h2849(str[i]); i += winding[1];       const region = new v2037(         '',          loops  [0],         winding[0]);       i = g3709(str, i, region);       return [region, i - p3768]; } 


class q2035 extends d2049 {     nodeId;      regions;        constructor(nodeId,                 regions = new u2020())     {         super(z1261);          this.nodeId  = nodeId;          this.regions = regions;      }        static fromObject(g111)     {         return new q2035(             g111.nodeId,             new u2020(g111.regions.map(r => v2037.fromObject(g111.nodeId, r))));     }        copy()     {         const copy = new q2035(             this.nodeId,             this.regions.copy());          copy.o3358(this);          return copy;     }        equals(other)     {         return other             && this.regions.equals(other.regions);     }        static create(nodeId, regions)     {         return new q2035(             nodeId,             regions);     }        async eval(parse)     {         return this;     }        t3711()     {         return this.regions.t3711();     }        isValid()     {         return this.regions.isValid();     }        toString()     {         return this.regions.toString();     }        d3704()     {         return this.regions.d3704();     }        k3705()     {         return this.regions.k3705();     }        q3632()     {         return this.copy();     }        r2846(gen)     {         return '';     }        p3357()     {         return q2035.NaN.copy();     }        static NaN = Object.freeze(new q2035(         '',         u2020.NaN)); }    function r3662(str, i = -1) {     if (   i <  0 && str    == e964         || i >= 0 && str[i] == e964)         return [q2035.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const p3768 = i;      const regions = u3481(str, i); i += regions[1];       const net = new q2035(         '',          regions[0]);       return [net, i - p3768]; } 


class s2026 extends b2028 {     operation;     children;        constructor(nodeId, children, operation)     {         super(i1287, nodeId);          this.children  = children;         this.operation = operation;          this.objects =              children.objects             ? children.objects.map(o => o.copy())             : null;     }        copy()     {         const copy = new s2026(             this.nodeId,             this.children .copy(),             this.operation.copy());          copy.o3358(this);          return copy;     }        equals(bool)     {         return bool             && this.children .equals(bool.children )             && this.operation.equals(bool.operation);     }        async eval(parse)     {         return this;     }        toString()     {         return      this.children .toString()             + ' ' + this.operation.toString();     }        d3704()     {         return      this.children .d3704()             + ' ' + this.operation.d3704();     }        k3705()     {         return      this.children .k3705()             + ' ' + this.operation.k3705();     }        q3632()     {         return this.copy();     }        isValid()     {         return super.isValid()             && this.children .isValid()             && this.operation.isValid();     }            static NaN = new s2026(         '',         u2020  .NaN,         z2021.NaN); }    function k3828(str, i = -1) {     if (   i <  0 && str    == e964         || i >= 0 && str[i] == e964)         return [s2026.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const p3768 = i;      const children  = u3481  (str, i); i += children [1];     const operation = h2849(str[i]); i += operation[1];      const bool = new s2026(         '',          children [0],         operation[0]);       i = g3709(str, i, bool);           return [bool, i - p3768]; } 


class WavePathValue extends b2028 {     shape;     x;     y;     width;     amplitude;     frequency;     offset;     alignX;       alignY;        degree;        constructor(nodeId,                 shape     = new z2021(0),                 x         = new z2021(0),                  y         = new z2021(0),                  width     = new z2021(0),                  amplitude = new z2021(0),                 frequency = new z2021(0),                 offset    = new z2021(0),                 alignX    = new z2021(0),                 alignY    = new z2021(0))     {         super(c1234, nodeId);          this.shape     = shape;         this.x         = x;         this.y         = y;         this.width     = width;         this.amplitude = amplitude;         this.frequency = frequency;         this.offset    = offset;         this.alignX    = alignX;         this.alignY    = alignY;          this.degree   = new z2021(2);     }        copy()     {         const copy = new WavePathValue(             this.nodeId,             this.shape    .copy(),             this.x        .copy(),              this.y        .copy(),              this.width    .copy(),              this.amplitude.copy(),             this.frequency.copy(),             this.offset   .copy(),             this.alignX   .copy(),             this.alignY   .copy());          copy.o3358(this);          return copy;     }        equals(wave)     {         return wave             && this.shape    .equals(wave.shape    )             && this.x        .equals(wave.x        )             && this.y        .equals(wave.y        )             && this.width    .equals(wave.width    )             && this.amplitude.equals(wave.amplitude)             && this.frequency.equals(wave.frequency)             && this.offset   .equals(wave.offset   )             && this.alignX   .equals(wave.alignX   )             && this.alignY   .equals(wave.alignY   );     }        async eval(parse)     {         return this.copy();     }                    t3711()     {         return super.t3711()             && this.shape    .t3711()             && this.x        .t3711()             && this.y        .t3711()             && this.width    .t3711()             && this.amplitude.t3711()             && this.frequency.t3711()             && this.offset   .t3711()             && this.alignX   .t3711()             && this.alignY   .t3711();     }        isValid()     {         return super.isValid()             && this.shape    .isValid()             && this.x        .isValid()             && this.y        .isValid()             && this.width    .isValid()             && this.amplitude.isValid()             && this.frequency.isValid()             && this.offset   .isValid()             && this.alignX   .isValid()             && this.alignY   .isValid();     }        q3632()     {         return this.copy();     }        toString()     {         return      this.shape    .toString()             + ' ' + this.x        .toString()             + ' ' + this.y        .toString()             + ' ' + this.width    .toString()             + ' ' + this.amplitude.toString()             + ' ' + this.frequency.toString()             + ' ' + this.offset   .toString()             + ' ' + this.alignX   .toString()             + ' ' + this.alignY   .toString()             + ' ' + super.toString();     }        d3704()     {         return 'wave';                                                                                                                          }        k3705()     {         return      this.shape    .k3705()             + ' ' + this.x        .k3705()             + ' ' + this.y        .k3705()             + ' ' + this.width    .k3705()             + ' ' + this.amplitude.k3705()             + ' ' + this.frequency.k3705()             + ' ' + this.offset   .k3705()             + ' ' + this.alignX   .k3705()             + ' ' + this.alignY   .k3705();     }        static NaN = new WavePathValue(         '',         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN); }    function parseWavePathValue(str, i = -1) {     if (   i <  0 && str    == e964         || i >= 0 && str[i] == e964)         return [WavePathValue.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const p3768 = i;      const shape     = h2849(str[i]); i += shape    [1];     const x         = h2849(str[i]); i += x        [1];     const y         = h2849(str[i]); i += y        [1];     const width     = h2849(str[i]); i += width    [1];     const amplitude = h2849(str[i]); i += amplitude[1];     const frequency = h2849(str[i]); i += frequency[1];     const offset    = h2849(str[i]); i += offset   [1];     const alignX    = h2849(str[i]); i += alignX   [1];     const alignY    = h2849(str[i]); i += alignY   [1];       const wave = new WavePathValue(         '',          shape    [0],         x        [0],         y        [0],         width    [0],         amplitude[0],         frequency[0],         offset   [0],         alignX   [0],         alignY   [0]);       i = g3709(str, i, wave);           return [wave, i - p3768]; } 


class ArcPathValue extends b2028 {     position;     x;     y;     width;     height;     start;     sweep;      degree;         constructor(nodeId,                 position = new z2021(0),                 x        = new z2021(0),                  y        = new z2021(0),                  width    = new z2021(0),                  height   = new z2021(0),                  start    = new z2021(0),                 sweep    = new z2021(0))     {         super(v1231, nodeId);          this.position = position;         this.x        = x;         this.y        = y;         this.width    = width;         this.height   = height;         this.start    = start;         this.sweep    = sweep;          this.degree   = new z2021(2);     }        copy()     {         const copy = new ArcPathValue(             this.nodeId,             this.position.copy(),              this.x       .copy(),              this.y       .copy(),              this.width   .copy(),              this.height  .copy(),              this.start   .copy(),             this.sweep   .copy());          copy.o3358(this);          return copy;     }        equals(arc)     {         return arc             && this.position.equals(arc.position)             && this.x       .equals(arc.x       )             && this.y       .equals(arc.y       )             && this.width   .equals(arc.width   )             && this.height  .equals(arc.height  )             && this.start   .equals(arc.start   )             && this.sweep   .equals(arc.sweep   );     }        async eval(parse)     {         return this.copy();     }                    t3711()     {         return super.t3711()             && this.position.t3711()             && this.x       .t3711()             && this.y       .t3711()             && this.width   .t3711()             && this.height  .t3711()             && this.start   .t3711()             && this.sweep   .t3711();     }        isValid()     {         return super.isValid()             && this.position.isValid()             && this.x       .isValid()             && this.y       .isValid()             && this.width   .isValid()             && this.height  .isValid()             && this.start   .isValid()             && this.sweep   .isValid();     }        q3632()     {         return this.copy();     }        toString()     {         return      this.position.toString()             + ' ' + this.x       .toString()             + ' ' + this.y       .toString()             + ' ' + this.width   .toString()             + ' ' + this.height  .toString()             + ' ' + this.start   .toString()             + ' ' + this.sweep   .toString()             + ' ' + super.toString();     }        d3704()     {         return 'arc';                                                                                                }        k3705()     {         return      this.position.k3705()             + ' ' + this.x       .k3705()             + ' ' + this.y       .k3705()             + ' ' + this.width   .k3705()             + ' ' + this.height  .k3705()             + ' ' + this.start   .k3705()             + ' ' + this.sweep   .k3705();     }        static NaN = Object.freeze(new ArcPathValue(         '',         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN)); }    function parseArcPathValue(str, i = -1) {     if (   i <  0 && str    == e964         || i >= 0 && str[i] == e964)         return [ArcPathValue.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const p3768 = i;      const pos    = h2849(str[i]); i += pos   [1];     const x      = h2849(str[i]); i += x     [1];     const y      = h2849(str[i]); i += y     [1];     const width  = h2849(str[i]); i += width [1];     const height = h2849(str[i]); i += height[1];     const start  = h2849(str[i]); i += start [1];     const sweep  = h2849(str[i]); i += sweep [1];       const arc = new ArcPathValue(         '',          pos   [0],         x     [0],         y     [0],         width [0],         height[0],         start [0],         sweep [0]);       i = g3709(str, i, arc);           return [arc, i - p3768]; } 


class f2027 extends d2049 {     items = [];        constructor(nodeId, items = [])     {         super(f1264, nodeId);          this.items = items;               }        copy()     {         const copy = new f2027(             this.nodeId,             this.items.map(i => i.copy()));          copy.o3358(this);          return copy;     }        equals(group)     {         if (!group)                                  return false;         if (!(group instanceof f2027))     return false;         if (this.items.length != group.items.length) return false;                      for (let i = 0; i < this.items.length; i++)             if (!this.items[i].equals(group.items[i]))                 return false;          return true;     }        async eval(parse)     {         return this;     }        toString()     {         if (!this.items)             return '';           let str = '';                           str += this.items.length;          for (let i = 0; i < this.items.length; i++)         {             const item = this.items[i];              str += ' ' + item.type + ' ';             str += item.toString();         }           return str;     }        d3704()     {         if (!this.items)             return '';           let str = '';                           str += this.items.length;          for (let i = 0; i < this.items.length; i++)         {             const item = this.items[i];              str += ' ' + item.type + ' ';             str += item.d3704();         }           return str;     }        k3705()     {         if (!this.items)             return '';           let str = '';                           str += this.items.length;          for (let i = 0; i < this.items.length; i++)         {             const item = this.items[i];              str += ' ' + item.type + ' ';             str += item.k3705();         }           return str;     }        q3632()     {         return this.copy();     }        isValid()     {         return  this.items             && !this.items.find(i => !i.isValid());     }            static NaN = new f2027(         '',         u2020.NaN); }    function u3829(str, i = -1) {     if (i < 0)     {         str = str.split(' ');         i   = 0;     }               const p3768 = i;      const group = new f2027();           const r4208 = parseInt(str[i++]);       for (let j = 0; j < r4208; j++)     {         const type = str[i++];                  switch (type)         {             case          z1056:               case    a1059: { const _list   = u3481        (str, i);  i += _list  [1];  group.items.push(_list  [0]);  break; }               case     m1218: { const rect    = a3710   (str, i);  i += rect   [1];  group.items.push(rect   [0]);  break; }             case          p1221: { const line    = u3821        (str, i);  i += line   [1];  group.items.push(line   [0]);  break; }             case       a1224: { const ellipse = s3822     (str, i);  i += ellipse[1];  group.items.push(ellipse[0]);  break; }             case       d1227: { const ellipse = a3823     (str, i);  i += ellipse[1];  group.items.push(ellipse[0]);  break; }             case       b1236: { const poly    = f3824     (str, i);  i += poly   [1];  group.items.push(poly   [0]);  break; }             case          y1239: { const star    = f3825        (str, i);  i += star   [1];  group.items.push(star   [0]);  break; }             case    x1242: { const text    = q3826   (str, i);  i += text   [1];  group.items.push(text   [0]);  break; }             case         v1245: { const point   = c3827       (str, i);  i += point  [1];  group.items.push(point  [0]);  break; }             case   q1249: { const path    = d3669  (str, i);  i += path   [1];  group.items.push(path   [0]);  break; }             case i1287: { const path    = k3828(str, i);  i += path   [1];  group.items.push(path   [0]);  break; }             case   f1264: { const _group  = u3829  (str, i);  i += _group [1];  group.items.push(_group [0]);  break; }             case         q1267: { const frame   = m3830       (str, i);  i += frame  [1];  group.items.push(frame  [0]);  break; }         }     }           return [         group,          i - p3768]; } 


class j2013 extends b2028 {     children;     position;     x;     y;     width;     height;     round;     clip;        constructor(nodeId, children, position, x, y, width, height, round, clip)     {         super(q1267, nodeId);          this.children = children;         this.position = position;         this.x        = x;         this.y        = y;         this.width    = width;         this.height   = height;         this.round    = round;         this.clip     = clip;          this.objects =                 children             && children.objects              ? children.objects.map(o => o.copy())              : [];     }        copy()     {         const copy = new j2013(             this.nodeId,             this.children.copy(),             this.position.copy(),             this.x       .copy(),             this.y       .copy(),             this.width   .copy(),             this.height  .copy(),             this.round   .copy(),             this.clip    .copy());          copy.o3358(this);          return copy;     }        equals(frame)     {         return frame             && this.children.equals(frame.children)             && this.position.equals(frame.position)             && this.x       .equals(frame.x       )             && this.y       .equals(frame.y       )             && this.width   .equals(frame.width   )             && this.height  .equals(frame.height  )             && this.round   .equals(frame.round   )             && this.clip    .equals(frame.clip    );     }        async eval(parse)     {         return this;     }        toString()     {         return       this.children.toString()              + ' ' + this.position.toString()              + ' ' + this.x       .toString()              + ' ' + this.y       .toString()              + ' ' + this.width   .toString()              + ' ' + this.height  .toString()              + ' ' + this.round   .toString()              + ' ' + this.clip    .toString()              + ' ' + super.toString();     }        d3704()     {         return 'frame';                                                                                                             }        k3705()     {         return       this.children.k3705()              + ' ' + this.position.k3705()              + ' ' + this.x       .k3705()              + ' ' + this.y       .k3705()              + ' ' + this.width   .k3705()              + ' ' + this.height  .k3705()              + ' ' + this.clip    .k3705()              + ' ' + this.round   .k3705();     }        q3632()     {         return this.copy();     }        isValid()     {         return super.isValid()             && this.children.isValid()             && this.position.isValid()             && this.x       .isValid()             && this.y       .isValid()             && this.width   .isValid()             && this.height  .isValid()             && this.round   .isValid()             && this.clip    .isValid();     }            static NaN = new j2013(         '',         u2020  .NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN,         z2021.NaN); }    function m3830(str, i = -1) {     if (   i <  0 && str    == e964         || i >= 0 && str[i] == e964)         return [j2013.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const p3768 = i;      const children = u3481  (str, i); i += children[1];     const position = h2849(str[i]); i += position[1];     const x        = h2849(str[i]); i += x       [1];     const y        = h2849(str[i]); i += y       [1];     const width    = h2849(str[i]); i += width   [1];     const height   = h2849(str[i]); i += height  [1];     const round    = h2849(str[i]); i += round   [1];     const clip     = h2849(str[i]); i += clip    [1];      const frame = new j2013(         '',          children[0],         position[0],         x       [0],         y       [0],         width   [0],         height  [0],         round   [0],         clip    [0]);       i = g3709(str, i, frame);           return [frame, i - p3768]; } 


class h1866 extends u2043 {     count            = null;     iteration        = null;    y3679            = null;     loop             = null;      f3818 = [];      isTerminal       = false;      activeAfter      = false;      listAfter        = false;         constructor(nodeId, options)     {         super(e1064, nodeId, options);     }            reset()     {         super.reset();          this. count      = null;         this. iteration  = null;         this.y3679      = null;         this. loop       = null;          this.isTerminal  = false;         this.activeAfter = false;         this.listAfter   = false;          this.f3818 = [];     }        copy()     {         const copy = new h1866(this.nodeId, this.options);          copy.o3358(this);          if (this. value    ) copy. value     = this. value    .copy();         if (this. iteration) copy. iteration = this. iteration.copy();         if (this. count    ) copy. count     = this. count    .copy();         if (this.y3679    ) copy.y3679     = this.y3679    .copy();         if (this. loop     ) copy. loop      = this. loop     .copy();          copy.isTerminal  = this.isTerminal;         copy.activeAfter = this.activeAfter;         copy.listAfter   = this.listAfter;          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       let   count     = await evalNumberValue(this.count,     parse);         let   iteration = await evalNumberValue(this.iteration, parse);         let  y3679     = new z2021(1);           let iterations = [];          if (iteration.isValid())         {             if (iteration.type != i1143)                 iteration = new b2032(iteration.value.toString());              const _iterations = iteration.value.split(',');                          if (_iterations.length > 1)             {                 for (const iter of _iterations)                 {                     if (iter.includes('-'))                     {                         const iterParts = iter.split('-');                          if (iterParts.length == 2)                         {                             let start = iterParts[0];                             let end   = iterParts[1];                              if (   !isNaN(Number(start))                                 && !isNaN(Number(end  )))                             {                                 for (let i = start; i <= end; i++)                                     iterations.push(parseInt(i));                             }                         }                     }                     else                         iterations.push(parseInt(iter));                 }             }             else                 iterations.push(parseInt(iteration.value));         }           count =              count             ? new z2021(Math.floor(count.value))             : new z2021(0);           if (   this.loop              && this.loop.type != m1091)              l3356(this.loop, this);           this.value = new u2020();         this.value.objects = [];           if (   count             && count.value > 0)                                                             {             if (this.input)             {                 const j3179    = Date.now();                 let   r3817 = false;                   const nRepeats =                      this.options.enabled                      ? count.value                      : 0;                                   let repeat =                 {                     repeatId:         this.nodeId,                     currentIteration: 0,                     total:            nRepeats                 };                                       parse.repeats.push(repeat);                  if (parse.repeats.length == 1)                     parse.s3639 += nRepeats;                   if (   this.loop                     && this.loop.y3628)                     this.loop.y3628(parse, this.nodeId);                   if (this.loop)                 {                     parse.evalAccumulate = false;                     await this.loop.eval(parse);                      parse.evalAccumulate = true;                 }                   for (let i = 0, o = 0; i < Math.max(1, nRepeats); i++)                 {                     if (  !r3817                         && Date.now() - j3179 > 50)                     {                         z2076(this.nodeId);                         r3817 = true;                     }                       repeat.currentIteration = i;                       this.input.e4088(parse, this, false);                                           const input = await evalValue      (this.input, parse);                          y3679 = await evalNumberValue(this.y3679, parse);                       if (   input                         && nRepeats > 0                         && (  !y3679                              || y3679.value > 0))                     {                                                                           if (o957(input.type))                         {                             if (input.condensed === true)                                 this.value.items.push(input);                             else                             {                                 for (const item of input.items)                                     this.value.items.push(item);                             }                         }                         else                             this.value.items.push(input);                                   if (   this.options.active                             || this.options.d2997                             || this.options.beforeList)                         {                             this.f3818 = [];                                                       if (input.objects)                             {                                 for (let j = 0; j < input.objects.length; j++, o++)                                 {                                     const g111 = w3737(input.objects[j]);                                       this.f3818.push(g111.copy());                                       if (  !iteration.isValid()                                         || iterations.includes(i))                                     {                                         g111.nodeId      = this.nodeId;                                         g111.listId      = i;                                          g111.objectId   += c967 + this.nodeId + ':' + (o+1).toString();                                         g111.objectName += ' ' + (o+1).toString();                                          g111.y3819   = repeat.currentIteration;                                          if (this.value.objects)                                             this.value.objects.push(g111);                                     }                                 }                             }                         }                     }                       this.input.q4086(parse);                       if (   this.loop                         && this.loop.iterateCache)                         this.loop.iterateCache(parse, this);                                           if (parse.repeats.length == 1)                     {                         parse.n3638++;                          if (await t3861(parse.f2066))                         {                             v2078(this.nodeId);                             return this;                         }                     }                                           if (r3817)                         y2077(parse, this.nodeId, i / nRepeats);                 }                   if (   this.loop                     && this.loop.z3631)                     this.loop.z3631(parse, this.nodeId);                   if (this.startTimer > -1)                 {                     clearTimeout(this.startTimer);                     this.startTimer = -1;                 }                   v2078(this.nodeId);                   c952(parse.repeats.at(-1) == repeat, 'invalid nested repeat \'' + this.nodeId + '\'');                 parse.repeats.pop();             }             else if (this.input)                 await evalValue(this.input, parse);         }         else if (this.input)             await evalValue(this.input, parse);                   const type = this.outputListType();          this.l4100(parse,         [             ['type',      type     ],             ['count',     count    ],             ['iteration', iteration]         ]);           this.validate();          return this;     }        q3632()     {         return this.value.copy();     }        isValid()     {         return super.isValid()             && this. count     && this. count    .isValid()             && this. iteration && this. iteration.isValid()             && (!this.y3679   || this.y3679    .isValid());     }        g4087(parse)     {         super.g4087(parse);          if (this. count    ) this. count    .g4087(parse);         if (this. iteration) this. iteration.g4087(parse);         if (this.y3679    ) this.y3679    .g4087(parse);         if (this. loop     ) this. loop     .g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this. count    ) this. count    .e4088(parse, from, force);         if (this. iteration) this. iteration.e4088(parse, from, force);         if (this.y3679    ) this.y3679    .e4088(parse, from, force);         if (this. loop     ) this. loop     .e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this. count    ) this. count    .q4086(parse);         if (this. iteration) this. iteration.q4086(parse);         if (this.y3679    ) this.y3679    .q4086(parse);         if (this. loop     ) this. loop     .q4086(parse);     } }    function l3356(loop, node) {     c952(            loop.type == o1086         || loop.type == p1066         || loop.type == g1104         || loop.type == a1105         || loop.type == a1103         || loop.type == e1106         || loop.type == d1107         || loop.type == h1108         || loop.type == v1069         || loop.type == PARAM,          'only volatile types can be repeated'); }


class b1875 extends u2043 {     from   = null;      q3820 = NULL;            constructor(nodeId, options)     {         super(s1063, nodeId, options);     }            reset()     {         super.reset();          this.from = null;     }        copy()     {         const copy = new b1875(this.nodeId, this.options);          copy.o3358(this);          if (this.value) copy.value = this.value.copy();          return copy;     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        async eval(parse)     {         if (     !parse.evalFeedback)             return this;                    const input = await evalValue(this.input, parse);                     this.l4100(parse,          [             ['type', this.outputListType()]         ]);           await this.t4099(parse, {input});                   this.validate();          return this;     }        async t4099(parse, options = {})     {         const repeat = parse.repeats.find(r => r.repeatId == this.q3820);           const feedback =                 repeat             && repeat.currentIteration > 0             && this.from;                   this.value = new u2020();          if (feedback)         {             for (const g111 of this.from.f3818)                 this.value.items.push(g111.q3632());              if (this.from.f3818)                 this.value.objects = this.from.f3818.map(o => o.copy());         }         else if (options.input               && options.input.isValid())         {             this.value.items.push(options.input);              if (options.input.objects)                 this.value.objects = options.input.objects.map(o => o.copy());         }           const iter =             repeat              ? NAME_SEPARATOR + repeat.currentIteration              : '';          for (const item of this.value.items)             item.nodeId = this.nodeId;          if (this.value.objects)         {             for (let i = 0; i < this.value.objects.length; i++)             {                 const g111 = this.value.objects[i];                  g111.nodeId   = this.nodeId;                 g111.objectId = this.nodeId + c967 + i + iter;             }         }           await super.t4099(parse);     }        q3632()     {         return this.value.copy();     }                                y3628(parse, nodeId)     {         super.y3628(parse, nodeId);          this.from = parse.c4242.find(n => n.nodeId == nodeId);     }        z3631(parse, nodeId)     {         super.z3631(parse, nodeId);          this.from = null;     } } 


class o1865 extends u2043 {     constructor(nodeId, options)     {         super(o1060, nodeId, options);     }            copy()     {         const copy = new o1865(this.nodeId, this.options);          copy.o3358(this);          if (this.value) copy.value = this.value.copy();         if (this.input) copy.input = this.input.copy();          return copy;     }        async eval(parse)     {                             this.value =              this.input              ? (await this.input.eval(parse)).q3632()              : new x4216();           this.g4215();           this.l4100(parse,         [             ['type', this.outputType()]         ]);           this.validate();          return this;     }        q3632()     {         return this.value              ? this.value.copy()              : null;     } } 


class f1880 extends z2042 {     varValue = null;        constructor(nodeId, options, styleId)     {         super(o1061, nodeId, options);     }        reset()     {         super.reset();          this.varValue = null;     }        copy()     {         const copy = new t1886(this.nodeId, this.options);          if (this.varValue) copy.varValue = this.varValue.copy();                  return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                   this.value =              this.varValue             ? (await this.varValue.eval(parse)).q3632()             : new x4216();           this.l4100(parse,         [             ['value', this.value]         ]);           this.validate();          return this;     }        evalVariable(options = {})     {         if (!this.options.enabled)             return;     }        isValid()     {         return this.varValue && this.varValue.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.varValue) this.varValue.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.varValue) this.varValue.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.varValue) this.varValue.q4086(parse);     } }


class w1881 extends z2042 {     input = null;        constructor(nodeId, options)     {         super(l1062, nodeId, options);     }        copy()     {         const copy = new m1863(this.nodeId, this.options);                  copy.o3358(this);          if (this.input) copy.input = this.input.copy();                  for (const key of this.keys())         {             if (this[key] instanceof d2049)                 Object.assign(copy, {[key]: this[key]});         }          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await evalListValue(this.input, parse);           this.c3095 = [];                                                                                                                                                                                                                                                  this.l4100(parse, [['', new x4216()]], true);                                        this.validate();          return this;     }                u4241(v2991)     {         return this.value             && this.value.items             && v2991 != 'value'             ? this.value.items.find(i => i.valueId == v2991)              : null;     }        q3632()     {         return this.value.copy();     }        isValid()     {         return this.input && this.input.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.input) this.input.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.input) this.input.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.input) this.input.q4086(parse);     } }


class u1853 extends u2043 {     a4211 = null;        constructor(nodeId, options)     {         super(m1065, nodeId, options);     }            reset()     {         super.reset();          this.a4211 = null;     }        copy()     {         const copy = new u1853(this.nodeId, this.options);          copy.o3358(this);          if (this.value) copy.value = this.value.copy();                   return copy;     }        async eval(parse)     {         if (!this.options.enabled)             this.a4211 = null;                      if (   this.isCached()             && this.a4211)             return this;           if (this.a4211)         {             this.value = this.a4211.copy();         }         else         {             const input = await evalValue(this.input, parse);              this.value = input;              if (   this.options.enabled                 && this.value)                 this.a4211 = this.value.copy();                       }           this.g4215();           this.l4100(parse,         [             ['type', this.outputType()]         ]);           this.validate();          return this;     }        q3632()     {         return this.value              ? this.value.copy()              : null;     }        iterateCache(parse, from)     {         this.a4211 = null;          super.iterateCache(parse, from);     } } 


class w1861 extends u2043 {     frozen = false;      q3820 = NULL;        constructor(nodeId, options)     {         super(p1066, nodeId, options);     }            reset()     {         super.reset();          this.frozen = false;     }        copy()     {         const copy = new w1861(this.nodeId, this.options);          copy.o3358(this);          if (this.value) copy.value = this.value.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const repeat = parse.repeats.find(r => r.repeatId == this.q3820);           if (      repeat                && repeat.currentIteration == 0             || !this.options.enabled)             this.frozen = false;           if (!this.frozen)         {             this.value =                  this.input                  ? (await this.input.eval(parse)).q3632()                 : new x4216();              this.frozen = true;              this.g4215();         }           this.l4100(parse,         [             ['type', this.outputType()]         ]);           this.validate();          return this;     }        q3632()     {         return this.value              ? this.value.copy()              : null;     } } 


class h1877 extends u2043 {     interval = null;    y3679    = null;     loop     = null;        constructor(nodeId, options)     {         super(v1067, nodeId, options);     }            reset()     {         super.reset();          this. interval = null;         this.y3679    = null;         this. loop     = null;     }        copy()     {         const copy = new h1877(this.nodeId, this.options);          copy.o3358(this);          if (this. interval) copy. interval = this. interval.copy();         if (this.y3679   ) copy.y3679    = this.y3679   .copy();         if (this. loop    ) copy. loop     = this. loop    .copy();          return copy;     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;           const  interval = await evalNumberValue(this. interval, parse);         const y3679    = await evalNumberValue(this.y3679,    parse);         const  loop     = await evalNumberValue(this. loop,     parse);                       if (this.loop.type != m1091) l3356(this.loop, this);          if (y3679.value == 0)             return this;           if (this.input)         {             this.input.e4088(parse, this, true);              const input = await evalValue(this.input, parse);              this.value = input ? input : new x4216();              if (this.loop.type != m1091)                 this.loop.q4086(parse);         }         else             this.value = new x4216();                       this.l4100(parse,         [             ['value',    this.value],             ['interval', interval  ]         ]);                   this.g4215();           this.validate();          return this;     }        q3632()     {         return this.value.copy();     }        isValid()     {         return super.isValid()             && this.interval && this.interval.isValid()             && this.y3679   && this.y3679  .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this. interval) this. interval.g4087(parse);         if (this.y3679   ) this.y3679   .g4087(parse);         if (this. loop    ) this. loop    .g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this. interval) this. interval.e4088(parse, from, force);         if (this.y3679   ) this.y3679   .e4088(parse, from, force);         if (this. loop    ) this. loop    .e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this. interval) this. interval.q4086(parse);         if (this.y3679   ) this.y3679   .q4086(parse);         if (this. loop    ) this. loop    .q4086(parse);     } } 


class c1879 extends u2043 {     name = null;        constructor(nodeId, options)     {         super(d1068, nodeId, options);     }            reset()     {         super.reset();          this.name = null;     }        copy()     {         const copy = new c1879(this.nodeId, this.options);          copy.o3358(this);          if (this.value) copy.value = this.value.copy();         if (this.name ) copy.name  = this.name .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value =              this.input              ? (await this.input.eval(parse)).q3632()              : new x4216();                   const name = await evalTextValue(this.name, parse);           if (   this.options.enabled             && this.value.isValid())         {             this.value.valueId = name.value;         }           this.g4215();           this.l4100(parse,         [             ['type', this.outputType()],             ['name', name             ]         ]);           this.validate();          return this;     }        q3632()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.name && this.name.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.name) this.name.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.name) this.name.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.name) this.name.q4086(parse);     }        z3631(parse, nodeId)     {         super.z3631(parse, nodeId);          if (this.name) this.name.z3631(parse, nodeId);     } } 


class GGetListValueNames extends u2043 {             constructor(nodeId, options)     {         super(j1352, nodeId, options);     }            reset()     {         super.reset();               }        copy()     {         const copy = new GGetListValueNames(this.nodeId, this.options);          copy.o3358(this);          return copy;     }        async eval(parse)     {         if (   this.isCached())                          return this;           const input = await evalListValue(this.input, parse);           this.counts = new u2020();                                                    if (   input                 && input.items)             {                 if (this.options.enabled)                 {                     this.value = new u2020();                     this.value.objects = [];                      for (let i = 0; i < input.items.length; i++)                         this.value.items.push(new b2032(input.items[i].valueId));                      if (input.objects)                     {                         for (let i = 0; i < input.objects.length; i++)                             this.value.objects.push(input.objects[i]);                     }                 }                 else                     this.value = input.copy();             }             else                 this.value = u2020.NaN.copy();                                       this.g4215();           this.l4100(parse,          [             ['type',   this.outputListType()                   ],             ['length', new z2021(this.value.items.length)]         ]);                           if (parse.settings.l3733)         {             this.l4100(parse,             [                 ['preview', new u2020(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     } } 


class GListValueNames extends z2044 {     constructor(nodeId, options)     {         super(l1353, nodeId, options);     }            copy()     {         const copy = new GListValueNames(this.nodeId, this.options);          copy.o3358(this);          if (this.value) copy.value = this.value.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const z4082 = await evalListValue(this.z4082, parse);         const z4083 = await evalListValue(this.z4083, parse);                   if (   this.options.enabled             && z4082             && z4083             && z4082.items             && z4083.items)         {             for (let i = 0; i < z4082.items.length && i < z4083.items.length; i++)                 z4082.items[i].valueId = z4083.items[i].value;              this.value = z4082;         }         else if (z4082)             this.value = z4082;            this.g4215();           this.l4100(parse,         [             ['type', this.outputListType()]         ]);           this.validate();          return this;     } } 


class GObjectName extends u2043 {     name    = null;           constructor(nodeId, options)     {         super(p1354, nodeId, options);     }            reset()     {         super.reset();          this.name    = null;            }        copy()     {         const copy = new GObjectName(this.nodeId, this.options);          copy.o3358(this);          if (this.value  ) copy.value   = this.value  .copy();         if (this.name   ) copy.name    = this.name   .copy();                 return copy;     }        async eval(parse)     {                             this.value =              this.input              ? (await this.input.eval(parse)).q3632()              : new x4216();                   const name    = await evalTextValue  (this.name, parse);                          if (   this.options.enabled             && this.value.isValid()             && this.value.objects)         {             for (const g111 of this.value.objects)             {                 g111.nodeId     = this.nodeId;                 g111.objectName = name.value;                           }         }           this.g4215();           this.l4100(parse,         [             ['type',    this.outputType()],             ['name',    name             ]                    ]);           this.validate();          return this;     }        q3632()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.name    && this.name   .isValid()               }        g4087(parse)     {         super.g4087(parse);          if (this.name   ) this.name   .g4087(parse);           }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.name   ) this.name   .e4088(parse, from, force);           }        q4086(parse)     {         super.q4086(parse);          if (this.name   ) this.name   .q4086(parse);           }        z3631(parse, nodeId)     {         super.z3631(parse, nodeId);          if (this.name   ) this.name   .z3631(parse, nodeId);           } } 


class w1856 extends z2042 {     inputs = [];      value;        constructor(nodeId, options)     {         super(v1069, nodeId, options);     }            reset()     {         super.reset();          this.inputs = [];     }        copy()     {         const copy = new w1856(this.nodeId, this.options);          copy.o3358(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.value) copy.value = this.value.copy();          return copy;     }        isCached()     {         for (const input of this.inputs)             if (!input.isCached())                 return false;          return super.isCached();     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new u2020();          this.value.objects = [];           for (let i = 0; i < this.inputs.length; i++)         {             const input = await evalValue(this.inputs[i], parse);               if (   input                 && input.isValid()                 && this.options.enabled)             {                 if (o957(input.type))                 {                     if (input.condensed === true)                         this.value.items.push(input);                     else                     {                         for (const item of input.items)                             this.value.items.push(item);                     }                 }                 else                     this.value.items.push(input);             }               const inputObjects = this.g3626(input, i);                          for (const g111 of inputObjects)             {                 g111.objectId += c967 + i;                 g111.y3819 = i;             }              this.value.objects.push(...inputObjects);         }                     const bounds = getObjBounds(this.value.objects);          const singlePoint =                this.value.objects.length  == 1              && this.value.objects[0].type == q1246;          for (const g111 of this.value.objects)         {             const angle1 = m884(g111.sp0, g111.sp1);             const angle2 = m884(g111.sp0, g111.sp2);              g111.f3741(g111.sp0.x, g111.sp0.y);                          g111.sp1 = x895(g111.sp0, vector(angle1, 1));             g111.sp2 = x895(g111.sp0, vector(angle2, 1));              g111.resetSpace(bounds, singlePoint);         }                   const length = new z2021(this.value.items.length);         const type   = new b2032(s3478(this.value.items));           this.l4100(parse,         [             ['length', length],             ['type',   type  ]         ]);           if (parse.settings.l3733)         {             this.l4100(parse,             [                 ['preview', new u2020(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        q3632()     {         return this.value.copy();     }        isValid()     {         return !this.inputs.find(i => !i.isValid());     }        g4087(parse)     {         super.g4087(parse);          this.inputs.forEach(i => i.g4087(parse));     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          this.inputs.forEach(i => i.e4088(parse, from, force));     }        y3628(parse, q3820)     {         this.inputs.forEach(i => i.y3628(parse, q3820));     }        i3629(parse, nodeId)     {         this.inputs.forEach(i => i.i3629(parse, nodeId));     }        q4086(parse)     {         this.inputs.forEach(i => i.q4086(parse));     }        iterateCache(parse, from)     {         for (const input of this.inputs)         {             if (   input.type == k1080                 || input.type == v1069                 || input.type == m1065)                 input.iterateCache(parse, from);         }     }        z3631(parse, nodeId)     {         this.inputs.forEach(i => i.z3631(parse, nodeId));     } }


class h1857 extends u2043 {             constructor(nodeId, options)     {         super(t1070, nodeId, options);     }            reset()     {         super.reset();               }        copy()     {         const copy = new h1857(this.nodeId, this.options);          copy.o3358(this);                    return copy;     }        async eval(parse)     {         if (   this.isCached())                          return this;           this.value = new u2020();         this.value.condensed = true;          let length = 0;           const input = await evalListValue(this.input, parse);                                                    if (input)             {                 length = input.items.length;                                                       if (   o957(input.type)                     && this.options.enabled)                 {                     for (const item of input.items)                     {                         const copy = item.copy();                          this.value.items.push(copy);                                              }                 }                 else                 {                     const copy = input.copy();                      this.value.items.push(copy);                     this.value.objects.push(...copy.objects);                 }             }             else                 this.value = new u2020();                                       this.g4215();               this.l4100(parse,         [             ['length', new z2021(length)                              ],             ['type', new b2032(s3478(this.value.items))]         ]);                   this.validate();          return this;     } } 


class k1859 extends u2043 {     indices     = null;                  constructor(nodeId, options)     {         super(j1071, nodeId, options);     }            reset()     {         super.reset();          this.indices = null;                   }        copy()     {         const copy = new k1859(this.nodeId, this.options);          copy.o3358(this);          if (this.indices) copy.indices = this.indices.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input   = await evalListValue(this.input,   parse);         const indices = await evalListValue(this.indices, parse);           this.value = new u2020();          let length = 0;                                                            if (   input                 && indices                 && input.items)             {                 length = input.items.length;                   if (this.options.enabled)                 {                     for (let i = 0; i < indices.items.length; i++)                     {                         const item = input.items[Math.round(indices.items[i].value)];                                                  this.value.items.push(item ? item.copy() : new x4216());                                                  if (   item                             && item.objects                             && this.value.objects)                              this.value.objects.push(...item.objects);                     }                 }             }             else                 this.value = u2020.NaN.copy();                               this.g4215();           this.l4100(parse,         [             ['type',    this.outputListType()                   ],             ['length',  new z2021(this.value.items.length)],              ['indices', indices                                 ]         ]);                   if (parse.settings.l3733)         {             this.l4100(parse,             [                 ['preview', new u2020(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.indices && this.indices.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.indices) this.indices.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.indices) this.indices.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.indices) this.indices.q4086(parse);     } } 


class e1872 extends z2044 {     name = null;            constructor(nodeId, options)     {         super(z1072, nodeId, options);     }            reset()     {         super.reset();          this.name  = null;     }        copy()     {         const copy = new e1872(this.nodeId, this.options);          copy.o3358(this);          if (this.name) copy.name = this.name.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const z4082 = await evalValue    (this.z4082, parse);         const z4083 = await evalValue    (this.z4083, parse);         const name   = await evalTextValue(this.name,   parse);           if (   z4082             && name)         {             let nameValue = name.value.trim();               if (o957(z4082.type))             {                 this.value = new u2020();                  if (this.options.enabled)                 {                     for (let i = 0; i < z4082.items.length; i++)                     {                         const item = z4082.items[i];                          if (   z4083                             && name.value.trim() != '')                             item.customParams.push([nameValue, z4083]);                                                   if (   item                             && item[nameValue]                             && item[nameValue].objects                              && this.value.objects)                             this.value.objects.push(...item[nameValue].objects);                     }                 }                 else                     this.value = z4082;             }             else             {                 this.value = z4082;                  if (   z4083                     && nameValue != ''                     && this.options.enabled)                     this.value.customParams.push([nameValue, z4083]);             }         }         else         {             this.value = new x4216();         }           this.g4215();           this.l4100(parse,         [             ['type', this.outputType()],             ['name', name             ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.name && this.name.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.name) this.name.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.name) this.name.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.name) this.name.q4086(parse);     } } 


class g1873 extends u2043 {     name = null;            constructor(nodeId, options)     {         super(q1073, nodeId, options);     }            reset()     {         super.reset();          this.name  = null;     }        copy()     {         const copy = new g1873(this.nodeId, this.options);          copy.o3358(this);          if (this.name) copy.name = this.name.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalValue    (this.input, parse);         const name  = await evalTextValue(this.name,  parse);           if (   input             && name             && name.value.trim() != '')         {             if (this.options.enabled)             {                 if (o957(input.type))                 {                     this.value = new u2020();                      for (let i = 0; i < input.items.length; i++)                         this.value.items.push(getGetParamValue(input.items[i], name));                 }                 else                     this.value = getGetParamValue(input, name);             }             else                 this.value = input.copy();         }         else         {             this.value = new x4216();         }           this.g4215();           const type = this.outputType();                  this.l4100(parse,         [             ['value', this.value],             ['type',  type      ],             ['name',  name      ]         ]);                   if (type.value == i1143 && parse.settings.z3732)         {             this.l4100(parse,             [                 ['preview', this.value]             ],             true);         }         else if (o957(type.value)   && parse.settings.l3733)         {             this.l4100(parse,             [                 ['preview', new u2020(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.name && this.name.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.name) this.name.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.name) this.name.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.name) this.name.q4086(parse);     } }    function getGetParamValue(input, name) {     let nameValue = name.value.trim();       if (    input         && !input[nameValue])     {              if (input[name.value.toUpperCase()]) nameValue = name.value.toUpperCase();         else if (input[name.value.toLowerCase()]) nameValue = name.value.toLowerCase();     }       let value = null;      if (   input         && input[nameValue])     {         value = input[nameValue];     }     else     {         const customIndex = input.customParams.findIndex(p => p[0] == nameValue);          value =             customIndex > -1             ? input.customParams[customIndex][1]             : new x4216();     }       if (   input         && input[nameValue]         && input[nameValue].objects          && this.value.objects)         value.objects.push(...input[nameValue].objects);       return value; }


class f1876 extends u2043 {     start       = null;     end         = null;                  constructor(nodeId, options)     {         super(f1074, nodeId, options);     }            reset()     {         super.reset();          this.start       = null;         this.end         = null;               }        copy()     {         const copy = new f1876(this.nodeId, this.options);          copy.o3358(this);          if (this.start) copy.start = this.start.copy();         if (this.end  ) copy.end   = this.end  .copy();          return copy;     }        async eval(parse)     {         if (   this.isCached())                          return this;           const input = await evalListValue  (this.input, parse);         const start = await evalNumberValue(this.start, parse);         const end   = await evalNumberValue(this.end,   parse);           let length = 0;                                                                this.value = new u2020();             this.value.objects = [];               if (   input                 && start                 && end)             {                 if (input.items)                 {                     length = input.items.length;                       const _end =                         end.isValid()                         ? end                         : new z2021(input.items.length);                       if (this.options.enabled)                     {                         const endValue =                              _end.value < 0                             ? length + _end.value                             : _end.value;                          if (start.value < endValue)                         {                             for (let i = start.value, j = 0; i < endValue; i++, j++)                             {                                 const item = input.items[i];                                                                  this.value.items.push(item ? item.copy() : new x4216());                                                                  if (   item                                     && this.value.objects                                     && item.objects)                                 {                                     item.objects.forEach(o => o.y3819 = j);                                     this.value.objects.push(...item.objects);                                 }                             }                         }                         else                             this.value = u2020.NaN.copy();                     }                     else                         this.value = input.copy();                 }                 else                     this.value = u2020.NaN.copy();             }                                   this.g4215();           this.l4100(parse,         [             ['type',       this.outputListType()                          ],             ['length',     new z2021(this.value.items.length)       ],              ['fullLength', new z2021(input ? input.items.length : 0)],              ['start',      start                                          ],             ['end',        end                                            ]         ]);                   if (parse.settings.l3733)         {             this.l4100(parse,             [                 ['preview', new u2020(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.start && this.start.isValid()             && this.end   && this.end  .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.start) this.start.g4087(parse);         if (this.end  ) this.end  .g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.start) this.start.e4088(parse, from, force);         if (this.end  ) this.end  .e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.start) this.start.q4086(parse);         if (this.end  ) this.end  .q4086(parse);     } } 


class v1878 extends u2043 {     counts      = null;     indices     = null;                  constructor(nodeId, options)     {         super(k1075, nodeId, options);     }            reset()     {         super.reset();          this.counts  = null;         this.indices = null;                       }        copy()     {         const copy = new v1878(this.nodeId, this.options);          copy.o3358(this);          if (this.counts ) copy.counts  = this.counts .copy();         if (this.indices) copy.indices = this.indices.copy();          return copy;     }        async eval(parse)     {         if (   this.isCached())                          return this;           const input = await evalListValue(this.input, parse);                                                    this.counts  = new u2020();             this.indices = new u2020();                           if (input)             {                 if (this.options.enabled)                 {                     this.value = new u2020();                      for (let i = 0; i < input.items.length; i++)                     {                         const item       = input.items[i];                         const foundIndex = this.value.items.findIndex(i => i.equals(item));                          if (foundIndex < 0)                         {                             this.value.items.push(item.copy());                              if (   this.value.objects                                 && item.objects)                                 this.value.objects.push(...item.objects);                              this.counts .items.push(new z2021(1));                             this.indices.items.push(new u2020([new z2021(i)]));                         }                         else                         {                             this.counts .items[foundIndex].value++;                             this.indices.items[foundIndex].items.push(new z2021(i));                         }                     }                 }                 else                     this.value = input.copy();             }             else                 this.value = new u2020();                               this.g4215();           this.l4100(parse,         [             ['type',    this.outputListType()                   ],             ['length',  new z2021(this.value.items.length)],             ['counts',  this.counts                             ],             ['indices', this.indices                            ]         ]);                   if (parse.settings.l3733)         {             this.l4100(parse,             [                 ['preview', new u2020(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }                                                                                                                                        } 


class f1867 extends u2043 {     indices = null;            constructor(nodeId, options)     {         super(y1349, nodeId, options);     }            reset()     {         super.reset();          this.indices = null;     }        copy()     {         const copy = new f1867(this.nodeId, this.options);          copy.o3358(this);          if (this.indices) copy.indices = this.indices.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input   = await evalListValue(this.input,   parse);         const indices = await evalListValue(this.indices, parse);           this.value         = new u2020();         this.value.objects = [];           if (   input             && input.items)         {             if (   this.options.enabled                 && indices                 && input.items                 && indices.items                 && input.items.length == indices.items.length)             {                 this.value.items = new Array(input.items.length);                  for (let i = 0; i < input.items.length; i++)                     this.value.items[i] = input.items[indices.items[i].value];                                   for (let i = 0; i < this.value.items.length; i++)                 {                     const item = this.value.items[i];                      if (   item.objects                         && this.value.objects)                     {                         const objects = ordered.objects.filter(o => o.y3819 == y3819).map(o => o.copy());                         objects.forEach(o => o.y3819 = i);                          this.value.objects.push(...objects);                     }                 }             }             else                 this.value = input.copy();         }         else             this.value = new u2020();           this.g4215();           this.l4100(parse,         [             ['type',    this.outputListType()],             ['indices', indices              ]         ]);                   if (parse.settings.l3733)         {             this.l4100(parse,             [                 ['preview', new u2020(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.indices && this.indices.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.indices) this.indices.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.indices) this.indices.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.indices) this.indices.q4086(parse);     } }


class l1868 extends u2043 {     offset = null;            constructor(nodeId, options)     {         super(x1350, nodeId, options);     }            reset()     {         super.reset();          this.offset = null;     }        copy()     {         const copy = new l1868(this.nodeId, this.options);          copy.o3358(this);          if (this.offset) copy.offset = this.offset.copy();          return copy;     }        async eval(parse)     {         if (   this.isCached())                          return this;           const input  = await evalListValue  (this.input,  parse);         const offset = await evalNumberValue(this.offset, parse);           let length = 0;                       this.value = new u2020();         this.value.objects = [];           if (   input             && offset)         {             if (input.items)             {                 length = input.items.length;                  if (this.options.enabled)                 {                     let _offset = offset.value % input.items.length;                     while (_offset < 0) _offset += input.items.length;                      let j = 0;                     for (let i = _offset; i < input.items.length; i++, j++)                         this.addItem(input, i, j);                      for (let i = 0; i < _offset; i++, j++)                         this.addItem(input, i, j);                 }                 else                     this.value = input.copy();             }             else                 this.value = u2020.NaN.copy();         }           this.g4215();           this.l4100(parse,         [             ['type',       this.outputListType()                          ],             ['length',     new z2021(this.value.items.length)       ],              ['offset',     offset                                         ]         ]);                   if (parse.settings.l3733)         {             this.l4100(parse,             [                 ['preview', new u2020(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        addItem(input, i, j)     {         const item = input.items[i];          this.value.items.push(item ? item.copy() : new x4216());                  if (   item             && this.value.objects             && input.objects)         {                          item.objects.forEach(o => o.y3819 = j);              this.value.objects.push(...item.objects);         }     }        isValid()     {         return super.isValid()             && this.offset && this.offset.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.offset) this.offset.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.offset) this.offset.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.offset) this.offset.q4086(parse);     } } 


class j1869 extends u2043 {     constructor(nodeId, options)     {         super(u1076, nodeId, options);     }            reset()     {         super.reset();     }        copy()     {         const copy = new j1869(this.nodeId, this.options);          copy.o3358(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalValue(this.input, parse);           if (input)         {             if (this.options.enabled)             {                 this.value = new u2020();                 this.value.objects = [];                  for (let i = input.items.length-1; i >= 0; i--)                     this.value.items.push(input.items[i]);                  if (input.objects)                 {                     for (let i = input.objects.length-1; i >= 0; i--)                         this.value.objects.push(input.objects[i]);                 }             }             else                 this.value = input.copy();         }         else             this.value = u2020.NaN.copy();               this.g4215();           this.l4100(parse,          [             ['type',   this.outputListType()                   ],             ['length', new z2021(this.value.items.length)]         ]);                           if (parse.settings.l3733)         {             this.l4100(parse,             [                 ['preview', new u2020(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     } } 


class GBuckleList extends u2043 {     amount;        constructor(nodeId, options)     {         super(j1351, nodeId, options);     }            reset()     {         super.reset();          this.buckle = null;     }        copy()     {         const copy = new GBuckleList(this.nodeId, this.options);          copy.o3358(this);          if (this.amount) copy.amount = this.amount.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalListValue  (this.input,  parse);         const amount = await evalNumberValue(this.amount, parse);          amount.value = Math.round(amount.value);                           if (   input             && input.isValid())         {             const _amount = Math.min(amount.value + 1, Math.floor(input.items.length/2));              if (this.options.enabled)             {                 const temp1 =                  [                     ...input.items.slice(input.items.length - _amount).map(i => i.value),                     ...input.items.slice(0, _amount)                  .map(i => i.value).map(i => i - input.items[0].value + input.items.at(-1).value)                 ];                  const temp2 =                  [                     ...input.items.slice(input.items.length - _amount).map(i => i.value).map(i => i - input.items.at(-1).value + input.items[0].value),                     ...input.items.slice(0, _amount)                  .map(i => i.value)                 ];                  c952(                     temp1.length == temp2.length,                     'error building list edge blend');                                   const temp = [];                  for (let i = 0; i < _amount*2; i++)                     temp.push(new z2021(r1035(temp1[i], temp2[i], i/(_amount*2-1))));                   this.value = new u2020();                  for (let i = 0; i < _amount; i++)                     this.value.items.push(temp[_amount + i]);                  for (let i = _amount; i < input.items.length - _amount; i++)                     this.value.items.push(input.items[i]);                  for (let i = 0; i < _amount; i++)                     this.value.items.push(temp[i]);             }             else                 this.value = input;         }         else             this.value = u2020.NaN.copy();               this.l4100(parse,          [             ['length', new z2021(this.value.items.length)],             ['amount', amount                                  ]         ]);                           if (parse.settings.l3733)         {             this.l4100(parse,             [                 ['preview', new u2020(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     } } 


class t1874 extends u2043 {     condition     = null;     reverse       = null;     indices       = null;      u4212 = null;                   constructor(nodeId, options)     {         super(l1077, nodeId, options);     }            reset()     {         super.reset();          this.condition = null;         this.reverse   = null;         this.indices   = null;     }        copy()     {         const copy = new t1874(this.nodeId, this.options);          copy.o3358(this);          if (this.condition) copy.condition = this.condition.copy();         if (this.reverse  ) copy.reverse   = this.reverse  .copy();         if (this.indices  ) copy.indices   = this.indices  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input   = await evalListValue  (this.input,   parse);         const reverse = await evalNumberValue(this.reverse, parse);           this.value         = new u2020();         this.value.objects = [];           let maxColumns = 0;          this.indices = new u2020();           if (   input             && reverse)         {             if (this.options.enabled)             {                 if (  !this.condition                     || this.condition.y3767)                 {                     if (this.condition)                         await this.condition.eval(parse);                      const conditionNode =                          this.condition                         ? this.condition.y3767(parse)                         : null;                       if (  !this.condition                         || conditionNode)                     {                         const e4213 = reverse.value > 0 ? -1 : 1;                         const t4214          = [...input.items];                           [ input       .items,                            this.indices.items ] = await asyncSort(                             parse,                              t4214,                              this.condition                              ? conditionNode                              : null,                                      this,                             this.condition,                              e4213);                           input.items.forEach(i => maxColumns = Math.max(maxColumns, o957(i.type) ? i.items.length : 1));                                                   for (let i = 0; i < input.items.length; i++)                         {                             const row       = input   .items[i];                             const y3819 = t4214.indexOf(row);                              this.value.items.push(row.copy());                              if (   row.objects                                 && this.value.objects)                             {                                 const objects = input.objects.filter(o => o.y3819 == y3819).map(o => o.copy());                                 objects.forEach(o => o.y3819 = i);                                  this.value.objects.push(...objects);                             }                         }                     }                 }                 else                 {                     this.value   = input;                     this.indices = new u2020(Array.from(Array(input.items.length).keys()).map(i => new z2021(i)));                 }             }             else             {                 this.value   = input;                 this.indices = new u2020(Array.from(Array(input.items.length).keys()).map(i => new z2021(i)));             }         }         else         {             this.value   = new u2020();             this.indices = new u2020();         }           this.g4215();           this.l4100(parse,         [             ['type',    this.outputListType()                   ],             ['length',  new z2021(this.value.items.length)],             ['reverse', reverse                                 ],             ['indices', this.indices                            ]         ]);                   if (parse.settings.l3733)         {             this.l4100(parse,             [                 ['preview', new u2020(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && (!this.condition || this.condition.isValid())             && this.reverse && this.reverse.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.condition) this.condition.g4087(parse);         if (this.reverse  ) this.reverse  .g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.condition) this.condition.e4088(parse, from, force);         if (this.reverse  ) this.reverse  .e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.condition) this.condition.q4086(parse);         if (this.reverse  ) this.reverse  .q4086(parse);     } }    async function asyncSort(parse, t4214, conditionNode, node, condition, e4213) {     const y3568 = conditionNode ? conditionNode.input : null;       const sorted  = [];       for (let i = 0; i < t4214.length; i++)     {         const item = t4214[i];          const cond = await getSortCondition(parse, conditionNode, node, condition, item);         if (!cond) return [t4214, [...t4214.keys()]];                  const condValue = cond.q3632();                   if (   condValue.type != m1091             && condValue.type != i1143)              return [t4214, [...t4214.keys()]];          sorted.push({item, condition: condValue.value, index: i});     }       sorted.sort((a, b) =>     {         if (   typeof(a.condition) == 'number'             && typeof(b.condition) == 'number')         {             if (a.condition < b.condition) return -1*e4213;             if (a.condition > b.condition) return  1*e4213;         }         else if (typeof(a.condition) == 'string'               && typeof(b.condition) == 'string')         {             if (a.condition.localeCompare(b.condition) < 0) return -1*e4213;             if (a.condition.localeCompare(b.condition) > 0) return  1*e4213;         }          return 0;     });       if (conditionNode)         conditionNode.input = y3568;       return [ sorted.map(item => item.item),               sorted.map(item => new z2021(item.index)) ]; }    async function getSortCondition(parse, conditionNode, node, condition, item) {     if (!conditionNode)         return item;          conditionNode.reset();      conditionNode.input = item.copy();     condition.e4088(parse, node, true);       return await condition.eval(parse); }


class s1860 extends u2043 {     condition = null;     indices   = null;                  constructor(nodeId, options)     {         super(s1085, nodeId, options);     }            reset()     {         super.reset();          this.condition = null;         this.indices   = null;     }        copy()     {         const copy = new s1860(this.nodeId, this.options);          copy.o3358(this);          if (this.condition) copy.condition = this.condition.copy();         if (this.indices  ) copy.indices   = this.indices  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalListValue(this.input, parse);           this.value         = new u2020();         this.value.objects = [];          let maxColumns = 0;                   this.indices = new u2020();           if (input)         {             if (this.options.enabled)             {                 if (  !this.condition                     || this.condition.y3767)                 {                     if (this.condition)                         await this.condition.eval(parse);                      const conditionNode =                          this.condition                         ? this.condition.y3767(parse)                         : null;                       if (  !this.condition                         || conditionNode)                     {                         const unfiltered = [...input.items];                           [input.items, this.indices.items] = await asyncFilter(                             parse,                              unfiltered,                              conditionNode,                             this,                             this.condition);                           input.items.forEach(i => maxColumns = Math.max(maxColumns, o957(i.type) ? i.items.length : 1));                                                   for (let i = 0; i < input.items.length; i++)                         {                             const row       = input   .items[i];                             const y3819 = unfiltered.indexOf(row);                              this.value.items.push(row.copy());                              if (   row.objects                                 && this.value.objects)                             {                                 const objects = input.objects.filter(o => o.y3819 == y3819).map(o => o.copy());                                 objects.forEach(o => o.y3819 = i);                                  this.value.objects.push(...objects);                             }                         }                     }                 }                 else                     this.value = await evalListValue(this.input, parse);             }             else                 this.value = input.copy();         }         else             this.value = new u2020();           this.g4215();           this.l4100(parse,         [             ['type',    this.outputListType()                   ],             ['length',  new z2021(this.value.items.length)],             ['indices', this.indices                            ]         ]);                   if (parse.settings.l3733)         {             this.l4100(parse,             [                 ['preview', new u2020(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && (!this.condition || this.condition.isValid());     }        g4087(parse)     {         super.g4087(parse);          if (this.condition) this.condition.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.condition) this.condition.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.condition) this.condition.q4086(parse);     } }    async function asyncFilter(parse, array, conditionNode, node, condition) {     const y3568 = conditionNode ? conditionNode.input : null;      const filtered = [];     const indices  = [];      for (let i = 0; i < array.length; i++)     {         const item = array[i];          const cond = await getFilterCondition(parse, conditionNode, node, condition, item);         if (!cond) return array;                  const condValue = cond.q3632();                   if (   condValue.type == m1091             && condValue.value > 0)         {             filtered.push(item);             indices .push(new z2021(i));         }     }      if (conditionNode)         conditionNode.input = y3568;      return [filtered, indices]; }    async function getFilterCondition(parse, conditionNode, node, condition, item) {     if (!conditionNode)         return item;          conditionNode.reset();      const value = conditionNode.q3632();     if (!value) return item;      if (   value.type == item.type         || value.type == j1087)     {         conditionNode.input = item.copy();         condition.e4088(parse, node, true);      }      return await condition.eval(parse); }


class e1855 extends u2043 {     index       = null;                  constructor(nodeId, options)     {         super(y1078, nodeId, options);     }            reset()     {         super.reset();          this.index       = null;               }        copy()     {         const copy = new e1855(this.nodeId, this.options);          copy.o3358(this);          if (this.index) copy.index = this.index.copy();          return copy;     }        async eval(parse)     {         if (   this.isCached())                          return this;           const input = await evalListValue  (this.input, parse);         const index = await evalNumberValue(this.index, parse);                   this.value = new u2020();          let maxColumns = 0;                                                    if (   input                 && index)             {                 if (isTable(input))                 {                     input.items.forEach(i => maxColumns = Math.max(maxColumns, i.items.length));                      if (index.value < maxColumns)                     {                         const valueIds = [];                          for (let i = 0; i < input.items.length; i++)                         {                             const row = input.items[i];                              if (index.value < row.items.length)                             {                                 const item = row.items[index.value].copy();                                  item.valueId = h1482(                                     item.valueId,                                      id => valueIds.includes(id),                                     item.valueId,                                     '',                                     1,                                     true);                                                                 this.value.items.push(item);                                  e949(valueIds, item.valueId);                                  if (   this.value.objects                                      && row.items[index.value].objects)                                     this.value.objects.push(...row.items[index.value].objects);                             }                         }                     }                 }                 else if (o957(input.type))                 {                     this.value = input.copy();                     maxColumns = 1;                 }             }                               this.g4215();          this.l4100(parse,         [             ['type',    this.outputListType()                   ],             ['length',  new z2021(this.value.items.length)],             ['columns', new z2021(maxColumns, 0)          ],             ['index',   index                                   ]         ]);               if (parse.settings.l3733)         {             this.l4100(parse,             [                 ['preview', new u2020(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.index && this.index.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.index) this.index.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.index) this.index.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.index) this.index.q4086(parse);     } }    function isTable(value) {     if (!o957(value.type))         return false;      for (const item of value.items)     {         if (!o957(item.type))             return false;     }      return true; }


class s1854 extends u2043 {     column;     row;            constructor(nodeId, options)     {         super(v1079, nodeId, options);     }            reset()     {         super.reset();          this.column = null;         this.row    = null;     }        copy()     {         const copy = new s1854(this.nodeId, this.options);          copy.o3358(this);          if (this.column) copy.column = this.column.copy();         if (this.row   ) copy.row    = this.row   .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalListValue  (this.input,  parse);         const column = await evalNumberValue(this.column, parse);         const row    = await evalNumberValue(this.row,    parse);           let columns = 0;         let rows    = 0;          if (   input             && column             && row)         {             if (isTable(input))             {                 rows = input.items.length;                  input.items.forEach(i => columns = Math.max(columns, i.items ? i.items.length : null));                  if (row.value < rows)                 {                     const _row = input.items[row.value];                      if (column.value < columns)                         this.value = _row.items[column.value].copy();                     else                         this.value = new x4216();                 }                 else                     this.value = new x4216();             }             else                 this.value = new x4216();         }         else             this.value = new x4216();           this.l4100(parse,         [                          ['type',    this.outputType()          ],             ['columns', new z2021(columns, 0)],             ['rows',    new z2021(rows   , 0)]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.column && this.column.isValid()             && this.row    && this.row   .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.column) this.column.g4087(parse);         if (this.row   ) this.row   .g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.column) this.column.e4088(parse, from, force);         if (this.row   ) this.row   .e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.column) this.column.q4086(parse);         if (this.row   ) this.row   .q4086(parse);     } }


class m1863 extends u2043 {     a4211 = null;        constructor(nodeId, options)     {         super(k1080, nodeId, options);     }        reset()     {         super.reset();          this.a4211 = null;     }        copy()     {         const copy = new m1863(this.nodeId, this.options);                  copy.o3358(this);          if (this.input) copy.input = this.input.copy();                  for (const key of this.keys())         {             if (this[key] instanceof d2049)                 Object.assign(copy, {[key]: this[key]});         }          return copy;     }        u4241(v2991)     {         let param =                this.value             && this.value.items             && v2991 != 'value'             ? this.value.items.find(i => i.valueId == v2991)             : null;          if (!param)             param = this[v2991];          return param;     }        async eval(parse)     {         if (   this.isCached()             && this.a4211)             return this;           const input = await evalListValue(this.input, parse);            if (this.a4211)            this.value = this.a4211.copy();          else         {             this.value = input ?? new x4216();             this.a4211 = this.value.copy();         }           this.c3095 = [];           if (    this.value.isValid()             &&  this.value.items             && !isEmpty(this.value.items))         {             for (let i = 0; i < this.value.items.length; i++)             {                 const item = this.value.items[i];                                  let valueId =                      item.valueId.trim() != ''                     ? item.valueId                     : i.toString();                  valueId = h1482(                     valueId,                     id => this.value.items.find(i =>                            i != item                          && i.valueId == id));                  Object.assign(this, {[valueId]: item});                 this.l4100(parse, [[valueId, item]], true);                  item.sortId = i;             }              this.c3095.sort((a, b) => a.sortId - b.sortId);               this.l4100(parse, [['-type-', this.outputType()]], true);         }         else             this.l4100(parse, [['-type-', new b2032(z1056)]], true);           this.g4215();           this.validate();          return this;     }                q3632()     {         return this.value.copy();     }        iterateCache(parse, from)     {         this.a4211 = null;     } }


class g1870 extends z2042 {     inputs = [];      index = null;            constructor(nodeId, options)     {         super(p1083, nodeId, options);     }        reset()     {         super.reset();          this.inputs = [];                  this.index = null;     }           copy()     {         const copy = new g1870(this.nodeId, this.options);          copy.o3358(this);                  copy.inputs = this.inputs.map(i => i.copy());          if (this.index) copy.index = this.index.copy();         if (this.value) copy.value = this.value.copy();          return copy;     }        isCached()     {         for (const input of this.inputs)             if (!input.isCached())                 return false;          return super.isCached();     }        async eval(parse)     {         if (this.isCached())             return this;          let index  = await evalNumberValue(this.index, parse);         let length = 0;           const inputs = [];          for (let i = 0; i < this.inputs.length; i++)             inputs.push(await evalValue(this.inputs[i], parse));           if (inputs.length > 0)         {             length = inputs.length;               index =                     index.isValid()                 && index.value >= -inputs.length                 && index.value <   inputs.length                 ? new z2021(Math.round(index.value))                 : new z2021(0);                           if (   index.isValid()                 && index.value >= -inputs.length                 && index.value <   inputs.length)             {                 this.value = inputs.at(index.value);                                   if (this.value.objects)                 {                     for (let i = 0; i < this.value.objects.length; i++)                     {                         const g111 = this.value.objects[i];                          g111.nodeId = this.nodeId;                         g111.listId = -1;                          g111.objectId = this.nodeId;                                                  if (g111.objectId != NULL)                              g111.objectId += '/';                          g111.objectId += index.value.toString();                          if (this.value.objects.length > 1)                         {                             g111.objectId += '/';                             g111.objectId += i.toString();                         }                     }                 }             }             else             {                 this.value = new x4216();             }         }         else         {             this.value = new x4216();         }                   const type = this.outputType();          this.l4100(parse,         [             ['value',      type == a1168                          || type == a1178                          ? this.value                          : new x4216()      ],             ['type',    type                   ],             ['length',  new z2021(length)],             ['index',   index                  ]         ]);           if (type.value == i1143 && parse.settings.z3732)         {             this.l4100(parse,             [                 ['preview', this.value]             ],             true);         }         else if (o957(type.value) && parse.settings.l3733)         {             this.l4100(parse,             [                 ['preview', new u2020(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return !this.inputs.find(i => !i.isValid())             &&  this.index && this.index.isValid();     }        g4087(parse)     {         super.g4087(parse);          this.inputs.forEach(i => i.g4087(parse));          if (this.index) this.index.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          this.inputs.forEach(i => i.e4088(parse, from, force));          if (this.index) this.index.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          this.inputs.forEach(i => i.q4086(parse));          if (this.index) this.index.q4086(parse);     } }


class u1871 extends u2043 {     index = null;        constructor(nodeId, options)     {         super(f1360, nodeId, options);     }        reset()     {         super.reset();          this.index = null;     }        copy()     {         const copy = new u1871(this.nodeId, this.options);                  copy.o3358(this);          if (this.input) copy.input = this.input.copy();         if (this.index) copy.index = this.index.copy();         if (this.value) copy.value = this.value.copy();          return copy;     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;                   const input = await evalListValue  (this.input, parse);         let   index = await evalNumberValue(this.index, parse);                  let  length = 0;                                    if (   input             && input.isValid()             && o957(input.type)             && input.items             && input.items.length > 0)         {             length = input.items.length;               index =                     index.isValid()                 && index.value >= -input.items.length                 && index.value <   input.items.length                 ? new z2021(Math.round(index.value))                 : new z2021(0);                           if (   index.isValid()                 && index.value >= -input.items.length                 && index.value <   input.items.length)             {                 this.value = input.items.at(index.value);                                  if (   input.objects                     && input.objects.at(index.value))                     this.value.objects = [input.objects.at(index.value)];                   if (this.value.objects)                 {                     for (let i = 0; i < this.value.objects.length; i++)                     {                         const g111 = this.value.objects[i];                          g111.nodeId = this.nodeId;                         g111.listId = -1;                          g111.objectId = this.nodeId;                                                  if (g111.objectId != NULL)                             g111.objectId += '/';                          g111.objectId += index.value.toString();                     }                 }             }             else             {                 this.value = new x4216();             }         }         else          {             this.value = new x4216();         }                     const type = this.outputType();          this.l4100(parse,         [             ['value',      type == a1168                          || type == a1178                          ? this.value                          : new x4216()],             ['type',    type                   ],             ['length',  new z2021(length)],             ['index',   index                  ]         ]);           if (type.value == i1143 && parse.settings.z3732)         {             this.l4100(parse,             [                 ['preview', this.value]             ],             true);         }         else if (o957(type.value) && parse.settings.l3733)         {             this.l4100(parse,             [                 ['preview', new u2020(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.index && this.index.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.index) this.index.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.index) this.index.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.index) this.index.q4086(parse);     } }


class k1864 extends u2043 {     start = null;        constructor(nodeId, options)     {         super(n1081, nodeId, options);     }        reset()     {         super.reset();          this.start = null;     }        copy()     {         const copy = new k1864(this.nodeId, this.options);                  copy.o3358(this);          if (this.input) copy.input = this.input.copy();         if (this.start) copy.start = this.start.copy();                  if (this.count) copy.count = this.count.copy();          return copy;     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalListValue  (this.input, parse);         const start = await evalNumberValue(this.start, parse);                   if (input)         {             const count = input.items.length;             this.value = new z2021(count - (start.value == 0 ? 1 : 0));         }         else             this.value = z2021.NaN.copy();           this.l4100(parse,         [             ['value', this.value],             ['start', start     ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.start && this.start.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.start) this.start.g4087(parse);     }            e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.start) this.start.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.start) this.start.q4086(parse);     }     }


class GObjectCount extends u2043 {     start = null;        constructor(nodeId, options)     {         super(n1081, nodeId, options);     }        reset()     {         super.reset();          this.start = null;     }        copy()     {         const copy = new k1864(this.nodeId, this.options);                  copy.o3358(this);          if (this.input) copy.input = this.input.copy();         if (this.start) copy.start = this.start.copy();                  if (this.count) copy.count = this.count.copy();          return copy;     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalValue      (this.input, parse);         const start = await evalNumberValue(this.start, parse);                   if (input)         {             const count =                  input.objects                 ? input.objects.length                 : 0;              this.value = new z2021(count - (start.value == 0 ? 1 : 0));         }         else             this.value = z2021.NaN.copy();           this.l4100(parse,         [             ['value', this.value],             ['start', start     ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.start && this.start.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.start) this.start.g4087(parse);     }            e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.start) this.start.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.start) this.start.q4086(parse);     }     }


class y1858 extends z2044 {     first;     last;     all;        constructor(nodeId, options)     {         super(x1082, nodeId, options);     }            reset()     {         super.reset();          this.first = null;         this.last  = null;         this.all   = null;     }        copy()     {         const copy = new y1858(this.nodeId, this.options);          copy.o3358(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const z4082 = await evalListValue(this.z4082, parse);         const z4083 = await evalValue    (this.z4083, parse);               if (   z4082 && z4082.isValid()              && z4083 && z4083.isValid())         {             const indices = [];                           if (   z4083                 && z4083.isValid())             {                 for (let i = 0; i < z4082.items.length; i++)                 {                     if (z4082.items[i].equals(z4083))                         indices.push(i);                 }                     this.value = new z2021(indices.length > 0 ? 1 : 0);                  this.first = indices.length > 0 ? new z2021(indices.at( 0)) : z2021.NaN.copy();                 this.last  = indices.length > 0 ? new z2021(indices.at(-1)) : z2021.NaN.copy();                  this.all   = new u2020();                  for (const index of indices)                     this.all.items.push(new z2021(index));             }             else             {                 this.value = new z2021(1);                  this.first = z2021.NaN.copy();                 this.last  = z2021.NaN.copy();                 this.all   =   u2020.NaN.copy();             }         }         else                           {             this.value = z2021.NaN.copy();             this.first = z2021.NaN.copy();             this.last  = z2021.NaN.copy();             this.all   =   u2020.NaN.copy();         }               this.l4100(parse,         [             ['value', this.value],             ['first', this.first],             ['last',  this.last ],             ['all',   this.all  ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.first && this.first.isValid()             && this.last  && this.last .isValid()             && this.all   && this.all  .isValid();     } }


class q1862 extends z2042 {     z4082    = null;     z4083    = null;      condition = null;        constructor(nodeId, options)     {         super(z1084, nodeId, options);     }            reset()     {         super.reset();          this.z4082    = null;         this.z4083    = null;          this.condition = null;     }        copy()     {         const copy = new q1862(this.nodeId, this.options);          copy.o3358(this);          if (this.z4082   ) copy.z4082    = this.z4082   .copy();         if (this.z4083   ) copy.z4083    = this.z4083   .copy();          if (this.condition) copy.condition = this.condition.copy();          if (this.value    ) copy.value     = this.value    .copy();          return copy;     }        isCached()     {         return super.isCached()             && (!this.z4082 || this.z4082.isCached())             && (!this.z4083 || this.z4083.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;                   const z4082 = await evalValue(this.z4082, parse);         const z4083 = await evalValue(this.z4083, parse);                  const cond   = await evalNumberValue(this.condition, parse);             if (   z4082                && z4083) this.value = cond.value != 0 ? z4082 : z4083;         else if (z4082) this.value = cond.value != 0 ? z4082 : new x4216();         else if (z4083) this.value = cond.value == 0 ? z4083 : new x4216();         else             this.value = new x4216();           this.g4215();           this.l4100(parse,         [             ['type',      this.outputType()],             ['condition', cond             ]         ]);                           this.validate();          return this;     }        q3632()     {         return this.value              ? this.value.copy()               : null;     }        isValid()     {         return this.z4082    && this.z4082   .isValid()             && this.z4083    && this.z4083   .isValid()             && this.condition && this.condition.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.z4082   ) this.z4082   .g4087(parse);         if (this.z4083   ) this.z4083   .g4087(parse);         if (this.condition) this.condition.g4087(parse);     }            e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.z4082   ) this.z4082   .e4088(parse, from, force);         if (this.z4083   ) this.z4083   .e4088(parse, from, force);         if (this.condition) this.condition.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.z4082   ) this.z4082   .q4086(parse);         if (this.z4083   ) this.z4083   .q4086(parse);         if (this.condition) this.condition.q4086(parse);     }     } 


class s1898 extends z2042 {     inputs = [];        reset()     {         super.reset();          this.inputs = [];     }        y3767()     {         const conditionNodes = [];          for (const input of this.inputs)         {             const conditionNode = input.y3767();             if (conditionNode) conditionNodes.push(conditionNode);                     }          console.assert(conditionNodes.length < 2, 'Error: sort order requires not more than one order node');          return conditionNodes.length == 1              ? conditionNodes[0]              : null;     }        isCached()     {         for (const input of this.inputs)             if (!input.isCached())                 return false;          return super.isCached();     }        isValid()     {         return  this.inputs.length > 0             && !this.inputs.find(i => !i.isValid());     }        g4087(parse)     {         super.g4087(parse);          this.inputs.forEach(i => i.g4087(parse));     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          this.inputs.forEach(i => i.e4088(parse, from, force));     }        q4086(parse)     {         super.q4086(parse);          this.inputs.forEach(i => i.q4086(parse));     } } 


class y1935 extends u2043 {     constructor(nodeId, options)     {         super(s1092, nodeId, options);     }        copy()     {         const copy = new y1935(this.nodeId, this.options);                  copy.o3358(this);          copy.value = this.value;          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalNumberValue(this.input, parse);           if (input)             this.value = input;         else if (this.value)             await this.value.eval(parse);         else             this.value = z2021.NaN.copy();           this.l4100(parse,          [             ['value', this.value]         ]);           this.validate();          return this;     }        isValid()     {         return !this.input               || this.input.isValid();     } }


class GSetPrecision extends u2043 {     decimals;        constructor(nodeId, options)     {         super(b1355, nodeId, options);     }            reset()     {         super.reset();          this.decimals = null;     }        copy()     {         const copy = new GSetPrecision(this.nodeId, this.options);          copy.o3358(this);          if (this.decimals) copy.decimals = this.decimals.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new z2021(0);                   const input    = await evalNumberValue(this.input,    parse);         const decimals = await evalNumberValue(this.decimals, parse);           if (input)         {             if (this.options.enabled)             {                 if (o957(input.type))                 {                     this.value = new u2020();                      for (let i = 0; i < input.items.length; i++)                     {                         const item = input.items[i];                          this.value.items.push(                             item.type == m1091                             ? getSetPrecisionValue(item, decimals)                             : z2021.NaN.copy());                        }                 }                 else                     this.value = getSetPrecisionValue(input, decimals);             }             else                 this.value = input;         }         else             this.value = z2021.NaN.copy();           this.l4100(parse,         [             ['type',     this.outputType()],             ['value',    this.value       ],             ['decimals', decimals         ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.decimals && this.decimals.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.decimals) this.decimals.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.decimals) this.decimals.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.decimals) this.decimals.q4086(parse);     } }    function getSetPrecisionValue(input, decimals) {     c952(          input == m1091,          'input must be NUMBER_VALUE');      return new z2021(input.value, decimals.value); }


class e1942 extends u2043 {     constructor(nodeId, options)     {         super(l1093, nodeId, options);     }            copy()     {         const copy = new e1942(this.nodeId, this.options);          copy.o3358(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalNumberValue(this.input, parse);           if (input)         {             if (o957(input.type))             {                 this.value = new u2020();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == m1091                         ? getSignValue(item)                         : z2021.NaN.copy());                    }             }             else                 this.value = getSignValue(input); }         else             this.value = z2021.NaN.copy();           this.l4100(parse,          [             ['type', this.outputType()]         ]);           this.validate();          return this;     } }    function getSignValue(input) {     c952(          input.type == m1091,          'input.type must be NUMBER_VALUE');      return new z2021(Math.sign(input.value)); }


class o1923 extends u2043 {     constructor(nodeId, options)     {         super(v1094, nodeId, options);     }            copy()     {         const copy = new o1923(this.nodeId, this.options);          copy.o3358(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalNumberValue(this.input, parse);           if (input)         {             if (o957(input.type))             {                 this.value = new u2020();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == m1091                         ? getAbsoluteValue(item, this.options.enabled)                         : z2021.NaN.copy());                    }             }             else                 this.value = getAbsoluteValue(input, this.options.enabled);         }         else             this.value = z2021.NaN.copy();           this.l4100(parse,          [             ['type', this.outputType()]         ]);           this.validate();          return this;     } }    function getAbsoluteValue(input, enabled) {     c952(          input.type == m1091,          'input.type must be NUMBER_VALUE');      return enabled         ? new z2021(Math.abs(input.value), input.decimals)         : input; }


class GNegative extends u2043 {     constructor(nodeId, options)     {         super(i1356, nodeId, options);     }            copy()     {         const copy = new GNegative(this.nodeId, this.options);          copy.o3358(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalNumberValue(this.input, parse);                       if (input)         {             if (o957(input.type))             {                 this.value = new u2020();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == m1091                         ? getNegativeValue(item, this.options.enabled)                         : z2021.NaN.copy());                    }             }             else                 this.value = getNegativeValue(input, this.options.enabled);         }         else             this.value = z2021.NaN.copy();           this.l4100(parse,          [             ['type', this.outputType()]         ]);           this.validate();          return this;     } }    function getNegativeValue(input, enabled) {     c952(          input == m1091,          'input must be NUMBER_VALUE');      return new z2021(         (enabled ? -1 : 1) * input.value,         input.decimals); }


class n1940 extends u2043 {     type;     decimals;        constructor(nodeId, options)     {         super(t1095, nodeId, options);     }            reset()     {         super.reset();          this.type     = null;         this.decimals = null;     }        copy()     {         const copy = new n1940(this.nodeId, this.options);          copy.o3358(this);          if (this.type    ) copy.type     = this.type    .copy();         if (this.decimals) copy.decimals = this.decimals.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new z2021(0);                   const input = await evalNumberValue(this.input,    parse);         const type  = await evalNumberValue(this.type,     parse);         const dec   = await evalNumberValue(this.decimals, parse);           if (   input             && type             && dec)         {             if (o957(input.type))             {                 this.value = new u2020();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == m1091                         ? getRoundValue(item, type, dec, this.options.enabled)                         : z2021.NaN.copy());                    }             }             else                 this.value = getRoundValue(input, type, dec, this.options.enabled); }         else             this.value = z2021.NaN.copy();           this.l4100(parse,         [             ['_type',    this.outputType()],             ['type',     type             ],             ['decimals', dec              ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.type     && this.type    .isValid()             && this.decimals && this.decimals.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.type    ) this.type    .g4087(parse);         if (this.decimals) this.decimals.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.type    ) this.type    .e4088(parse, from, force);         if (this.decimals) this.decimals.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.type    ) this.type    .q4086(parse);         if (this.decimals) this.decimals.q4086(parse);     } }    function getRoundValue(input, type, dec, enabled) {     c952(         input.type == m1091,         'input.type must be NUMBER_VALUE');       if (!enabled)         return input;      switch (type.value)     {         case 0: return new z2021(l1015(input.value, dec.value), dec.value);         case 1: return new z2021(i1016(input.value, dec.value), dec.value);         case 2: return new z2021( k1017(input.value, dec.value), dec.value);     } }


class GQuantize extends u2043 {     type;     base;     step;     amount;        constructor(nodeId, options)     {         super(n1357, nodeId, options);     }            reset()     {         super.reset();          this.type   = null;         this.base   = null;         this.step   = null;         this.amount = null;     }        copy()     {         const copy = new GQuantize(this.nodeId, this.options);          copy.o3358(this);          if (this.type  ) copy.type   = this.type  .copy();         if (this.base  ) copy.base   = this.base  .copy();         if (this.step  ) copy.step   = this.step  .copy();         if (this.amount) copy.amount = this.amount.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new z2021(0);                   const input  = await evalNumberValue(this.input,  parse);         const type   = await evalNumberValue(this.type,   parse);         const base   = await evalNumberValue(this.base,   parse);         const step   = await evalNumberValue(this.step,   parse);         const amount = await evalNumberValue(this.amount, parse);           if (input)         {             if (o957(input.type))             {                 this.value = new u2020();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == m1091                         ? getQuantizeValue(item, type, base, step, amount, this.options.enabled)                         : z2021.NaN.copy());                    }             }             else                 this.value = getQuantizeValue(input, type, base, step, amount, this.options.enabled); }         else             this.value = z2021.NaN.copy();           this.l4100(parse,         [             ['_type',  this.outputType()],             ['type',   type             ],             ['base',   base             ],             ['step',   step             ],             ['amount', amount           ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.type   && this.type  .isValid()             && this.base   && this.base  .isValid()             && this.step   && this.step  .isValid()             && this.amount && this.amount.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.type  ) this.type  .g4087(parse);         if (this.base  ) this.base  .g4087(parse);         if (this.step  ) this.step  .g4087(parse);         if (this.amount) this.amount.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.type  ) this.type  .e4088(parse, from, force);         if (this.base  ) this.base  .e4088(parse, from, force);         if (this.step  ) this.step  .e4088(parse, from, force);         if (this.amount) this.amount.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.type  ) this.type  .q4086(parse);         if (this.base  ) this.base  .q4086(parse);         if (this.step  ) this.step  .q4086(parse);         if (this.amount) this.amount.q4086(parse);     } }    function getQuantizeValue(input, type, base, step, amount, enabled) {     c952(          input.type == m1091,          'input.type must be NUMBER_VALUE');           if (!enabled)         return input;       let qval;      switch (type.value)     {         case 0: qval = base.value + step.value * Math.floor((input.value - base.value) / step.value); break;         case 1: qval = base.value + step.value * Math.round((input.value - base.value) / step.value); break;         case 2: qval = base.value + step.value * Math. ceil((input.value - base.value) / step.value); break;     }      return new z2021(         input.value + (qval - input.value) * amount.value/100,         Math.max(base.decimals, step.decimals)); }


class j1943 extends u2043 {     operand;     operation;        constructor(nodeId, options)     {         super(m1096, nodeId, options);     }            reset()     {         super.reset();          this.operand   = null;         this.operation = null;     }        copy()     {         const copy = new n1940(this.nodeId, this.options);          copy.o3358(this);          if (this.operand  ) copy.operand   = this.operand  .copy();         if (this.operation) copy.operation = this.operation.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new z2021(0);                   const input   = await evalNumberValue(this.input,     parse);         const operand = await evalNumberValue(this.operand,   parse);         const op      = await evalNumberValue(this.operation, parse);           if (input)         {             if (this.options.enabled)             {                 if (o957(input.type))                 {                     this.value = new u2020();                      for (let i = 0; i < input.items.length; i++)                     {                         const item = input.items[i];                          this.value.items.push(                             item.type == m1091                             ? getSimpleMinMaxValue(item, operand, op, this.options.enabled)                             : z2021.NaN.copy());                        }                 }                 else                 {                     this.value = getSimpleMinMaxValue(input, operand, op, this.options.enabled);                 }             }             else                 this.value = input.copy();         }         else             this.value = z2021.NaN.copy();           this.l4100(parse,         [                          ['type',      this.outputType()],             ['operand',   operand          ],             ['operation', op               ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.operand   && this.operation.isValid()             && this.operation && this.operand  .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.operand  ) this.operand  .g4087(parse);         if (this.operation) this.operation.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.operand  ) this.operand  .e4088(parse, from, force);         if (this.operation) this.operation.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.operand  ) this.operand  .q4086(parse);         if (this.operation) this.operation.q4086(parse);     } }    function getSimpleMinMaxValue(input, operand, op, enabled) {     c952(         input.type == m1091,          'input.type is ' + input.type + ', must be NUMBER_VALUE');       if (enabled)     {         op.value = Math.min(Math.max(0, Math.floor(op.value)), 1);          return new z2021(op.value == 0             ? Math.min(input.value, operand.f3702())             : Math.max(input.value, operand.f3702()));     }     else         return input; }


class p1932 extends s1898 {     operation;        constructor(nodeId, options)     {         super(u1097, nodeId, options);     }            reset()     {         super.reset();          this.operation = null;     }        copy()     {         const copy = new p1932(this.nodeId, this.options);          copy.o3358(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.operation) copy.operation = this.operation.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           let op = await evalNumberValue(this.operation, parse);          if (op) op = op.c3728();           if (this.options.enabled)             op.value = Math.min(Math.max(0, op.value), r1311.length-1);                   this.value = await evalMinMaxInputs(this.inputs, op.value, parse);                   this.l4100(parse,         [             ['operation', op        ]                      ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.operation && this.operation.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.operation) this.operation.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.operation) this.operation.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.operation) this.operation.q4086(parse);     } }    async function evalMinMaxInputs(inputs, op, parse) {     if (isEmpty(inputs))         return z2021.NaN.copy();       let value = new z2021(0);       const x3689 = await evalNumberValue(inputs[0], parse);       if (   inputs.length == 1         && x3689.type == m1091)     {         value = new z2021(-x3689.value);     }     else if (o957(x3689.type)             && !isEmpty(x3689.items))     {         value = x3689.items[0].copy();                  for (let i = 1; i < x3689.items.length; i++)         {             const item = x3689.items[i];              if (item.type == m1091)             {                 value = new z2021(                      op == 0                     ? Math.min(value.value, item.value)                     : Math.max(value.value, item.value));             }                             }     }     else     {         if (x3689.type != m1091)             return z2021.NaN.copy();          value = x3689;     }       for (let i = 1; i < inputs.length; i++)     {         const val = await evalNumberValue(inputs[i], parse);           if (o957(val.type))         {             for (const item of val.items)             {                 if (item.type == m1091)                 {                     value = new z2021(                         op == 0                         ? Math.min(value.value, item.value)                         : Math.max(value.value, item.value));                                       }                                 }         }         else         {             c952(                 val.type == m1091,                  'val.type must be NUMBER_VALUE');                              value = new z2021(                 op == 0                 ? Math.min(value.value, val.value)                 : Math.max(value.value, val.value));                       }     }       return value; }


class x1931 extends u2043 {     min = null;     max = null;            constructor(nodeId, options)     {         super(d1098, nodeId, options);     }            reset()     {         super.reset();          this.min = null;         this.max = null;     }        copy()     {         const copy = new x1931(this.nodeId, this.options);          copy.o3358(this);          if (this.min) copy.min = this.min.copy();         if (this.max) copy.max = this.max.copy();          return copy;     }        isCached()     {         return super.isCached()             && (!this.min || this.min.isCached())             && (!this.max || this.max.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;                       const input = await evalNumberValue(this.input, parse);         const min   = await evalNumberValue(this.min,   parse);         const max   = await evalNumberValue(this.max,   parse);           if (input)         {             if (o957(input.type))             {                 this.value = new u2020();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == m1091                         ? getLimitsValue(item, min, max, this.options.enabled)                         : z2021.NaN.copy());                    }             }             else                 this.value = getLimitsValue(input, min, max, this.options.enabled);         }         else             this.value = z2021.NaN.copy();           this.l4100(parse,         [             ['type', this.outputType()],             ['min',   min             ],             ['max',   max             ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.min && this.min.isValid()             && this.max && this.max.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.input) this.input.g4087(parse);         if (this.min  ) this.min  .g4087(parse);         if (this.max  ) this.max  .g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.input) this.input.e4088(parse, from, force);         if (this.min  ) this.min  .e4088(parse, from, force);         if (this.max  ) this.max  .e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.input) this.input.q4086(parse);         if (this.min  ) this.min  .q4086(parse);         if (this.max  ) this.max  .q4086(parse);     } }    function getLimitsValue(input, min, max, enabled) {     c952(          input.type == m1091,          'input.type must be NUMBER_VALUE');      if (!enabled)         return input;      return new z2021(         Math.min(Math.max(             min.value,             input.value),             max.value),         input.decimals); }


class n1936 extends u2043 {     min   = null;     max   = null;     power = null;            constructor(nodeId, options)     {         super(z1099, nodeId, options);     }            reset()     {         super.reset();          this.min   = null;         this.max   = null;         this.power = null;     }        copy()     {         const copy = new n1936(this.nodeId, this.options);          copy.o3358(this);          if (this.min  ) copy.min   = this.min  .copy();         if (this.max  ) copy.max   = this.max  .copy();         if (this.power) copy.power = this.power.copy();          return copy;     }        isCached()     {         return super.isCached()             && (!this.min   || this.min  .isCached())             && (!this.max   || this.max  .isCached())             && (!this.power || this.power.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;                       const input = await evalNumberValue(this.input, parse);         const min   = await evalNumberValue(this.min,   parse);         const max   = await evalNumberValue(this.max,   parse);         const power = await evalNumberValue(this.power, parse);           if (input)         {             if (o957(input.type))             {                 this.value = new u2020();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == m1091                         ? getNumberCurveValue(item, min, max, power, this.options.enabled)                         : z2021.NaN.copy());                    }             }             else                 this.value = getNumberCurveValue(input, min, max, power, this.options.enabled);         }         else             this.value = z2021.NaN.copy();           this.l4100(parse,         [             ['type',  this.outputType()],             ['min',   min              ],             ['max',   max              ],             ['power', power            ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.min   && this.min  .isValid()             && this.max   && this.max  .isValid()             && this.power && this.power.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.min  ) this.min  .g4087(parse);         if (this.max  ) this.max  .g4087(parse);         if (this.power) this.power.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.min  ) this.min  .e4088(parse, from, force);         if (this.max  ) this.max  .e4088(parse, from, force);         if (this.power) this.power.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.min  ) this.min  .q4086(parse);         if (this.max  ) this.max  .q4086(parse);         if (this.power) this.power.q4086(parse);     } }    function getNumberCurveValue(input, min, max, power, enabled) {     c952(         input.type == m1091,         'input.type must be NUMBER_VALUE');       if (!enabled)         return input;       let f = (input.value - min.value) / (max.value - min.value);      f = Math.pow(f, power.value);     f = min.value + f * (max.value - min.value);          return new z2021(f); }


class GNumberMap extends u2043 {     from = null;     to   = null;            constructor(nodeId, options)     {         super(m1358, nodeId, options);     }            reset()     {         super.reset();          this.from = null;         this.to   = null;     }        copy()     {         const copy = new GNumberMap(this.nodeId, this.options);          copy.o3358(this);          if (from) copy.from = this.from.copy();         if (to  ) copy.to   = this.to  .copy();          return copy;     }        isCached()     {         return super.isCached()             && (!this.from  || this.from.isCached())             && (!this.to    || this.to  .isCached());     }        async eval(parse)     {         if (this.isCached())             return this;                       const input = await evalValue    (this.input, parse);         const from  = await evalListValue(this.from,  parse);         const to    = await evalListValue(this.to,    parse);           if (   input              && input.isValid())         {             if (this.options.enabled)             {                 if (   from && from.isValid() && from.items.length > 0                     && to   && to  .isValid() && to  .items.length > 0)                 {                     if (o957(input.type))                     {                         this.value = new u2020();                                  for (let i = 0; i < input.items.length; i++)                         {                             const item = input.items[i];                                      this.value.items.push(                                 item.type == m1091                                 ? getNumberMapValue(item, from, to)                                 : z2021.NaN.copy());                            }                     }                     else                         this.value = getNumberMapValue(input, from, to);                 }                 else                     this.value = z2021.NaN.copy();             }             else                 this.value = input;         }         else             this.value = z2021.NaN.copy();           this.l4100(parse,         [             ['type', this.outputType()],             ['from', from             ],             ['to',   to               ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.from && this.from.isValid()             && this.to   && this.to  .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.from) this.from.g4087(parse);         if (this.to  ) this.to  .g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.from) this.from.e4088(parse, from, force);         if (this.to  ) this.to  .e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.from) this.from.q4086(parse);         if (this.to  ) this.to  .q4086(parse);     } }    function getNumberMapValue(input, from, to) {     c952(         input.type == m1091,         'input.type must be NUMBER_VALUE');       const maxDec = Math.max(         from.items.reduce((max, val) => Math.max(max, val.decimals), 0),         to  .items.reduce((max, val) => Math.max(max, val.decimals), 0));       if (from.items.length == 1)         return input;             const nFromSegments = Math.floor(from.items.length-1);     let   fromIndex     = 0;      while (fromIndex < nFromSegments-1)     {         if (   input.value >= from.items[fromIndex  ]             && input.value <  from.items[fromIndex+1])             break;          fromIndex++;     }               const fromLocal =              (input.value - from.items[fromIndex].value)          / (from.items[fromIndex+1].value - from.items[fromIndex].value);      const f = fromIndex/nFromSegments + fromLocal * ((fromIndex+1)/nFromSegments - fromIndex/nFromSegments);                 const nToSegments = Math.floor(to.items.length-1);     const toIndex     = Math.min(Math.max(0, Math.floor((to.items.length-1) * f)), nToSegments-1);       if (to.items.length == 1)         return to.items[0];      else if (to.items.length > 0             && toIndex < to.items.length-1)     {         const toLocal =              nToSegments > 1             ? (f - toIndex/nToSegments) * nToSegments             : f;           const x3689 = to.items[toIndex  ];         const val1 = to.items[toIndex+1];          return new z2021(             r1035(x3689.value, val1.value, toLocal),             maxDec);     } }


class GNumberBias extends u2043 {     min    = null;     max    = null;     bias   = null;     spread = null;            constructor(nodeId, options)     {         super(j1359, nodeId, options);     }            reset()     {         super.reset();          this.min    = null;         this.max    = null;         this.bias   = null;         this.spread = null;     }        copy()     {         const copy = new GNumberBias(this.nodeId, this.options);          copy.o3358(this);          if (this.min   ) copy.min    = this.min   .copy();         if (this.max   ) copy.max    = this.max   .copy();         if (this.bias  ) copy.bias   = this.bias  .copy();         if (this.spread) copy.spread = this.spread.copy();          return copy;     }        isCached()     {         return super.isCached()             && (!this.min    || this.min   .isCached())             && (!this.max    || this.max   .isCached())             && (!this.bias   || this.bias  .isCached())             && (!this.spread || this.spread.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;                       const input  = await evalNumberValue(this.input,  parse);         const min    = await evalNumberValue(this.min,    parse);         const max    = await evalNumberValue(this.max,    parse);         const bias   = await evalNumberValue(this.bias,   parse);         const spread = await evalNumberValue(this.spread, parse);           if (input)         {             if (o957(input.type))             {                 this.value = new u2020();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == m1091                         ? getNumberBiasValue(item, min, max, bias, spread, this.options.enabled)                         : z2021.NaN.copy());                    }             }             else                 this.value = getNumberBiasValue(input, min, max, bias, spread, this.options.enabled);         }         else             this.value = z2021.NaN.copy();           this.l4100(parse,         [             ['type',   this.outputType()],             ['min',    min              ],             ['max',    max              ],             ['bias',   bias             ],             ['spread', spread           ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.min    && this.min   .isValid()             && this.max    && this.max   .isValid()             && this.bias   && this.bias  .isValid()             && this.spread && this.spread.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.min   ) this.min   .g4087(parse);         if (this.max   ) this.max   .g4087(parse);         if (this.bias  ) this.bias  .g4087(parse);         if (this.spread) this.spread.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.min   ) this.min   .e4088(parse, from, force);         if (this.max   ) this.max   .e4088(parse, from, force);         if (this.bias  ) this.bias  .e4088(parse, from, force);         if (this.spread) this.spread.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.min   ) this.min   .q4086(parse);         if (this.max   ) this.max   .q4086(parse);         if (this.bias  ) this.bias  .q4086(parse);         if (this.spread) this.spread.q4086(parse);     } }    function o3734(f, bias, spread) {     const b = bias   / 50;     const s = spread / 50;       f =          b >= 0         ? 1 - Math.pow(1-f, 1+b)         :     Math.pow(  f, 1-b);            if (s >= 0 && f >= 0.5) f = 1 - Math.pow((1-f)*2, 1+s) / 2;     else if (s >= 0 && f <  0.5) f = Math.pow(f*2, 1+s) / 2;     else if (s < 0)              f = y1037(0, (1-s)/3, (2+s)/3, 1, f);       return f; }    function getNumberBiasValue(input, min, max, bias, spread, enabled) {     c952(         input.type == m1091,         'input.type must be NUMBER_VALUE');       if (!enabled)         return input;       let f = (input.value - min.value) / (max.value - min.value);      f = o3734(f, bias.value, spread.value);     f = min.value + f * (max.value - min.value);      return new z2021(f); }


class x1933 extends u2043 {     _value = null;        constructor(nodeId, options)     {         super(l1100, nodeId, options);     }            reset()     {         super.reset();          this._value = null;     }        copy()     {         const copy = new x1933(this.nodeId, this.options);          copy.o3358(this);          if (this._value) copy._value = this._value.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const  input = await evalNumberValue(this. input, parse);         const _value = await evalNumberValue(this._value, parse);           if (input)         {             if (o957(input.type))             {                 this.value = new u2020();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == m1091                         ? getNaNisNumberValue(item, _value, this.options.enabled)                         : b2032.NaN.copy());                    }             }             else             {                 this.value = getNaNisNumberValue(input, _value, this.options.enabled);             }         }          else             this.value = z2021.NaN.copy();           this.l4100(parse,         [             ['type',   this.outputType()]                      ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.value && this.value.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.value) this.value.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.value) this.value.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.value) this.value.q4086(parse);     } }    function getNaNisNumberValue(input, value, enabled) {     if (    enabled         && !input.isValid())         return value;     else         return input; }


class u1926 extends z2042 {     constant;        constructor(nodeId, options)     {         super(c1101, nodeId, options);     }            reset()     {         super.reset();          this.constant = null;     }        copy()     {         const copy = new u1926(this.nodeId, this.options);          copy.o3358(this);          if (this.constant) copy.constant = this.constant.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                                  const constant = await evalNumberValue(this.constant, parse);                   let value;          switch (Math.min(Math.max(0, constant.f3702()), 5))         {             case 0: value = 1.4142135623; break;              case 1: value = 2.7182818284; break;              case 2: value = 0.6180339887; break;              case 3: value = 1.6180339887; break;              case 4: value = 3.1415926536; break;              case 5: value = 6.2831853072; break;          }           this.value = new z2021(value);                   this.l4100(parse,         [             ['value',   this.value],             ['constant', constant ]         ]);           this.validate();          return this;     }        isValid()     {         return this.constant && this.constant.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.constant) this.constant.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.constant) this.constant.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.constant) this.constant.q4086(parse);     } } 


class v1928 extends z2042 {     seconds   = null;     minutes   = null;     hours     = null;     dayOfWeek = null;     date      = null;     month     = null;     year      = null;                    constructor(nodeId, options)     {         super(d1098, nodeId, options);     }            reset()     {         super.reset();                  this.seconds   = null;         this.minutes   = null;         this.hours     = null;         this.dayOfWeek = null;         this.date      = null;         this.month     = null;         this.year      = null;     }        copy()     {         const copy = new x1931(this.nodeId, this.options);                  copy.o3358(this);                  if (this.seconds  ) copy.seconds   = this.seconds  .copy();         if (this.minutes  ) copy.minutes   = this.minutes  .copy();         if (this.hours    ) copy.hours     = this.hours    .copy();         if (this.dayOfWeek) copy.dayOfWeek = this.dayOfWeek.copy();         if (this.date     ) copy.date      = this.date     .copy();         if (this.month    ) copy.month     = this.month    .copy();         if (this.year     ) copy.year      = this.year     .copy();          return copy;     }                        isCached()     {         return super.isCached()             && (!this.year      || this.year     .isCached())             && (!this.month     || this.month    .isCached())             && (!this.date      || this.date     .isCached())             && (!this.dayOfWeek || this.dayOfWeek.isCached())             && (!this.hours     || this.hours    .isCached())             && (!this.minutes   || this.minutes  .isCached())             && (!this.seconds   || this.seconds  .isCached())     }        async eval(parse)     {         if (this.isCached())             return this;           this.c3095 = [];                   if (this.options.enabled)         {             const dateTime = new Date();              const seconds   = new z2021(dateTime.getSeconds() );             const minutes   = new z2021(dateTime.getMinutes() );             const hours     = new z2021(dateTime.getHours()   );             const dayOfWeek = new z2021(dateTime.getDay()     );             const date      = new z2021(dateTime.getDate()    );             const month     = new z2021(dateTime.getMonth()   );             const year      = new z2021(dateTime.getFullYear());               this.l4100(parse,             [                 ['seconds',   seconds  ],                 ['minutes',   minutes  ],                 ['hours',     hours    ],                 ['dayOfWeek', dayOfWeek],                 ['date',      date     ],                 ['month',     month    ],                 ['year',      year     ]             ]);             }                       this.validate();          return this;     }            isValid()     {         return this.year      && this.year     .isValid()             && this.month     && this.month    .isValid()             && this.date      && this.date     .isValid()             && this.dayOfWeek && this.dayOfWeek.isValid()             && this.hours     && this.hours    .isValid()             && this.minutes   && this.minutes  .isValid()             && this.seconds   && this.seconds  .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.year     ) this.year     .g4087(parse);         if (this.month    ) this.month    .g4087(parse);         if (this.date     ) this.date     .g4087(parse);         if (this.dayOfWeek) this.dayOfWeek.g4087(parse);         if (this.hours    ) this.hours    .g4087(parse);         if (this.minutes  ) this.minutes  .g4087(parse);         if (this.seconds  ) this.seconds  .g4087(parse);     }            e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.year     ) this.year     .e4088(parse, from, force);         if (this.month    ) this.month    .e4088(parse, from, force);         if (this.date     ) this.date     .e4088(parse, from, force);         if (this.dayOfWeek) this.dayOfWeek.e4088(parse, from, force);         if (this.hours    ) this.hours    .e4088(parse, from, force);         if (this.minutes  ) this.minutes  .e4088(parse, from, force);         if (this.seconds  ) this.seconds  .e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.year     ) this.year     .q4086(parse);         if (this.month    ) this.month    .q4086(parse);         if (this.date     ) this.date     .q4086(parse);         if (this.dayOfWeek) this.dayOfWeek.q4086(parse);         if (this.hours    ) this.hours    .q4086(parse);         if (this.minutes  ) this.minutes  .q4086(parse);         if (this.seconds  ) this.seconds  .q4086(parse);     }     } 


class f1929 extends z2042 {     inputs = [];        constructor(nodeId, options)     {         super(o1086, nodeId, options);     }            reset()     {         super.reset();          this.input = [];     }        copy()     {         const copy = new f1929(this.nodeId, this.options);          copy.o3358(this);          copy.inputs = this.inputs.map(i => i.copy());          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const _values = [];          for (let i = 0; i < this.inputs.length; i++)         {             const input = await evalValue(this.inputs[i], parse);              if (   input                 && this.options.enabled)                         {                 if (o957(input.type))                 {                     for (const item of input.items)                         _values.push(item.copy());                    }                 else                     _values.push(input.copy());             }         }                       this.value =              _values.length > 0             ? _values[this.currentIteration % _values.length]             : new x4216();           if (   this.value              && this.value.objects)         {             for (let i = 0; i < this.value.objects.length; i++)             {                 const g111 = this.value.objects[i];                      g111.nodeId = this.nodeId;                 g111.listId = -1;                      g111.objectId = this.nodeId;                                  if (g111.objectId != NULL)                      g111.objectId += '/';                      g111.objectId += i.toString();             }         }           this.t4099(parse);                   this.l4100(parse,         [             ['type', this.outputType()]         ]);                   this.validate();          return this;     }        q3632()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return !this.inputs.find(i => !i.isValid());     }        g4087(parse)     {         super.g4087(parse);          this.inputs.forEach(i => i.g4087(parse));     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          this.inputs.forEach(i => i.e4088(parse, from, force));     }        q4086(parse)     {         super.q4086(parse);          this.inputs.forEach(i => i.q4086(parse));     } } 


class s1941 extends z2042 {     start    = null;     multiply = null;     add      = null;     end      = null;      current  = null;                    constructor(nodeId, options)     {         super(a1103, nodeId, options);     }        reset()     {         super.reset();                  this.start    = null;         this.multiply = null;         this.add      = null;         this.end      = null;              this.current  = null;     }           copy()     {         const copy = new s1941(this.nodeId, this.options);          copy.o3358(this);          if (this.start   ) copy.start    = this.start   .copy();         if (this.multiply) copy.multiply = this.multiply.copy();         if (this.add     ) copy.add      = this.add     .copy();         if (this.end     ) copy.end      = this.end     .copy();          if (this.current) copy.current = this.current.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const start = await evalNumberValue(this.start,    parse);         const mult  = await evalNumberValue(this.multiply, parse);         const add   = await evalNumberValue(this.add,      parse);         const end   = await evalNumberValue(this.end,      parse);               if (   start             && mult             && add             && end)         {             const value = start.value + (this.options.enabled ? add.value * this.currentIteration : 0);              if (!end.isValid())                 this.value = getSequenceValue(start, mult, add, this.currentIteration, this.options.enabled);              else if (   end.isValid()                         && (   add.value == 0                          || add.value >  0 && start.value < end.value                                            &&       value < end.value                          || add.value <  0 && start.value > end.value                                            &&       value > end.value))                 this.value = getSequenceValue(start, mult, add, this.currentIteration, this.options.enabled);              else                 this.value = z2021.NaN.copy();         }         else             this.value = z2021.NaN.copy();           this.l4100(parse,         [             ['start',    start],             ['multiply', mult ],             ['add',      add  ],             ['end',      end  ]         ]);                   this.validate();          return this;     }        q3632()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return this.start    && this.start   .isValid()             && this.multiply && this.multiply.isValid()             && this.add      && this.add     .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.start   ) this.start   .g4087(parse);         if (this.multiply) this.multiply.g4087(parse);         if (this.add     ) this.add     .g4087(parse);         if (this.end     ) this.end     .g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.start   ) this.start   .e4088(parse, from, force);         if (this.multiply) this.multiply.e4088(parse, from, force);         if (this.add     ) this.add     .e4088(parse, from, force);         if (this.end     ) this.end     .e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.start   ) this.start   .q4086(parse);         if (this.multiply) this.multiply.q4086(parse);         if (this.add     ) this.add     .q4086(parse);         if (this.end     ) this.end     .q4086(parse);     } }    function getSequenceValue(start, mult, add, iteration, enabled) {     let value = start.value;      if (enabled)     {         for (let i = 0; i < iteration; i++)         {             value *= mult.value;             value += add .value;         }     }      return new z2021(value); }


class o1939 extends z2042 {     from  = null;     start = null;     end   = null;                constructor(nodeId, options)     {         super(g1104, nodeId, options);     }            reset()     {         super.reset();          this.from  = null;         this.start = null;         this.end   = null;     }        copy()     {         const copy = new o1939(this.nodeId, this.options);          copy.o3358(this);          if (this.from   ) copy.from    = this.from   .copy();         if (this.start  ) copy.start   = this.start  .copy();         if (this.end    ) copy.end     = this.end    .copy();          if (this.current) copy.current = this.current.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const from  = await evalNumberValue(this.from,  parse);         const start = await evalNumberValue(this.start, parse);         const end   = await evalNumberValue(this.end,   parse);               const repeat    = parse.repeats.find(r => r.repeatId == this.q3820);         const iteration = repeat ? repeat.currentIteration : 0;           if (   from             && start             && end)         {             let delta = end.value - start.value;              let step =                  repeat                 && this.options.enabled                 ? delta / Math.max(1, repeat.total - (from.value == 1 ? 1 : 0))                 : 0;                               let startOffset;                   if (from  .value == 2) startOffset = step;             else if (from  .value == 1                 && repeat                 && repeat.total == 1) startOffset = delta/2;             else                        startOffset = 0;               let f;                          if (repeat)             {                      if (from.value == 2) f = iteration/repeat.total;                 else if (from.value == 1) f = (repeat.total > 1 ? iteration/(repeat.total-1) : 0);                 else if (from.value == 0) f = iteration/repeat.total;             }             else                 f = 0;               this.value = new z2021(                 start.value + startOffset + f * delta,                 Math.max(start.decimals, end.decimals));         }         else             this.value = z2021.NaN.copy();           this.l4100(parse,         [             ['from',  from ],             ['start', start],             ['end',   end  ]         ]);           this.validate();          return this;     }        q3632()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return this.from  && this.from .isValid()             && this.start && this.start.isValid()             && this.end   && this.end  .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.from ) this.from .g4087(parse);         if (this.start) this.start.g4087(parse);         if (this.end  ) this.end  .g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.from ) this.from .e4088(parse, from, force);         if (this.start) this.start.e4088(parse, from, force);         if (this.end  ) this.end  .e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.from ) this.from .q4086(parse);         if (this.start) this.start.q4086(parse);         if (this.end  ) this.end  .q4086(parse);     } } 


class j1945 extends z2042 {     shape     = null;     base      = null;     amplitude = null;     frequency = null;     offset    = null;     bias      = null;          useWavelength;     offsetAbsolute;        constructor(nodeId, options)     {         super(a1105, nodeId, options);     }            reset()     {         super.reset();          this.shape     = null;         this.base      = null;         this.amplitude = null;         this.frequency = null;         this.offset    = null;         this.bias      = null;     }        copy()     {         const copy = new j1945(this.nodeId, this.options);          copy.o3358(this);          if (this.shape    ) copy.shape     = this.shape    .copy();         if (this.base     ) copy.base      = this.base     .copy();         if (this.amplitude) copy.amplitude = this.amplitude.copy();         if (this.frequency) copy.frequency = this.frequency.copy();         if (this.offset   ) copy.offset    = this.offset   .copy();         if (this.bias     ) copy.bias      = this.bias     .copy();          if (this.current) copy.current = this.current.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const shape  = await evalNumberValue(this.shape,     parse);         const base   = await evalNumberValue(this.base,      parse);         const amp    = await evalNumberValue(this.amplitude, parse);         let   freq   = await evalNumberValue(this.frequency, parse);         const offset = await evalNumberValue(this.offset,    parse);         const bias   = await evalNumberValue(this.bias,      parse);               const repeat    = parse.repeats.find(r => r.repeatId == this.q3820);         const iteration = repeat ? repeat.currentIteration : 0;            if (this.options.enabled)         {             let t;                                       if (   repeat                 && shape                 && freq                 && offset)             {                 const _freq =                     this.useWavelength                     ? repeat.total / nozero(freq.value)                     : freq.value;                  let _offset =                     this.offsetAbsolute                     ? offset.value/repeat.total                     : (offset.value/100)/_freq;                  if (shape.value == 3)                     _offset -= 0.25;                  t = (iteration/repeat.total - _offset) * _freq;                  while (t < 0) t++;                 while (t > 1) t--;                  switch (shape.value)                 {                     case 0: t = (t%1) < 0.5 ? 1 : -1;      break;                      case 1: t = (1 - (t%1)*2);             break;                      case 2: t = ((t%1)*2 - 1);             break;                      case 3: t = 1 - 2*Math.abs(2*(t%1)-1); break;                      case 4: t = Math.sin(t * Tau);         break;                  }             }             else                  t = 0;                           if (bias)             {                 const b = bias.value / 100;                  if (b >= 0) t = t / (1+b) + b/2;                 else        t = t / (1-b) + b/2;             }               if (amp ) t = t * amp .value;             if (base) t = t + base.value;               this.value = new z2021(t);         }         else             this.value = base;                   this.l4100(parse,         [             ['shape',     shape ],             ['base',      base  ],             ['amplitude', amp   ],             ['frequency', freq  ],             ['offset',    offset],             ['bias',      bias  ]         ]);           this.validate();          return this;     }        q3632()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return this.shape     && this.shape    .isValid()             && this.base      && this.base     .isValid()             && this.amplitude && this.amplitude.isValid()             && this.frequency && this.frequency.isValid()             && this.offset    && this.offset   .isValid()             && this.bias      && this.bias     .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.shape    ) this.shape    .g4087(parse);         if (this.base     ) this.base     .g4087(parse);         if (this.amplitude) this.amplitude.g4087(parse);         if (this.frequency) this.frequency.g4087(parse);         if (this.offset   ) this.offset   .g4087(parse);         if (this.bias     ) this.bias     .g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.shape    ) this.shape    .e4088(parse, from, force);         if (this.base     ) this.base     .e4088(parse, from, force);         if (this.amplitude) this.amplitude.e4088(parse, from, force);         if (this.frequency) this.frequency.e4088(parse, from, force);         if (this.offset   ) this.offset   .e4088(parse, from, force);         if (this.bias     ) this.bias     .e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.shape    ) this.shape    .q4086(parse);         if (this.base     ) this.base     .q4086(parse);         if (this.amplitude) this.amplitude.q4086(parse);         if (this.frequency) this.frequency.q4086(parse);         if (this.offset   ) this.offset   .q4086(parse);         if (this.bias     ) this.bias     .q4086(parse);     } } 


class h1938 extends z2042 {     seed         = null;     iteration    = null;     min          = null;     max          = null;     bias         = null;     spread       = null;     unique       = null;      random       = null;     randomUnique = null;      lastValue1   = -1;     lastValue2   = -1;     uniqueOffset =  0;        constructor(nodeId, options)     {         super(e1106, nodeId, options);     }            reset()     {         super.reset();          this.seed      = null;         this.iteration = null;         this.min       = null;         this.max       = null;         this.bias      = null;         this.spread    = null;         this.unique    = null;     }        copy()     {         const copy = new h1938(this.nodeId, this.options);          copy.o3358(this);          if (this.seed     ) copy.seed      = this.seed     .copy();         if (this.iteration) copy.iteration = this.iteration.copy();         if (this.min      ) copy.min       = this.min      .copy();         if (this.max      ) copy.max       = this.max      .copy();         if (this.bias     ) copy.bias      = this.bias     .copy();         if (this.spread   ) copy.spread    = this.spread   .copy();         if (this.unique   ) copy.unique    = this.unique   .copy();          if (this.random   ) copy.random    = this.random   .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const seed      = await evalNumberValue(this.seed,      parse);         const iteration = await evalNumberValue(this.iteration, parse);         const min       = await evalNumberValue(this.min,       parse);         const max       = await evalNumberValue(this.max,       parse);         const bias      = await evalNumberValue(this.bias,      parse);         const spread    = await evalNumberValue(this.spread,    parse);         const unique    = await evalNumberValue(this.unique,    parse);               if (   this.options.enabled             && iteration             && seed             && min             && max             && bias             && spread             && unique)         {             if (  !this.random                 || this.random.seed != seed.value)             {                 this.random       = new Random(seed.value);                 this.randomUnique = new Random(seed.value+1);             }               if (iteration.isValid())                 this.currentIteration = Math.round(iteration.value);               if (this.currentIteration >= 0)             {                 let f  = this.random.get(this.currentIteration + this.uniqueOffset);                  f = o3734(f, bias.value, spread.value);                 f = min.value + f * (max.value - min.value);                                  this.value = new z2021(f, Math.max(min.decimals, max.decimals));                                       const _unique = unique.value/100;                                   if (max.value - min.value >= 1)                 {                     while (this.value.f3702() == this.lastValue1                         && this.randomUnique.get(this.currentIteration) < _unique)                         this.value = new z2021(                             min.value + this.random.get(this.currentIteration + ++this.uniqueOffset) * (max.value - min.value),                             Math.max(min.decimals, max.decimals));                 }                  if (max.value - min.value >= 2)                 {                     while ((   this.value.f3702() == this.lastValue1                             || this.value.f3702() == this.lastValue2)                         && this.randomUnique.get(this.currentIteration) < Math.max(_unique - 1))                         this.value = new z2021(                             min.value + this.random.get(this.currentIteration + ++this.uniqueOffset) * (max.value - min.value),                             Math.max(min.decimals, max.decimals));                 }                     }             else                 this.value = new z2021((min.value + max.value) / 2);         }         else             this.value = z2021.NaN.copy();           if (this.value.isValid())             this.value.value = this.value.f3702();          this.lastValue2 = this.lastValue1;         this.lastValue1 = this.value.value;           this.l4100(parse,         [             ['iteration', iteration],             ['seed',      seed     ],             ['min',       min      ],             ['max',       max      ],             ['bias',      bias     ],             ['spread',    spread   ],             ['unique',    unique   ]         ]);                   this.validate();          return this;     }        q3632()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return this.seed      && this.seed     .isValid()             && this.iteration && this.iteration.isValid()             && this.min       && this.min      .isValid()             && this.max       && this.max      .isValid()             && this.bias      && this.bias     .isValid()             && this.spread    && this.spread   .isValid()             && this.unique    && this.unique   .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.seed     ) this.seed     .g4087(parse);         if (this.iteration) this.iteration.g4087(parse);         if (this.min      ) this.min      .g4087(parse);         if (this.max      ) this.max      .g4087(parse);         if (this.bias     ) this.bias     .g4087(parse);         if (this.spread   ) this.spread   .g4087(parse);         if (this.unique   ) this.unique   .g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.seed     ) this.seed     .e4088(parse, from, force);         if (this.iteration) this.iteration.e4088(parse, from, force);         if (this.min      ) this.min      .e4088(parse, from, force);         if (this.max      ) this.max      .e4088(parse, from, force);         if (this.bias     ) this.bias     .e4088(parse, from, force);         if (this.spread   ) this.spread   .e4088(parse, from, force);         if (this.unique   ) this.unique   .e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.seed     ) this.seed     .q4086(parse);         if (this.iteration) this.iteration.q4086(parse);         if (this.min      ) this.min      .q4086(parse);         if (this.max      ) this.max      .q4086(parse);         if (this.bias     ) this.bias     .q4086(parse);         if (this.spread   ) this.spread   .q4086(parse);         if (this.unique   ) this.unique   .q4086(parse);     }        y3628(parse, nodeId)     {         super.y3628(parse, nodeId);          this.uniqueOffset = 0;     }        z3631(parse, nodeId)     {         super.z3631(parse, nodeId);          this.uniqueOffset = 0;     } } 


class j1934 extends z2042 {     seed        = null;     iteration   = null;     min         = null;     max         = null;     scale       = null;     interpolate = null;     offset      = null;     evolve      = null;     detail      = null;          randoms     = [];     offsets     = [];                    constructor(nodeId, options)     {         super(d1107, nodeId, options);     }                    reset()     {         super.reset();                  this.seed          = null;         this.iteration     = null;         this.min           = null;         this.max           = null;         this.scale         = null;         this.interpolate   = null;         this.offset        = null;         this.evolve        = null;         this.detail        = null;     }        copy()     {         const copy = new j1934(this.nodeId, this.options);          copy.o3358(this);          if (this.seed       ) copy.seed        = this.seed       .copy();         if (this.iteration  ) copy.iteration   = this.iteration  .copy();         if (this.min        ) copy.min         = this.min        .copy();         if (this.max        ) copy.max         = this.max        .copy();         if (this.scale      ) copy.scale       = this.scale      .copy();         if (this.offset     ) copy.offset      = this.offset     .copy();         if (this.evolve     ) copy.evolve      = this.evolve     .copy();         if (this.interpolate) copy.interpolate = this.interpolate.copy();         if (this.detail     ) copy.detail      = this.detail     .copy();          if (this.randoms    ) copy.randoms     = this.randoms.map(r => r.copy());         if (this.offsets    ) copy.offsets     = this.offsets.slice();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const seed        = await evalNumberValue(this.seed,        parse);         const iteration   = await evalNumberValue(this.iteration,   parse);         const min         = await evalNumberValue(this.min,         parse);         const max         = await evalNumberValue(this.max,         parse);         const scale       = await evalNumberValue(this.scale,       parse);         const offset      = await evalNumberValue(this.offset,      parse);         const evolve      = await evalNumberValue(this.evolve,      parse);         const interpolate = await evalNumberValue(this.interpolate, parse);         const detail      = await evalNumberValue(this.detail,      parse);               if (   this.options.enabled             && seed             && iteration             && min             && max             && scale             && offset             && evolve             && interpolate             && detail)         {             const _detail = Math.max(1, Math.ceil(detail.value));               if (  !this.randoms                 || this.randoms.length < _detail)             {                 const randoms = new Array(_detail);                  for (let c = 0; c < this.randoms.length; c++)                     randoms[c] = this.randoms[c];                                   let _seed = seed.value;                  for (let c = this.randoms.length; c < _detail; c++)                 {                     randoms[c] = new l375(_seed);                     _seed = seed.value;                 }                   this.randoms = randoms;                   this.updateOffsets(this.randoms[0].width * _detail);             }               let   size  = 1;             let   power = 1;                          const avg   = (min.value + max.value) / 2;             let   r;                           if (iteration.isValid())                 this.currentIteration = Math.round(iteration.value);                               if (   this.options.enabled                 && scale  && scale .isValid()                 && offset && offset.isValid()                 && evolve && evolve.isValid())             {                 r = avg;                                  if (this.currentIteration >= 0)                 {                     for (let c = 0; c < _detail; c++)                     {                         const i  = Math.max(0, this.currentIteration / (Math.max(0.000001, scale.value) * size) + offset.value);                         const i0 = Math.floor(i);                         const i1 = Math.ceil (i);                                                   this.updateOffsets((i1 + 1) * _detail);                          const o0 = this.offsets[i0];                         const o1 = this.offsets[i1];                         let   _o;                          switch (interpolate.value)                         {                             case 0: _o = o0;                                                 break;                             case 1: _o = r1035(o0, o1, i-i0);                                 break;                             case 2: _o = (o0 + (o1 - o0) * (-Math.cos((i-i0)*Tau/2) + 1)/2); break;                         }                                                   const j   = evolve.value + _o;                         const j0  = Math.floor(j);                         const j1  = Math.ceil (j);                           const r00 = this.randoms[c].get(i0, j0);                         const r10 = this.randoms[c].get(i1, j0);                         const r01 = this.randoms[c].get(i0, j1);                         const r11 = this.randoms[c].get(i1, j1);                                       let _r, _r0, _r1;                                                  switch (interpolate.value)                         {                             case 0:                                  _r = r00;                                 break;                              case 1:                                  _r0 = r1035(r00, r10, i-i0);                                 _r1 = r1035(r01, r11, i-i0);                                 _r  = r1035(_r0, _r1, j-j0);                                 break;                              case 2:                                  _r0 = (r00 + (r10 - r00) * (-Math.cos((i-i0)*Tau/2) + 1)/2);                                  _r1 = (r01 + (r11 - r01) * (-Math.cos((i-i0)*Tau/2) + 1)/2);                                  _r  = (_r0 + (_r1 - _r0) * (-Math.cos((j-j0)*Tau/2) + 1)/2);                                  break;                         }                           const clamp =                              detail.value - c < 1                              ? detail.value - c                              : 1;                          r +=                              - power *      (avg       - min.value) * clamp                             + power * _r * (max.value - min.value) * clamp;                                                   size  /= 2;                         power /= 2;                                                   this.updateOffsets(this.randoms[0].width * _detail);                     }                 }             }             else             {                 r = min.value;             }               this.value = new z2021(r, Math.max(min.decimals, max.decimals));         }         else         {             this.value = z2021.NaN.copy();         }           this.l4100(parse,         [             ['seed',        seed       ],             ['iteration',   iteration  ],             ['min',         min        ],             ['max',         max        ],             ['scale',       scale      ],             ['offset',      offset     ],             ['evolve',      evolve     ],             ['interpolate', interpolate],             ['detail',      detail     ]         ]);                   this.validate();          return this;     }        updateOffsets(newSize)     {         if (newSize < this.offsets.length)              return;          this.offsets = new Array(newSize);         const offsetRandom = new Random(0);          for (let o = 0; o < newSize; o++)             this.offsets[o] = offsetRandom.get(o);     }        q3632()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return this.seed        && this.seed       .isValid()             && this.iteration   && this.iteration  .isValid()             && this.min         && this.min        .isValid()             && this.max         && this.max        .isValid()             && this.scale       && this.scale      .isValid()             && this.offset      && this.offset     .isValid()             && this.evolve      && this.evolve     .isValid()             && this.interpolate && this.interpolate.isValid()             && this.detail      && this.detail     .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.seed       ) this.seed       .g4087(parse);         if (this.iteration  ) this.iteration  .g4087(parse);         if (this.min        ) this.min        .g4087(parse);         if (this.max        ) this.max        .g4087(parse);         if (this.scale      ) this.scale      .g4087(parse);         if (this.offset     ) this.offset     .g4087(parse);         if (this.evolve     ) this.evolve     .g4087(parse);         if (this.interpolate) this.interpolate.g4087(parse);         if (this.detail     ) this.detail     .g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.seed       ) this.seed       .e4088(parse, from, force);         if (this.iteration  ) this.iteration  .e4088(parse, from, force);         if (this.min        ) this.min        .e4088(parse, from, force);         if (this.max        ) this.max        .e4088(parse, from, force);         if (this.scale      ) this.scale      .e4088(parse, from, force);         if (this.offset     ) this.offset     .e4088(parse, from, force);         if (this.evolve     ) this.evolve     .e4088(parse, from, force);         if (this.interpolate) this.interpolate.e4088(parse, from, force);         if (this.detail     ) this.detail     .e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.seed       ) this.seed       .q4086(parse);         if (this.iteration  ) this.iteration  .q4086(parse);         if (this.min        ) this.min        .q4086(parse);         if (this.max        ) this.max        .q4086(parse);         if (this.scale      ) this.scale      .q4086(parse);         if (this.offset     ) this.offset     .q4086(parse);         if (this.evolve     ) this.evolve     .q4086(parse);         if (this.interpolate) this.interpolate.q4086(parse);         if (this.detail     ) this.detail     .q4086(parse);     } } 


class x1937 extends z2044 {     seed      = null;     iteration = null;     chance    = null;     alternate = null;      random    = null;        constructor(nodeId, options)     {         super(h1108, nodeId, options);     }            reset()     {         super.reset();          this.seed      = null;         this.iteration = null;         this.chance    = null;         this.alternate = null;     }        copy()     {         const copy = new h1938(this.nodeId, this.options);          copy.o3358(this);          if (this.seed     ) copy.seed      = this.seed     .copy();         if (this.iteration) copy.iteration = this.iteration.copy();         if (this.chance   ) copy.chance    = this.chance   .copy();         if (this.alternate) copy.alternate = this.alternate.copy();          if (this.random) copy.random = this.random.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const z4082    = await evalValue      (this.z4082,    parse);         const z4083    = await evalValue      (this.z4083,    parse);         const seed      = await evalNumberValue(this.seed,      parse);         const iteration = await evalNumberValue(this.iteration, parse);         const chance    = await evalNumberValue(this.chance,    parse);         const alternate = await evalNumberValue(this.alternate, parse);               if (   seed             && iteration             && chance             && alternate)         {             if (  !this.random                 || this.random.seed != seed.value)                 this.random = new Random(seed.value);               if (iteration.isValid())                 this.currentIteration = Math.round(iteration.value);               if (this.currentIteration >= 0)             {                 const calt  = this.currentIteration % 2 == 0 ? 0 : 1;                  let   cval  = chance.value/100;                       cval += alternate.value/100 * (calt - cval);                  const ch    = this.random.get(this.currentIteration) > cval ? 0 : 1;                                   if (   z4082                      && z4083)                 {                     if (   z4082.isValid()                         && z4083.isValid())                         this.value = ch < 0.5 ? z4082 : z4083;                     else                         this.value = new x4216();                 }                  else if (z4082)                     this.value = z4082;                                  else if (z4083)                     this.value = z4083;                                  else                     this.value = new z2021(ch < 0.5 ? 0 : 1);             }             else                 this.value = new x4216();         }         else             this.value = new x4216();           this.l4100(parse,         [             ['type',      this.outputType()],             ['seed',      seed             ],             ['iteration', iteration        ],             ['chance',    chance           ],             ['alternate', alternate        ]         ]);                   this.validate();          return this;     }        q3632()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return this.seed      && this.seed     .isValid()             && this.iteration && this.iteration.isValid()             && this.chance    && this.chance   .isValid()             && this.alternate && this.alternate.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.seed     ) this.seed     .g4087(parse);         if (this.iteration) this.iteration.g4087(parse);         if (this.chance   ) this.chance   .g4087(parse);         if (this.alternate) this.alternate.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.seed     ) this.seed     .e4088(parse, from, force);         if (this.iteration) this.iteration.e4088(parse, from, force);         if (this.chance   ) this.chance   .e4088(parse, from, force);         if (this.alternate) this.alternate.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.seed     ) this.seed     .q4086(parse);         if (this.iteration) this.iteration.q4086(parse);         if (this.chance   ) this.chance   .q4086(parse);         if (this.alternate) this.alternate.q4086(parse);     } } 


class m1924 extends u2043 {     current;     when;        constructor(nodeId, options)     {         super(m1109, nodeId, options);          this.current = new z2021(0);     }            reset()     {         super.reset();          this.current = null;         this.when    = null;     }        copy()     {         const copy = new m1924(this.nodeId, this.options);          copy.o3358(this);          if (this.when   ) copy.when    = this.when   .copy();         if (this.current) copy.current = this.current.copy();          return copy;     }        async eval(parse)     {         if (    this.isCached()             || !parse.evalAccumulate)             return this;           const input = await evalNumberValue(this.input, parse);         const when  = await evalNumberValue(this.when,  parse);                       if (   input             && when)         {             if (this.options.enabled)             {                 if (when.value > 0)                     this.value = this.current.copy();                  if (input)                 {                     this.current.value   += input.value;                     this.current.decimals = Math.max(this.current.decimals, input.decimals);                 }                  if (when.value == 0)                     this.value = this.current.copy();             }             else                 this.value = input.copy();         }         else             this.value = z2021.NaN.copy();           this.l4100(parse,          [             ['when', when]         ]);                   this.validate();          return this;     }        q3632()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.when && this.when.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.when) this.when.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.when) this.when.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.when) this.when.q4086(parse);     }        z3631(parse, nodeId)     {         super.z3631(parse, nodeId);          this.current = new z2021(0);     } } 


class GHold extends u2043 {     current;     first;        constructor(nodeId, options)     {         super(HOLD, nodeId, options);          this.current = null;     }            reset()     {         super.reset();          this.current = null;         this.first   = null;     }        copy()     {         const copy = new GHold(this.nodeId, this.options);          copy.o3358(this);          if (this.first  ) copy.first   = this.first  .copy();         if (this.current) copy.current = this.current.copy();          return copy;     }        async eval(parse)     {         if (    this.isCached()             || !parse.evalAccumulate)             return this;           const input = await evalValue(this.input, parse);         const first = await evalValue(this.first, parse);                       if (   input             && first)         {             if (this.options.enabled)             {                 this.value   = this.current ? this.current : first;                 this.current = input;             }             else                 this.value = input;         }         else             this.value = z2021.NaN.copy();           this.l4100(parse,          [             ['type', this.outputType()]         ]);                   this.validate();          return this;     }        q3632()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.first && this.first.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.first) this.first.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.first) this.first.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.first) this.first.q4086(parse);     }        z3631(parse, nodeId)     {         super.z3631(parse, nodeId);          this.current = null;     } } 


class c1930 extends z2044 {     inputs = [];      amount;     degree;        constructor(nodeId, options)     {         super(s1110, nodeId, options);     }            reset()     {         super.reset();          this.inputs = [];          this.amount = null;         this.degree = null;     }        copy()     {         const copy = new c1930(this.nodeId, this.options);          copy.o3358(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.amount) copy.amount = this.amount.copy();         if (this.degree) copy.degree = this.degree.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const amount = await evalNumberValue(this.amount, parse);         const degree = await evalNumberValue(this.degree, parse);           const values = [];                  for (const e3811 of this.inputs)         {             const input = await evalNumberValue(e3811, parse);              if (o957(input.type))             {                 for (const item of input.items)                 {                                                                    const value = await evalNumberValue(item, parse);                     values.push(value);                 }             }             else             {                 const value = await evalNumberValue(input, parse);                 values.push(value);             }         }                           const maxDec = values.reduce((max, v) => Math.max(max, v.decimals), 0);           const deg =             degree.value < 3             ? Math.min(degree.value, 2) + 1             : 1;          const nSegments = Math.floor((values.length-1)/deg);         const index     = Math.min(Math.floor((values.length-1)/deg * amount.value/100), nSegments-1);           if (values.length == 1)             this.value = values[0];          else if (values.length > 0               && index < values.length - deg)         {             const localAmount =                  nSegments > 1                 ? (amount.value/100 - index/nSegments) * nSegments                 : amount.value/100;               if (degree.value == 0)              {                 const x3689 = values[index*deg  ];                 const val1 = values[index*deg+1];                  this.value = new z2021(                     r1035(x3689.value, val1.value, localAmount),                     maxDec);             }             else if (degree.value == 1)              {                 const x3689 = values[index*deg  ];                 const val1 = values[index*deg+1];                 const val2 = values[index*deg+2];                  this.value = new z2021(                     s1036(x3689.value, val1.value, val2.value, localAmount),                     maxDec);             }             else if (degree.value == 2)              {                 const x3689 = values[index*deg  ];                 const val1 = values[index*deg+1];                 const val2 = values[index*deg+2];                 const val3 = values[index*deg+3];                  this.value = new z2021(                     y1037(x3689.value, val1.value, val2.value, val3.value, localAmount),                     maxDec);             }             else if (degree.value == 3)              {                 const x3689 = values[index*deg  ];                 const val1 = values[index*deg+1];                  this.value = new z2021(                     lerpCos(x3689.value, val1.value, localAmount),                     maxDec);             }             else                 this.value = z2021.NaN.copy();         }          else                               this.value = z2021.NaN.copy();           this.l4100(parse,         [             ['value',  this.value],             ['amount', amount    ],             ['degree', degree    ]         ]);                   this.validate();          return this;     }        isValid()     {         return  super.isValid()             &&  this.inputs.length > 0             && !this.inputs.find(i => !i.isValid())             &&  this.amount && this.amount.isValid()             &&  this.degree && this.degree.isValid();     }        g4087(parse)     {         super.g4087(parse);          this.inputs.forEach(i => i.g4087(parse));          if (this.amount) this.amount.g4087(parse);         if (this.degree) this.degree.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          this.inputs.forEach(i => i.e4088(parse, from, force));          if (this.amount) this.amount.e4088(parse, from, force);         if (this.degree) this.degree.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          this.inputs.forEach(i => i.q4086(parse));          if (this.amount) this.amount.q4086(parse);         if (this.degree) this.degree.q4086(parse);     } } 


class y1944 extends u2043 {     current = null;     target  = null;      temp    = null;            constructor(nodeId, options)     {         super(d1098, nodeId, options);     }            reset()     {         super.reset();          this.current = null;         this.target  = null;         this.temp    = null;     }        copy()     {         const copy = new y1944(this.nodeId, this.options);          copy.o3358(this);          if (this.current) copy.current = this.current.copy();         if (this.target ) copy.target  = this.target .copy();          return copy;     }        isCached()     {         return super.isCached()             && this.current.isCached()             && this.target .isCached();     }        async eval(parse)     {         if (this.isCached())             return this;           let   input   = await evalNumberValue(this.input,   parse);         let   current = await evalNumberValue(this.current, parse);         const target  = await evalNumberValue(this.target,  parse);           if (   input             && current.isValid()             && target .isValid())         {             c952(                 input.type == m1091,                  'input.type must be NUMBER_VALUE');               if (this.options.enabled)             {                 let   diff      = target.value - current.value;                 let   prevDiff  = 0;                   let   temp      = 0;                 let   step      = Number.MAX_SAFE_INTEGER/65536;                   let   iter      = 0;                 const maxIter   = 1000;                                   z2076(this.nodeId);                   parse.s3639 += maxIter;                   while (iter++ < maxIter)                 {                     temp += step;                       if (this.input.type == PARAM)                     {                         this.input.node[this.input.v2991].value    = temp;                         this.input.node[this.input.v2991].decimals = i1004(temp);                     }                                               this.current.e4088(parse, this);                     current = await evalNumberValue(this.current, parse);                                                                                      if (current.isValid())                     {                         diff = target.value - current.value;                                                   if (Math.abs(diff) < 0.0000001)                             break;                                                       if (   Math.abs (diff) >  Math.abs (prevDiff)                             || Math.sign(diff) != Math.sign(prevDiff))                             step /= -2;                                                                             prevDiff = diff;                     }                                               parse.n3638++;                     y2077(parse, this.nodeId, iter / maxIter);                 }                   if (iter < maxIter)                 {                     parse.n3638 += maxIter - iter;                      input = await evalNumberValue(this.input, parse);                     this.value = input.copy();                 }                 else                 {                     this.value = z2021.NaN.copy();                     console.warn('max solve iterations');                 }             }             else                 this.value = input.copy();         }         else         {             if (this.input)                  await this.input.eval(parse);              this.value = z2021.NaN.copy();         }                             this.l4100(parse,         [                          ['current', current   ],             ['target',  target    ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.current && this.current.isValid()             && this.target  && this.target .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.current) this.current.g4087(parse);         if (this.target ) this.target .g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.current) this.current.e4088(parse, from, force);         if (this.target ) this.target .e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.current) this.current.q4086(parse);         if (this.target ) this.target .q4086(parse);     } } 


class n1925 extends z2042 {     from   = null;     to     = null;     curve  = null;     repeat = null;     length = null;     time   = null;                    constructor(nodeId, options)     {         super(g1112, nodeId, options);     }                    reset()     {         super.reset();                  this.from   = null;         this.to     = null;         this.curve  = null;         this.repeat = null;         this.length = null;         this.time   = null;     }        copy()     {         const copy = new n1925(this.nodeId, this.options);          copy.o3358(this);          if (this.from  ) copy.from   = this.from  .copy();         if (this.to    ) copy.to     = this.to    .copy();         if (this.curve ) copy.curve  = this.curve .copy();         if (this.repeat) copy.repeat = this.repeat.copy();         if (this.length) copy.length = this.length.copy();         if (this.time  ) copy.time   = this.time  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const from   = await evalNumberValue(this.from,   parse);         const to     = await evalNumberValue(this.to,     parse);         const curve  = await evalNumberValue(this.curve,  parse);         const repeat = await evalNumberValue(this.repeat, parse);         const length = await evalNumberValue(this.length, parse);         const time   = await evalNumberValue(this.time,   parse);               const maxDec = Math.max(from.decimals, to.decimals);          switch (curve.value)         {             case 0:              {                 this.value = new z2021(                     time.value < length.value ? from.value : to.value,                      maxDec);                      break;             }             case 1:              {                 this.value = new z2021(                     from.value + (to.value - from.value) * time.value / length.value,                     maxDec);                  break;             }             case 2:              {                 let f = time.value / length.value;                  f = 1 - sqr(1 - f);                  this.value = new z2021(                     from.value + (to.value - from.value) * f,                     maxDec);                      break;             }             case 3:              {                 let f = time.value / length.value;                  f = sqr(f);                  this.value = new z2021(                     from.value + (to.value - from.value) * f,                     maxDec);                      break;             }             case 4:              {                 let f = time.value / length.value;                  f = 6*Math.pow(f, 5) - 15*Math.pow(f, 4) + 10*Math.pow(f, 3);                  this.value = new z2021(                     from.value + (to.value - from.value) * f,                     maxDec);                      break;             }         }                   this.l4100(parse,         [             ['from',   from  ],             ['to',     to    ],             ['curve',  curve ],             ['repeat', repeat],             ['length', length],             ['time',   time  ]         ]);                   this.validate();          return this;     }        isValid()     {         return this.from   && this.from  .isValid()             && this.to     && this.to    .isValid()             && this.curve  && this.curve .isValid()             && this.repeat && this.repeat.isValid()             && this.length && this.length.isValid()             && this.time   && this.time  .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.from  ) this.from  .g4087(parse);         if (this.to    ) this.to    .g4087(parse);         if (this.curve ) this.curve .g4087(parse);         if (this.repeat) this.repeat.g4087(parse);         if (this.length) this.length.g4087(parse);         if (this.time  ) this.time  .g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.from  ) this.from  .e4088(parse, from, force);         if (this.to    ) this.to    .e4088(parse, from, force);         if (this.curve ) this.curve .e4088(parse, from, force);         if (this.repeat) this.repeat.e4088(parse, from, force);         if (this.length) this.length.e4088(parse, from, force);         if (this.time  ) this.time  .e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.from  ) this.from  .q4086(parse);         if (this.to    ) this.to    .q4086(parse);         if (this.curve ) this.curve .q4086(parse);         if (this.repeat) this.repeat.q4086(parse);         if (this.length) this.length.q4086(parse);         if (this.time  ) this.time  .q4086(parse);     } } 


class g1901 extends s1898 {     operation;        constructor(nodeId, options)     {         super(p1114, nodeId, options);     }       reset()     {         super.reset();          this.operation = null;     }            copy()     {         const copy = new g1901(this.nodeId, this.options);          copy.o3358(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.operation) copy.operation = this.operation.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           let op = await evalNumberValue(this.operation, parse);          if (op) op = op.c3728();                   if (op.isValid())         {             op.value    = Math.min(Math.max(0, Math.round(op.value)), r1311.length-1);             op.decimals = 0;         }           if (this.options.enabled)         {             switch (op.value)             {                 case 0: this.value = await j3700  (this, this.inputs, parse); break;                 case 1: this.value = await z3699  (this, this.inputs, parse); break;                 case 2: this.value = await q3697(this, this.inputs, parse); break;                 case 3: this.value = await y3696     (this, this.inputs, parse); break;                 case 4: this.value = await a3698(this, this.inputs, parse); break;                 case 5: this.value = await z3701(this, this.inputs, parse); break;             }         }          else if (this.inputs.length > 0)             this.value =                     this.inputs.length > 0                  && this.inputs[0]                  ? (await this.inputs[0].eval(parse)).q3632()                  : null;          else             this.value = z2021.NaN.copy();           this.l4100(parse,         [                          ['operation', op        ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.operation && this.operation.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.operation) this.operation.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.operation) this.operation.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.operation) this.operation.q4086(parse);     } }    async function y3696(node, inputs, parse) {     if (isEmpty(inputs))         return z2021.NaN.copy();       const value = new z2021(0);       for (let i = 0; i < inputs.length; i++)     {         const val = await evalValue(inputs[i], parse);                   if (   !val             || !val.isValid())         {             for (let j = i+1; j < inputs.length; j++)                 await evalValue(inputs[j], parse);                          return z2021.NaN.copy();         }           if (o957(val.type))         {             if (   isEmpty(val.items)                 || val.items[0].type != m1091)                 return z2021.NaN.copy();              for (const item of val.items)             {                 if (item.type == m1091)                 {                     value.value   += item.value;                     value.decimals = Math.max(value.decimals, item.decimals);                 }             }         }         else         {             c952(                  val.type == m1091,                  'val.type must be NUMBER_VALUE');              value.value   += val.value;             value.decimals = Math.max(value.decimals, val.decimals);         }     }       return value; }    async function q3697(node, inputs, parse) {     if (isEmpty(inputs))         return z2021.NaN.copy();       let value = new z2021(0);       if (!isEmpty(inputs))     {         const x3689 = await evalValue(inputs[0], parse);          if (   !x3689             || !x3689.isValid())         {             for (let j = 1; j < inputs.length; j++)                 await evalValue(inputs[j], parse);                          return z2021.NaN.copy();         }                                                                 if (     o957(x3689.type)              && !isEmpty(x3689.items))         {             const x3688 = x3689.items[0];              if (   !x3688                 || !x3688.isValid())                 return z2021.NaN.copy();               value.value    = x3688.value;             value.decimals = x3688.decimals;              for (let i = 1; i < x3689.items.length; i++)             {                 const item = x3689.items[i];                  if (   !item                     || !item.isValid())                     return z2021.NaN.copy();                  if (item.type == m1091)                 {                     value.value   -= item.value;                     value.decimals = Math.max(value.decimals, item.decimals);                 }                                 }         }         else         {             if (x3689.type != m1091)                 return z2021.NaN.copy();              value.value    = x3689.value;             value.decimals = x3689.decimals;         }           for (let i = 1; i < inputs.length; i++)         {             const val = await evalNumberValue(inputs[i], parse);              if (   !val                 || !val.isValid())             {                 for (let j = i+1; j < inputs.length; j++)                     await evalValue(inputs[j], parse);                                  return z2021.NaN.copy();             }               if (o957(val.type))             {                 for (const item of val.items)                 {                     if (item.type == m1091)                     {                         value.value   -= item.value;                         value.decimals = Math.max(value.decimals, item.decimals);                     }                                     }             }             else             {                 c952(                      val.type == m1091,                      'val.type must be NUMBER_VALUE');                                      value.value   -= val.value;                 value.decimals = Math.max(value.decimals, val.decimals);             }         }     }       return value; }    async function a3698(node, inputs, parse) {     if (isEmpty(inputs))         return z2021.NaN.copy();       const value = new z2021(0);       if (!isEmpty(inputs))     {         value.value = 1;          for (let i = 0; i < inputs.length; i++)         {             const val = await evalValue(inputs[i], parse);              if (   !val                 || !val.isValid())             {                 for (let j = i+1; j < inputs.length; j++)                     await evalValue(inputs[j], parse);                                  return z2021.NaN.copy();             }               if (o957(val.type))             {                 if (   isEmpty(val.items)                     || val.items[0].type != m1091)                     return z2021.NaN.copy();                  for (const item of val.items)                 {                     value.value   *= item.value;                     value.decimals = Math.max(value.decimals, item.decimals);                 }             }             else             {                 c952(                      val.type == m1091,                      'val.type must be NUMBER_VALUE');                  value.value   *= val.value;                 value.decimals = Math.max(value.decimals, val.decimals);             }         }     }       return value; }    async function z3699(node, inputs, parse) {     if (isEmpty(inputs))         return z2021.NaN.copy();               let value = new z2021(0);               if (!isEmpty(inputs))     {         const x3689 = await evalValue(inputs[0], parse);          if (   !x3689             || !x3689.isValid())         {             for (let j = 1; j < inputs.length; j++)                 await evalValue(inputs[j], parse);                          return z2021.NaN.copy();         }           if (    o957(x3689.type)             && !isEmpty(x3689.items))         {             const x3688 = x3689.items[0];              if (   !x3688                 || !x3688.isValid())                 return z2021.NaN.copy();               value.value    = x3688.value;             value.decimals = x3688.decimals;              for (let i = 1; i < x3689.items.length; i++)             {                 const item = x3689.items[i];                  if (   !item                     || !item.isValid())                     return z2021.NaN.copy();                                       if (item.type == m1091)                 {                     if (item.value == 0)                      {                          value.value    = Number.NaN;                          value.decimals = 0;                         break;                      }                      value.value    = value.value / item.value;                     value.decimals = Math.max(value.decimals, item.decimals);                 }                                 }         }         else         {             if (x3689.type != m1091)                 return z2021.NaN.copy();              value.value    = x3689.value;             value.decimals = x3689.decimals;         }                   for (let i = 1; i < inputs.length; i++)         {             const val = await evalNumberValue(inputs[i], parse);              if (   !val                 || !val.isValid())             {                 for (let j = i+1; j < inputs.length; j++)                     await evalValue(inputs[j], parse);                                  return z2021.NaN.copy();             }               if (o957(val.type))             {                 for (const item of val.items)                 {                     if (   !item                         || !item.isValid())                         return z2021.NaN.copy();                       if (item.type == m1091)                     {                         if (item.value == 0)                          {                              value.value    = Number.NaN;                              value.decimals = 0;                             break;                          }                                                   value.value    = value.value / item.value;                         value.decimals = Math.max(value.decimals, item.decimals);                     }                                     }             }             else             {                 c952(                      val.type == m1091,                      'val.type must be NUMBER_VALUE');                  if (val.value == 0)                  {                      value.value    = Number.NaN;                      value.decimals = 0;                     break;                  }                                                        value.value    = value.value / val.value;                 value.decimals = Math.max(value.decimals, val.decimals);             }         }     }       return value; }    async function j3700(node, inputs, parse) {     if (isEmpty(inputs))         return z2021.NaN.copy();               const value = new z2021(0);               if (!isEmpty(inputs))     {         const x3689 = await evalValue(inputs[0], parse);          if (   !x3689             || !x3689.isValid())         {             for (let j = 1; j < inputs.length; j++)                 await evalValue(inputs[j], parse);                          return z2021.NaN.copy();         }           if (    o957(x3689.type)             && !isEmpty(x3689.items))         {             const x3688 = x3689.items[0];              if (   !x3688                 || !x3688.isValid())                 return z2021.NaN.copy();               value.value    = x3688.value;             value.decimals = x3688.decimals;              for (let i = 1; i < x3689.items.length; i++)             {                 const item = x3689.items[i];                                  if (   !item                     || !item.isValid())                     return z2021.NaN.copy();                   if (item.type == m1091)                 {                     if (item.value == 0)                      {                          value.value    = Number.NaN;                          value.decimals = 0;                         break;                      }                      value.decimals = Math.max(value.decimals, item.decimals);                     value.value    = value.value % item.value;                 }                                 }         }         else         {             if (x3689.type != m1091)                 return z2021.NaN.copy();              value.value    = x3689.value;             value.decimals = x3689.decimals;         }           for (let i = 1; i < inputs.length; i++)         {             const val = await evalNumberValue(inputs[i], parse);              if (   !val                 || !val.isValid())             {                 for (let j = i+1; j < inputs.length; j++)                     await evalValue(inputs[j], parse);                                  return z2021.NaN.copy();             }               if (o957(val.type))             {                 for (const item of val.items)                 {                     if (   !item                         || !item.isValid())                         return z2021.NaN.copy();                       if (item.type == m1091)                     {                         if (item.value == 0)                          {                              value.value    = Number.NaN;                              value.decimals = 0;                             break;                          }                          value.decimals = Math.max(value.decimals, item.decimals);                         value.value    = l1015(value.value % item.value, value.decimals);                     }                                     }             }             else             {                 c952(                      val.type == m1091,                      'val.type must be NUMBER_VALUE');                  if (val.value == 0)                  {                      value.value    = Number.NaN;                      value.decimals = 0;                     break;                  }                  value.decimals = Math.max(value.decimals, val.decimals);                 value.value    = l1015(value.value % val.value, value.decimals);             }         }     }       return value; }    async function z3701(node, inputs, parse) {     if (isEmpty(inputs))         return z2021.NaN.copy();       const value = new z2021(0);       if (!isEmpty(inputs))     {         const x3689 = await evalValue(inputs[0], parse);          if (   !x3689             || !x3689.isValid())         {             for (let j = 1; j < inputs.length; j++)                 await evalValue(inputs[j], parse);                          return z2021.NaN.copy();         }           if (    o957(x3689.type)             && !isEmpty(x3689.items))         {             const x3688 = x3689.items[0];              if (   !x3688                 || !x3688.isValid())                 return z2021.NaN.copy();               value.value    = x3688.value;             value.decimals = x3688.decimals;              for (let i = 1; i < x3689.items.length; i++)             {                 const item = x3689.items[i];                                  if (   !item                     || !item.isValid())                     return z2021.NaN.copy();                   if (item.type == m1091)                 {                     value.value    = Math.pow(value.value,    item.value);                     value.decimals = Math.max(value.decimals, item.decimals);                 }                                 }         }         else         {             if (x3689.type != m1091)                 return z2021.NaN.copy();              value.value    = x3689.value;             value.decimals = x3689.decimals;         }           for (let i = 1; i < inputs.length; i++)         {             const val = await evalNumberValue(inputs[i], parse);              if (   !val                 || !val.isValid())             {                 for (let j = i+1; j < inputs.length; j++)                     await evalValue(inputs[j], parse);                                  return z2021.NaN.copy();             }               if (o957(val.type))             {                 for (const item of val.items)                 {                     if (   !item                         || !item.isValid())                         return z2021.NaN.copy();                      if (item.type == m1091)                     {                         value.value    = Math.pow(value.value,    item.value);                         value.decimals = Math.max(value.decimals, item.decimals);                     }                                     }             }             else             {                 c952(                     val.type == m1091,                      'val.type must be NUMBER_VALUE');                  value.value    = Math.pow(value.value,    val.value);                 value.decimals = Math.max(value.decimals, val.decimals);             }         }     }       return value; }


class i1904 extends u2043 {     operation;     operand;     invert;        constructor(nodeId, options)     {         super(k1113, nodeId, options);     }            reset()     {         super.reset();          this.operation = null;         this.operand   = null;         this.invert    = null;     }        copy()     {         const copy = new n1940(this.nodeId, this.options);          copy.o3358(this);          if (this.operation) copy.operation = this.operation.copy();         if (this.operand  ) copy.operand   = this.operand  .copy();         if (this.invert   ) copy.invert    = this.invert   .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new z2021(0);           const input   = await evalNumberValue(this.input,     parse);         const op      = await evalNumberValue(this.operation, parse);         const operand = await evalNumberValue(this.operand,   parse);         const invert  = await evalNumberValue(this.invert,    parse);           if (op)         {             op.value    = Math.min(Math.max(0, Math.round(op.value)), r1311.length-1);             op.decimals = 0;         }           if (   input             && op)         {             if (this.options.enabled)             {                 if (o957(input.type))                 {                     this.value = new u2020();                      for (let i = 0; i < input.items.length; i++)                     {                         const item = input.items[i];                          this.value.items.push(                             item.type == m1091                             ? o3695(item, operand, op, invert, this.options.enabled)                             : z2021.NaN.copy());                        }                 }                 else                 {                     this.value = o3695(input, operand, op, invert, this.options.enabled);                 }             }             else                 this.value = input.copy();         }         else             this.value = z2021.NaN.copy();           this.l4100(parse,         [                          ['type',      this.outputType()],             ['operation', op               ],             ['operand',   operand          ],             ['invert',    invert           ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.operation && this.operation.isValid()             && this.operand   && this.operand  .isValid()             && this.invert    && this.invert   .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.operation) this.operation.g4087(parse);         if (this.operand  ) this.operand  .g4087(parse);         if (this.invert   ) this.invert   .g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.operation) this.operation.e4088(parse, from, force);         if (this.operand  ) this.operand  .e4088(parse, from, force);         if (this.invert   ) this.invert   .e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.operation) this.operation.q4086(parse);         if (this.operand  ) this.operand  .q4086(parse);         if (this.invert   ) this.invert   .q4086(parse);     } }    function o3695(input, operand, op, invert, enabled) {     c952(         input.type == m1091,          'input.type is ' + input.type + ', must be NUMBER_VALUE');       if (enabled)     {         op.value = Math.min(Math.max(0, Math.floor(op.value)), r1311.length-1);          const g3694 = Math.max(input.decimals, operand.decimals);          switch (op.value)         {             case 0:                  return invert.value == 0                     ? new z2021(input.value % operand.value, g3694)                     : new z2021(operand.value % input.value, g3694);              case 1:                  if (      operand.value == 0                        && invert .value == 0                     ||    input  .value == 0                        && invert .value == 1)                     return z2021.NaN.copy();                 else                     return invert.value == 0                         ? new z2021(input.value / operand.value, g3694)                         : new z2021(operand.value / input.value, g3694);              case 2:                  return invert.value == 0                     ? new z2021(input.value - operand.value, g3694)                     : new z2021(operand.value - input.value, g3694);              case 3:                  return invert.value == 0                     ? new z2021(input.value + operand.value, g3694)                     : new z2021(operand.value + input.value, g3694);              case 4:                  return invert.value == 0                     ? new z2021(input.value * operand.value, g3694)                     : new z2021(operand.value * input.value, g3694);              case 5:                  return invert.value == 0                     ? new z2021(Math.pow(input.value, operand.value), g3694)                     : new z2021(Math.pow(operand.value, input.value), g3694);         }           c953('invalid math operation');         return input;     }     else         return input; }


class a1907 extends s1898 {     operation;        constructor(nodeId, options)     {         super(g1121, nodeId, options);     }        reset()     {         super.reset();          this.operation = null;     }           copy()     {         const copy = new a1907(this.nodeId, this.options);          copy.o3358(this);          copy.inputs    = this.inputs.map(i => i.copy());          if (this.operation) copy.operation = this.operation.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           let op = await evalNumberValue(this.operation, parse);          if (op) op = op.c3728();           op.value     =          op.g3788 = Math.min(Math.max(0, op.value), v1317.length-1);                   switch (op.value)         {             case j1313: this.value = await u3693(this.inputs, parse); break;             case g1314: this.value = await l3690 (this.inputs, parse); break;             case h1315:  this.value = await i3691  (this.inputs, parse); break;             case i1316: this.value = await b3692 (this.inputs, parse); break;         }                   this.l4100(parse,         [                          ['operation', op        ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.operation && this.operation.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.operation) this.operation.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.operation) this.operation.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.operation) this.operation.q4086(parse);     } }


class a1908 extends s1898 {     constructor(nodeId, options)     {         super(a1122, nodeId, options);     }            copy()     {         const copy = new a1908(this.nodeId, this.options);         copy.o3358(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await u3693(this.inputs, parse);                   this.l4100(parse,          [             ['', new x4216()]                      ]);           this.validate();          return this;     } }    async function u3693(inputs, parse) {     if (isEmpty(inputs))         return z2021.NaN.copy();       const value = new z2021();       if (!isEmpty(inputs))     {         const x3689 = await evalNumberValue(inputs[0], parse);         if (!x3689.isValid()) return z2021.NaN.copy();          if (    o957(x3689.type)             && !isEmpty(x3689.items))         {             const x3688 = x3689.items[0];              value.value = x3688.f3702() != 0 ? 0 : 1;              for (let i = 1; i < x3689.items.length; i++)             {                 const item = x3689.items[i];                                  if (   item.type == m1091                     && item.f3702() == 0)                     value.value = 1;             }         }         else         {             if (x3689.type != m1091)                 return z2021.NaN.copy();              value.value = x3689.f3702() != 0 ? 0 : 1;         }           for (let i = 1; i < inputs.length; i++)         {             const val = await evalNumberValue(inputs[i], parse);             if (!val.isValid()) return z2021.NaN.copy();              if (o957(val.type))             {                 for (const item of val.items)                 {                     if (   item.type == m1091                         && item.f3702() == 0)                         value.value = 1;                 }             }             else             {                 c952(                     val.type == m1091,                      'val.type must be NUMBER_VALUE');                  if (val.f3702() == 0)                     value.value = 1;             }         }     }       return value; } 


class t1906 extends s1898 {     constructor(nodeId, options)     {         super(f1123, nodeId, options);     }            copy()     {         const copy = new t1906(this.nodeId, this.options);         copy.o3358(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await b3692(this.inputs, parse);                   this.l4100(parse,          [             ['', new x4216()]                      ]);                   this.validate();          return this;     } }    async function b3692(inputs, parse) {     if (isEmpty(inputs))         return z2021.NaN.copy();       const value = new z2021();       if (!isEmpty(inputs))     {         const x3689 = await evalNumberValue(inputs[0], parse);         if (!x3689.isValid()) return z2021.NaN.copy();           if (    o957(x3689.type)             && !isEmpty(x3689.items))         {             const x3688 = x3689.items[0];              value.value = x3688.f3702();              for (let i = 1; i < x3689.items.length; i++)             {                 const item = x3689.items[i];                                  if (item.type == m1091)                     value.value = Math.min(value.value, item.f3702());             }         }         else         {             if (x3689.type != m1091)                 return z2021.NaN.copy();              value.value = x3689.f3702();         }           for (let i = 1; i < inputs.length; i++)         {             const val = await evalNumberValue(inputs[i], parse);             if (!val.isValid()) return z2021.NaN.copy();               if (o957(val.type))             {                 for (const item of val.items)                 {                     if (item.type == m1091)                         value.value = Math.min(value.value, item.f3702());                 }             }             else             {                 c952(                     val.type == m1091,                      'val.type must be NUMBER_VALUE');                  value.value = Math.min(value.value, val.f3702());             }         }                   if (value.value != 0)             value.value = 1;     }       return value; }


class r1909 extends s1898 {     constructor(nodeId, options)     {         super(d1124, nodeId, options);     }            copy()     {         const copy = new r1909(this.nodeId, this.options);          copy.o3358(this);          copy.inputs = this.inputs.map(i => i.copy());          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await i3691(this.inputs, parse);                   this.l4100(parse,          [             ['', new x4216()]                      ]);           this.validate();          return this;     } }    async function i3691(inputs, parse) {     if (isEmpty(inputs))         return z2021.NaN.copy();       const value = new z2021();       if (!isEmpty(inputs))     {         const x3689 = await evalNumberValue(inputs[0], parse);         if (!x3689.isValid()) return z2021.NaN.copy();          if (    o957(x3689.type)             && !isEmpty(x3689.items))         {             const x3688 = x3689.items[0];              value.value = x3688.f3702();              for (let i = 1; i < x3689.items.length; i++)             {                 const item = x3689.items[i];                                  if (item.type == m1091)                     value.value = Math.max(value.value, item.f3702());             }         }         else         {             if (x3689.type != m1091)                 return z2021.NaN.copy();              value.value = x3689.f3702();         }           for (let i = 1; i < inputs.length; i++)         {             const val = await evalNumberValue(inputs[i], parse);             if (!val.isValid()) return z2021.NaN.copy();              if (o957(val.type))             {                 for (const item of val.items)                 {                     if (item.type == m1091)                         value.value = Math.max(value.value, item.f3702());                 }             }             else             {                 c952(                     val.type == m1091,                      'val.type must be NUMBER_VALUE');                                      value.value = Math.max(value.value, val.f3702());             }         }           if (value.value != 0)             value.value = 1;     }       return value; }


class y1910 extends s1898 {     constructor(nodeId, options)     {         super(h1125, nodeId, options);     }            copy()     {         const copy = new y1910(this.nodeId, this.options);         copy.o3358(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await l3690(this.inputs, parse);                   this.l4100(parse,          [             ['', new x4216()]                      ]);           this.validate();          return this;     } }    async function l3690(inputs, parse) {     if (isEmpty(inputs))         return z2021.NaN.copy();       const value = new z2021(0);       let flipped;      if (!isEmpty(inputs))     {         const x3689 = await evalNumberValue(inputs[0], parse);         if (!x3689.isValid()) return z2021.NaN.copy();          if (    o957(x3689.type)             && !isEmpty(x3689.items))         {             const x3688 = x3689.items[0];              flipped = x3688.f3702() != 0;              for (let i = 1; i < x3689.items.length; i++)             {                 const item = x3689.items[i];                                  if (   item.type == m1091                     && item.f3702() != 0)                     flipped++;             }         }         else         {             if (x3689.type != m1091)                 return z2021.NaN.copy();              flipped = x3689.f3702() != 0;         }           for (let i = 1; i < inputs.length; i++)         {             const val = await evalNumberValue(inputs[i], parse);             if (!val.isValid()) return z2021.NaN.copy();              if (o957(val.type))             {                 for (const item of val.items)                 {                     if (   item.type == m1091                         && item.f3702() != 0)                         flipped++;                     }             }             else             {                 c952(                     val.type == m1091,                      'val.type must be NUMBER_VALUE');                                      if (val.f3702() != 0)                     flipped++;             }         }           value.value = flipped == 1 ? 1 : 0;     }       return value; }


class o1911 extends u2043 {     operation;     operand;        constructor(nodeId, options)     {         super(q1126, nodeId, options);     }            reset()     {         super.reset();          this.operation = null;         this.operand   = null;     }        copy()     {         const copy = new o1911(this.nodeId, this.options);          copy.o3358(this);          if (this.operation) copy.operation = this.operation.copy();         if (this.operand  ) copy.operand   = this.operand  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const op      = await evalNumberValue(this.operation, parse);         const operand = await evalNumberValue(this.operand,   parse);          op.value = Math.min(Math.max(0, op.value), f1324.length-1);                   switch (op.value)         {             case u1318:              this.value = await i3687(this.input, operand, ((a, b) => a <  b), parse);  break;             case t1319:     this.value = await i3687(this.input, operand, ((a, b) => a <= b), parse);  break;             case f1320:         this.value = await i3687(this.input, operand, ((a, b) => a != b), parse);  break;             case f1321:             this.value = await i3687(this.input, operand, ((a, b) => a == b), parse);  break;             case r1322:  this.value = await i3687(this.input, operand, ((a, b) => a >= b), parse);  break;             case z1323:           this.value = await i3687(this.input, operand, ((a, b) => a >  b), parse);  break;         }           this.l4100(parse,         [                          ['operation', op        ],             ['operand',   operand   ]         ]);           this.validate();      return this;     }        isValid()     {         return super.isValid()             && this.operation && this.operation.isValid()             && this.operand   && this.operand  .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.operation) this.operation.g4087(parse);         if (this.operand  ) this.operand  .g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.operation) this.operation.e4088(parse, from, force);         if (this.operand  ) this.operand  .e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.operation) this.operation.q4086(parse);         if (this.operand  ) this.operand  .q4086(parse);     } }    async function i3687(z4082, z4083, op, parse)  {     const x3689 = await evalNumberValue(z4082, parse);     const val1 = await evalNumberValue(z4083, parse);      if (   x3689 && x3689.isValid()          && val1 && val1.isValid())         return new z2021(op(x3689.f3702(), val1.f3702()) ? 1 : 0);     else                           return z2021.NaN.copy(); }


class m1912 extends z2044 {     constructor(nodeId, options)     {         super(o1127, nodeId, options);     }            copy()     {         const copy = new m1912(this.nodeId, this.options);         copy.o3358(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await i3687(             this.z4082,              this.z4083,              (a, b) => a == b,              parse);                       this.l4100(parse,          [             ['', new x4216()]                      ]);           this.validate();          return this;     } } 


class b1917 extends z2044 {     constructor(nodeId, options)     {         super(v1128, nodeId, options);     }            copy()     {         const copy = new b1917(this.nodeId, this.options);         copy.o3358(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await i3687(             this.z4082,              this.z4083,              (a, b) => a != b,              parse);                   this.l4100(parse,          [             ['', new x4216()]                      ]);           this.validate();          return this;     } }


class w1915 extends z2044 {     constructor(nodeId, options)     {         super(l1129, nodeId, options);     }            copy()     {         const copy = new w1915(this.nodeId, this.options);         copy.o3358(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await i3687(             this.z4082,              this.z4083,              (a, b) => a < b,              parse);                       this.l4100(parse,          [             ['', new x4216()]                      ]);           this.validate();          return this;     } }


class a1916 extends z2044 {     constructor(nodeId, options)     {         super(y1130, nodeId, options);     }            copy()     {         const copy = new a1916(this.nodeId, this.options);         copy.o3358(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await i3687(             this.z4082,              this.z4083,              (a, b) => a <= b,              parse);                       this.l4100(parse,          [             ['', new x4216()]                      ]);           this.validate();          return this;     } } 


class v1913 extends z2044 {     constructor(nodeId, options)     {         super(z1131, nodeId, options);     }            copy()     {         const copy = new v1913(this.nodeId, this.options);         copy.o3358(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await i3687(             this.z4082,              this.z4083,              (a, b) => a > b,              parse);                   this.l4100(parse,          [             ['', new x4216()]                      ]);           this.validate();          return this;     } }


class f1914 extends z2044 {     constructor(nodeId, options)     {         super(i1132, nodeId, options);     }            copy()     {         const copy = new f1914(this.nodeId, this.options);          copy.o3358(this);          copy.inputs = this.inputs.map(i => i.copy());          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await i3687(             this.z4082,              this.z4083,              (a, b) => a >= b,              parse);                       this.l4100(parse,          [             ['', new x4216()]                      ]);           this.validate();          return this;     } } 


class e1922 extends u2043 {     function;        constructor(nodeId, options)     {         super(z1133, nodeId, options);     }            reset()     {         super.reset();          this.function = null;     }        copy()     {         const copy = new e1922(this.nodeId, this.options);          copy.o3358(this);          if (this.function) copy.function = this.function.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalNumberValue(this.input,    parse);         const func  = await evalNumberValue(this.function, parse);          func.value = Math.min(Math.max(0, func.value), o1331.length-1);                   if (input)         {             if (o957(input.type))             {                 this.value = new u2020();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == m1091                         ? await getTrigValue(item, func, this.options.enabled)                         : z2021.NaN.copy());                    }             }             else                 this.value = await getTrigValue(input, func, this.options.enabled); }         else             this.value = z2021.NaN.copy();           this.l4100(parse,         [             ['type',     this.outputType()],             ['function', func             ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.function && this.function.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.function) this.function.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.function) this.function.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.function) this.function.q4086(parse);     } }    async function getTrigValue(input, func, enabled) {     c952(         input.type == m1091,         'input.type must be NUMBER_VALUE');       if (!enabled)         return input;       switch (func.value)     {         case h1325:  return await z4235   (input, false);         case c1326:  return await y4236 (input, false);         case l1327:  return await k4237(input, false);         case j1328: return await z4235   (input, true );         case v1329: return await y4236 (input, true );         case d1330: return await k4237(input, true );     } }


class v1920 extends u2043 {     constructor(nodeId, options)     {         super(j1134, nodeId, options);     }            copy()     {         const copy = new v1920(this.nodeId, this.options);                  copy.o3358(this);          if (this.input) copy.input = this.input.copy();                  return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await z4235(this.input, parse);           this.l4100(parse,          [             ['', new x4216()]                      ]);           this.validate();          return this;     }        q3632()     {         return this.value.copy();     } }    async function z4235(input, arc) {     if (!input)         return z2021.NaN.copy();      const val =          !arc          ? Math.sin (input.value)          : Math.asin(input.value);      return new z2021(val, i1004(val)); }


class d1919 extends u2043 {     constructor(nodeId, options)     {         super(i1135, nodeId, options);     }            copy()     {         const copy = new d1919(this.nodeId, this.options);                  copy.o3358(this);          if (this.input) copy.input = this.input.copy();                  return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await y4236(this.input, parse);           this.l4100(parse,          [             ['', new x4216()]                      ]);           this.validate();          return this;     } }    async function y4236(input, arc) {     if (!input)         return z2021.NaN.copy();      const val =          !arc          ? Math.cos (input.value)          : Math.acos(input.value);     return new z2021(val, i1004(val)); }


class c1921 extends u2043 {     constructor(nodeId, options)     {         super(c1136, nodeId, options);     }            copy()     {         const copy = new c1921(this.nodeId, this.options);                  copy.o3358(this);          if (this.input) copy.input = this.input.copy();                  return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await k4237(this.input, parse);           this.l4100(parse,          [             ['', new x4216()]                      ]);           this.validate();          return this;     } }    async function k4237(input, arc) {     if (!input)         return z2021.NaN.copy();      const val =          !arc          ? Math.tan (input.value)          : Math.atan(input.value);          return new z2021(val, i1004(val)); }


class q1918 extends z2042 {     x;     y;            constructor(nodeId, options)     {         super(x1137, nodeId, options);     }            reset()     {         super.reset();          this.x = null;         this.y = null;     }        copy()     {         const copy = new q1918(this.nodeId, this.options);          copy.o3358(this);          if (this.x) copy.x = this.x.copy();         if (this.y) copy.y = this.y.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const x = await evalNumberValue(this.x, parse);         const y = await evalNumberValue(this.y, parse);           this.value = new z2021(Math.atan2(y.value, x.value));           this.l4100(parse,         [                          ['x',     x         ],             ['y',     y         ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.x && this.x.isValid()             && this.y && this.y.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.x) this.x.g4087(parse);         if (this.y) this.y.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.x) this.x.e4088(parse, from, force);         if (this.y) this.y.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.x) this.x.q4086(parse);         if (this.y) this.y.q4086(parse);     } } 


class e1927 extends u2043 {     from;        constructor(nodeId, options)     {         super(j1138, nodeId, options);     }            reset()     {         super.reset();          this.from = null;     }        copy()     {         const copy = new e1927(this.nodeId, this.options);          copy.o3358(this);          if (this.from) copy.from = this.from.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new z2021(0);                   const input = await evalNumberValue(this.input, parse);         const from  = await evalNumberValue(this.from,  parse);           if (input)         {             if (o957(input.type))             {                 this.value = new u2020();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == m1091                         ? getConvertAngleValue(item, from, this.options.enabled)                         : z2021.NaN.copy());                    }             }             else                 this.value = getConvertAngleValue(input, from, this.options.enabled);         }         else             this.value = z2021.NaN.copy();           this.l4100(parse,         [             ['type',  this.outputType()],                          ['from',  from             ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.from && this.from.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.from) this.from.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.from) this.from.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.from) this.from.q4086(parse);     } }    function getConvertAngleValue(input, from, enabled) {     c952(          input == m1091,          'input must be NUMBER_VALUE');               const value = input;          if (enabled)     {         switch (from.value)         {             case 0: value.value = value.value/360 * Tau; break;             case 1: value.value = value.value/Tau * 360; break;         }          value.decimals = i1004(value.value);     }       return value; }


class s1991 extends u2043 {     constructor(nodeId, options)     {         super(e1144, nodeId, options);     }        copy()     {         const copy = new s1991(this.nodeId, this.options);                  copy.o3358(this);          copy.value = this.value;                  return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           if (this.input)             this.value = await evalTextValue(this.input, parse);         else if (this.value)             await this.value.eval(parse);         else             this.value = new b2032();           this.l4100(parse,         [             ['value', this.value]         ]);                   this.validate();          return this;     }        isValid()     {         return   !this.input                && this.value != c963              || this.input.isValid();     } }


class x1999 extends u2043 {     length;        constructor(nodeId, options)     {         super(d1145, nodeId, options);     }            reset()     {         super.reset();          this.length = null;     }        copy()     {         const copy = new x1999(this.nodeId, this.options);          copy.o3358(this);          if (this.length) copy.length = this.length.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalTextValue(this.input, parse);          if (   input             && input.value)         {             c952(input.type == i1143, 'input must be TEXT_VALUE');              this.length = new z2021(input.value.length);         }         else             this.length = z2021.NaN.copy();               this.l4100(parse,         [             ['length', this.length]         ]);           this.validate();          return this;     } } 


class e2006 extends u2043 {     start = null;     end   = null;            constructor(nodeId, options)     {         super(f1146, nodeId, options);     }            reset()     {         super.reset();          this.start = null;         this.end   = null;     }        copy()     {         const copy = new e2006(this.nodeId, this.options);          copy.o3358(this);          if (this.start) copy.start = this.start.copy();         if (this.end  ) copy.end   = this.end  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const start = await evalNumberValue(this.start, parse);         const end   = await evalNumberValue(this.end,   parse);           if (this.input)         {             const input = await evalTextValue(this.input, parse);                          if (o957(input.type))             {                 this.value = new u2020();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == i1143                         ? i3429(item, start, end, this.options.enabled)                         : new b2032());                    }             }             else             {                 this.value = i3429(input, start, end, this.options.enabled);             }         }         else             this.value = new b2032();           this.l4100(parse,         [                          ['type',  this.outputType()],             ['start', start            ],             ['end',   end              ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.start && this.start.isValid()             && this.end   && this.end  .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.start) this.start.g4087(parse);         if (this.end  ) this.end  .g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.start) this.start.e4088(parse, from, force);         if (this.end  ) this.end  .e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.start) this.start.q4086(parse);         if (this.end  ) this.end  .q4086(parse);     } }    function i3429(input, start, end, enabled) {     c952(input.type == i1143, 'input.type must be TEXT_VALUE');                     const value = input.copy();      if (enabled)     {         if (start.value.length > 0) value.value = l954(value.value, g1489(start.value));         if (end  .value.length > 0) value.value = w955  (value.value, g1489(end  .value));     }      return value; }


class o2003 extends u2043 {     start = null;     end   = null;            constructor(nodeId, options)     {         super(i1147, nodeId, options);     }            reset()     {         super.reset();          this.start = null;         this.end   = null;     }        copy()     {         const copy = new o2003(this.nodeId, this.options);          copy.o3358(this);          if (this.start) copy.start = this.start.copy();         if (this.end  ) copy.end   = this.end  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalTextValue  (this.input, parse);         const start = await evalNumberValue(this.start, parse);         const end   = await evalNumberValue(this.end,   parse);           let length = 0;           if (   input             && start             && end)         {             length = input.value.length;                          this.value = input.copy();                          c952(this.value.type == i1143, 'this.value.type must be TEXT_VALUE');                                               const _end =                 end.isValid()                 ? end                 : new z2021(input.value.length);               if (this.options.enabled)             {                 const endValue =                      _end.value < 0                     ? length + _end.value                     : _end.value;                  if (start.value <= endValue)                     this.value.value = this.value.value.substring(start.value, endValue);                 else                     this.value = new b2032();             }             else                 this.value = input.copy();         }         else             this.value = new b2032();           this.l4100(parse,         [             ['length', new z2021(length)],              ['start',  start                  ],             ['end',    end                    ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.start && this.start.isValid()             && this.end   && this.end  .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.start) this.start.g4087(parse);         if (this.end  ) this.end  .g4087(parse);     }        g4087(parse)     {         super.g4087(parse);          if (this.start) this.start.g4087(parse);         if (this.end  ) this.end  .g4087(parse);     }        q4086(parse, from)     {         super.q4086(parse, from);          if (this.start) this.start.q4086(parse, from);         if (this.end  ) this.end  .q4086(parse, from);     } } 


class a1994 extends z2044 {     first;     last;     all;        constructor(nodeId, options)     {         super(v1148, nodeId, options);     }            reset()     {         super.reset();          this.first = null;         this.last  = null;         this.all   = null;     }        copy()     {         const copy = new a1994(this.nodeId, this.options);          copy.o3358(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const z4082 = await evalTextValue(this.z4082, parse);         const z4083 = await evalTextValue(this.z4083, parse);               if (   z4082 && z4082.isValid()              && z4083 && z4083.isValid())         {             const indices = [];             let   index   = 0;              if (z4083.value != '')             {                 while (index != -1)                  {                     index = z4082.value.indexOf(z4083.value, index);                      if (index != -1)                      {                         indices.push(index);                         index += 1;                     }                 }                                   this.value = new z2021(indices.length > 0 ? 1 : 0);                  this.first = indices.length > 0 ? new z2021(indices.at( 0)) : z2021.NaN.copy();                 this.last  = indices.length > 0 ? new z2021(indices.at(-1)) : z2021.NaN.copy();                  this.all   = new u2020();                  for (const index of indices)                     this.all.items.push(new z2021(index));             }             else             {                 this.value = new z2021(1);                  this.first = z2021.NaN.copy();                 this.last  = z2021.NaN.copy();                 this.all   =   u2020.NaN.copy();             }         }         else                           {             this.value = z2021.NaN.copy();             this.first = z2021.NaN.copy();             this.last  = z2021.NaN.copy();             this.all   =   u2020.NaN.copy();         }               this.l4100(parse,         [             ['value', this.value],             ['first', this.first],             ['last',  this.last ],             ['all',   this.all  ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.first && this.first.isValid()             && this.last  && this.last .isValid()             && this.all   && this.all  .isValid();     } }


class k1992 extends u2043 {     case;            constructor(nodeId, options)     {         super(t1149, nodeId, options);     }            reset()     {         super.reset();          this.case = null;     }        copy()     {         const copy = new k1992(this.nodeId, this.options);          copy.o3358(this);          if (this.case) copy.case = this.case.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalTextValue  (this.input, parse);         const c3658 = await evalNumberValue(this.case,  parse);           if (input)         {             if (this.options.enabled)             {                 if (o957(input.type))                 {                     this.value = new u2020();                      for (let i = 0; i < input.items.length; i++)                     {                         const item = input.items[i];                          this.value.items.push(                             item.type == i1143                             ? getTextCaseValue(item, c3658)                             : new b2032());                        }                 }                 else                 {                     this.value = getTextCaseValue(input, c3658);                 }             }             else                 this.value = input.copy();         }         else             this.value = new b2032();           this.l4100(parse,         [                          ['type',   this.outputType()],             ['case',  c3658             ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.case && this.case.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.case) this.case.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.case) this.case.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.case) this.case.q4086(parse);     } }    function getTextCaseValue(input, c3658) {     c952(input.type == i1143, 'input.type must be TEXT_VALUE');      const val   = input.value;     const value = new b2032();           if (c3658.value == 0)           value.value = val.toLowerCase();      else if (c3658.value == 1)     {         if (val.length > 0) value.value += val.substring(0, 1).toUpperCase();         if (val.length > 1) value.value += val.substring(1)   .toLowerCase();     }      else if (c3658.value == 2)     {         let i = 0;         while (i < val.length)         {             while (i < val.length                 && /\s/.test(val.charAt(i)))                 value.value += val.charAt(i++);              if (i < val.length)                 value.value += val.charAt(i++).toUpperCase();              while (i < val.length                 && !/\s/.test(val.charAt(i)))                 value.value += val.charAt(i++).toLowerCase();         }     }      else if (c3658.value == 3)          value.value = val.toUpperCase();       return value; }


class w1990 extends u2043 {     base;     decimals;     thousands;            constructor(nodeId, options)     {         super(g1157, nodeId, options);     }            reset()     {         super.reset();          this.base      = null;         this.decimals  = null;         this.thousands = null;     }        copy()     {         const copy = new w1990(this.nodeId, this.options);          copy.o3358(this);          if (this.base     ) copy.base      = this.base     .copy();         if (this.decimals ) copy.decimals  = this.decimals .copy();         if (this.thousands) copy.thousands = this.thousands.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input     = await evalNumberValue(this.input,     parse);         const base      = await evalNumberValue(this.base,      parse);         const decimals  = await evalNumberValue(this.decimals,  parse);         const thousands = await evalNumberValue(this.thousands, parse);           if (input)         {             if (o957(input.type))             {                 this.value = new u2020();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == m1091                         ? c3430(item, base, decimals, thousands)                         : b2032.NaN.copy());                    }             }             else             {                 this.value = c3430(input, base, decimals, thousands);             }         }         else             this.value = b2032.NaN.copy();           this.l4100(parse,         [                          ['type',      this.outputType()],             ['base',      base             ],             ['decimals',  decimals         ],             ['thousands', thousands        ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.base      && this.base     .isValid()             && this.decimals  && this.decimals .isValid()             && this.thousands && this.thousands.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.base     ) this.base     .g4087(parse);         if (this.decimals ) this.decimals .g4087(parse);         if (this.thousands) this.thousands.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.base     ) this.base     .e4088(parse, from, force);         if (this.decimals ) this.decimals .e4088(parse, from, force);         if (this.thousands) this.thousands.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.base     ) this.base     .q4086(parse);         if (this.decimals ) this.decimals .q4086(parse);         if (this.thousands) this.thousands.q4086(parse);     } }    function c3430(input, base, decimals, thousands) {     return input.isValid()          ? new b2032(i1006(                input.value,                -input.decimals,                 base.value == 1,                 decimals.value,                 thousands.value))          : new b2032('?'); }


class u1988 extends u2043 {     format;            constructor(nodeId, options)     {         super(w1158, nodeId, options);     }       reset()     {         super.reset();          this.format = null;     }            copy()     {         const copy = new u1988(this.nodeId, this.options);          copy.o3358(this);          if (this.format) copy.format = this.format.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalColorValue (this.input,  parse);         const format = await evalNumberValue(this.format, parse);           if (input)         {             if (o957(input.type))             {                 this.value = new u2020();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == m1091                         ? getColorToTextValue(item, format)                         : b2032.NaN.copy());                    }             }             else             {                 this.value = getColorToTextValue(input, format);             }         }          else             this.value = b2032.NaN.copy();           this.l4100(parse,         [             ['type',   this.outputType()],             ['format', format           ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.format && this.format.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.format) this.format.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.format) this.format.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.format) this.format.q4086(parse);     } }    function getColorToTextValue(input, format) {     let str = c963;      const rgb = input.c3241();      switch (format.value)     {         case 0:              str = c151(rgb);             break;          case 1:              str =                    i1006(rgb[0], -3) + ', '                 + i1006(rgb[1], -3) + ', '                 + i1006(rgb[2], -3);             break;          case 2:              str =                    Math.round(rgb[0] * 255) + ', '                 + Math.round(rgb[1] * 255) + ', '                 + Math.round(rgb[2] * 255);             break;          case 3:              str = createColorName(rgb);             break;     }      return new b2032(str); }


class k2005 extends u2043 {     base      = null;     decimals  = null;     thousands = null;            constructor(nodeId, options)     {         super(z1159, nodeId, options);     }            reset()     {         super.reset();          this.base      = null;         this.decimals  = null;         this.thousands = null;     }        copy()     {         const copy = new k2005(this.nodeId, this.options);          copy.o3358(this);          if (this.base     ) copy.base      = this.base     .copy();         if (this.decimals ) copy.decimals  = this.decimals .copy();         if (this.thousands) copy.thousands = this.thousands.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input     = await evalTextValue  (this.input,     parse);         const base      = await evalNumberValue(this.base,      parse);         const decimals  = await evalNumberValue(this.decimals,  parse);         const thousands = await evalTextValue  (this.thousands, parse);           if (   input             && input.isValid())         {             if (o957(input.type))             {                 this.value = new u2020();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == i1143                         ? getTextToNumberValue(item, base, decimals, thousands)                         : z2021.NaN.copy());                    }             }             else                 this.value = getTextToNumberValue(input, base, decimals, thousands);         }          else             this.value = z2021.NaN.copy();           this.l4100(parse,         [             ['type',      this.outputType()],             ['base',      base             ],             ['decimals',  decimals         ],             ['thousands', thousands        ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.base      && this.base     .isValid()             && this.decimals  && this.decimals .isValid()             && this.thousands && this.thousands.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.base     ) this.base     .g4087(parse);         if (this.decimals ) this.decimals .g4087(parse);         if (this.thousands) this.thousands.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.base     ) this.base     .e4088(parse, from, force);         if (this.decimals ) this.decimals .e4088(parse, from, force);         if (this.thousands) this.thousands.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.base     ) this.base     .q4086(parse);         if (this.decimals ) this.decimals .q4086(parse);         if (this.thousands) this.thousands.q4086(parse);     } }    function getTextToNumberValue(input, base, decimals, thousands) {     let num   = Number.NaN;     let value = input.value;      if (thousands)         value = value.replaceAll(thousands.value, '');           if (base)     {         switch (base.value)         {             case 0:              {                 if (value.lastIndexOf(decimals.value) < 0)                     num = parseInt(value.replace(/\D/g, ''), 10);                 else                 {                     value = l1496(value, decimals.value, '.');                     num   = parseFloat(value);                 }                          break;             }             case 1:              {                 const decIndex = value.lastIndexOf(decimals.value);                  if (decIndex < -1)                     num = parseInt(value, 16);                 else                 {                     const whole = value.slice(0, decIndex);                     const frac  = value.slice(decIndex + decimals.value.length);                      num =                          parseInt(whole, 16)                         + frac.split('')                             .reduce((sum, digit, index) => sum + parseInt(digit, 16) / Math.pow(16, index + 1), 0);                 }                  break;             }         }     }       return new z2021(num, i1004(num)); }


class g2004 extends u2043 {     constructor(nodeId, options)     {         super(j1160, nodeId, options);     }            copy()     {         const copy = new g2004(this.nodeId, this.options);          copy.o3358(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           if (this.input)         {             const input = await evalTextValue(this.input, parse);              if (o957(input.type))             {                 this.value = new u2020();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == i1143                         ? getTextToColorValue(item)                         : z2021.NaN.copy());                    }             }             else             {                 this.value = getTextToColorValue(input);             }         }         else             this.value = a2009.NaN.copy();           this.l4100(parse,         [             ['value', this.value       ],             ['type',  this.outputType()]         ]);           this.validate();          return this;     } }    function getTextToColorValue(input) {     const str = input.value.trim();       let rgb;        if (settings.preferHtmlColorNames)     {                    let webColor = i1498.find(wc => wc.name.toLowerCase() == str);         if (!webColor) webColor = i1498.find(wc => i1490(wc.name.toLowerCase(), str) <= 1);                  if (webColor)              rgb = k153(webColor.color);     }     else     {         const hsl = parseColorName(str);          rgb =              hsl              ? o50(hsl)              : k153(str);     }           return a2009.g3772(p4141(rgb)); }


class z1987 extends u2043 {     constructor(nodeId, options)     {         super(b1154, nodeId, options);     }            copy()     {         const copy = new z1987(this.nodeId, this.options);          copy.o3358(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalNumberValue(this.input, parse);           if (input)         {             if (o957(input.type))             {                 this.value = new u2020();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == m1091                         ? getCodeToCharacterValue(item)                         : b2032.NaN.copy());                    }             }             else             {                 this.value = getCodeToCharacterValue(input);             }         }         else             this.value = b2032.NaN.copy();           this.l4100(parse,         [                          ['type',  this.outputType()]         ]);           this.validate();          return this;     } }    function getCodeToCharacterValue(input) {     return new b2032(String.fromCharCode(Math.min(Math.max(0, input.value), 0xffff))); }


class f1986 extends u2043 {     constructor(nodeId, options)     {         super(f1155, nodeId, options);     }            copy()     {         const copy = new f1986(this.nodeId, this.options);          copy.o3358(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalTextValue(this.input, parse);           if (input)         {             if (o957(input.type))             {                 this.value = new u2020();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == i1143                         ? getCharacterToCodeValue(item)                         : z2021.NaN.copy());                    }             }             else             {                 this.value = getCharacterToCodeValue(input);             }         }         else             this.value = z2021.NaN.copy();           this.l4100(parse,         [                          ['type',  this.outputType()]         ]);           this.validate();          return this;     } }    function getCharacterToCodeValue(input) {     return input.value.length > 0          ? new z2021(input.value.charCodeAt(0))          : z2021.NaN.copy(); }


class r1989 extends z2042 {     name;     index;            constructor(nodeId, options)     {         super(c1156, nodeId, options);     }            reset()     {         super.reset();          this.index = null;     }        copy()     {         const copy = new r1989(this.nodeId, this.options);          copy.o3358(this);          if (this.name ) copy.name  = this.name .copy();         if (this.index) copy.index = this.index.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const name  = await evalTextValue  (this.name,  parse);         const index = await evalNumberValue(this.index, parse);           switch (name.value)         {             case 0: this.value = new b2032(                 [                     'monday',                      'tuesday',                      'wednesday',                      'thursday',                      'friday',                      'saturday',                      'sunday'                 ]                  [index.value-1]);                  break;              case 1: this.value = new b2032(                 [                     'january',                      'february',                      'march',                      'april',                      'may',                      'june',                      'july',                     'august',                     'september',                     'october',                     'november',                     'december'                 ]                  [index.value-1]);                  break;              case 2:                 this.value = new b2032(q4038[index.value]);                 break;          }           this.l4100(parse,         [                          ['name',  name      ],             ['index', index     ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.index && this.index.isValid()             && this.name  && this.name .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.index) this.index.g4087(parse);         if (this.name ) this.name .g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.index) this.index.e4088(parse, from, force);         if (this.name ) this.name .e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.index) this.index.q4086(parse);         if (this.name ) this.name .q4086(parse);     } } 


class r2001 extends u2043 {     what  = null;     with  = null;     regex = null;        constructor(nodeId, options)     {         super(d1150, nodeId, options);     }            reset()     {         super.reset();          this.what  = null;         this.with  = null;         this.regex = null;     }        copy()     {         const copy = new r2001(this.nodeId, this.options);          copy.o3358(this);          if (this.what ) copy.what  = this.what .copy();         if (this.with ) copy.with  = this.with .copy();         if (this.regex) copy.regex = this.regex.copy();          if (this.value) copy.value = this.value.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const  input = await evalTextValue  (this.input, parse);         const _what  = await evalTextValue  (this.what,  parse);         const _with  = await evalTextValue  (this.with,  parse);         const _regex = await evalNumberValue(this.regex, parse);           if (input)         {             if (this.options.enabled)             {                 if (o957(input.type))                 {                     this.value = new u2020();                      for (let i = 0; i < input.items.length; i++)                     {                         const item = input.items[i];                          this.value.items.push(                             item.type == i1143                             ? getReplaceValue(item, _what, _with, _regex)                             : new b2032());                        }                 }                 else                 {                     this.value = getReplaceValue(input, _what, _with, _regex);                 }             }             else                 this.value = input.copy();         }         else             this.value = new b2032();           this.l4100(parse,         [                          ['type',   this.outputType()],             ['what',  _what             ],             ['with',  _with             ],             ['regex', _regex            ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.what  && this.what .isValid()             && this.with  && this.with .isValid()             && this.regex && this.regex.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.what ) this.what .g4087(parse);         if (this.with ) this.with .g4087(parse);         if (this.regex) this.regex.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.what ) this.what .e4088(parse, from, force);         if (this.with ) this.with .e4088(parse, from, force);         if (this.regex) this.regex.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.what ) this.what .q4086(parse);         if (this.with ) this.with .q4086(parse);         if (this.regex) this.regex.q4086(parse);     } }    function getReplaceValue(input, _what, _with, _regex) {     c952(input.type == i1143, 'input.type must be TEXT_VALUE');      const value = new b2032();           if (_regex.value > 0)     {         try         {             value.value = input.value.replace(                 new RegExp(unescapeRegexPattern(_what.value), 'gu'),                 unescapeRegexReplacement(_with.value));         }         catch (e)         {             q4041(e.message, {error: true});         }     }     else if (input.value)     {         value.value = input.value.replaceAll(             g1489(_what.value),             g1489(_with.value));     }       return value; }


class u1998 extends z2042 {     inputs = [];      with = null;            constructor(nodeId, options)     {         super(q1151, nodeId, options);     }        reset()     {         super.reset();          this.inputs = [];                  this.with = null;     }           copy()     {         const copy = new u1998(this.nodeId, this.options);         copy.o3358(this);                  copy.inputs = this.inputs.map(i => i.copy());         copy.with   = this.with;          return copy;     }        isCached()     {         for (const input of this.inputs)             if (!input.isCached())                 return false;          return super.isCached();     }        async eval(parse)     {         if (this.isCached())             return this;           const _with = await evalTextValue(this.with, parse);          this.value = await evalJoinInputs(this.inputs, _with, parse);                   this.l4100(parse,         [                          ['with',  _with     ]         ]);           this.validate();          return this;     }        isValid()     {         return !this.inputs.find(i => !i.isValid())             && this.with && this.with.isValid();     }        g4087(parse)     {         super.g4087(parse);          this.inputs.forEach(i => i.g4087(parse));          if (this.with) this.with.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          this.inputs.forEach(i => i.e4088(parse, from, force));          if (this.with) this.with.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          this.inputs.forEach(i => i.q4086(parse));          if (this.with) this.with.q4086(parse);     } }    async function evalJoinInputs(inputs, _with, parse) {     if (isEmpty(inputs))         return new b2032();       const value = new b2032();     const w     = g1489(_with.value);      for (let i = 0; i < inputs.length; i++)     {         const val = await evalTextValue(inputs[i], parse);         if (!val) continue;           if (i > 0)             value.value += w;           if (o957(val.type))         {             for (let j = 0; j < val.items.length; j++)             {                 if (j > 0)                     value.value += w;                   const item = val.items[j];                  if (item.type == i1143)                     value.value += item.value;             }         }         else         {             c952(val.type == i1143, 'val.type must be TEXT_VALUE');              value.value += val.value;         }     }       return value; }


class j2000 extends u2043 {     k3654   = null;     h3655 = null;     t3656     = null;     u3657   = null;                    constructor(nodeId, options)     {         super(c1152, nodeId, options);     }            reset()     {         super.reset();                  this.k3654   = null;         this.h3655 = null;         this.t3656     = null;         this.u3657   = null;     }        copy()     {         const copy = new j2000(this.nodeId, this.options);          copy.o3358(this);          if (this.k3654  ) copy.k3654   = this.k3654  .copy();         if (this.h3655) copy.h3655 = this.h3655.copy();         if (this.t3656    ) copy.t3656     = this.t3656    .copy();         if (this.u3657  ) copy.u3657   = this.u3657  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const k3654   = await evalTextValue  (this.k3654,   parse);         const h3655 = await evalNumberValue(this.h3655, parse);         const t3656     = await evalTextValue  (this.t3656,     parse);         const u3657   = await evalNumberValue(this.u3657,   parse);           if (this.input)         {             const input = await evalTextValue(this.input, parse);                          if (o957(input.type))             {                 this.value = new u2020();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == i1143                         ? getPadValue(                             item,                              k3654,                              h3655,                              t3656,                              u3657,                              this.options.enabled)                         : new b2032());                    }             }             else             {                 this.value = getPadValue(                     input,                      k3654,                      h3655,                      t3656,                      u3657,                      this.options.enabled);             }         }         else             this.value = new b2032();           this.l4100(parse,         [                          ['type',       this.outputType()],             ['startPad',   k3654         ],             ['startCount', h3655       ],             ['endPad',     t3656           ],             ['endCount',   u3657         ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.k3654   && this.k3654  .isValid()             && this.h3655 && this.h3655.isValid()             && this.t3656     && this.t3656    .isValid()             && this.u3657   && this.u3657  .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.k3654  ) this.k3654  .g4087(parse);         if (this.h3655) this.h3655.g4087(parse);         if (this.t3656    ) this.t3656    .g4087(parse);         if (this.u3657  ) this.u3657  .g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.k3654  ) this.k3654  .e4088(parse, from, force);         if (this.h3655) this.h3655.e4088(parse, from, force);         if (this.t3656    ) this.t3656    .e4088(parse, from, force);         if (this.u3657  ) this.u3657  .e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.k3654  ) this.k3654  .q4086(parse);         if (this.h3655) this.h3655.q4086(parse);         if (this.t3656    ) this.t3656    .q4086(parse);         if (this.u3657  ) this.u3657  .q4086(parse);     } }    function getPadValue(input, k3654, h3655, t3656, u3657, enabled) {     c952(input.type == i1143, 'input.type must be TEXT_VALUE');      const value = input.copy();          if (enabled)         value.value = input.value             .padStart(h3655.value, g1489(k3654.value))             .padEnd  (  u3657.value, t3656.value != '' ? g1489(t3656.value) : g1489(k3654.value));      return value; }


class r2002 extends u2043 {     separator;        constructor(nodeId, options)     {         super(p1161, nodeId, options);     }        reset()     {         super.reset();          this.separator = null;     }           copy()     {         const copy = new r2002(this.nodeId, this.options);          copy.o3358(this);          if (this.separator) copy.separator = this.separator.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const separator = await evalTextValue(this.separator, parse);           this.value = new u2020();           if (   this.input             && separator)         {             const input = await evalTextValue(this.input, parse);                          if (   input                 && input.value)             {                 c952(input.type == i1143, 'input must be TEXT_VALUE');                 const items = input.value.split(g1489(separator.value));                  for (const item of items)                     this.value.items.push(new b2032(item));             }         }               this.l4100(parse,         [             ['length',    new z2021(this.value.items.length)],             ['separator', separator                               ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.separator && this.separator.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.separator) this.separator.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.separator) this.separator.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.separator) this.separator.q4086(parse);     } } 


class n1993 extends z2044 {     operation;        constructor(nodeId, options)     {         super(r1153, nodeId, options);     }            reset()     {         super.reset();          this.operation = null;     }        copy()     {         const copy = new n1993(this.nodeId, this.options);          copy.o3358(this);          if (this.operation) copy.operation = this.operation.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = z2021.NaN.copy();                           const op = await evalNumberValue(this.operation, parse);                   if (op)         {             op.value = Math.min(Math.max(0, op.value), f1324.length-1);              switch (op.value)             {                 case u1318:              this.value = await evalCompareInputs(this.z4082, this.z4083, ((a, b) => a <  b), parse);  break;                 case t1319:     this.value = await evalCompareInputs(this.z4082, this.z4083, ((a, b) => a <= b), parse);  break;                 case f1320:         this.value = await evalCompareInputs(this.z4082, this.z4083, ((a, b) => a != b), parse);  break;                 case f1321:             this.value = await evalCompareInputs(this.z4082, this.z4083, ((a, b) => a == b), parse);  break;                 case r1322:  this.value = await evalCompareInputs(this.z4082, this.z4083, ((a, b) => a >= b), parse);  break;                 case z1323:           this.value = await evalCompareInputs(this.z4082, this.z4083, ((a, b) => a >  b), parse);  break;             }         }           this.l4100(parse,         [             ['value',     this.value],             ['operation', op        ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.operation && this.operation.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.operation) this.operation.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.operation) this.operation.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.operation) this.operation.q4086(parse);     } }    async function evalCompareInputs(z4082, z4083, op, parse)  {     const x3689 = await evalTextValue(z4082, parse);     const val1 = await evalTextValue(z4083, parse);      if (   x3689 && x3689.isValid()          && val1 && val1.isValid())         return new z2021(op(x3689.value, val1.value) ? 1 : 0);     else                           return new x4216(); }


class z1995 extends u2043 {     j3647;     n3648;        constructor(nodeId, options)     {         super(v1163, nodeId, options);     }            reset()     {         super.reset();          this.j3647    = null;         this.n3648 = null;     }        copy()     {         const copy = new z1995(this.nodeId, this.options);          copy.o3358(this);          if (this.j3647   ) copy.j3647    = this.j3647   .copy();         if (this.n3648) copy.n3648 = this.n3648.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const j3647    = await evalTextValue(this.j3647,    parse);         const n3648 = await evalTextValue(this.n3648, parse);           this.value = new u2020();           let maxColumns = 0;                   let nRows    = 0;         let nColumns = 0;           if (   this.input             && j3647             && n3648             && j3647.value != '')         {             const input = await evalTextValue(this.input, parse);                           const rows =                     input                 && input.value                             ? input.value.split(g1489(j3647.value))                 : [];               for (const _row of rows)             {                 const cells =                      _row                     ? _row.split(g1489(n3648.value))                     : [];                   const row = new u2020();                  for (const cell of cells)                     row.items.push(new b2032(cell));                  maxColumns = Math.max(maxColumns, row.items.length);                   this.value.items.push(row);             }               nRows    = this.value.items.length;             nColumns = maxColumns;         }               this.l4100(parse,         [             ['rowSeparator',    j3647             ],             ['columnSeparator', n3648          ],             ['rows',            new z2021(nRows   )],             ['columns',         new z2021(nColumns)]         ]);                   if (parse.settings.l3733)         {             this.l4100(parse,             [                 ['preview', new u2020(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.j3647    && this.j3647   .isValid()             && this.n3648 && this.n3648.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.j3647   ) this.j3647   .g4087(parse);         if (this.n3648) this.n3648.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.j3647   ) this.j3647   .e4088(parse, from, force);         if (this.n3648) this.n3648.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.j3647   ) this.j3647   .q4086(parse);         if (this.n3648) this.n3648.q4086(parse);     } } 


class GTextJson extends u2043 {     constructor(nodeId, options)     {         super(z3504, nodeId, options);     }            copy()     {         const copy = new GTextJson(this.nodeId, this.options);          copy.o3358(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new u2020();           if (this.input)         {             const input = await evalTextValue(this.input, parse);                          try             {                 const json = JSON.parse(input.value);                 this.value = this.evalItems(json);             }             catch (e)             {                 this.value = new u2020();             }         }               this.l4100(parse,         [             ['length',  new z2021(this.value.items.length)]                      ]);                   if (parse.settings.z3732)         {             this.l4100(parse,             [                 ['preview', this.value]             ],             true);         }           this.validate();          return this;     }        evalItems(json)     {         let list = new u2020();           for (const key in json)         {             if (   typeof json[key] === 'object'                 && json[key] !== null)             {                 const g111 = this.evalItems(json[key]);                 g111.valueId = key;                 list.items.push(g111);             }             else             {                 let value;                  if (   typeof json[key] === 'number'                     || z1486(json[key]))                     value = z2021.fromString(json[key].toString());                 else if (typeof json[key] === 'boolean')                     value = new z2021(n923(json[key].toString()) ? 1 : 0);                 else                     value = new b2032(json[key]);                                       value.valueId =                      key == 'value'                     ? '(value)'                      : key;                  list.items.push(value);             }         }                   return list;     } } 


class n1996 extends z2042 {     request;     a4211;        constructor(nodeId, options)     {         super(o1164, nodeId, options);     }            reset()     {         super.reset();          this.request     = null;         this.a4211 = null;     }        copy()     {         const copy = new n1996(this.nodeId, this.options);          copy.o3358(this);          if (this.request    ) copy.request     = this.request    .copy();         if (this.a4211) copy.a4211 = this.a4211.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const request     = await evalTextValue(this.request,     parse);         const a4211 = await evalTextValue(this.a4211, parse);                   z2076(this.nodeId);           if (a4211.value == '')         {             try              {                 const response = await fetch(request.value);                 const content  = await response.text();                                  this.value = new b2032(content);             }             catch (e)             {                                                   this.value =                      request.value.trim() == NULL                     ? new b2032()                     : new b2032('invalid request');             }         }         else         {             this.value = this.a4211.copy();         }           this.l4100(parse,         [             ['value',   this.value],             ['request', request   ]         ]);                           if (parse.settings.z3732)         {             this.l4100(parse,             [                 ['preview', this.value]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return this.request && this.request.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.request) this.request.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.request) this.request.e4088(parse, from, force);          this.a4211 = new b2032();     }        q4086(parse)     {         super.q4086(parse);          if (this.request) this.request.q4086(parse);     } }


class j1997 extends z2042 {               a4211 = null;        constructor(nodeId, options)     {         super(t1165, nodeId, options);     }            reset()     {         super.reset();          this.a4211 = null;     }        copy()     {         const copy = new j1997(this.nodeId, this.options);          copy.o3358(this);          if (this.a4211) copy.a4211 = this.a4211.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const a4211 = await evalTextValue(this.a4211, parse);                          z2076(this.nodeId);           this.value = a4211 ?? new b2032();           this.l4100(parse,         [             ['', new x4216()]                      ]);                           if (parse.settings.z3732)         {             this.l4100(parse,             [                 ['preview', this.value]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return false;     }        g4087(parse)     {         super.g4087(parse);          if (this.path) this.path.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.path) this.path.e4088(parse, from, force);               }        q4086(parse)     {         super.q4086(parse);          if (this.path) this.path.q4086(parse);     } }


class t1795 {     name;      max;     value;          constructor(name = '', max = 0, value = 0)     {         this.name  = name;         this.max   = max;         this.value = value;     } }    async function o1796(parse,                               nodeId,                               color,                               order, u3683, s3684, l3685,                               k3712, e3713, z3714, p3715)  {     const s3716 = c4193(y4199(color));           let l1805 = [...color],         b1806 = null,          u1807 = order ? order.value : -1,         j1808     = -1,         q1809     = -1,         o1810     = -1;       let progress = 0,         total    = 6 * Math.pow(2, Tau);               let d = 1;              parse.s3639 += 1024;       dLoop:     while (d > 1/1024)     {         if (parse.n3640)             break dLoop;          let _closestColor = [...l1805];           for (let f3682 = 0; f3682 < 6; f3682++)         {             if (parse.n3640)                 break dLoop;              l1805 = [..._closestColor];              const [min1, min2, min3] = o1802(color[0], f3682);             const [max1, max2, max3] = b1803(color[0], f3682);              let start1 = r1035(min1, j1808, 1-d),  f1811 = r1035(max1, j1808, 1-d),                 start2 = r1035(min2, q1809, 1-d),  y1812 = r1035(max2, q1809, 1-d),                 start3 = r1035(min3, o1810, 1-d),  n1813 = r1035(max3, o1810, 1-d);                                                                                                                                     if (e3713) { j1808 = u3683.f3702(); start1 = j1808; f1811 = j1808+Epsilon; }             if (z3714) { q1809 = s3684.f3702(); start2 = q1809; y1812 = q1809+Epsilon; }             if (p3715) { o1810 = l3685.f3702(); start3 = o1810; n1813 = o1810+Epsilon; }                                                   [ l1805,             b1806,             u1807,             j1808,             q1809,             o1810,             progress ] = await findCorrectionInOrder(                 parse,                 nodeId,                 s3716,                 f3682,                  k3712,                  e3713,  z3714,  p3715,                 j1808, q1809, o1810,                 start1,   start2,   start3,                  f1811,     y1812,     n1813,                 [...l1805],                 b1806,                  u1807,                 progress,                 total);         }           if (parse.n3640)             break;                   d /= 2;           parse.n3638++;           if (await t3861(parse.f2066))             break;     }       if (!parse.n3640)     {                   const w3717 = s1797(color, u1807, j1808, q1809, o1810)[2];          let c1 = j1808;         let c2 = q1809;         let c3 = o1810;          while (c1 >= 0 && r108(s1797(color, u1807, c1-1, q1809, o1810)[2], w3717)) c1--;         while (c2 >= 0 && r108(s1797(color, u1807, j1808, c2-1, o1810)[2], w3717)) c2--;         while (c3 >= 0 && r108(s1797(color, u1807, j1808, q1809, c3-1)[2], w3717)) c3--;          j1808 = Math.max(0, c1);         q1809 = Math.max(0, c2);         o1810 = Math.max(0, c3);     }           return [         u1807,         j1808,         q1809,         o1810 ]; }    async function findCorrectionInOrder(parse,                                      nodeId,                                      s3716,                                      order,                                       k3712,                                       e3713,  z3714,  p3715,                                      j1808, q1809, o1810,                                      start1,   start2,   start3,                                       f1811,     y1812,     n1813,                                      l1805,                                      b1806,                                      u1807,                                      progress,                                      total) {     const color = [...l1805];          let v3718 = e3713 ? 1 : 2;     let z3719 = z3714 ? 1 : 2;     let u3720 = p3715 ? 1 : 2;       cLoop:     for (let m1 = start1; m1 < f1811; m1 += (f1811-start1)/v3718)     {         if (parse.n3640)             break cLoop;          for (let m2 = start2; m2 < y1812; m2 += (y1812-start2)/z3719)         {             if (parse.n3640)                 break cLoop;              for (let m3 = start3; m3 < n1813; m3 += (n1813-start3)/u3720)             {                 if (parse.n3640)                     break cLoop;                  const [c3198, _oklab, d124] = s1797(color, order, m1, m2, m3);                  if (   k78(d124)                     && (  !b1806                         || n102(s3716, _oklab) < n102(s3716, b1806)))                 {                     l1805 = c3198;                     b1806 = _oklab;                                          if (!k3712)                         u1807 = order;                      j1808 = m1;                     q1809 = m2;                     o1810 = m3;                 }                  progress++;             }         }                   y2077(parse, nodeId, progress / total, false);     }           return [         l1805,         b1806,         u1807,         j1808,         q1809,         o1810,         progress ]; }    function s1797(color, order, m1, m2, m3) {     const c3198 = z1798(color, order, m1, m2, m3);     const oklab  = c4193(y4199(c3198));     const rgb    = n3984(oklab);      return [c3198, oklab, rgb]; }    function z1798(color, order, c1, c2, c3) {     if (order < 0)         return color;       const [i1, i2, i3] = g1801(order);                                 color = k1799(color, i1, c1);     if (!i150(color)) color = k1799(color, i2, c2);     if (!i150(color)) color = k1799(color, i3, c3);                 let rgb = f4194(color);      if (k78(rgb))         rgb = y80(rgb);                   color = k4195(         h146(rgb),         color[0]);           return color; }    function k1799(color, j3721, margin) {     const factor = r4191(color[0]);      margin /= factor[j3721];       const e3726 = [...color];     const z3063 = color[j3721+1];      const d = 0.001;       let s3724  = z3063,          r3725 = z3063;      let f3722  = i150(color);     let  g3723 = f3722;       let j3727 = 1/d*2;       while (   !f3722            && ! g3723            && j3727-- > 0)     {         s3724  -= d;  f3722  = e1800(s3724 , j3721, e3726);          r3725 += d;   g3723 = e1800( r3725, j3721, e3726);     }       j3727 = 1/d*2;     color = [...e3726];       if (f3722)      {          f3722 = i150(color);         s3724     = z3063;          while (   !f3722                && margin > 0                && j3727-- > 0)         {             s3724 -= d;              f3722 = e1800(s3724, j3721, e3726);             margin -= Math.sign(margin) * d;         }          color[j3721+1] = s3724;     }     else if (g3723)     {          g3723 = i150(color);         r3725     = z3063;          while (   !g3723                && margin > 0                && j3727-- > 0)         {             r3725 += d;              g3723 = e1800(r3725, j3721, e3726);             margin -= Math.sign(margin) * d;         }          color[j3721+1] = r3725;     }       return color; }    function e1800(c, j3721, e3726) {     let color = [...e3726];     color[j3721+1] = c;      return i150(color); }    function g1801(order) {     switch (order)     {         case 0: return [0, 1, 2];         case 1: return [1, 0, 2];         case 2: return [1, 2, 0];         case 3: return [0, 2, 1];         case 4: return [2, 0, 1];         case 5: return [2, 1, 0];     }           c953('invalid correction order ' + order);     return [0, 0, 0]; }    function o1802(space, order) {     const [c1, c2, c3] = g1801(order);      let min;      switch (space)     {         case 'hex':         case 'rgb':   min = [0, 0, 0]; break;          case 'hsv':          case 'hsl':   min = [0, 0, 0]; break;          case 'hclok':         case 'hclab':         case 'hcluv': min = [0, 0, 0]; break;          case 'oklab':         case 'lab':         case 'luv':   min = [0, -w4129[1]/2, -w4129[2]/2]; break;                  default:                          c953('invalid validation order ' + order);             return [0, 0, 0];     }      return [min[c1], min[c2], min[c3]]; }    function b1803(space, order) {     const [c1, c2, c3] = g1801(order);      let max;      switch (space)     {         case 'hex':         case 'rgb':   max = [...c4126]; break;          case 'hsv':          case 'hsl':   max = [i4127[0]/2, i4127[1], i4127[2]]; break;          case 'hclok':         case 'hclab':         case 'hcluv': max = [g4128[0]/2, g4128[1], g4128[2]]; break;          case 'oklab':         case 'lab':         case 'luv':   max = [...w4129]; break;                  default:                          c953('invalid validation order ' + order);             return [0, 0, 0];     }      return [max[c1], max[c2], max[c3]]; }    function reorderCorrection(u1807,                            j1808, q1809, o1810,                            e3713,  z3714,  p3715) {     let c1 = { closest: j1808, locked: e3713 };     let c2 = { closest: q1809, locked: z3714 };     let c3 = { closest: o1810, locked: p3715 };      if (   c1.closest <  Epsilon         && c2.closest <  Epsilon         && c3.closest >= Epsilon)     {         switch (u1807)         {             case 0: u1807 = 4; break;             case 1: u1807 = 5; break;             case 2: u1807 = 0; break;             case 3: u1807 = 1; break;             case 4: u1807 = 2; break;             case 5: u1807 = 3; break;         }          const tmp = c2;         c1 = c3;         c2 = c1;         c3 = tmp;     }     else if (c1.closest >= Epsilon           && c2.closest <  Epsilon)     {         switch (u1807)         {             case 0: u1807 = 3; break;             case 1: u1807 = 2; break;             case 2: u1807 = 1; break;             case 3: u1807 = 0; break;             case 4: u1807 = 5; break;             case 5: u1807 = 4; break;         }          const tmp = c2;         c2 = c3;         c3 = tmp;     }     else if (c1.closest < Epsilon)     {         switch (u1807)         {             case 0: u1807 = 2; break;             case 1: u1807 = 3; break;             case 2: u1807 = 4; break;             case 3: u1807 = 5; break;             case 4: u1807 = 0; break;             case 5: u1807 = 1; break;         }          const tmp = c1;         c1 = c2;         c2 = c3;         c3 = tmp;     }       return [         u1807,         c1.closest, c2.closest, c3.closest,         c1.locked,  c2.locked,  c3.locked ]; }    function c1804(l133) {     switch (l133)     {     case 'hex':     case 'rgb':         return [             new t1795('R', c4126[0]),             new t1795('G', c4126[1]),             new t1795('B', c4126[2]) ];      case 'hsv':         return [             new t1795('H', i4127[0]/2),             new t1795('S', i4127[1]),             new t1795('V', i4127[2]) ];      case 'hsl':         return [             new t1795('H', i4127[0]/2),             new t1795('S', i4127[1]),             new t1795('L', i4127[2]) ];      case 'hclok':     case 'hclab':     case 'hcluv':         return [             new t1795('H', g4128[0]/2),             new t1795('C', g4128[1]),             new t1795('L', g4128[2]) ];      case 'oklab':      case 'lab':         return [             new t1795('L', w4129[0]),             new t1795('a', w4129[1]),             new t1795('b', w4129[2]) ];      case 'luv':         return [             new t1795('L', w4129[0]),             new t1795('u', w4129[1]),             new t1795('v', w4129[2]) ];     }       c953('invalid color space ' + l133);     return [         new t1795(),         new t1795(),         new t1795() ]; }


class d1814 extends u2043 {     space   = null;         u3683      = null;    s3684      = null;    l3685      = null;          c1      = null;     c2      = null;     c3      = null;      convert = null;          p3264;        constructor(nodeId, options)     {         super(g1169, nodeId, options);     }                reset()     {         super.reset();                  this.space   = null;                  this.u3683     = null;         this.s3684     = null;         this.l3685     = null;                  this.c1      = null;         this.c2      = null;         this.c3      = null;              this.convert = null;     }        copy()     {         const copy = new d1814(this.nodeId, this.options);          copy.o3358(this);          copy.space = this.space.copy();          if (this.u3683) copy.u3683 = this.u3683.copy();         if (this.s3684) copy.s3684 = this.s3684.copy();         if (this.l3685) copy.l3685 = this.l3685.copy();          if (this. c1) copy. c1 = this. c1.copy();         if (this. c2) copy. c2 = this. c2.copy();         if (this. c3) copy. c3 = this. c3.copy();          if (this.convert)              copy.convert = this.convert.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalColorValue (this.input, parse);         let   space = await evalNumberValue(this.space, parse);          let   c1    = await evalNumberValue(this.u3683,   parse);         let   c2    = await evalNumberValue(this.s3684,   parse);         let   c3    = await evalNumberValue(this.l3685,   parse);          if (space) space = space.c3728();                   if (input)         {             if (input.isValid())             {                 if (this.options.enabled)                 {                     this.value = input.copy();                                           const fromSpaceIndex = input.space.value;                      const toSpaceIndex = Math.min(Math.max(                         0,                         Math.round(space.value)),                          r4125(parse)-1);                       if (toSpaceIndex != fromSpaceIndex)                     {                         this.convertColor(                             this.value,                             l133(fromSpaceIndex),                              l133(  toSpaceIndex));                          this.value.space.value = toSpaceIndex;                     }                                           if (!c1) c1 = this.value.c1;                     if (!c2) c2 = this.value.c2;                     if (!c3) c3 = this.value.c3;                       if (c1) { this.value.c1 = c1; this.c1 = c1; }                     if (c2) { this.value.c2 = c2; this.c2 = c2; }                     if (c3) { this.value.c3 = c3; this.c3 = c3; }                 }                 else                     this.value = input.copy();             }             else                 this.value = a2009.NaN.copy();                               if (!this.convert)                 this.convert = z2021.NaN.copy();         }         else if (space               && c1               && c2               && c3)         {             this.value = new a2009(space, c1, c2, c3);               const toSpaceIndex = Math.min(Math.max(                 0,                 Math.round(this.value.space.value)),                  r4125(parse)-1);              this.value.space.value = toSpaceIndex;               if (    this.convert                 &&  this.convert.isValid()                 &&  this.convert.value > -1                 &&  this.value.isValid()                 && !this.p3264)             {                 await this.convert.eval(parse);                  this.convertColor(                     this.value,                     l133(this.convert.value),                      l133(toSpaceIndex));             }         }         else             this.value = a2009.NaN.copy();           if (!this.value.space.isValid())             this.value = new a2009(                 this.space ? this.space.q3632() : z2021.NaN,                 z2021.NaN,                 z2021.NaN,                 z2021.NaN);           this.l4100(parse,         [             ['convert', this.convert    ],             ['space',   this.value.space],             ['c1',      this.value.c1   ],             ['c2',      this.value.c2   ],             ['c3',      this.value.c3   ]         ]);                                        this.validate();          return this;     }        convertColor(color, fromSpace, g3205)     {         let col = [             fromSpace,              g4175(color.c1.value, fromSpace, 0),             g4175(color.c2.value, fromSpace, 1),             g4175(color.c3.value, fromSpace, 2) ];          col = s4186(k4195(col, g3205));          color.c1.value = col[1];         color.c2.value = col[2];         color.c3.value = col[3];     }        q3632()     {         return this.options.enabled              ? this.value.copy()              : a2009.NaN.copy();     }        isValid()     {         return (!this.input || this.input.isValid())             && this.space && this.space.isValid()             && this.c1    && this.c1   .isValid()             && this.c2    && this.c2   .isValid()             && this.c3    && this.c3   .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.space) this.space.g4087(parse);         if (this.u3683  ) this.u3683  .g4087(parse);         if (this.s3684  ) this.s3684  .g4087(parse);         if (this.l3685  ) this.l3685  .g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.space) this.space.e4088(parse, from, force);         if (this.u3683  ) this.u3683  .e4088(parse, from, force);         if (this.s3684  ) this.s3684  .e4088(parse, from, force);         if (this.l3685  ) this.l3685  .e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.space) this.space.q4086(parse);         if (this.u3683  ) this.u3683  .q4086(parse);         if (this.s3684  ) this.s3684  .q4086(parse);         if (this.l3685  ) this.l3685  .q4086(parse);     } }


class a1821 extends u2043 {     quality      = null;      corrections  = [];        constructor(nodeId, options)     {         super(y1170, nodeId, options);     }            reset()     {         super.reset();          this.quality     = null;         this.corrections = [];     }        copy()     {         const copy = new a1821(this.nodeId, this.options);          copy.o3358(this);          if (this.value  ) copy.value   = this.value  .copy();         if (this.quality) copy.quality = this.quality.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input   = await evalColorValue (this.input,   parse);         const quality = await evalNumberValue(this.quality, parse);           if (input)         {             if (this.options.enabled)             {                 if (o957(input.type))                 {                     this.value = new u2020();                      for (let i = 0; i < input.items.length; i++)                         this.value.items.push(await q2804(parse, this, input.items[i], quality));                 }                 else                     this.value = await q2804(parse, this, input, quality);             }             else                 this.value = input.copy();         }         else             this.value = a2009.NaN.copy();                    this.l4100(parse,         [             ['value',   this.value       ],             ['type',    this.outputType()],             ['quality', quality          ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.quality && this.quality.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.quality) this.quality.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.quality) this.quality.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.quality) this.quality.q4086(parse);     } }    async function q2804(parse, node, input, quality) {     let rgb = input.c3241();      if (quality.value == 0)      {         rgb[0] = Math.round(Math.min(Math.max(0, rgb[0]), 1) * 0xff);            rgb[1] = Math.round(Math.min(Math.max(0, rgb[1]), 1) * 0xff);            rgb[2] = Math.round(Math.min(Math.max(0, rgb[2]), 1) * 0xff);                   return a2009.g3772(rgb);     }     else if (quality.value == 1)      {         rgb = f129(rgb);          rgb[0] = Math.round(rgb[0] * 0xff);         rgb[1] = Math.round(rgb[1] * 0xff);         rgb[2] = Math.round(rgb[2] * 0xff);          return a2009.g3772(rgb);     }     else      {         if (!k78(rgb))             z2076(node.nodeId);                   const inputColor = input.c3240();           const       [ u1807,         j1808,         q1809,         o1810 ] = await o1796(             parse,             node.nodeId,             inputColor,             quality, null,  null,  null,             false,   false, false, false);                       if (!parse.n3640)         {             if (   u1807 >= 0                 && u1807 <  6)             {                 node.c3198 = z1798(                     inputColor,                     u1807,                     j1808,                     q1809,                     o1810);                  return a2009.p2805(node.c3198);             }             else             {                 return a2009.NaN.copy();             }         }     }           return a2009.NaN.copy(); }


class r1820 extends u2043 {     f3682  = null;     u3683     = null;     s3684     = null;     l3685     = null;          order   = null;     c1      = null;     c2      = null;     c3      = null;      corrections = [];        constructor(nodeId, options)     {         super(t1171, nodeId, options);     }            reset()     {         super.reset();          this.f3682  = null;         this.u3683     = null;         this.s3684     = null;         this.l3685     = null;                  this.order   = null;         this.c1      = null;         this.c2      = null;         this.c3      = null;              this.corrections = [];     }        copy()     {         const copy = new r1820(this.nodeId, this.options);          copy.o3358(this);                  if (this.f3682) copy.f3682 = this.order .copy();         if (this.u3683   ) copy.u3683    = this.u3683   .copy();         if (this.s3684   ) copy.s3684    = this.s3684   .copy();         if (this.l3685   ) copy.l3685    = this.l3685   .copy();                  if (this. order) copy. order = this.order .copy();         if (this. c1   ) copy. c1    = this. c1   .copy();         if (this. c2   ) copy. c2    = this. c2   .copy();         if (this. c3   ) copy. c3    = this. c3   .copy();                  if (this.value ) copy. value = this. value.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalColorValue (this. input, parse);         let   order = await evalNumberValue(this.f3682, parse);         const c1    = await evalNumberValue(this.u3683,    parse);         const c2    = await evalNumberValue(this.s3684,    parse);         const c3    = await evalNumberValue(this.l3685,    parse);          if (order)          {             order       = order.c3728();             order.value = Math.min(Math.max(0, order.value), 5);         }           if (input)         {             if (this.options.enabled)             {                 const rgb = input.c3241();                                  if (!k78(rgb))                     z2076(this.nodeId);                   const inputColor = input.c3240();                   const               [ u1807,                 j1808,                 q1809,                 o1810 ] = await o1796(                     parse,                     this.nodeId,                     inputColor,                      order, c1, c2, c3,                      this.order != null,                     this.c1    != null,                      this.c2    != null,                      this.c3    != null);                                        if (    !parse.n3640)                 {                     if (   u1807 >= 0                          && u1807 <  6)                     {                         this.c3198 = z1798(                             inputColor,                             u1807,                             j1808,                             q1809,                             o1810);                                                       this.order = new z2021(u1807);                         this.c1    = new z2021(j1808);                         this.c2    = new z2021(q1809);                         this.c3    = new z2021(o1810);                                                   this.value = a2009.p2805(this.c3198);                          this.value.c1.decimals = input.c1.decimals;                         this.value.c2.decimals = input.c2.decimals;                         this.value.c3.decimals = input.c3.decimals;                           this.l4100(parse,                         [                             ['order', new z2021(u1807, 0)],                             ['c1',    new z2021(j1808,     1)],                             ['c2',    new z2021(q1809,     1)],                             ['c3',    new z2021(o1810,     1)],                             ['value', this.value                      ]                         ]);                     }                     else                     {                         this.order = z2021.NaN.copy();                         this.c1    = z2021.NaN.copy();                         this.c2    = z2021.NaN.copy();                         this.c3    = z2021.NaN.copy();                         this.value = input.copy();                                  this.l4100(parse,                         [                             ['order', this.order],                             ['c1',    this.c1   ],                             ['c2',    this.c2   ],                             ['c3',    this.c3   ],                             ['value', this.value]                         ]);                     }                 }                 else                 {                     this.order = z2021.NaN.copy();                     this.c1    = z2021.NaN.copy();                     this.c2    = z2021.NaN.copy();                     this.c3    = z2021.NaN.copy();                     this.value = input.copy();                          this.l4100(parse,                     [                         ['order', this.order],                         ['c1',    this.c1   ],                         ['c2',    this.c2   ],                         ['c3',    this.c3   ],                         ['value', this.value]                     ]);                 }             }             else             {                 this.order = z2021.NaN.copy();                 this.c1    = z2021.NaN.copy();                 this.c2    = z2021.NaN.copy();                 this.c3    = z2021.NaN.copy();                 this.value = input.copy();                  this.l4100(parse,                 [                     ['order', this.order],                     ['c1',    this.c1   ],                     ['c2',    this.c2   ],                     ['c3',    this.c3   ],                     ['value', this.value]                 ]);             }         }         else         {             this.order = z2021.NaN.copy();             this.c1    = z2021.NaN.copy();             this.c2    = z2021.NaN.copy();             this.c3    = z2021.NaN.copy();             this.value = a2009 .NaN.copy();              this.l4100(parse,             [                 ['order', z2021.NaN],                 ['c1',    z2021.NaN],                 ['c2',    z2021.NaN],                 ['c3',    z2021.NaN],                 ['value', a2009 .NaN]             ]);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.order && this.order.isValid()             && this.c1    && this.c1   .isValid()             && this.c2    && this.c2   .isValid()             && this.c3    && this.c3   .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.f3682) this.f3682.g4087(parse);         if (this.u3683   ) this.u3683   .g4087(parse);         if (this.s3684   ) this.s3684   .g4087(parse);         if (this.l3685   ) this.l3685   .g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.f3682) this.f3682.e4088(parse, from, force);         if (this.u3683   ) this.u3683   .e4088(parse, from, force);         if (this.s3684   ) this.s3684   .e4088(parse, from, force);         if (this.l3685   ) this.l3685   .e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.f3682) this.f3682.q4086(parse);         if (this.u3683   ) this.u3683   .q4086(parse);         if (this.s3684   ) this.s3684   .q4086(parse);         if (this.l3685   ) this.l3685   .q4086(parse);     } } 


class p1817 extends z2044 {     standard = null;     contrast = null;       constructor(nodeId, options)     {         super(s1173, nodeId, options);     }        reset()     {         super.reset();          this.standard = null;         this.contrast = null;     }        copy()     {         const copy = new p1817(this.nodeId, this.options);          copy.o3358(this);          if (this.standard) copy.standard = this.standard.copy();         if (this.contrast) copy.contrast = this.contrast.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const z4082   = await evalColorValue (this.z4082,   parse);         const z4083   = await evalColorValue (this.z4083,   parse);         const standard = await evalNumberValue(this.standard, parse);                   if (standard.isValid())             standard.value = Math.min(Math.max(0, standard.value), 1);           if (   z4082              && z4083)         {             if (   z4082.isValid()                 && z4083.isValid())             {                 if (   w149(z4082.c3240())                     && w149(z4083.c3240()))                 {                     if (standard.value == 0)                     {                         const value = i157(z4082.c3241(), z4083.c3241());                         this.contrast = new z2021(value, 2);                     }                     else                     {                         const value = x161(z4082.c3241(), z4083.c3241());                         this.contrast = new z2021(value, 1);                     }                 }                 else                     this.contrast = z2021.NaN.copy();             }             else                 this.contrast = z2021.NaN.copy();               this.value =                  z4082                  ? z4082                 : a2009.NaN.copy();               this.l4100(parse,             [                 ['text', z4082],                 ['back', z4083]             ]);         }          else if (z4082)          {             this.l4100(parse,             [                 ['text', z4082.isValid() ? z4082 : a2009.NaN],                 ['back', a2009.NaN                            ]             ]);                          this.value    = z4082;             this.contrast = z2021.NaN.copy();         }          else if (z4083)          {             this.l4100(parse,             [                 ['text', a2009.NaN                            ],                 ['back', z4083.isValid() ? z4083 : a2009.NaN]             ]);              this.value    = a2009 .NaN.copy();             this.contrast = z2021.NaN.copy();         }          else         {             this.value    = a2009 .NaN.copy();             this.contrast = z2021.NaN.copy();              this.l4100(parse,             [                 ['text', a2009.NaN],                 ['back', a2009.NaN]             ]);         }                    this.l4100(parse,         [             ['standard', standard     ],             ['contrast', this.contrast]         ],         true);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.standard && this.standard.isValid()             && (!this.contrast || this.contrast.isValid());     }        g4087(parse)     {         super.g4087(parse);          if (this.standard) this.standard.g4087(parse);         if (this.contrast) this.contrast.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.standard) this.standard.e4088(parse, from, force);         if (this.contrast) this.contrast.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.standard) this.standard.q4086(parse);         if (this.contrast) this.contrast.q4086(parse);     } } 


class f1819 extends u2043 {     from = null;        constructor(nodeId, options)     {         super(n1172, nodeId, options);     }            reset()     {         super.reset();          this.from = null;     }        copy()     {         const copy = new f1819(this.nodeId, this.options);          copy.o3358(this);          if (this.value) copy.value = this.value.copy();         if (this.from ) copy.from  = this.from .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalColorValue (this.input, parse);         let   from  = await evalNumberValue(this.from,  parse);          if (from) from = from.c3728();                   if (input)         {             if (this.options.enabled)             {                 if (o957(input.type))                 {                     this.value = new u2020();                      for (let i = 0; i < input.items.length; i++)                         this.value.items.push(await getConvertP3Value(input.items[i], from));                 }                 else                     this.value = await getConvertP3Value(input, from);             }             else                 this.value = input.copy();         }         else             this.value = a2009.NaN.copy();                    this.l4100(parse,         [             ['value',   this.value       ],             ['type',    this.outputType()],             ['quality', from             ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.from && this.from.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.from) this.from.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.from) this.from.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.from) this.from.q4086(parse);     } }    function getConvertP3Value(input, from) {     return a2009.g3772(         from.value == 0         ? p4141(x61(input.c3241()))         : p4141(k62(input.c3241()))); }


class s1816 extends u2043 {     l;     m;     s;       constructor(nodeId, options)     {         super(y1174, nodeId, options);     }            reset()     {         super.reset();          this.l = null;         this.m = null;         this.s = null;     }        copy()     {         const copy = new s1816(this.nodeId, this.options);          copy.o3358(this);          if (this.l) copy.l = this.l.copy();         if (this.m) copy.m = this.m.copy();         if (this.s) copy.s = this.s.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalColorValue (this.input, parse);         const l     = await evalNumberValue(this.l,     parse);          const m     = await evalNumberValue(this.m,     parse);         const s     = await evalNumberValue(this.s,     parse);           if (input)         {             if (this.options.enabled)             {                 if (o957(input.type))                 {                     this.value = new u2020();                      for (let i = 0; i < input.items.length; i++)                         this.value.items.push(getColorBlindValue(input.items[i], l, m, s));                 }                 else                     this.value = getColorBlindValue(input, l, m, s);             }             else                 this.value = input.copy();         }         else             this.value = a2009.NaN.copy();           this.l4100(parse,         [             ['value',  this.value       ],             ['type',   this.outputType()],             ['l',      l                ],             ['m',      m                ],             ['s',      s                ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.l && this.l.isValid()             && this.m && this.m.isValid()             && this.s && this.s.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.l) this.l.g4087(parse);         if (this.m) this.m.g4087(parse);         if (this.s) this.s.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.l) this.l.e4088(parse, from, force);         if (this.m) this.m.e4088(parse, from, force);         if (this.s) this.s.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.l) this.l.q4086(parse);         if (this.m) this.m.q4086(parse);         if (this.s) this.s.q4086(parse);     } }    function getColorBlindValue(input, l, m, s) {     const rgb   = input.c3241();      const rgbCb = k134(         rgb,         l.value / 2,         m.value / 2,         s.value / 2);      if (   !g73(rgb  )         && !g73(rgbCb))     {         const validRgbCb = rgbCb;              const validCol = k4195(             h146(validRgbCb),              l133(input.space.value));          return a2009.p2805(validCol);     }     else         return a2009.NaN.copy(); }


class l1818 extends z2044 {     space;     amount;     gamma;       constructor(nodeId, options)     {         super(m1175, nodeId, options);     }            reset()     {         super.reset();          this.space  = null;         this.amount = null;         this.gamma  = null;     }        copy()     {         const copy = new l1818(this.nodeId, this.options);          copy.o3358(this);          if (this.space ) copy.space  = this.space .copy();         if (this.amount) copy.amount = this.amount.copy();         if (this.gamma ) copy.gamma  = this.gamma .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const z4082 = await evalColorValue (this.z4082, parse);         const z4083 = await evalColorValue (this.z4083, parse);         let   space  = await evalNumberValue(this.space,  parse);         const amount = await evalNumberValue(this.amount, parse);         const gamma  = await evalNumberValue(this.gamma,  parse);          if (space) space = space.c3728();                   if (   z4082              && z4083)         {             c952(                 amount.type == m1091,                  'this.result.type must be NUMBER_VALUE');              const f = amount.value / 100;               const spaceIndex = Math.min(Math.max(0, space.value), r4125()-1);             const gammaValue = Math.max(0.0001, gamma.value);              const _space = l133(spaceIndex);              const c3198 = this.interpolate(                 spaceIndex,                 k4195(z4082.c3240(), _space),                 k4195(z4083.c3240(), _space),                 f,                 gammaValue);                                          this.value = a2009.p2805(c3198, spaceIndex);         }          else if (z4082)              this.value = z4082;          else if (z4083)              this.value = z4083;                      else              this.value = a2009.NaN.copy();           this.l4100(parse,         [             ['space',  space     ],             ['amount', amount    ],             ['gamma',  gamma     ],             ['value',  this.value]         ]);                   this.validate();                  return this;     }        interpolate(space, col0, j103, f, gamma)     {         if (   space <= 1             || space >  6)          {             gamma = Math.max(0.01, gamma);              const r0 = Math.sign(col0[1]) * Math.pow(Math.abs(col0[1]), gamma);               const g0 = Math.sign(col0[2]) * Math.pow(Math.abs(col0[2]), gamma);               const b0 = Math.sign(col0[3]) * Math.pow(Math.abs(col0[3]), gamma);                const r1 = Math.sign(j103[1]) * Math.pow(Math.abs(j103[1]), gamma);             const g1 = Math.sign(j103[2]) * Math.pow(Math.abs(j103[2]), gamma);             const b1 = Math.sign(j103[3]) * Math.pow(Math.abs(j103[3]), gamma);              const r = r1035(r0, r1, f);                     const g = r1035(g0, g1, f);                         const b = r1035(b0, b1, f);                      return [                 l133(space),                 Math.sign(r) * Math.pow(Math.abs(r), 1/gamma),                 Math.sign(g) * Math.pow(Math.abs(g), 1/gamma),                 Math.sign(b) * Math.pow(Math.abs(b), 1/gamma) ];         }         else          {             const h0 = col0[1] * Tau;  const h1 = j103[1] * Tau;             const c0 = col0[2];        const c1 = j103[2];             const l0 = col0[3];        const l1 = j103[3];              return [                 l133(space),                 l1038(h0 + w887(h0, h1) * f) / Tau,                 r1035(c0, c1, f),                 r1035(l0, l1, f) ];         }     }        isValid()     {         return super.isValid()             && this.space  && this.space .isValid()             && this.amount && this.amount.isValid()             && this.gamma  && this.gamma .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.space ) this.space .g4087(parse);         if (this.amount) this.amount.g4087(parse);         if (this.gamma ) this.gamma .g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.space ) this.space .e4088(parse, from, force);         if (this.amount) this.amount.e4088(parse, from, force);         if (this.gamma ) this.gamma .e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.space ) this.space .q4086(parse);         if (this.amount) this.amount.q4086(parse);         if (this.gamma ) this.gamma .q4086(parse);     } } 


class f1815 extends z2044 {     mode    = null;     opacity = null;           constructor(nodeId, options)     {         super(d1176, nodeId, options);     }            reset()     {         super.reset();          this.mode    = null;         this.opacity = null;     }        copy()     {         const copy = new f1815(this.nodeId, this.options);          copy.o3358(this);          if (this.mode   ) copy.mode    = this.mode   .copy();         if (this.opacity) copy.opacity = this.opacity.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const z4082  = await evalColorValue (this.z4082,  parse);         const z4083  = await evalColorValue (this.z4083,  parse);         let   mode    = await evalNumberValue(this.mode,    parse);         const opacity = await evalNumberValue(this.opacity, parse);                  if (mode) mode = mode.c3728();           if (   z4082              && z4083)         {             c952(                 opacity.type == m1091,                  'this.result.type must be NUMBER_VALUE');              const w3771 = opacity.value / 100;              const x3770 = Math.min(Math.max(0, mode.value), l1393.length-1);               const col = this.blend(                 x3770,                 z4082.c3241(),                 z4083.c3241(),                 w3771);              this.value = a2009.g3772(p4141(col));         }          else if (z4082)              this.value = z4082;          else if (this.z4083)              this.value = z4083;                      else              this.value = a2009.NaN.copy();           this.l4100(parse,         [             ['value',   this.value],             ['mode',    mode      ],             ['opacity', opacity   ]         ]);           this.validate();                  return this;     }        blend(mode, col0, j103, opacity)     {         switch (mode)         {             case  0: return a4247    (col0, j103, opacity);              case  1: return j4248    (col0, j103, opacity);             case  2: return y4249  (col0, j103, opacity);             case  3: return m4250 (col0, j103, opacity);              case  4: return c4251   (col0, j103, opacity);             case  5: return l4252    (col0, j103, opacity);             case  6: return s4254(col0, j103, opacity);              case  7: return s4256   (col0, j103, opacity);             case  8: return w4257 (col0, j103, opacity);             case  9: return w4259 (col0, j103, opacity);              case 10: return q4261(col0, j103, opacity);             case 11: return k4262 (col0, j103, opacity);              case 12: return g4264       (col0, j103, opacity);             case 13: return s4265(col0, j103, opacity);             case 14: return e4266     (col0, j103, opacity);             case 15: return v4267(col0, j103, opacity);         }     }        isValid()     {         return super.isValid()             && this.mode    && this.mode   .isValid()             && this.opacity && this.opacity.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.mode   ) this.mode   .g4087(parse);         if (this.opacity) this.opacity.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.mode   ) this.mode   .e4088(parse, from, force);         if (this.opacity) this.opacity.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.mode   ) this.mode   .q4086(parse);         if (this.opacity) this.opacity.q4086(parse);     } } 


function a4247(col, back, opacity) {     return [ col[0] * opacity + back[0] * (1 - opacity),              col[1] * opacity + back[1] * (1 - opacity),              col[2] * opacity + back[2] * (1 - opacity) ]; }    function j4248(col, back, opacity) {     return a4247(         [ Math.min(back[0], col[0]),           Math.min(back[1], col[1]),           Math.min(back[2], col[2]) ],         back,         opacity); }    function chanMultiply(c, b) {     return c * b; }    function y4249(col, back, opacity) {     return a4247(         [ chanMultiply(col[0], back[0]),           chanMultiply(col[1], back[1]),           chanMultiply(col[2], back[2]) ],         back,         opacity); }    function chanColorBurn(c, b) {          if (b == 1) return 1;     else if (c == 0) return 0;     else             return 1 - Math.min((1 - b) / c, 1); }    function m4250(col, back, opacity) {     return a4247(          [ chanColorBurn(col[0], back[0]),            chanColorBurn(col[1], back[1]),            chanColorBurn(col[2], back[2]) ],         back,         opacity); }    function c4251(col, back, opacity) {     return a4247(         [ Math.max(back[0], col[0]),           Math.max(back[1], col[1]),           Math.max(back[2], col[2]) ],         back,         opacity); }    function s4253(c, b) {     return b + c - b*c; }    function l4252(col, back, opacity) {     return a4247(         [ s4253(col[0], back[0]),           s4253(col[1], back[1]),           s4253(col[2], back[2]) ],         back,         opacity); }    function v4255(c, b) {          if (b == 0) return 0;     else if (c == 1) return 1;     else             return Math.min(b / (1 - c), 1); }    function s4254(col, back, opacity) {     return a4247(         [ v4255(col[0], back[0]),           v4255(col[1], back[1]),           v4255(col[2], back[2]) ],         back,         opacity); }    function s4256(col, back, opacity) {     return a4247(         [ h4260(back[0], col[0]),           h4260(back[1], col[1]),           h4260(back[2], col[2]) ],         back,         opacity); }    function p2806(b) {     return b <= 0.25          ? ((16 * b - 12) * b + 4) * b          : Math.sqrt(b); }    function k4258(c, b) {     return c <= 0.5          ? b - (1 - 2*c) * b * (1 - b)          : b + (2*c - 1) * (p2806(b) - b); }    function w4257(col, back, opacity) {     return a4247(         [ k4258(col[0], back[0]),           k4258(col[1], back[1]),           k4258(col[2], back[2]) ],         back,         opacity); }    function h4260(c, b) {     if (c <= 0.5) return chanMultiply(b, 2 * c);     else          return s4253(b, 2 * c - 1); }    function w4259(col, back, opacity) {     return a4247(         [ h4260(col[0], back[0]),           h4260(col[1], back[1]),           h4260(col[2], back[2]) ],         back,         opacity); }    function q4261(col, back, opacity) {     return [ Math.abs(back[0] - col[0]),              Math.abs(back[1] - col[1]),              Math.abs(back[2] - col[2]) ]; }    function r4263(c, b) {     return b + c - 2*b*c; }    function k4262(col, back, opacity) {     return a4247(         [ r4263(col[0], back[0]),           r4263(col[1], back[1]),           r4263(col[2], back[2]) ],         back,         opacity); }    function t2807(col) {     return col[0] * 0.30          + col[1] * 0.59          + col[2] * 0.11; }    function h2808(p127, l) {     const col = [...p127];      const d = l - t2807(col);      col[0] += d;     col[1] += d;     col[2] += d;      return j2816(col); }    function l2809(col) {     return Math.max(col[0], col[1], col[2])           - Math.min(col[0], col[1], col[2]); }    function t2810(col) {          if (col[0] <= col[1]            && col[0] <= col[2]) return 0;     else if (col[1] <= col[1]            && col[1] <= col[2]) return 1;     else                       return 2; }    function j2811(col) {          if (   col[0] >= col[1]               && col[0] <= col[2]           ||    col[0] <= col[1]               && col[0] >= col[2]) return 0;     else if (   col[1] >= col[0]               && col[1] <= col[2]           ||    col[1] <= col[0]               && col[1] >= col[2]) return 1;     else                          return 2; }    function a2812(col) {          if (col[0] >= col[1]            && col[0] >= col[2]) return 0;     else if (col[1] >= col[1]            && col[1] >= col[2]) return 1;     else                       return 2; }    function d2813(col)  {     if (   col[0] == col[1]          && col[0] == col[2])         return [0, 1, 2];      else          return [             t2810(col),              j2811(col),              a2812(col)]; }    function s2814(p127, s) {     const col       = [...p127];     const [n, d, x] = d2813(col);      if (col[x] > col[n])     {         col[d] = (((col[d] - col[n]) * s) / (col[x] - col[n]));         col[x] = s;     }     else         col[d] = col[x] = 0;      col[n] = 0;      return col; }    function t2815(c, l, n, x) {          if (n < 0) return l + (((c - l) * l) / (l - n));     else if (x > 1) return l + (((c - l) * (1 - l)) / (x - l));     else            return c; }    function j2816(col) {     const l   = t2807(col);      const n = Math.min(col[0], col[1], col[2]);     const x = Math.max(col[0], col[1], col[2]);      return [ t2815(col[0], l, n, x),              t2815(col[1], l, n, x),              t2815(col[2], l, n, x) ]; }    function g4264(col, back, opacity) {     return a4247(         h2808(s2814(col, l2809(back)), t2807(back)),         back,         opacity); }    function s4265(col, back, opacity) {     return a4247(         h2808(s2814(back, l2809(col)), t2807(back)),         back,         opacity); }    function e4266(col, back, opacity) {     return a4247(         h2808(col, t2807(back)),         back,         opacity); }    function v4267(col, back, opacity) {     return a4247(         h2808(back, t2807(col)),         back,         opacity); }


class t1886 extends z2042 {     id;      colorStyle;     h2817;           linked;        constructor(nodeId, options, styleId)     {         super(w1216, nodeId, options);          this.id == styleId;     }        copy()     {         const copy = new t1886(this.nodeId, this.options);          copy.id = this.id;          if (this.colorStyle) copy.colorStyle = this.colorStyle.copy();         if (this.h2817  ) copy.h2817   = this.h2817  .copy();                         copy.linked   = this.linked;          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                   this.value = await evalColorValue(this.h2817, parse);           if (   this.value.isValid()             && this.linked)                                   {             if (this.value.type == a1168)                 this.value = e2012.g3772(p4141(this.value.c3241()), 0xff);              const rgba       = this.value.y99();             const q3260 = s100(k120(rgba), rgba[3]);              this.evalStyle({rgba: q3260});         }         else             this.value = e2012.NaN.copy();           this.l4100(parse,         [             ['value', this.value]         ]);           this.validate();          return this;     }        evalStyle(options = {})     {         if (!this.options.enabled)             return;                       const colorStyle = new k1838(this.nodeId, this.id, this.name);                     colorStyle.paints =          [             [ 'SOLID',                        Math.round(options.rgba[0] * 0xff)               + ' ' + Math.round(options.rgba[1] * 0xff)               + ' ' + Math.round(options.rgba[2] * 0xff)               + ' ' + Math.round(options.rgba[3] * 100 ) ]         ];           this.colorStyle = colorStyle;     }        isValid()     {         return this.h2817 && this.h2817.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.h2817) this.h2817.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.h2817) this.h2817.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.h2817) this.h2817.q4086(parse);     } }


class a1888 extends u2043 {     color   = null;     opacity = null;     blend   = null;        constructor(nodeId, options)     {         super(a1179, nodeId, options);     }        reset()     {         super.reset();          this.color   = null;         this.opacity = null;         this.blend   = null;     }        copy()     {         const copy = new a1888(this.nodeId, this.options);          copy.o3358(this);          if (this.color  ) copy.color   = this.color  .copy();         if (this.opacity) copy.opacity = this.opacity.copy();         if (this.blend  ) copy.blend   = this.blend  .copy();          return copy;     }        u4241(v2991)     {         switch (v2991)         {             case 'color':   return this.input ? this.value.color   : this.color;             case 'opacity': return this.input ? this.value.opacity : this.opacity;             case 'blend':   return this.input ? this.value.blend   : this.blend;         }          return null;     }        async eval(parse)     {         if (this.isCached())             return this;           const input   = await evalFillValue  (this.input,   parse);         let   color   = await evalColorValue (this.color,   parse);         let   opacity = await evalNumberValue(this.opacity, parse);         let   blend   = await evalNumberValue(this.blend,   parse);           if (input)         {             this.value = new e2012(                 color   ?? input.color,                 opacity ?? input.opacity,                 blend   ?? input.blend);         }         else if ((!color   || color  .type == a1168 )               && (!opacity || opacity.type == m1091)               && (!blend   || blend  .type == m1091))         {             this.value = new e2012(                 color,                  opacity,                 blend);         }         else             this.value = e2012.NaN.copy();           this.l4100(parse,         [             ['value',   this.value],             ['color',   color     ],             ['opacity', opacity   ],             ['blend',   blend     ]         ]);                                                this.validate();          return this;     }        q3632()     {         return this.options.enabled             ? new e2012(                 this.color   ? this.color  .q3632() : this.input.value.color  .q3632(),                 this.opacity ? this.opacity.q3632() : this.input.value.opacity.q3632(),                 this.blend   ? this.blend  .q3632() : this.input.value.blend  .q3632())             : e2012.NaN.copy();     }        isValid()     {         return (!this.input || this.input.isValid())             && this.color   && this.color  .isValid()             && this.opacity && this.opacity.isValid()             && this.blend   && this.blend  .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.color  ) this.color  .g4087(parse);         if (this.opacity) this.opacity.g4087(parse);         if (this.blend  ) this.blend  .g4087(parse);     }                    e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.color  ) this.color  .e4088(parse, from, force);         if (this.opacity) this.opacity.e4088(parse, from, force);         if (this.blend  ) this.blend  .e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.color  ) this.color  .q4086(parse);         if (this.opacity) this.opacity.q4086(parse);         if (this.blend  ) this.blend  .q4086(parse);     } }


class h1885 extends u2043 {     fill     = null;     position = null;        constructor(nodeId, options)     {         super(i1185, nodeId, options);     }        reset()     {         super.reset();          this.fill     = null;         this.position = null;     }        copy()     {         const copy = new h1885(this.nodeId, this.options);          copy.o3358(this);          if (this.fill    ) copy.fill     = this.fill    .copy();         if (this.position) copy.position = this.position.copy();          return copy;     }        u4241(v2991)     {         switch (v2991)         {             case 'fill':      return this.input ? this.value.fill     : this.fill;             case 'position':  return this.input ? this.value.position : this.position;         }          return null;     }        async eval(parse)     {         if (this.isCached())             return this;                                     const input    = await evalColorStopValue(this.input,    parse);         let   fill     = await evalFillValue     (this.fill,     parse);         const position = await evalNumberValue   (this.position, parse);                  fill = this.validateFill(fill);           if (input)         {             this.value = new a2008(                    fill                  && fill.type != a1178                      ? fill                      : input.fill,                 position ?? input.position);         }         else         {             this.value = new a2008(                 fill,                  position);         }           this.l4100(parse,          [             ['value', this.value]         ]);                   if (!this.fill    ) this.fill     = this.value.fill    .copy();         if (!this.position) this.position = this.value.position.copy();           this.validate();          return this;     }        validateFill(fill)     {         if (!fill)             return null;           if (fill.type == a1168)             return e2012.g3772(p4141(fill.c3241()), 100);         else             return fill;     }        q3632()     {         return new a2008(             this.options.enabled             ? this.validateFill(this.fill ? this.fill.q3632() : this.input.fill.q3632())             : e2012.NaN,             this.position ? this.position.q3632() : this.input.position.q3632());     }                         isValid()     {         return (!this.input || this.input.isValid())             && this.fill     && this.fill    .isValid()             && this.position && this.position.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.fill    ) this.fill    .g4087(parse);         if (this.position) this.position.g4087(parse);     }                    e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.fill    ) this.fill    .e4088(parse, from, force);         if (this.position) this.position.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.fill    ) this.fill    .q4086(parse);         if (this.position) this.position.q4086(parse);     } }


class x1889 extends z2042 {     inputs = [];      k3686 = null;     position = null;     x        = null;     y        = null;     size     = null;     angle    = null;     aspect   = null;     skew     = null;     blend    = null;          diagAspect;                constructor(nodeId, options)     {         super(y1188, nodeId, options);     }                    reset()     {         super.reset();                  this.inputs = [];              this.k3686 = null;         this.position = null;         this.x        = null;         this.y        = null;         this.size     = null;         this.angle    = null;         this.aspect   = null;         this.skew     = null;         this.blend    = null;     }        copy()     {         const copy = new x1889(this.nodeId, this.options);          copy.o3358(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.k3686) copy.k3686 = this.x       .copy();         if (this.position) copy.position = this.position.copy();         if (this.x       ) copy.x        = this.x       .copy();         if (this.y       ) copy.y        = this.y       .copy();         if (this.size    ) copy.size     = this.size    .copy();         if (this.angle   ) copy.angle    = this.angle   .copy();         if (this.aspect  ) copy.aspect   = this.aspect  .copy();         if (this.skew    ) copy.skew     = this.skew    .copy();         if (this.blend   ) copy.blend    = this.blend   .copy();          return copy;     }        u4241(v2991)     {         switch (v2991)         {             case 'gradType':  return this.input ? this.value.k3686 : this.k3686;             case 'position':  return this.input ? this.value.position : this.position;             case 'x':         return this.input ? this.value.x        : this.x;             case 'y':         return this.input ? this.value.y        : this.y;             case 'size':      return this.input ? this.value.size     : this.size;             case 'angle':     return this.input ? this.value.angle    : this.angle;             case 'aspect':    return this.input ? this.value.aspect   : this.aspect;             case 'skew':      return this.input ? this.value.skew     : this.skew;             case 'blend':     return this.input ? this.value.blend    : this.blend;         }          return null;     }        async eval(parse)     {         if (this.isCached())             return this;                       let k3686 = await evalNumberValue(this.k3686, parse);         let position = await evalNumberValue(this.position, parse);         let x        = await evalNumberValue(this.x,        parse);         let y        = await evalNumberValue(this.y,        parse);         let size     = await evalNumberValue(this.size,     parse);         let angle    = await evalNumberValue(this.angle,    parse);         let aspect   = await evalNumberValue(this.aspect,   parse);         let skew     = await evalNumberValue(this.skew,     parse);         let blend    = await evalNumberValue(this.blend,    parse);           if (position) position.value = Math.min(Math.max(0, Math.floor(position.value)), 4);         if (blend   ) blend   .value = Math.min(Math.max(0, Math.floor(blend   .value)), l1393.length-1);           let stops = new u2020();           const inputs = [];                  for (const input of this.inputs)             inputs.push(await evalValue(input, parse));           if (   inputs.length == 1             && inputs[0].type == q1187)         {             this.value        = inputs[0].q3632();             this.value.nodeId = this.nodeId;             this.value.v3625(inputs[0]);              if (k3686)  this.value.k3686 = k3686;  else  k3686 = this.value.k3686;                   if (position)  this.value.position = position;  else  position = this.value.position;                   if (x       )  this.value.x        = x;         else  x        = this.value.x;                   if (y       )  this.value.y        = y;         else  y        = this.value.y;                   if (size    )  this.value.size     = size;      else  size     = this.value.size;                   if (angle   )  this.value.angle    = angle;     else  angle    = this.value.angle;                   if (aspect  )  this.value.aspect   = aspect;    else  aspect   = this.value.aspect;                   if (skew    )  this.value.skew     = skew;      else  skew     = this.value.skew;                   if (blend   )  this.value.blend    = blend;     else  blend    = this.value.blend;               }         else         {             for (let i = 0, o = 0; i < inputs.length; i++)             {                 const input = inputs[i];                  if (   input                     && this.options.enabled)                 {                     if (o957(input.type))                     {                         for (const item of input.items)                             if (item.isValid())                                 stops.items.push(item);                     }                     else if (input.type == q1187)                     {                         for (const item of input.stops.items)                             stops.items.push(item);                     }                     else                         if (input.isValid())                             stops.items.push(input);                 }             }               stops.items = s1826(stops.items);              d1828(stops.items);               this.value = new m2014(                 stops,                 k3686,                 position,                 x,                  y,                  size,                  angle,                  aspect,                 this.diagAspect,                 skew,                 blend);         }                   this.l4100(parse,         [             ['value',    this.value],             ['gradType', k3686  ],             ['position', position  ],             ['x',        x         ],             ['y',        y         ],             ['size',     size      ],             ['angle',    angle     ],             ['aspect',   aspect    ],             ['skew',     skew      ],             ['blend',    blend     ]         ]);                   if (   inputs.length == 1             && inputs[0].type == q1187)         {             if (!this.k3686) this.k3686 = this.value.k3686.copy();             if (!this.position) this.position = this.value.position.copy();             if (!this.x       ) this.x        = this.value.x       .copy();             if (!this.y       ) this.y        = this.value.y       .copy();             if (!this.size    ) this.size     = this.value.size    .copy();             if (!this.angle   ) this.angle    = this.value.angle   .copy();             if (!this.aspect  ) this.aspect   = this.value.aspect  .copy();             if (!this.skew    ) this.skew     = this.value.skew    .copy();             if (!this.blend   ) this.blend    = this.value.blend   .copy();         }           this.validate();          return this;     }                q3632()     {         return this.value.copy();     }                         isValid()     {         return !this.inputs.find(i => !i.isValid())             && this.k3686 && this.k3686.isValid()             && this.position && this.position.isValid()             && this.x        && this.x       .isValid()             && this.y        && this.y       .isValid()             && this.size     && this.size    .isValid()             && this.angle    && this.angle   .isValid()             && this.aspect   && this.aspect  .isValid()             && this.skew     && this.skew    .isValid()             && this.blend    && this.blend   .isValid();     }        g4087(parse)     {         super.g4087(parse);          this.inputs.forEach(i => i.g4087(parse));          if (this.k3686) this.k3686.g4087(parse);         if (this.position) this.position.g4087(parse);         if (this.x       ) this.x       .g4087(parse);         if (this.y       ) this.y       .g4087(parse);         if (this.size    ) this.size    .g4087(parse);         if (this.angle   ) this.angle   .g4087(parse);         if (this.aspect  ) this.aspect  .g4087(parse);         if (this.skew    ) this.skew    .g4087(parse);         if (this.blend   ) this.blend   .g4087(parse);     }            e4088(parse, from, force)     {         super.e4088(parse, from, force);          this.inputs.forEach(i => i.e4088(parse, from, force));                  if (this.k3686) this.k3686.e4088(parse, from, force);         if (this.position) this.position.e4088(parse, from, force);         if (this.x       ) this.x       .e4088(parse, from, force);         if (this.y       ) this.y       .e4088(parse, from, force);         if (this.size    ) this.size    .e4088(parse, from, force);         if (this.angle   ) this.angle   .e4088(parse, from, force);         if (this.aspect  ) this.aspect  .e4088(parse, from, force);         if (this.skew    ) this.skew    .e4088(parse, from, force);         if (this.blend   ) this.blend   .e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          this.inputs.forEach(i => i.q4086(parse));          if (this.k3686) this.k3686.q4086(parse);         if (this.position) this.position.q4086(parse);         if (this.x       ) this.x       .q4086(parse);         if (this.y       ) this.y       .q4086(parse);         if (this.size    ) this.size    .q4086(parse);         if (this.angle   ) this.angle   .q4086(parse);         if (this.aspect  ) this.aspect  .q4086(parse);         if (this.skew    ) this.skew    .q4086(parse);         if (this.blend   ) this.blend   .q4086(parse);     }     }


class o1895 extends u2043 {     fills  = null;    a3674  = null;      weight = null;     fit    = null;     join   = null;     miter  = null;     cap    = null;     dashes = null;                constructor(nodeId, options)     {         super(s1182, nodeId, options);     }                reset()     {         super.reset();                  this. fills  = null;         this.a3674  = null;          this. weight = null;         this. fit    = null;         this. join   = null;         this. miter  = null;         this. cap    = null;         this. dashes = null;     }        copy()     {         const copy = new o1895(this.nodeId, this.options);          copy.o3358(this);          if (this.fills ) copy. fills  = this.fills .copy();         if (this.a3674) copy.a3674  = this.a3674.copy();         if (this.weight) copy. weight = this.weight.copy();         if (this.fit   ) copy. fit    = this.fit   .copy();         if (this.join  ) copy. join   = this.join  .copy();         if (this.miter ) copy. miter  = this.miter .copy();         if (this.cap   ) copy. cap    = this.cap   .copy();         if (this.dashes) copy. dashes = this.dashes.copy();          return copy;     }        u4241(v2991)     {         switch (v2991)         {             case 'fills ':  return this.input ? this.value.fills  : this.fills;             case 'weight':  return this.input ? this.value.weight : this.weight;             case 'fit':     return this.input ? this.value.fit    : this.fit;             case 'join':    return this.input ? this.value.join   : this.join;             case 'miter':   return this.input ? this.value.miter  : this.miter;             case 'cap':     return this.input ? this.value.cap    : this.cap;             case 'dashes':  return this.input ? this.value.dashes : this.dashes;         }          return null;     }        async eval(parse)     {         if (this.isCached())             return this;          const input = await evalStrokeValue(this. input, parse);         let   fills = await evalListValue  (this.a3674, parse);          fills = this.validateFills(fills);          if (!o957(this.a3674.type))             this.fills = fills;           const weight = await evalNumberValue(this.weight, parse);         const fit    = await evalNumberValue(this.fit,    parse);         const join   = await evalNumberValue(this.join,   parse);         const miter  = await evalNumberValue(this.miter,  parse);         const cap    = await evalNumberValue(this.cap,    parse);         const dashes = await evalTextValue  (this.dashes, parse);           if (input)         {             this.value = new o2030(                 fills  ?? input.fills,                 weight ?? input.weight,                 fit    ?? input.fit,                 join   ?? input.join,                 miter  ?? input.miter,                 cap    ?? input.cap,                 dashes ?? input.dashes);         }         else         {             this.value = new o2030(                 fills,                  weight,                  fit,                  join,                 miter,                 cap,                 dashes);         }           this.l4100(parse,         [             ['value',  this.value],             ['fills',  fills     ],             ['weight', weight    ],             ['fit',    fit       ],             ['join',   join      ],             ['miter',  miter     ],             ['cap',    cap       ],             ['dashes', dashes    ]         ]);           this.validate();          return this;     }        validateFills(fills)     {                     if (!fills)             return null;          if (fills.type == a1168)             return new u2020([e2012.g3772(p4141(fills.c3241()), 100)]);          else if (fills.type ==     a1178               || fills.type == q1187)             return new u2020([fills]);         else         {             c952(fills.type == z1056, 'stroke.fills must be a LIST_VALUE');             return fills;         }     }        q3632()     {         return new o2030(             this.options.enabled             ? this.validateFills(this.fills ? this.fills.q3632() : this.input.fills.q3632())             : new u2020(),             this.weight ? this.weight.q3632() : this.input.weight.q3632(),             this.fit    ? this.fit   .q3632() : this.input.fit   .q3632(),             this.join   ? this.join  .q3632() : this.input.join  .q3632(),             this.miter  ? this.miter .q3632() : this.input.miter .q3632(),             this.cap    ? this.cap   .q3632() : this.input.cap   .q3632(),             this.dashes ? this.dashes.q3632() : this.input.dashes.q3632());     }                         isValid()     {         return (!this.input || this.input.isValid())             && this.fills  && this.fills .isValid()             && this.weight && this.weight.isValid()             && this.fit    && this.fit   .isValid()             && this.join   && this.join  .isValid()             && this.miter  && this.miter .isValid()             && this.cap    && this.cap   .isValid()             && this.dashes && this.dashes.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.a3674) this.a3674.g4087(parse);         if (this.weight) this.weight.g4087(parse);         if (this.fit   ) this.fit   .g4087(parse);         if (this.join  ) this.join  .g4087(parse);         if (this.miter ) this.miter .g4087(parse);         if (this.cap   ) this.cap   .g4087(parse);         if (this.dashes) this.dashes.g4087(parse);     }                    e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.a3674) this.a3674.e4088(parse, from, force);         if (this.weight) this.weight.e4088(parse, from, force);         if (this.fit   ) this.fit   .e4088(parse, from, force);         if (this.join  ) this.join  .e4088(parse, from, force);         if (this.miter ) this.miter .e4088(parse, from, force);         if (this.cap   ) this.cap   .e4088(parse, from, force);         if (this.dashes) this.dashes.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.a3674) this.a3674.q4086(parse);         if (this.weight) this.weight.q4086(parse);         if (this.fit   ) this.fit   .q4086(parse);         if (this.join  ) this.join  .q4086(parse);         if (this.miter ) this.miter .q4086(parse);         if (this.cap   ) this.cap   .q4086(parse);         if (this.dashes) this.dashes.q4086(parse);     }     }


class GStrokeSides extends u2043 {     top    = null;     left   = null;     right  = null;     bottom = null;                constructor(nodeId, options)     {         super(w1191, nodeId, options);     }                reset()     {         super.reset();                  this.top    = null;         this.left   = null;         this.right  = null;         this.bottom = null;     }        copy()     {         const copy = new GStrokeSides(this.nodeId, this.options);          copy.o3358(this);          if (this.top   ) copy.top    = this.top   .copy();         if (this.left  ) copy.left   = this.left  .copy();         if (this.right ) copy.right  = this.right .copy();         if (this.bottom) copy.bottom = this.bottom.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalStrokeSidesValue(this.input,  parse);         const top    = await evalNumberValue     (this.top,    parse);         const left   = await evalNumberValue     (this.left,   parse);         const right  = await evalNumberValue     (this.right,  parse);         const bottom = await evalNumberValue     (this.bottom, parse);           if (input)         {             this.value = new n4271(                 top    ?? input.top,                 left   ?? input.left,                 right  ?? input.right,                 bottom ?? input.bottom,                 this.options.enabled);         }         else         {             this.value = new n4271(                 top,                  left,                  right,                  bottom,                 this.options.enabled);         }           this.l4100(parse,         [             ['top',    this.value.top   ],             ['left',   this.value.left  ],             ['right',  this.value.right ],             ['bottom', this.value.bottom]         ]);                   if (!this.top   ) this.top    = this.value.top   .copy();         if (!this.left  ) this.left   = this.value.left  .copy();         if (!this.right ) this.right  = this.value.right .copy();         if (!this.bottom) this.bottom = this.value.bottom.copy();           this.validate();          return this;     }        q3632()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.top    && this.top   .isValid()             && this.left   && this.left  .isValid()             && this.right  && this.right .isValid()             && this.bottom && this.bottom.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.top   ) this.top   .g4087(parse);         if (this.left  ) this.left  .g4087(parse);         if (this.right ) this.right .g4087(parse);         if (this.bottom) this.bottom.g4087(parse);     }                   e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.top   ) this.top   .e4088(parse, from, force);         if (this.left  ) this.left  .e4088(parse, from, force);         if (this.right ) this.right .e4088(parse, from, force);         if (this.bottom) this.bottom.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.top   ) this.top   .q4086(parse);         if (this.left  ) this.left  .q4086(parse);         if (this.right ) this.right .q4086(parse);         if (this.bottom) this.bottom.q4086(parse);     } }


class l1894 extends u2043 {     tl = null;     tr = null;     bl = null;     br = null;                constructor(nodeId, options)     {         super(q1194, nodeId, options);     }                reset()     {         super.reset();                  this.tl = null;         this.tr = null;         this.bl = null;         this.br = null;     }        copy()     {         const copy = new l1894(this.nodeId, this.options);          copy.o3358(this);          if (this.tl) copy.tl = this.tl.copy();         if (this.tr) copy.tr = this.tr.copy();         if (this.bl) copy.bl = this.bl.copy();         if (this.br) copy.br = this.br.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalRoundedCornersValue(this.input, parse);         const tl    = await evalNumberValue        (this.tl,    parse);         const tr    = await evalNumberValue        (this.tr,    parse);         const bl    = await evalNumberValue        (this.bl,    parse);         const br    = await evalNumberValue        (this.br,    parse);           if (input)         {             this.value = new q2025(                 tl ?? input.tl,                 tr ?? input.tr,                 bl ?? input.bl,                 br ?? input.br,                 this.options.enabled);         }         else         {             this.value = new q2025(                 tl,                  tr,                  bl,                  br,                 this.options.enabled);         }           this.l4100(parse,         [             ['tl', this.value.tl],             ['tr', this.value.tr],             ['bl', this.value.bl],             ['br', this.value.br]         ]);                   if (!this.tl) this.tl = this.value.tl.copy();         if (!this.tr) this.tr = this.value.tr.copy();         if (!this.bl) this.bl = this.value.bl.copy();         if (!this.br) this.br = this.value.br.copy();           this.validate();          return this;     }        q3632()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.tl && this.tl.isValid()             && this.tr && this.tr.isValid()             && this.bl && this.bl.isValid()             && this.br && this.br.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.tl) this.tl.g4087(parse);         if (this.tr) this.tr.g4087(parse);         if (this.bl) this.bl.g4087(parse);         if (this.br) this.br.g4087(parse);     }                   e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.tl) this.tl.e4088(parse, from, force);         if (this.tr) this.tr.e4088(parse, from, force);         if (this.bl) this.bl.e4088(parse, from, force);         if (this.br) this.br.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.tl) this.tl.q4086(parse);         if (this.tr) this.tr.q4086(parse);         if (this.bl) this.bl.q4086(parse);         if (this.br) this.br.q4086(parse);     } }


class e1887 extends u2043 {     x      = null;     y      = null;     blur   = null;     spread = null;     fill   = null;     blend  = null;     behind = null;                constructor(nodeId, options)     {         super(h1197, nodeId, options);     }                reset()     {         super.reset();                  this.x      = null;         this.y      = null;         this.blur   = null;         this.spread = null;         this.fill   = null;         this.blend  = null;         this.behind = null;     }        copy()     {         const copy = new e1887(this.nodeId, this.options);          copy.o3358(this);          if (this.x     ) copy.x      = this.x     .copy();         if (this.y     ) copy.y      = this.y     .copy();         if (this.blur  ) copy.blur   = this.blur  .copy();         if (this.spread) copy.spread = this.spread.copy();         if (this.fill  ) copy.fill   = this.fill  .copy();         if (this.blend ) copy.blend  = this.blend .copy();         if (this.behind) copy.behind = this.behind.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalValue      (this.input,  parse);         const x      = await evalNumberValue(this.x,      parse);         const y      = await evalNumberValue(this.y,      parse);         const blur   = await evalNumberValue(this.blur,   parse);         const spread = await evalNumberValue(this.spread, parse);         let   fill   = await evalFillValue  (this.fill,   parse);         const blend  = await evalNumberValue(this.blend,  parse);         const behind = await evalNumberValue(this.behind, parse);           if (   fill             && fill.type == a1168)             fill = new e2012(fill);                   if (input)         {             this.value = new s2010(                 x      ?? input.x,                 y      ?? input.y,                 blur   ?? input.blur,                 spread ?? input.spread,                 fill   ?? input.fill,                 blend  ?? input.blend,                 behind ?? input.behind,                 this.options.enabled);         }         else         {             this.value = new s2010(                 x,                  y,                  blur,                  spread,                  fill,                  blend,                  behind,                 this.options.enabled);         }           this.l4100(parse,         [             ['x',      this.value.x     ],             ['y',      this.value.y     ],             ['blur',   this.value.blur  ],             ['spread', this.value.spread],             ['fill',   this.value.fill  ],             ['blend',  this.value.blend ],             ['behind', this.value.behind]         ]);                   if (!this.x     ) this.x      = this.value.x     .copy();         if (!this.y     ) this.y      = this.value.y     .copy();         if (!this.blur  ) this.blur   = this.value.blur  .copy();         if (!this.spread) this.spread = this.value.spread.copy();         if (!this.fill  ) this.fill   = this.value.fill  .copy();         if (!this.blend ) this.blend  = this.value.blend .copy();         if (!this.behind) this.behind = this.value.behind.copy();           this.validate();          return this;     }        q3632()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.x      && this.x     .isValid()             && this.y      && this.y     .isValid()             && this.blur   && this.blur  .isValid()             && this.spread && this.spread.isValid()             && this.fill   && this.fill  .isValid()             && this.blend  && this.blend .isValid()             && this.behind && this.behind.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.x     ) this.x     .g4087(parse);         if (this.y     ) this.y     .g4087(parse);         if (this.blur  ) this.blur  .g4087(parse);         if (this.spread) this.spread.g4087(parse);         if (this.fill  ) this.fill  .g4087(parse);         if (this.blend ) this.blend .g4087(parse);         if (this.behind) this.behind.g4087(parse);     }                   e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.x     ) this.x     .e4088(parse, from, force);         if (this.y     ) this.y     .e4088(parse, from, force);         if (this.blur  ) this.blur  .e4088(parse, from, force);         if (this.spread) this.spread.e4088(parse, from, force);         if (this.fill  ) this.fill  .e4088(parse, from, force);         if (this.blend ) this.blend .e4088(parse, from, force);         if (this.behind) this.behind.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.x     ) this.x     .q4086(parse);         if (this.y     ) this.y     .q4086(parse);         if (this.blur  ) this.blur  .q4086(parse);         if (this.spread) this.spread.q4086(parse);         if (this.fill  ) this.fill  .q4086(parse);         if (this.blend ) this.blend .q4086(parse);         if (this.behind) this.behind.q4086(parse);     } }


class x1890 extends u2043 {     x      = null;     y      = null;     blur   = null;     spread = null;     fill   = null;     blend  = null;                constructor(nodeId, options)     {         super(x1200, nodeId, options);     }        reset()     {         super.reset();          this.x      = null;         this.y      = null;         this.blur   = null;         this.spread = null;         this.fill   = null;         this.blend  = null;     }        copy()     {         const copy = new x1890(this.nodeId, this.options);          copy.o3358(this);          if (this.x     ) copy.x      = this.x     .copy();         if (this.y     ) copy.y      = this.y     .copy();         if (this.blur  ) copy.blur   = this.blur  .copy();         if (this.spread) copy.spread = this.spread.copy();         if (this.fill  ) copy.fill   = this.fill  .copy();         if (this.blend ) copy.blend  = this.blend .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalInnerShadowValue(this.input,  parse);         const x      = await evalNumberValue     (this.x,      parse);         const y      = await evalNumberValue     (this.y,      parse);         const blur   = await evalNumberValue     (this.blur,   parse);         const spread = await evalNumberValue     (this.spread, parse);         let   fill   = await evalFillValue       (this.fill,   parse);         const blend  = await evalNumberValue     (this.blend,  parse);                   if (   fill             && fill.type == a1168)             fill = new e2012(fill);           if (input)         {             this.value = new x2015(                 x      ?? input.x,                 y      ?? input.y,                 blur   ?? input.blur,                 spread ?? input.spread,                 fill   ?? input.fill,                 blend  ?? input.blend,                 this.options.enabled);         }         else         {             this.value = new x2015(                 x,                  y,                  blur,                  spread,                  fill,                  blend,                 this.options.enabled);         }           this.l4100(parse,         [             ['x',      this.value.x     ],             ['y',      this.value.y     ],             ['blur',   this.value.blur  ],             ['spread', this.value.spread],             ['fill',   this.value.fill  ],             ['blend',  this.value.blend ],         ]);                   if (!this.x     ) this.x      = this.value.x     .copy();         if (!this.y     ) this.y      = this.value.y     .copy();         if (!this.blur  ) this.blur   = this.value.blur  .copy();         if (!this.spread) this.spread = this.value.spread.copy();         if (!this.fill  ) this.fill   = this.value.fill  .copy();         if (!this.blend ) this.blend  = this.value.blend .copy();           this.validate();          return this;     }        q3632()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.x      && this.x     .isValid()             && this.y      && this.y     .isValid()             && this.blur   && this.blur  .isValid()             && this.spread && this.spread.isValid()             && this.fill   && this.fill  .isValid()             && this.blend  && this.blend .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.x     ) this.x     .g4087(parse);         if (this.y     ) this.y     .g4087(parse);         if (this.blur  ) this.blur  .g4087(parse);         if (this.spread) this.spread.g4087(parse);         if (this.fill  ) this.fill  .g4087(parse);         if (this.blend ) this.blend .g4087(parse);     }                    e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.x     ) this.x     .e4088(parse, from, force);         if (this.y     ) this.y     .e4088(parse, from, force);         if (this.blur  ) this.blur  .e4088(parse, from, force);         if (this.spread) this.spread.e4088(parse, from, force);         if (this.fill  ) this.fill  .e4088(parse, from, force);         if (this.blend ) this.blend .e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.x     ) this.x     .q4086(parse);         if (this.y     ) this.y     .q4086(parse);         if (this.blur  ) this.blur  .q4086(parse);         if (this.spread) this.spread.q4086(parse);         if (this.fill  ) this.fill  .q4086(parse);         if (this.blend ) this.blend .q4086(parse);     } }


class z1892 extends u2043 {     radius = null;        constructor(nodeId, options)     {         super(o1203, nodeId, options);     }        reset()     {         super.reset();          this.radius = null;     }        copy()     {         const copy = new z1892(this.nodeId, this.options);          copy.o3358(this);          if (this.radius) copy.radius = this.radius.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalLayerBlurValue(this.input,  parse);         const radius = await evalNumberValue   (this.radius, parse);                   if (input)         {             this.value = new z2017(                 radius ?? input.radius,                 this.options.enabled);         }         else         {             this.value = new z2017(                 radius,                 this.options.enabled);         }           this.l4100(parse,         [             ['radius', this.value.radius]         ]);                   if (!this.radius) this.radius = this.value.radius.copy();           this.validate();          return this;     }        q3632()     {         return new z2017(             this.radius ? this.radius.q3632() : this.input.radius.q3632(),             this.options.enabled);     }        isValid()     {         return super.isValid()             && this.radius && this.radius.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.radius) this.radius.g4087(parse);     }                    e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.radius) this.radius.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.radius) this.radius.q4086(parse);     } }


class v1884 extends u2043 {     radius = null;        constructor(nodeId, options)     {         super(d1206, nodeId, options);     }        reset()     {         super.reset();          this.radius = null;     }        copy()     {         const copy = new v1884(this.nodeId, this.options);          copy.o3358(this);          if (this.radius) copy.radius = this.radius.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalValue      (this.input,  parse);         const radius = await evalNumberValue(this.radius, parse);                   if (input)         {             this.value = new p2007(                 radius ?? input.radius,                 this.options.enabled);         }         else         {             this.value = new p2007(                 radius,                 this.options.enabled);         }           this.l4100(parse,         [             ['radius', this.value.radius]         ]);                   if (!this.radius) this.radius = this.value.radius.copy();           this.validate();          return this;     }        q3632()     {         return new p2007(             this.radius ? this.radius.q3632() : this.input.radius.q3632(),             this.options.enabled);     }        isValid()     {         return super.isValid()             && this.radius && this.radius.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.radius) this.radius.g4087(parse);     }                    e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.radius) this.radius.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.radius) this.radius.q4086(parse);     } }


class s1891 extends z2042 {     opacity;     blend;        constructor(nodeId, options)     {         super(f1212, nodeId, options);     }        reset()     {         super.reset();          this.opacity = null;         this.blend   = null;     }        copy()     {         const copy = new s1891(this.nodeId, this.options);          copy.o3358(this);          if (this.opacity) copy.opacity = this.opacity.copy();         if (this.blend  ) copy.blend   = this.blend  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const opacity = await evalNumberValue(this.opacity, parse);         const blend   = await evalNumberValue(this.blend,   parse);           this.value =              this.options.enabled             ? new f2016(opacity, blend)             : new f2016(new z2021(100), new z2021(0));           this.l4100(parse,          [             ['opacity', opacity],             ['blend',   blend  ]         ]);           this.validate();          return this;     }        q3632()     {         return this.value.copy();     }        isValid()     {         return this.opacity && this.opacity.isValid()             && this.blend   && this.blend  .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.opacity) this.opacity.g4087(parse);         if (this.blend  ) this.blend  .g4087(parse);     }                    e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.opacity) this.opacity.e4088(parse, from, force);         if (this.blend  ) this.blend  .e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.opacity) this.opacity.q4086(parse);         if (this.blend  ) this.blend  .q4086(parse);     } }


class a1893 extends z2042 {     maskType;        constructor(nodeId, options)     {         super(o1209, nodeId, options);     }        reset()     {         super.reset();          this.maskType = null;     }        copy()     {         const copy = new a1893(this.nodeId, this.options);          copy.o3358(this);          if (this.maskType) copy.maskType = this.maskType.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const maskType = await evalNumberValue(this.maskType, parse);           this.value = new c2018(maskType, this.options.enabled);           this.l4100(parse,          [             ['maskType', maskType]         ]);           this.validate();          return this;     }        q3632()     {         return this.value.copy();     }        isValid()     {         return this.maskType && this.maskType.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.maskType) this.maskType.g4087(parse);     }                    e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.maskType) this.maskType.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.maskType) this.maskType.q4086(parse);     } }


class p1974 extends z2042 {     x      = null;     y      = null;     width  = null;     height = null;        constructor(type, nodeId, options)     {         super(type, nodeId, options);     }        reset()     {         super.reset();                  this.x      = null;         this.y      = null;         this.width  = null;         this.height = null;     }        o3358(base)     {         super.o3358(base);          if (base.x     ) this.x      = base.x     .copy();         if (base.y     ) this.y      = base.y     .copy();         if (base.width ) this.width  = base.width .copy();         if (base.height) this.height = base.height.copy();     }        async evalBaseParams(parse, evalHeight = true)     {         let x      =              await evalNumberValue(this.x,      parse);         let y      =              await evalNumberValue(this.y,      parse);         let width  =              await evalNumberValue(this.width,  parse);         let height = evalHeight ? await evalNumberValue(this.height, parse) : null;          return [x, y, width, height];     }        evalStyle(options = {})     {                       }        isValid()     {         return this.x      && this.x     .isValid()             && this.y      && this.y     .isValid()             && this.width  && this.width .isValid()             && this.height && this.height.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.x     ) this.x     .g4087(parse);         if (this.y     ) this.y     .g4087(parse);         if (this.width ) this.width .g4087(parse);         if (this.height) this.height.g4087(parse);     }            e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.x     ) this.x     .e4088(parse, from, force);         if (this.y     ) this.y     .e4088(parse, from, force);         if (this.width ) this.width .e4088(parse, from, force);         if (this.height) this.height.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.x     ) this.x     .q4086(parse);         if (this.y     ) this.y     .q4086(parse);         if (this.width ) this.width .q4086(parse);         if (this.height) this.height.q4086(parse);     } }    function validateObjectRect(x, y, w, h, a = 0, _a = 0) {     if (w < 0)     {         x += w * Math.cos(_a);         y += w * Math.sin(_a);     }      if (h < 0)     {         y += h * Math.cos(_a);         x -= h * Math.sin(_a);     }             w = Math.abs(w);     h = Math.abs(h);       return [x, y, w, h, a, _a]; }


class c1973 extends p1974 {     input = null;      props = null;           constructor(type, nodeId, options)     {         super(type, nodeId, options);     }        reset()     {         super.reset();          this.input = null;         this.props = null;     }        o3358(base)     {         super.o3358(base);                  if (base.input) this.input = base.input.copy();         if (base.props) this.props = base.props.copy();     }        u4241(v2991)     {         switch (v2991)         {             case 'props':  return this.input ? this.value.props : this.props;         }          return null;     }        w2896()     {         return this.value             && this.value.props             && this.value.props.isValid();     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        async s2895(parse)     {         let props = await evalListValue(this.props, parse);          if (   props             && a1215.includes(props.type))             props = new u2020([props]);                   if (this.value)         {             if (this.input)             {                 this.value.props = props ?? this.input.q3632().props;                                  if (props)  this.value.props = props;  else  props = this.value.props;               }             else                 this.value.props = props;                                   if (   this.value                 && this.value.isValid()                 && this.value.props != undefined)              {                 this.l4100(parse,                  [                                      ],                  true);                                   if (!this.props) this.props = this.value.props.copy();             }         }     }        async t4099(parse)     {         if (!this.value)             return;           for (const g111 of this.value.objects)         {             c952(g111.fills,   'obj.fills   must not be null');             c952(g111.strokes, 'obj.strokes must not be null');             c952(g111.effects, 'obj.effects must not be null');               if (this.value.props)                 addProps(g111, this.value.props);         }     }        evalStyle(options = {})     {      }        isValid()     {         return super.isValid()             && (!this.input || this.input.isValid())             && this.props && this.props.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.input) this.input.g4087(parse);         if (this.props) this.props.g4087(parse);     }            e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.input) this.input.e4088(parse, from, force);         if (this.props) this.props.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.input) this.input.q4086(parse);         if (this.props) this.props.q4086(parse);     } }    function addProps(g111, props) {     if (o957(props.type))     {                        for (let i = 0; i < props.items.length; i++)             k1822(g111, props.items[i]);     }     else         k1822(g111, props); }


class m1968 extends c1973 {     round = null;        constructor(nodeId, options)     {         super(g1219, nodeId, options);     }        reset()     {         super.reset();          this.round = null;     }        copy()     {         const copy = new m1968(this.nodeId, this.options);          copy.o3358(this);          if (this.round) copy.round = this.round.copy();          return copy;     }        u4241(v2991)     {         switch (v2991)         {             case 'x':      return this.input ? this.value.x      : this.x;             case 'y':      return this.input ? this.value.y      : this.y;             case 'width':  return this.input ? this.value.width  : this.width;             case 'height': return this.input ? this.value.height : this.height;             case 'round':  return this.input ? this.value.round  : this.round;         }          return super.u4241(v2991);     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalRectangleValue(this.input, parse);         let   round = await evalNumberValue   (this.round, parse);          if (round && !round.isValid()) round = z2021.NaN.copy();                   let [x, y, width, height] = await this.evalBaseParams(parse);           if (input)         {             this.value        = input.q3632();             this.value.nodeId = this.nodeId;             this.value.v3625(input);                          if (x     )  this.value.x      = x;       else  x      = this.value.x;                   if (y     )  this.value.y      = y;       else  y      = this.value.y;                   if (width )  this.value.width  = width;   else  width  = this.value.width;               if (height)  this.value.height = height;  else  height = this.value.height;              if (round )  this.value.round  = round;   else  round  = this.value.round;           }         else         {             this.value = new k2024(                 this.nodeId,                  x,                  y,                  width,                  height,                  round);         }                  this.l4100(parse,          [             ['x',      x     ],             ['y',      y     ],             ['width',  width ],             ['height', height],             ['round',  round ]         ]);           await this.s2895(parse);           await this.t4099(parse);           if (!this.x     ) this.x      = this.value.x     .copy();         if (!this.y     ) this.y      = this.value.y     .copy();         if (!this.width ) this.width  = this.value.width .copy();         if (!this.height) this.height = this.value.height.copy();         if (!this.round ) this.round  = this.value.round .copy();           this.validate();          return this;     }        async t4099(parse, options = {})     {         if (!this.options.enabled)             return;                        this.value.objects = [];           if (   super.w2896()                && this.value.x     .isValid()             && this.value.y     .isValid()             && this.value.width .isValid()             && this.value.height.isValid()             && this.value.round .isValid())         {             let   x = this.value.x     .value;             let   y = this.value.y     .value;             let   w = this.value.width .value;             let   h = this.value.height.value;             const r = Math.max(0, this.value.round.value);               [x, y, w, h, , ] = validateObjectRect(x, y, w, h);               if (   w != 0                  && h != 0)             {                 const rect = new a1845(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     x, y, w, h, r);                  rect.s4097(x, y);                 rect.l3729(x, y, w, h);                  this.value.objects.push(rect);             }         }                   await super.t4099(parse);     }                                                                                    isValid()     {         return super.isValid()             && this.round && this.round.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.round) this.round.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.round) this.round.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.round) this.round.q4086(parse);     } }


class u1959 extends c1973 {     constructor(nodeId, options)     {         super(i1222, nodeId, options);     }        copy()     {         const copy = new u1959(this.nodeId, this.options);          copy.o3358(this);          return copy;     }        u4241(v2991)     {         switch (v2991)         {             case 'x':     return this.input ? this.value.x     : this.x;             case 'y':     return this.input ? this.value.y     : this.y;             case 'width': return this.input ? this.value.width : this.width;         }          return super.u4241(v2991);     }        async eval(parse)     {         if (this.isCached())             return this;           let input = await evalLineValue(this.input, parse);          let [x, y, width, ] = await this.evalBaseParams(parse, false);                       if (input)         {             this.value        = input.q3632();             this.value.nodeId = this.nodeId;             this.value.v3625(input);              if (x    )  this.value.x     = x;      else  x     = this.value.x;                   if (y    )  this.value.y     = y;      else  y     = this.value.y;                   if (width)  this.value.width = width;  else  width = this.value.width;           }         else         {             this.value = new l2019(                 this.nodeId,                  x,                  y,                  width);         }           this.l4100(parse,          [             ['x',      x     ],             ['y',      y     ],             ['width',  width ]         ]);           await this.s2895(parse);           await this.t4099(parse);           if (!this.x    ) this.x     = this.value.x    .copy();         if (!this.y    ) this.y     = this.value.y    .copy();         if (!this.width) this.width = this.value.width.copy();           this.validate();          return this;     }        async t4099(parse, options = {})     {         if (!this.options.enabled)             return;                       this.value.objects = [];           if (   super.w2896()                && this.value.x    .isValid()             && this.value.y    .isValid()             && this.value.width.isValid())          {             let x = this.value.x    .value;             let y = this.value.y    .value;             let w = this.value.width.value;               [x, y, w, , , ] = validateObjectRect(x, y, w, 0);               if (w != 0)             {                 const line = new q1841(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     x, y, w);                  line.s4097(x, y);                 line.l3729(x, y, w, 0.01);                                  this.value.objects.push(line);             }         }                   await super.t4099(parse);     }        isValid()     {         return super.isValid()             && this.x     && this.x    .isValid()             && this.y     && this.y    .isValid()             && this.width && this.width.isValid();     }        g4087(parse)     {         super.g4087(parse);           if (this.x    ) this.x    .g4087(parse);         if (this.y    ) this.y    .g4087(parse);         if (this.width) this.width.g4087(parse);     }                   e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.x    ) this.x    .e4088(parse, from, force);         if (this.y    ) this.y    .e4088(parse, from, force);         if (this.width) this.width.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);           if (this.x    ) this.x    .q4086(parse);         if (this.y    ) this.y    .q4086(parse);         if (this.width) this.width.q4086(parse);     } }


class r1955 extends c1973 {     position = null;     round    = null;     start    = null;     sweep    = null;     inner    = null;      innerAbsolute;     sweepInDegrees;        constructor(nodeId, options)     {         super(c1225, nodeId, options);     }        reset()     {         super.reset();          this.position = null;         this.round    = null;         this.start    = null;         this.sweep    = null;         this.inner    = null;     }        copy()     {         const copy = new r1955(this.nodeId, this.options);          copy.o3358(this);          if (this.position) copy.position = this.position.copy();         if (this.round   ) copy.round    = this.round   .copy();         if (this.start   ) copy.start    = this.start   .copy();         if (this.sweep   ) copy.sweep    = this.sweep   .copy();         if (this.inner   ) copy.inner    = this.inner   .copy();                  return copy;     }        u4241(v2991)     {         switch (v2991)         {             case 'position': return this.input ? this.value.position : this.position;             case 'x':        return this.input ? this.value.x        : this.x;             case 'y':        return this.input ? this.value.y        : this.y;             case 'width':    return this.input ? this.value.width    : this.width;             case 'height':   return this.input ? this.value.height   : this.height;             case 'round':    return this.input ? this.value.round    : this.round;             case 'start':    return this.input ? this.value.start    : this.start;             case 'sweep':    return this.input ? this.value.sweep    : this.sweep;             case 'inner':    return this.input ? this.value.inner    : this.inner         }          return super.u4241(v2991);     }        async eval(parse)     {         if (this.isCached())             return this;           let [x, y, width, height] = await this.evalBaseParams(parse);          let input = await evalValue      (this.input,    parse);         let pos   = await evalNumberValue(this.position, parse);         let round = await evalNumberValue(this.round,    parse);         let start = await evalNumberValue(this.start,    parse);         let sweep = await evalNumberValue(this.sweep,    parse);         let inner = await evalNumberValue(this.inner,    parse);          if (pos   && !pos  .isValid()) pos   = z2021.NaN.copy();         if (round && !round.isValid()) round = z2021.NaN.copy();         if (start && !start.isValid()) start = z2021.NaN.copy();         if (sweep && !sweep.isValid()) sweep = z2021.NaN.copy();         if (inner && !inner.isValid()) inner = z2021.NaN.copy();           if (input)         {             this.value        = input.copy();             this.value.nodeId = this.nodeId;             this.value.v3625(input);              if (pos   )  this.value.position = pos;     else  pos    = this.value.position;             if (x     )  this.value.x        = x;       else  x      = this.value.x;                   if (y     )  this.value.y        = y;       else  y      = this.value.y;                   if (width )  this.value.width    = width;   else  width  = this.value.width;               if (height)  this.value.height   = height;  else  height = this.value.height;              if (round )  this.value.round    = round;   else  round  = this.value.round;               if (start )  this.value.start    = start;   else  start  = this.value.start;             if (sweep )  this.value.sweep    = sweep;   else  sweep  = this.value.sweep;             if (inner )  this.value.inner    = inner;   else  inner  = this.value.inner;           }         else         {             this.value = new g2011(                 this.nodeId,                 pos,                 x,                  y,                  width,                  height,                 round,                 start,                 sweep,                 inner);         }           this.l4100(parse,          [             ['position', pos   ],             ['x',        x     ],             ['y',        y     ],             ['width',    width ],             ['height',   height],             ['round',    round ],             ['start',    start ],             ['sweep',    sweep ],             ['inner',    inner ]         ]);           await this.s2895(parse);           await this.t4099(parse);           this.validate();          return this;     }        async t4099(parse, options = {})     {        if (!this.options.enabled)            return;                                 this.value.objects = [];           if (   super.w2896()             && this.value.x     .isValid()             && this.value.y     .isValid()             && this.value.width .isValid()             && this.value.height.isValid())          {             const vpos = this.value.position;             const vx   = this.value.x;             const vy   = this.value.y;             const vw   = this.value.width;             const vh   = this.value.height;              const _x = vpos.value <= 0 ? vx : new z2021(vx.value - vw.value, Math.max(vx.decimals, vw.decimals));             const _y = vpos.value <= 0 ? vy : new z2021(vy.value - vh.value, Math.max(vy.decimals, vh.decimals));             const _w = vpos.value <= 0 ? vw : new z2021(vw.value*2, Math.max(vx.decimals, vw.decimals));             const _h = vpos.value <= 0 ? vh : new z2021(vh.value*2, Math.max(vy.decimals, vh.decimals));                          let   x  = _x.value;             let   y  = _y.value;             let   w  = _w.value;             let   h  = _h.value;             let   r  = this.value.round .value;             const st = this.value.start .value;             let   sw = this.value.sweep .value;             let   i  = this.value.inner .value;               [x, y, w, h, , ] = validateObjectRect(x, y, w, h);               if (   w != 0                  && h != 0)             {                 if (this.innerAbsolute ) i  /= Math.max(w, h) / 200;                 if (this.sweepInDegrees) sw /= 3.6;                  const ellipse = new e1839(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     x, y, w, h, r, st, sw, i);                  ellipse.s4097(x, y);                 ellipse.l3729(x, y, w, h);                  this.value.objects.push(ellipse);             }         }           await super.t4099(parse);     }                       isValid()     {         return super.isValid()             && this.position && this.position.isValid()             && this.round    && this.round   .isValid()             && this.start    && this.start   .isValid()             && this.sweep    && this.sweep   .isValid()             && this.inner    && this.inner   .isValid();     }        g4087(parse)     {         super.g4087(parse);           if (this.position) this.position.g4087(parse);         if (this.round   ) this.round   .g4087(parse);         if (this.start   ) this.start   .g4087(parse);         if (this.sweep   ) this.sweep   .g4087(parse);         if (this.inner   ) this.inner   .g4087(parse);     }                   e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.position) this.position.e4088(parse, from, force);         if (this.round   ) this.round   .e4088(parse, from, force);         if (this.start   ) this.start   .e4088(parse, from, force);         if (this.sweep   ) this.sweep   .e4088(parse, from, force);         if (this.inner   ) this.inner   .e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);           if (this.position) this.position.q4086(parse);         if (this.round   ) this.round   .q4086(parse);         if (this.start   ) this.start   .q4086(parse);         if (this.sweep   ) this.sweep   .q4086(parse);         if (this.inner   ) this.inner   .q4086(parse);     } }


class d1979 extends c1973 {     round = null;     bias  = null;        constructor(nodeId, options)     {         super(c1228, nodeId, options);     }        reset()     {         super.reset();          this.round = null;         this.bias  = null;     }        copy()     {         const copy = new d1979(this.nodeId, this.options);          copy.o3358(this);          if (this.round) copy.round = this.round.copy();         if (this.bias ) copy.bias  = this.bias .copy();          return copy;     }        u4241(v2991)     {         switch (v2991)         {             case 'x':      return this.input ? this.value.x      : this.x;             case 'y':      return this.input ? this.value.y      : this.y;             case 'width':  return this.input ? this.value.width  : this.width;             case 'height': return this.input ? this.value.height : this.height;             case 'round':  return this.input ? this.value.round  : this.round;             case 'bias':   return this.input ? this.value.bias   : this.bias;         }          return super.u4241(v2991);     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalValue      (this.input, parse);         let   round = await evalNumberValue(this.round, parse);         let   bias  = await evalNumberValue(this.bias,  parse);                  let [x, y, width, height] = await this.evalBaseParams(parse);           if (input)         {             this.value        = input.q3632();             this.value.nodeId = this.nodeId;             this.value.v3625(input);              if (x     )  this.value.x      = x;       else  x      = this.value.x;                   if (y     )  this.value.y      = y;       else  y      = this.value.y;                   if (width )  this.value.width  = width;   else  width  = this.value.width;               if (height)  this.value.height = height;  else  height = this.value.height;              if (round )  this.value.round  = round;   else  round  = this.value.round;               if (bias  )  this.value.bias   = bias;    else  bias   = this.value.bias;           }         else         {             this.value = new s2033(                 this.nodeId,                  x,                  y,                  width,                  height,                  round,                 bias);         }                  this.l4100(parse,          [             ['x',      x     ],             ['y',      y     ],             ['width',  width ],             ['height', height],             ['round',  round ],             ['bias',   bias  ]         ]);           await this.s2895(parse);           await this.t4099(parse);           if (!this.x     ) this.x      = this.value.x     .copy();         if (!this.y     ) this.y      = this.value.y     .copy();         if (!this.width ) this.width  = this.value.width .copy();         if (!this.height) this.height = this.value.height.copy();         if (!this.round ) this.round  = this.value.round .copy();         if (!this.bias  ) this.bias   = this.value.bias  .copy();           this.validate();          return this;     }        async t4099(parse, options = {})     {         if (!this.options.enabled)             return;                        this.value.objects = [];           if (   super.w2896()                && this.value.x     .isValid()                 && this.value.y     .isValid()                 && this.value.width .isValid()             && this.value.height.isValid()             && this.value.round .isValid()             && this.value.bias  .isValid())         {             let   x = this.value.x     .value;             let   y = this.value.y     .value;             let   w = this.value.width .value;             let   h = this.value.height.value;             const r = Math.max(0, this.value.round.value);             let   b = this.value.bias  .value;               [x, y, w, h, , ] = validateObjectRect(x, y, w, h);               if (   w != 0                  && h != 0)             {                 const trapeze = new b1850(                     this.nodeId,                      this.nodeId,                      this.nodeName,                      x, y, w, h, r, b);                  trapeze.s4097(x, y);                 trapeze.l3729(x, y, w, h);                  this.value.objects.push(trapeze);             }         }           await super.t4099(parse);     }        isValid()     {         return super.isValid()             && this.round && this.round.isValid()             && this.bias  && this.bias .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.round) this.round.g4087(parse);         if (this.bias ) this.bias .g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.round) this.round.e4088(parse, from, force);         if (this.bias ) this.bias .e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.round) this.round.q4086(parse);         if (this.bias ) this.bias .q4086(parse);     } }


class o1967 extends c1973 {     position = null;     round    = null;     corners  = null;        constructor(nodeId, options)     {         super(e1237, nodeId, options);     }        reset()     {         super.reset();          this.position = null;         this.round    = null;         this.corners  = null;     }        copy()     {         const copy = new o1967(this.nodeId, this.options);          copy.o3358(this);          if (this.position) copy.position = this.position.copy();         if (this.round   ) copy.round    = this.round   .copy();         if (this.corners ) copy.corners  = this.corners .copy();          return copy;     }        u4241(v2991)     {         switch (v2991)         {             case 'position': return this.input ? this.value.position : this.position;             case 'x':        return this.input ? this.value.x        : this.x;             case 'y':        return this.input ? this.value.y        : this.y;             case 'width':    return this.input ? this.value.width    : this.width;             case 'height':   return this.input ? this.value.height   : this.height;             case 'round':    return this.input ? this.value.round    : this.round;             case 'corners':  return this.input ? this.value.corners  : this.corners;         }          return super.u4241(v2991);     }        async eval(parse)     {         if (this.isCached())             return this;                       let [x, y, width, height] = await this.evalBaseParams(parse);          let input   = await evalPolygonValue(this.input,    parse);         let pos     = await evalNumberValue (this.position, parse);         let round   = await evalNumberValue (this.round,    parse);         let corners = await evalNumberValue (this.corners,  parse);           if (input)         {             this.value        = input.q3632();             this.value.nodeId = this.nodeId;             this.value.v3625(input);              if (pos    )  this.value.position = pos;      else  pos     = this.value.position;             if (x      )  this.value.x        = x;        else  x       = this.value.x;                   if (y      )  this.value.y        = y;        else  y       = this.value.y;                   if (width  )  this.value.width    = width;    else  width   = this.value.width;               if (height )  this.value.height   = height;   else  height  = this.value.height;              if (round  )  this.value.round    = round;    else  round   = this.value.round;               if (corners)  this.value.corners  = corners;  else  corners = this.value.corners;           }         else         {             this.value = new u2023(                 this.nodeId,                 pos,                 x,                  y,                  width,                  height,                 round,                 corners);         }           this.l4100(parse,          [             ['position', pos    ],             ['x',        x      ],             ['y',        y      ],             ['width',    width  ],             ['height',   height ],             ['round',    round  ],             ['corners',  corners]         ]);           await this.s2895(parse);           await this.t4099(parse);           if (!this.position) this.position = this.value.position.copy();         if (!this.x       ) this.x        = this.value.x       .copy();         if (!this.y       ) this.y        = this.value.y       .copy();         if (!this.width   ) this.width    = this.value.width   .copy();         if (!this.height  ) this.height   = this.value.height  .copy();         if (!this.round   ) this.round    = this.value.round   .copy();         if (!this.corners ) this.corners  = this.value.corners .copy();           this.validate();          return this;     }        async t4099(parse, options = {})     {         if (!this.options.enabled)             return;                                   this.value.objects = [];           if (   super.w2896()                && this.value.x      .isValid()             && this.value.y      .isValid()             && this.value.width  .isValid()             && this.value.height .isValid()             && this.value.round  .isValid()             && this.value.corners.isValid())         {             const vpos = this.value.position;             const vx   = this.value.x;             const vy   = this.value.y;             const vw   = this.value.width;             const vh   = this.value.height;              const _x = vpos.value <= 0 ? vx : new z2021(vx.value - vw.value, Math.max(vx.decimals, vw.decimals));             const _y = vpos.value <= 0 ? vy : new z2021(vy.value - vh.value, Math.max(vy.decimals, vh.decimals));             const _w = vpos.value <= 0 ? vw : new z2021(vw.value*2, Math.max(vx.decimals, vw.decimals));             const _h = vpos.value <= 0 ? vh : new z2021(vh.value*2, Math.max(vy.decimals, vh.decimals));                          let   x = _x.value;             let   y = _y.value;             let   w = _w.value;             let   h = _h.value;             const r = Math.max(0, this.value.round.value);             const c = Math.max(3, Math.floor(this.value.corners.value));               [x, y, w, h, , ] = validateObjectRect(x, y, w, h);               if (   w != 0                  && h != 0)             {                 const poly = new m1844(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     x, y, w, h, r, c);                  poly.s4097(x, y);                 poly.l3729(x, y, w, h);                  this.value.objects.push(poly);             }         }                   await super.t4099(parse);     }                                                                                              isValid()     {         return super.isValid()             && this.position && this.position.isValid()             && this.round    && this.round   .isValid()             && this.corners  && this.corners .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.position) this.position.g4087(parse);         if (this.round   ) this.round   .g4087(parse);         if (this.corners ) this.corners .g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.position) this.position.e4088(parse, from, force);         if (this.round   ) this.round   .e4088(parse, from, force);         if (this.corners ) this.corners .e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.position) this.position.q4086(parse);         if (this.round   ) this.round   .q4086(parse);         if (this.corners ) this.corners .q4086(parse);     } }


 class v1977 extends c1973 {     position = null;     round    = null;     points   = null;     convex   = null;        constructor(nodeId, options)     {         super(f1240, nodeId, options);     }        reset()     {         super.reset();          this.position = null;         this.round    = null;         this.points   = null;         this.convex   = null;     }        copy()     {         const copy = new v1977(this.nodeId, this.options);          copy.o3358(this);          if (this.position) copy.position = this.position.copy();         if (this.round   ) copy.round    = this.round   .copy();         if (this.points  ) copy.points   = this.points  .copy();         if (this.convex  ) copy.convex   = this.convex  .copy();          return copy;     }        u4241(v2991)     {         switch (v2991)         {             case 'position': return this.input ? this.value.position : this.position;             case 'x':        return this.input ? this.value.x        : this.x;             case 'y':        return this.input ? this.value.y        : this.y;             case 'width':    return this.input ? this.value.width    : this.width;             case 'height':   return this.input ? this.value.height   : this.height;             case 'round':    return this.input ? this.value.round    : this.round;             case 'points':   return this.input ? this.value.points   : this.points;             case 'convex':   return this.input ? this.value.convex   : this.convex;         }          return super.u4241(v2991);     }        async eval(parse)     {         if (this.isCached())             return this;                       let [x, y, width, height] = await this.evalBaseParams(parse);          let input  = await evalValue      (this.input,    parse);         let pos    = await evalNumberValue(this.position, parse);         let round  = await evalNumberValue(this.round,    parse);         let points = await evalNumberValue(this.points,   parse);         let convex = await evalNumberValue(this.convex,   parse);           if (input)         {             this.value        = input.q3632();             this.value.nodeId = this.nodeId;             this.value.v3625(input);              if (pos   )  this.value.position = pos;     else  pos    = this.value.position;             if (x     )  this.value.x        = x;       else  x      = this.value.x;                   if (y     )  this.value.y        = y;       else  y      = this.value.y;                   if (width )  this.value.width    = width;   else  width  = this.value.width;               if (height)  this.value.height   = height;  else  height = this.value.height;              if (round )  this.value.round    = round;   else  round  = this.value.round;               if (points)  this.value.points   = points;  else  points = this.value.points;               if (convex)  this.value.convex   = convex;  else  convex = this.value.convex;          }         else         {             this.value = new q2029(                 this.nodeId,                 pos,                 x,                  y,                  width,                  height,                 round,                 points,                 convex);         }           this.l4100(parse,          [             ['position', pos   ],             ['x',        x     ],             ['y',        y     ],             ['width',    width ],             ['height',   height],             ['round',    round ],             ['points',   points],             ['convex',   convex]         ]);           await this.s2895(parse);           await this.t4099(parse);           if (!this.position) this.position = this.value.position.copy();         if (!this.x       ) this.x        = this.value.x       .copy();         if (!this.y       ) this.y        = this.value.y       .copy();         if (!this.width   ) this.width    = this.value.width   .copy();         if (!this.height  ) this.height   = this.value.height  .copy();         if (!this.round   ) this.round    = this.value.round   .copy();         if (!this.points  ) this.points   = this.value.points  .copy();         if (!this.convex  ) this.convex   = this.value.convex  .copy();            this.validate();          return this;    }       async t4099(parse, options = {})    {         if (!this.options.enabled)            return;                                 this.value.objects = [];           if (   super.w2896()                && this.value.x     .isValid()             && this.value.y     .isValid()             && this.value.width .isValid()             && this.value.height.isValid()              && this.value.round .isValid()             && this.value.points.isValid()             && this.value.convex.isValid())         {             const vpos = this.value.position;             const vx   = this.value.x;             const vy   = this.value.y;             const vw   = this.value.width;             const vh   = this.value.height;              const _x = vpos.value <= 0 ? vx : new z2021(vx.value - vw.value, Math.max(vx.decimals, vw.decimals));             const _y = vpos.value <= 0 ? vy : new z2021(vy.value - vh.value, Math.max(vy.decimals, vh.decimals));             const _w = vpos.value <= 0 ? vw : new z2021(vw.value*2, Math.max(vx.decimals, vw.decimals));             const _h = vpos.value <= 0 ? vh : new z2021(vh.value*2, Math.max(vy.decimals, vh.decimals));                          let   x = _x.value;             let   y = _y.value;             let   w = _w.value;             let   h = _h.value;             const r = Math.max(0, this.value.round.value);             const p = Math.max(3, Math.floor(this.value.points.value));             const c = this.value.convex.value;               if (   w != 0                 && h != 0)             {                 const star = new i1848(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     x, y, w, h, r, p, c);                  star.s4097(x, y);                 star.l3729(x, y, w, h);                  this.value.objects.push(star);             }         }                  await super.t4099(parse);     }                                                                                                    isValid()     {         return super.isValid()             && this.position && this.position.isValid()             && this.round    && this.round   .isValid()             && this.points   && this.points  .isValid()             && this.convex   && this.convex  .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.position) this.position.g4087(parse);         if (this.round   ) this.round   .g4087(parse);         if (this.points  ) this.points  .g4087(parse);         if (this.convex  ) this.convex  .g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.position) this.position.e4088(parse, from, force);         if (this.round   ) this.round   .e4088(parse, from, force);         if (this.points  ) this.points  .e4088(parse, from, force);         if (this.convex  ) this.convex  .e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.position) this.position.q4086(parse);         if (this.round   ) this.round   .q4086(parse);         if (this.points  ) this.points  .q4086(parse);         if (this.convex  ) this.convex  .q4086(parse);     } }


class q1978 extends c1973 {     text          = null;     x             = null;     y             = null;     width         = null;     height        = null;     font          = null;     size          = null;     style         = null;     alignX        = null;     alignY        = null;     lineHeight    = null;     letterSpacing = null;                constructor(nodeId, options)     {         super(k1243, nodeId, options);     }            reset()     {         super.reset();                  this.text          = null;         this.x             = null;         this.y             = null;         this.width         = null;         this.height        = null;         this.font          = null;         this.size          = null;         this.style         = null;         this.alignX        = null;         this.alignY        = null;         this.lineHeight    = null;         this.letterSpacing = null;     }        copy()     {         const copy = new q1978(this.nodeId, this.options);          copy.o3358(this);          if (this.text         ) copy.text          = this.text         .copy();         if (this.x            ) copy.x             = this.x            .copy();         if (this.y            ) copy.y             = this.y            .copy();         if (this.width        ) copy.width         = this.width        .copy();         if (this.height       ) copy.height        = this.height       .copy();         if (this.font         ) copy.font          = this.font         .copy();         if (this.style        ) copy.style         = this.style        .copy();         if (this.size         ) copy.size          = this.size         .copy();         if (this.alignX       ) copy.alignX        = this.alignX       .copy();         if (this.alignY       ) copy.alignY        = this.alignY       .copy();         if (this.lineHeight   ) copy.lineHeight    = this.lineHeight   .copy();         if (this.letterSpacing) copy.letterSpacing = this.letterSpacing.copy();          return copy;     }        u4241(v2991)     {         switch (v2991)         {             case 'text':          return this.input ? this.value.text          : this.text;             case 'x':             return this.input ? this.value.x             : this.x;             case 'y':             return this.input ? this.value.y             : this.y;             case 'width':         return this.input ? this.value.width         : this.width;             case 'height':        return this.input ? this.value.height        : this.height;             case 'font':          return this.input ? this.value.font          : this.font;             case 'style':         return this.input ? this.value.style         : this.style;             case 'size':          return this.input ? this.value.size          : this.size;             case 'alignX':        return this.input ? this.value.alignX        : this.alignX;             case 'alignY':        return this.input ? this.value.alignY        : this.alignY;             case 'lineHeight':    return this.input ? this.value.lineHeight    : this.lineHeight;             case 'letterSpacing': return this.input ? this.value.letterSpacing : this.letterSpacing;         }          return super.u4241(v2991);     }        async eval(parse)     {         if (this.isCached())             return this;           const input         = await evalTextShapeValue(this.input,         parse);         let   text          = await evalNumberValue   (this.text,          parse);         let   x             = await evalNumberValue   (this.x,             parse);         let   y             = await evalNumberValue   (this.y,             parse);         let   width         = await evalNumberValue   (this.width,         parse);         let   height        = await evalNumberValue   (this.height,        parse);         let   font          = await evalNumberValue   (this.font,          parse);         let   style         = await evalNumberValue   (this.style,         parse);         let   size          = await evalNumberValue   (this.size,          parse);         let   alignX        = await evalNumberValue   (this.alignX,        parse);         let   alignY        = await evalNumberValue   (this.alignY,        parse);         let   lineHeight    = await evalNumberValue   (this.lineHeight,    parse);         let   letterSpacing = await evalNumberValue   (this.letterSpacing, parse);           if (text          && !text         .isValid()) text          = new b2032();         if (x             && !x            .isValid()) x             = z2021.NaN.copy();         if (y             && !y            .isValid()) y             = z2021.NaN.copy();         if (width         && !width        .isValid()) width         = z2021.NaN.copy();         if (height        && !height       .isValid()) height        = z2021.NaN.copy();         if (font          && !font         .isValid()) font          = z2021.NaN.copy();         if (style         && !style        .isValid()) style         = z2021.NaN.copy();         if (size          && !size         .isValid()) size          = z2021.NaN.copy();         if (alignX        && !alignX       .isValid()) alignX        = z2021.NaN.copy();         if (alignY        && !alignY       .isValid()) alignY        = z2021.NaN.copy();         if (lineHeight    && !lineHeight   .isValid()) lineHeight    = z2021.NaN.copy();         if (letterSpacing && !letterSpacing.isValid()) letterSpacing = z2021.NaN.copy();                    if (text          && text         .type !=   i1143) text          = new b2032();         if (x             && x            .type != m1091) x             = z2021.NaN.copy();         if (y             && y            .type != m1091) y             = z2021.NaN.copy();         if (width         && width        .type != m1091) width         = z2021.NaN.copy();         if (height        && height       .type != m1091) height        = z2021.NaN.copy();         if (font          && font         .type != m1091) font          = z2021.NaN.copy();         if (style         && style        .type != m1091) style         = z2021.NaN.copy();         if (size          && size         .type != m1091) size          = z2021.NaN.copy();         if (alignX        && alignX       .type != m1091) alignX        = z2021.NaN.copy();         if (alignY        && alignY       .type != m1091) alignY        = z2021.NaN.copy();         if (lineHeight    && lineHeight   .type != m1091) lineHeight    = z2021.NaN.copy();         if (letterSpacing && letterSpacing.type != m1091) letterSpacing = z2021.NaN.copy();                   if (input)         {             this.value        = input.q3632();             this.value.nodeId = this.nodeId;             this.value.v3625(input);                          if (text         )  this.value.text          = text;           else  text          = this.value.text;             if (x            )  this.value.x             = x;              else  x             = this.value.x;             if (y            )  this.value.y             = y;              else  y             = this.value.y;             if (width        )  this.value.width         = width;          else  width         = this.value.width;             if (height       )  this.value.height        = height;         else  height        = this.value.height;             if (font         )  this.value.font          = font;           else  font          = this.value.font;             if (style        )  this.value.style         = style;          else  style         = this.value.style;             if (size         )  this.value.size          = size;           else  size          = this.value.size;             if (alignX       )  this.value.alignX        = alignX;         else  alignX        = this.value.alignX;             if (alignY       )  this.value.alignY        = alignY;         else  alignY        = this.value.alignY;             if (lineHeight   )  this.value.lineHeight    = lineHeight;     else  lineHeight    = this.value.lineHeight;             if (letterSpacing)  this.value.letterSpacing = letterSpacing;  else  letterSpacing = this.value.letterSpacing;          }         else         {             this.value = new p2031(                 this.nodeId,                  text,                  x,                  y,                  width,                  height,                  font,                  style,                 size,                 alignX,                 alignY,                 lineHeight,                 letterSpacing);         }                  this.l4100(parse,          [             ['text',          text         ],             ['x',             x            ],             ['y',             y            ],             ['width',         width        ],             ['height',        height       ],             ['font',          font         ],             ['style',         style        ],             ['size',          size         ],             ['alignX',        alignX       ],             ['alignY',        alignY       ],             ['lineHeight',    lineHeight   ],             ['letterSpacing', letterSpacing]         ]);           await this.s2895(parse);           await this.t4099(parse);           if (!this.text         ) this.text          = this.value.text         .copy();         if (!this.x            ) this.x             = this.value.x            .copy();         if (!this.y            ) this.y             = this.value.y            .copy();         if (!this.width        ) this.width         = this.value.width        .copy();         if (!this.height       ) this.height        = this.value.height       .copy();         if (!this.font         ) this.font          = this.value.font         .copy();         if (!this.style        ) this.style         = this.value.style        .copy();         if (!this.size         ) this.size          = this.value.size         .copy();         if (!this.alignX       ) this.alignX        = this.value.alignX       .copy();         if (!this.alignY       ) this.alignY        = this.value.alignY       .copy();         if (!this.lineHeight   ) this.lineHeight    = this.value.lineHeight   .copy();         if (!this.letterSpacing) this.letterSpacing = this.value.letterSpacing.copy();                   this.validate();          return this;     }        async t4099(parse, options = {})     {         if (!this.options.enabled)             return;                   this.value.objects = [];           if (   super.w2896()                && this.value.text         .isValid()             && this.value.x            .isValid()             && this.value.y            .isValid()             && this.value.width        .isValid()             && this.value.height       .isValid()             && this.value.font         .isValid()             && this.value.style        .isValid()             && this.value.size         .isValid()             && this.value.alignX       .isValid()             && this.value.alignY       .isValid()             && this.value.lineHeight   .isValid()             && this.value.letterSpacing.isValid())         {             let x = this.value.x     .value;             let y = this.value.y     .value;             let w = this.value.width .value;             let h = this.value.height.value;              const fontName   = q4038[this.value.font.value];             const fontStyles = getFontStyles(fontName);              const text = new o1849(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 this.value.text.value,                 x, y, w, h,                 fontName,                 this.value.size         .value,                 fontStyles[Math.min(this.value.style.value, fontStyles.length-1)],                 this.value.alignX       .value,                 this.value.alignY       .value,                 this.value.lineHeight   .value,                 this.value.letterSpacing.value);                               text.s4097(x, y);                                                                                                                                                                                                text.l3729(x, y, w, h);                  this.value.objects.push(text);                      }                   await super.t4099(parse);     }        isValid()     {         return super.isValid()             && this.text          && this.text         .isValid()             && this.x             && this.x            .isValid()             && this.y             && this.y            .isValid()             && this.width         && this.width        .isValid()             && this.height        && this.height       .isValid()             && this.font          && this.font         .isValid()             && this.style         && this.style        .isValid()             && this.size          && this.size         .isValid()             && this.alignX        && this.alignX       .isValid()             && this.alignY        && this.alignY       .isValid()             && this.lineHeight    && this.lineHeight   .isValid()             && this.letterSpacing && this.letterSpacing.isValid();     }        g4087(parse)     {         super.g4087(parse);                  if (this.text         ) this.text         .g4087(parse);         if (this.x            ) this.x            .g4087(parse);         if (this.y            ) this.y            .g4087(parse);         if (this.width        ) this.width        .g4087(parse);         if (this.height       ) this.height       .g4087(parse);         if (this.font         ) this.font         .g4087(parse);         if (this.style        ) this.style        .g4087(parse);         if (this.size         ) this.size         .g4087(parse);         if (this.alignX       ) this.alignX       .g4087(parse);         if (this.alignY       ) this.alignY       .g4087(parse);         if (this.lineHeight   ) this.lineHeight   .g4087(parse);         if (this.letterSpacing) this.letterSpacing.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);                  if (this.text         ) this.text         .e4088(parse, from, force);         if (this.x            ) this.x            .e4088(parse, from, force);         if (this.y            ) this.y            .e4088(parse, from, force);         if (this.width        ) this.width        .e4088(parse, from, force);         if (this.height       ) this.height       .e4088(parse, from, force);         if (this.font         ) this.font         .e4088(parse, from, force);         if (this.style        ) this.style        .e4088(parse, from, force);         if (this.size         ) this.size         .e4088(parse, from, force);         if (this.alignX       ) this.alignX       .e4088(parse, from, force);         if (this.alignY       ) this.alignY       .e4088(parse, from, force);         if (this.lineHeight   ) this.lineHeight   .e4088(parse, from, force);         if (this.letterSpacing) this.letterSpacing.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);                  if (this.text         ) this.text         .q4086(parse);         if (this.x            ) this.x            .q4086(parse);         if (this.y            ) this.y            .q4086(parse);         if (this.width        ) this.width        .q4086(parse);         if (this.height       ) this.height       .q4086(parse);         if (this.font         ) this.font         .q4086(parse);         if (this.style        ) this.style        .q4086(parse);         if (this.size         ) this.size         .q4086(parse);         if (this.alignX       ) this.alignX       .q4086(parse);         if (this.alignY       ) this.alignY       .q4086(parse);         if (this.lineHeight   ) this.lineHeight   .q4086(parse);         if (this.letterSpacing) this.letterSpacing.q4086(parse);     } }


class u1963 extends u2043 {     x = null;     y = null;        constructor(nodeId, options)     {         super(q1246, nodeId, options);     }        reset()     {         super.reset();          this.x = null;         this.y = null;     }        copy()     {         const copy = new u1963(this.nodeId, this.options);          copy.o3358(this);          if (this.value) copy.value = this.value.copy();         if (this.x    ) copy.x     = this.x    .copy();         if (this.y    ) copy.y     = this.y    .copy();          return copy;     }        u4241(v2991)     {         switch (v2991)         {             case 'x': return this.input ? this.value.x : this.x;             case 'y': return this.input ? this.value.y : this.y;         }          return null;     }        async eval(parse)     {         if (this.isCached())             return this;                   let input = await evalPointValue (this.input, parse);         let x     = await evalNumberValue(this.x,     parse);         let y     = await evalNumberValue(this.y,     parse);           if (   input             && input.isValid())         {             const e3811 = input;              if (input.type == u1252)             {                 input = new t2022(input.nodeId, input.x, input.y);                 input.v3625(e3811);             }                          this.value        = input;             this.value.nodeId = this.nodeId;             this.value.v3625(input);               if (   this.value.objects                 && this.value.objects.length > 0)             {                 this.value.x = new z2021(this.value.objects[0].x);                 this.value.y = new z2021(this.value.objects[0].y);             }                          if (x)  this.value.x = x;  else  x = this.value.x;             if (y)  this.value.y = y;  else  y = this.value.y;         }         else if (x                && y)         {             this.value = new t2022(                 this.nodeId,                  x,                  y);         }         else             this.value = t2022.NaN.copy();           this.value.u3735 = this.u3735;           await this.t4099(parse);           this.l4100(parse,          [             ['x', x],             ['y', y]         ]);               this.validate();          return this;     }        async t4099(parse, options = {})     {         if (!this.options.enabled)             return;                                   if (!this.value.objects)             this.value.objects = [];           if (   this.value.x             && this.value.y                && this.value.x.isValid()             && this.value.y.isValid())         {             const x = this.value.x.value;             const y = this.value.y.value;              const point = new d1843(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 x,                 y,                 this.smooth ? this.smooth.value/100 : 1);              point.s4097(x, y);              this.value.objects = [point];         }           await super.t4099(parse);     }        isValid()     {         return super.isValid()             && this.x && this.x.isValid()             && this.y && this.y.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.x) this.x.g4087(parse);         if (this.y) this.y.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.x) this.x.e4088(parse, from, force);         if (this.y) this.y.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.x) this.x.q4086(parse);         if (this.y) this.y.q4086(parse);     } }


class p1964 extends u2043 {     smooth = null;        constructor(nodeId, options)     {         super(m1248, nodeId, options);     }        reset()     {         super.reset();          this.smooth = null;     }        copy()     {         const copy = new p1964(this.nodeId, this.options);          copy.o3358(this);          if (this.value ) copy.value  = this.value .copy();         if (this.smooth) copy.smooth = this.smooth.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                   const input  = await evalPointValue (this.input,  parse);         const smooth = await evalNumberValue(this.smooth, parse);                  if (input)         {             this.value        = input;             this.value.nodeId = this.nodeId;             this.value.v3625(input);              this.value.smooth = smooth;               if (   this.value.objects                 && this.value.objects.length > 0)             {                 this.value.x = new z2021(this.value.objects[0].x);                 this.value.y = new z2021(this.value.objects[0].y);             }         }         else             this.value = t2022.NaN.copy();           await this.t4099(parse);           this.l4100(parse,          [             ['smooth', smooth]         ]);           this.validate();          return this;     }        async t4099(parse, options = {})     {         if (!this.options.enabled)             return;                                   this.value.objects = [];           if (   this.value.x.isValid()             && this.value.y.isValid())         {             const x      = this.value.x.value;             const y      = this.value.y.value;             const smooth = this.value.smooth ? this.value.smooth.value/100 : 1;              const point = new d1843(                 this.nodeId,                  this.nodeId,                  this.nodeName,                  x,                  y,                  smooth);              point.s4097(x, y);              this.value.objects = [point];         }           await super.t4099(parse);     }        q3632()     {         return this.value.copy();                                                    }        isValid()     {         return super.isValid()             && this.smooth && this.smooth.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.smooth) this.smooth.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.smooth) this.smooth.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.smooth) this.smooth.q4086(parse);     } }


class f1983 extends c1973 {     points  = null;     closed  = null;     degree  = null;     winding = null;     round   = null;        constructor(nodeId, options)     {         super(b1250, nodeId, options);     }        reset()     {         super.reset();          this.points  = null;         this.closed  = null;         this.degree  = null;         this.winding = null;         this.round   = null;     }        copy()     {         const copy = new f1983(this.nodeId, this.options);          copy.o3358(this);          if (this.points ) copy.points  = this.points .copy();         if (this.closed ) copy.closed  = this.closed .copy();         if (this.degree ) copy.degree  = this.degree .copy();         if (this.winding) copy.winding = this.winding.copy();         if (this.round  ) copy.round   = this.round  .copy();          return copy;     }        u4241(v2991)     {         switch (v2991)         {             case 'points':  return this.input ? this.value.points  : this.points;             case 'closed':  return this.input ? this.value.closed  : this.closed;             case 'degree':  return this.input ? this.value.degree  : this.degree;             case 'winding': return this.input ? this.value.winding : this.winding;             case 'round':   return this.input ? this.value.round   : this.round;         }          return super.u4241(v2991);     }        async eval(parse)     {         if (this.isCached())             return this;           const input   = await evalVectorPathValue(this.input,   parse);         let   points  = await evalNumberValue    (this.points,  parse);         let   closed  = await evalNumberValue    (this.closed,  parse);         let   degree  = await evalNumberValue    (this.degree,  parse);         let   winding = await evalNumberValue    (this.winding, parse);         let   round   = await evalNumberValue    (this.round,   parse);           await this.evalBaseParams(parse);           if (input)         {                                                    if (   input.points                 && input.points.items                 && input.points.objects)             {                 c952(                      input.points.items.length == input.points.objects.length,                     'Vector path points input item count must match object count');                  for (let i = 0; i < input.points.items.length; i++)                 {                     const item = input.points.items  [i].copy();                     const g111  = input.points.objects[i].copy();                      if (item && g111)                     {                         item.x = new z2021(g111.x);                         item.y = new z2021(g111.y);                     }                 }             }               this.value = new y2036(                 this.nodeId,                    points                  && points.items.length > 0                  ? points                 : input.points,                 closed  ?? input.closed,                 degree  ?? input.degree,                 winding ?? input.winding,                 round   ?? input.round);              this.value.v3625(input);                           if (points )  this.value.points   = points;   else  points  = this.value.points;                 if (closed )  this.value.closed   = closed;   else  closed  = this.value.closed;                 if (degree )  this.value.degree   = degree;   else  degree  = this.value.degree;               if (winding)  this.value.windingt = winding;  else  winding = this.value.winding;              if (round  )  this.value.round    = round;    else  round   = this.value.round;           }         else         {             this.value = new y2036(                 this.nodeId,                  points,                  closed,                  degree,                  winding,                  round);         }                   this.l4100(parse,          [                        ['closed',  closed ],             ['degree',  degree ],             ['winding', winding],             ['round',   round  ]         ]);           await this.s2895(parse);           await this.t4099(parse);           this.validate();          return this;     }        async t4099(parse, options = {})     {         if (!this.options.enabled)             return;                       const points = [];          if (this.value.points.objects)         {             const h4101 = this.value.points.objects.filter(o => o.type == q1246);              for (const pt of h4101)             {                 const p = t2022.create(this.nodeId, pt.x, pt.y);                                  if (pt.smooth != null)                     p.smooth = new z2021(pt.smooth);                  points.push(p);             }         }           this.value.objects = [];           if (   super.w2896()                && points.length >= 2             && this.value.closed .isValid()             && this.value.degree .isValid()             && this.value.winding.isValid()             && this.value.round  .isValid())         {             const path = new h1852(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 points,                 this.value.closed .value,                 this.value.degree .value,                 this.value.winding.value,                 this.value.round  .value);                               const bounds = getObjBounds([path]);              path.f3741(                 bounds.x + bounds.width /2,                             bounds.y + bounds.height/2                         );               let x = bounds.x;             let y = bounds.y;             let w = bounds.w;             let h = bounds.h;                          path.s4097(x, y);             path.l3729(x, y, w, h);               this.value.objects.push(path);         }           await super.t4099(parse);     }        isValid()     {         return super.isValid()             && this.points  && this.points .isValid()             && this.closed  && this.closed .isValid()             && this.degree  && this.degree .isValid()             && this.winding && this.winding.isValid()             && this.round   && this.round  .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.points ) this.points .g4087(parse);         if (this.closed ) this.closed .g4087(parse);         if (this.degree ) this.degree .g4087(parse);         if (this.winding) this.winding.g4087(parse);         if (this.round  ) this.round  .g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.points ) this.points .e4088(parse, from, force);         if (this.closed ) this.closed .e4088(parse, from, force);         if (this.degree ) this.degree .e4088(parse, from, force);         if (this.winding) this.winding.e4088(parse, from, force);         if (this.round  ) this.round  .e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.points ) this.points .q4086(parse);         if (this.closed ) this.closed .q4086(parse);         if (this.degree ) this.degree .q4086(parse);         if (this.winding) this.winding.q4086(parse);         if (this.round  ) this.round  .q4086(parse);     } }


class d1985 extends u2043 {     x     = null;     y     = null;     join  = null;     cap   = null;     round = null;        constructor(nodeId, options)     {         super(o1253, nodeId, options);     }        reset()     {         super.reset();          this.x     = null;         this.y     = null;         this.join  = null;         this.cap   = null;         this.round = null;     }        copy()     {         const copy = new d1985(this.nodeId, this.options);          copy.o3358(this);          if (this.x    ) copy.x     = this.x    .copy();         if (this.y    ) copy.y     = this.y    .copy();         if (this.join ) copy.join  = this.join .copy();         if (this.cap  ) copy.cap   = this.cap  .copy();         if (this.round) copy.round = this.round.copy();          return copy;     }        u4241(v2991)     {         switch (v2991)         {             case 'x':     return this.input ? this.value.x     : this.x;             case 'y':     return this.input ? this.value.y     : this.y;             case 'join':  return this.input ? this.value.join  : this.join;             case 'cap':   return this.input ? this.value.cap   : this.cap;             case 'round': return this.input ? this.value.round : this.round;         }          return null;     }        async eval(parse)     {         if (this.isCached())             return this;                   let input = await evalVectorVertexValue(this.input, parse);         let x     = await evalNumberValue      (this.x,     parse);         let y     = await evalNumberValue      (this.y,     parse);         let join  = await evalNumberValue      (this.join,  parse);         let cap   = await evalNumberValue      (this.cap,   parse);         let round = await evalNumberValue      (this.round, parse);           if (input)         {             const e3811 = input;              if (input.type == v1245)             {                 input = new z2038(input.nodeId, input.x, input.y);                 input.v3625(e3811);             }                          this.value        = input.copy();             this.value.nodeId = this.nodeId;             this.value.v3625(input);                                                                                                                          this.value.x     = new z2021(this.value.objects[0].x    );             this.value.y     = new z2021(this.value.objects[0].y    );             this.value.join  = new z2021(this.value.objects[0].join );             this.value.cap   = new z2021(this.value.objects[0].cap  );             this.value.round = new z2021(this.value.objects[0].round);              if (x    )  this.value.x     = x;      else  x     = this.value.x;             if (y    )  this.value.y     = y;      else  y     = this.value.y;             if (join )  this.value.join  = join;   else  join  = this.value.join;             if (cap  )  this.value.cap   = cap;    else  cap   = this.value.cap;             if (round)  this.value.round = round;  else  round = this.value.round;         }         else         {             this.value = new z2038(                 this.nodeId,                  x,                  y,                  join,                  cap,                  round);         }                  this.value.u3735 = this.u3735;           await this.t4099(parse);           this.l4100(parse,          [             ['value', this.value]         ]);           this.validate();          return this;     }        async t4099(parse, options = {})     {         if (!this.options.enabled)             return;                                   this.value.objects = [];           if (   this.value.x                 && this.value.y                 && this.value.join              && this.value.cap               && this.value.round)         {             const x     = this.value.x    .value;             const y     = this.value.y    .value;                                                     const point = new d1843(this.nodeId, this.nodeId, this.nodeName, x, y);              point.s4097(x, y);              this.value.objects = [point];         }           await super.t4099(parse);     }        q3632()     {         const point = new z2038(             this.nodeId,             this.x    .q3632(),             this.y    .q3632(),             this.join .q3632(),             this.cap  .q3632(),             this.round.q3632());          point.v3625(this.value);          point.objects  = this.value.objects.map(o => o.copy());         point.u3735 = this.value.u3735;          return point;     }        isValid()     {         return super.isValid()             && this.x    .isValid()             && this.y    .isValid()             && this.join .isValid()             && this.cap  .isValid()             && this.round.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.x    ) this.x    .g4087(parse);         if (this.y    ) this.y    .g4087(parse);         if (this.join ) this.join .g4087(parse);         if (this.cap  ) this.cap  .g4087(parse);         if (this.round) this.round.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.x    ) this.x    .e4088(parse, from, force);         if (this.y    ) this.y    .e4088(parse, from, force);         if (this.join ) this.join .e4088(parse, from, force);         if (this.cap  ) this.cap  .e4088(parse, from, force);         if (this.round) this.round.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.x    ) this.x    .q4086(parse);         if (this.y    ) this.y    .q4086(parse);         if (this.join ) this.join .q4086(parse);         if (this.cap  ) this.cap  .q4086(parse);         if (this.round) this.round.q4086(parse);     } }


class h1980 extends z2044 {     l3664 = null;     f3665   = null;                    constructor(nodeId, options)     {         super(p1256, nodeId, options);     }        reset()     {         super.reset();                  this.l3664 = null;         this.f3665   = null;     }        copy()     {         const copy = new h1980(this.nodeId, this.options);          copy.o3358(this);          if (this.l3664) copy.l3664 = this.l3664.copy();         if (this.f3665  ) copy.f3665   = this.f3665  .copy();          return copy;     }        u4241(v2991)     {         switch (v2991)         {             case 'startTangent': return this.input ? this.value.l3664 : this.l3664;             case 'endTangent':   return this.input ? this.value.f3665   : this.f3665;         }          return null;     }        async eval(parse)     {         if (this.isCached())             return this;                   let z4082       = await evalVectorVertexValue(this.z4082,       parse);         let z4083       = await evalVectorVertexValue(this.z4083,       parse);         let l3664 = await evalNumberValue      (this.l3664, parse);         let   f3665 = await evalNumberValue      (this.  f3665, parse);          if (   z4082             && z4083             && l3664             && f3665)         {             if (z4082.type == v1245) z4082 = new z2038(z4082.nodeId, z4082.x, z4082.y);             if (z4083.type == v1245) z4083 = new z2038(z4083.nodeId, z4083.x, z4083.y);              if (l3664.type == u1252) l3664 = new t2022(l3664.nodeId, l3664.x, l3664.y);             if (  f3665.type == u1252)   f3665 = new t2022(  f3665.nodeId,   f3665.x,   f3665.y);               this.value = new t2034(                 this.nodeId,                 z4082,                 z4083,                 l3664,                 f3665);               this.value.u3735 = this.u3735;         }         else             this.value = t2034.NaN.copy();                           await this.t4099(parse);           this.l4100(parse,          [             ['value', this.value]         ]);           this.validate();          return this;     }        async t4099(parse, options = {})     {         if (   !this.options.enabled             || !this.value.start.isValid()             || !this.value.end  .isValid())             return;                                   this.value.objects = [];           if (   this.value.start.isValid()             && this.value.end  .isValid())         {             const path = new h1852(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 [ this.value.start,                   this.value.l3664.isValid() ? this.value.l3664 : this.value.start,                   this.value.f3665  .isValid() ? this.value.  f3665 : this.value.end,                   this.value.end ],                 0,                 2,                  0,                 0);                           const bounds = getObjBounds([path]);              let x = bounds.x;             let y = bounds.y;             let w = bounds.w;             let h = bounds.h;               path.s4097(x, y);             path.l3729(x, y, w, h);              this.value.objects.push(path);         }           await super.t4099(parse);     }                                                                               isValid()     {         return super.isValid()             && this.l3664.isValid()             && this.f3665  .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.l3664) this.l3664.g4087(parse);         if (this.f3665  ) this.f3665  .g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.l3664) this.l3664.e4088(parse, from, force);         if (this.f3665  ) this.f3665  .e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.l3664) this.l3664.q4086(parse);         if (this.f3665  ) this.f3665  .q4086(parse);     } }


class s1984 extends c1973 {     inputs  = [];      loops   = null;     winding = null;        constructor(nodeId, options)     {         super(s1259, nodeId, options);     }        reset()     {         super.reset();          this.inputs  = [];          this.loops   = null;         this.winding = null;     }        copy()     {         const copy = new s1984(this.nodeId, this.options);          copy.o3358(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.winding) copy.winding = this.winding.copy();          return copy;     }        u4241(v2991)     {         switch (v2991)         {             case 'loops':   return this.input ? this.value.loops   : this.loops;             case 'winding': return this.input ? this.value.winding : this.winding;         }          return super.u4241(v2991);     }        isCached()     {         for (const input of this.inputs)             if (!input.isCached())                 return false;          return super.isCached()             && this.winding.isCached();     }        async eval(parse)     {         if (this.isCached())             return this;                   const winding = await evalNumberValue(this.winding, parse);           this.loops = new u2020();           const loop = new u2020();          for (let i = 0; i < this.inputs.length; i++)         {             const input = await evalVectorEdgeValue(this.inputs[i], parse);              if (o957(input.type))             {                 const _loop = new u2020();                  for (let j = 0; j < input.items.length; j++)                 {                     const item = input.items[j];                      if (item.type == i1255)                     {                         const edge = item.copy();                          if (_loop.items.length > 0)                         {                             const prevEdge = _loop.items.at(-1);                              if (   edge.end.x.equals(prevEdge.end.x)                                 && edge.end.y.equals(prevEdge.end.y))                             {                                 [edge.start,        edge.end       ] = [edge.end,        edge.start       ];                                 [edge.l3664, edge.f3665] = [edge.f3665, edge.l3664];                             }                         }                          _loop.items.push(edge);                     }                 }                  if (!isEmpty(_loop.items))                     loops.items.push(_loop);             }             else             {                 c952(                      input.type == i1255,                      'input.type must be VECTOR_EDGE_VALUE');                  const edge = input.copy();                  if (loop.items.length > 0)                 {                     const prevEdge = loop.items.at(-1);                      if (   edge.end.x.equals(prevEdge.end.x)                         && edge.end.y.equals(prevEdge.end.y))                     {                         [edge.start,        edge.end       ] = [edge.end,        edge.start       ];                         [edge.l3664, edge.f3665] = [edge.f3665, edge.l3664];                     }                 }                  loop.items.push(edge);             }         }           if (!isEmpty(loop.items))             this.loops.items.push(loop);           this.value = new v2037(             this.nodeId,             this.loops,              winding);           this.value.u3735 = this.u3735;           this.l4100(parse,         [             ['value',   this.value],             ['winding', winding   ]         ]);           await this.s2895(parse);           await this.t4099(parse);           this.validate();          return this;     }        async t4099(parse, options = {})     {         if (   !this.options.enabled             || !this.value.isValid())             return;                                   this.value.objects = [];                   if (   this.loops  .isValid()             && this.winding.isValid())         {             const regions = [];               for (let i = 0; i < this.loops.items.length; i++)             {                 const loop = this.loops.items[i];                   const points = [];                      for (let j = 0; j < loop.items.length; j++)                 {                     const edge = loop.items[j];                     const next = loop.items[j == loop.items.length-1 ? 0 : j+1];                      points.push(                            edge.start.u3735 == next.start.u3735                         || edge.start.u3735 == next.end  .u3735                         ? edge.end                           : edge.start);                 }                   regions.push(new h1852(                     this.nodeId,                     this.nodeId + '/' + i,                     this.nodeName,                     points,                     1,                     0,                      this.winding.value,                     0));             }                           let bounds = getObjBounds(regions);              let x = bounds.x;             let y = bounds.y;             let w = bounds.w;             let h = bounds.h;               for (const region of regions)             {                 region.s4097(x, y);                 region.l3729(x, y, w, h);                  this.value.objects.push(region);             }         }           await super.t4099(parse);     }                                                                          isValid()     {         if (!super.isValid())             return false;                      for (const input of this.inputs)             if (!input.isCached())                 return false;                  return this.winding.isValid()             && this.props  .isValid();     }        g4087(parse)     {         super.g4087(parse);          this.inputs.forEach(i => i.g4087(parse));          if (this.winding) this.winding.g4087(parse);         if (this.props  ) this.props  .g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          this.inputs.forEach(i => i.e4088(parse, from, force));          if (this.winding) this.winding.e4088(parse, from, force);         if (this.props  ) this.props  .e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          this.inputs.forEach(i => i.q4086(parse));          if (this.winding) this.winding.q4086(parse);         if (this.props  ) this.props  .q4086(parse);     } }


class j1982 extends c1973 {     inputs = [];        constructor(nodeId, options)     {         super(h1262, nodeId, options);     }        reset()     {         super.reset();          this.inputs = [];     }        copy()     {         const copy = new j1982(this.nodeId, this.options);          copy.o3358(this);          copy.inputs = this.inputs.map(i => i.copy());          return copy;     }        isCached()     {         for (const input of this.inputs)             if (!input.isCached())                 return false;          return super.isCached();     }        async eval(parse)     {         if (this.isCached())             return this;                   const regions = new u2020();          for (let i = 0; i < this.inputs.length; i++)         {             const input = await evalVectorRegionValue(this.inputs[i], parse);              c952(                  input.type == o1258,                  'input.type must be VECTOR_REGION_VALUE');              regions.items.push(input);         }           this.value = new q2035(             this.nodeId,             regions);           this.l4100(parse,          [             ['value', this.value]         ]);           await this.s2895(parse);                   await this.t4099(parse);           this.validate();          return this;     }        async t4099(parse, options = {})     {         if (   !this.options.enabled             || !this.value.isValid())             return;                                   this.value.objects = [];           if (!isEmpty(this.value.regions.items))         {             let points  = [];             let edges   = [];             let regions = [];               for (const region of this.value.regions.items)             {                 if (!isEmpty(region.objects))                     region.fills = region.objects[0].fills;                   if (region.loops)                 {                     for (const loop of region.loops.items)                     {                         for (const edge of loop.items)                         {                             w950(points, edge.start, p => p.u3735 == edge.start.u3735);                             w950(points, edge.end,   p => p.u3735 == edge.end  .u3735);                              w950(edges, edge, e => e.u3735 == edge.u3735);                         }                     }                      w950(regions, region, r => r.u3735 == region.u3735);                 }             }                           const network = new y1851(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 points,                 edges,                 regions);                           const bounds = getObjBounds([network]);              let x = bounds.x;             let y = bounds.y;             let w = bounds.w;             let h = bounds.h;               network.s4097(x, y);             network.l3729(x, y, w, h);              this.value.objects.push(network);         }           await super.t4099(parse);     }                                                                isValid()     {         return super.isValid()             && this.regions.isValid();     }        g4087(parse)     {         super.g4087(parse);          this.inputs.forEach(i => i.g4087(parse));     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          this.inputs.forEach(i => i.g4087(parse));     }        q4086(parse)     {         super.q4086(parse);          this.inputs.forEach(i => i.q4086(parse));     } }


class GArcPath extends c1973 {     position = null;     start    = null;     sweep    = null;      sweepInDegrees;        constructor(nodeId, options)     {         super(j1230, nodeId, options);     }        reset()     {         super.reset();          this.position = null;         this.start    = null;         this.sweep    = null;     }        copy()     {         const copy = new GArcPath(this.nodeId, this.options);          copy.o3358(this);          if (this.position) copy.position = this.position.copy();         if (this.start   ) copy.start    = this.start   .copy();         if (this.sweep   ) copy.sweep    = this.sweep   .copy();                  return copy;     }        u4241(v2991)     {         switch (v2991)         {             case 'position': return this.input ? this.value.position : this.position;             case 'x':        return this.input ? this.value.x        : this.x;             case 'y':        return this.input ? this.value.y        : this.y;             case 'width':    return this.input ? this.value.width    : this.width;             case 'height':   return this.input ? this.value.height   : this.height;             case 'start':    return this.input ? this.value.start    : this.start;             case 'sweep':    return this.input ? this.value.sweep    : this.sweep;         }          return super.u4241(v2991);     }        async eval(parse)     {         if (this.isCached())             return this;           let [x, y, width, height] = await this.evalBaseParams(parse);          let input = await evalArcPathValue(this.input,    parse);         let pos   = await evalNumberValue (this.position, parse);         let start = await evalNumberValue (this.start,    parse);         let sweep = await evalNumberValue (this.sweep,    parse);           if (input)         {             this.value        = input.copy();             this.value.nodeId = this.nodeId;             this.value.v3625(input);              if (pos   )  this.value.position = pos;     else  pos    = this.value.position;             if (x     )  this.value.x        = x;       else  x      = this.value.x;                   if (y     )  this.value.y        = y;       else  y      = this.value.y;                   if (width )  this.value.width    = width;   else  width  = this.value.width;               if (height)  this.value.height   = height;  else  height = this.value.height;              if (start )  this.value.start    = start;   else  start  = this.value.start;             if (sweep )  this.value.sweep    = sweep;   else  sweep  = this.value.sweep;         }         else         {             this.value = new ArcPathValue(                 this.nodeId,                 pos,                 x,                  y,                  width,                  height,                 start,                 sweep);         }           this.l4100(parse,          [             ['position', pos   ],             ['x',        x     ],             ['y',        y     ],             ['width',    width ],             ['height',   height],             ['start',    start ],             ['sweep',    sweep ]         ]);           await this.s2895(parse);           await this.t4099(parse);           this.validate();          return this;     }        async t4099(parse, options = {})     {        if (!this.options.enabled)            return;                                 this.value.objects = [];           if (   super.w2896()             && this.value.x     .isValid()             && this.value.y     .isValid()             && this.value.width .isValid()             && this.value.height.isValid())          {             const vpos = this.value.position;             const vx   = this.value.x;             const vy   = this.value.y;             const vw   = this.value.width;             const vh   = this.value.height;              const _x   = vpos.value <= 0 ? vx : new z2021(vx.value - vw.value, Math.max(vx.decimals, vw.decimals));             const _y   = vpos.value <= 0 ? vy : new z2021(vy.value - vh.value, Math.max(vy.decimals, vh.decimals));             const _w   = vpos.value <= 0 ? vw : new z2021(vw.value*2, Math.max(vx.decimals, vw.decimals));             const _h   = vpos.value <= 0 ? vh : new z2021(vh.value*2, Math.max(vy.decimals, vh.decimals));                          let   x    = _x.value;             let   y    = _y.value;             let   w    = _w.value;             let   h    = _h.value;             const st   = this.value.start.value/360 * Tau;             let   sw   = this.value.sweep.value/100 * Tau;               [x, , w, , , ] = validateObjectRect(x, y, w, h);                                                          if (this.sweepInDegrees) sw /= 3.6;                  const arc = new FigmaArcPath(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     vpos.value,                     x, y, w, h, st, sw);                   const bounds = getObjBounds([arc]);                          arc.f3741(x + w/2, y + h/2);                 arc.s4097(bounds.x, bounds.y);                 arc.l3729(bounds.x, bounds.y, bounds.w, bounds.h);                   this.value.objects.push(arc);                      }           await super.t4099(parse);     }                       isValid()     {         return super.isValid()             && this.position && this.position.isValid()             && this.start    && this.start   .isValid()             && this.sweep    && this.sweep   .isValid();     }        g4087(parse)     {         super.g4087(parse);           if (this.position) this.position.g4087(parse);         if (this.start   ) this.start   .g4087(parse);         if (this.sweep   ) this.sweep   .g4087(parse);     }                   e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.position) this.position.e4088(parse, from, force);         if (this.start   ) this.start   .e4088(parse, from, force);         if (this.sweep   ) this.sweep   .e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);           if (this.position) this.position.q4086(parse);         if (this.start   ) this.start   .q4086(parse);         if (this.sweep   ) this.sweep   .q4086(parse);     } }


class GWavePath extends c1973 {     shape     = null;     amplitude = null;     frequency = null;     offset    = null;     alignX    = null;     alignY    = null;      useWavelength;     offsetAbsolute;        constructor(nodeId, options)     {         super(o1233, nodeId, options);     }        reset()     {         super.reset();          this.shape     = null;         this.amplitude = null;         this.frequency = null;         this.offset    = null;         this.alignX    = null;         this.alignY    = null;     }        copy()     {         const copy = new GWavePath(this.nodeId, this.options);          copy.o3358(this);          if (this.shape    ) copy.shape     = this.shape    .copy();         if (this.amplitude) copy.amplitude = this.amplitude.copy();         if (this.frequency) copy.frequency = this.frequency.copy();         if (this.offset   ) copy.offset    = this.offset   .copy();         if (this.alignX   ) copy.alignX    = this.alignX   .copy();         if (this.alignY   ) copy.alignY    = this.alignY   .copy();                  return copy;     }        u4241(v2991)     {         switch (v2991)         {             case 'shape':     return this.input ? this.value.shape     : this.shape;             case 'x':         return this.input ? this.value.x         : this.x;             case 'y':         return this.input ? this.value.y         : this.y;             case 'width':     return this.input ? this.value.width     : this.width;             case 'amplitude': return this.input ? this.value.amplitude : this.amplitude;             case 'frequency': return this.input ? this.value.frequency : this.frequency;             case 'offset':    return this.input ? this.value.offset    : this.offset;             case 'alignX':    return this.input ? this.value.alignX    : this.alignX;             case 'alignY':    return this.input ? this.value.alignY    : this.alignY;         }          return super.u4241(v2991);     }        async eval(parse)     {         if (this.isCached())             return this;           let [x, y, width, ] = await this.evalBaseParams(parse);           let input     = await evalWavePathValue(this.input,     parse);         let shape     = await evalNumberValue  (this.shape,     parse);         let amplitude = await evalNumberValue  (this.amplitude, parse);         let frequency = await evalNumberValue  (this.frequency, parse);         let offset    = await evalNumberValue  (this.offset,    parse);         let alignX    = await evalNumberValue  (this.alignX,    parse);         let alignY    = await evalNumberValue  (this.alignY,    parse);           if (input)         {             this.value        = input.copy();             this.value.nodeId = this.nodeId;             this.value.v3625(input);              if (shape    )  this.value.shape     = shape;      else  shape      = this.value.shape;             if (x        )  this.value.x         = x;          else  x          = this.value.x;                   if (y        )  this.value.y         = y;          else  y          = this.value.y;                   if (width    )  this.value.width     = width;      else  width      = this.value.width;               if (amplitude)  this.value.amplitude = amplitude;  else  amplitude  = this.value.amplitude;             if (frequency)  this.value.frequency = frequency;  else  frequency  = this.value.frequency;             if (offset   )  this.value.offset    = offset;     else  offset     = this.value.offset;             if (alignX   )  this.value.alignX    = alignX;     else  alignX     = this.value.alignX;             if (alignY   )  this.value.alignY    = alignY;     else  alignY     = this.value.alignY;         }         else         {             this.value = new WavePathValue(                 this.nodeId,                 shape,                 x,                  y,                  width,                  amplitude,                 frequency,                 offset,                 alignX,                 alignY);         }           this.l4100(parse,          [             ['shape',     shape    ],             ['x',         x        ],             ['y',         y        ],             ['width',     width    ],             ['amplitude', amplitude],             ['frequency', frequency],             ['offset',    offset   ],             ['alignX',    alignX   ],             ['alignY',    alignY   ]         ]);           await this.s2895(parse);           await this.t4099(parse);           this.validate();          return this;     }        async t4099(parse, options = {})     {        if (!this.options.enabled)            return;                                 this.value.objects = [];           if (   super.w2896()             && this.value.shape    .isValid()             && this.value.x        .isValid()             && this.value.y        .isValid()             && this.value.width    .isValid()             && this.value.amplitude.isValid()             && this.value.frequency.isValid()             && this.value.offset   .isValid()             && this.value.alignX   .isValid()             && this.value.alignY   .isValid())         {             const sh     = this.value.shape    .value;             let   x      = this.value.x        .value;             let   y      = this.value.y        .value;             let   w      = this.value.width    .value;             const amp    = this.value.amplitude.value;             let   freq   = this.value.frequency.value;             const off    = this.value.offset   .value;             const alignX = this.value.alignX   .value;             const alignY = this.value.alignY   .value;               [x, y, w, , ] = validateObjectRect(x, y, w, 0);               const _freq = this.useWavelength ? w/nozero(freq) : freq;             const wl    = this.useWavelength ? freq : w/nozero(freq);              const so    = this.shape.value >= 3 ? 0.25 : 0;              const _off =                 this.offsetAbsolute                 ? off - so*wl                 : (off/100 - so) * wl;                                                          const wave = new FigmaWavePath(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     sh,                      x, y, w,                     amp,                     _freq,                     _off,                     alignX,                     alignY);                   const bounds = getObjBounds([wave]);                  wave.f3741(                     bounds.x + bounds.width /2,                                 bounds.y + bounds.height/2                             );                  wave.s4097(bounds.x, bounds.y);                 wave.l3729(bounds.x, bounds.y, bounds.w, bounds.h);                   this.value.objects.push(wave);                      }           await super.t4099(parse);     }                       isValid()     {         return super.isValid()             && this.shape     && this.shape    .isValid()             && this.amplitude && this.amplitude.isValid()             && this.frequency && this.frequency.isValid()             && this.offset    && this.offset   .isValid()             && this.alignX    && this.alignX   .isValid()             && this.alignY    && this.alignY   .isValid();     }        g4087(parse)     {         super.g4087(parse);           if (this.shape    ) this.shape    .g4087(parse);         if (this.amplitude) this.amplitude.g4087(parse);         if (this.frequency) this.frequency.g4087(parse);         if (this.offset   ) this.offset   .g4087(parse);         if (this.alignX   ) this.alignX   .g4087(parse);         if (this.alignY   ) this.alignY   .g4087(parse);     }                   e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.shape    ) this.shape    .e4088(parse, from, force);         if (this.amplitude) this.amplitude.e4088(parse, from, force);         if (this.frequency) this.frequency.e4088(parse, from, force);         if (this.offset   ) this.offset   .e4088(parse, from, force);         if (this.alignX   ) this.alignX   .e4088(parse, from, force);         if (this.alignY   ) this.alignY   .e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);           if (this.shape    ) this.shape    .q4086(parse);         if (this.amplitude) this.amplitude.q4086(parse);         if (this.frequency) this.frequency.q4086(parse);         if (this.offset   ) this.offset   .q4086(parse);         if (this.alignX   ) this.alignX   .q4086(parse);         if (this.alignY   ) this.alignY   .q4086(parse);     } }


class c1975 extends p1974 {     inputs = [];        constructor(nodeId, options)     {         super(g1265, nodeId, options);     }        reset()     {         super.reset();          this.inputs = [];     }        copy()     {         const copy = new c1975(this.nodeId, this.options);          copy.o3358(this);          copy.inputs = this.inputs.map(i => i.copy());          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new f2027(this.nodeId);          this.value.objects = [];                  const inputs = [];                  if (this.options.enabled)         {             for (let i = 0; i < this.inputs.length; i++)             {                 const input = await evalValue(this.inputs[i], parse);                  if (input)                             {                     inputs.push(input);                      if (   input.type == a1059                         || input.type == z1056)                     {                         for (const item of input.items)                         {                             if (!f1294.includes(item.type))                                 continue;                              this.value.items.push(item);                                                      }                     }                     else                     {                         this.value.items.push(input);                                              }                 }             }         }           this.l4100(parse,          [             ['value', this.value]         ]);                      await this.t4099(parse, {inputs: inputs});           this.validate();          return this;     }        async t4099(parse, options = {})     {         if (!this.options.enabled)             return;                       if (this.value.items)         {             const group = new v1847(                 this.nodeId,                 this.nodeId,                 this.nodeName);               for (let i = 0; i < options.inputs.length; i++)             {                 const input = options.inputs[i];                  if (input.objects)                 {                     for (let j = 0; j < input.objects.length; j++)                         this.r3736(group.children, input.objects[j], i, j);                 }             }                                 const bounds = getObjBounds(group.children);              const singlePoint =                    group.children.length  == 1                  && group.children[0].type == q1246;              for (const g111 of group.children)             {                                                        g111.f3741(g111.sp0.x, g111.sp0.y);                                                                     g111.resetSpace(bounds, singlePoint);             }               group.x      = bounds.x;             group.y      = bounds.y;             group.width  = bounds.width;             group.height = bounds.height;                           group.f3741();             group.resetSpace(bounds);              group.s4097(bounds.x, bounds.y);             group.l3729(bounds.x, bounds.y, bounds.width, bounds.height);               this.value.objects = [group];         }         else         {             this.value.objects = [];         }           await super.t4099(parse);     }        r3736(objects, _obj, inputIndex, objIndex)     {         const g111 = w3737(_obj);          g111.nodeId    = this.nodeId;         g111.objectId += c967 + inputIndex;         g111.listId    = -1;          objects.push(g111);     }        q3632()     {         return this.value.copy();     }        isValid()     {         if (!super.isValid())              return false;          for (const input of this.inputs)             if (!input.isValid())                 return false;          return true;     }        g4087(parse)     {         super.g4087(parse);          this.inputs.forEach(i => i.g4087(parse));     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          this.inputs.forEach(i => i.e4088(parse, from, force));     }        q4086(parse)     {         super.q4086(parse);          this.inputs.forEach(i => i.q4086(parse));     } }


class c1956 extends c1973 {     children = null;     position = null;     round    = null;     clip     = null;        constructor(nodeId, options)     {         super(t1268, nodeId, options);     }        reset()     {         super.reset();          this.children = null;         this.position = null;         this.round    = null;         this.clip     = null;     }        copy()     {         const copy = new c1956(this.nodeId, this.options);          copy.o3358(this);          if (this.children) copy.children = this.children.copy();         if (this.position) copy.position = this.position.copy();         if (this.round   ) copy.round    = this.round   .copy();         if (this.clip    ) copy.clip     = this.clip    .copy();          return copy;     }        u4241(v2991)     {         switch (v2991)         {             case 'children': return this.input ? this.value.children : this.children;             case 'position': return this.input ? this.value.position : this.position;             case 'x':        return this.input ? this.value.x        : this.x;             case 'y':        return this.input ? this.value.y        : this.y;             case 'width':    return this.input ? this.value.width    : this.width;             case 'height':   return this.input ? this.value.height   : this.height;             case 'round':    return this.input ? this.value.round    : this.round;             case 'clip':     return this.input ? this.value.clip     : this.clip;         }          return super.u4241(v2991);     }        async eval(parse)     {         if (this.isCached())             return this;           const [x, y, width, height] = await this.evalBaseParams(parse);          let children = await evalListValue  (this.children, parse);         let position = await evalNumberValue(this.position, parse);         let round    = await evalNumberValue(this.round,    parse);         let clip     = await evalNumberValue(this.clip,     parse);           if (   children             && f1294.includes(children.type)             && children.type != a1059)         {             const objects    = children.objects;             children         = new u2020([children]);             children.objects = objects;         }           let input = null;          if (this.input)         {             input = await evalFrameValue(this.input, parse);              this.value = new j2013(                 this.nodeId,                 children ?? input.children,                 position ?? input.position,                 x        ?? input.x,                 y        ?? input.y,                 width    ?? input.width,                 height   ?? input.height,                 round    ?? input.round,                 clip     ?? input.clip);         }         else         {             this.value = new j2013(                 this.nodeId,                  children,                 position,                 x,                  y,                  width,                 height,                  round,                 clip);         }           const childType = new b2032(s3478(children.items));          this.l4100(parse,          [             ['childType', childType],             ['position',  position ],             ['x',         x        ],             ['y',         y        ],             ['width',     width    ],             ['height',    height   ],             ['round',     round    ],             ['clip',      clip     ]         ]);           await this.s2895(parse);           await this.t4099(parse);           if (!this.children) this.children = this.value.children.copy();         if (!this.position) this.position = this.value.position.copy();         if (!this.x       ) this.x        = this.value.x       .copy();         if (!this.y       ) this.y        = this.value.y       .copy();         if (!this.width   ) this.width    = this.value.width   .copy();         if (!this.height  ) this.height   = this.value.height  .copy();         if (!this.round   ) this.round    = this.value.round   .copy();         if (!this.clip    ) this.clip     = this.value.clip    .copy();           this.validate();          return this;     }        async t4099(parse, options = {})     {         if (!this.options.enabled)             return;                       if (   this.value.position             && this.value.x             && this.value.y             && this.value.width             && this.value.height             && this.value.round             && this.value.clip)         {             let   pos = this.value.position.value;             let   x   = this.value.x       .value;             let   y   = this.value.y       .value;             let   w   = this.value.width   .value;             let   h   = this.value.height  .value;             const r   = Math.max(0, this.value.round.value);             const c   = this.value.clip    .value;               const frame = new l1840(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 x, y, w, h, r, c);               const bounds = getObjBounds(this.value.objects);              const singlePoint =                    this.value.objects.length  == 1                  && this.value.objects[0].type == q1246;                               const xoff = b893(-x, -y);              for (let i = 0; i < this.value.objects.length; i++)             {                 const g111 = this.value.objects[i];                                                     g111.f3741();                                                                     g111.resetSpace(bounds, singlePoint);                  if (pos > 0)                     g111.r4098(xoff, 2);                  this.r3736(frame.children, g111);             }               frame.s4097(x, y);             frame.l3729(x, y, w, h);                      this.value.objects = [frame];                           this.l4100(parse,              [                 ['nChildren', new z2021(frame.children.length)]             ],              true);         }           await super.t4099(parse);     }        r3736(objects, _obj)     {         const g111 = w3737(_obj);                              g111.nodeId   = this.nodeId;         g111.objectId = g111.objectId + c967 + this.nodeId;         g111.listId   = -1;                  objects.push(g111);     }        q3632()     {         return this.value.copy();     }        isValid()     {         return super.isValid()             && this.children && this.children.isValid()             && this.position && this.position.isValid()             && this.round    && this.round   .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.children) this.children.g4087(parse);         if (this.position) this.position.g4087(parse);         if (this.round   ) this.round   .g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.children) this.children.e4088(parse, from, force);         if (this.position) this.position.e4088(parse, from, force);         if (this.round   ) this.round   .e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.children) this.children.q4086(parse);         if (this.position) this.position.q4086(parse);         if (this.round   ) this.round   .q4086(parse);     } }


class r1952 extends u2043 {     props   = null;     replace = null;        constructor(nodeId, options)     {         super(x1277, nodeId, options);     }        reset()     {         super.reset();          this.props   = null;         this.replace = null;     }        copy()     {         const copy = new r1952(this.nodeId, this.options);          copy.o3358(this);          if (this.props  ) copy.props   = this.props  .copy();         if (this.replace) copy.replace = this.replace.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                   const input   = await evalValue    (this.input,   parse);         const props   = await evalListValue(this.props,   parse);         const replace = await evalValue    (this.replace, parse);            if (input)         {             this.value         = input;             this.value.props   = props;             this.value.replace = replace;         }         else         {             this.value = new x4216();         }                  await this.t4099(parse);           this.l4100(parse,          [             ['type',    this.outputType()],                          ['props',   props            ],             ['replace', replace          ]         ]);           this.validate();          return this;     }        async t4099(parse, options = {})     {         if (this.value.isValid())         {             this.value.objects =                     this.input                  && this.input.value                 ? this.input.value.objects.map(o => o.copy())                  : [];         }           if (this.value.objects)         {             for (const g111 of this.value.objects)             {                 g111.nodeId   = this.nodeId;                 g111.objectId = g111.objectId + c967 + this.nodeId;             }              this.applyProps(this.value.objects, this.value.props, this.value.replace.value);         }                   await super.t4099(parse);     }        applyProps(objects, props, replace)     {         for (const g111 of objects)         {             if (this.options.enabled)             {                                                                                                                                          {                     if (replace == 1)                     {                         g111.fills    = [];                         g111.strokes  = [];                         g111.effects  = [];                         g111.maskType = 0;                     }                       if (o957(props.type))                     {                                        for (let i = props.items.length-1; i >= 0; i--)                             k1822(g111, props.items[i]);                     }                     else                         k1822(g111, props);                 }             }         }     }        q3632()     {         return this.value              ? this.value.copy()              : null;     }            isValid()     {         return super.isValid()             && this.props   && this.props  .isValid()             && this.replace && this.replace.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.props  ) this.props  .g4087(parse);         if (this.replace) this.replace.g4087(parse);     }       e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.props  ) this.props  .e4088(parse, from, force);         if (this.replace) this.replace.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.props  ) this.props  .q4086(parse);         if (this.replace) this.replace.q4086(parse);     } }


class g1946 extends c1973 {     children  = null;     operation = null;        constructor(nodeId, options)     {         super(b1286, nodeId, options);     }        reset()     {         super.reset();          this.children  = null;         this.operation = null;     }        copy()     {         const copy = new g1946(this.nodeId, this.options);          copy.o3358(this);          if (this.children ) copy.children  = this.children .copy();         if (this.operation) copy.operation = this.operation.copy();          return copy;     }        u4241(v2991)     {         switch (v2991)         {             case 'children':  return this.input ? this.value.children  : this.children;             case 'operation': return this.input ? this.value.operation : this.operation;         }          return super.u4241(v2991);     }        async eval(parse)     {         if (this.isCached())             return this;           await this.evalBaseParams(parse);          let   children  = await evalListValue  (this.children,  parse);         const operation = await evalNumberValue(this.operation, parse);           if (   children             && f1294.includes(children.type)             && children.type != a1059)         {             const objects    = children.objects;             children         = new u2020([children]);             children.objects = objects;         }           let input = null;          if (this.input)         {             input = await evalValue(this.input, parse);              this.value = new s2026(                 this.nodeId,                 children  ?? input.children,                 operation ?? input.operation);         }         else         {             this.value = new s2026(                 this.nodeId,                  children,                 operation);         }           this.l4100(parse,         [             ['operation', operation]         ]);           await this.s2895(parse);           await this.t4099(parse);           if (!this.children ) this.children  = this.value.children .copy();         if (!this.operation) this.operation = this.value.operation.copy();           this.validate();          return this;     }        async t4099(parse, options = {})     {         if (!this.options.enabled)             return;                       if (   this.value.objects             && this.value.operation)         {             let typeSuffix = '';              switch (this.operation.value)             {                 case 0: typeSuffix = '+'; break;                 case 1: typeSuffix = '-'; break;                 case 2: typeSuffix = '*'; break;                 case 3: typeSuffix = '/'; break;             }               const bool = new y1837(                 this.nodeId,                 this.nodeId + c967 + typeSuffix,                 this.nodeName,                 this.operation.value);               const bounds = getObjBounds(this.value.objects);              for (let i = 0; i < this.value.objects.length; i++)             {                 const g111 = this.value.objects[i];                                                     g111.f3741();                                                                     g111.resetSpace(bounds, false);                  this.r3736(bool.children, g111);             }                            bool.x      = bounds.x;             bool.y      = bounds.y;             bool.width  = bounds.width;             bool.height = bounds.height;                           bool.f3741();             bool.resetSpace(bounds);              bool.s4097(bounds.x, bounds.y);             bool.l3729(bounds.x, bounds.y, bounds.width, bounds.height);                      this.value.objects = [bool];               const nChildren = new z2021(                 this.children.objects                  ? this.children.objects.length                 : 0);               this.l4100(parse,             [                 ['nChildren', nChildren]             ],             true);         }         else         {             this.value.objects = [];                          this.l4100(parse,             [                 ['nChildren', new z2021(0)]             ],             true);         }                   await super.t4099(parse);     }        r3736(objects, _obj)     {         const g111 = w3737(_obj);          g111.nodeId   = this.nodeId;         g111.objectId = g111.objectId + c967 + this.nodeId;         g111.listId   = -1;          objects.push(g111);     }       q3632()     {         return this.value.copy();     }        isValid()     {         return super.isValid()             && this.children  && this.children .isValid()             && this.operation && this.operation.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.input    ) this.input    .g4087(parse);         if (this.children ) this.children .g4087(parse);         if (this.operation) this.operation.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.input    ) this.input    .e4088(parse, from, force);         if (this.children ) this.children .e4088(parse, from, force);         if (this.operation) this.operation.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.input    ) this.input    .q4086(parse);         if (this.children ) this.children .q4086(parse);         if (this.operation) this.operation.q4086(parse);     } }














class g1969 extends p1974 {     inputs = [];      retain = null;      finalize;        constructor(nodeId, options)     {         super(n1293, nodeId, options);     }        reset()     {         super.reset();          this.inputs = [];         this.retain = null;     }        copy()     {         const copy = new g1969(this.nodeId, this.options);          copy.o3358(this);          copy.inputs = this.inputs.map(i => i.copy());          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;          const retain   = await evalNumberValue(this.retain, parse);         const finalize = this.finalize.value > 0;           this.value = new u2020();          this.value.objects = [];           for (let i = 0, o = 0; i < this.inputs.length; i++)         {             await this.inputs[i].eval(parse);              const objects = t3627(this.inputs[i].value);                                   if (   this.options.enabled                 && (   finalize                     || retain.value == 1))             {                 for (let j = 0; j < objects.length; j++, o++)                 {                     let g111 = objects[j];                                            g111.nodeId   = this.nodeId;                     g111.objectId = g111.objectId + c967 + this.nodeId;                     g111.listId   = -1;                      if (  (   !isEmpty(g111.fills  )                            || !isEmpty(g111.strokes))                         && !g111.q3738)                             g111.retain = finalize ? 2 : 1;                                                  this.value.objects.push(g111);                 }             }         }           this.l4100(parse, [['', new x4216()]]);           this.validate();          return this;     }        q3632()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && !this.inputs.find(i => !i.isValid())             && this.retain && this.retain.isValid();     }        g4087(parse)     {         super.g4087(parse);          this.inputs.forEach(i => i.g4087(parse));          if (this.retain) this.retain.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          this.inputs.forEach(i => i.e4088(parse, from, force));          if (this.retain) this.retain.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          this.inputs.forEach(i => i.q4086(parse));          if (this.retain) this.retain.q4086(parse);     } }


class GExport extends p1974 {     inputs = [];      scale;     format;         suffix;          constructor(nodeId, options)     {         super(EXPORT, nodeId, options);     }        reset()     {         super.reset();          this.inputs = [];                  this.scale    = null;         this.format   = null;                     this.suffix   = null;           }        copy()     {         const copy = new GExport(this.nodeId, this.options);          copy.o3358(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.scale   ) copy.scale    = this.scale   .copy();         if (this.format  ) copy.format   = this.format  .copy();                     if (this.suffix  ) copy.suffix   = this.suffix  .copy();                return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const scale      = await evalNumberValue(this.scale,    parse);         const format     = await evalNumberValue(this.format,   parse);                     const suffix     = await evalTextValue  (this.suffix,   parse);                 this.value = new u2020();          this.value.objects = [];           for (let i = 0, o = 0; i < this.inputs.length; i++)         {             await this.inputs[i].eval(parse);              const objects = t3627(this.inputs[i].value);                                   for (let j = 0; j < objects.length; j++, o++)             {                 let g111 = objects[j];                                    g111.nodeId   = this.nodeId;                 g111.objectId = g111.objectId + c967 + this.nodeId;                 g111.listId   = -1;                  this.value.objects.push(g111);             }         }           this.l4100(parse,          [             ['objectIds', new u2020(this.value.objects.map(o => new b2032(o.objectId)))]         ]);           this.validate();          return this;     }        q3632()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && !this.inputs.find(i => !i.isValid())             && this.scale    && this.scale   .isValid()             && this.format   && this.format  .isValid()                                 && this.suffix   && this.suffix  .isValid();               }        g4087(parse)     {         super.g4087(parse);          this.inputs.forEach(i => i.g4087(parse));          if (this.scale   ) this.scale   .g4087(parse);         if (this.format  ) this.format  .g4087(parse);                     if (this.suffix  ) this.suffix  .g4087(parse);           }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          this.inputs.forEach(i => i.e4088(parse, from, force));          if (this.scale   ) this.scale   .e4088(parse, from, force);         if (this.format  ) this.format  .e4088(parse, from, force);                     if (this.suffix  ) this.suffix  .e4088(parse, from, force);           }        q4086(parse)     {         super.q4086(parse);          this.inputs.forEach(i => i.q4086(parse));          if (this.scale   ) this.scale   .q4086(parse);         if (this.format  ) this.format  .q4086(parse);                     if (this.suffix  ) this.suffix  .q4086(parse);           } }


class o1961 extends u2043 {     y3661    = null;     x           = null;     y           = null;     affectSpace = null;          _a          = 0;        constructor(nodeId, options)     {         super(y1270, nodeId, options);     }        reset()     {         super.reset();          this.y3661    = null;         this.x           = null;         this.y           = null;         this.affectSpace = null;          this._a          = 0;     }        copy()     {         const copy = new o1961(this.nodeId, this.options);          copy.o3358(this);          if (this.y3661   ) copy.y3661    = this.y3661   .copy();         if (this.x          ) copy.x           = this.x          .copy();         if (this.y          ) copy.y           = this.y          .copy();         if (this.affectSpace) copy.affectSpace = this.affectSpace.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const input       = await evalValue      (this.input,       parse);         const y3661    = await evalNumberValue(this.y3661,    parse);         const x           = await evalNumberValue(this.x,           parse);         const y           = await evalNumberValue(this.y,           parse);         const affectSpace = await evalNumberValue(this.affectSpace, parse);           if (input)         {             this.value = input.copy();              if (this.value)                 this.value.nodeId = this.nodeId;         }         else         {             this.value = new x4216();         }           await this.t4099(             parse,              {                 y3661:    y3661,                 x:           x,                  y:           y,                 affectSpace: affectSpace             });           this.l4100(parse,         [             ['type',        this.outputType()],             ['moveType',    y3661         ],             ['x',           x                ],             ['y',           y                ],             ['affectSpace', affectSpace      ]         ]);           this.validate();          return this;     }        async t4099(parse, options = {})     {         if (   this.value             && this.value.isValid()             && options.y3661             && options.x             && options.y             && options.affectSpace)         {             this.value.objects = t3627(this.input.value);               if (o957(this.value.type))             {                 for (let i = 0; i < this.value.items.length; i++)                     this.value.items[i].objects = this.value.objects.filter(o => o.y3819 == i);             }                              const y3661    = options.y3661   .value;             const x           = options.x          .value;             const y           = options.y          .value;             const affectSpace = options.affectSpace.value;               let _a = y/360*Tau;              while (_a <  0  ) _a += Tau;             while (_a >= Tau) _a -= Tau;                   const _v = vector(_a, x);                          const _x = y3661 == 0 ? x : _v.x;             const _y = y3661 == 0 ? y : _v.y;               const y4207 =                  y3661 == 0                 ? b893(_x, _y)                 : x889(                     b893(_x, _y),                     x892(-_a));                                    for (const g111 of this.value.objects)             {                 g111.nodeId    = this.nodeId;                 g111.objectId += c967 + this.nodeId;                  if (this.options.enabled)                     g111.r4098(y4207, affectSpace);             }               if (   this.value.type == q1249                 && this.value.objects                 && this.value.objects.length > 0                 && this.value.points.objects)             {                 for (let i = 0; i < this.value.objects[0].points.length; i++)                 {                     const p = this.value.objects[0].points[i].y3746();                          this.value.points.objects[i].x = p.x;                     this.value.points.objects[i].y = p.y;                 }             }         }                           await super.t4099(parse);     }        q3632()     {         return this.value              ? this.value.copy()              : null;     }                    isValid()     {         return super.isValid()             && this.y3661    && this.y3661   .isValid()             && this.x           && this.x          .isValid()             && this.y           && this.y          .isValid()             && this.affectSpace && this.affectSpace.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.y3661   ) this.y3661   .g4087(parse);         if (this.x          ) this.x          .g4087(parse);         if (this.y          ) this.y          .g4087(parse);         if (this.affectSpace) this.affectSpace.g4087(parse);     }       e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.y3661   ) this.y3661   .e4088(parse, from, force);         if (this.x          ) this.x          .e4088(parse, from, force);         if (this.y          ) this.y          .e4088(parse, from, force);         if (this.affectSpace) this.affectSpace.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.y3661   ) this.y3661   .q4086(parse);         if (this.x          ) this.x          .q4086(parse);         if (this.y          ) this.y          .q4086(parse);         if (this.affectSpace) this.affectSpace.q4086(parse);     } }


class y1951 extends u2043 {     affectSpace = null;        constructor(type, nodeId, options)     {         super(type, nodeId, options);     }        reset()     {         super.reset();          this.affectSpace = null;     }        o3358(base)     {         super.o3358(base);          if (base.affectSpace) this.affectSpace = base.affectSpace.copy();     }        async evalBaseParams(parse)     {         const affectSpace = await evalNumberValue(this.affectSpace, parse);          return [affectSpace];     }        async evalAffineObjects(parse, options, i3739, scaleStyle, getXform)     {         if (   !this.value             || !this.value.isValid()             || !this.input)             return o1047.NaN;           this.value.objects = t3627(this.input.value);                  if (o957(this.value.type))         {             for (let i = 0; i < this.value.items.length; i++)                 this.value.items[i].objects = this.value.objects.filter(o => o.y3819 == i);         }           const bounds = getObjBounds(this.value.objects);         const y4207  = getXform();           for (const g111 of this.value.objects)         {             g111.nodeId   = this.nodeId;             g111.objectId = g111.objectId + c967 + this.nodeId;               if (this.options.enabled)             {                 g111.r4098(                     y4207,                      options.affectSpace ? options.affectSpace.value : 2);                  g111.checkFlipped(                     options.flipX === true && y4207[0][0] < 0,                      options.flipY === true && y4207[1][1] < 0);                                      g111.i3739 *= Math.abs(i3739);                 g111.scaleStyle   *= Math.abs(scaleStyle  );                                  if (g111.type == k1243)                 {                     const sx = Math.sqrt(sqr(y4207[0][0]) + sqr(y4207[0][1]));                     const sy = Math.sqrt(sqr(y4207[1][0]) + sqr(y4207[1][1]));                      g111.size *= Math.min(sx, sy);                 }             }         }           if (   this.value.type == q1249             && this.value.objects             && this.value.objects.length > 0             && this.value.points.objects)         {             for (let i = 0; i < this.value.objects[0].points.length; i++)             {                 const p = this.value.objects[0].points[i].y3746();                  this.value.points.objects[i].x = p.x;                 this.value.points.objects[i].y = p.y;             }         }           return bounds;     }        isValid()     {         return super.isValid()             && this.affectSpace && this.affectSpace.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.affectSpace) this.affectSpace.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.affectSpace) this.affectSpace.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.affectSpace) this.affectSpace.q4086(parse);     } }


class d1971 extends y1951 {     angle = null;        constructor(nodeId, options)     {         super(s1271, nodeId, options);     }        reset()     {         super.reset();          this.angle = null;     }        copy()     {         const copy = new d1971(this.nodeId, this.options);          copy.o3358(this);          if (this.angle) copy.angle = this.angle.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalValue      (this.input, parse);         const angle = await evalNumberValue(this.angle, parse);           const [affectSpace] = await this.evalBaseParams(parse);           if (input)         {             this.value = input.copy();                          if (this.value)                 this.value.nodeId = this.nodeId;         }         else         {             this.value = new x4216();         }                  const _bounds = await this.t4099(             parse,              {                 angle:       angle,                  affectSpace: affectSpace             });                   const bounds = new k2024(             this.nodeId,             new z2021(_bounds.x     ),              new z2021(_bounds.y     ),              new z2021(_bounds.width ),             new z2021(_bounds.height),             new z2021(0));           this.l4100(parse,         [             ['type',        this.outputType()],             ['angle',       angle            ],             ['affectSpace', affectSpace      ],             ['bounds',      bounds           ]         ]);           this.validate();          return this;     }        async t4099(parse, options)     {         const a     = options.angle ? options.angle.value/360*Tau : 0;         const y4207 = x892(a);          options.flipX = false;         options.flipY = false;          return await this.evalAffineObjects(             parse,             options,              1,              1,             () => y4207);     }        q3632()     {         return this.value         ? this.value.copy()         : null;     }                    isValid()     {         return super.isValid()             && this.angle && this.angle.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.angle) this.angle.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.angle) this.angle.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.angle) this.angle.q4086(parse);     } }


class t1972 extends y1951 {     scaleX        = null;     scaleY        = null;     affectCorners = null;     affectStyle   = null;            constructor(nodeId, options)     {         super(z1272, nodeId, options);     }        reset()     {         super.reset();          this.scaleX        = null;         this.scaleY        = null;         this.affectCorners = null;         this.affectStyle   = null;     }        copy()     {         const copy = new t1972(this.nodeId, this.options);          copy.o3358(this);          if (this.scaleX       ) copy.scaleX        = this.scaleX       .copy();         if (this.scaleY       ) copy.scaleY        = this.scaleY       .copy();         if (this.affectCorners) copy.affectCorners = this.affectCorners.copy();         if (this.affectStyle  ) copy.affectStyle   = this.affectStyle  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input         = await evalValue      (this.input,         parse);         let   scaleX        = await evalNumberValue(this.scaleX,        parse);         let   scaleY        = await evalNumberValue(this.scaleY,        parse);         let   affectCorners = await evalNumberValue(this.affectCorners, parse);         let   affectStyle   = await evalNumberValue(this.affectStyle,   parse);           const [affectSpace] = await this.evalBaseParams(parse);           if (input)         {             this.value = input.copy();                          if (this.value)                 this.value.nodeId = this.nodeId;         }         else         {             this.value = new x4216();         }                  const _bounds = await this.t4099(             parse,              {                 scaleX:        scaleX,                  scaleY:        scaleY,                  affectSpace:   affectSpace,                 affectCorners: affectCorners,                 affectStyle:   affectStyle             });           const bounds = new k2024(             this.nodeId,             new z2021(_bounds.x     ),              new z2021(_bounds.y     ),              new z2021(_bounds.width ),             new z2021(_bounds.height),             new z2021(0));           this.l4100(parse,         [             ['type',          this.outputType()],             ['scaleX',        scaleX           ],             ['scaleY',        scaleY           ],             ['affectSpace',   affectSpace      ],             ['affectCorners', affectCorners    ],             ['affectStyle',   affectStyle      ],             ['bounds',        bounds           ]         ]);                   this.validate();          return this;     }        async t4099(parse, options)     {         let sx = w879(options.scaleX.value / 100);         let sy = w879(options.scaleY.value / 100);          options.flipX = sx < 0;         options.flipY = sy < 0;                  const scale = Math.min(sx, sy);          return await this.evalAffineObjects(             parse,             options,              this.affectCorners.value > 0 ? scale : 1,             this.affectStyle  .value > 0 ? scale : 1,             () => [[sx, 0,  0],                    [0,  sy, 0],                    [0,  0,  1]]);     }        isValid()     {         return super.isValid()             && this.scaleX        && this.scaleX       .isValid()             && this.scaleY        && this.scaleY       .isValid()             && this.affectCorners && this.affectCorners.isValid()             && this.affectStyle   && this.affectStyle  .isValid();     }        q3632()     {         return this.value              ? this.value.copy()              : null;     }        g4087(parse)     {         super.g4087(parse);          if (this.scaleX       ) this.scaleX       .g4087(parse);         if (this.scaleY       ) this.scaleY       .g4087(parse);         if (this.affectCorners) this.affectCorners.g4087(parse);         if (this.affectStyle  ) this.affectStyle  .g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.scaleX       ) this.scaleX       .e4088(parse, from, force);         if (this.scaleY       ) this.scaleY       .e4088(parse, from, force);         if (this.affectCorners) this.affectCorners.e4088(parse, from, force);         if (this.affectStyle  ) this.affectStyle  .e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.scaleX       ) this.scaleX       .q4086(parse);         if (this.scaleY       ) this.scaleY       .q4086(parse);         if (this.affectCorners) this.affectCorners.q4086(parse);         if (this.affectStyle  ) this.affectStyle  .q4086(parse);     } }


class y1976 extends y1951 {     skewX = null;     skewY = null;        constructor(nodeId, options)     {         super(o1273, nodeId, options);     }        reset()     {         super.reset();          this.skewX = null;         this.skewY = null;     }        copy()     {         const copy = new y1976(this.nodeId, this.options);          copy.o3358(this);          if (this.skewX) copy.skewX = this.skewX.copy();         if (this.skewY) copy.skewY = this.skewY.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const input = await evalValue      (this.input, parse);         let   skewX = await evalNumberValue(this.skewX, parse);         let   skewY = await evalNumberValue(this.skewY, parse);           const [affectSpace] = await this.evalBaseParams(parse);           if (input)         {             this.value = input;              if (this.value)                 this.value.nodeId = this.nodeId;         }         else         {             this.value = new x4216();         }                   const _bounds = await this.t4099(             parse,              {                 skewX:       skewX,                  skewY:       skewY,                  affectSpace: affectSpace             });           const bounds = new k2024(             this.nodeId,             new z2021(_bounds.x     ),              new z2021(_bounds.y     ),              new z2021(_bounds.width ),             new z2021(_bounds.height),             new z2021(0));           this.l4100(parse,         [             ['type',        this.outputType()],             ['skewX',       skewX            ],             ['skewY',       skewY            ],             ['affectSpace', affectSpace      ],             ['bounds',      bounds           ]         ]);           this.validate();          return this;     }        async t4099(parse, options)     {         const sx = -options.skewX.value / 100;         const sy = -options.skewY.value / 100;          options.flipX = false;         options.flipY = false;          return await this.evalAffineObjects(             parse,             options,              1, 1,             () => [[1,  sx, 0],                    [sy, 1,  0],                    [0,  0,  1]]);     }        isValid()     {         return super.isValid()             && this.skewX && this.skewX.isValid()             && this.skewY && this.skewY.isValid();     }        q3632()     {         return this.value              ? this.value.copy()              : null;     }        g4087(parse)     {         super.g4087(parse);          if (this.skewX) this.skewX.g4087(parse);         if (this.skewY) this.skewY.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.skewX) this.skewX.e4088(parse, from, force);         if (this.skewY) this.skewY.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.skewX) this.skewX.q4086(parse);         if (this.skewY) this.skewY.q4086(parse);     } }


class GShowCenter extends u2043 {     show = null;        constructor(nodeId, options)     {         super(SHOW_CENTER, nodeId, options);     }        copy()     {         const copy = new GShowCenter(this.nodeId, this.options);          copy.o3358(this);          if (this.show) copy.show = this.show.copy();                  return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalValue      (this.input, parse);         const show  = await evalNumberValue(this.show,  parse);           if (   input             && show)         {             this.value = input;              this.value.nodeId = this.nodeId;         }         else             this.value = new x4216();                   await this.t4099(parse, {show: show && show.value > 0});           const type = this.outputType();          this.l4100(parse,         [             ['type', type],             ['show', show]         ]);           this.validate();          return this;     }        async t4099(parse, options = {})     {         if (   this.value             && this.value.isValid())         {             this.value.objects = t3627(this.input.value);               for (const g111 of this.value.objects)             {                 g111.nodeId   = this.nodeId;                 g111.objectId = g111.objectId + c967 + this.nodeId;                                  if (   this.options.enabled                     && options.show)                     g111.showCenter = options.show;             }         }                           await super.t4099(parse);     }        q3632()     {         return this.value         ? this.value.copy()         : null;     }        isValid()     {         return super.isValid()             && this.show && this.show.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.show) this.show.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.show) this.show.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.show) this.show.q4086(parse);     } }


class p1953 extends u2043 {     centerX = null;     centerY = null;     units   = null;        constructor(nodeId, options)     {         super(a1274, nodeId, options);     }        reset()     {         super.reset();          this.centerX = null;         this.centerY = null;         this.units   = null;     }        copy()     {         const copy = new p1953(this.nodeId, this.options);          copy.o3358(this);          if (this.centerX) copy.centerX = this.centerX.copy();         if (this.centerY) copy.centerY = this.centerY.copy();         if (this.units  ) copy.units   = this.units  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const input   = await evalValue      (this.input,   parse);         const centerX = await evalNumberValue(this.centerX, parse);         const centerY = await evalNumberValue(this.centerY, parse);         const units   = await evalNumberValue(this.units,   parse);           if (this.input)         {             this.value = input.copy();              if (this.value)                 this.value.nodeId = this.nodeId;         }         else         {             this.value = new x4216();         }                   await this.t4099(             parse,              {                 centerX:    centerX,                  centerY:    centerY,                 units:      units             });           const type = this.outputType();          this.l4100(parse,         [             ['type',    type   ],             ['centerX', centerX],             ['centerY', centerY],             ['units',   units  ]         ]);           this.validate();          return this;     }        async t4099(parse, options = {})     {         if (   this.value             && this.value.isValid())         {             this.value.objects = t3627(this.input.value);                           const centerX = options.centerX    ? options.centerX   .value : 0;             const centerY = options.centerY    ? options.centerY   .value : 0;             const units   = options.units      ? options.units     .value : 0;                   const cx      = units == 0 ? centerX/100 : centerX;             const cy      = units == 0 ? centerY/100 : centerY;               const bounds  = getObjBounds(this.value.objects);               const singlePoint =                      this.value.objects.length  == 1                  && this.value.objects[0].type == q1246;               for (const g111 of this.value.objects)             {                 g111.nodeId   = this.nodeId;                 g111.objectId = g111.objectId + c967 + this.nodeId;                  if (this.options.enabled)                     g111.resetSpace(bounds, singlePoint, cx, cy, units);             }         }                           await super.t4099(parse);     }        q3632()     {         return this.value             ? this.value.copy()             : null;     }                    isValid()     {         return super.isValid()             && this.centerX && this.centerX.isValid()             && this.centerY && this.centerY.isValid()             && this.units   && this.units  .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.centerX) this.centerX.g4087(parse);         if (this.centerY) this.centerY.g4087(parse);         if (this.units  ) this.units  .g4087(parse);     }       e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.centerX) this.centerX.e4088(parse, from, force);         if (this.centerY) this.centerY.e4088(parse, from, force);         if (this.units  ) this.units  .e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.centerX) this.centerX.q4086(parse);         if (this.centerY) this.centerY.q4086(parse);         if (this.units  ) this.units  .q4086(parse);     } }


class i1970 extends u2043 {     constructor(nodeId, options)     {         super(j1275, nodeId, options);     }        copy()     {         const copy = new i1970(this.nodeId, this.options);          copy.o3358(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalValue(this.input, parse);           if (input)         {             this.value = input;              this.value.nodeId = this.nodeId;         }         else             this.value = new x4216();                   await this.t4099(parse);           const type = this.outputType();          this.l4100(parse,         [             ['type', type]         ]);           this.validate();          return this;     }        async t4099(parse, options = {})     {         if (   this.value             && this.value.isValid())         {             this.value.objects = t3627(this.input.value);               const bounds = getObjBounds(this.value.objects);              const singlePoint =                    this.value.objects.length  == 1                  && this.value.objects[0].type == q1246;               for (const g111 of this.value.objects)             {                 g111.nodeId    = this.nodeId;                 g111.objectId += c967 + this.nodeId;                  if (this.options.enabled)                 {                     g111.f3741();                     g111.resetSpace(bounds, singlePoint);                 }             }         }                           await super.t4099(parse);     }        q3632()     {         return this.value         ? this.value.copy()         : null;     } }


class GJoinPaths extends c1973 {     inputs  = [];      closed  = null;     degree  = null;     winding = null;     round   = null;        constructor(nodeId, options)     {         super(JOIN_PATHS, nodeId, options);     }        reset()     {         super.reset();          this.inputs  = [];          this.closed  = null;         this.degree  = null;         this.winding = null;         this.round   = null;     }        copy()     {         const copy = new GJoinPaths(this.nodeId, this.options);          copy.o3358(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.closed ) copy.closed  = this.closed .copy();         if (this.degree ) copy.degree  = this.degree .copy();         if (this.winding) copy.winding = this.winding.copy();         if (this.round  ) copy.round   = this.round  .copy();          return copy;     }        u4241(v2991)     {         switch (v2991)         {             case 'closed':  return this.input ? this.value.closed  : this.closed;             case 'degree':  return this.input ? this.value.degree  : this.degree;             case 'winding': return this.input ? this.value.winding : this.winding;             case 'round':   return this.input ? this.value.round   : this.round;         }          return super.u4241(v2991);     }        async eval(parse)     {         if (this.isCached())             return this;           const closed  = await evalNumberValue(this.closed,  parse);         const degree  = await evalNumberValue(this.degree,  parse);         const winding = await evalNumberValue(this.winding, parse);         const round   = await evalNumberValue(this.round,   parse);           if (this.inputs.length > 0)         {             const paths  = [];             const points = new u2020();              for (const e3811 of this.inputs)             {                 const input = await evalVectorPathValue(e3811, parse);                  if (o957(input.type)) paths.push(...input.items);                 else                             paths.push(input);             }                                          for (let i = 0; i < paths.length; i++)             {                 const path = paths[i];                                  if (   !path                     || !path.objects                     ||  path.objects.length == 0)                     continue;                   let _degree;                       if (path.type == q1249) _degree = path.degree.value;                 else if (path.type == v1231   ) _degree = 2;                 else if (path.type == c1234  ) _degree = path.shape.value == 4 ? 2 : 0;                   const r3745 = path.objects[0].r3745;                 const pathDegree = Math.min(_degree, 2) + 1;                                   if (r3745.length == 0) continue;                   const segment = this.makeCubic(r3745, pathDegree);                  if (   i > 0                     && points.items.length > 1                     && segment.length > 1)                     this.joinSegment(points, segment, degree);                  points.items.push(...segment.map(p => t2022.fromPoint(this.nodeId, p)));             }               if (   closed.value > 0                 && points.items.length > 1)             {                 const segment = [ points.items[0].y3746(),                                   points.items[1].y3746() ];                  this.joinSegment(points, segment, degree);                  points.items.push(points.items[0].copy());             }               this.value = new y2036(                 this.nodeId,                  points,                  closed,                  new z2021(2),                 winding,                  round);               this.value.points.objects = this.value.points.items.map(p =>             {                 return new d1843(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     p.x.value,                     p.y.value,                     p.smooth ? p.smooth.value/100 : 1);             });         }         else         {             this.value = new y2036(                 this.nodeId,                  new u2020(),                  closed,                  new z2021(2),                 winding,                  round);         }           this.l4100(parse,          [             ['closed',  closed ],             ['degree',  degree ],             ['winding', winding],             ['round',   round  ]         ]);           await this.s2895(parse);           await this.t4099(parse);           this.validate();          return this;     }        joinSegment(points, segment, degree)     {         const p_2 = points.items.at(-2).y3746();         const p_1 = points.items.at(-1).y3746();          const p0  = segment[0];         const p1  = segment[1];          if (!o1019(p_1, p0))             points.items.push(...this.getJoinPoints(p_2, p_1, p0, p1, degree).map(p => t2022.fromPoint(this.nodeId, p)));         else             points.items.pop();     }        getJoinPoints(p_2, p_1, p0, p1, degree)     {         const points = [];           switch (degree.value)         {              case 0:                  points.push(z986(p_1, p0, 1/3));                 points.push(z986(p_1, p0, 2/3));                 break;              case 1:              {                 const c = f989(p_2, p_1, p1, p0, false);                 points.push(x895(p_1, i897(w886(v900(c, p_1)), Math.min(distv(p_2, p_1), distv(p_1, c) * 2/3))));                 points.push(x895(p0,  i897(w886(v900(c, p0 )), Math.min(distv(p1,  p0),  distv(p0,  c) * 2/3))));                 break;             }             case 2:                  points.push(x895(p_2, i897(v900(p_1, p_2), 2)));                 points.push(x895(p1,  i897(v900(p0,  p1),  2)));                 break;              case 3:                  points.push(point(r1035(p_1.x, p0.x, 0.3615), p_1.y));                 points.push(point(r1035(p0.x, p_1.x, 0.3615), p0 .y));                 break;              case 4:                  points.push(point(p_1.x, r1035(p_1.y, p0.y, 0.3615)));                 points.push(point(p0 .x, r1035(p0.y, p_1.y, 0.3615)));                 break;         }                   return points;     }        makeCubic(r3745, pathDegree)     {         const points = [r3745[0]];           for (let i = 0; i < r3745.length-pathDegree; i += pathDegree)         {             let segPoints;              switch (pathDegree)             {                 case 1: segPoints = linear2cubic(r3745.slice(i, i+2)); break;                 case 2: segPoints =   quad2cubic(r3745.slice(i, i+3)); break;                 case 3: segPoints =              r3745.slice(i, i+4);  break;             }              points.push(...segPoints.slice(1));          }                  return points;     }        async t4099(parse, options = {})     {         if (!this.options.enabled)             return;                       const points = [];          for (const pt of this.value.points.items)         {             const p = t2022.create(this.nodeId, pt.x.value, pt.y.value);                          if (pt.smooth != null)                 p.smooth = new z2021(pt.smooth);              points.push(p);         }           this.value.objects = [];           if (   super.w2896()                && points.length >= 2             && this.value.closed .isValid()             && this.value.degree .isValid()             && this.value.winding.isValid()             && this.value.round  .isValid())         {             const path = new h1852(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 points,                 this.value.closed .value,                 this.value.degree .value,                 this.value.winding.value,                 this.value.round  .value);                               const bounds = getObjBounds([path]);              let x = bounds.x;             let y = bounds.y;             let w = bounds.w;             let h = bounds.h;                           path.f3741(x + w/2, y + h/2);             path.s4097(x, y);             path.l3729(x, y, w, h);              this.value.objects.push(path);         }           await super.t4099(parse);     }        isValid()     {         if (!super.isValid())              return false;          for (const input of this.inputs)             if (!input.isValid())                 return false;          return this.closed  && this.closed .isValid()             && this.degree  && this.degree .isValid()             && this.winding && this.winding.isValid()             && this.round   && this.round  .isValid();     }        g4087(parse)     {         super.g4087(parse);          this.inputs.forEach(i => i.g4087(parse));          if (this.closed ) this.closed .g4087(parse);         if (this.degree ) this.degree .g4087(parse);         if (this.winding) this.winding.g4087(parse);         if (this.round  ) this.round  .g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          this.inputs.forEach(i => i.e4088(parse, from, force));          if (this.closed ) this.closed .e4088(parse, from, force);         if (this.degree ) this.degree .e4088(parse, from, force);         if (this.winding) this.winding.e4088(parse, from, force);         if (this.round  ) this.round  .e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          this.inputs.forEach(i => i.q4086(parse));          if (this.closed ) this.closed .q4086(parse);         if (this.degree ) this.degree .q4086(parse);         if (this.winding) this.winding.q4086(parse);         if (this.round  ) this.round  .q4086(parse);     } }


class GReorientPaths extends c1973 {     inputs  = [];      reverse = null;        constructor(nodeId, options)     {         super(JOIN_PATHS, nodeId, options);     }        reset()     {         super.reset();          this.inputs  = [];          this.reverse = null;     }        copy()     {         const copy = new GReorientPaths(this.nodeId, this.options);          copy.o3358(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.reverse) copy.reverse = this.reverse.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const reverse = await evalNumberValue(this.reverse, parse);           if (this.inputs.length > 0)         {             const paths = [];              for (const e3811 of this.inputs)             {                 const input = await evalVectorPathValue(e3811, parse);                  if (o957(input.type)) paths.push(...input.items);                 else                             paths.push(input);             }               this.value = new u2020();               const reorientedPaths =                  this.options.enabled                 ? reorientPaths(paths, reverse.value > 0)                 : paths                       .filter(path => path.objects && path.objects.length > 0)                       .map   (path => path.objects[0].r3745);         ;              c952(paths.length == reorientedPaths.length, 'original path count must match reoriented path count');                                       for (let i = 0; i < reorientedPaths.length; i++)             {                 const points =                      reorientedPaths[i]                     ? reorientedPaths[i].map(p => t2022.fromPoint(this.nodeId, p))                     :    paths[i]                     && paths[i].points                     ? paths[i].points.items                     : [];                  if (points.length == 0)                     continue;                                  const path = new y2036(                     this.nodeId,                     new u2020(points),                     paths[i].closed,                     paths[i].degree,                     paths[i].winding,                     paths[i].round);                                      path.o3358(paths[i]);                                  this.value.items.push(path);             }         }         else         {             this.value = new u2020();         }           this.l4100(parse,          [             ['reverse', reverse]         ]);           await this.s2895(parse);           await this.t4099(parse);           this.validate();          return this;     }        async t4099(parse, options = {})     {         this.value.objects = [];           for (let i = 0; i < this.value.items.length; i++)         {             const _path = this.value.items[i];             if (!_path) continue;               if (   _path.points.items.length >= 2                 && _path.closed .isValid()                 && _path.degree .isValid()                 && _path.winding.isValid()                 && _path.round  .isValid())             {                 const path = new h1852(                      this.nodeId,                      this.nodeId + c967 + i,                      this.nodeName,                     _path.points.items,                     _path.closed .value,                     _path.degree .value,                     _path.winding.value,                     _path.round  .value);                   if (_path.props)                     addProps(path, _path.props);                                       _path.objects = [path];                  this.value.objects.push(path);             }         }           const bounds = getObjBounds(this.value.objects);          for (const path of this.value.objects)         {             path.f3741(                 bounds.x + bounds.width /2,                             bounds.y + bounds.height/2                         );               let x = bounds.x;             let y = bounds.y;             let w = bounds.w;             let h = bounds.h;                          path.s4097(x, y);             path.l3729(x, y, w, h);         }           await super.t4099(parse);     }        isValid()     {         if (!super.isValid())              return false;          for (const input of this.inputs)             if (!input.isValid())                 return false;          return this.reverse && this.reverse.isValid();     }        g4087(parse)     {         super.g4087(parse);          this.inputs.forEach(i => i.g4087(parse));          if (this.reverse) this.reverse.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          this.inputs.forEach(i => i.e4088(parse, from, force));              if (this.reverse) this.reverse.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          this.inputs.forEach(i => i.q4086(parse));          if (this.reverse) this.reverse.q4086(parse);     } }    function reorientPaths(paths, reverse)  {     const orderedPaths = [];      let remainingPaths = paths         .filter(path => path.objects && path.objects.length > 0)         .map   (path => path.objects[0].r3745);       orderedPaths.push(remainingPaths.shift());       while (remainingPaths.length > 0)      {         const currentPath = orderedPaths.at(-1);                  const { closestPathIndex, shouldReverse } = findNextPath(currentPath, remainingPaths);          if (closestPathIndex == -1)              break;           let nextPath = remainingPaths.splice(closestPathIndex, 1)[0];                  if (shouldReverse)             nextPath.reverse();          orderedPaths.push(nextPath);     }       return reverse          ? orderedPaths.reverse().map(path => path.slice().reverse())          : orderedPaths; }    function findNextPath(currentPath, remainingPaths) {     let minDistance      = Infinity;     let closestPathIndex = -1;     let shouldReverse    = false;       const currentEndPoint = currentPath.at(-1);      remainingPaths.forEach((path, index) =>      {         const distanceToStart = distv(currentEndPoint, path.at( 0));         const distanceToEnd   = distv(currentEndPoint, path.at(-1));          if (distanceToStart < minDistance)          {             minDistance      = distanceToStart;             closestPathIndex = index;             shouldReverse    = false;         }          if (distanceToEnd < minDistance)          {             minDistance      = distanceToEnd;             closestPathIndex = index;             shouldReverse    = true;         }     });       return { closestPathIndex, shouldReverse }; }


class n1960 extends u2043 {     length = null;     angle  = null;            constructor(nodeId, options)     {         super(v1278, nodeId, options);     }            reset()     {         super.reset();          this.length = null;         this.angle  = null;     }        copy()     {         const copy = new n1960(this.nodeId, this.options);          copy.o3358(this);          if (this.length) copy.length = this.length.copy();         if (this.angle ) copy.angle  = this.angle .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalPointValue(this.input, parse);           if (input)         {             const v   = input.y3746();              const len = f885(v);             let   ang = o883 (v);              if (ang > Tau/2) ang -= Tau;              this.length = new z2021(len, -2);              this.angle =                  len > 0                  ? new z2021(ang/Tau * 360, -2)                  : z2021.NaN.copy();         }         else         {             this.length = z2021.NaN.copy();             this.angle  = z2021.NaN.copy();         }           this.l4100(parse,         [             ['length', this.length],             ['angle',  this.angle ]         ]);                   this.validate();          return this;     } }


class GPointAngle extends u2043 {     constructor(nodeId, options)     {         super(e1279, nodeId, options);     }            copy()     {         const copy = new GPointAngle(this.nodeId, this.options);          copy.o3358(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalPointValue(this.input, parse);           if (input)         {             if (o957(input.type))             {                 this.value = new u2020();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                     const g111  = input.objects[i];                      this.value.items.push(                         item.type == v1245                         ? new z2021(anglev2(g111.sp0, g111.sp1) / Tau * 360)                         : z2021.NaN.copy());                    }             }             else             {                 if (input.objects)                 {                     const g111 = input.objects[0];                     this.value = new z2021(anglev2(g111.sp0, g111.sp1) / Tau * 360);                 }             }         }         else             this.value = z2021.NaN.copy();           this.l4100(parse,         [                          ['type',  this.outputType()]         ]);           this.validate();          return this;     } }         


class q1981 extends z2044 {     transform = null;        constructor(nodeId, options)     {         super(l1280, nodeId, options);     }            reset()     {         super.reset();                  this.transform = null;     }        copy()     {         const copy = new q1981(this.nodeId, this.options);          copy.o3358(this);          if (this.transform) copy.transform = this.transform .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const z4082    = await evalPointValue (this.z4082,    parse);         const z4083    = await evalPointValue (this.z4083,    parse);         const transform = await evalNumberValue(this.transform, parse);           if (   z4082 && z4082.objects && z4082.objects.length > 0 && z4082.objects[0]             && z4083 && z4083.objects && z4083.objects.length > 0 && z4083.objects[0])         {             this.value = t2022.fromPoint(                 this.nodeId,                 v900(z4083.objects[0].y3746(), z4082.objects[0].y3746()));              await this.t4099(                 parse,                  {                     transform: transform,                 });         }         else         {             this.value = t2022.NaN.copy();         }           this.l4100(parse,         [             ['transform', transform]         ]);                   this.validate();          return this;     }        async t4099(parse, options = {})     {                                                     if (!this.value.objects)             this.value.objects = [];           if (   this.value.x             && this.value.y                && this.value.x.isValid()             && this.value.y.isValid())         {             const x = this.value.x.value;             const y = this.value.y.value;              const point = new d1843(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 x,                 y,                 this.smooth ? this.smooth.value/100 : 1);               point.s4097(x, y);                           if (options.transform.value > 0)             {                 point.r4098(                     getTransformFromAngle(o883(point.y3746())),                     2);             }                       this.value.objects = [point];         }           await super.t4099(parse);     }        isValid()     {         return super.isValid()             && this.transform && this.transform.isValid(); }        g4087(parse)     {         super.g4087(parse);          if (this.transform) this.transform.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.transform) this.transform.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.transform) this.transform.q4086(parse);     } }    function getTransformFromAngle(a)  {     const cosa = Math.cos(a);     const sina = Math.sin(a);      return [[ cosa, -sina, 0 ],              [ sina,  cosa, 0 ],              [ 0,     0,    1 ]]; }


class c1954 extends p2045 {     constructor(nodeId, options)     {         super(l1281, nodeId, options);     }                                   copy()     {         const copy = new c1954(this.nodeId, this.options);          copy.o3358(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const z4082 = await evalPointValue(this.z4082, parse);         const z4083 = await evalPointValue(this.z4083, parse);         const n4084 = await evalPointValue(this.n4084, parse);           if (   z4082 && z4082.isValid()             && z4083 && z4083.isValid()             && n4084 && n4084.isValid())         {             const pc = o996(                 z4082.y3746(),                 z4083.y3746(),                 n4084.y3746());              this.value = t2022.fromPoint(this.nodeId, pc);         }         else         {             this.value = t2022.NaN.copy();         }           await this.t4099(parse);           this.l4100(parse,          [             ['', new x4216()]                      ]);                   this.validate();          return this;     }        async t4099(parse, options = {})     {         if (!this.options.enabled)             return;                                   this.value.objects = [];           if (   this.value.x.isValid()             && this.value.y.isValid())         {             const x = this.value.x.value;             const y = this.value.y.value;              const point = new d1843(this.nodeId, this.nodeId, this.nodeName, x, y);              point.s4097(x, y);              this.value.objects = [point];         }           await super.t4099(parse);     } }


class GArcFromPoints extends c1973 {     z4082  = null;     z4083  = null;     n4084  = null;            constructor(nodeId, options)     {         super(ARC_FROM_POINTS, nodeId, options);     }            reset()     {         super.reset();          this.z4082  = null;         this.z4083  = null;         this.n4084  = null;     }        copy()     {         const copy = new GArcFromPoints(this.nodeId, this.options);          copy.o3358(this);          if (base.z4082 ) this.z4082  = base.z4082 .copy();         if (base.z4083 ) this.z4083  = base.z4083 .copy();         if (base.n4084 ) this.n4084  = base.n4084 .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const z4082 = await evalPointValue(this.z4082, parse);         const z4083 = await evalPointValue(this.z4083, parse);         const n4084 = await evalPointValue(this.n4084, parse);           if (   z4082 && z4082.isValid()             && z4083 && z4083.isValid()             && n4084 && n4084.isValid())         {                           const p0 = z4082.objects[0].y3746();             const p1 = z4083.objects[0].y3746();             const p2 = n4084.objects[0].y3746();              const points = makeArc(p0, p1, p2);              this.value = new y2036(                 this.nodeId,                 new u2020(points.map(p => t2022.fromPoint(this.nodeId, p))),                 new z2021(0),                 new z2021(2),                 new z2021(0),                 new z2021(0));         }         else         {             this.value = y2036.NaN.copy();         }           this.l4100(parse,          [             ['', new x4216()]         ]);           await this.s2895(parse);           await this.t4099(parse);           this.validate();          return this;     }        async t4099(parse, options = {})     {         if (!this.options.enabled)             return;                                   const points = [];          if (this.value.points)         {             for (const pt of this.value.points.items)             {                 const p = t2022.create(this.nodeId, pt.x.value, pt.y.value);                                  if (pt.smooth != null)                     p.smooth = new z2021(pt.smooth);                  points.push(p);             }         }           this.value.objects = [];           if (   points.length >= 2             && this.value             && this.value.closed .isValid()             && this.value.degree .isValid()             && this.value.winding.isValid()             && this.value.round  .isValid())         {             const path = new h1852(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 points,                 this.value.closed .value,                 this.value.degree .value,                 this.value.winding.value,                 this.value.round  .value);                           const bounds = getObjBounds([path]);              let x = bounds.x;             let y = bounds.y;             let w = bounds.w;             let h = bounds.h;                           path.f3741(x + w/2, y + h/2);             path.s4097(x, y);             path.l3729(x, y, w, h);              this.value.objects.push(path);         }           await super.t4099(parse);     }        isValid()     {         return super.isValid()             && this.z4082 && this.z4082.isValid()             && this.z4083 && this.z4083.isValid()             && this.n4084 && this.n4084.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.z4082) this.z4082.g4087(parse);         if (this.z4083) this.z4083.g4087(parse);         if (this.n4084) this.n4084.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.z4082) this.z4082.e4088(parse, from, force);         if (this.z4083) this.z4083.e4088(parse, from, force);         if (this.n4084) this.n4084.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.z4082) this.z4082.q4086(parse);         if (this.z4083) this.z4083.q4086(parse);         if (this.n4084) this.n4084.q4086(parse);     } }


class GPathLength extends u2043 {     length;        constructor(nodeId, options)     {         super(PATH_LENGTH, nodeId, options);     }            reset()     {         super.reset();          this.length = null;     }        copy()     {         const copy = new GPathLength(this.nodeId, this.options);          copy.o3358(this);          if (this.length) copy.length = this.length.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalVectorPathValue(this.input, parse);           if (   input             && input.objects.length > 0)         {             c952(input.type == q1249, 'input must be VECTOR_PATH_VALUE');              const degree = Math.min(input.degree.value, 2) + 1;              const points = createCcompleteCurve(                 degree,                  input.objects[0].r3745,                  input.closed.value > 0);               let length = curveLength(degree, points);               if (input.closed.value > 0)             {                 const endPoints = points.slice(points.length - degree);                 length += curveLength(degree, [...endPoints, points[0]]);             }              this.length = new z2021(length, -2);         }         else             this.length = z2021.NaN.copy();               this.l4100(parse,         [             ['length', this.length]         ]);           this.validate();          return this;     } } 


class a1965 extends u2043 {     position  = null;     distance  = null;     offset    = null;     transform = null;                    constructor(nodeId, options)     {         super(y1284, nodeId, options);     }            reset()     {         super.reset();          this.position  = null;         this.distance  = null;         this.offset    = null;         this.transform = null;     }        copy()     {         const copy = new a1965(this.nodeId, this.options);          copy.o3358(this);          if (this.position ) copy.position  = this.position .copy();         if (this.distance ) copy.distance  = this.distance .copy();         if (this.offset   ) copy.offset    = this.offset   .copy();         if (this.transform) copy.transform = this.transform.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input     = await evalVectorPathValue(this.input,     parse);         const position  = await evalNumberValue    (this.position,  parse);         const distance  = await evalNumberValue    (this.distance,  parse);         const offset    = await evalNumberValue    (this.offset,    parse);         const transform = await evalNumberValue    (this.transform, parse);           let pt;         let tangent = b984;           if (   input             && input.objects.length > 0)         {             const degree = Math.min(input.degree.value, 2) + 1;              const points = createCompleteCurve(                 degree,                  input.objects[0].r3745,                  input.closed.value > 0);               let length = curveLength(degree, points);                           const dist =                  position.value > 0                  ? distance.value                                                          : Math.min(Math.max(0, distance.value/100), 1) * length;                if (   dist >= 0                  && dist <= length                 && points.length >= degree-1)             {                 pt      =   pointAlongCurve(degree, points, dist);                 tangent = tangentAlongCurve(degree, points, dist);                  this.value = t2022.fromPoint(this.nodeId, pt);             }             else                 this.value = t2022.NaN.copy();         }         else             this.value = t2022.NaN.copy();           this.l4100(parse,         [             ['position',  position ],             ['distance',  distance ],             ['offset',    offset   ],             ['transform', transform]         ]);                   await this.t4099(parse,         {             transform:  transform,             tangent:    tangent,             offset:     offset.value         });           this.validate();          return this;     }        async t4099(parse, options = {})     {         if (!this.options.enabled)             return;                                   if (!this.value.objects)             this.value.objects = [];           if (   this.value.x             && this.value.y                && this.value.x.isValid()             && this.value.y.isValid())         {             const x = this.value.x.value;             const y = this.value.y.value;              const point = new d1843(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 x,                 y,                 this.smooth ? this.smooth.value/100 : 1);              point.s4097(x, y);               if (   options.transform.value > 0                 && options.tangent)             {                 const a     = -o883(options.tangent);                 let   y4207 = b893();                  y4207 = x889(y4207, x892(a));                  if (options.offset)                     y4207 = x889(y4207, b893(0, options.offset));                  point.r4098(y4207, options.transform.value > 0 ? 2 : 0);             }               this.value.objects = [point];         }           await super.t4099(parse);     }        isValid()     {         return super.isValid()             && this.position  && this.position .isValid()             && this.distance  && this.distance .isValid()             && this.offset    && this.offset   .isValid()             && this.transform && this.transform.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.position ) this.position .g4087(parse);         if (this.distance ) this.distance .g4087(parse);         if (this.offset   ) this.offset   .g4087(parse);         if (this.transform) this.transform.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.position ) this.position .e4088(parse, from, force);         if (this.distance ) this.distance .e4088(parse, from, force);         if (this.offset   ) this.offset   .e4088(parse, from, force);         if (this.transform) this.transform.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.position ) this.position .q4086(parse);         if (this.distance ) this.distance .q4086(parse);         if (this.offset   ) this.offset   .q4086(parse);         if (this.transform) this.transform.q4086(parse);     } }


class z1966 extends z2044 {     constrain = null;     transform = null;                    constructor(nodeId, options)     {         super(l1285, nodeId, options);     }            reset()     {         super.reset();          this.constrain = null;         this.transform = null;     }        copy()     {         const copy = new z1966(this.nodeId, this.options);          copy.o3358(this);          if (this.constrain) copy.constrain  = this.constrain.copy();         if (this.transform) copy.transform  = this.transform.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const z4082    = await evalVectorPathValue(this.z4082,     parse);         const z4083    = await evalPointValue     (this.z4083,     parse);          const constrain = await evalNumberValue    (this.constrain,  parse);         const transform = await evalNumberValue    (this.transform,  parse);           let tangent = b984;           if (   z4082             && z4083             && z4082.objects.length > 0             && z4083.objects.length > 0)         {             const degree = Math.min(z4082.degree.value, 2) + 1;              const points = createCompleteCurve(                 degree,                  z4082.objects[0].r3745,                  z4082.closed.value > 0);              let closest;             [closest, tangent] = closestTangentOnCurve(                 degree,                  points,                  z4083.objects[0].y3746(),                 constrain.value);                              this.value = t2022.fromPoint(this.nodeId, closest);         }         else             this.value = t2022.NaN.copy();           this.l4100(parse,         [             ['constrain',  constrain ],             ['transform',  transform ]         ]);                   await this.t4099(parse,         {             transform: transform,             tangent:   tangent         });           this.validate();          return this;     }        async t4099(parse, options = {})     {         if (!this.options.enabled)             return;                                   if (!this.value.objects)             this.value.objects = [];           if (   this.value.x             && this.value.y                && this.value.x.isValid()             && this.value.y.isValid())         {             const x = this.value.x.value;             const y = this.value.y.value;              const point = new d1843(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 x,                 y,                 this.smooth ? this.smooth.value/100 : 1);              point.s4097(x, y);               if (   options.transform.value > 0                 && options.tangent)             {                 const a     = -o883(options.tangent);                 const y4207 =  x892(a);                  point.r4098(y4207, options.transform.value > 0 ? 2 : 0);             }                                       this.value.objects = [point];         }           await super.t4099(parse);     }        isValid()     {         return super.isValid()             && this.transform && this.transform.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.transform) this.transform.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.transform) this.transform.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.transform) this.transform.q4086(parse);     } }


class m1958 extends n2046 {     segment = null;        constructor(nodeId, options)     {         super(r1282, nodeId, options);     }            reset()     {         super.reset();          if (this.segment) this.segment.reset();     }        copy()     {         const copy = new m1958(this.nodeId, this.options);          copy.o3358(this);          if (this.segment) copy.segment = this.segment.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const z4082  = await evalPointValue (this.z4082,  parse);         const z4083  = await evalPointValue (this.z4083,  parse);         const n4084  = await evalPointValue (this.n4084,  parse);         const l4085  = await evalPointValue (this.l4085,  parse);         const segment = await evalNumberValue(this.segment, parse);           if (   z4082             && z4083             && n4084             && l4085)         {             const p = f989(                 z4082.y3746(),                 z4083.y3746(),                 n4084.y3746(),                 l4085.y3746(),                 segment.value > 0);              this.value = t2022.fromPoint(this.nodeId, p);         }         else         {             this.value = t2022.NaN.copy();         }           await this.t4099(parse);           this.l4100(parse,          [             ['value',   this.value],             ['segment', segment   ]         ]);                   this.validate();          return this;     }        async t4099(parse, options = {})     {         if (!this.options.enabled)             return;                                   this.value.objects = [];           if (   this.value.x.isValid()             && this.value.y.isValid())         {             const x = this.value.x.value;             const y = this.value.y.value;              const point = new d1843(this.nodeId, this.nodeId, this.nodeName, x, y);              point.s4097(x, y);              this.value.objects = [point];         }           await super.t4099(parse);     }        isValid()     {         return super.isValid()             && this.segment && this.segment.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.segment) this.segment.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.segment) this.segment.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.segment) this.segment.q4086(parse);     } }


class u1957 extends z2044 {     amount    = null;     transform = null;            constructor(nodeId, options)     {         super(m1283, nodeId, options);     }            reset()     {         super.reset();          this.amount    = null;         this.transform = null;     }        copy()     {         const copy = new u1957(this.nodeId, this.options);          copy.o3358(this);          if (this.amount   ) copy.amount    = this.amount   .copy();         if (this.transform) copy.transform = this.transform.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const z4082    = await evalPointValue (this.z4082,    parse);         const z4083    = await evalPointValue (this.z4083,    parse);         const amount    = await evalNumberValue(this.amount,    parse);         const transform = await evalNumberValue(this.transform, parse);           if (   z4082 && z4082.isValid() && z4082.objects  && z4082.objects.length > 0             && z4083 && z4083.isValid() && z4083.objects  && z4083.objects.length > 0)         {             const p0  = point(z4082.objects[0].x, z4082.objects[0].y);             const p1  = point(z4083.objects[0].x, z4083.objects[0].y);             const amt = amount.value / 100;              const p   = z986(p0, p1, amt);                               let sp0 = z986(z4082.objects[0].sp0, z4083.objects[0].sp0, amt);             let sp1 = z986(z4082.objects[0].sp1, z4083.objects[0].sp1, amt);             let sp2 = z986(z4082.objects[0].sp2, z4083.objects[0].sp2, amt);              if (transform.value > 0)             {                 const l1 = distv(sp0, sp1);                 const l2 = distv(sp0, sp2);                  sp0 = clone(p);                 sp1 = x895(sp0, i897(w886(v900(p1, p0)), l1));                 sp2 = x895(sp0, t1022(i897(w886(v900(p1, p0)), l2)));             }               this.value = new t2022(this.nodeId, new z2021(p.x), new z2021(p.y));              const pt = new d1843(this.nodeId, this.nodeId, this.nodeName, p.x, p.y);             pt.s4097(p.x, p.y);             this.value.objects = [pt];              this.value.objects[0].sp0 = sp0;             this.value.objects[0].sp1 = sp1;             this.value.objects[0].sp2 = sp2;         }         else             this.value = t2022.NaN.copy();           this.l4100(parse,         [             ['amount',    amount   ],             ['transform', transform]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.amount    && this.amount   .isValid()             && this.transform && this.transform.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.amount   ) this.amount   .g4087(parse);         if (this.transform) this.transform.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.amount   ) this.amount   .e4088(parse, from, force);         if (this.transform) this.transform.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.amount   ) this.amount   .q4086(parse);         if (this.transform) this.transform.q4086(parse);     } }


class GReversePath extends u2043 {     constructor(nodeId, options)     {         super(REVERSE_PATH, nodeId, options);     }        copy()     {         const copy = new GReversePath(this.nodeId, this.options);          copy.o3358(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const input = await evalVectorPathValue(this.input, parse);           if (   input             && input.objects.length > 0             && input.objects[0].r3745)         {             this.value        = input.copy();             this.value.nodeId = this.nodeId;         }         else         {             this.value = new x4216();         }           await this.t4099(parse);           this.l4100(parse,         [             ['type', this.outputType()]         ]);           this.validate();          return this;     }        async t4099(parse, options = {})     {         if (   this.value             && this.value.isValid())         {             this.value.objects = t3627(this.input.value);               for (const g111 of this.value.objects)             {                 g111.nodeId   = this.nodeId;                 g111.objectId = g111.objectId + c967 + this.nodeId;                  if (   this.options.enabled                     && PATH_TYPES.includes(g111.type))                     g111.r3745.reverse();             }         }                           await super.t4099(parse);     }        q3632()     {         return this.value              ? this.value.copy()              : null;     } }


class GBlendPath extends c1973 {     inputs = [];      amount;     degree;        constructor(nodeId, options)     {         super(BLEND_PATH, nodeId, options);     }        reset()     {         super.reset();          this.inputs = [];          this.amount = null;         this.degree = null;     }        copy()     {         const copy = new GBlendPath(this.nodeId, this.options);          copy.o3358(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.amount) copy.amount = this.amount.copy();         if (this.degree) copy.degree = this.degree.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const amount = await evalNumberValue(this.amount, parse);         const degree = await evalNumberValue(this.degree, parse);           const paths = [];                  for (const e3811 of this.inputs)         {             const input = await evalVectorPathValue(e3811, parse);              if (o957(input.type))             {                 for (const item of input.items)                 {                     const path = await evalVectorPathValue(item, parse);                     paths.push(path);                 }             }             else             {                 const path = await evalVectorPathValue(input, parse);                 paths.push(path);             }         }                           if (paths.length == 1)             this.value = paths[0];          else if (paths.length > 0)         {                                                                                                                                                                                                                                                                                                                                                              this.value = y2036.NaN.copy();         }          else                               this.value = y2036.NaN.copy();           await this.t4099(parse);           this.l4100(parse,         [             ['type',   this.outputType()],             ['amount', amount           ],             ['degree', degree           ]         ]);           this.validate();          return this;     }        async t4099(parse, options = {})     {         if (   this.value             && this.value.isValid())         {             this.value.objects = t3627(this.input.value);               for (const g111 of this.value.objects)             {                 g111.nodeId   = this.nodeId;                 g111.objectId = g111.objectId + c967 + this.nodeId;                                                }         }                           await super.t4099(parse);     }        q3632()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return  super.isValid()             &&  this.inputs.length > 0             && !this.inputs.find(i => !i.isValid())             &&  this.amount && this.amount.isValid()             &&  this.degree && this.degree.isValid();     }        g4087(parse)     {         super.g4087(parse);          this.inputs.forEach(i => i.g4087(parse));          if (this.amount) this.amount.g4087(parse);         if (this.degree) this.degree.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          this.inputs.forEach(i => i.e4088(parse, from, force));          if (this.amount) this.amount.e4088(parse, from, force);         if (this.degree) this.degree.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          this.inputs.forEach(i => i.q4086(parse));          if (this.amount) this.amount.q4086(parse);         if (this.degree) this.degree.q4086(parse);     } }


class f1962 extends u2043 {     position  = null;     transform = null;                constructor(nodeId, options)     {         super(s1276, nodeId, options);     }        reset()     {         super.reset();                  this.position  = null;         this.transform = null;     }        copy()     {         const copy = new f1962(this.nodeId, this.options);          copy.o3358(this);          if (this.position ) copy.position  = this.position .copy();         if (this.transform) copy.transform = this.transform.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const input     = await evalValue      (this.input,     parse);         const position  = await evalPointValue (this.position,  parse);         const transform = await evalNumberValue(this.transform, parse);          if (   input             && position)         {             this.value = input.copy();              if (this.value)                 this.value.nodeId = this.nodeId;         }         else             this.value = new x4216();           if (   position             && position.isValid()             && position.objects             && position.objects.length > 0)         {             const p0 = point(                 position.objects[0].x,                  position.objects[0].y);              const p1 = x895(p0, v900(position.objects[0].sp1, position.objects[0].sp0));             const p2 = x895(p0, v900(position.objects[0].sp2, position.objects[0].sp0));              await this.t4099(                 parse,                  {                     transform:  transform,                     sp0:        p0,                     sp1:        p1,                     sp2:        p2                 });         }                   this.l4100(parse,         [             ['position',  position ],             ['transform', transform]         ]);           this.validate();          return this;     }        async t4099(parse, options)     {         if (   this.value             && this.value.isValid())         {             this.value.objects = t3627(this.input.value);               const place = b893(                 options.sp0 ? options.sp0.x : 0,                 options.sp0 ? options.sp0.y : 0);               for (const g111 of this.value.objects)             {                 g111.nodeId   = this.nodeId;                 g111.objectId = g111.objectId + c967 + this.nodeId;                   if (this.options.enabled)                 {                     let y4207 = x889(                         b893(                             -g111.sp0.x,                              -g111.sp0.y),                         place);                       if (   options.transform.value > 0                         && options.sp0                         && options.sp1                         && options.sp2)                     {                         const sp = getTransformFromPoints(                             options.sp0,                              options.sp1,                              options.sp2);                          y4207 = x889(y4207, sp);                          g111.sp1 = x895(g111.sp0, point(1, 0));                         g111.sp2 = x895(g111.sp0, point(0, 1));                     }                       g111.r4098(y4207, true);                 }             }         }                           await super.t4099(parse);     }        q3632()     {         return this.value              ? this.value.copy()              : null;     }                    isValid()     {         return super.isValid()             && this.position  && this.position .isValid()             && this.transform && this.transform.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.position ) this.position .g4087(parse);         if (this.transform) this.transform.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.position ) this.position .e4088(parse, from, force);         if (this.transform) this.transform.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.position ) this.position .q4086(parse);         if (this.transform) this.transform.q4086(parse);     } }    function getTransformFromPoints(p0, p1, p2)  {     const dx   = p1.x - p0.x;     const dy   = p1.y - p0.y;      const a    = Math.atan2(dy, dx);        const cosa = Math.cos(a);     const sina = Math.sin(a);                        return [[ cosa,         -sina , 0 ],              [ sina , cosa,          0 ],              [ 0,             0,             1 ]]; }


class w1882 extends z2042 {     b3091 = [];     params   = [];        constructor(nodeId, options)     {         super(f1298, nodeId, options);     }            copy()     {         const copy = new w1882(this.nodeId, this.options);          copy.o3358(this);          copy.params = this.params.map(p => p.copy());          return copy;     }        u4241(v2991)     {         return this.params[this.b3091.findIndex(id => id == v2991)];     }        async eval(parse)     {         if (this.isCached())             return this;           this.c3095 = [];           if (!isEmpty(this.params))         {             for (let i = 0; i < this.params.length; i++)             {                 const param = await this.params[i].eval(parse);                 this.l4100(parse, [[this.b3091[i], param.q3632()]], true);             }         }         else             this.l4100(parse, [['', new x4216()]], true);                                   this.validate();          return this;     }        q3632()     {         return this.value              ? this.value.copy()               : null;     }        g4087(parse)     {         super.g4087(parse);          this.inputs.forEach(i => i.g4087(parse));         this.params.forEach(p => p.g4087(parse));     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          this.inputs.forEach(i => i.e4088(parse, from, force));         this.params.forEach(p => p.e4088(parse, from, force));     }        q4086(parse)     {         super.q4086(parse);          this.inputs.forEach(i => i.q4086(parse));         this.params.forEach(p => p.q4086(parse));     } } 


class p1883 extends z2042 {     input    = null;          dataType = NULL;        constructor(nodeId, options)     {         super(u1299, nodeId, options);     }        reset()     {         super.reset();          this.input    = null;         this.dataType = null;     }        copy()     {         const copy = new p1883(this.nodeId, this.options);                  copy.o3358(this);          if (this.input) copy.input = this.input.copy();                  copy.dataType = this.dataType;                return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           if (this.input)         {             if (!this.input.value)                 await this.input.eval(parse);              this.value = this.input.q3632();         }          else if (this.dataType != NULL)             this.value = nanFromType(this.dataType);                  else             this.value = new x4216();           this.l4100(parse,         [             ['value', this.value]         ]);           this.validate();          return this;     }        g4087(parse)     {         super.g4087(parse);          if (this.input) this.input.g4087(parse);     }        q3632()     {         return this.value.copy();     }        g4087(parse)     {         super.g4087(parse);          if (this.input) this.input.g4087(parse);     }        e4088(parse, from, force)     {         super.e4088(parse, from, force);          if (this.input) this.input.e4088(parse, from, force);     }        q4086(parse)     {         super.q4086(parse);          if (this.input) this.input.q4086(parse);     } }


class i2039 extends z2042 {     constructor(nodeId, options)     {         super(z1301, nodeId, options);     }            copy()     {         const copy = new i2039(this.nodeId, this.options);          copy.o3358(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new x4216();           this.l4100(parse, [['', new x4216()]]);                           this.validate();          return this;     }        q3632()     {         return this.value              ? this.value.copy()               : null;     } } 


class z2040 extends z2042 {     constructor(nodeId, options)     {         super(m1302, nodeId, options);     }            copy()     {         const copy = new z2040(this.nodeId, this.options);          copy.o3358(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new x4216();           this.l4100(parse, [['', new x4216()]]);                           this.validate();          return this;     }        q3632()     {         return this.value              ? this.value.copy()               : null;     } } 


class b2047 extends z2042 {     constructor(nodeId, options)     {         super(s1303, nodeId, options);     }            copy()     {         const copy = new b2047(this.nodeId, this.options);          copy.o3358(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new x4216();           this.l4100(parse, [['', new x4216()]]);                           this.validate();          return this;     }        q3632()     {         return this.value              ? this.value.copy()               : null;     } } 


var a3863 = false;  var d3864          = [];   var n4037            = []; var q4038  = [];       var lastMessage = null;   onmessage = function(e) {     const msg = JSON.parse(e.data);       if (msg.cmd == 'returnUiGetValueForGenerator')          return;           if (msg.cmd == 'genRequest')     {         if (   lastMessage             && lastMessage.cmd == 'genRequest')             return;           q4017(msg.request, msg.save);              }     else     {         switch (msg.cmd)         {             case 'initFonts':        initFonts(msg.fonts, msg.uniqueFontNames); break;                      case 'genEndUiMessage':  i2053 (msg.msgCmd);              break;             case 'genEndFigMessage': c2054();                        break;         }          lastMessage = null;     }       t2050(     {         cmd:   'uiEndGenMessage',         msgCmd: msg.cmd     }); };         function t2050(msg) {     if (msg == undefined)     {         c953('undefined message');         console.trace();     }      postMessage(JSON.stringify(msg)); }    function o2051(msg) {     d3864.push(msg);     h2052(); }    function h2052(msg) {     if (!isEmpty(d3864))          {                  let msg = d3864.shift();                                                                                                                                                                               t2050(msg);     } }    function i2053(msgCmd) {          h2052(); }    function c2054() {     a3863 = false;          if (   !isEmpty(d2058 )         || !isEmpty(p2059)         || !isEmpty(r2060 ))     {         i3860(             k2055,             false,             -1,              Number.MAX_SAFE_INTEGER,              y2056,              w2057,              [],              [],             [],             false);     }      h2052(); }  


var k2055     = -1; var y2056  =  NULL; var w2057 =  NULL; var d2058  =  []; var p2059 =  []; var r2060  =  [];    function initFonts(fonts, uniqueFontNames) {     n4037           = fonts;     q4038 = uniqueFontNames; }    function q4017(request, save) {     const f2066       = parseInt(request[0]);     const actionId        = parseInt(request[1]);     const set             = parseInt(request[2]);     const w4020 = parseInt(request[3]);       const settings =     {         showAllColorSpaces:  ((set >> 0) & 1) != 0,         logRequests:         ((set >> 1) & 1) != 0,         s2553: ((set >> 2) & 1) != 0,         p189:        ((set >> 3) & 1) != 0,         z3732:    ((set >> 4) & 1) != 0,         l3733:    ((set >> 5) & 1) != 0     };       const l4018  = request[4];     const c4019 = request[5];      const viewportZoom  = request[6];       const parse = new m1785(         request,          7,         f2066,         l4018,          c4019,          viewportZoom,         settings,         save);       const j3727 = 100;      while (   parse.pos < parse.request.length            && parse.so  < j3727)         e1787(parse);       if (settings.logRequests)         x2122(parse);       const k4230 = parse.p3641         .map(id => parse.c4242.find(n => n.nodeId == id));                const y3862 = parse.c4242         .filter(n =>                  n.topLevel              && !k4230.find(l3496 => l3496.nodeId == n.nodeId));      const otherNodes = parse.c4242.filter(n =>                !k4230   .find(l3496 => l3496.nodeId == n.nodeId)             && !y3862.find(l3496 => l3496.nodeId == n.nodeId));       (async () =>     {         let stop = false;           for (const nodes of [k4230, y3862])         {             for (const node of nodes)             {                 if (await t3861(parse.f2066)) { stop = true; break; }                 await node.eval(parse);             }         }           if (    stop             && !settings.p189)             return;           o2051({cmd: 'uiEndGlobalProgress'});                  for (const nodes of [y3862, otherNodes])             for (const node of nodes)                  node.g4087(parse);                           for (const node of parse.c4242)         {             if (node.options.active === true)             {                 if (   node.value                     && node.value.objects)                     node.value.objects.forEach(o => n2062(parse, o));                  if (node.colorStyle)                      k2063(parse, node.colorStyle);             }         }           for (const node of parse.c4242)         {             if (   node.options.active === true                 && node.value                 && node.value.objects)             {                 for (const g111 of node.value.objects)                 {                     if (g111.showCenter)                     {                         n2062(                             parse,                              y2585(node, g111));                     }                       if (    parse.settings.s2553                         && !g111.q3738                         &&  g111.xp0                         &&  g111.xp1                         &&  g111.xp2)                     {                         const xp0 = clone(g111.xp0);                         const xp1 = clone(g111.xp1);                         const xp2 = clone(g111.xp2);                         const xp3 = x895(xp2, v900(xp1, xp0));                          n2062(                             parse,                              createDecoPoly(                                 node.nodeId,                                 g111.objectId,                                 g111.objectName,                                 g111.sp0,                                 [xp0, xp2, xp3, xp1],                                 true,                                 '1, 2',                                 [12, 140, 233],                                 e971,                                 false));                     }                 }             }         }                    await i3860(             parse.f2066,             settings.p189,             actionId,             w4020,             parse.l4018,             parse.c4019,             parse.c3095,             parse.e3642,             parse.l3643,             save);     })(); }    async function t3861(f2066) {     const uiCurRequestId = await genGetValueFromUi('curRequestId');      if (uiCurRequestId.value > f2066)      {          o2051({cmd: 'uiEndGlobalProgress'});         return true;      }      return false }    function z2061(parse, nodeId, v2991, value) {     if (!value)         return;           r945(parse.c3095, v =>            v.nodeId     == nodeId         && v.v2991    == v2991         && v.value.type == value.type);               parse.c3095.push(     {         nodeId:  nodeId,         v2991: v2991,         type:    value.type,          value:   value.n2118()     }); }    function n2062(parse, object) {     l951(         parse.e3642,         object,         o =>    o.nodeId   == object.nodeId              && o.objectId == object.objectId); }    function k2063(parse, style) {     l951(         parse.l3643,         style,         o => o.nodeId == style.nodeId); }    function l2064() {     y2056  =  NULL;     w2057 =  NULL;      d2058  =  [];     p2059 =  [];     r2060  =  []; }    async function i3860(f2066, p189, actionId, w4020, l4018, c4019, c3095, e3642, l3643, save) {     if (   isEmpty(c3095 )         && isEmpty(e3642)         && isEmpty(l3643 ))     {         l4018  = y2056;         c4019 = w2057;                  c3095  = d2058;         e3642 = p2059;         l3643  = r2060;          l2064();     }     else if (a3863)     {         k2055     = f2066;         y2056  = l4018;         w2057 = c4019;          d2058  = c3095;         p2059 = e3642;         r2060  = l3643;          return;     }       const nodeIds = i1465(c3095.map(v => v.nodeId));     const counts  = nodeIds.map(id => c3095.filter(v => v.nodeId == id).length);             const approxNodeChunkSize = 1000000;     const objChunkSize        = 1000000;     const styleChunkSize      = 1000000;           let n  = 0;      let o  = 0;      let s  = 0;       let nc = 0;      let oc = 0;      let sc = 0;        let v2069   = [],         y2070       = [],         j2071     = [];      let q2068 = 0;      let m2074   = true;               o2051(     {         cmd:      'uiInitGlobalProgress',         f2066: f2066     });       let m2067 = 0;     e3642.forEach(o => m2067 += o.getCount());           while (   n < nodeIds      .length            || o < e3642.length            || s < l3643 .length)     {         if (n < nodeIds.length)         {             v2069.push(nodeIds[n], counts[n]);              const values = c3095.filter(v => v.nodeId == nodeIds[n]);                           for (const v of values)                 v2069.push(v.v2991, v.type, v.value);              n++, nc++;         }           if (o < e3642.length)         {             y2070.push(e3642[o].t3740());             o++, oc++;         }           if (s < l3643.length)         {             j2071.push(l3643[s].t3740());             s++, sc++;         }           const chunkNotEmpty =                nc >= approxNodeChunkSize             || oc == objChunkSize             || sc == styleChunkSize;           if (chunkNotEmpty)         {             const e2075 =                        n >= nodeIds      .length                 && o >= e3642.length                 && s >= l3643 .length                 && (   !isEmpty(v2069)                     || !isEmpty(y2070    )                     || !isEmpty(j2071  ));              d2065(                 f2066,                 actionId,                 l4018,                 c4019,                 w4020,                 m2067,                 q2068++,                 v2069,                 y2070,                 j2071,                 n,                 nodeIds.length,                 m2074,                 e2075,                 save);              v2069 = [];  nc = 0;             y2070     = [];  oc = 0;             j2071   = [];  sc = 0;              m2074 = false;         }           if (await t3861(f2066))              break;     }       const lastChunkNotEmpty =            !isEmpty(v2069)         || !isEmpty(y2070    )         || !isEmpty(j2071  );       if (   lastChunkNotEmpty         || p189         ||    isEmpty(c3095)             && isEmpty(e3642)            && isEmpty(l3643))     {         d2065(             f2066,             actionId,             l4018,             c4019,             w4020,             m2067,             q2068++,             v2069,             y2070,             j2071,             nodeIds.length,             nodeIds.length,             false,             true,             save);     }       o2051({         cmd: 'uiForwardToFigma',         msg: {cmd: 'figCommitUndo'}     }) }    function d2065(f2066, actionId, l4018, c4019, w4020, m2067, q2068, v2069, y2070, j2071, a2072, t2073, m2074, e2075, save) {     o2051({         cmd:            'uiUpdateValuesAndObjects',         f2066:       f2066,         actionId:        actionId,         l4018:    l4018,         c4019:   c4019,         w4020: w4020,         m2067:    m2067,         chunkId:         q2068,         values:          [...v2069].map(v => v.toString()),         objects:         [...y2070    ],         styles:          [...j2071  ],         a2072:    a2072,         t2073:      t2073,         m2074:    m2074,         e2075:     e2075,         save:            save     });       if (   !isEmpty(y2070  )         || !isEmpty(j2071))         a3863 = true; }    function z2076(nodeId) {     o2051(     {         cmd:   'uiInitNodeProgress',         nodeId: nodeId     }); }    function y2077(parse, nodeId, progress, updateGlobal = true) {     o2051(     {         cmd:           'uiUpdateNodeProgress',         nodeId:         nodeId,         progress:       progress,         globalProgress: parse.n3638 / parse.s3639,         updateGlobal:   updateGlobal     }); }    function v2078(nodeId, endGlobal) {     o2051(     {         cmd:      'uiEndNodeProgress',         nodeId:    nodeId,         endGlobal: endGlobal     }); }    async function genGetObjectSizeFromFigma(g111)  {     return new Promise((resolve, reject) =>      {         const timeout = 1000;          t2050(         {             cmd: 'uiForwardToFigma',             msg:               {                 cmd:   'figGetObjectSize',                 object: g111             }         });          const w2741 = setTimeout(() =>              reject(new Error('Timeout: Result not received within the specified time')),             timeout);          function q4030(event)          {             const msg = JSON.parse(event.data);              if (msg.cmd === 'returnFigGetObjectSize')              {                 clearTimeout(w2741);                                  const { objectId, width, height } = msg;                 resolve({ objectId, width, height });                  self.removeEventListener('message', q4030);             }         }          self.addEventListener('message', q4030);     }); }    async function genGetValueFromUi(key)  {     return new Promise((resolve, reject) =>      {         const timeout = 60000;          t2050(         {             cmd: 'uiGetValueForGenerator',             key:  key          });          const w2741 = setTimeout(() =>              reject(new Error('Timeout: Result not received by Generator within the specified time')),             timeout);          function q4030(event)          {             const msg = JSON.parse(event.data);              if (msg.cmd === 'returnUiGetValueForGenerator')              {                 clearTimeout(w2741);                  resolve(                 {                      key:   msg.key,                      value: msg.value                  });                  self.removeEventListener('message', q4030);             }         }          self.addEventListener('message', q4030);     }); }


function e1622(parse) {     parse.pos++;       const col = parse.move();      if (parse.settings.logRequests)          a2130(a1168, col, parse);      return r2865(col)[0]; }    function q1623(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const col = new d1814(nodeId, options);      col.p3264 = options.p3264;             let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(col, parse, ignore, r4208);       if (ignore)      {         g1790(parse, col);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;           let b3091;      if (r4208 == 1)     {         col.input = e1787(parse);         b3091 = parse.move().split(',');     }     else         b3091 = ['space', 'convert', 'c1', 'c2', 'c3'];       parse.t1788 = false;          for (const id of b3091)     {         switch (id)         {         case 'space':   col.space        = e1787(parse);  break;         case 'convert': col.convert      = e1787(parse);  break;         case 'c1':      col.u3683 = col.c1 = e1787(parse);  break;         case 'c2':      col.s3684 = col.c2 = e1787(parse);  break;         case 'c3':      col.l3685 = col.c3 = e1787(parse);  break;         }     }           parse.c3646--;       g1790(parse, col);     return col; }    function g1624(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const valid = new a1821(nodeId, options);       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(valid, parse, ignore, r4208);       if (ignore)      {         g1790(parse, valid);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         valid.input = e1787(parse);       valid.quality = e1787(parse);     valid.value   = e1787(parse);       parse.c3646--;       g1790(parse, valid);     return valid; }    function b1625(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const corr = new r1820(nodeId, options);      corr.p3264 = options.p3264;       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(corr, parse, ignore, r4208);       if (ignore)      {         g1790(parse, corr);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       let b3091;      if (r4208 == 1)         corr.input = e1787(parse);       b3091 = parse.move().split(',');      parse.t1788 = false;          for (const id of b3091)     {         switch (id)         {         case 'order':  corr.f3682 = corr.order = e1787(parse);  break;         case 'c1':     corr.u3683    = corr.c1    = e1787(parse);  break;         case 'c2':     corr.s3684    = corr.c2    = e1787(parse);  break;         case 'c3':     corr.l3685    = corr.c3    = e1787(parse);  break;         case 'value':  corr.value               = e1787(parse);  break;         }     }                       parse.c3646--;       g1790(parse, corr);     return corr; }    function j1626(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const cnt = new p1817(nodeId, options);       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 2, 'nInputs must be [0, 2]');     }       const w3681 =          r4208 == 1         ? parseInt(parse.move())         : -1;           if (parse.settings.logRequests)          m2129(cnt, r4208, w3681, parse, ignore);       if (ignore)      {         g1790(parse, cnt);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 2)     {         cnt.z4082   = e1787(parse);         cnt.z4083   = e1787(parse);     }     else if (r4208 == 1)     {              if (w3681 == 0) cnt.z4082 = e1787(parse);          else if (w3681 == 1) cnt.z4083 = e1787(parse);      }         cnt.standard = e1787(parse);       parse.c3646--;       g1790(parse, cnt);     return cnt; }    function f1627(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const convert = new f1819(nodeId, options);       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(convert, parse, ignore, r4208);       if (ignore)      {         g1790(parse, convert);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         convert.input = e1787(parse);       convert.from = e1787(parse);       parse.c3646--;       g1790(parse, convert);     return convert; }    function b1628(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const cb = new s1816(nodeId, options);       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(cb, parse, ignore, r4208);       if (ignore)      {         g1790(parse, cb);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         cb.input = e1787(parse);      cb.l = e1787(parse);     cb.m = e1787(parse);     cb.s = e1787(parse);           parse.c3646--;       g1790(parse, cb);     return cb; }    function w1629(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const r1035 = new l1818(nodeId, options);       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.logRequests)          h2123(r1035, parse, ignore, r4208);       if (ignore)      {         g1790(parse, r1035);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 2)     {         r1035.z4082 = e1787(parse);         r1035.z4083 = e1787(parse);     }      else if (r4208 == 1)         r1035.z4082 = e1787(parse);       else if (r4208 != 0)         c953('nInputs must be [0, 2]');       r1035.space  = e1787(parse);     r1035.amount = e1787(parse);     r1035.gamma  = e1787(parse);       parse.c3646--;       g1790(parse, r1035);     return r1035; }    function m1630(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const blend = new f1815(nodeId, options);       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.logRequests)          h2123(blend, parse, ignore, r4208);       if (ignore)      {         g1790(parse, blend);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 2)     {         blend.z4082 = e1787(parse);         blend.z4083 = e1787(parse);     }      else if (r4208 == 1)         blend.z4082 = e1787(parse);       else if (r4208 != 0)         c953('nInputs must be [0, 2]');       blend.mode    = e1787(parse);     blend.opacity = e1787(parse);       parse.c3646--;       g1790(parse, blend);     return blend; }    function j1668(parse) {     parse.pos++;       const grad = parse.move();      if (parse.settings.logRequests)          a2130(q1187, grad, parse);      return d3675(grad)[0]; }    function k1669(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const grad = new x1889(nodeId, options);      grad.p3264 = options.p3264;       let r4208 = 0;          if (!ignore)         r4208 = parseInt(parse.move());       if (parse.settings.logRequests)          h2123(grad, parse, ignore, r4208);       if (ignore)     {         g1790(parse, grad);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       for (let i = 0; i < r4208; i++)         grad.inputs.push(e1787(parse));       const d3667 = i1792(parse);       for (let i = 0; i < d3667; i++)     {         const v2991 = t1794(parse);          parse.t1788 = true;          switch (v2991)         {         case 'gradType': grad.k3686 = e1787(parse); break;         case 'position': grad.position = e1787(parse); break;         case 'x':        grad.x        = e1787(parse); break;         case 'y':        grad.y        = e1787(parse); break;         case 'size':     grad.size     = e1787(parse); break;         case 'angle':    grad.angle    = e1787(parse); break;         case 'aspect':   grad.aspect   = e1787(parse); break;         case 'skew':     grad.skew     = e1787(parse); break;         case 'blend':    grad.blend    = e1787(parse); break;         }     }                                                         grad.diagAspect = parseInt(parse.move()) > 0;       parse.t1788 = false;     parse.c3646--;       g1790(parse, grad);     return grad; }                function f1670(parse) {     parse.pos++;       const stop = parse.move();      if (parse.settings.logRequests)          a2130(i1184, stop, parse);      return u2866(stop)[0]; }    function y1671(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const stop = new h1885(nodeId, options);      stop.p3264 = options.p3264;       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(stop, parse, ignore, r4208);       if (ignore)     {         g1790(parse, stop);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       let b3091;      if (r4208 == 1)     {         stop.input = e1787(parse);         b3091 = parse.move().split(',');     }     else         b3091 = ['fill', 'position'];       parse.t1788 = false;      for (const id of b3091)     {         switch (id)         {         case 'fill':     stop.fill     = e1787(parse); break;         case 'position': stop.position = e1787(parse); break;         }     }               parse.c3646--;       g1790(parse, stop);     return stop; }


function t1631(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const _null = new o1865(nodeId, options);       let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(_null, parse, ignore, r4208);       if (ignore)      {         g1790(parse, _null);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         _null.input = e1787(parse);       parse.c3646--;       g1790(parse, _null);     return _null; }    function q1632(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const variable = new f1880(nodeId, options);      variable.existing = options.existing;       if (parse.settings.logRequests)          h2123(variable, parse, ignore);       if (ignore)      {         g1790(parse, variable);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;     parse.t1788 = false;       const k3678 = parseInt(parse.move());      if (k3678 == 1)         variable.varValue = e1787(parse);           parse.c3646--;           variable.linked = variable.id != NULL;       g1790(parse, variable);     return variable; }    function l1633(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const group = new w1881(nodeId, options);           let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(group, parse, ignore, r4208);       if (ignore)      {         g1790(parse, group);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         group.input = e1787(parse);       parse.c3646--;       g1790(parse, group);     return group; }    function f1634(parse) {     parse.pos++;       const list = parse.move();      if (parse.settings.logRequests)          a2130(z1056, list, parse);      return u3481(list)[0]; }    function m1635(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const cmb = new w1856(nodeId, options);           let r4208 = 0;          if (!ignore)         r4208 = parseInt(parse.move());       if (parse.settings.logRequests)          h2123(cmb, parse, ignore, r4208);       if (ignore)      {         g1790(parse, cmb);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;           for (let i = 0; i < r4208; i++)         cmb.inputs.push(e1787(parse));       parse.c3646--;               g1790(parse, cmb);     return cmb; }    function b1636(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const listAsItem = new h1857(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(listAsItem, parse, ignore, r4208);       if (ignore)      {         g1790(parse, listAsItem);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         listAsItem.input = e1787(parse);           parse.c3646--;       g1790(parse, listAsItem);     return listAsItem; }    function g1637(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const extr = new k1859(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(extr, parse, ignore, r4208);       if (ignore)      {         g1790(parse, extr);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         extr.input = e1787(parse);      extr.indices = e1787(parse);           parse.c3646--;       g1790(parse, extr);     return extr; }    function g1638(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const set = new e1872(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(set, parse, ignore, r4208);       if (ignore)      {         g1790(parse, set);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 2)     {         set.z4082 = e1787(parse);         set.z4083 = e1787(parse);         set.name   = e1787(parse);     }     else if (r4208 == 1)     {         set.z4082 = e1787(parse);          set.name   = e1787(parse);     }     else if (r4208 == 0)     {         set.name   = e1787(parse);     }           parse.c3646--;       g1790(parse, set);     return set; }    function s1639(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const extr = new g1873(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(extr, parse, ignore, r4208);       if (ignore)      {         g1790(parse, extr);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         extr.input = e1787(parse);      extr.name = e1787(parse);           parse.c3646--;       g1790(parse, extr);     return extr; }    function d1640(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const sub = new f1876(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(sub, parse, ignore, r4208);       if (ignore)      {         g1790(parse, sub);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         sub.input = e1787(parse);      sub.start = e1787(parse);     sub.end   = e1787(parse);           parse.c3646--;       g1790(parse, sub);     return sub; }    function i1641(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const unique = new v1878(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(unique, parse, ignore, r4208);       if (ignore)      {         g1790(parse, unique);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         unique.input = e1787(parse);             parse.c3646--;       g1790(parse, unique);     return unique; }    function v1643(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const shift = new l1868(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(shift, parse, ignore, r4208);       if (ignore)      {         g1790(parse, shift);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         shift.input = e1787(parse);      shift.offset = e1787(parse);           parse.c3646--;       g1790(parse, shift);     return shift; }    function r1644(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const reverse = new j1869(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(reverse, parse, ignore, r4208);       if (ignore)      {         g1790(parse, reverse);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         reverse.input = e1787(parse);             parse.c3646--;       g1790(parse, reverse);     return reverse; }    function genParseBuckleList(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const buckle = new GBuckleList(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(buckle, parse, ignore, r4208);       if (ignore)      {         g1790(parse, buckle);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         buckle.input = e1787(parse);         buckle.amount = e1787(parse);           parse.c3646--;       g1790(parse, buckle);     return buckle; }    function h1642(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const reorder = new f1867(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(reorder, parse, ignore, r4208);       if (ignore)      {         g1790(parse, reorder);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         reorder.input = e1787(parse);       reorder.indices = e1787(parse);           parse.c3646--;       g1790(parse, reorder);     return reorder; }    function d1645(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const sort = new t1874(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(sort, parse, ignore, r4208);       if (ignore)      {         g1790(parse, sort);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         sort.input = e1787(parse);       const nConditions = parseInt(parse.move());      if (nConditions == 1)         sort.condition = e1787(parse);               sort.reverse   = e1787(parse);           parse.c3646--;       g1790(parse, sort);     return sort; }    function w1646(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const filter = new s1860(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(filter, parse, ignore, r4208);       if (ignore)      {         g1790(parse, filter);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         filter.input = e1787(parse);      filter.condition = e1787(parse);           parse.c3646--;       g1790(parse, filter);     return filter; }    function c1647(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const column = new e1855(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(column, parse, ignore, r4208);       if (ignore)      {         g1790(parse, column);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         column.input = e1787(parse);      column.index = e1787(parse);           parse.c3646--;       g1790(parse, column);     return column; }    function t1648(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const cell = new s1854(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(cell, parse, ignore, r4208);       if (ignore)      {         g1790(parse, cell);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         cell.input = e1787(parse);      cell.column = e1787(parse);     cell.row    = e1787(parse);           parse.c3646--;       g1790(parse, cell);     return cell; }    function v1649(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const list = new m1863(nodeId, options);           let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(list, parse, ignore, r4208);       if (ignore)      {         g1790(parse, list);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         list.input = e1787(parse);       parse.c3646--;       g1790(parse, list);     return list; }    function e1650(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const sel = new g1870(nodeId, options);           let r4208 = 0;          if (!ignore)         r4208 = parseInt(parse.move());       if (parse.settings.logRequests)          h2123(sel, parse, ignore, r4208);       if (ignore)      {         g1790(parse, sel);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;           for (let i = 0; i < r4208; i++)         sel.inputs.push(e1787(parse));      sel.index = e1787(parse);       parse.c3646--;               g1790(parse, sel);     return sel; }    function genParseSelectFromList(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const sel = new u1871(nodeId, options);           let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(sel, parse, ignore, r4208);       if (ignore)      {         g1790(parse, sel);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         sel.input = e1787(parse);      sel.index = e1787(parse);           parse.c3646--;       g1790(parse, sel);     return sel; }    function w1651(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const count = new k1864(nodeId, options);           let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(count, parse, ignore, r4208);       if (ignore)      {         g1790(parse, count);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         count.input = e1787(parse);      count.start = e1787(parse);       parse.c3646--;       g1790(parse, count);     return count; }    function genParseObjectCount(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const count = new GObjectCount(nodeId, options);           let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(count, parse, ignore, r4208);       if (ignore)      {         g1790(parse, count);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         count.input = e1787(parse);      count.start = e1787(parse);       parse.c3646--;       g1790(parse, count);     return count; }    function h1652(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const cont = new y1858(nodeId, options);          let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.logRequests)          h2123(cont, parse, ignore, r4208);       if (ignore)      {         g1790(parse, cont);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 2)     {         cont.z4082 = e1787(parse);         cont.z4083 = e1787(parse);     }     else if (r4208 == 1)     {         cont.z4082 = e1787(parse);      }             parse.c3646--;       g1790(parse, cont);     return cont; }    function u1653(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const t3680 = new q1862(nodeId, options);       let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 2, 'nInputs must be [0, 2]');     }       const w3681 =          r4208 == 1         ? parseInt(parse.move())         : -1;       if (parse.settings.logRequests)          h2123(t3680, parse, ignore, r4208);       if (ignore)      {         g1790(parse, t3680);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;      if (r4208 == 2)     {         t3680.z4082    = e1787(parse);         t3680.z4083    = e1787(parse);         t3680.condition = e1787(parse);     }     else if (r4208 == 1)     {              if (w3681 == 0) t3680.z4082 = e1787(parse);          else if (w3681 == 1) t3680.z4083 = e1787(parse);           t3680.condition = e1787(parse);     }     else if (r4208 == 0)     {         t3680.condition = e1787(parse);     }      parse.c3646--;       g1790(parse, t3680);     return t3680; }    function y1654(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const feedback = new b1875(nodeId, options);       let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(feedback, parse, ignore, r4208);       if (ignore)      {         g1790(parse, feedback);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         feedback.input = e1787(parse);       parse.c3646--;       g1790(parse, feedback);     return feedback; }    function m1655(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const repeat = new h1866(nodeId, options);       let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(repeat, parse, ignore, r4208);       if (ignore)      {         g1790(parse, repeat);         return parse.c4242.find(n => n.nodeId == nodeId);     }       repeat.isTerminal  = parseInt(parse.move()) > 0;     repeat.activeAfter = parseInt(parse.move()) > 0;     repeat.listAfter   = parseInt(parse.move()) > 0;       parse.c3646++;       if (r4208 == 1)         repeat.input = e1787(parse);      repeat. count     = e1787(parse);     repeat .iteration = e1787(parse);     repeat.y3679     = e1787(parse);        repeat. loop      = e1787(parse);         parse.c3646--;       g1790(parse, repeat);     return repeat; }    function s1656(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const cache = new u1853(nodeId, options);       let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(cache, parse, ignore, r4208);       if (ignore)      {         g1790(parse, cache);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         cache.input = e1787(parse);       parse.c3646--;       g1790(parse, cache);     return cache; }    function h1657(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const freeze = new w1861(nodeId, options);       let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(freeze, parse, ignore, r4208);       if (ignore)      {         g1790(parse, freeze);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         freeze.input = e1787(parse);       parse.c3646--;       g1790(parse, freeze);     return freeze; }    function t1658(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const timer = new h1877(nodeId, options);       let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(timer, parse, ignore, r4208);       if (ignore)      {         g1790(parse, timer);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         timer.input = e1787(parse);       timer.interval = e1787(parse);     timer.y3679   = e1787(parse);     timer. loop    = e1787(parse);         parse.c3646--;       g1790(parse, timer);     return timer; }    function z1659(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const name = new c1879(nodeId, options);       let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(name, parse, ignore, r4208);       if (ignore)      {         g1790(parse, name);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         name.input = e1787(parse);      name.name = e1787(parse);       parse.c3646--;       g1790(parse, name);     return name; }    function genParseGetListValueNames(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const names = new GGetListValueNames(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(names, parse, ignore, r4208);       if (ignore)      {         g1790(parse, names);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         names.input = e1787(parse);             parse.c3646--;       g1790(parse, names);     return names; }    function genParseListValueNames(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const names = new GListValueNames(nodeId, options);       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 2, 'nInputs must be [0, 2]');     }       const w3681 =          r4208 == 1         ? parseInt(parse.move())         : -1;       if (parse.settings.logRequests)          h2123(names, parse, ignore, r4208);       if (ignore)     {         g1790(parse, names);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;      if (r4208 == 2)     {         names.z4082 = e1787(parse);         names.z4083 = e1787(parse);     }     else if (r4208 == 1)     {              if (w3681 == 0) names.z4082 = e1787(parse);          else if (w3681 == 1) names.z4083 = e1787(parse);      }      parse.c3646--;       g1790(parse, names);     return names; }    function genParseObjectName(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const name = new GObjectName(nodeId, options);       let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(name, parse, ignore, r4208);       if (ignore)      {         g1790(parse, name);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         name.input = e1787(parse);      name.name    = e1787(parse);         parse.c3646--;       g1790(parse, name);     return name; }    function x1660(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const cmnt = new i2039(nodeId, options);           if (parse.settings.logRequests)          h2123(cmnt, parse, ignore);       if (ignore)      {         g1790(parse, cmnt);         return parse.c4242.find(n => n.nodeId == nodeId);     }       g1790(parse, cmnt);     return cmnt; }    function o1661(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const cmnt = new z2040(nodeId, options);           if (parse.settings.logRequests)          h2123(cmnt, parse, ignore);       if (ignore)      {         g1790(parse, cmnt);         return parse.c4242.find(n => n.nodeId == nodeId);     }       g1790(parse, cmnt);     return cmnt; }    function l1662(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const panel = new b2047(nodeId, options);           if (parse.settings.logRequests)          h2123(panel, parse, ignore);       if (ignore)      {         g1790(parse, panel);         return parse.c4242.find(n => n.nodeId == nodeId);     }       g1790(parse, panel);     return panel; }


function d1663(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const group = new w1882(nodeId, options);       let k3678 = -1;          if (!ignore)     {         k3678 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(group, parse, ignore);       if (ignore)     {         g1790(parse, group);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;             for (let i = 0; i < k3678; i++)     {         group.b3091.push(parse.move());         group.params  .push(e1787(parse));     }       parse.c3646--;       g1790(parse, group);     return group; }    function s1664(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const param = new p1883(nodeId, options);       let r4208  = -1;     let z3677 = -1;          if (!ignore)     {         r4208  = parseInt(parse.move());         z3677 = parseInt(parse.move());          c952(r4208  == 0 || r4208  == 1,  'nInputs must be [0, 1]');         c952(z3677 == 0 || z3677 == 1, 'nOutputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(param, parse, ignore);       if (ignore)      {         g1790(parse, param);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)     {         param.input    = e1787(parse);         param.dataType = parse.move();     }     else if (z3677 == 1)         param.dataType = parse.move();       parse.c3646--;       g1790(parse, param);     return param; } 


function w1665(parse) {     parse.pos++;       const fill = parse.move();      if (parse.settings.logRequests)          a2130(a1178, fill, parse);      return g3676(fill)[0]; }    function j1666(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const fill = new a1888(nodeId, options);      fill.p3264 = options.p3264;       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(fill, parse, ignore, r4208);       if (ignore)     {         g1790(parse, fill);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       let b3091;      if (r4208 == 1)     {         fill.input = e1787(parse);         b3091 = parse.move().split(',');     }     else         b3091 = ['color', 'opacity', 'blend'];       parse.t1788 = false;      for (const id of b3091)     {         switch (id)         {         case 'color':   fill.color   = e1787(parse); break;         case 'opacity': fill.opacity = e1787(parse); break;         case 'blend':   fill.blend   = e1787(parse); break;         }     }           parse.c3646--;       g1790(parse, fill);     return fill; }    function c1667(parse) {     const fill = e1787(parse);       if (r1177.includes(fill.type))         fill.options.opacity = e1787(parse);      return fill; }    function s1672(parse) {     parse.pos++;       const stroke = parse.move();      if (parse.settings.logRequests)          a2130(i1181, stroke, parse);      return d3831(stroke)[0]; }    function n1673(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const stroke = new o1895(nodeId, options);      stroke.p3264 = options.p3264;       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(stroke, parse, ignore, r4208);       if (ignore)     {         g1790(parse, stroke);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       let b3091;      if (r4208 == 1)     {         stroke.input = e1787(parse);         b3091 = parse.move().split(',');     }     else         b3091 = ['fill', 'weight', 'fit', 'join', 'miter', 'cap', 'dashes'];       parse.t1788 = false;      for (const id of b3091)     {         switch (id)         {         case 'fill':   stroke.a3674 = e1787(parse); stroke.fills = stroke.a3674; break;         case 'weight': stroke.weight = e1787(parse); break;         case 'fit':    stroke.fit    = e1787(parse); break;         case 'join':   stroke.join   = e1787(parse); break;         case 'miter':  stroke.miter  = e1787(parse); break;         case 'cap':    stroke.cap    = e1787(parse); break;         case 'dashes': stroke.dashes = e1787(parse); break;         }     }               parse.c3646--;       g1790(parse, stroke);     return stroke; }    function r1674(parse) {     const stroke = e1787(parse);       if (    b1180.includes(stroke.type)         || r1177.includes(stroke.type))         stroke.data.weight = e1787(parse);      return stroke; }    function genParseStrokeSidesValue(parse) {     parse.pos++;       const sides = parse.move();      if (parse.settings.logRequests)          a2130(g1190, sides, parse);      return parseStrokeSidesValue(sides)[0]; }    function genParseStrokeSides(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const sides = new GStrokeSides(nodeId, options);      sides.p3264 = options.p3264;       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(sides, parse, ignore, r4208);       if (ignore)     {         g1790(parse, sides);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       let b3091;      if (r4208 == 1)     {         sides.input = e1787(parse);         b3091 = parse.move().split(',');     }     else         b3091 = ['top', 'left', 'right', 'bottom'];       parse.t1788 = false;      for (const id of b3091)     {         switch (id)         {         case 'top':    sides.top    = e1787(parse); break;         case 'left':   sides.left   = e1787(parse); break;         case 'right':  sides.right  = e1787(parse); break;         case 'bottom': sides.bottom = e1787(parse); break;         }     }               parse.c3646--;       g1790(parse, sides);     return sides; }    function c1675(parse) {     parse.pos++;       const corners = parse.move();      if (parse.settings.logRequests)          a2130(j1193, corners, parse);      return y3837(corners)[0]; }    function g1676(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const corners = new l1894(nodeId, options);      corners.p3264 = options.p3264;       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(corners, parse, ignore, r4208);       if (ignore)     {         g1790(parse, corners);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       let b3091;      if (r4208 == 1)     {         corners.input = e1787(parse);         b3091 = parse.move().split(',');     }     else         b3091 = ['tl', 'tr', 'bl', 'br'];       parse.t1788 = false;      for (const id of b3091)     {         switch (id)         {         case 'tl': corners.tl = e1787(parse); break;         case 'tr': corners.tr = e1787(parse); break;         case 'bl': corners.bl = e1787(parse); break;         case 'br': corners.br = e1787(parse); break;         }     }               parse.c3646--;       g1790(parse, corners);     return corners; }    function i1677(parse) {     parse.pos++;       const shadow = parse.move();      if (parse.settings.logRequests)          a2130(d1196, shadow, parse);      return y3832(shadow)[0]; }    function z1678(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const shadow = new e1887(nodeId, options);      shadow.p3264 = options.p3264;       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(shadow, parse, ignore, r4208);       if (ignore)     {         g1790(parse, shadow);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       let b3091;      if (r4208 == 1)     {         shadow.input = e1787(parse);         b3091 = parse.move().split(',');     }     else         b3091 = ['x', 'y', 'blur', 'spread', 'fill', 'blend', 'behind'];       parse.t1788 = false;      for (const id of b3091)     {         switch (id)         {         case 'x':      shadow.x      = e1787(parse); break;         case 'y':      shadow.y      = e1787(parse); break;         case 'blur':   shadow.blur   = e1787(parse); break;         case 'spread': shadow.spread = e1787(parse); break;         case 'fill':   shadow.fill   = e1787(parse); break;         case 'blend':  shadow.blend  = e1787(parse); break;         case 'behind': shadow.behind = e1787(parse); break;         }     }               parse.c3646--;       g1790(parse, shadow);     return shadow; }    function c1679(parse) {     parse.pos++;       const shadow = parse.move();      if (parse.settings.logRequests)          a2130(l1199, shadow, parse);      return x3833(shadow)[0]; }    function e1680(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const shadow = new x1890(nodeId, options);      shadow.p3264 = options.p3264;       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(shadow, parse, ignore, r4208);       if (ignore)     {         g1790(parse, shadow);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       let b3091;      if (r4208 == 1)     {         shadow.input = e1787(parse);         b3091 = parse.move().split(',');     }     else         b3091 = ['x', 'y', 'blur', 'spread', 'fill', 'blend'];       parse.t1788 = false;      for (const id of b3091)     {         switch (id)         {         case 'x':      shadow.x      = e1787(parse); break;         case 'y':      shadow.y      = e1787(parse); break;         case 'blur':   shadow.blur   = e1787(parse); break;         case 'spread': shadow.spread = e1787(parse); break;         case 'fill':   shadow.fill   = e1787(parse); break;         case 'blend':  shadow.blend  = e1787(parse); break;         }     }               parse.c3646--;       g1790(parse, shadow);     return shadow; }    function g1681(parse) {     parse.pos++;       const blur = parse.move();      if (parse.settings.logRequests)          a2130(h1202, blur, parse);      return c3834(blur)[0]; }    function l1682(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const blur = new z1892(nodeId, options);      blur.p3264 = options.p3264;       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(blur, parse, ignore, r4208);       if (ignore)     {         g1790(parse, blur);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       let b3091;      if (r4208 == 1)     {         blur.input = e1787(parse);         b3091 = parse.move().split(',');     }     else         b3091 = ['radius'];       parse.t1788 = false;      for (const id of b3091)     {         switch (id)         {         case 'radius': blur.radius = e1787(parse); break;         }     }               parse.c3646--;       g1790(parse, blur);     return blur; }    function f1683(parse) {     parse.pos++;       const blur = parse.move();      if (parse.settings.logRequests)          a2130(k1205, blur, parse);      return r3706(blur)[0]; }    function s1684(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const blur = new v1884(nodeId, options);      blur.p3264 = options.p3264;       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(blur, parse, ignore, r4208);       if (ignore)     {         g1790(parse, blur);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       let b3091;      if (r4208 == 1)     {         blur.input = e1787(parse);         b3091 = parse.move().split(',');     }     else         b3091 = ['radius'];       parse.t1788 = false;      for (const id of b3091)     {         switch (id)         {         case 'radius': blur.radius = e1787(parse); break;         }     }               parse.c3646--;       g1790(parse, blur);     return blur; }    function p1685(parse) {     parse.pos++;       const layer = parse.move();      if (parse.settings.logRequests)          a2130(k1211, layer, parse);      return f3707(layer)[0]; }    function l1686(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const layer = new s1891(nodeId, options);       if (parse.settings.logRequests)          h2123(layer, parse, ignore);       if (ignore)     {         g1790(parse, layer);         return parse.c4242.find(n => n.nodeId == nodeId);     }       layer.opacity = e1787(parse);     layer.blend   = e1787(parse);               g1790(parse, layer);     return layer; }    function w1687(parse) {     parse.pos++;       const mask = parse.move();      if (parse.settings.logRequests)          a2130(t1208, mask, parse);      return h3708(mask)[0]; }    function n1688(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const mask = new a1893(nodeId, options);       if (parse.settings.logRequests)          h2123(mask, parse, ignore);       if (ignore)     {         g1790(parse, mask);         return parse.c4242.find(n => n.nodeId == nodeId);     }       mask.maskType = e1787(parse);               g1790(parse, mask);     return mask; }


function u1690(parse) {     parse.pos++;       const val = parse.move();      if (parse.settings.logRequests)          a2130(m1091, val, parse);      return val.indexOf(',') >= 0          ? h2849      (val)[0]          : s3835(val)[0]; }    function t1691(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const num = new y1935(nodeId, options);           if (parse.settings.logRequests)          h2123(num, parse, ignore);       if (ignore)      {         g1790(parse, num);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;     parse.t1788 = false;       if (parse.next == m1091) num.value = e1787(parse);     else                            num.input = e1787(parse);       parse.c3646--;       g1790(parse, num);     return num; }    function genParseSetPrecision(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const prec = new GSetPrecision(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(prec, parse, ignore, r4208);       if (ignore)      {         g1790(parse, prec);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         prec.input = e1787(parse);      prec.decimals = e1787(parse);           parse.c3646--;       g1790(parse, prec);     return prec; }    function n1692(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const j3673 = new u1926(nodeId, options);       if (parse.settings.logRequests)          h2123(j3673, parse, ignore);       if (ignore)      {         g1790(parse, j3673);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       j3673.constant = e1787(parse);       parse.c3646--;       g1790(parse, j3673);     return j3673; }    function g1693(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const dateTime = new v1928(nodeId, options);       if (parse.settings.logRequests)          h2123(dateTime, parse, ignore);       if (ignore)      {         g1790(parse, dateTime);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       dateTime.seconds   = e1787(parse);     dateTime.minutes   = e1787(parse);     dateTime.hours     = e1787(parse);     dateTime.dayOfWeek = e1787(parse);     dateTime.date      = e1787(parse);     dateTime.month     = e1787(parse);     dateTime.year      = e1787(parse);       parse.c3646--;       g1790(parse, dateTime);     return dateTime; }    function v1694(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const sign = new e1942(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(sign, parse, ignore);       if (ignore)      {         g1790(parse, sign);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         sign.input = e1787(parse);           parse.c3646--;       g1790(parse, sign);     return sign; }    function p1695(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const abs = new o1923(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(abs, parse, ignore);       if (ignore)      {         g1790(parse, abs);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         abs.input = e1787(parse);           parse.c3646--;       g1790(parse, abs);     return abs; }    function genParseNegative(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const neg = new GNegative(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(neg, parse, ignore);       if (ignore)      {         g1790(parse, neg);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         neg.input = e1787(parse);           parse.c3646--;       g1790(parse, neg);     return neg; }    function x1696(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const round = new n1940(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(round, parse, ignore, r4208);       if (ignore)      {         g1790(parse, round);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         round.input = e1787(parse);      round.type     = e1787(parse);     round.decimals = e1787(parse);           parse.c3646--;       g1790(parse, round);     return round; }    function genParseQuantize(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const quant = new GQuantize(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(quant, parse, ignore, r4208);       if (ignore)      {         g1790(parse, quant);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         quant.input = e1787(parse);      quant.type   = e1787(parse);     quant.base   = e1787(parse);     quant.step   = e1787(parse);     quant.amount = e1787(parse);           parse.c3646--;       g1790(parse, quant);     return quant; }    function d1697(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const e3672 = new j1943(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(e3672, parse, ignore, r4208);       if (ignore)      {         g1790(parse, e3672);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         e3672.input = e1787(parse);      e3672.operand   = e1787(parse);     e3672.operation = e1787(parse);           parse.c3646--;       g1790(parse, e3672);     return e3672; }    function d1698(parse) {     const [type, nodeId, options, ignore] = a1789(parse);       const f3671 = new p1932(nodeId, options);           let r4208 = 0;          if (!ignore)         r4208 = parseInt(parse.move());       if (parse.settings.logRequests)          h2123(f3671, parse, ignore, r4208);       if (ignore)      {         g1790(parse, f3671);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;      for (let i = 0; i < r4208; i++)         f3671.inputs.push(e1787(parse));       f3671.operation = e1787(parse);       parse.c3646--;               g1790(parse, f3671);     return f3671; }    function v1699(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const limits = new x1931(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(limits, parse, ignore, r4208);       if (ignore)      {         g1790(parse, limits);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         limits.input = e1787(parse);      limits.min = e1787(parse);     limits.max = e1787(parse);           parse.c3646--;       g1790(parse, limits);     return limits; }    function u1700(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const curve = new n1936(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(curve, parse, ignore, r4208);       if (ignore)      {         g1790(parse, curve);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         curve.input = e1787(parse);      curve.min    = e1787(parse);     curve.max    = e1787(parse);     curve.power  = e1787(parse);           parse.c3646--;       g1790(parse, curve);     return curve; }    function genParseNumberMap(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const map = new GNumberMap(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(map, parse, ignore, r4208);       if (ignore)      {         g1790(parse, map);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         map.input = e1787(parse);      map.from = e1787(parse);     map.to   = e1787(parse);           parse.c3646--;       g1790(parse, map);     return map; }    function genParseNumberBias(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const bias = new GNumberBias(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(bias, parse, ignore, r4208);       if (ignore)      {         g1790(parse, bias);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         bias.input = e1787(parse);      bias.min    = e1787(parse);     bias.max    = e1787(parse);     bias.bias   = e1787(parse);     bias.spread = e1787(parse);           parse.c3646--;       g1790(parse, bias);     return bias; }    function t1701(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const a3670 = new x1933(nodeId, options);       let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(a3670, parse, ignore, r4208);       if (ignore)      {         g1790(parse, a3670);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         a3670.input = e1787(parse);      a3670._value = e1787(parse);      parse.c3646--;       g1790(parse, a3670);     return a3670; }    function t1702(parse, s1689) {     const [type, nodeId, options, ignore] = a1789(parse);       const math = s1689(nodeId, options);           let r4208 = 0;          if (!ignore)         r4208 = parseInt(parse.move());       if (parse.settings.logRequests)          h2123(math, parse, ignore, r4208);       if (ignore)      {         g1790(parse, math);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;      for (let i = 0; i < r4208; i++)         math.inputs.push(e1787(parse));       math.operation = e1787(parse);       parse.c3646--;               g1790(parse, math);     return math; }    function j1703(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const smath = new i1904(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(smath, parse, ignore, r4208);       if (ignore)      {         g1790(parse, smath);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         smath.input = e1787(parse);      smath.operation = e1787(parse);     smath.operand   = e1787(parse);     smath.invert    = e1787(parse);           parse.c3646--;       g1790(parse, smath);     return smath; }    function p1704(parse, s1689) {     const [type, nodeId, options, ignore] = a1789(parse);       const arith = s1689(nodeId, options);       let r4208 = 0;          if (!ignore)         r4208 = parseInt(parse.move());       if (parse.settings.logRequests)          h2123(arith, parse, ignore, r4208);       if (ignore)      {         g1790(parse, arith);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;      for (let i = 0; i < r4208; i++)         arith.inputs.push(e1787(parse));      parse.c3646--;               g1790(parse, arith);     return arith; }    function f1705(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const convert = new e1927(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(convert, parse, ignore, r4208);       if (ignore)      {         g1790(parse, convert);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         convert.input = e1787(parse);      convert.from = e1787(parse);           parse.c3646--;       g1790(parse, convert);     return convert; }    function genParseIterate(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const define = new f1929(nodeId, options);       let r4208 = 0;          if (!ignore)         r4208 = parseInt(parse.move());       if (parse.settings.logRequests)          h2123(define, parse, ignore, r4208);       if (ignore)      {         g1790(parse, define);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;           for (let i = 0; i < r4208; i++)         define.inputs.push(e1787(parse));       parse.c3646--;       g1790(parse, define);     return define; }    function u1707(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const dist = new o1939(nodeId, options);       if (parse.settings.logRequests)          h2123(dist, parse, ignore);       if (ignore)      {         g1790(parse, dist);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       dist.from   = e1787(parse);     dist.start  = e1787(parse);     dist.end    = e1787(parse);       parse.c3646--;       g1790(parse, dist);     return dist; }    function c1708(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const wave = new j1945(nodeId, options);       if (parse.settings.logRequests)          h2123(wave, parse, ignore);       if (ignore)      {         g1790(parse, wave);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       wave.shape     = e1787(parse);     wave.base      = e1787(parse);     wave.amplitude = e1787(parse);     wave.frequency = e1787(parse);     wave.offset    = e1787(parse);     wave.bias      = e1787(parse);       wave.useWavelength  = parseInt(parse.move()) > 0;     wave.offsetAbsolute = parseInt(parse.move()) > 0;       parse.c3646--;       g1790(parse, wave);     return wave; }    function w1709(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const seq = new s1941(nodeId, options);       if (parse.settings.logRequests)          h2123(seq, parse, ignore);       if (ignore)      {         g1790(parse, seq);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       seq.start    = e1787(parse);     seq.multiply = e1787(parse);     seq.add      = e1787(parse);     seq.end      = e1787(parse);       parse.c3646--;       g1790(parse, seq);     return seq; }    function f1710(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const rnd = new h1938(nodeId, options);       if (parse.settings.logRequests)          h2123(rnd, parse, ignore);       if (ignore)      {         g1790(parse, rnd);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       rnd.seed      = e1787(parse);     rnd.iteration = e1787(parse);     rnd.min       = e1787(parse);     rnd.max       = e1787(parse);     rnd.bias      = e1787(parse);     rnd.spread    = e1787(parse);     rnd.unique    = e1787(parse);       parse.c3646--;       g1790(parse, rnd);     return rnd; }    function k1711(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const noise = new j1934(nodeId, options);       if (parse.settings.logRequests)          h2123(noise, parse, ignore);       if (ignore)      {         g1790(parse, noise);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       noise.seed        = e1787(parse);     noise.iteration   = e1787(parse);     noise.min         = e1787(parse);     noise.max         = e1787(parse);     noise.scale       = e1787(parse);     noise.offset      = e1787(parse);     noise.evolve      = e1787(parse);     noise.interpolate = e1787(parse);     noise.detail      = e1787(parse);       parse.c3646--;       g1790(parse, noise);     return noise; }    function i1712(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const prob = new x1937(nodeId, options);       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 2, 'nInputs must be [0, 2]');     }       const w3681 =          r4208 == 1         ? parseInt(parse.move())         : -1;       if (parse.settings.logRequests)          h2123(prob, parse, ignore, r4208);       if (ignore)      {         g1790(parse, prob);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 2)     {         prob.z4082   = e1787(parse);         prob.z4083   = e1787(parse);     }     else if (r4208 == 1)     {              if (w3681 == 0) prob.z4082 = e1787(parse);          else if (w3681 == 1) prob.z4083 = e1787(parse);      }       prob.seed      = e1787(parse);     prob.iteration = e1787(parse);     prob.chance    = e1787(parse);     prob.alternate = e1787(parse);       parse.c3646--;       g1790(parse, prob);     return prob; }    function q1713(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const accum = new m1924(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(accum, parse, ignore, r4208);       if (ignore)      {         g1790(parse, accum);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         accum.input = e1787(parse);      accum.when = e1787(parse);               parse.c3646--;       g1790(parse, accum);     return accum; }    function genParseHold(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const hold = new GHold(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(hold, parse, ignore, r4208);       if (ignore)      {         g1790(parse, hold);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         hold.input = e1787(parse);      hold.first = e1787(parse);               parse.c3646--;       g1790(parse, hold);     return hold; }    function u1714(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const r1035 = new c1930(nodeId, options);       let r4208 = 0;          if (!ignore)         r4208 = parseInt(parse.move());       if (parse.settings.logRequests)          h2123(r1035, parse, ignore, r4208);       if (ignore)      {         g1790(parse, r1035);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;      for (let i = 0; i < r4208; i++)         r1035.inputs.push(e1787(parse));       r1035.amount = e1787(parse);     r1035.degree = e1787(parse);       parse.c3646--;       g1790(parse, r1035);     return r1035; }    function q1715(parse) {     const [type, nodeId, options, ignore] = a1789(parse);       const bool = new a1907(nodeId, options);           let r4208 = 0;          if (!ignore)         r4208 = parseInt(parse.move());       if (parse.settings.logRequests)          h2123(bool, parse, ignore, r4208);       if (ignore)      {         g1790(parse, bool);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;      for (let i = 0; i < r4208; i++)         bool.inputs.push(e1787(parse));       bool.operation = e1787(parse);       parse.c3646--;               g1790(parse, bool);     return bool; }    function c1716(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const cond = new o1911(nodeId, options);       let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(cond, parse, ignore, r4208);       if (ignore)      {         g1790(parse, cond);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         cond.input = e1787(parse);             cond.operation = e1787(parse);     cond.operand   = e1787(parse);       parse.c3646--;       g1790(parse, cond);     return cond; }    function f1717(parse, s1689) {     const [type, nodeId, options, ignore] = a1789(parse);       const cond = s1689(nodeId, options);       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.logRequests)         h2123(cond, parse, ignore, r4208);        if (ignore)      {         g1790(parse, cond);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;      if (r4208 == 2)     {         cond.z4082 = e1787(parse);         cond.z4083 = e1787(parse);     }     else if (r4208 == 1)     {         cond.z4082 = e1787(parse);      }      parse.c3646--;       g1790(parse, cond);     return cond; }    function l1718(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const trig = new e1922(nodeId, options);       let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(trig, parse, ignore, r4208);       if (ignore)      {         g1790(parse, trig);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         trig.input = e1787(parse);      trig.function = e1787(parse);      parse.c3646--;       g1790(parse, trig);     return trig; }    function c1719(parse, s1689) {     const [type, nodeId, options, ignore] = a1789(parse);       const trig = s1689(nodeId, options);       let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)         h2123(trig, parse, ignore, r4208);        if (ignore)      {         g1790(parse, trig);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         trig.input = e1787(parse);       parse.c3646--;       g1790(parse, trig);     return trig; }    function k1720(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const atan2 = new q1918(nodeId, options);              if (parse.settings.logRequests)          h2123(atan2, parse, ignore);       if (ignore)      {         g1790(parse, atan2);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       atan2.x = e1787(parse);     atan2.y = e1787(parse);           parse.c3646--;       g1790(parse, atan2);     return atan2; }    function m1721(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const solve = new y1944(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(solve, parse, ignore, r4208);       if (ignore)      {         g1790(parse, solve);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         solve.input = e1787(parse);      solve.current = e1787(parse);     solve.target  = e1787(parse);           parse.c3646--;       g1790(parse, solve);     return solve; }    function p1722(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const anim = new n1925(nodeId, options);       if (parse.settings.logRequests)          h2123(anim, parse);       if (ignore)      {         g1790(parse, anim);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       anim.from   = e1787(parse);     anim.to     = e1787(parse);     anim.curve  = e1787(parse);     anim.repeat = e1787(parse);     anim.length = e1787(parse);     anim.time   = e1787(parse);       parse.c3646--;       g1790(parse, anim);     return anim; } 


function q1723(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const rect = new m1968(nodeId, options);       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(rect, parse, ignore);       if (ignore)      {         g1790(parse, rect);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         rect.input = e1787(parse);       const d3667 = i1792(parse);      for (let i = 0; i < d3667; i++)     {         const v2991 = t1794(parse);          parse.t1788 = true;          switch (v2991)         {         case 'x':      rect.x      = e1787(parse); break;         case 'y':      rect.y      = e1787(parse); break;         case 'width':  rect.width  = e1787(parse); break;         case 'height': rect.height = e1787(parse); break;         case 'round':  rect.round  = e1787(parse); break;         case 'props':  rect.props  = e1787(parse); break;         }     }       parse.t1788 = false;     parse.c3646--;       g1790(parse, rect);     return rect; }                                                                     function q1724(parse) {     const [, nodeId, options, ignore] = a1789(parse);         const line = new u1959(nodeId, options);       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(line, parse, ignore);       if (ignore)      {         g1790(parse, line);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         line.input = e1787(parse);       const d3667 = i1792(parse);      for (let i = 0; i < d3667; i++)     {         const v2991 = t1794(parse);          parse.t1788 = true;          switch (v2991)         {         case 'x':     line.x     = e1787(parse); break;         case 'y':     line.y     = e1787(parse); break;         case 'width': line.width = e1787(parse); break;         case 'props': line.props = e1787(parse); break;         }     }       parse.t1788 = false;     parse.c3646--;       g1790(parse, line);     return line; }    function l1725(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const ellipse = new r1955(nodeId, options);       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(ellipse, parse, ignore);       if (ignore)      {         g1790(parse, ellipse);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         ellipse.input = e1787(parse);       const d3667 = i1792(parse);      for (let i = 0; i < d3667; i++)     {         const v2991 = t1794(parse);          parse.t1788 = true;          switch (v2991)         {         case 'position': ellipse.position = e1787(parse); break;         case 'x':        ellipse.x        = e1787(parse); break;         case 'y':        ellipse.y        = e1787(parse); break;         case 'width':    ellipse.width    = e1787(parse); break;         case 'height':   ellipse.height   = e1787(parse); break;         case 'round':    ellipse.round    = e1787(parse); break;         case 'start':    ellipse.start    = e1787(parse); break;         case 'sweep':    ellipse.sweep    = e1787(parse); break;         case 'inner':    ellipse.inner    = e1787(parse); break;         case 'props':    ellipse.props    = e1787(parse); break;         }     }               ellipse.innerAbsolute  = parseInt(parse.move()) > 0;     ellipse.sweepInDegrees = parseInt(parse.move()) > 0;       parse.t1788 = false;     parse.c3646--;       g1790(parse, ellipse);     return ellipse; }    function l1726(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const trapeze = new d1979(nodeId, options);       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(trapeze, parse, ignore);       if (ignore)      {         g1790(parse, trapeze);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         trapeze.input = e1787(parse);       const d3667 = i1792(parse);      for (let i = 0; i < d3667; i++)     {         const v2991 = t1794(parse);          parse.t1788 = true;          switch (v2991)         {         case 'x':      trapeze.x      = e1787(parse); break;         case 'y':      trapeze.y      = e1787(parse); break;         case 'width':  trapeze.width  = e1787(parse); break;         case 'height': trapeze.height = e1787(parse); break;         case 'round':  trapeze.round  = e1787(parse); break;         case 'bias':   trapeze.bias   = e1787(parse); break;         case 'props':  trapeze.props  = e1787(parse); break;         }     }               parse.t1788 = false;     parse.c3646--;       g1790(parse, trapeze);     return trapeze; }    function l1727(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const poly = new o1967(nodeId, options);       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(poly, parse, ignore);       if (ignore)      {         g1790(parse, poly);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         poly.input = e1787(parse);       const d3667 = i1792(parse);      for (let i = 0; i < d3667; i++)     {         const v2991 = t1794(parse);          parse.t1788 = true;          switch (v2991)         {         case 'position': poly.position = e1787(parse); break;         case 'x':        poly.x        = e1787(parse); break;         case 'y':        poly.y        = e1787(parse); break;         case 'width':    poly.width    = e1787(parse); break;         case 'height':   poly.height   = e1787(parse); break;         case 'round':    poly.round    = e1787(parse); break;         case 'corners':  poly.corners  = e1787(parse); break;         case 'props':    poly.props    = e1787(parse); break;         }     }               parse.t1788 = false;     parse.c3646--;       g1790(parse, poly);     return poly; }    function r1728(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const star = new v1977(nodeId, options);       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(star, parse, ignore);       if (ignore)      {         g1790(parse, star);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         star.input = e1787(parse);       const d3667 = i1792(parse);      for (let i = 0; i < d3667; i++)     {         const v2991 = t1794(parse);          parse.t1788 = true;          switch (v2991)         {         case 'position': star.position = e1787(parse); break;         case 'x':        star.x        = e1787(parse); break;         case 'y':        star.y        = e1787(parse); break;         case 'width':    star.width    = e1787(parse); break;         case 'height':   star.height   = e1787(parse); break;         case 'round':    star.round    = e1787(parse); break;         case 'points':   star.points   = e1787(parse); break;         case 'convex':   star.convex   = e1787(parse); break;         case 'props':    star.props    = e1787(parse); break;         }     }               parse.t1788 = false;     parse.c3646--;       g1790(parse, star);     return star; }    function b1729(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const text = new q1978(nodeId, options);       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(text, parse, ignore);       if (ignore)      {         g1790(parse, text);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         text.input = e1787(parse);       const d3667 = i1792(parse);      for (let i = 0; i < d3667; i++)     {         const v2991 = t1794(parse);          parse.t1788 = true;          switch (v2991)         {                case 'text':          text.text          = e1787(parse); break;         case 'x':             text.x             = e1787(parse); break;         case 'y':             text.y             = e1787(parse); break;         case 'width':         text.width         = e1787(parse); break;         case 'height':        text.height        = e1787(parse); break;         case 'font':          text.font          = e1787(parse); break;         case 'size':          text.size          = e1787(parse); break;         case 'style':         text.style         = e1787(parse); break;         case 'props':         text.props         = e1787(parse); break;         case 'alignX':        text.alignX        = e1787(parse); break;         case 'alignY':        text.alignY        = e1787(parse); break;         case 'lineHeight':    text.lineHeight    = e1787(parse); break;         case 'letterSpacing': text.letterSpacing = e1787(parse); break;         }     }       parse.t1788 = false;     parse.c3646--;       g1790(parse, text);     return text; }    function e1730(parse) {     parse.pos++;       const point = parse.move();      if (parse.settings.logRequests)          a2130(v1245, point, parse);      return c3827(point)[0]; }    function d1731(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const point = new u1963(nodeId, options);       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(point, parse, ignore);       if (ignore)      {         g1790(parse, point);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         point.input = e1787(parse);       const d3667 = i1792(parse);      for (let i = 0; i < d3667; i++)     {         const v2991 = t1794(parse);          parse.t1788 = true;          switch (v2991)         {         case 'x': point.x = e1787(parse); break;         case 'y': point.y = e1787(parse); break;         }     }       parse.t1788 = false;     parse.c3646--;       g1790(parse, point);     return point; }    function f1732(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const corner = new p1964(nodeId, options);       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(corner, parse, ignore);       if (ignore)      {         g1790(parse, corner);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         corner.input = e1787(parse);      corner.smooth = e1787(parse);       parse.t1788 = false;     parse.c3646--;       g1790(parse, corner);     return corner; }    function e1733(parse) {     parse.pos++;       const path = parse.move();      if (parse.settings.logRequests)          a2130(q1249, path, parse);      return d3669(path)[0]; }    function i1734(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const path = new f1983(nodeId, options);       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(path, parse, ignore);       if (ignore)      {         g1790(parse, path);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         path.input = e1787(parse);       const d3667 = i1792(parse);      for (let i = 0; i < d3667; i++)     {         const v2991 = t1794(parse);          parse.t1788 = true;          switch (v2991)         {                case 'points':  path.points  = e1787(parse); break;         case 'closed':  path.closed  = e1787(parse); break;         case 'degree':  path.degree  = e1787(parse); break;         case 'winding': path.winding = e1787(parse); break;         case 'round':   path.round   = e1787(parse); break;         case 'props':   path.props   = e1787(parse); break;         }     }       parse.t1788 = false;     parse.c3646--;       g1790(parse, path);     return path; }    function genParsePathLength(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const len = new GPathLength(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(len, parse, ignore, r4208);       if (ignore)      {         g1790(parse, len);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         len.input = e1787(parse);           parse.c3646--;       g1790(parse, len);     return len; }    function genParseJoinPaths(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const join = new GJoinPaths(nodeId, options);       let r4208 = 0;          if (!ignore)         r4208 = parseInt(parse.move());       if (parse.settings.logRequests)          h2123(join, parse, ignore, r4208);       if (ignore)      {         g1790(parse, join);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       for (let i = 0; i < r4208; i++)         join.inputs.push(e1787(parse));       const d3667 = i1792(parse);      for (let i = 0; i < d3667; i++)     {         const v2991 = t1794(parse);          parse.t1788 = true;          switch (v2991)         {                case 'closed':  join.closed  = e1787(parse); break;         case 'degree':  join.degree  = e1787(parse); break;         case 'winding': join.winding = e1787(parse); break;         case 'round':   join.round   = e1787(parse); break;         case 'props':   join.props   = e1787(parse); break;         }     }       parse.t1788 = false;     parse.c3646--;       g1790(parse, join);     return join; }    function genParseReorientPaths(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const reorient = new GReorientPaths(nodeId, options);       let r4208 = 0;          if (!ignore)         r4208 = parseInt(parse.move());       if (parse.settings.logRequests)          h2123(reorient, parse, ignore, r4208);       if (ignore)      {         g1790(parse, reorient);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       for (let i = 0; i < r4208; i++)         reorient.inputs.push(e1787(parse));       reorient.reverse = e1787(parse);                   parse.t1788 = false;     parse.c3646--;       g1790(parse, reorient);     return reorient; }    function k1735(parse) {     parse.pos++;       const point = parse.move();      if (parse.settings.logRequests)          a2130(u1252, point, parse);      return e3668(point)[0]; }    function n1736(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const point = new d1985(nodeId, options);       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(point, parse, ignore);       if (ignore)      {         g1790(parse, point);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         point.input = e1787(parse);       const d3667 = i1792(parse);      for (let i = 0; i < d3667; i++)     {         const v2991 = t1794(parse);          parse.t1788 = true;          switch (v2991)         {         case 'x':     point.x     = e1787(parse); break;         case 'y':     point.y     = e1787(parse); break;         case 'join':  point.join  = e1787(parse); break;         case 'cap':   point.cap   = e1787(parse); break;         case 'round': point.round = e1787(parse); break;         }     }       parse.t1788 = false;     parse.c3646--;       g1790(parse, point);     return point; }    function b1737(parse) {     parse.pos++;       const edge = parse.move();      if (parse.settings.logRequests)          a2130(i1255, edge, parse);      return s3666(edge)[0]; }    function p1738(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const edge = new h1980(nodeId, options);       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.logRequests)          h2123(edge, parse, ignore, r4208);       if (ignore)      {         g1790(parse, edge);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 2)     {         edge.z4082 = e1787(parse);         edge.z4083 = e1787(parse);     }     else if (r4208 == 1)     {         edge.z4082 = e1787(parse);      }       edge.l3664 = e1787(parse);     edge.  f3665 = e1787(parse);       parse.t1788 = false;     parse.c3646--;       g1790(parse, edge);     return edge; }    function n1739(parse) {     parse.pos++;       const region = parse.move();      if (parse.settings.logRequests)          a2130(o1258, region, parse);      return n3663(region)[0]; }    function l1740(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const region = new s1984(nodeId, options);       let r4208 = 0;          if (!ignore)         r4208 = parseInt(parse.move());       if (parse.settings.logRequests)          h2123(region, parse, ignore, r4208);       if (ignore)      {         g1790(parse, region);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       for (let i = 0; i < r4208; i++)         region.inputs.push(e1787(parse));       region.winding = e1787(parse);     region.props   = e1787(parse);       parse.t1788 = false;     parse.c3646--;       g1790(parse, region);     return region; }    function q1741(parse) {     parse.pos++;       const region = parse.move();      if (parse.settings.logRequests)          a2130(z1261, region, parse);      return r3662(region)[0]; }    function t1742(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const network = new j1982(nodeId, options);       let r4208 = 0;          if (!ignore)         r4208 = parseInt(parse.move());       if (parse.settings.logRequests)          h2123(network, parse, ignore, r4208);       if (ignore)      {         g1790(parse, network);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       for (let i = 0; i < r4208; i++)         network.inputs.push(e1787(parse));      network.props = e1787(parse);       parse.c3646--;        g1790(parse, network);     return network; }    function r1743(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const bool = new g1946(nodeId, options);       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(bool, parse, ignore);       if (ignore)      {         g1790(parse, bool);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         bool.input = e1787(parse);       const d3667 = i1792(parse);      for (let i = 0; i < d3667; i++)     {         const v2991 = t1794(parse);          parse.t1788 = true;          switch (v2991)         {         case 'children':  bool.children  = e1787(parse); break;         case 'operation': bool.operation = e1787(parse); break;         case 'props':     bool.props     = e1787(parse); break;         }     }       parse.t1788 = false;     parse.c3646--;       g1790(parse, bool);     return bool; }    function genParseArcPath(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const arc = new GArcPath(nodeId, options);       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(arc, parse, ignore);       if (ignore)      {         g1790(parse, arc);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         arc.input = e1787(parse);       const d3667 = i1792(parse);      for (let i = 0; i < d3667; i++)     {         const v2991 = t1794(parse);          parse.t1788 = true;          switch (v2991)         {         case 'position': arc.position = e1787(parse); break;         case 'x':        arc.x        = e1787(parse); break;         case 'y':        arc.y        = e1787(parse); break;         case 'width':    arc.width    = e1787(parse); break;         case 'height':   arc.height   = e1787(parse); break;         case 'start':    arc.start    = e1787(parse); break;         case 'sweep':    arc.sweep    = e1787(parse); break;         case 'props':    arc.props    = e1787(parse); break;         }     }               arc.sweepInDegrees = parseInt(parse.move()) > 0;       parse.t1788 = false;     parse.c3646--;       g1790(parse, arc);     return arc; }    function genParseWavePath(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const wave = new GWavePath(nodeId, options);       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(wave, parse, ignore);       if (ignore)      {         g1790(parse, wave);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         wave.input = e1787(parse);       const d3667 = i1792(parse);      for (let i = 0; i < d3667; i++)     {         const v2991 = t1794(parse);          parse.t1788 = true;          switch (v2991)         {         case 'shape':     wave.shape     = e1787(parse); break;         case 'x':         wave.x         = e1787(parse); break;         case 'y':         wave.y         = e1787(parse); break;         case 'width':     wave.width     = e1787(parse); break;         case 'amplitude': wave.amplitude = e1787(parse); break;         case 'frequency': wave.frequency = e1787(parse); break;         case 'offset':    wave.offset    = e1787(parse); break;         case 'alignX':    wave.alignX    = e1787(parse); break;         case 'alignY':    wave.alignY    = e1787(parse); break;         case 'props':     wave.props     = e1787(parse); break;         }     }               wave.useWavelength  = parseInt(parse.move()) > 0;     wave.offsetAbsolute = parseInt(parse.move()) > 0;       parse.t1788 = false;     parse.c3646--;       g1790(parse, wave);     return wave; }    function m1744(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const group = new c1975(nodeId, options);       let r4208 = 0;          if (!ignore)         r4208 = parseInt(parse.move());       if (parse.settings.logRequests)          h2123(group, parse, ignore, r4208);       if (ignore)      {         g1790(parse, group);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       for (let i = 0; i < r4208; i++)         group.inputs.push(e1787(parse));       parse.c3646--;       g1790(parse, group);     return group; }    function k1745(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const frame = new c1956(nodeId, options);       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(frame, parse, ignore);       if (ignore)      {         g1790(parse, frame);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         frame.input = e1787(parse);       const d3667 = i1792(parse);      for (let i = 0; i < d3667; i++)     {         const v2991 = t1794(parse);          parse.t1788 = true;          switch (v2991)         {         case 'children': frame.children = e1787(parse); break;         case 'position': frame.position = e1787(parse); break;         case 'x':        frame.x        = e1787(parse); break;         case 'y':        frame.y        = e1787(parse); break;         case 'width':    frame.width    = e1787(parse); break;         case 'height':   frame.height   = e1787(parse); break;         case 'round':    frame.round    = e1787(parse); break;         case 'clip':     frame.clip     = e1787(parse); break;         case 'props':    frame.props    = e1787(parse); break;         }     }       parse.t1788 = false;     parse.c3646--;       g1790(parse, frame);     return frame; }    function l1746(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const move = new o1961(nodeId, options);       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(move, parse, ignore);       if (ignore)      {         g1790(parse, move);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         move.input = e1787(parse);      move.y3661    = e1787(parse);     move.x           = e1787(parse);     move.y           = e1787(parse);     move.affectSpace = e1787(parse);       parse.t1788 = false;     parse.c3646--;       g1790(parse, move);     return move; }    function w1747(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const rotate = new d1971(nodeId, options);       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(rotate, parse, ignore);       if (ignore)      {         g1790(parse, rotate);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         rotate.input = e1787(parse);      rotate.angle       = e1787(parse);     rotate.affectSpace = e1787(parse);           parse.t1788 = false;     parse.c3646--;       g1790(parse, rotate);     return rotate; }    function l1748(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const scale = new t1972(nodeId, options);       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(scale, parse, ignore);       if (ignore)      {         g1790(parse, scale);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         scale.input = e1787(parse);      scale.scaleX        = e1787(parse);     scale.scaleY        = e1787(parse);     scale.affectCorners = e1787(parse);     scale.affectStyle   = e1787(parse);     scale.affectSpace   = e1787(parse);           parse.t1788 = false;     parse.c3646--;       g1790(parse, scale);     return scale; }    function e1749(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const skew = new y1976(nodeId, options);       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(skew, parse, ignore);       if (ignore)      {         g1790(parse, skew);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         skew.input = e1787(parse);      skew.skewX       = e1787(parse);     skew.skewY       = e1787(parse);     skew.affectSpace = e1787(parse);       parse.t1788 = false;     parse.c3646--;       g1790(parse, skew);     return skew; }    function genParseShowCenter(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const showCenter = new GShowCenter(nodeId, options);       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(showCenter, parse, ignore);       if (ignore)      {         g1790(parse, showCenter);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         showCenter.input = e1787(parse);      showCenter.show = e1787(parse);       parse.t1788 = false;     parse.c3646--;       g1790(parse, showCenter);     return showCenter; }    function m1750(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const center = new p1953(nodeId, options);       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(center, parse, ignore);       if (ignore)      {         g1790(parse, center);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         center.input = e1787(parse);      center.centerX    = e1787(parse);     center.centerY    = e1787(parse);     center.units      = e1787(parse);       parse.t1788 = false;     parse.c3646--;       g1790(parse, center);     return center; }    function r1751(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const reset = new i1970(nodeId, options);       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(reset, parse, ignore);       if (ignore)      {         g1790(parse, reset);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         reset.input = e1787(parse);       parse.c3646--;       g1790(parse, reset);     return reset; }    function s1752(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const measure = new n1960(nodeId, options);       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(measure, parse, ignore, r4208);       if (ignore)      {         g1790(parse, measure);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;           if (r4208 == 1)         measure.input = e1787(parse);                 parse.c3646--;       g1790(parse, measure);     return measure; }    function a1753(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const angle = new GPointAngle(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(angle, parse, ignore, r4208);       if (ignore)      {         g1790(parse, angle);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         angle.input = e1787(parse);           parse.c3646--;       g1790(parse, angle);     return angle; }    function k1754(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const vector = new q1981(nodeId, options);       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.logRequests)          h2123(vector, parse, ignore, r4208);       if (ignore)      {         g1790(parse, vector);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;           if (r4208 == 2)     {         vector.z4082 = e1787(parse);         vector.z4083 = e1787(parse);     }     else if (r4208 == 1)     {         vector.z4082 = e1787(parse);      }       vector.transform  = e1787(parse);       parse.c3646--;       g1790(parse, vector);     return vector; }    function h1755(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const center = new c1954(nodeId, options);       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 3, 'nInputs must be [0, 3]');     }           if (parse.settings.logRequests)          h2123(center, parse, ignore, r4208);       if (ignore)      {         g1790(parse, center);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;           if (r4208 == 3)     {         center.z4082 = e1787(parse);         center.z4083 = e1787(parse);         center.n4084 = e1787(parse);     }     else if (r4208 == 2)     {         center.z4082 = e1787(parse);         center.z4083 = e1787(parse);     }     else if (r4208 == 1)     {         center.z4082 = e1787(parse);     }       parse.c3646--;       g1790(parse, center);     return center; }    function genParseArcFromPoints(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const arc = new GArcFromPoints(nodeId, options);       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 3, 'nInputs must be [0, 3]');     }           if (parse.settings.logRequests)          h2123(arc, parse, ignore, r4208);       if (ignore)      {         g1790(parse, arc);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;           if (r4208 == 3)     {         arc.z4082 = e1787(parse);         arc.z4083 = e1787(parse);         arc.n4084 = e1787(parse);     }     else if (r4208 == 2)     {         arc.z4082 = e1787(parse);         arc.z4083 = e1787(parse);     }     else if (r4208 == 1)     {         arc.z4082 = e1787(parse);     }       const d3667 = i1792(parse);      for (let i = 0; i < d3667; i++)     {         const v2991 = t1794(parse);          parse.t1788 = true;          switch (v2991)         {                case 'props':   arc.props   = e1787(parse); break;         }     }       parse.t1788 = false;     parse.c3646--;       g1790(parse, arc);     return arc; }    function e1756(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const inter = new m1958(nodeId, options);       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 4, 'nInputs must be [0, 4]');     }           if (parse.settings.logRequests)          h2123(inter, parse, ignore, r4208);       if (ignore)      {         g1790(parse, inter);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;           if (r4208 == 4)     {         inter.z4082 = e1787(parse);         inter.z4083 = e1787(parse);         inter.n4084 = e1787(parse);         inter.l4085 = e1787(parse);     }     else if (r4208 == 3)     {         inter.z4082 = e1787(parse);         inter.z4083 = e1787(parse);         inter.n4084 = e1787(parse);     }     else if (r4208 == 2)     {         inter.z4082 = e1787(parse);         inter.z4083 = e1787(parse);     }     else if (r4208 == 1)     {         inter.z4082 = e1787(parse);     }       inter.segment = e1787(parse);       parse.c3646--;       g1790(parse, inter);     return inter; }    function c1757(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const r1035 = new u1957(nodeId, options);       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.logRequests)          h2123(r1035, parse, ignore, r4208);       if (ignore)      {         g1790(parse, r1035);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 2)     {         r1035.z4082 = e1787(parse);         r1035.z4083 = e1787(parse);     }     else if (r4208 == 1)     {         r1035.z4082 = e1787(parse);      }       r1035.amount     = e1787(parse);     r1035.transform  = e1787(parse);       parse.c3646--;       g1790(parse, r1035);     return r1035; }    function genParsePointAlongPath(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const pap = new a1965(nodeId, options);       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(pap, parse, ignore, r4208);       if (ignore)      {         g1790(parse, pap);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         pap.input = e1787(parse);        pap.position   = e1787(parse);     pap.distance   = e1787(parse);     pap.offset     = e1787(parse);     pap.transform  = e1787(parse);       parse.c3646--;       g1790(parse, pap);     return pap; }    function genParseClosestPointOnPath(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const cpop = new z1966(nodeId, options);       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.logRequests)          h2123(cpop, parse, ignore, r4208);       if (ignore)      {         g1790(parse, cpop);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 2)     {         cpop.z4082 = e1787(parse);         cpop.z4083 = e1787(parse);     }     else if (r4208 == 1)     {         cpop.z4082 = e1787(parse);      }       cpop.constrain  = e1787(parse);     cpop.transform  = e1787(parse);       parse.c3646--;       g1790(parse, cpop);     return cpop; }    function genParseReversePath(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const reverse = new GReversePath(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(reverse, parse, ignore, r4208);       if (ignore)      {         g1790(parse, reverse);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         reverse.input = e1787(parse);             parse.c3646--;       g1790(parse, reverse);     return reverse; }    function genParseBlendPath(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const blend = new GBlendPath(nodeId, options);          let r4208 = 0;          if (!ignore)         r4208 = parseInt(parse.move());       if (parse.settings.logRequests)          h2123(blend, parse, ignore, r4208);       if (ignore)      {         g1790(parse, blend);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;           for (let i = 0; i < r4208; i++)         blend.inputs.push(e1787(parse));       blend.amount = e1787(parse);     blend.degree = e1787(parse);             parse.c3646--;       g1790(parse, blend);     return blend; }    function d1759(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const place = new f1962(nodeId, options);       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(place, parse, ignore);       if (ignore)      {         g1790(parse, place);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         place.input = e1787(parse);      place.position   = e1787(parse);     place.transform  = e1787(parse);       parse.t1788 = false;     parse.c3646--;       g1790(parse, place);     return place; }    function t1760(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const apply = new r1952(nodeId, options);       let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(apply, parse, ignore);       if (ignore)      {         g1790(parse, apply);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         apply.input = e1787(parse);      apply.props   = e1787(parse);     apply.replace = e1787(parse);       parse.t1788 = false;     parse.c3646--;       g1790(parse, apply);     return apply; }    function s1761(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const render = new g1969(nodeId, options);       let r4208 = 0;          if (!ignore)         r4208 = parseInt(parse.move());       if (parse.settings.logRequests)          h2123(render, parse, ignore, r4208);       if (ignore)      {         g1790(parse, render);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       for (let i = 0; i < r4208; i++)         render.inputs.push(e1787(parse));      render.retain   = e1787(parse);     render.finalize = e1787(parse);       parse.c3646--;       g1790(parse, render);     return render; }    function genParseExport(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const _export = new GExport(nodeId, options);       let r4208 = 0;          if (!ignore)         r4208 = parseInt(parse.move());       if (parse.settings.logRequests)          h2123(_export, parse, ignore, r4208);       if (ignore)      {         g1790(parse, _export);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       for (let i = 0; i < r4208; i++)         _export.inputs.push(e1787(parse));      _export.scale    = e1787(parse);     _export.format   = e1787(parse);         _export.suffix   = e1787(parse);     _export.profile  = e1787(parse);       parse.c3646--;       g1790(parse, _export);     return _export; }


              function c1762(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const style = new t1886(nodeId, options);      style.existing = options.existing;       if (parse.settings.logRequests)          h2123(style, parse, ignore);       if (ignore)      {         g1790(parse, style);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;     parse.t1788 = false;       style.id       = parse.move();     style.name     = options.nodeName;          style.h2817 = e1787(parse);           parse.c3646--;           style.linked = style.id != NULL;       g1790(parse, style);     return style; }                             


 function a1763(parse) {     parse.pos++;       const val = parse.move();      if (parse.settings.logRequests)          a2130(i1143, val, parse);      return k2864(val)[0]; }    function r1764(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const text = new s1991(nodeId, options);           if (parse.settings.logRequests)          h2123(text, parse, ignore);       if (ignore)      {         g1790(parse, text);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;     parse.t1788 = false;       if (parse.next == i1143) text.value = e1787(parse);     else                          text.input = e1787(parse);       parse.c3646--;       g1790(parse, text);     return text; }    function c1765(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const len = new x1999(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(len, parse, ignore, r4208);       if (ignore)      {         g1790(parse, len);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         len.input = e1787(parse);           parse.c3646--;       g1790(parse, len);     return len; }    function f1766(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const trim = new e2006(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(trim, parse, ignore, r4208);       if (ignore)      {         g1790(parse, trim);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         trim.input = e1787(parse);      trim.start = e1787(parse);     trim.end   = e1787(parse);           parse.c3646--;       g1790(parse, trim);     return trim; }    function e1767(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const sub = new o2003(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(sub, parse, ignore, r4208);       if (ignore)      {         g1790(parse, sub);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         sub.input = e1787(parse);      sub.start = e1787(parse);     sub.end   = e1787(parse);           parse.c3646--;       g1790(parse, sub);     return sub; }    function i1768(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const cont = new a1994(nodeId, options);          let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.logRequests)          h2123(cont, parse, ignore, r4208);       if (ignore)      {         g1790(parse, cont);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 2)     {         cont.z4082 = e1787(parse);         cont.z4083 = e1787(parse);     }     else if (r4208 == 1)     {         cont.z4082 = e1787(parse);      }             parse.c3646--;       g1790(parse, cont);     return cont; }    function k1769(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const c3658 = new k1992(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(c3658, parse, ignore, r4208);       if (ignore)      {         g1790(parse, c3658);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         c3658.input = e1787(parse);      c3658.case = e1787(parse);           parse.c3646--;       g1790(parse, c3658);     return c3658; }    function c1770(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const replace = new r2001(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(replace, parse, ignore, r4208);       if (ignore)      {         g1790(parse, replace);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         replace.input = e1787(parse);      replace.what  = e1787(parse);     replace.with  = e1787(parse);     replace.regex = e1787(parse);           parse.c3646--;       g1790(parse, replace);     return replace; }                                                                     function b1771(parse, s1689) {     const [type, nodeId, options, ignore] = a1789(parse);       const join = new u1998(nodeId, options);       let r4208 = 0;          if (!ignore)         r4208 = parseInt(parse.move());       if (parse.settings.logRequests)          h2123(join, parse, ignore, r4208);       if (ignore)      {         g1790(parse, join);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       for (let i = 0; i < r4208; i++)         join.inputs.push(e1787(parse));       join.with = e1787(parse);           parse.c3646--;               g1790(parse, join);     return join; }    function q1772(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const pad = new j2000(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(pad, parse, ignore, r4208);       if (ignore)      {         g1790(parse, pad);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         pad.input = e1787(parse);      pad.k3654   = e1787(parse);     pad.h3655 = e1787(parse);     pad.t3656     = e1787(parse);     pad.u3657   = e1787(parse);           parse.c3646--;       g1790(parse, pad);     return pad; }    function x1773(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const cmp = new n1993(nodeId, options);          let r4208 = -1;      if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 => 0 && r4208 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.logRequests)          h2123(cmp, parse, ignore, r4208);       if (ignore)      {         g1790(parse, cmp);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 2)     {         cmp.z4082 = e1787(parse);         cmp.z4083 = e1787(parse);     }     else if (r4208 == 1)     {         cmp.z4082 = e1787(parse);      }             cmp.operation = e1787(parse);           parse.c3646--;       g1790(parse, cmp);     return cmp; }    function q1774(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const i3653 = new z1987(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(i3653, parse, ignore, r4208);       if (ignore)      {         g1790(parse, i3653);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         i3653.input = e1787(parse);           parse.c3646--;       g1790(parse, i3653);     return i3653; }    function t1775(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const o3652 = new f1986(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(o3652, parse, ignore, r4208);       if (ignore)      {         g1790(parse, o3652);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         o3652.input = e1787(parse);           parse.c3646--;       g1790(parse, o3652);     return o3652; }    function s1776(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const index = new r1989(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(index, parse, ignore, r4208);       if (ignore)      {         g1790(parse, index);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       index.name  = e1787(parse);     index.index = e1787(parse);           parse.c3646--;       g1790(parse, index);     return index; }    function y1777(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const w3651 = new w1990(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(w3651, parse, ignore, r4208);       if (ignore)      {         g1790(parse, w3651);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         w3651.input = e1787(parse);      w3651.base      = e1787(parse);     w3651.decimals  = e1787(parse);     w3651.thousands = e1787(parse);           parse.c3646--;       g1790(parse, w3651);     return w3651; }    function d1778(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const p3650 = new u1988(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(p3650, parse, ignore, r4208);       if (ignore)      {         g1790(parse, p3650);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         p3650.input = e1787(parse);      p3650.format = e1787(parse);           parse.c3646--;       g1790(parse, p3650);     return p3650; }    function g1779(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const d3649 = new k2005(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(d3649, parse, ignore);       if (ignore)      {         g1790(parse, d3649);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         d3649.input = e1787(parse);      d3649.base      = e1787(parse);     d3649.decimals  = e1787(parse);     d3649.thousands = e1787(parse);           parse.c3646--;       g1790(parse, d3649);     return d3649; }    function a1780(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const text2col = new g2004(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          h2123(text2col, parse, ignore);       if (ignore)      {         g1790(parse, text2col);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         text2col.input = e1787(parse);           parse.c3646--;       g1790(parse, text2col);     return text2col; }    function o1781(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const split = new r2002(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(split, parse, ignore, r4208);       if (ignore)      {         g1790(parse, split);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         split.input = e1787(parse);      split.separator = e1787(parse);           parse.c3646--;       g1790(parse, split);     return split; }    function z1782(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const csv = new z1995(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(csv, parse, ignore, r4208);       if (ignore)      {         g1790(parse, csv);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         csv.input = e1787(parse);      csv.j3647    = e1787(parse);     csv.n3648 = e1787(parse);           parse.c3646--;       g1790(parse, csv);     return csv; }    function j3703(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const json = new GTextJson(nodeId, options);          let r4208 = -1;          if (!ignore)     {         r4208 = parseInt(parse.move());         c952(r4208 == 0 || r4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          h2123(json, parse, ignore, r4208);       if (ignore)      {         g1790(parse, json);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       if (r4208 == 1)         json.input = e1787(parse);           parse.c3646--;       g1790(parse, json);     return json; }    function m1783(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const fetch = new n1996(nodeId, options);          if (parse.settings.logRequests)          h2123(fetch, parse, ignore);       if (ignore)      {         g1790(parse, fetch);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       fetch.request     = e1787(parse);     fetch.a4211 = e1787(parse);           parse.c3646--;       g1790(parse, fetch);     return fetch; }    function p1784(parse) {     const [, nodeId, options, ignore] = a1789(parse);       const file = new j1997(nodeId, options);          if (parse.settings.logRequests)          h2123(file, parse, ignore);       if (ignore)      {         g1790(parse, file);         return parse.c4242.find(n => n.nodeId == nodeId);     }       parse.c3646++;       file.a4211 = e1787(parse);                parse.c3646--;       g1790(parse, file);     return file; }


class m1785 {     request;     f2066;          pos;      so;      settings = {};      save;       log  = '';          c3646 = 0;      get tab() { return this.t1788 ? ' ' : (t872 + y870.repeat(Math.max(0, this.c3646))); }           t1788 = false;       evalAccumulate = true;     evalFeedback   = true;           l4018;     c4019;      viewportZoom;      n3638 = 0;     s3639   = 0;      scope           = [];      c4242     = [];            repeats         = [];        n3640    = false;           p3641    = [];        j2875    = [];     c3095    = [];     e3642   = [];     l3643    = [];            get next() { return this.request[this.pos]; }      get b3645()      {          return this.pos+1 < this.request.length               ? this.request[this.pos+1]              : null;     }        constructor(request, e3644, f2066, l4018, c4019, viewportZoom, settings, save)     {         this.request       = request;         this.f2066     = f2066;                    this.pos           = e3644;          this.so            = 0;                  this.l4018  = l4018;          this.c4019 = c4019;             this.viewportZoom  = viewportZoom;          this.settings      = settings;          this.save          = save;     }        move()     {                   const token = this.request[this.pos++];                  return token;     }        k1786()      {         return isEmpty(this.repeats)             ||    this.repeats.length == 1                && this.repeats[0].currentIteration == this.repeats[0].total-1;     }  }    function e1787(parse, t1788 = true) {           if (!t1788)         parse.t1788 = false;       let result = null;            if (parse.next == PARAM                  ) result = l1793             (parse);              else if (parse.next ==        z1056                        || parse.next == f1057                        || parse.next ==   g1058                        || parse.next ==  a1059      ) result = f1634         (parse);       else if (parse.next == o1060              ) result = t1631              (parse);     else if (parse.next == o1061               ) result = q1632          (parse);     else if (parse.next == l1062         ) result = l1633     (parse);     else if (parse.next == z1084                ) result = u1653            (parse);     else if (parse.next == s1063               ) result = y1654          (parse);     else if (parse.next == e1064                 ) result = m1655            (parse);     else if (parse.next == m1065                  ) result = s1656             (parse);     else if (parse.next == o1086                ) result = genParseIterate           (parse);     else if (parse.next == p1066                 ) result = h1657            (parse);     else if (parse.next == v1067                  ) result = t1658             (parse);     else if (parse.next == d1068             ) result = z1659         (parse);     else if (parse.next == j1352   ) result = genParseGetListValueNames (parse);     else if (parse.next == l1353       ) result = genParseListValueNames    (parse);     else if (parse.next == p1354            ) result = genParseObjectName        (parse);      else if (parse.next == v1069                ) result = m1635           (parse);     else if (parse.next == t1070           ) result = b1636        (parse);     else if (parse.next == j1071                ) result = g1637           (parse);     else if (parse.next == z1072              ) result = g1638          (parse);     else if (parse.next == q1073              ) result = s1639          (parse);     else if (parse.next == f1074                ) result = d1640           (parse);     else if (parse.next == k1075                 ) result = i1641            (parse);     else if (parse.next == y1349           ) result = h1642       (parse);     else if (parse.next == x1350             ) result = v1643         (parse);     else if (parse.next == u1076           ) result = r1644       (parse);     else if (parse.next == j1351            ) result = genParseBuckleList        (parse);     else if (parse.next == l1077                   ) result = d1645              (parse);     else if (parse.next == s1085                 ) result = w1646            (parse);     else if (parse.next == y1078                 ) result = c1647            (parse);     else if (parse.next == v1079                   ) result = t1648              (parse);     else if (parse.next == k1080                   ) result = v1649              (parse);     else if (parse.next == p1083                 ) result = e1650            (parse);     else if (parse.next == f1360       ) result = genParseSelectFromList    (parse);     else if (parse.next == n1081             ) result = w1651         (parse);     else if (parse.next == OBJECT_COUNT           ) result = genParseObjectCount       (parse);     else if (parse.next == x1082               ) result = h1652      (parse);           else if (parse.next == m1091           ) result = u1690          (parse);     else if (parse.next == s1092                 ) result = t1691            (parse);     else if (parse.next == b1355       ) result = genParseSetPrecision      (parse);     else if (parse.next == l1093            ) result = v1694              (parse);     else if (parse.next == v1094        ) result = p1695          (parse);     else if (parse.next == i1356        ) result = genParseNegative          (parse);     else if (parse.next == t1095           ) result = x1696             (parse);     else if (parse.next == n1357        ) result = genParseQuantize          (parse);     else if (parse.next == u1097          ) result = d1698            (parse);     else if (parse.next == m1096   ) result = d1697      (parse);     else if (parse.next == d1098          ) result = v1699            (parse);     else if (parse.next == z1099           ) result = u1700       (parse);     else if (parse.next == m1358             ) result = genParseNumberMap         (parse);     else if (parse.next == j1359            ) result = genParseNumberBias        (parse);     else if (parse.next == l1100             ) result = t1701       (parse);     else if (parse.next == c1101        ) result = n1692          (parse);     else if (parse.next == l1102        ) result = g1693          (parse);     else if (parse.next == a1103        ) result = w1709          (parse);     else if (parse.next == g1104           ) result = u1707             (parse);     else if (parse.next == a1105            ) result = c1708              (parse);     else if (parse.next == e1106          ) result = f1710            (parse);     else if (parse.next == d1107           ) result = k1711             (parse);     else if (parse.next == h1108            ) result = i1712       (parse);     else if (parse.next == m1109      ) result = q1713        (parse);     else if (parse.next == HOLD                   ) result = genParseHold              (parse);     else if (parse.next == s1110     ) result = u1714       (parse);     else if (parse.next == o1111           ) result = m1721             (parse);     else if (parse.next == g1112         ) result = p1722           (parse);          else if (parse.next == p1114            ) result = t1702              (parse, (nodeId, options) => new g1901          (nodeId, options));     else if (parse.next == k1113     ) result = j1703        (parse, (nodeId, options) => new g1901          (nodeId, options));     else if (parse.next == b1115             ) result = p1704        (parse, (nodeId, options) => new i1897           (nodeId, options));     else if (parse.next == q1116        ) result = p1704        (parse, (nodeId, options) => new h1905      (nodeId, options));     else if (parse.next == w1117        ) result = p1704        (parse, (nodeId, options) => new y1903      (nodeId, options));     else if (parse.next == s1118          ) result = p1704        (parse, (nodeId, options) => new x1899        (nodeId, options));     else if (parse.next == m1119          ) result = p1704        (parse, (nodeId, options) => new j1902        (nodeId, options));     else if (parse.next == x1120        ) result = p1704        (parse, (nodeId, options) => new t1900      (nodeId, options));           else if (parse.next == g1121         ) result = q1715           (parse);     else if (parse.next == a1122             ) result = p1704        (parse, (nodeId, options) => new a1908           (nodeId, options));     else if (parse.next == f1123             ) result = p1704        (parse, (nodeId, options) => new t1906           (nodeId, options));     else if (parse.next == d1124              ) result = p1704        (parse, (nodeId, options) => new r1909            (nodeId, options));     else if (parse.next == h1125             ) result = p1704        (parse, (nodeId, options) => new y1910           (nodeId, options));           else if (parse.next == q1126       ) result = c1716         (parse);     else if (parse.next == o1127           ) result = f1717     (parse, (nodeId, options) => new m1912         (nodeId, options));     else if (parse.next == v1128       ) result = f1717     (parse, (nodeId, options) => new b1917      (nodeId, options));     else if (parse.next == l1129            ) result = f1717     (parse, (nodeId, options) => new w1915          (nodeId, options));     else if (parse.next == y1130   ) result = f1717     (parse, (nodeId, options) => new a1916   (nodeId, options));     else if (parse.next == z1131         ) result = f1717     (parse, (nodeId, options) => new v1913       (nodeId, options));     else if (parse.next == i1132) result = f1717     (parse, (nodeId, options) => new f1914(nodeId, options));       else if (parse.next == z1133            ) result = l1718     (parse);     else if (parse.next == j1134             ) result = c1719          (parse, (nodeId, options) => new v1920          (nodeId, options));     else if (parse.next == i1135             ) result = c1719          (parse, (nodeId, options) => new d1919        (nodeId, options));     else if (parse.next == c1136             ) result = c1719          (parse, (nodeId, options) => new c1921       (nodeId, options));     else if (parse.next == x1137           ) result = k1720             (parse, (nodeId, options) => new c1921       (nodeId, options));      else if (parse.next == j1138          ) result = f1705      (parse);       else if (parse.next == i1143             ) result = a1763         (parse);     else if (parse.next == e1144                   ) result = r1764              (parse);     else if (parse.next == d1145            ) result = c1765        (parse);     else if (parse.next == f1146              ) result = f1766          (parse);     else if (parse.next == i1147         ) result = e1767     (parse);     else if (parse.next == v1148          ) result = i1768      (parse);     else if (parse.next == t1149              ) result = k1769          (parse);     else if (parse.next == b1154              ) result = q1774   (parse);     else if (parse.next == f1155           ) result = t1775   (parse);     else if (parse.next == c1156          ) result = s1776       (parse);     else if (parse.next == g1157         ) result = y1777      (parse);     else if (parse.next == w1158          ) result = d1778       (parse);     else if (parse.next == z1159         ) result = g1779      (parse);     else if (parse.next == j1160          ) result = a1780       (parse);     else if (parse.next == d1150           ) result = c1770       (parse);     else if (parse.next == q1151              ) result = b1771          (parse);     else if (parse.next == c1152               ) result = q1772           (parse);     else if (parse.next == r1153           ) result = x1773       (parse);     else if (parse.next == p1161             ) result = o1781         (parse);     else if (parse.next == v1163               ) result = z1782           (parse);     else if (parse.next == z3504              ) result = j3703          (parse);     else if (parse.next == o1164             ) result = m1783         (parse);     else if (parse.next == t1165              ) result = p1784          (parse);       else if (parse.next == a1168            ) result = e1622        (parse);     else if (parse.next == g1169                  ) result = q1623             (parse);     else if (parse.next == y1170            ) result = g1624        (parse);     else if (parse.next == t1171          ) result = b1625      (parse);     else if (parse.next == s1173         ) result = j1626     (parse);     else if (parse.next == n1172       ) result = f1627    (parse);     else if (parse.next == y1174             ) result = b1628        (parse);     else if (parse.next == m1175      ) result = w1629  (parse);     else if (parse.next == d1176            ) result = m1630        (parse);            else if (parse.next == a1178             ) result = w1665         (parse);     else if (parse.next == a1179                   ) result = j1666              (parse);            else if (parse.next == i1184       ) result = f1670    (parse);     else if (parse.next == i1185             ) result = y1671         (parse);            else if (parse.next == q1187         ) result = j1668     (parse);     else if (parse.next == y1188               ) result = k1669          (parse);            else if (parse.next == i1181           ) result = s1672       (parse);     else if (parse.next == s1182                 ) result = n1673            (parse);            else if (parse.next == g1190     ) result = genParseStrokeSidesValue  (parse);     else if (parse.next == w1191           ) result = genParseStrokeSides       (parse);            else if (parse.next == j1193    ) result = c1675 (parse);     else if (parse.next == q1194          ) result = g1676      (parse);            else if (parse.next == d1196      ) result = i1677   (parse);     else if (parse.next == h1197            ) result = z1678        (parse);            else if (parse.next == l1199     ) result = c1679  (parse);     else if (parse.next == x1200           ) result = e1680       (parse);            else if (parse.next == h1202       ) result = g1681    (parse);     else if (parse.next == o1203             ) result = l1682         (parse);            else if (parse.next == k1205        ) result = f1683     (parse);     else if (parse.next == d1206              ) result = s1684          (parse);      else if (parse.next == k1211      ) result = p1685   (parse);     else if (parse.next == f1212            ) result = l1686        (parse);            else if (parse.next == t1208       ) result = w1687    (parse);     else if (parse.next == o1209             ) result = n1688         (parse);            else if (parse.next == w1216            ) result = c1762        (parse);            else if (parse.next == g1219              ) result = q1723         (parse);          else if (parse.next == i1222                   ) result = q1724              (parse);     else if (parse.next == c1225                ) result = l1725           (parse);     else if (parse.next == c1228                ) result = l1726           (parse);     else if (parse.next == e1237                ) result = l1727           (parse);     else if (parse.next == f1240                   ) result = r1728              (parse);     else if (parse.next == k1243             ) result = b1729         (parse);       else if (parse.next == v1245            ) result = e1730        (parse);     else if (parse.next == q1246                  ) result = d1731             (parse);     else if (parse.next == m1248           ) result = f1732       (parse);     else if (parse.next == q1249      ) result = e1733   (parse);     else if (parse.next == b1250            ) result = i1734        (parse);          else if (parse.next == u1252    ) result = k1735 (parse);     else if (parse.next == o1253          ) result = n1736      (parse);     else if (parse.next == i1255      ) result = b1737   (parse);     else if (parse.next == p1256            ) result = p1738        (parse);     else if (parse.next == o1258    ) result = n1739 (parse);     else if (parse.next == s1259          ) result = l1740      (parse);     else if (parse.next == z1261   ) result = q1741(parse);     else if (parse.next == h1262         ) result = t1742     (parse);      else if (parse.next == i1287    ) result = r3838 (parse);     else if (parse.next == b1286          ) result = r1743      (parse);      else if (parse.next == v1231         ) result = genParseArcPathValue      (parse);     else if (parse.next == j1230               ) result = genParseArcPath           (parse);      else if (parse.next == c1234        ) result = genParseWavePathValue     (parse);     else if (parse.next == o1233              ) result = genParseWavePath          (parse);      else if (parse.next == f1264      ) result = p3839   (parse);     else if (parse.next == g1265            ) result = m1744        (parse);       else if (parse.next == q1267            ) result = h3840        (parse);     else if (parse.next == t1268                  ) result = k1745             (parse);       else if (parse.next == y1270                   ) result = l1746              (parse);     else if (parse.next == s1271                 ) result = w1747            (parse);     else if (parse.next == z1272                  ) result = l1748             (parse);     else if (parse.next == o1273                   ) result = e1749              (parse);      else if (parse.next == SHOW_CENTER            ) result = genParseShowCenter        (parse);     else if (parse.next == a1274             ) result = m1750            (parse);     else if (parse.next == j1275            ) result = r1751    (parse);      else if (parse.next == PATH_LENGTH            ) result = genParsePathLength        (parse);     else if (parse.next == JOIN_PATHS             ) result = genParseJoinPaths         (parse);     else if (parse.next == REORIENT_PATHS         ) result = genParseReorientPaths     (parse);     else if (parse.next == v1278         ) result = s1752     (parse);     else if (parse.next == e1279            ) result = a1753        (parse);     else if (parse.next == l1280                 ) result = k1754            (parse);     else if (parse.next == l1281          ) result = h1755      (parse);     else if (parse.next == ARC_FROM_POINTS        ) result = genParseArcFromPoints     (parse);     else if (parse.next == r1282        ) result = e1756    (parse);     else if (parse.next == m1283      ) result = c1757  (parse);     else if (parse.next == y1284       ) result = genParsePointAlongPath    (parse);     else if (parse.next == l1285  ) result = genParseClosestPointOnPath(parse);     else if (parse.next == REVERSE_PATH           ) result = genParseReversePath       (parse);     else if (parse.next == BLEND_PATH             ) result = genParseBlendPath         (parse);      else if (parse.next == s1276                  ) result = d1759             (parse);     else if (parse.next == x1277            ) result = t1760        (parse);          else if (parse.next == n1293                 ) result = s1761            (parse);     else if (parse.next == EXPORT                 ) result = genParseExport            (parse);       else if (parse.next == f1298             ) result = d1663         (parse);     else if (parse.next == u1299            ) result = s1664        (parse);       else if (parse.next == z1301                ) result = x1660           (parse);     else if (parse.next == m1302          ) result = o1661      (parse);     else if (parse.next == s1303                  ) result = l1662             (parse);      else c953('unknown parse token \'' + parse.next + '\' @ ' + parse.pos);       parse.t1788 = false;       if (result)         return result;     else     {         parse.so++;         return null;     } }    function a1789(parse) {     const type     = parse.move();     const nodeId   = parse.move();     const nodeName = parse.move();           parse.scope.push(nodeId);       if (parse.c4242.find(n => n.nodeId == nodeId))         return [type, nodeId, {nodeName: nodeName}, true];       const options = l1791(parse);      options.nodeName = nodeName;       return [type, nodeId, options, false]; }    function g1790(parse, node = null) {     parse.scope.pop();      if (node)     {         if (isEmpty(parse.scope))             node.topLevel = true;          e949(parse.c4242, node);     } }    function l1791(parse) {     const opt = parseInt(parse.move());      const options =      {         active:       ((opt >>  0) & 1) != 0,         d2997: ((opt >>  1) & 1) != 0,         beforeList:   ((opt >>  2) & 1) != 0,         enabled:      ((opt >>  3) & 1) != 0,         cached:       ((opt >>  4) & 1) != 0,         unknown:      ((opt >>  5) & 1) != 0,         notCondition: ((opt >>  6) & 1) != 0,         p3264:    ((opt >> 20) & 1) != 0,         existing:     ((opt >> 21) & 1) != 0     };      return options; }    function i1792(parse) {     const d3667 = parseInt(parse.move());      if (parse.settings.logRequests)          parse.log += parse.tab + d3667;      return d3667; }    function l1793(parse) {     if (parse.next != PARAM)          return null;              parse.move();      const type = parse.move();            const nodeId  = parse.move();     const v2991 = parse.move();          const param   = new b2048(nodeId, v2991);        e949(parse.p3641, nodeId);       if (parse.settings.logRequests)          r2127(param, type, parse);       return param; }    function t1794(parse) {     const v2991 = parse.move();      if (parse.settings.logRequests)         parse.log += parse.tab + v2991;      return v2991; }


class j2131 {     request;     pos;      so            = 0;     c3646          = 0;        skipNewLine   = false;      loggedNodeIds = [];            constructor(request, pos)     {         this.request = request;         this.pos     = pos;     }       get tab()      {          if (this.skipNewLine)         {             this.skipNewLine = false;             return '';         }         else              return t872 + y870.repeat(Math.max(0, this.c3646));      } }    function log(str) {     b3881.innerHTML = str; }    function o2132(z2133, g111 = null) {     let str = z2133;      if (g111)         str = g111.id + '.' + str;      console.log(         '%c ' + str + ' ',          'background: #fc0; color: #632;'); }    function l2134(str, color = 'white', background = 'red') {     console.log(         '%c ' + str + ' ',          'background: ' + background + '; color: ' + color + ';'); }    function logValueUpdates(l4018, c4019, values) {           let log     = '';     let newLine = true;      if (   l4018  != ''          || c4019 != '')         log = '↓ ' + v2125(l4018) + '.' + v2125(c4019);     else         newLine = false;                 let i    = 0;     let c3646 = 0;      while (i < values.length)     {         const nodeId  = values[i++];         const r4208 = parseInt(values[i++]);          log +=                (newLine ? t872 : '') + y870.repeat(Math.max(0, c3646))             + nodeId;          newLine = true;          c3646++;          for (let j = 0; j < r4208; j++)         {             const index = values[i++];             const type  = values[i++];             const value = values[i++];              log +=                    t872 + y870.repeat(Math.max(0, c3646))                 + index + ' ' + q4209(type, value);         }          c3646--;     }       console.log(         '%c%s',          'background: #e70; color: white;',          log); }    function logObjectUpdates(objects) {     console.log(         '%cobjects',          'background: #07e; color: white;',          objects); }    function logStyleUpdates(styles) {     console.log(         '%cstyles',          'background: #b4d; color: white;',          styles); }    function b2135(pageJson) {     console.log('%cSAVING PAGES\n' + pageJson, 'color: black; background: #ddeeee;'); }    function f2136(nodeJson) {     console.log('%cSAVING NODES\n' + nodeJson, 'color: black; background: #ddeeff;'); }    function y2137(s2138) {     let log = 'SAVING ' + s2138.length + ' ' + t4015(s2138.length, 'CONNECTION');      for (const d243 of s2138)         log += '\n' + d243.n2118();      console.log(         '%c' + log,          'color: black; background: #ddeeff;'); }    function m2139(s2138) {     let log = 'UPDATING ' + s2138.length + ' ' + t4015(s2138.length, 'SAVED CONNECTION');      for (const d243 of s2138)         log += '\n' + d243.n2118();      console.log(         '%c' + log,          'color: black; background: #ddeeff;'); }    function m2140() {     let log =          'UNDO STACK:\n'         + r2885.actions.map(a => '    ' + a.name).join('\n');      console.log('%c%s', 'background: #ffd; color: #b80;', log); }    function u2141() {     let log =           'REDO STACK:\n'         + r2885.e2887.map(a => '    ' + a.name).join('\n');      console.log('%c%s', 'background: #fff4e8; color: #c64;', log); }


function x2122(parse) {     let log = '';      if (   parse.l4018  != ''          || parse.c4019 != '')         log = '↓ ' + v2125(parse.l4018) + '.' + v2125(parse.c4019);      log += parse.log;      console.log(         '%c%s',          'background: #60aa60; color: #fff',           log); }    function h2123(node, parse, ignore, r4208 = -1) {     parse.log += parse.tab + node.type;     parse.log += d2124(node, ignore);      if (    r4208 > -1         && !ignore)         parse.log += ' ' + r4208; }    function d2124(node, ignore = false) {     return ' '           + v2125(node.nodeId)           + ' ' + v2125(node.nodeName)          + (!ignore             ? s2126(node)             : ''); }    function v2125(nodeId) {     return nodeId == '' ? '\'\'' : nodeId; }    function s2126(node) {     let log = '';      if ( node.options.active      ) log += ' ' + r1304;     if ( node.options.d2997) log += ' ' + i1305;     if ( node.options.beforeList  ) log += ' ' + x1306;     if (!node.options.enabled     ) log += ' ' + f1307;      if (!node.cached              ) log += ' ' + n1308;      return log; }    function r2127(param, type, parse) {     parse.log +=                  parse.tab + PARAM         + ' ' + type          + ' ' + v2125(param.nodeId)          + '.' + v2125(param.v2991); }    function d2128(node, parse) {     parse.log += parse.tab + node.type;     parse.log += d2124(node); }    function m2129(r1035, r4208, w3681, parse, ignore) {     parse.log += parse.tab + s1173;     parse.log += d2124(r1035, ignore);      if (!ignore)     {         parse.log += ' ' + r4208;          if (r4208 == 1)             parse.log += ' ' + w3681;     } }    function a2130(type, val, parse) {     parse.log += parse.tab + type + ' ' + q4209(type, val); }                                           


async function logSavedNode(nodeKey, i4006) {     const log  = k2119(await e1563(nodeKey, false));      if (i4006)     {         console.log(             '%c%s\n%c%s',              'background: #fa24; color: white;',              x1054(nodeKey),              'background: #fa44; color: #edc;',             log);     }     else     {         console.log(             '%c%s\n%c%s',              'background: #fdb; color: black;',              x1054(nodeKey),              'background: #fed; color: black;',             log);     } }    function k2119(json) {     let r4032 = json         .replace('{\n', '')         .replace('\n}', '')          .replace('[\n' + y870, '')         .replace('\n' + y870 + ']', '')          .split(y870 + '"params":\n').join('')           .split('": "').join(': ')         .split('", "').join(': ')          .split(y870 + '"').join(y870)         .split(y870 + y870 + '["').join(y870 + y870)                  .split('",\n').join('\n')         .split('"\n').join('\n')                  .split('"],\n').join('\n');       if (r4032[r4032.length-1] == '"')         r4032 = r4032.substring(0, r4032.length - 1);      if (r4032.substring(r4032.length-2) == '"]')             r4032 = r4032.substring(0, r4032.length - 2);      return r4032; }    function v2120(json) {     let r4032 = json         .replace('{\n', '')         .replace('\n}', '')         .replace('[\n' + y870, '')         .replace('\n' + y870 + ']', '');      return r4032; }    function m2121(d243, i4006) {     const o4210 = w924(d243, true);      if (i4006)     {         console.log(             '%c%s',              'background: #4f44; color: #ded',              o4210);      }     else     {         console.log(             '%c%s',              'background: #cfc; color: black;',              o4210);      } }


  const D65 = [0.95047, 1, 1.08883];    function j31(R, G, B, Y, W, gamma, degamma, regamma, luminance) {     return {             R:         R,         G:         G,         B:         B,          Y:         Y,          W:         W,          m3974:   o32(R, G, B, W),         xyz2lin:   r891(o32(R, G, B, W)),          gamma:     gamma,                  degamma:   degamma,         regamma:   regamma,                  luminance: luminance     }; }   function o32(R, G, B, W) {     const C0 = y33(R);     const C1 = y33(G);     const C2 = y33(B);      const M = [ [ C0[0], C1[0], C2[0] ],                  [ C0[1], C1[1], C2[1] ],                  [ C0[2], C1[2], C2[2] ] ];      const S = q948(W, r891(M));      return [ [ S[0]*C0[0], S[1]*C1[0], S[2]*C2[0] ],              [ S[0]*C0[1], S[1]*C1[1], S[2]*C2[1] ],              [ S[0]*C0[2], S[1]*C1[2], S[2]*C2[2] ] ]; }   function y33(c) {     const x = c[0],           y = c[1];      return [x/y, 1, (1-x-y)/y]; } 


const k36 = j31 (     [0.64, 0.33],      [0.3,  0.6 ],      [0.15, 0.06],       [0.212656,      0.715158,      0.072186],       D65,              2.4,                function(v)      {         return v >= 0.04045                ? Math.pow((v + 0.055) / 1.055, this.gamma)                : v / 12.92;     },            function(v)      {         return v > 0.0031308                ? 1.055 * Math.pow(v, 1/this.gamma) - 0.055                : v * 12.92;     },                function(rgb)      {         return  this.Y[0] * this.degamma(rgb[0])                + this.Y[1] * this.degamma(rgb[1])                + this.Y[2] * this.degamma(rgb[2]);     } ); 


function m66(rgb, amount) {     const hsv = m52(rgb);     hsv[2] *= amount;     return a54(hsv); }    function i67(rgb, amount) {     const hsv = m52(rgb);     hsv[1] *= amount;     return a54(hsv); }    function w68(rgb, amount) {     const hsl = e48(rgb);     hsl[1] *= amount;     return o50(hsl); }


function s51(r, g, b) {     let h, s, v;      let min = Math.min(Math.min(r, g), b),         max = Math.max(Math.max(r, g), b);      let delta = max - min;      v = max;     s = max == 0 ? 0 : delta / max; 	     if      (max == r) h = 1/6 * (g - b) / delta + 1;        else if (max == g) h = 1/6 * (b - r) / delta + 1/3;      else if (max == b) h = 1/6 * (r - g) / delta + 2/3;   	if (h > 1) h -= 1; 	      return [h, s, v]; }    function m52(rgb) {     return s51(rgb[0], rgb[1], rgb[2]); }    function z53(h, s, v) {     while (h < 0) h++;     h %= 1;      if (s == 0)         return [v, v, v];       h *= 6 - 0.0000001;      let i = Math.floor(h);     let f = h - i; 	     let p = v * (1 - s);     let q = v * (1 - s * f);     let t = v * (1 - s * (1 - f));      switch (i)     {         case 0:  return [v, t, p];         case 1:  return [q, v, p];         case 2:  return [p, v, t];         case 3:  return [p, q, v];         case 4:  return [t, p, v];         default: return [v, p, q];     } }    function a54(hsv) { 	return z53(hsv[0], hsv[1], hsv[2]); }


function k47(r, g, b) {     let h, s, l;      let min = Math.min(Math.min(r, g), b),         max = Math.max(Math.max(r, g), b);      let delta = max - min;      l = (max + min) / 2;           if (max == min) h = 0;     else if (max == r  ) h = 1/6 * (g - b) / delta + 1;     else if (max == g  ) h = 1/6 * (b - r) / delta + 1/3;     else if (max == b  ) h = 1/6 * (r - g) / delta + 2/3;           if (max == min) s = 0;     else if (l <= 0.5)   s = delta / (2 * l);     else if (l >  0.5)   s = delta / (2 - 2 * l);      return [h, s, l]; }    function e48(rgb) {     return k47(rgb[0], rgb[1], rgb[2]); }    function x49(h, s, l) {     while (h < 0) h++;     h %= 1;      let q =         l < 0.5         ? l * (1 + s)         : l + s - l * s;      let p = 2 * l - q;      let tr = h + 1/3;     let tg = h;     let tb = h - 1/3;      if (tr < 0) tr += 1; if (tr > 1) tr -= 1;     if (tg < 0) tg += 1; if (tg > 1) tg -= 1;     if (tb < 0) tb += 1; if (tb > 1) tb -= 1;      let r, g, b;      let qp6 = (q - p) * 6;            if (tr <  1/6)				r = p + qp6 * tr;     else if (tr >= 1/6 && tr < 0.5)	r = q;     else if (tr >= 0.5 && tr < 2/3)	r = p + qp6 * (2/3 - tr);     else							r = p; 	          if (tg <  1/6)				g = p + qp6 * tg;     else if (tg >= 1/6 && tg < 0.5)	g = q;     else if (tg >= 0.5 && tg < 2/3) g = p + qp6 * (2/3 - tg);     else							g = p;           if (tb <  1/6)				b = p + qp6 * tb;     else if (tb >= 1/6 && tb < 0.5) b = q;     else if (tb >= 0.5 && tb < 2/3) b = p + qp6 * (2/3 - tb);     else							b = p;      return [r, g, b]; }    function o50(hsl) {     return x49(hsl[0], hsl[1], hsl[2]); }


function j59(xyz) {     return q948(xyz, CAT); }    function n60(lms) {     return q948(lms, invCAT); } 


function v69(rgb, cs = k36) {      return q70(degamma(rgb, cs), cs); }        function q70(rgb, cs = k36) {     return q948(rgb, cs.m3974); }            function x71(xyz, cs = k36) {     return regamma(f72(xyz, cs), cs); }    function f72(xyz, cs = k36) {     return q948(xyz, cs.xyz2lin); }


function s3976(rgb, cs = k36) {     return b3978(v69(rgb, cs), cs.W); }    function e3977(luv, cs = k36) {     return x71(h3979(luv, cs.W), cs); }    function b3978(xyz, W = k36.W) {     const x = xyz[0],            y = xyz[1],            z = xyz[2];      const e = cube(6/29);     const k = cube(29/3);      const yw = y / W[1];      let l =          yw > e         ? 116 * Math.cbrt(yw) - 16         : k * yw;      const u_ = 4*x / (x + 15*y + 3*z);     const v_ = 9*y / (x + 15*y + 3*z);          const uw = 4*W[0] / (W[0] + 15*W[1] + 3*W[2]);     const vw = 9*W[1] / (W[0] + 15*W[1] + 3*W[2]);          const u = 13*l * (u_ - uw);     const v = 13*l * (v_ - vw);      return [         l / 100,          u / 100,          v / 100]; }    function h3979(luv, W = k36.W) {     let l = luv[0] * 100,          u = luv[1] * 100,          v = luv[2] * 100;      const e = cube(6/29);         const k = cube(29/3);      const uw = 4*W[0] / (W[0] + 15*W[1] + 3*W[2]);     const vw = 9*W[1] / (W[0] + 15*W[1] + 3*W[2]);          const y =          l > e*k         ? cube((l + 16) / 116)         : l / k;          const a = (52*l / nozero(u + 13*l*uw) - 1) / 3;     const b = -5 * y;     const c = -1/3;     const d =  y * (39*l / nozero(v + 13*l*vw) - 5);      const x = (d - b) / nozero(a - c);      const z = x*a + b;      return [x, y, z]; }


function c55(rgb, cs = k36) {     return g57(v69(rgb, cs), cs.W); }    function u56(lab, cs = k36) {     return x71(x58(lab, cs.W), cs); }    function g57(xyz, W = k36.W) {     const x = xyz[0],            y = xyz[1],            z = xyz[2];      const e = 0.008856;      const k = 903.3;          let xw = x / W[0];     let yw = y / W[1];     let zw = z / W[2];      xw = xw > e ? Math.cbrt(xw) : (k / 100 * xw + 0.16) / 1.16;     yw = yw > e ? Math.cbrt(yw) : (k / 100 * yw + 0.16) / 1.16;     zw = zw > e ? Math.cbrt(zw) : (k / 100 * zw + 0.16) / 1.16;       const l = (1.16 * yw) - 0.16;     const a = 5 * (xw - yw);     const b = 2 * (yw - zw);      return [l, a, b]; }    function x58(lab, W = k36.W) {     const l = lab[0],            a = lab[1],            b = lab[2];      const e = 0.008856 / 100;      const k = 903.3    / 100;       const yw = (l + 0.16)/1.16;     const xw = a/5 + yw;     const zw = yw - b/2;      let x = cube(xw) > e ? cube(xw) : (1.16*xw - 0.16) / k;     let y = cube(yw) > e ? cube(yw) : (1.16*yw - 0.16) / k;     let z = cube(zw) > e ? cube(zw) : (1.16*zw - 0.16) / k;      x *= W[0];     y *= W[1];     z *= W[2];       return [x, y, z]; }


function o3980(rgb, cs = k36) {     return u3981(rgb[0], rgb[1], rgb[2], cs); }    function u3981(r, g, b, cs = k36)  {     return j3983(i3982(r, g, b, cs)); }    function i3982(r, g, b, cs = k36)  {     r = cs.degamma(r);     g = cs.degamma(g);     b = cs.degamma(b);      return [         0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b, 	    0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b, 	    0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b ]; }            function j3983(lms)  {     const l = Math.cbrt(lms[0]);     const m = Math.cbrt(lms[1]);     const s = Math.cbrt(lms[2]);      const l_ = 0.2104542553 * l + 0.7936177850 * m - 0.0040720468 * s;     const a_ = 1.9779984951 * l - 2.4285922050 * m + 0.4505937099 * s;     const b_ = 0.0259040371 * l + 0.7827717662 * m - 0.8086757660 * s;      return [         l_,         a_,          b_ ]; }            function n3984(lab, cs = k36) {     return k3988(f3986(lab), cs); }    function v3985(l, a, b, cs = k36)  {     return n3984([l, a, b], cs); }    function f3986(lab) {     return f3987(lab[0], lab[1], lab[2]); }    function f3987(l, a, b)  {     return [         l + 0.3963377774 * a + 0.2158037573 * b,         l - 0.1055613458 * a - 0.0638541728 * b,         l - 0.0894841775 * a - 1.2914855480 * b ]; }    function k3988(lms, cs = k36)  {     const l = cube(lms[0]);     const m = cube(lms[1]);     const s = cube(lms[2]);  	const r =  4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s; 	const g = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s; 	const b = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s;      return [         cs.regamma(r),         cs.regamma(g),         cs.regamma(b) ]; }


const h65 = 0.89;   function f63(opp)  {                const l = opp[0],            a = opp[1],            b = opp[2];      const h = Math.atan2(b, a);     const c = Math.sqrt(a*a + b*b);      return [h, c, l]; }    function j64(pol)  {                const h = pol[0],            c = pol[1],            l = pol[2];      const a = c * Math.cos(h);     const b = c * Math.sin(h);      return [l, a, b]; }


function u34(hcl, cs = k36) {     hcl = [...hcl];      hcl[0] *= Tau;     hcl[1] *= hcl[2];       return n3984(j64(hcl), cs); }        function m35(h, c, l, cs = k36) {     return m35([h, c, l], cs); }                    function i37(rgb, cs = k36) {     const hcl = f63(o3980(rgb, cs));      hcl[0] /= Tau;     hcl[1] /= nozero(hcl[2]);      while (hcl[0] < 0) hcl[0] += 1;     while (hcl[0] > 1) hcl[0] -= 1;      return hcl; }    function a38(r, g, b, cs = k36) {     return i37([r, g, b], cs); }    function o39(hcl) {     hcl = [...hcl];      hcl[0] *= Tau;     hcl[1] *= hcl[2];      return j64(hcl); }    function y40(hcl, cs = k36) {     return u56(o39(hcl), cs); }    function p41(lab) {     let hcl = f63(lab);      hcl[0] /= Tau;     hcl[1] /= hcl[2];      while (hcl[0] < 0) hcl[0] += 1;     while (hcl[0] > 1) hcl[0] -= 1;      return hcl; }    function i42(rgb, cs = k36) {     return p41(c55(rgb, cs)); }    function q43(hcl) {     hcl = [...hcl];      hcl[0] *= Tau;     hcl[1] *= hcl[2];      return j64(hcl); }    function g44(hcl, cs = k36) {     return e3977(q43(hcl), cs); }    function f45(luv) {     let hcl = f63(luv);      hcl[0] /= Tau;     hcl[1] /= hcl[2];      while (hcl[0] < 0) hcl[0] += 1;     while (hcl[0] > 1) hcl[0] -= 1;      return hcl; }    function d46(rgb, cs = k36) {     return f45(s3976(rgb, cs)); }


function x61(rgb) {     const p3 =          [ [ 0.8225, 0.1774, 0      ],           [ 0.0332, 0.9669, 0      ],           [ 0.0171, 0.0724, 0.9108 ] ];      rgb = degamma(rgb);      return regamma(k1039(p3, rgb)); }    function k62(rgb)  {     const invp3 =          [ [ 1.2249, -0.2247, 0      ],           [-0.0420,  1.0419, 0      ],           [-0.0197, -0.0786, 1.0979 ] ];        rgb = k1039(invp3, degamma(rgb));        return regamma(rgb); }


const t131 =  [     ['hex',   'Hex'   ],     ['rgb',   'RGB'   ],      ['hsv',   'HSV'   ],      ['hsl',   'HSL'   ],      ['hclok', 'HCL/ok'],     ['hclab', 'HCL/ab'],     ['hcluv', 'HCL/uv'],     ['oklab', 'okLab' ],     ['lab',   'Lab'   ],     ['luv',   'Luv'   ] ];    class g132 {     hex   = Object.freeze(0);     rgb   = Object.freeze(1);     hsv   = Object.freeze(2);     hsl   = Object.freeze(3);     hclok = Object.freeze(4);     hclab = Object.freeze(5);     hcluv = Object.freeze(6);     oklab = Object.freeze(7);     lab   = Object.freeze(8);     luv   = Object.freeze(9); }    class Color extends Float32Array {     get r() { return this[0]; }     get g() { return this[1]; }     get b() { return this[2]; }     get a() { return this[3]; }     get s() { return this[4]; }      set r(r) { this[0] = r; }     set g(g) { this[1] = g; }     set b(b) { this[2] = b; }     set a(a) { this[3] = a; }     set s(s) { this[4] = s; }        constructor(c = null)     {         super(5);           if (c)         {             this.r = c.r;             this.g = c.g;             this.b = c.b;             this.a = c.a;             this.s = c.s;         }         else         {             this.r = 0;             this.g = 0;             this.b = 0;             this.a = 0;             this.s = g132.rgb;         }     } }


const w76 = 0.001;    function h146(rgb) {     const _space = 'rgb';      return [         _space,          g4175(rgb[0], _space, 0),          g4175(rgb[1], _space, 1),          g4175(rgb[2], _space, 2) ];  }    function r147(space, c1, c2, c3) {     const _space = l133(space.value);      return [         _space,          g4175(c1.value, _space, 0),          g4175(c2.value, _space, 1),          g4175(c3.value, _space, 2) ];  }    function f148(c) {     return isNaN(c[1])         || isNaN(c[2])         || isNaN(c[3]); }    function w149(col, lim = w76) {     return w75(f4194(col), lim); }    function i150(col, lim = w76) {     return k78(f4194(col), lim); }


const rgb_NaN = [     Number.NaN,     Number.NaN,     Number.NaN ];  const rgba_NaN = [     Number.NaN,     Number.NaN,     Number.NaN,     Number.NaN ];   const rgbInvalid  = [0xff, 0, 0xff]; const rgbaInvalid = [0xff, 0, 0xff, 0xff];   const q3813 = Object.freeze([     'rgb',     Number.NaN,     Number.NaN,     Number.NaN ]);            const CAT = [[ 0.7328, 0.4296, -0.1624],              [-0.7036, 1.6975,  0.0061],              [ 0.0030, 0.0136,  0.9834]];  const invCAT = r891(CAT);   const M1 = [[ 0.8189330101, 0.3618667424, -0.1288597137 ],             [ 0.0329845436, 0.9293118715,  0.0361456387 ],             [ 0.0482003018, 0.2643662691,  0.6338517070 ]];  const invM1 = r891(M1);    function g73(rgb)  {     return isNaN(rgb[0])         || isNaN(rgb[1])         || isNaN(rgb[2]); }    function h74(rgba)  {     return isNaN(rgba[0])         || isNaN(rgba[1])         || isNaN(rgba[2])         || isNaN(rgba[3]); }    function w75(rgb, lim = w76) {     return rgb[0] > -lim && rgb[0] < 1 + lim          && rgb[1] > -lim && rgb[1] < 1 + lim          && rgb[2] > -lim && rgb[2] < 1 + lim; }    function o77(rgba, lim = w76) {     return rgba[0] > -lim && rgba[0] < 1 + lim          && rgba[1] > -lim && rgba[1] < 1 + lim          && rgba[2] > -lim && rgba[2] < 1 + lim         && rgba[3] > -lim && rgba[3] < 1 + lim; }    function k78(rgb, lim = w76) {     return !g73  (rgb)         &&  w75(rgb, lim); }    function d79(rgba, lim = w76) {     return !h74  (rgba)         &&  o77(rgba, lim); }    function y80(rgb) {     return [         Math.min(Math.max(0, rgb[0]), 1),         Math.min(Math.max(0, rgb[1]), 1),         Math.min(Math.max(0, rgb[2]), 1) ]; }    function i81(e82, i83, t) {     return [ r1035(e82[0], i83[0], t),              r1035(e82[1], i83[1], t),              r1035(e82[2], i83[2], t) ]; }    function w84(z3801, rgba2, t) {     return [ r1035(z3801[0], rgba2[0], t),              r1035(z3801[1], rgba2[1], t),              r1035(z3801[2], rgba2[2], t),              r1035(z3801[3], rgba2[3], t) ]; }    function l85(e82, i83) {     return [ e82[0] + i83[0],              e82[1] + i83[1],              e82[2] + i83[2] ]; }    function rgbaAdd(z3801, rgba2) {     return [ z3801[0] + rgba2[0],              z3801[1] + rgba2[1],              z3801[2] + rgba2[2],              z3801[3] + rgba2[3] ]; }    function w86(e82, i83) {     return [ e82[0] - i83[0],              e82[1] - i83[1],              e82[2] - i83[2] ]; }    function p87(rgb, s) {     return [ rgb[0] * s,              rgb[1] * s,              rgb[2] * s ]; }    function rgbaMuls(rgba, s) {     return [ rgba[0] * s,              rgba[1] * s,              rgba[2] * s,              rgba[3] * s ]; }    function x88(e82, i83) {     return [ (e82[0] + i83[0]) / 2,              (e82[1] + i83[1]) / 2,              (e82[2] + i83[2]) / 2 ]; }    function r89(e82, i83) {     return [ Math.max(e82[0], i83[0]),              Math.max(e82[1], i83[1]),              Math.max(e82[2], i83[2]) ]; }    function r90(col, p) {     return [         Math.pow(col[0], p),          Math.pow(col[1], p),          Math.pow(col[2], p) ] }    function d91(cones) {     return cones.l == 1          && cones.m == 1          && cones.s == 1; }    function l92(rgb) {     return '{' + Math.round(rgb[0] * 255) + ', '                + Math.round(rgb[1] * 255) + ', '                + Math.round(rgb[2] * 255) + '}'; }    function q93(r, g, b, a) {     if (a !== undefined)     {         return 'rgba('             + Math.round(r * 0xff) + ', '             + Math.round(g * 0xff) + ', '             + Math.round(b * 0xff) + ', '             + a + ')';     }     else     {         return 'rgb('             + Math.round(r * 0xff) + ', '             + Math.round(g * 0xff) + ', '             + Math.round(b * 0xff) + ')';     } }    function b94(r, g, b) {     return q93(r, g, b, 1); }    function b95(rgb) {     return q93(rgb[0], rgb[1], rgb[2], 1); }    function e96(r, g, b, a) {     return q93(r, g, b, a); }    function d97(rgba) {     return q93(rgba[0], rgba[1], rgba[2], rgba[3]); }    function h98(rgb, a = 1) {     return q93(rgb[0], rgb[1], rgb[2], a); }    function y99(rgb_) {     return rgb_.length == 3          ? [...rgb_, 1]          : rgb_; }    function s100(rgb, a = 1) {     return [rgb[0], rgb[1], rgb[2], a]; }    function u101(rgb, threshold = 0.71) {     return i37(rgb)[2] < threshold; }    function n102(j103, g104) {     const d0 = g104[0] - j103[0];     const d1 = g104[1] - j103[1];     const d2 = g104[2] - j103[2];      return Math.sqrt(d0*d0 + d1*d1 + d2*d2); }    function q105(rgba, v) {     return [         rgba[0] * v,         rgba[1] * v,         rgba[2] * v,         rgba[3] * v ]; }    function m106(rgba, v) {     return [         rgba[0] / v,         rgba[1] / v,         rgba[2] / v,         rgba[3] / v ]; }    function g107(j103, g104) {     return Math.max(Math.max(Math.max(         Math.abs(g104[0] - j103[0]),         Math.abs(g104[1] - j103[1])),         Math.abs(g104[2] - j103[2]))); }    function r108(e82, i83) {     return Math.abs(e82[0] - i83[0]) < w76         && Math.abs(e82[1] - i83[1]) < w76         && Math.abs(e82[2] - i83[2]) < w76;         }    function e109(style)  {     n4014.fillStyle = style;     n4014.fillRect(0, 0, 1, 1);      return m106(n4014.getImageData(0, 0, 1, 1).data, 0xFF); }    function g110(g111, style)  {     n4014.fillStyle = w1499(g111, style);     n4014.fillRect(0, 0, 1, 1);      return m106(n4014.getImageData(0, 0, 1, 1).data, 0xFF); }    function w112(rgb, opacity = 1) {     return !g73(rgb)            ? (opacity >= 0.5                ? (u101(rgb) ? [1, 1, 1, 0.75] : [0, 0, 0, 0.75])                : (i4006 ? [1, 1, 1, 0.75] : [0, 0, 0, 0.75]))            : (i4006 ? h2441 : b2440); }    function t113(rgb) {     return !g73(rgb)          ? (u101(rgb)  ? [1, 1, 1, 0.133] : [0, 0, 0, 0.161])            : (i4006 ? [1, 1, 1, 0.031] : [0, 0, 0, 0.031]);   }    function l114(e115) {     let j3848,          d3849;                   const r3850 = t113(e115);            if (!g73(e115))     {         const l3851 = i37(e115);          const z3852 = [...l3851];         const r3853 = [...l3851];          z3852[0] += 1/12;  if (z3852[0] > 1) z3852[0] -= 1;         r3853[0] -= 1/12;  if (r3853[0] < 0) r3853[0] += 1;           const v3854 = s100(e123(u34(z3852)), 0.35);         const d3855 = s100(e123(u34(r3853)), 0.35);          const factor   = x119(e115);          const colWarn1 = w84(r3850, v3854, factor);         const colWarn2 = w84(r3850, d3855, factor);                  j3848     = d97(colWarn1);         d3849     = d97(colWarn2);     }     else     {         j3848 = d97(r3850);         d3849 = d97(r3850);     }       return [j3848,              d3849]; }    function s116(i, c117, j118) {     return 'repeating-linear-gradient('             + '-45deg, '             + 'transparent 0 ' + i   + 'px,'              +  c117 + ' '    + i   + 'px ' + i*2 +'px,'             + 'transparent '   + i*2 + 'px ' + i*3 +'px,'             +  j118 + ' '    + i*3 + 'px ' + i*4 +'px)'; }    function x119(e115) {     let dr, dg, db;      if (e115[0] < 0) dr = -e115[0]; else if (e115[0] > 1) dr = e115[0] - 1; else dr = 0;     if (e115[1] < 0) dg = -e115[1]; else if (e115[1] > 1) dg = e115[1] - 1; else dg = 0;     if (e115[2] < 0) db = -e115[2]; else if (e115[2] > 1) db = e115[2] - 1; else db = 0;          const d   = [dr, dg, db].sort()[1];     const avg = (dr + dg + db) / 3;      const factor = Math.min((d + avg) / 2, 1);                                                              return factor; }    function k120(x121) {     let g3856 = [...x121];              const factor = x119(x121);      if (factor > 0)     {         const hcl = i37(e123(x121));         hcl[1] /= 2;                   g3856 = i81(x121, f129(u34(hcl)), factor);     }      return g3856; }    function l122(rgba) {     return !h74(rgba)          ? (u101(rgba)  ? '#ffffff29' : '#00000022')          : (i4006 ? '#ffffff08' : '#00000006');  }    function e123(d124) {     const rgb = [...d124];      rgb[0] = Math.min(Math.max(0, rgb[0]), 1);        rgb[1] = Math.min(Math.max(0, rgb[1]), 1);        rgb[2] = Math.min(Math.max(0, rgb[2]), 1);       return rgb; }    function n125(val) {     return Math.min(Math.max(0, val), 1); }    function m126(p127, e128, val) {     const col = [...p127];     col[e128] = val;     return col; }    function f129(rgb) {     let hcl = i37(rgb);      let g3857 = 10000;      while (!w75(u34(hcl))          && hcl[1] > 0.001          && g3857-- > 0)         hcl[1] -= 0.001;      rgb = u34(hcl);      rgb[0] = Math.min(Math.max(0, rgb[0]), 1);        rgb[1] = Math.min(Math.max(0, rgb[1]), 1);        rgb[2] = Math.min(Math.max(0, rgb[2]), 1);       return rgb; }    function r130(rgba) {     if (!h74(rgba))         return 'transparent';     else     {         return i4006             ? 'rgba(56, 56, 56, 0.95)'             : 'rgba(255, 255, 255, 0.95)';     } }


// https://ixora.io/projects/colorblindness/color-blindness-simulation-research/
  const d135 = j59(q70([1, 1, 1])); const v136 = j59(q70([0, 0, 1])); const v137 = j59(q70([1, 0, 0]));  const b138 = (d135[2]*v136[0] - v136[2]*d135[0]) / (d135[2]*v136[1] - v136[2]*d135[1]); const f139 = (d135[1]*v136[0] - v136[1]*d135[0]) / (d135[1]*v136[2] - v136[1]*d135[2]);  const z140 = (d135[2]*v136[1] - v136[2]*d135[1]) / (d135[2]*v136[0] - v136[2]*d135[0]); const q141 = (d135[0]*v136[1] - v136[0]*d135[1]) / (d135[0]*v136[2] - v136[0]*d135[2]);  const x142 = (d135[1]*v137[2] - v137[1]*d135[2]) / (d135[1]*v137[0] - v137[1]*d135[0]); const s143 = (d135[0]*v137[2] - v137[0]*d135[2]) / (d135[0]*v137[1] - v137[0]*d135[1]);  const l144 = d135[0] / d135[2]; const l145 = d135[1] / d135[2];   // this is a number I made up following the information here: https://www.color-blindness.com/2007/07/20/monochromacy-complete-color-blindness/
    const k3858 = 0.88;   function k134(rgb, l, m, s, cs = k36) {     if (   l == 0         && m == 0         && s == 0)     {                   const a =                cs.Y[0] * rgb[0]             + cs.Y[1] * rgb[1]             + cs.Y[2] * rgb[2];          rgb = [a, a, a];     }     else     {         const xyz = v69(rgb, cs);         const lms = j59(xyz);          const a =                cs.Y[0] * rgb[0]             + cs.Y[1] * rgb[1]             + cs.Y[2] * rgb[2];          const lm = Math.min(l + m, 1);           const lms_ = [             lms[0] + r1035(k3858 * (l144*lms[2] - lms[0]), (1 - l) * ((b138*lms[1] + f139*lms[2]) - lms[0]), lm),             lms[1] + r1035(k3858 * (l145*lms[2] - lms[1]), (1 - m) * ((z140*lms[0] + q141*lms[2]) - lms[1]), lm),             lms[2] + r1035(0,                     r1035(s, 1 - s, lm) * ((x142*lms[0] + s143*lms[1]) - lms[2]), lm) ];          const xyz_ = n60(lms_);               rgb  = x71(xyz_, cs);           let bm_ = c55(rgb, cs);         bm_[0] = r1035(a, bm_[0], lm);         rgb = u56(bm_, cs);                   rgb = i81(             [a, a, a],              rgb,              Math.min(s + lm, 1));     }           return rgb; }


function c151(rgb) {     let hex =           Math.round(rgb[0] * 0xff).toString(16).padStart(2, '0').toUpperCase()         + Math.round(rgb[1] * 0xff).toString(16).padStart(2, '0').toUpperCase()         + Math.round(rgb[2] * 0xff).toString(16).padStart(2, '0').toUpperCase();      return hex; }    function u152(rgba) {     let hex =           Math.round(rgba[0] * 0xff).toString(16).padStart(2, '0').toUpperCase()         + Math.round(rgba[1] * 0xff).toString(16).padStart(2, '0').toUpperCase()         + Math.round(rgba[2] * 0xff).toString(16).padStart(2, '0').toUpperCase()         + Math.round(rgba[3] * 0xff).toString(16).padStart(2, '0').toUpperCase();      return hex; }    function k153(hex)  {     return hex.indexOf(e964) > -1             ? rgb_NaN             : v155(hex); }    function o154(hex)  {     return hex.indexOf(e964) > -1             ? rgba_NaN             : j156(hex); }    function v155(hex) {     if (hex[0] == '#')         hex = hex.substring(1);               let rgb = [];      if (hex.length >= 6)     {         rgb[0] = parseInt(hex.slice(0, 2), 16);          rgb[1] = parseInt(hex.slice(2, 4), 16);          rgb[2] = parseInt(hex.slice(4, 6), 16);      }     else if (hex.length >= 3)     {         rgb[0] = parseInt(hex[0], 16) * 0x11;          rgb[1] = parseInt(hex[1], 16) * 0x11;          rgb[2] = parseInt(hex[2], 16) * 0x11;      }     else if (hex.length == 2)     {         let v = parseInt(hex, 16);                  rgb[0] = v;          rgb[1] = v;          rgb[2] = v;      }     else if (hex.length == 1)     {         let v = parseInt(hex, 16);                  rgb[0] = v * 0x11;          rgb[1] = v * 0x11;          rgb[2] = v * 0x11;      }     else if (hex.length == 0)     {         rgb[0] = 0;          rgb[1] = 0;          rgb[2] = 0;              }       rgb[0] /= 0xff;     rgb[1] /= 0xff;     rgb[2] /= 0xff;           return rgb; }    function j156(hex) {     if (hex[0] == '#')         hex = hex.substring(1);               let rgba = [];      if (hex.length >= 8)     {         rgba[0] = parseInt(hex.slice(0, 2), 16);          rgba[1] = parseInt(hex.slice(2, 4), 16);          rgba[2] = parseInt(hex.slice(4, 6), 16);          rgba[3] = parseInt(hex.slice(6, 8), 16);      }     else if (hex.length >= 6)     {         rgba[0] = parseInt(hex.slice(0, 2), 16);          rgba[1] = parseInt(hex.slice(2, 4), 16);          rgba[2] = parseInt(hex.slice(4, 6), 16);          rgba[3] = 0xff;      }     else if (hex.length >= 4)     {         rgba[0] = parseInt(hex[0], 16) * 0x11;          rgba[1] = parseInt(hex[1], 16) * 0x11;          rgba[2] = parseInt(hex[2], 16) * 0x11;          rgba[3] = parseInt(hex[3], 16) * 0x11;      }     else if (hex.length == 3)     {         rgba[0] = parseInt(hex[0], 16) * 0x11;          rgba[1] = parseInt(hex[1], 16) * 0x11;          rgba[2] = parseInt(hex[2], 16) * 0x11;          rgba[3] = 0xff;      }     else if (hex.length == 2)     {         let v = parseInt(hex, 16);                  rgba[0] = v;          rgba[1] = v;          rgba[2] = v;          rgba[3] = 0xff;      }     else if (hex.length == 1)     {         let v = parseInt(hex, 16);                  rgba[0] = v * 0x11;          rgba[1] = v * 0x11;          rgba[2] = v * 0x11;          rgba[3] = 0xff;      }     else if (hex.length == 0)     {         rgba[0] = 0;          rgba[1] = 0;          rgba[2] = 0;                  rgba[3] = 0;      }       rgba[0] /= 0xff;     rgba[1] /= 0xff;     rgba[2] /= 0xff;     rgba[3] /= 0xff;       return rgba; }


function i157(f158, t159) {     if (    g73  (f158)         || !w75(f158))         return Number.NaN;      const n164 = k36.luminance(f158);     const  m165 = k36.luminance(t159);      return (         m165 > n164         ? ( m165 + 0.05) / (n164 + 0.05)         : (n164 + 0.05) / ( m165 + 0.05)); }    function e160(ratio) {          if (ratio >= 7  ) return 'AAA';     else if (ratio >= 4.5) return 'AA';     else if (ratio >= 3  ) return 'AA<sub>L</sub>';     else                   return ''; }    function x161(f158, t159) {     if (!k78(f158))         return Number.NaN;      return m163(         b162(f158),         b162(t159)); }    // I copied the code below from https://github.com/Myndex/p4122-APCA/blob/master/WEBTOOLS/APCA/JS/DEV.0.1.2.G_SAPCsRGB.js
  const j4102     = 2.4;          const o4103        = 0.2126729,        u4104        = 0.7151522,        e4105        = 0.0721750;      const f4106      = 0.56,        a4107     = 0.57,       v4108      = 0.62,       h4109       = 0.65;      const h4110     = 0.022,       k4111     = 1.414,        e4112    = 1.14,       k4113    = 1.14,       g4114 = 0.035991,       i4115 = 0.035991,       v4116 = 27.7847239587675,       q4117 = 27.7847239587675,       b4118 = 0.027,       p4119 = 0.027,       w4120      = 0.001,       r4121   = 0.0005;    function b162(rgb)  {                     return o4103 * Math.pow(rgb[0], j4102)           + u4104 * Math.pow(rgb[1], j4102)          + e4105 * Math.pow(rgb[2], j4102); }    function m163(n164, m165) {     let p4122           = 0;      let s4123 = 0;       n164 =          n164 > h4110          ? n164          : n164 + Math.pow(h4110 - n164, k4111);              m165 =          m165 > h4110          ? m165          : m165 + Math.pow(h4110 - m165, k4111);      if (Math.abs(m165 - n164) < r4121)           return 0;        if (m165 > n164)      {           p4122 = (Math.pow(m165, f4106) - Math.pow(n164, a4107)) * e4112;          s4123 =              p4122 < w4120              ? 0              : p4122 < g4114               ? p4122 - p4122 * v4116 * b4118                : p4122 - b4118;     }      else      {           p4122 = (Math.pow(m165, h4109) - Math.pow(n164, v4108)) * k4113;          s4123 =              p4122 > -w4120              ? 0              : p4122 > -i4115                ? p4122 - p4122 * q4117 * p4119                : p4122 + p4119;     }       return s4123 * 100; }


function l133     (index) { return t131[index][0]; } function i4124(space) { return t131.findIndex(s => s[0] == space); }  function r4125(parse = null) {      const set = parse ? parse.settings : settings;      return set.showAllColorSpaces             ? t131.length         : t131.length - 5;  }    const c4126  = [255, 255, 255]; const i4127  = [360, 100, 100]; const g4128  = [360, 100, 100]; const w4129  = [100, 100, 100];      const g4130   = [255, 255, 255];    const j4131   = [360, 100, 100];   const u4132 = [360, 50,  100]; const f4133 = [360, 400, 100]; const b4134 = [360, 330, 100];     const k4135 = [100,  30,  30]; const i4136   = [100, 100, 100]; const k4137   = [100, 150, 150];     function f4138(space) {     switch (space)     {         case 'hex':         case 'rgb':   return c4126;          case 'hsv':         case 'hsl':   return i4127;          case 'hclok':         case 'hclab':         case 'hcluv': return g4128;          case 'oklab':           case 'lab':               case 'luv':   return w4129;                     default:      c953('invalid color factor from space \''+space+'\''); break;     } }    function i4139(col, space) {     let scale;      switch (space)     {         case 'hex':             case 'rgb':   scale = g4130;   break;          case 'hsv':             case 'hsl':   scale = j4131;   break;          case 'hclok': scale = u4132; break;         case 'hclab': scale = f4133; break;         case 'hcluv': scale = b4134; break;          case 'oklab': scale = k4135; break;         case 'lab':   scale = i4136;   break;         case 'luv':   scale = k4137;   break;     }      return [         col[0] * scale[0],         col[1] * scale[1],         col[2] * scale[2] ]; }    function g4140(rgb) {     return [ rgb[0] / 255,              rgb[1] / 255,              rgb[2] / 255 ]; }    function p4141(rgb) {     return [ Math.round(rgb[0] * 255),              Math.round(rgb[1] * 255),              Math.round(rgb[2] * 255) ]; }    function k4142(node, space) {     switch (space)     {         case 'hex':   w4144   (node); break;         case 'rgb':   g4145   (node); break;          case 'hsv':   i4146   (node); break;         case 'hsl':   f4147   (node); break;          case 'hclok': k4148 (node); break;         case 'hclab': g4149 (node); break;         case 'hcluv': x4150 (node); break;          case 'oklab': j4151 (node); break;         case 'lab':   r4152   (node); break;         case 'luv':   b4153   (node); break;     }      node.x4143(); }    function w4144  (node) { x4154   (node); a4164(node); } function g4145  (node) { x4154   (node);                        }  function i4146  (node) { u4155   (node, 'V');                   } function f4147  (node) { u4155   (node, 'L');                   }               function k4148(node) { s4156(node);                        } function g4149(node) { q4157(node);                        } function x4150(node) { g4158(node);                        }               function j4151(node) { c4159 (node, 'a', 'b');              } function r4152  (node) { c4160   (node, 'a', 'b');              } function b4153  (node) { w4161   (node, 'u', 'v');              }       function x4154(node) {     z4163(node,          'R', 0, g4130[0], '', false,          'G', 0, g4130[1],          'B', 0, g4130[2]);        node.i4168.t4269[0].min =      node.w4169.t4269[0].min =      node.a4170.t4269[0].min = Number.MIN_SAFE_INTEGER;       node.i4168.t4269[0].max =      node.w4169.t4269[0].max =      node.a4170.t4269[0].max = Number.MAX_SAFE_INTEGER;       showRgbControlHex(node, false);     }    function u4155(node, v_or_l)  {      z4163(node,          'H',    0, j4131[0], '°', true,           'S',    0, j4131[1],          v_or_l, 0, j4131[2]);        node.i4168.t4269[0].m811 = -4;      node.w4169.t4269[0].min =      node.a4170.t4269[0].min = Number.MIN_SAFE_INTEGER;       node.w4169.t4269[0].max =      node.a4170.t4269[0].max = Number.MAX_SAFE_INTEGER;       showRgbControlHex(node, false);  }    function switchToHclControls(node, scale)  {      z4163(node,          'H', 0, scale[0], '°', true,           'C', 0, scale[1],          'L', 0, scale[2]);        node.i4168.t4269[0].m811 = -4;      node.w4169.t4269[0].min =      node.a4170.t4269[0].min = Number.MIN_SAFE_INTEGER;       node.w4169.t4269[0].max =      node.a4170.t4269[0].max = Number.MAX_SAFE_INTEGER;       showRgbControlHex(node, false);  }    function s4156(node) { switchToHclControls(node, u4132); } function q4157(node) { switchToHclControls(node, f4133); } function g4158(node) { switchToHclControls(node, b4134); }    function t4162(node, c2, c3, scale) {      z4163(node,          'L', 0,        scale[0], '', false,           c2, -scale[1], scale[1],          c3, -scale[2], scale[2]);        showRgbControlHex(node, false);  }    function c4159(node) { t4162(node, 'a', 'b', k4135); } function c4160  (node) { t4162(node, 'a', 'b', i4136  ); } function w4161  (node) { t4162(node, 'u', 'v', k4137  ); }    function showRgbControlHex(node, show) {     node.i4168.t4269[0].t4000 = show;     node.w4169.t4269[0].t4000 = show;     node.a4170.t4269[0].t4000 = show; }    function z4163(node, c1, c1min, c1max, c1suffix, c1wrap, c2, c2min, c2max, c3, c3min, c3max) {     x4165(node);      node.i4168.r2954(c1, false);      node.w4169.r2954(c2, false);      node.a4170.r2954(c3, false);      node.i4168.t4269[0].l809 = c1wrap;     node.i4168.t4269[0].setSuffix(c1suffix, c1suffix != '');      node.i4168.t4269[0].s3121(c1min);      node.w4169.t4269[0].s3121(c2min);     node.a4170.t4269[0].s3121(c3min);          node.i4168.t4269[0].f3122(c1max);      node.w4169.t4269[0].f3122(c2max);      node.a4170.t4269[0].f3122(c3max);           node.i4168.f2833();     node.w4169.f2833();     node.a4170.f2833();      node.i4168.t4269[0].m811 = 0; }    function a4164(node) {     z4167(node);      t1504(node.i4168.div, node.k4171);     t1504(node.w4169.div, node.k4171);     t1504(node.a4170.div, node.k4171);              w1503(node.k4172.div, node.k4171); }    function p4166(node) {     z4167(node);      t1504(node.i4168.div,     node.k4171);     t1504(node.w4169.div,     node.k4171);     t1504(node.a4170.div,     node.k4171);          t1504(node.k4172.div, node.k4171); }    function z4167(node) {     for (let i = node.inputs.length-1; i >= 2; i--)         if (node.inputs[i].connected)             w2599(node.inputs[i]);      for (let i = node.outputs.length-1; i >= 2; i--)         for (const input of node.outputs[i].s4173)             w2599(input); }    function x4165(node) {     t1504(node.k4172.div, node.k4171);      w1503(node.i4168.div, node.k4171);     w1503(node.w4169.div, node.k4171);     w1503(node.a4170.div, node.k4171); }    function h146(rgb) {     return [        'rgb',         rgb[0],         rgb[1],         rgb[2] ]; }    function g4175(value, space, e128) {     switch (space)     {         case 'hex':         case 'rgb':   return g4176(value, e128);          case 'hsv':            case 'hsl':   return s4177 (value, e128);          case 'hclok':          case 'hclab':          case 'hcluv': return b4179 (value, e128);          case 'oklab':           case 'lab':             case 'luv':   return w4178 (value, e128);     } }    function g4176(value, e128) {     switch (e128)     {         case 0: return value / c4126[0];         case 1: return value / c4126[1];          case 2: return value / c4126[2];     } }    function s4177(value, e128) {     switch (e128)     {         case 0: return value / i4127[0];         case 1: return value / i4127[1];          case 2: return value / i4127[2];     } }    function w4178(value, e128) {     switch (e128)     {         case 0: return value / w4129[0];         case 1: return value / w4129[1];          case 2: return value / w4129[2];     } }    function b4179(value, e128) {     switch (e128)     {         case 0: return value / g4128[0];         case 1: return value / g4128[1];          case 2: return value / g4128[2];     } }    function j4180(color) {     return w4181(         color[0],          color[1],          color[2],          color[3]) }    function w4181(space, c1, c2, c3) {     switch (space)     {         case 'hex':         case 'rgb':   return y4182(c1, c2, c3);          case 'hsv':            case 'hsl':   return a4183(c1, c2, c3);          case 'hclok':          case 'hclab':          case 'hcluv': return z4184(c1, c2, c3);          case 'oklab':          case 'lab':          case 'luv':   return w4185(c1, c2, c3);     } }    function y4182(c1, c2, c3) {     return [         c1 / c4126[0],          c2 / c4126[1],          c3 / c4126[2]]; }    function a4183(c1, c2, c3) {     return [         c1 / i4127[0],          c2 / i4127[1],          c3 / i4127[2]]; }    function z4184(c1, c2, c3) {     return [         c1 / g4128[0],          c2 / g4128[1],          c3 / g4128[2]]; }    function w4185(c1, c2, c3) {     return [         c1 / w4129[0],          c2 / w4129[1],          c3 / w4129[2]]; }    function s4186(color) {     switch (color[0])     {         case 'hex':         case 'rgb':   return t4187(         color[1], color[2], color[3]);          case 'hsv':   return h4188('hsv',   color[1], color[2], color[3]);         case 'hsl':   return h4188('hsl',   color[1], color[2], color[3]);          case 'hclok': return h4189('hclok', color[1], color[2], color[3]);         case 'hclab': return h4189('hclab', color[1], color[2], color[3]);         case 'hcluv': return h4189('hcluv', color[1], color[2], color[3]);          case 'oklab': return s4190('oklab', color[1], color[2], color[3]);         case 'lab':   return s4190('lab',   color[1], color[2], color[3]);         case 'luv':   return s4190('luv',   color[1], color[2], color[3]);     } }    function t4187(c1, c2, c3) {     return [        'rgb',         c1 * c4126[0],          c2 * c4126[1],          c3 * c4126[2] ]; }    function h4188(space, c1, c2, c3) {     return [         space,         c1 * i4127[0],          c2 * i4127[1],          c3 * i4127[2] ]; }    function h4189(space, c1, c2, c3) {     return [         space,         c1 * g4128[0],          c2 * g4128[1],          c3 * g4128[2] ]; }    function s4190(space, c1, c2, c3) {     return [         space,         c1 * w4129[0],          c2 * w4129[1],          c3 * w4129[2] ]; }    function v3204(node, color) {     const g3205 = l133(node.w3200.value);     node.c3198   = k4195(color, g3205);      node.n3484(node.c3198); }    function r4191(space) {     switch (space)     {         case 'hex':         case 'rgb':   return c4126;          case 'hsv':            case 'hsl':   return i4127;          case 'hclok':          case 'hclab':          case 'hcluv': return g4128;          case 'oklab':          case 'lab':          case 'luv':   return w4129;     }     }    function e4192(space) {     switch (space)     {         case 'hex':         case 'rgb':   return g4130;          case 'hsv':            case 'hsl':   return j4131;          case 'hclok': return u4132;         case 'hclab': return f4133;         case 'hcluv': return b4134;          case 'oklab': return k4135;         case 'lab':   return i4136;         case 'luv':   return k4137;     }     }


function c4193(color) {     return [         color[1],          color[2],          color[3]]; }    function f4194(color) {     const col = c4193(color);      switch (color[0])     {         case 'hex':         case 'rgb':   return           col;          case 'hsv':   return a54  (col);         case 'hsl':   return o50  (col);          case 'hclok': return u34(col);         case 'hclab': return y40(col);         case 'hcluv': return g44(col);          case 'oklab': return n3984(col);         case 'lab':   return u56  (col);         case 'luv':   return e3977  (col);     } }    function k4195(color, g3205) {     switch (g3205)     {         case 'hex':             case 'rgb':   return v4196    (color);          case 'hsv':   return l4197    (color);         case 'hsl':   return w4198    (color);          case 'hclok': return x4202  (color);         case 'hclab': return o4203  (color);         case 'hcluv': return f4204  (color);          case 'oklab': return y4199(color);         case 'lab':   return r4200    (color);         case 'luv':   return j4201    (color);     } }    function v4196(m4205) {     const col = c4193(m4205);      let rgb;      switch (m4205[0])     {         case 'hex':         case 'rgb':   rgb =           col;  break;          case 'hsv':   rgb = a54  (col); break;         case 'hsl':   rgb = o50  (col); break;          case 'hclok': rgb = u34(col); break;         case 'hclab': rgb = y40(col); break;         case 'hcluv': rgb = g44(col); break;          case 'oklab': rgb = n3984(col); break;         case 'lab':   rgb = u56  (col); break;         case 'luv':   rgb = e3977  (col); break;     }      return h146(rgb); }    function l4197(m4205) {     const col = c4193(m4205);          let hsv;          switch (m4205[0])     {         case 'hex':         case 'rgb':   hsv = m52(          col ); break;          case 'hsv':   hsv =                   col;   break;         case 'hsl':   hsv = m52(o50  (col)); break;          case 'hclok': hsv = m52(u34(col)); break;         case 'hclab': hsv = m52(y40(col)); break;         case 'hcluv': hsv = m52(g44(col)); break;          case 'oklab': hsv = m52(n3984(col)); break;         case 'lab':   hsv = m52(u56  (col)); break;         case 'luv':   hsv = m52(e3977  (col)); break;     }          if (isNaN(hsv[0]))         hsv[0] = 5/6;          return [        'hsv',         hsv[0],         hsv[1],         hsv[2] ]; }    function w4198(m4205) {     const col = c4193(m4205);      let hsl;      switch (m4205[0])     {         case 'hex':         case 'rgb':   hsl = e48(          col ); break;          case 'hsv':   hsl = e48(a54  (col)); break;         case 'hsl':   hsl =                   col;   break;          case 'hclok': hsl = e48(u34(col)); break;         case 'hclab': hsl = e48(y40(col)); break;         case 'hcluv': hsl = e48(g44(col)); break;          case 'oklab': hsl = e48(n3984(col)); break;         case 'lab':   hsl = e48(u56  (col)); break;         case 'luv':   hsl = e48(e3977  (col)); break;     }      return [        'hsl',         hsl[0],         hsl[1],         hsl[2] ]; }    function y4199(m4205) {     const col = c4193(m4205);      let lab;      switch (m4205[0])     {         case 'hex':         case 'rgb':   lab = o3980(          col ); break;          case 'hsv':   lab = o3980(a54  (col)); break;         case 'hsl':   lab = o3980(o50  (col)); break;          case 'hclok': lab = o3980(u34(col)); break;         case 'hclab': lab = o3980(y40(col)); break;         case 'hcluv': lab = o3980(g44(col)); break;          case 'oklab': lab =                     col;   break;         case 'lab':   lab = o3980(u56  (col)); break;         case 'luv':   lab = o3980(e3977  (col)); break;     }      return [        'oklab',         lab[0],         lab[1],         lab[2] ]; }    function r4200(m4205) {     const col = c4193(m4205);      let lab;      switch (m4205[0])     {         case 'hex':         case 'rgb':   lab = c55(          col ); break;          case 'hsv':   lab = c55(a54  (col)); break;         case 'hsl':   lab = c55(o50  (col)); break;          case 'hclok': lab = c55(u34(col)); break;         case 'hclab': lab =         o39(col);  break;         case 'hcluv': lab = c55(g44(col)); break;          case 'oklab': lab = c55(n3984(col)); break;         case 'lab':   lab =                   col;   break;         case 'luv':   lab = c55(e3977  (col)); break;     }      return [        'lab',         lab[0],         lab[1],         lab[2] ]; }    function j4201(m4205) {     const col = c4193(m4205);      let luv;      switch (m4205[0])     {         case 'hex':         case 'rgb':   luv = s3976(          col ); break;          case 'hsv':   luv = s3976(a54  (col)); break;         case 'hsl':   luv = s3976(o50  (col)); break;          case 'hclok': luv = s3976(u34(col)); break;         case 'hclab': luv = s3976(y40(col)); break;         case 'hcluv': luv =         q43(col);  break;          case 'oklab': luv = s3976(n3984(col)); break;         case 'lab':   luv = s3976(u56  (col)); break;         case 'luv':   luv =                   col;   break;     }      return [        'luv',         luv[0],         luv[1],         luv[2] ]; }    function x4202(m4205) {     const col = c4193(m4205);      let hcl;      switch (m4205[0])     {         case 'hex':         case 'rgb':   hcl = i37(          col);  break;          case 'hsv':   hcl = i37(a54  (col)); break;         case 'hsl':   hcl = i37(o50  (col)); break;          case 'hclok': hcl =                     col;   break;         case 'hclab': hcl = i37(y40(col)); break;         case 'hcluv': hcl = i37(g44(col)); break;          case 'oklab': hcl = i37(n3984(col)); break;         case 'lab':   hcl = i37(u56  (col)); break;         case 'luv':   hcl = i37(e3977  (col)); break;     }      return [        'hclok',         hcl[0],         hcl[1],         hcl[2] ]; }    function o4203(m4205) {     const col = c4193(m4205);      let lab;      switch (m4205[0])     {         case 'hex':         case 'rgb':   lab = i42(          col) ; break;                  case 'hsv':   lab = i42(a54  (col)); break;         case 'hsl':   lab = i42(o50  (col)); break;                  case 'hclok': lab = i42(u34(col)); break;         case 'hclab': lab =                     col;   break;         case 'hcluv': lab = i42(g44(col)); break;                  case 'oklab': lab = i42(n3984(col)); break;         case 'lab':   lab = p41(          col ); break;         case 'luv':   lab = i42(e3977  (col)); break;     }      return [        'hclab',         lab[0],         lab[1],         lab[2] ]; }    function f4204(m4205) {     const col = c4193(m4205);      let hcl;      switch (m4205[0])     {         case 'hex':         case 'rgb':   hcl = d46(          col ); break;          case 'hsv':   hcl = d46(a54  (col)); break;         case 'hsl':   hcl = d46(o50  (col)); break;          case 'hclab': hcl = d46(y40(col)); break;         case 'hcluv': hcl =                     col;   break;         case 'hclok': hcl = d46(u34(col)); break;          case 'oklab': hcl = d46(n3984(col)); break;         case 'lab':   hcl = d46(u56  (col)); break;         case 'luv':   hcl = f45(          col ); break;     }      return [        'hcluv',         hcl[0],         hcl[1],         hcl[2] ]; }


</script>