function h1052(key, tag)  {     return key.substring(0, tag.length+1) == tag + ' '; }    function j1053(key, tag) {     return key.substring(tag.length+1); }    function m1054(key) { return h1052(key, u876); } function i1055(key) { return h1052(key, d874); } function c1056(key) { return h1052(key, f875); }    function y1057(key) { return j1053(key, u876); } function v1058(key) { return j1053(key, d874); } function y1059(key) { return j1053(key, f875); }


const generatorVersion = 413;   const w868        = 2147483647;    const NULL             = '';    const l869             = '  ';  const i870              = '    '; const e871               = '\n';    const w872   = '◦ G •'; const f873    = w872 + ' ';  const d874          = 'G_NODE'; const f875          = 'G_CONN'; const u876          = 'G_PAGE'; const y877          = 'G_TEMP';  const minWindowWidth   = 602; const minWindowHeight  =  39;   const identity = Object.freeze(     [[1, 0, 0],      [0, 1, 0],      [0, 0, 1]]);    const Epsilon = 0.0000001; const Tau     = Math.PI * 2;    var enableAsserts = false;    function z878(x, eps = 0.000000001)  {      return Math.abs(x) < eps ? 0 : x; }    function nozero(x, eps = 0.000000001)  {      return x != 0           ? x           : (x < 0 ? -eps : eps); }    function m879(v, eps = 0.000000001)  {      return point(         nozero(v.x, eps),          nozero(v.y, eps));  }    function equal(a, b, eps = 0.000000001) {     return Math.abs(b - a) < eps; }    function sqr (x) { return x*x;   }; function cube(x) { return x*x*x; };    function b880(f) { return Math.floor(f) | 0; }    function b881(x) {     x = b880(x);      x--;      x |= x >>  1;     x |= x >>  2;     x |= x >>  4;     x |= x >>  8;     x |= x >> 16;     x |= x >> 32;      return ++x; }    function gcd(a, b) {     let temp;     while (1)     {         temp = a % b;          if (temp == 0)           return b;          a = b;         b = temp;     } }    function distv(p1, p2) {     const dx = p2.x - p1.x;     const dy = p2.y - p1.y;      return Math.sqrt(dx*dx + dy*dy); }    function p882(v) {     let angle = Math.atan2(v.y, v.x);     if (angle < 0) angle += Tau;      return angle; }    function anglev2(v1, v2) {     return anglev2_(v1.x, v1.y, v2.x, v2.y); }    function anglev2_(x1, y1, x2, y2) {     const dx = x2 - x1;     const dy = y2 - y1;      let angle = Math.atan2(dy, dx);     if (angle < 0) angle += Tau;      return angle; }    function o884(v) {     return Math.sqrt(v.x*v.x + v.y*v.y); }    function lengthv_(x, y) {     return Math.sqrt(x*x + y*y); }    function d885(v) {     return point(         v.x == 0 ? 0 : v.x / o884(v),         v.y == 0 ? 0 : v.y / o884(v)); }    function dotv(v1, v2) {     return v1.x * v2.x + v1.y * v2.y; }    function l886(a1, a2) {     let diff = a2 - a1;      while (diff <= -Tau/2) diff += Tau;     while (diff >   Tau/2) diff -= Tau;      return diff;  }    function c887(v, m) {     let v3 = [v.x, v.y, 1];     let r  = k951(v3, m);      return point(r[0], r[1]); }    function g888(...mm) {     w955(mm.length > 0, 'mulm3m3() must take at least one argument');      let result = clone(mm[0]);      for (let a = 1; a < mm.length; a++)     {         const m1 = result;         const m2 = mm[a];          const m = [[0, 0, 0],                    [0, 0, 0],                    [0, 0, 0]];          for (let i = 0; i < 3; i++)         {             for (let j = 0; j < 3; j++)             {                                  for (let k = 0; k < 3; k++)                     m[i][j] += m1[i][k] * m2[k][j];             }         }          result = m;     }      return result; }    function y889(m, s) {     for (let i = 0; i < 3; i++)         for (let j = 0; j < 3; j++)             m[i][j] /= s;      return m; }    function adjugate(m) {     return cofactor(transpose(m)); }    function transpose(m) {     return [[m[0][0], m[1][0], m[2][0]],             [m[0][1], m[1][1], m[2][1]],             [m[0][2], m[1][2], m[2][2]]]; }    function cofactor(m) {     return [[  m[1][1] * m[2][2] - m[2][1] * m[1][2], -(m[1][0] * m[2][2] - m[2][0] * m[1][2]),  m[1][0] * m[2][1] - m[2][0] * m[1][1] ],             [-(m[0][1] * m[2][2] - m[2][1] * m[0][2]),  m[0][0] * m[2][2] - m[2][0] * m[0][2], -(m[0][0] * m[2][1] - m[2][0] * m[0][1])],             [  m[0][1] * m[1][2] - m[1][1] * m[0][2], -(m[0][0] * m[1][2] - m[1][0] * m[0][2]),  m[0][0] * m[1][1] - m[1][0] * m[0][1] ]];  }    function determinant(m) {     return   m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1])            - m[0][1] * (m[1][0] * m[2][2] - m[2][0] * m[1][2])            + m[0][2] * (m[1][0] * m[2][1] - m[2][0] * m[1][1]); }    function s890(m) {     return y889(adjugate(m), determinant(m)); }    function s891(angle) {     const cosA = z878(Math.cos(angle));     const sinA = z878(Math.sin(angle));      return [[ cosA, sinA, 0],             [-sinA, cosA, 0],             [ 0,    0,    1]]; }    function l892(x = 0, y = 0, k893 = 1, m894 = 1, angle = 0, z895 = 0, l896 = 0) {     const cosA = Math.cos(angle);     const sinA = Math.sin(angle);      return [[k893*cosA -  l896*sinA, -z895*cosA + m894*sinA, x],             [ l896*cosA + k893*sinA, m894*cosA +  z895*sinA, y],             [0,                         0,                         1]]; }    function t897(v1, v2) {                               return v1.x * v2.y - v1.y * v2.x; }	    function m898(v1, v2) {     return point(         v1.x + v2.x,         v1.y + v2.y); }	    function sqrv(v) {     return h899(v, v); }    function h899(v1, v2) {     return point(         v1.x * v2.x,         v1.y * v2.y); }	    function d900(v, s) {     return point(         v.x * s,         v.y * s); }	    function l901(v1, v2) {     return point(         v1.x / v2.x,         v1.y / v2.y); }	    function k902(v, s) {     return point(         v.x / s,         v.y / s); }	    function r903(v1, v2) {     return point(         v1.x - v2.x,         v1.y - v2.y); }	    function w904(str)  {     return decodeURI(encodeURIComponent(str)); }    function s905(str)  {     return decodeURIComponent(encodeURI(str)); }    function d906(bytes)  {     let str = '';      for (let i = 0; i < bytes.length; i++)         str += String.fromCharCode(bytes[i]);      return str; }    function s907(str) {     return Array.from(s905(str), c => c.charCodeAt(0)); }    function k908(array, size)  {     const newArray = new Uint8Array(size);     h909(array, newArray);     return newArray; }    function h909(src, dst) {     v910(         src, 0, src.length,         dst, 0, dst.length); }    function v910(src, a911, f912, dst, o913, e914) {     const size = Math.min(f912, e914);      for (let i = 0; i < size; i++)         dst[o913 + i] = src[a911 + i]; }    function q915(w916, a917) {     if (w916.length != a917.length)         return false;      for (let i = 0; i < w916.length; i++)     {         if (w916[i] != a917[i])             return false;     }      return true; }    function p918(v919, j920) {     return v919.findIndex(i => j920.includes(i)) > -1; }    function  h921(list) { return list ? '<==' : '<--'; };  function l922(list) { return list ? '==>' : '-->'; };   function y923(nodeId) { return d874 + ' ' + nodeId; } function t924(name)   { return f875 + ' ' + name;   } function q925(name)   { return u876 + ' ' + name;   }    function t926(str)  {      return str.toLowerCase() == 'true'         || str == '1'; }    function m927(t928, e929 = false) {     return i934(         t928.outputNodeId,         t928.outputId,         t928.outputOrder,         t928.inputNodeId,         t928.inputId,         t928.list,         e929); }    function u930(outputNodeId, outputId, outputOrder, inputNodeId, inputId) {     return t924(           outputNodeId + ' '         + outputId     + ' '         + outputOrder  + ' '         + inputNodeId  + ' '         + inputId); }    function b931(o243) {     return u930(         o243.outputNodeId,         o243.outputId,         o243.outputOrder,         o243.inputNodeId,         o243.inputId); }    function l932(o243) {     return u930(         o243.output.node.id,         o243.output.id,         o243.outputOrder,         o243.input.node.id,         o243.input.id); }    function r933(o243, e929 = false) {     return i934(         o243.output.node.id,         o243.output.id,         o243.outputOrder,         o243.input.node.id,         o243.input.id,         o243.list,         e929); }    function i934(outputNodeId, outputId, outputOrder, inputNodeId, inputId, list, e929 = false) {     const  sp   = e929 ? ' ' : '  ';      const jsp   = e929 ? ''  : ' ';       const arrow =            sp          + p938(typeof outputOrder == 'string' ? parseInt(outputOrder) : outputOrder)          + l922(typeof list == 'string' ? t926(list) : list)          + sp;      const join  = jsp + '.' + jsp;      return  outputNodeId + join + outputId          + arrow          + inputNodeId  + join + inputId;           }    function q935(pageId) {     return q925(pageId); }    function q936(num) {     const str = num.toString();      let sup = '';      for (const c of str)         sup += x937(c);      return sup; }    function x937(c) {     switch (c)     {         case '0': return '⁰';         case '1': return '¹';         case '2': return '²';         case '3': return '³';         case '4': return '⁴';         case '5': return '⁵';         case '6': return '⁶';         case '7': return '⁷';         case '8': return '⁸';         case '9': return '⁹';         case '.': return '·';     } }    function p938(num) {     const str = num.toString();      let sup = '';      for (const c of str)         sup += v939(c);      return sup; }    function v939(c) {     switch (c)     {         case '0': return '₀';         case '1': return '₁';         case '2': return '₂';         case '3': return '₃';         case '4': return '₄';         case '5': return '₅';         case '6': return '₆';         case '7': return '₇';         case '8': return '₈';         case '9': return '₉';         case '.': return ' ';     } }    function a940(bool) {     return bool ? 'true' : 'false'; }    function isValid(val) {     return val != undefined         && val != null; }    function isEmpty(array) {     return array.length == 0; }    function s941(array, item) {     r942(array, array.indexOf(item)); }    function r942(array, index) {     if (   index > -1          && index < array.length)         array.splice(index, 1); }    function z943(array) {     if (isEmpty(array))         return null;      let last = array.at(-1);     array.splice(array.length-1, 1);      return last; }    function d944(array) {     return array[array.length-1]; }    function r945(array, from, to)  {     const item = array[from];     array.splice(from, 1);     array.splice(to, 0, item); }    function m946(array, item) {     const index = array.indexOf(item);          if (index > -1)         array.splice(index, 1); }    function x947(z2779, array) {     for (const item of array)     {         const index = z2779.indexOf(item);                  if (index > -1)             z2779.splice(index, 1);     } }    function g948(array, where) {     const index = array.findIndex(where);          if (index > -1)         array.splice(index, 1); }    function v949(styleId) {     return styleId.split(',')[0] + ','; }    function c950(points) {     let i4014 = '';       if (points.length < 2)         return i4014;       i4014 += 'M';     i4014 += ' ' + z878(points[0].x);     i4014 += ' ' + z878(points[0].y);      for (let i = 1; i < points.length; i++)     {         i4014 +=                ' L'             + ' ' + z878(points[i].x)             + ' ' + z878(points[i].y);     }       return i4014; }    function point(x, y) { return {x: x, y: y}; }    function k951(v, m) {     let r = [0, 0, 0];      for (let i = 0; i < 3; i++)         for (let j = 0; j < 3; j++)             r[i] += v[j] * m[i][j];      return r; }    function clone(val)  {     const type = typeof val;          if (val === null)        return null;      else if (type === 'undefined'            || type === 'number'            || type === 'string'            || type === 'boolean')          return val;      else if (type === 'object')      {         if (val instanceof Array)              return val.map(x => clone(x));          else if (val instanceof Uint8Array)              return new Uint8Array(val);          else          {             let k111 = {};              for (const key in val)                  k111[key] = clone(val[key]);              return k111;         }     }      throw 'unknown'; }    function e952(array, item, equal = null) {     if (equal)     {         if (Array.isArray(item))             item.forEach(i => e952(array, i, equal));         else if (!array.find(i => equal(i, item)))             array.push(item);     }     else     {         if (Array.isArray(item))             item.forEach(i => e952(array, i));         else if (!array.includes(item))             array.push(item);     } }    function r953(array, item, equal) {     if (Array.isArray(item))         item.forEach(i => r953(array, i, equal));     else if (!array.find(equal))         array.push(item); }    function y954(array, item, except) {     if (Array.isArray(item))         item.forEach(i => y954(array, i, except));     else if (!array.find(except))         array.push(item); }    function w955(...args) {               if (enableAsserts)     {         console.assert(...args);              } }    function z956(...args) {               if (enableAsserts)         console.error(...args); }    function m957(str, trim)  {     while (str.length >= trim.length         && str.substring(0, trim.length) == trim)          str = str.substring(trim.length);      return str; }    function y958(str, trim)  {     while (str.length >= trim.length         && str.substring(str.length - trim.length) == trim)          str = str.substring(0, str.length - trim.length);      return str; }    function g959(i4074) {     const fills = [];       for (const fill of i4074)     {         switch (fill[0])         {             case 'SOLID':             {                 const color = {                     r: Math.min(Math.max(0, fill[1] / 0xff), 1),                      g: Math.min(Math.max(0, fill[2] / 0xff), 1),                      b: Math.min(Math.max(0, fill[3] / 0xff), 1) };                  const opacity = Math.min(Math.max(0, fill[4] / 100), 1);                   if (   !isNaN(color.r)                     && !isNaN(color.g)                     && !isNaN(color.b)                     && !isNaN(opacity))                     fills.push(                     {                         type:      fill[0],                          color:     color,                         opacity:   opacity,                         blendMode: fill[5]                     });                   break;             }              case 'GRADIENT_LINEAR':             case 'GRADIENT_RADIAL':             case 'GRADIENT_ANGULAR':             case 'GRADIENT_DIAMOND':             {                 const j4190 = fill[1];                   const stops = [];                  for (const stop of fill[2])                 {                     stops.push({                         color:                          {                             r: Math.min(Math.max(0, stop[0]), 1),                             g: Math.min(Math.max(0, stop[1]), 1),                             b: Math.min(Math.max(0, stop[2]), 1),                             a: Math.min(Math.max(0, stop[3]), 1)                         },                         position: stop[4]                     });                   }                   fills.push(                 {                     type:              fill[0],                     gradientTransform: j4190,                     gradientStops:     stops,                     blendMode:         fill[3]                 });                   break;             }         }     }       return fills; }    function z960(type) {     return e1093.includes(type); }


const f1060           = 'LIST#';  const x1061    = 'NLIST#'; const   o1062    = 'TLIST#'; const  j1063    = 'SLIST#';   const k1064            = 'NULL'; const c1065             = 'VAR'; const n1066       = 'VARGRP'; const f1067             = 'FEEDBK'; const y1068               = 'REPT'; const w1069                = 'CACHE'; const z1070               = 'FRZ'; const w1071                = 'TIMER'; const w1072           = 'VNAME'; const GET_LIST_VALUE_NAMES = 'GVNAMES'; const LIST_VALUE_NAMES     = 'VNAMES'; const OBJECT_NAME          = 'ONAME';  const g1073              = 'CMB'; const r1074         = 'LSASIT'; const j1075              = 'EXTR'; const w1076            = 'SETP'; const k1077            = 'GETP'; const n1078              = 'SUBLST'; const t1079               = 'UNIQ'; const REORDER_LIST         = 'RORD'; const SHIFT_LIST           = 'SHFTLST'; const j1080         = 'REVLST'; const BUCKLE_LIST          = 'BUKLST'; const x1081                 = 'SORT'; const v1082               = 'CLMN'; const d1083                 = 'CELL'; const n1084                 = 'LIST'; const d1085           = 'COUNT'; const OBJECT_COUNT         = 'OBJCOUNT'; const w1086             = 'LCONT'; const p1087               = 'SELECT'; const SELECT_FROM_LIST     = 'LSTSEL'; const y1088              = 'IF'; const q1089               = 'LSTFLT';   const f1091            = 'ANY#';   const s1092 = [     f1060,     x1061,     o1062,     j1063,     g1073,     j1075,     w1076,     k1077,     n1078,     n1084,     d1085,     w1086,     y1068 ];   const e1093 = [            f1060,     x1061,       o1062,      j1063 ];   const d1090                 = 'ITER';   const k1112             = 'PROB';   const HOLD                    = 'HOLD';   const n1095            = 'NUM#';   const y1096                  = 'NUM';    const NUMBER_PRECISION        = 'NPREC';    const o1097             = 'NSIGN';    const a1098         = 'ABS';    const NUMBER_NEGATIVE         = 'NEG';    const c1099            = 'ROUND';    const NUMBER_QUANTIZE         = 'QUANT';    const p1100    = 'SMINMAX';    const g1101           = 'MINMAX';    const d1102           = 'LIM';    const j1103            = 'NCURVE';    const NUMBER_MAP              = 'NMAP';    const NUMBER_BIAS             = 'NBIAS';    const t1104              = 'NANISNUM'; const c1105         = 'CONST';   const w1106         = 'DATE';   const b1107         = 'SEQ';   const s1108            = 'RANGE';   const d1109             = 'WAVE';   const m1110           = 'RAND';   const r1111            = 'NOISE';   const b1113       = 'ACCUM';   const p1114      = 'LERP';  const i1115            = 'SOLVE'; const c1116          = 'NANIM';  const k1117      = 'SMATH';   const w1118             = 'MATH';   const g1119              = 'ADD';    const g1120         = 'SUB';    const y1121         = 'MUL';    const g1122           = 'DIV';    const h1123           = 'MOD';    const t1124         = 'EXP';  const t1125          = 'NBOOL';   const d1126              = 'NOT'; const s1127              = 'AND'; const n1128               = 'OR'; const d1129              = 'XOR';  const l1130        = 'COND'; const h1131            = 'EQ'; const j1132        = 'NE'; const k1133             = 'LT'; const e1134    = 'LE'; const c1135          = 'GT'; const t1136 = 'GE';  const l1137             = 'TRIG';   const j1138              = 'SIN';    const l1139              = 'COS';    const h1140              = 'TAN'; const u1141            = 'ATAN2';  const x1142           = 'CNVANG';   const s1094 = [     k1064,     c1065,     n1066,     ...s1092,     r1074,     j1075,     w1076,     k1077,     n1078,     t1079,     REORDER_LIST,     SHIFT_LIST,     j1080,     BUCKLE_LIST,     v1082,     x1081,     d1083,     n1084,     p1087,     SELECT_FROM_LIST,     y1088,     q1089,     f1067,     y1068,          d1090,     k1112,     HOLD,     w1069,     z1070,     w1071,     w1072,     GET_LIST_VALUE_NAMES,     LIST_VALUE_NAMES,     OBJECT_NAME ];   const v1143 = [     w1118,     k1117,     g1119,     g1120,     y1121,     g1122,     h1123,     t1124 ];   const e1144 = [     t1125,     d1126,     s1127,     n1128,     d1129 ];   const l1145 = [     l1130,     h1131,     j1132,     k1133,     e1134,     c1135,     t1136 ];   const u1146 = [     l1137,     j1138,     l1139,     h1140,     u1141 ];   const q1147     = 'TEXT#'; const p1148           = 'TEXT'; const k1149    = 'TLEN'; const l1150      = 'TTRIM'; const o1151 = 'TSUB'; const s1152  = 'TCONT'; const t1153      = 'TCASE'; const w1154   = 'TREPL'; const r1155      = 'TJOIN'; const a1156       = 'TPAD'; const w1157   = 'TCMP'; const q1158      = 'TCHAR'; const a1159   = 'TUNI'; const z1160  = 'INDEX'; const e1161 = 'N2T'; const o1162  = 'C2T'; const o1163 = 'T2N'; const s1164  = 'T2C'; const e1165     = 'TSPLT'; const b3488      = 'TJSON'; const a1167       = 'TCSV'; const x1168     = 'FETCH'; const n1169      = 'TFILE';   const o1170 = [     n1095,     x1061,     y1096,     NUMBER_PRECISION,     o1097,     a1098,     NUMBER_NEGATIVE,     c1099,     NUMBER_QUANTIZE,     p1100,     g1101,     d1102,     j1103,     NUMBER_MAP,     NUMBER_BIAS,     t1104,     c1105,     w1106,     b1107,     s1108,     d1109,     m1110,     r1111,     b1113,     p1114,     i1115,     c1116,     e1161,     q1158,      ...v1143,     ...e1144,     ...l1145,     ...u1146,      x1142,     BUCKLE_LIST ];   const r1171 = [     q1147,     o1062,     p1148,     k1149,     l1150,     o1151,     s1152,     t1153,     r1155,     a1156,     w1154,     w1157,     a1159,     z1160,     o1163,     s1164,     e1165,     b3488,     a1167,     x1168,     n1169 ];   const a1172        = 'COL#';   const l1173              = 'COL';    const z1174        = 'CVAL';   const m1175      = 'CCOR';   const a1176   = 'COLP3'; const l1177     = 'CCNT';   const c1178         = 'BLND';   const h1179  = 'CLERP';  const y1180        = 'CBLND';   const m1181 = [     a1172,     l1173,     m1175,     a1176,     c1178,     h1179,     y1180,     o1162 ];   const d1182          = 'FILL#'; const d1183                = 'FILL'; const s1184          = [d1182, d1183];    const w1185        = 'STRK#'; const o1186              = 'STRK'; const p1187        = [w1185, o1186];    const o1188    = 'CSTOP#'; const m1189          = 'CSTOP'; const c1190    = [o1188, m1189];    const x1191      = 'GRAD#'; const v1192            = 'GRAD'; const j1193      = [x1191, v1192];    const l1194 = 'RCRN#'; const c1195       = 'RCRN'; const g1196 = [l1194, c1195];  const j1197   = 'DRSH#'; const d1198         = 'DRSH'; const a1199   = [j1197, d1198];   const d1200  = 'INSH#'; const u1201        = 'INSH'; const t1202  = [d1200, u1201];   const b1203    = 'LBLR#'; const v1204          = 'LBLR'; const t1205    = [b1203, v1204];   const n1206     = 'BBLR#'; const h1207           = 'BBLR'; const u1208     = [n1206, h1207];   const j1209    = 'MASK#'; const q1210          = 'MASK'; const p1211    = [j1209, q1210];   const t1212   = 'BLEND#'; const i1213         = 'BLEND'; const c1214   = [t1212, i1213];   const m1215 = [     ...g1196,     ...a1199,     ...t1202,     ...t1205,     ...u1208,     ...c1214,     ...p1211 ];   const b1216 = [            a1172,              d1182,          x1191,            w1185,      j1197,     d1200,       b1203,        n1206,      t1212,       j1209 ];   const k1217           = 'CSTL';     const v1218           = 'SHP#';    const v1219       = 'RECT#'; const p1220             = 'RECT';  const s1221       = [v1219, p1220];   const l1222            = 'LINE#'; const l1223                  = 'LINE';  const l1224            = [l1222, l1223];     const r1225         = 'ELPS#'; const v1226               = 'ELPS';  const r1227         = [r1225, v1226];   const z1228         = 'TRPZ#'; const w1229               = 'TRPZ'; const f1230         = [z1228, w1229];   const b1237         = 'POLY#'; const h1238               = 'POLY';  const y1239         = [b1237, h1238];     const i1240            = 'STAR#'; const h1241                  = 'STAR';  const v1242            = [i1240, h1241];     const e1243      = 'TXTS#'; const v1244            = 'TXTS';  const m1245      = [e1243, v1244];    const d1246           = 'PT#'; const n1247                 = 'PT'; const h1248           = [d1246, n1247];  const z1249          = 'PCORN';  const b1250     = 'VPATH#'; const v1251           = 'VPATH';  const n1252     = [b1250, v1251];   const i1253   = 'VPT#'; const k1254         = 'VPT';  const l1255   = [i1253, k1254];  const j1256     = 'VEDGE#'; const h1257           = 'VEDGE';  const q1258     = [j1256, h1257];  const e1259   = 'VREG#'; const y1260         = 'VREG';  const w1261   = [e1259, y1260];  const h1262  = 'VNET#'; const y1263        = 'VNET';  const d1264  = [h1262, y1263];  const z1265     = 'SGRP#'; const h1266           = 'SGRP'; const q1267     = [z1265, h1266];  const d1268           = 'FRM#'; const y1269                 = 'FRM'; const t1270           = [d1268, y1269];   const h1232        = 'ARC#'; const r1231              = 'ARC'; const c1233        = [h1232, r1231];  const d1235       = 'WAVEP#'; const e1234             = 'WAVEP'; const t1236       = [d1235, e1234];  const z1271                  = 'MOVE'; const d1272                = 'ROT'; const w1273                 = 'SCALE'; const m1274                  = 'SKEW';  const i1275            = 'SCENTR'; const x1276           = 'RSTX';  const g1277                 = 'PLACE'; const p1278           = 'APPLY';    const PATH_LENGTH           = 'PTHLEN'; const JOIN_PATHS            = 'JOINPTH'; const REORIENT_PATHS        = 'REORPTH'; const u1284      = 'PTALPATH'; const k1285 = 'CPTONPATH'; const y1279        = 'MESPT'; const n1280                = 'VECLEN'; const i1281         = 'CIRCEN'; const ARC_FROM_POINTS       = 'ARCPT'; const j1282       = 'INTLIN'; const a1283     = 'PTLERP'; const REVERSE_PATH          = 'REVPTH'; const BLEND_PATH            = 'BLENDPTH';   const PATH_TYPES = [     v1251,      w1229,     r1231,     e1234 ];  const PATH_VALUES = [     b1250,      z1228,     h1232,     d1235 ];   const d1286         = 'SBOOL'; const z1287   = 'SBOOL#';  const s1288            = 'SBOOLU'; const t1289         = 'SBOOLS'; const u1290        = 'SBOOLI'; const l1291          = 'SBOOLE';   const k1292 = [     d1286,     z1287,     s1288,     t1289,     u1290,     l1291 ];   const d1293               = 'RENDER'; const EXPORT               = 'EXPORT';   const a1294 = [     v1218,     j1063,     v1219,     l1222,     r1225,     z1228,     b1237,     i1240,     e1243,     d1246,     b1250,     i1253,     j1256,     e1259,     h1262,     h1232,     d1235,     z1265,     d1268,     z1287,     j1197,     d1200,     b1203,     n1206,     t1212,     j1209 ];   const l1295 = [     d1272,     w1273,     m1274 ];   const z1296 = [     ...a1294,      ...s1221,     ...l1224,     ...r1227,     ...f1230,     ...y1239,     ...v1242,     ...m1245,     ...h1248,        z1249,     ...n1252,     ...l1255,     ...q1258,     ...w1261,     ...d1264,     ...c1233,     ...t1236,     ...q1267,     ...t1270,     ...k1292,          z1271,     ...l1295,     i1275,     x1276,              g1277,     p1278,          PATH_LENGTH,     JOIN_PATHS,     REORIENT_PATHS,     u1284,     k1285,              y1279,     n1280,     i1281,     r1231,     e1234,     ARC_FROM_POINTS,     j1282,     a1283,     REVERSE_PATH,     BLEND_PATH,      d1293,     EXPORT ];   const w1297 = [             f1060,      x1061,        o1062,       j1063,                 n1095,             q1147,            a1172,               d1182,       o1188,         x1191,           w1185,         o1188,         x1191,              v1218,        v1219,             l1222,          r1225,          z1228,          b1237,             i1240,       e1243,            d1246,      b1250,    i1253,      j1256,    e1259,   h1262,      z1265,            d1268,     l1194,      j1197,     d1200,       b1203,        n1206,       t1212,       j1209 ];   const a1298    = 'GROUP'; const v1299   = 'GPARAM';   const f1300 = [     a1298,     v1299 ];   const m1301       = 'CMNT'; const j1302 = 'CMNTARR'; const i1303         = 'PANEL';   const f1304        = 'ACT'; const b1305 = 'BFACT'; const s1306   = 'BFLST'; const r1307      = 'DIS'; const v1308       = 'NOC';   const PARAM         = 'PARAM';     const c1309           = 'LOG';   const n1310         = 'GRAPH';   const c1311 =  [        [h1123,   '%' ],     [g1122,   '/' ],      [g1120, '−' ],     [g1119,      '+' ],     [y1121, '×' ],     [t1124, 'e<sup>x']  ];   const s1312 =  [        [g1122,   '/' ],      [g1120, '−' ],     [g1119,      '+'],     [y1121, '×'] ];    const s1313 = 0; const q1314 = 1; const p1315  = 2; const m1316 = 3;   const h1317 =  [        [s1313, 'not'],     [q1314, 'xor'],      [p1315,  'or' ],     [m1316, 'and'] ];    const d1318             = 0; const t1319    = 1; const w1320        = 2; const i1321            = 3; const y1322 = 4; const j1323          = 5;   const e1324 =  [        [d1318,             '<'],     [t1319,    '≤'],     [w1320,        '≠'],     [i1321,            '='],     [y1322, '≥'],     [j1323,          '>'] ];    const i1325  = 0; const p1326  = 1; const z1327  = 2; const v1328 = 3; const b1329 = 4; const i1330 = 5;   const a1331 =  [        [i1325,  'sin' ],     [p1326,  'cos' ],     [z1327,  'tan' ],     [v1328, 'asin'],     [b1329, 'acos'],     [i1330, 'atan'] ];    const f1332               = 'EMPTY'; const t1333             = 'CONNECT'; const s1334              = 'CREATE'; const b1335       = 'CREATE_INSERT'; const y1336              = 'DELETE'; const b1337          = 'DISCONNECT'; const u1338          = 'LINK_STYLE'; const s1339       = 'LINK_VARIABLE'; const s1340 = 'LINK_VARIABLE_GROUP'; const l1341         = 'MAKE_ACTIVE'; const MAKE_NOT_CONDITION_ACTION  = 'MAKE_NOT_CONDITION'; const e1342        = 'MAKE_PASSIVE'; const q1343               = 'PASTE'; const f1344           = 'RECONNECT'; const r1345              = 'REMOVE'; const t1346              = 'RENAME'; const r1347      = 'REORDER_INPUTS'; const n1348 = 'REORDER_CONNECTIONS'; const k1349              = 'SELECT'; const y1350         = 'SELECT_MOVE'; const s1351          = 'MOVE_NODES'; const t1352     = 'SET_PARAM_VALUE'; const SET_MULTIPLE_VALUES_ACTION = 'SET_MULTIPLE_VALUES'; const h1353   = 'SET_PARAM_SETTING'; const y1354       = 'SET_NODE_RECT'; const w1355      = 'TOGGLE_DISABLE'; const o1356 = 'TOGGLE_PARAM_HEADER'; const z1357   = 'SET_CURRENT_GRAPH'; const e1358         = 'CREATE_PAGE'; const x1359         = 'DELETE_PAGE'; const m1360         = 'GROUP_NODES'; const s1361       = 'UNGROUP_NODES'; const v1362     = 'HIGHLIGHT_NODES'; const SCROLL_LIST_NODE_ACTION    = 'SCROLL_LIST_NODE'; const SET_LIST_DIVIDER_ACTION    = 'SET_LIST_DIVIDER'; const SET_NODE_PARAM_ACTION      = 'SET_NODE_PARAM';   const t1363               = 'BNORM'; const t1364               = 'BDARK'; const n1365             = 'BMULT'; const w1366          = 'BPDRK'; const y1367           = 'BBURN'; const z1368              = 'BLITE'; const o1369               = 'BSCRN'; const r1370         = 'BPLGT'; const l1371          = 'BDODG'; const n1372              = 'BOVER'; const k1373           = 'BSOFT'; const b1374           = 'BHARD'; const l1375           = 'BDIFF'; const e1376            = 'BEXCL'; const h1377                  = 'BHUE'; const e1378           = 'BSAT'; const m1379                = 'BCOL'; const p1380           = 'BLUM';   const x1381 = [     [t1363,       'normal',       'NORMAL'      ],     [t1364,       'darken',       'DARKEN'      ],     [n1365,     'multiply',     'MULTIPLY'    ],     [w1366,  'plus darker',  'LINEAR_BURN' ],     [y1367,   'color burn',   'COLOR_BURN'  ],     [z1368,      'lighten',      'LIGHTEN'     ],     [o1369,       'screen',       'SCREEN'      ],     [r1370, 'plus lighter', 'LINEAR_DODGE'],     [l1371,  'color dodge',  'COLOR_DODGE' ],     [n1372,      'overlay',      'OVERLAY'     ],     [k1373,   'soft light',   'SOFT_LIGHT'  ],     [b1374,   'hard light',   'HARD_LIGHT'  ],     [l1375,   'difference',   'DIFFERENCE'  ],     [e1376,    'exclusion',    'EXCLUSION'   ],     [h1377,          'hue',          'HUE'         ],     [e1378,   'saturation',   'SATURATION'  ],     [m1379,        'color',        'COLOR'       ],     [p1380,   'luminosity',   'LUMINOSITY'  ] ];    const m1382 = [     ['thin',        100],     ['extra light', 200],     ['light',       300],     ['regular',     400],     ['medium',      500],     ['semi bold',   600],     ['bold',        700],     ['extra bold',  800],     ['black',       900] ];    const FO_TYPE           =  0; const FO_NODE_ID        =  1;  const FO_OBJECT_ID      =  2;   const FO_STYLE_ID     = 2; const FO_OBJECT_NAME    =  3;   const FO_STYLE_NAME   = 3;  const FO_FEEDBACK       =  4;   const FO_STYLE_PAINTS = 4; const FO_RETAIN         =  5;   const FO_XP0            =  6; const FO_XP1            =  7; const FO_XP2            =  8;  const FO_SCALE          =  9;  const FO_FILLS          = 10; const FO_STROKES        = 11;   const FO_STROKE_WEIGHT  = 12; const FO_STROKE_ALIGN   = 13; const FO_STROKE_JOIN    = 14;                                     const FO_STROKE_MITER   = 15; const FO_STROKE_CAP     = 16; const FO_STROKE_DASHES  = 17;  const FO_EFFECTS        = 18;  const FO_DECO           = 19; const FO_IS_CENTER      = 20;     const FO_OPACITY        = 21; const FO_BLEND          = 22; const FO_MASK           = 23;  const FO_X              = 24;                                                                         const FO_BOOLEAN_CHILDREN    = 24;                                                                                              const FO_GROUP_CHILDREN = 24; const FO_Y              = 25;                                                                         const FO_BOOLEAN_OPERATION   = 25; const FO_WIDTH          = 26;    const FO_HEIGHT         = 27;                                      const FO_RECT_ROUND     = 28;   const FO_ELLIPSE_ROUND   = 28;   const FO_VECTOR_NETWORK_DATA = 28;   const FO_VECTOR_PATH_DATA    = 28;   const FO_POLY_ROUND   = 28;   const FO_STAR_ROUND  = 28;   const FO_FIG_WIDTH      = 28;   const FO_FRAME_ROUND    = 28;                                 const FO_ELLIPSE_START   = 29;                                        const FO_VECTOR_PATH_WINDING = 29;   const FO_POLY_CORNERS = 29;   const FO_STAR_POINTS = 29;   const FO_FIG_HEIGHT     = 29;   const FO_FRAME_CHILDREN = 29;                                 const FO_ELLIPSE_SWEEP   = 30;                                        const FO_VECTOR_PATH_ROUND   = 30;                                 const FO_STAR_CONVEX = 30;   const FO_TEXT           = 30;                                                                                                                                                                    const FO_ELLIPSE_INNER   = 31;                                                                                                                                        const FO_FONT           = 31;                                                                                                                                                                                                       const FO_FONT_SIZE      = 32;                                                                                                                                                                                                       const FO_FONT_STYLE     = 33;                                                                                                                                                                                                                                                                                                                                                                                                                                            const FO_ALIGN_H        = 34;                                                                                                                                                                                                       const FO_ALIGN_V        = 35;                                                                                                                                                                                                                                                                                                                                                                                                                                            const FO_LINE_HEIGHT    = 36;                                                                                                                                                                                                       const FO_LETTER_SPACING = 37;


const x2780 = '12345679ABCDEFGHJKLMNPQRSTUVWXYZ';    function d846(array, chars = x2780) {     let d848 = '';           let len = array.length;     let i   = 0;      while (len > 0)     {         if (len >= 5)         {             const a0 = array[i  ],                   a1 = array[i+1],                   a2 = array[i+2],                   a3 = array[i+3],                   a4 = array[i+4];                          d848 += chars[ (a0 & 0xF8) >>> 3];             d848 += chars[((a0 & 0x07) <<  2) | ((a1 & 0xC0) >>> 6)];             d848 += chars[ (a1 & 0x3E) >>> 1];             d848 += chars[((a1 & 0x01) <<  4) | ((a2 & 0xF0) >>> 4)];             d848 += chars[((a2 & 0x0F) <<  1) | ((a3 & 0x80) >>> 7)];             d848 += chars[ (a3 & 0x7C) >>> 2];             d848 += chars[((a3 & 0x03) <<  3) | ((a4 & 0xE0) >>> 5)];             d848 += chars[ (a4 & 0x1F)];         }         else if (len == 4)         {             const a0 = array[i  ],                   a1 = array[i+1],                   a2 = array[i+2],                   a3 = array[i+3];                          d848 += chars[ (a0 & 0xF8) >>> 3];             d848 += chars[((a0 & 0x07) <<  2) | ((a1 & 0xC0) >>> 6)];             d848 += chars[ (a1 & 0x3E) >>> 1];             d848 += chars[((a1 & 0x01) <<  4) | ((a2 & 0xF0) >>> 4)];             d848 += chars[((a2 & 0x0F) <<  1) | ((a3 & 0x80) >>> 7)];             d848 += chars[ (a3 & 0x7C) >>> 2];             d848 += chars[((a3 & 0x03) <<  3)];         }         else if (len == 3)         {             const a0 = array[i  ],                   a1 = array[i+1],                   a2 = array[i+2];                          d848 += chars[ (a0 & 0xF8) >>> 3];             d848 += chars[((a0 & 0x07) <<  2) | ((a1 & 0xC0) >>> 6)];             d848 += chars[ (a1 & 0x3E) >>> 1];             d848 += chars[((a1 & 0x01) <<  4) | ((a2 & 0xF0) >>> 4)];             d848 += chars[((a2 & 0x0F) <<  1)];         }         else if (len == 2)         {             const a0 = array[i  ],                   a1 = array[i+1];                          d848 += chars[ (a0 & 0xF8) >>> 3];             d848 += chars[((a0 & 0x07) <<  2) | ((a1 & 0xC0) >>> 6)];             d848 += chars[ (a1 & 0x3E) >>> 1];             d848 += chars[((a1 & 0x01) <<  4)];         }         else if (len == 1)         {             const a0 = array[i];                          d848 += chars[ (a0 & 0xF8) >>> 3];             d848 += chars[((a0 & 0x07) <<  2)];         }           i   += 5;         len -= 5;     }       return d848; }    function h847(d848, chars = x2780) {     const array = [];       let len = d848.length;     let c   = 0;      while (len > 0)     {         if (len >= 8)         {             const c0 = chars.indexOf(d848[c  ]),                   c1 = chars.indexOf(d848[c+1]),                   c2 = chars.indexOf(d848[c+2]),                   c3 = chars.indexOf(d848[c+3]),                   c4 = chars.indexOf(d848[c+4]),                   c5 = chars.indexOf(d848[c+5]),                   c6 = chars.indexOf(d848[c+6]),                   c7 = chars.indexOf(d848[c+7]);              array.push( (c0         << 3) | ((c1 & 0x1C) >>> 2));             array.push(((c1 & 0x03) << 6) | (c2 << 1) | ((c3 & 0x10) >>> 4));             array.push(((c3 & 0x0F) << 4) | ((c4 & 0x1E) >>> 1));             array.push(((c4 & 0x01) << 7) | (c5 << 2) | ((c6 & 0x18) >>> 3));             array.push(((c6 & 0x07) << 5) | c7);         }         else if (len == 7)         {             const c0 = chars.indexOf(d848[c  ]),                   c1 = chars.indexOf(d848[c+1]),                   c2 = chars.indexOf(d848[c+2]),                   c3 = chars.indexOf(d848[c+3]),                   c4 = chars.indexOf(d848[c+4]),                   c5 = chars.indexOf(d848[c+5]),                   c6 = chars.indexOf(d848[c+6]);              array.push(( c0         << 3) | ((c1 & 0x1C) >>> 2));             array.push(((c1 & 0x03) << 6) | (c2 << 1) | ((c3 & 0x10) >>> 4));             array.push(((c3 & 0x0F) << 4) | ((c4 & 0x1E) >>> 1));             array.push(((c4 & 0x01) << 7) | (c5 << 2) | ((c6 & 0x18) >>> 3));         }         else if (len == 5)         {             const c0 = chars.indexOf(d848[c  ]),                   c1 = chars.indexOf(d848[c+1]),                   c2 = chars.indexOf(d848[c+2]),                   c3 = chars.indexOf(d848[c+3]),                   c4 = chars.indexOf(d848[c+4]);              array.push( (c0         << 3) | ((c1 & 0x1C) >>> 2));             array.push(((c1 & 0x03) << 6) | (c2 << 1) | ((c3 & 0x10) >>> 4));             array.push(((c3 & 0x0F) << 4) | ((c4 & 0x1E) >>> 1));         }         else if (len == 4)         {             const c0 = chars.indexOf(d848[c  ]),                   c1 = chars.indexOf(d848[c+1]),                   c2 = chars.indexOf(d848[c+2]),                   c3 = chars.indexOf(d848[c+3]);              array.push( (c0         << 3) | ((c1 & 0x1C) >>> 2));             array.push(((c1 & 0x03) << 6) | (c2 << 1) | ((c3 & 0x10) >>> 4));         }         else if (len == 2)         {             const c0 = chars.indexOf(d848[c  ]),                   c1 = chars.indexOf(d848[c+1]);              array.push((c0 << 3) | ((c1 & 0x1C) >>> 2));         }           c   += 8;         len -= 8;     }       return array; }


async function logSavedNode(nodeKey, j3989) {     const log  = u2103(await d1548(nodeKey, false));      if (j3989)     {         console.log(             '%c%s\n%c%s',              'background: #fa24; color: white;',              v1058(nodeKey),              'background: #fa44; color: #edc;',             log);     }     else     {         console.log(             '%c%s\n%c%s',              'background: #fdb; color: black;',              v1058(nodeKey),              'background: #fed; color: black;',             log);     } }    function u2103(json) {     let h4015 = json         .replace('{\n', '')         .replace('\n}', '')          .replace('[\n' + l869, '')         .replace('\n' + l869 + ']', '')          .split(l869 + '"params":\n').join('')           .split('": "').join(': ')         .split('", "').join(': ')          .split(l869 + '"').join(l869)         .split(l869 + l869 + '["').join(l869 + l869)                  .split('",\n').join('\n')         .split('"\n').join('\n')                  .split('"],\n').join('\n');       if (h4015[h4015.length-1] == '"')         h4015 = h4015.substring(0, h4015.length - 1);      if (h4015.substring(h4015.length-2) == '"]')             h4015 = h4015.substring(0, h4015.length - 2);      return h4015; }    function j2104(json) {     let h4015 = json         .replace('{\n', '')         .replace('\n}', '')         .replace('[\n' + l869, '')         .replace('\n' + l869 + ']', '');      return h4015; }    function i2105(o243, j3989) {     const p4193 = m927(o243, true);      if (j3989)     {         console.log(             '%c%s',              'background: #4f44; color: #ded',              p4193);      }     else     {         console.log(             '%c%s',              'background: #cfc; color: black;',              p4193);      } }


console.clear();   figma.payments.setPaymentStatusInDevelopment({type: 'PAID'});   figma.loadAllPagesAsync().then(() => {           figma.on('documentchange',  c1519);     figma.on('selectionchange', d1527);     figma.on('close',           x1520); });   c1509(true);   figma.clientStorage.getAsync('pro').then(data => {     figma.showUI(         __html__,         {             visible:     false,             themeColors: true,             title:       'Generator'          }); });   var h2692 = figma.viewport.zoom; setInterval(k1524, 100);   const t2781   = 'clock_'; const w2782 = 1000;   var l2783          = false; var objectCenterSize = 15;         function d1521() {     (async function()     {         figma.currentPage.loadAsync().then(async () =>         {             let w2784  = await figma.currentPage.getPluginData(figma.currentUser.id+',windowWidth');             let f2785 = await figma.currentPage.getPluginData(figma.currentUser.id+',windowHeight');              let j2786;             let p2787;              if (w2784  === NULL) { j2786  = 800; figma.currentPage.setPluginData(figma.currentUser.id+',windowWidth',  w2784 .toString()); } else j2786  = parseInt(w2784 );             if (f2785 === NULL) { p2787 = 600; figma.currentPage.setPluginData(figma.currentUser.id+',windowHeight', f2785.toString()); } else p2787 = parseInt(f2785);                           figma.ui.resize(                 Math.max(minWindowWidth,  j2786 ),                 Math.max(minWindowHeight, p2787));              figma.ui.show();                           const fonts = await figma.listAvailableFontsAsync();                  const eula      = (await figma.clientStorage.getAsync('eula'     )) === 'true';             const tutorials = (await figma.clientStorage.getAsync('tutorials')) === 'true';             const isLocked  = await z1526();                       l1528(             {                 cmd:          'uiReturnFigStartGenerator',                 currentUser:   figma.currentUser,                 viewportRect:  figma.viewport.bounds,                 viewportZoom:  figma.viewport.zoom,                 fonts:         fonts,                 eula:          eula,                 tutorials:     tutorials,                 isLocked:      isLocked,                 windowWidth:   j2786,                 windowHeight:  p2787             });         });     })(); }    function h1522() {     c1509();      figma.showUI(         __html__,         {             visible:     false,             themeColors: true         }); }    function g1523() {     setInterval(r1525, w2782); }    function k1524() {     if (figma.viewport.zoom == h2692)         return;      h2692 = figma.viewport.zoom;      t2680();     q1542();     c1544(); }    function r1525() {     b1549(t2781 + figma.currentUser.sessionId.toString(), Date.now().toString()) }    async function z1526() {     await figma.currentPage.loadAsync();       const clocks = figma.currentPage.getPluginDataKeys()         .filter(k =>                 k.length > t2781.length             && k.substring(0, t2781.length) == t2781             && k.substring(   t2781.length) != figma.currentUser.sessionId.toString())         .map(async k => parseInt(await d1548(k)));       clocks.sort();      const now = Date.now();      const locked = clocks.length > 0         && now - (await clocks[clocks.length-1]) < w2782*2;       return locked; }    function d1527() {     t2680(); }


var t2713 = new Array();  var e2715  = new Array();     async function figGetObjectsFromIds(objectIds) {     for (let i = o2749.length-1; i >= 0; i--)         if (  !o2749[i].removed             && objectIds.includes(o2749[i].getPluginData('objectId')))             o2749.splice(i, 1);      for (let i = d2765.length-1; i >= 0; i--)         if (   d2765[i].removed             || objectIds.includes(d2765[i].getPluginData('objectId')))             d2765.splice(i, 1);      await figma.currentPage.loadAsync();      return figma.currentPage.findAll(o => objectIds.includes(o.getPluginData('objectId'))); }    async function b1508(nodeIds) {     for (let i = o2749.length-1; i >= 0; i--)         if (  !o2749[i].removed             && nodeIds.includes(o2749[i].getPluginData('nodeId')))             o2749.splice(i, 1);      for (let i = d2765.length-1; i >= 0; i--)         if (   d2765[i].removed             || nodeIds.includes(d2765[i].getPluginData('nodeId')))             d2765.splice(i, 1);      await figma.currentPage.loadAsync();      figma.currentPage         .findAll(o => nodeIds.includes(o.getPluginData('nodeId')))         .forEach(o => { if (!o.removed) o.remove(); });       t2713 = t2713.filter(a => !nodeIds.includes(a.nodeId)); }    function c1509(r1510 = false) {     for (const p1515 of figma.currentPage.children)     {         if (p1515.removed)             continue;          if (    p1515.getPluginData('objectId') != ''             &&  p1515.getPluginData('userId'  ) == figma.currentUser.id             && (   parseInt(p1515.getPluginData('retain')) == 0                 || r1510))              p1515.remove();     } }    function v1511(nodeIds, o1512) {     for (let i = t2713.length-1; i >= 0; i--)     {         const q2714 = t2713[i];          if (!nodeIds.includes(q2714.nodeId))             continue;           for (let j = q2714.objects.length-1; j >= 0; j--)         {             const p1515 = q2714.objects[j];                          if (    p1515.removed                 || !a1513(p1515, o1512))             {                 if (!p1515.removed)                     p1515.remove();                  m946(q2714.objects, p1515);                  if (o2749.includes(p1515))                     m946(o2749, p1515);                  if (d2765.includes(p1515))                     m946(d2765, p1515);             }                           if (  !p1515.removed)             {                 if (parseInt(p1515.getPluginData('retain')) == 2)                     k1534(p1515);             }         }           if (isEmpty(q2714.objects))             m946(t2713, q2714);      } }    function a1513(p1515, o1512) {     if (   p1515.type == h1266         || p1515.type == y1269)     {         for (const child of p1515.children)         {             const found = a1513(child, o1512);             if (found) return found;         }     }     else     {         const found = o1512.find(o =>                    p1515.getPluginData('objectId' ) == o[FO_OBJECT_ID]                 && p1515.getPluginData('userId'   ) == figma.currentUser.id                             ||    o[FO_RETAIN] == 2                && o[FO_RETAIN] == p1515.getPluginData('retain'));          if (found)              return found;     }           return null; }    function o1516(nodeIds, t1517) {           figma.getLocalPaintStylesAsync().then(paintStyles =>     {         paintStyles             .filter(s =>                      nodeIds.includes(s.getPluginData('nodeId')))                  .forEach(s =>              {                 const nodeId   = s.getPluginData('nodeId');                 const existing = t926(s.getPluginData('existing'));                                  if (!existing)                  {                     s.remove();                 }                 else if (t1517)                 {                     g948(e2715, a => a.nodeId == nodeId);                      s.setPluginData('type',     NULL);                     s.setPluginData('nodeId',   NULL);                     s.setPluginData('existing', NULL);                 }             });     });       if (t1517)         e2715 = e2715.filter(a => !nodeIds.includes(a.nodeId)); } 


var x1518 = false;                                                                                                                                        function c1519(e) {     for (const change of e.documentChanges)     {         switch (change.type)         {             case 'STYLE_CREATE':                                                     if (!change.style)                     break;                  if (!x1518)                 {                     change.style.setPluginData('type',     NULL);                     change.style.setPluginData('nodeId',   NULL);                     change.style.setPluginData('existing', NULL);                 }                  break;               case 'STYLE_PROPERTY_CHANGE':              {                 if (!change.style)                     break;                  if (!x1518)                 {                     const msg = {                         cmd:       'uiStylePropertyChange',                         styleId:    v949(change.id),                         properties: change.properties,                         name:       '',                         paints:     [] };                           for (const prop of change.properties)                     {                         switch (prop)                         {                             case 'name':  msg.name   = change.style.name;   break;                             case 'paint': msg.paints = change.style.paints; break;                         }                     }                       l1528(msg);                 }                                  break;             }                           case 'STYLE_DELETE':                 l1528({                     cmd:    'uiStyleDelete',                     styleId: change.id });                  break;         }     }      x1518 = false; }    function x1520() {     c1509();     l1528({ cmd: 'updateMetrics' }); }


   figma.ui.onmessage = function(msg) {     msg = JSON.parse(msg);           if (msg.cmd == 'returnUiGetValueForFigma')          return;       switch (msg.cmd)     {         case 'figStartGenerator':                     d1521                    ();                                            break;         case 'figRestartGenerator':                   h1522                  ();                                            break;               case 'figFinishStart':                        g1523                       ();                                            break;                 case 'figDockWindowNormal':                   o2722                        ('normal');                                    break;         case 'figDockWindowMaximize':                 o2722                        ('maximize');                                  break;         case 'figDockWindowTop':                      o2722                        ('top');                                       break;         case 'figDockWindowLeft':                     o2722                        ('left');                                      break;         case 'figDockWindowRight':                    o2722                        ('right');                                     break;         case 'figDockWindowBottom':                   o2722                        ('bottom');                                    break;                  case 'figGetMousePosition':                   c1594                  (msg.clientPosition);                          break;                   case 'figResizeWindow':                       m1597                      (msg.width, msg.height);                       break;           case 'figSetWindowRect':                      u1595                     (msg.x, msg.y, msg.width, msg.height);         break;          case 'figNotify':                             k1598                         (msg);                                         break;               case 'figGetLocalData':                       d1546                      (msg.key);                                     break;         case 'figSetLocalData':                       r1547                      (msg.key, msg.value);                          break;               case 'figClearAllLocalData':                  h4010                 ();                                            break;               case 'figGetPageData':                        d1548                       (msg.key);                                     break;         case 'figSetPageData':                        b1549                       (msg.key, msg.value);                          break;                  case 'figSavePages':                          h1554                         (msg.pageIds, msg.pageJson, msg.currentPageId); break;                case 'figLoadNodesAndConns':                  a1551                 (msg.debugMode);                               break;         case 'figSaveNodes':                          h1555                         (msg.nodeIds, msg.nodeJson);                   break;               case 'figGetAllLocalTemplateNames':           k2719          ();                                            break;         case 'figSaveLocalTemplate':                  n1556                 (msg.r4011, msg.template);              break;          case 'figRemoveConnsToNodes':                 y1557                (msg.nodeIds);                                 break;         case 'figRemoveSavedNodesAndConns':           r1558          (msg.nodeIds);                                 break;         case 'figRemoveAllSavedNodesAndConns':        r1559       ();                                            break;                case 'figLogAllSavedNodesAndConns':           c1560          (msg.j3989);                                break;         case 'figLogAllSavedNodes':                   i1561                  (msg.j3989);                                break;         case 'figLogAllSavedConns':                   f1562                  (msg.j3989);                                break;               case 'figLogAllSavedPageKeys':                e1563               (msg.j3989);                                break;         case 'figLogAllSavedPages':                   o1564                  (msg.j3989);                                break;         case 'figLogAllSavedConnKeys':                z1565               (msg.j3989);                                break;          case 'figLogAllLocalData':                    p1566                   (msg.j3989);                                break;               case 'figGetValue':                           t1567                          (msg.key, msg.spec);                           break;          case 'figRemoveSavedPage':                    s1569                   (msg.pageId);                                  break;         case 'figRemoveAllSavedPages':                k1570               ();                                            break;           case 'figSaveConnection':                     p1571                    (msg.key, msg.json);                           break;         case 'figSaveConnections':                    q1572                   (msg.keys, msg.json);                          break;         case 'figUpdateSavedConnections':             r1573            (msg.curKeys, msg.newKeys, msg.json);          break;         case 'figDeleteSavedConnection':              y1574             (msg.key);                                     break;               case 'figRemoveAllSavedConnections':          n1575         ();                                            break;         case 'figDeleteSavedConnectionsToNode':       n1576      (msg.nodeId);                                  break;         case 'figDeleteSavedConnectionsFromNode':     i1577    (msg.nodeId);                                  break;         case 'figRemovePluginDataFromAllLocalStyles': e1578();                                            break;          case 'figGetAllLocalVariables':               a1602         (msg.nodeId, msg.px, msg.py);                  break;         case 'figLinkNodeToVariable':                 q1604                (msg.nodeId, msg.variableId);                  break;         case 'figUpdateVariable':                     figUpdateVariableAsync               (msg.variableId, msg.value);                   break;          case 'figGetAllLocalColorStyles':             b1579            (msg.nodeId, msg.px, msg.py);                  break;         case 'figLinkNodeToExistingColorStyle':       o1580      (msg.nodeId, msg.styleId);                     break;                           case 'figExport':                             figExport                            (msg.objectIds, msg.scale, msg.format, msg.suffix); break;          case 'figGetObjectSize':                      v1533                     (msg.object);                                  break;         case 'figGetVariableUpdates':                 q1568                (msg.linkedVarIds);                            break;          case 'figUpdateShowIds':                                   l2783 = msg.l2783;              break;               case 'figUpdateObjectCenterSize':                                   objectCenterSize = msg.objectCenterSize;              break;               case 'figDeleteAllObjects':                   c1509                  ();                                            break;          case 'figUpdateObjectsAndStyles':             a2728 = 0;             c2729  = 0;                          msg.objects.forEach(o => o.counted = false);                          w2716(                 null,                  msg.objects,                  msg.f4003,                  msg.j2051,                 msg.nodeIds,                  msg.q2745,                  msg.b2746,                  msg.x270);                          n1585(msg);                          break;               case 'figDeleteObjectsAndStyles':             b1508(msg.nodeIds);             o1516(msg.nodeIds, msg.t1517);             break;               case 'figDeleteObjectsExcept':                          v1511(msg.nodeIds, msg.ignoreObjects);             break;               case 'figTriggerUndo': figma.triggerUndo(); break;         case 'figCommitUndo':  figma.commitUndo();  break;          case 'figSaveSnapshot': figSaveSnapshot(msg.index, msg.objectIds); break     }       l1528({         cmd:    'uiEndFigMessage',         msgCmd:  msg.cmd }); };         function l1528(msg) {     figma.ui.postMessage(JSON.stringify(msg)); }  


async function c2717(key) {     return await figma.clientStorage.getAsync(key);  }    function d1546(key) {     figma.currentPage.loadAsync().then(() =>     {         if (key == 'canvasEmpty')         {             l1528(             {                 cmd:  'uiReturnFigGetLocalData',                 key:   key,                 value: figma.currentPage.children.length == 0             });         }         else if (key == 'debugWarningCrash')         {             figma.clientStorage.getAsync('debugWarning').then(data =>             {                 l1528({                     cmd:  'uiReturnFigGetLocalData',                     key:   key,                     value: data                 });             });         }         else         {             figma.clientStorage.getAsync(key).then(data =>             {                 l1528({                     cmd:  'uiReturnFigGetLocalData',                     key:   key,                     value: data                 });             });         }     }); }    function r1547(key, value, postToUi = true) {     figma.clientStorage.setAsync(key, value);       if (postToUi)     {         l1528({             cmd:  'uiReturnFigSetLocalData',             key:   key,             value: value         });     } }    async function h4010() {     const keys = await figma.clientStorage.keysAsync();       for (const key of keys)         figma.clientStorage.deleteAsync(key); }    async function d1548(key, postToUi = true) {     await figma.currentPage.loadAsync();      const data = figma.currentPage.getPluginData(key);      if (postToUi)     {         l1528({             cmd:  'uiReturnFigGetPageData',             key:   key,             value: data         });     }      return data; }    function b1549(key, value) {     h1550(key);      figma.currentPage.setPluginData(key, value); }    function h1550(key) {     figma.currentPage.setPluginData(key, '');  }    function a1551(debugMode) {     figma.currentPage.loadAsync().then(() =>     {                    const pageKeys  = figma.currentPage.getPluginDataKeys().filter(k => m1054(k));         const nodeKeys  = figma.currentPage.getPluginDataKeys().filter(k => i1055(k));         const connKeys  = figma.currentPage.getPluginDataKeys().filter(k => c1056(k));           if (!debugMode)             n1553(nodeKeys, connKeys);          const pages     = pageKeys.map(k => figma.currentPage.getPluginData(k));         const nodes     = nodeKeys.map(k => figma.currentPage.getPluginData(k));         const o2122     = connKeys.map(k => figma.currentPage.getPluginData(k));           const pageOrder     = figma.currentPage.getPluginData('pageOrder').split(',');         const currentPageId = figma.currentPage.getPluginData('currentPageId');                   q1552(nodes);           const showAllColorSpaces = figma.currentPage.getPluginData('showAllColorSpaces');           l1528({             cmd:               'uiReturnFigLoadNodesAndConns',             showAllColorSpaces: showAllColorSpaces,             pageKeys:           pageKeys,             pageJson:           pages,             pageOrder:          pageOrder,             currentPageId:      currentPageId,             nodeKeys:           nodeKeys,             nodeJson:           nodes,             connKeys:           connKeys,             connJson:           o2122         });     }); }    function q1552(nodes) {     e2715 = [];       figma.getLocalPaintStylesAsync().then(paintStyles =>     {         for (const d3002 of nodes)         {             const node = JSON.parse(d3002);              if (node.type == k1217)             {                 const style = paintStyles.find(s =>                 {                     const nodeId = s.getPluginData('nodeId');                     return nodeId == node.id;                 });                  if (style)                 {                     e2715.push({                         nodeId:   node.id,                          existing: t926(node.existing),                          styles:   [style]});                 }             }         }     }); }    function n1553(nodeKeys, connKeys) {     figma.currentPage.loadAsync().then(() =>     {          const y2718 = '"loading": "true"';         const not         = '{\n';         const set         = '{\n' + l869 + y2718 + ',\n';          nodeKeys.forEach(k => figma.currentPage.setPluginData(k,              figma.currentPage.getPluginData(k)                 .replace(set, not)                 .replace(not, set)));                  connKeys.forEach(k => figma.currentPage.setPluginData(k,              figma.currentPage.getPluginData(k)                 .replace(set, not)                 .replace(not, set)));     }); }    function h1554(pageIds, pageJson, currentPageId) {     for (let i = 0; i < pageIds.length; i++)     {         b1549(             q925(pageIds[i]),              pageJson[i]);     }      b1549('pageOrder',     pageIds.join(','));     b1549('currentPageId', currentPageId); }    function h1555(nodeIds, nodeJson) {     for (let i = 0; i < nodeIds.length; i++)     {         b1549(             y923(nodeIds[i]),             nodeJson[i]);             } }    async function k2719() {     let keys = await figma.clientStorage.keysAsync();       keys = keys.filter(k =>             k.length >= y877.length         && k.substring(0, y877.length) == y877);              l1528({         cmd:          'uiReturnGetAllLocalTemplateNames',         templateNames: keys     }) }    function n1556(r4011, template) {     r1547(         y877 + ' ' + r4011,         template); }    function y1557(nodeIds) {     figma.currentPage.loadAsync().then(() =>     {         const connKeys = figma.currentPage.getPluginDataKeys().filter(k => c1056(k));          for (const key of connKeys)         {             const parts = y1059(key).split(' ');              if (   nodeIds.includes(parts[0])                 || nodeIds.includes(parts[2]))                 h1550(key);         }     }); }    function r1558(nodeIds) {     figma.currentPage.loadAsync().then(() =>     {         y1557(nodeIds);          const nodeKeys = figma.currentPage.getPluginDataKeys().filter(             k => i1055(k)             && nodeIds.includes(v1058(k)));          nodeKeys.forEach(k => h1550(k));     }); }    function r1559() {     figma.currentPage.loadAsync().then(() =>     {         const nodeKeys = figma.currentPage.getPluginDataKeys().filter(k => i1055(k));         const connKeys = figma.currentPage.getPluginDataKeys().filter(k => c1056(k));          for (const key of nodeKeys) h1550(key);         for (const key of connKeys) h1550(key);     }); }    async function c1560(j3989) {     await i1561(j3989);           f1562(j3989); }    async function i1561(j3989) {     await figma.currentPage.loadAsync();      figma.currentPage.getPluginDataKeys()         .filter (k => i1055(k))         .forEach(async k => await logSavedNode(k, j3989)); }    function f1562(j3989) {     figma.currentPage.loadAsync().then(() =>     {         const connKeys = figma.currentPage.getPluginDataKeys()             .filter(k => c1056(k));                      connKeys.sort((key1, key2) =>          {             const p1 = y1059(key1).split(' ');             const p2 = y1059(key2).split(' ');              if (p1[2] != p2[2]) return p1[2] < p2[2] ? -1 : 1;             if (p1[3] != p2[3]) return parseInt(p1[3]) - parseInt(p2[3]);                          if (p1[2] == p2[0]) return -1;             if (p2[2] == p1[0]) return  1;              return 0;         });          connKeys.forEach(k => i2105(JSON.parse(figma.currentPage.getPluginData(k)), j3989));     }); }    function e1563(j3989) {     figma.currentPage.loadAsync().then(() =>     {         const connKeys = figma.currentPage.getPluginDataKeys()             .filter(k => m1054(k));                      connKeys.forEach(k =>              console.log(                 '%c'+k,                  'background: #fff; color: ' + (j3989 ? 'black' : 'white')));          const pageOrder = figma.currentPage.getPluginData('pageOrder');                      console.log(             '%c'+pageOrder,              'background: #fff; color: ' + (j3989 ? 'black' : 'white'));     }); }    function o1564(j3989) {     figma.currentPage.loadAsync().then(() =>     {         const connKeys = figma.currentPage.getPluginDataKeys()             .filter(k => m1054(k));                      connKeys.forEach(k =>              console.log(                 '%c'+figma.currentPage.getPluginData(k),                  'background: #fff; color: ' + (j3989 ? 'black' : 'white')));          const pageOrder = figma.currentPage.getPluginData('pageOrder');                      console.log(             '%c'+pageOrder,              'background: #fff; color: ' + (j3989 ? 'black' : 'white'));     }); }    function z1565(j3989) {     figma.currentPage.loadAsync().then(() =>     {         const connKeys = figma.currentPage.getPluginDataKeys()             .filter(k => c1056(k));                      connKeys.forEach(k =>              console.log(                 '%c'+k,                  'background: #dff; color: ' + (j3989 ? 'black' : 'white')));     }); }    function p1566(j3989) {     figma.clientStorage.keysAsync().then(keys =>         keys.forEach(k =>              figma.clientStorage.getAsync(k).then(val => console.log(k + ': ' + val)))); }    async function t1567(key, spec) {     let result = null;       switch (key)     {         case 'getVariableData':             result = await l1603(spec);             break;          case 'getPaidStatus':             result = figma.payments.status.type;             break;          case 'figSubscribe':         {             await figma.payments.initiateCheckoutAsync({interstitial: 'PAID_FEATURE'});             result = figma.payments.status.type;             break;         }     }           l1528(     {         cmd:  'returnFigGetValue',         value: result     }); }    function q1568(varIds) {     l1603(varIds).then(values =>     {         l1528(         {             cmd:   'uiReturnFigGetVariableUpdates',             values: values         });     }); }    async function s1569(pageId) {     h1550(q935(pageId));      const pageOrder = (await d1548('pageOrder')).split(',');     g948(pageOrder, id => id == pageId);     b1549('pageOrder', pageOrder.join(',')); }    function k1570() {     figma.currentPage.loadAsync().then(() =>     {         const pageKeys = figma.currentPage.getPluginDataKeys().filter(k => m1054(k));         pageKeys.forEach(k => h1550(k));          h1550('pageOrder');     }); }    function p1571(key, json) {     b1549(key, json);         }    function q1572(_keys, _json) {     const keys = JSON.parse(_keys);     const json = JSON.parse(_json);      for (let i = 0; i < keys.length; i++)         b1549(keys[i], json[i]); }    function r1573(_curKeys, _newKeys, _json) {     const curKeys = JSON.parse(_curKeys);     const newKeys = JSON.parse(_newKeys);     const json    = JSON.parse(_json);      for (let i = 0; i < curKeys.length; i++)     {         h1550(curKeys[i]);         b1549(newKeys[i], json[i]);     } }    function y1574(key) {     h1550(key);         }    function n1575() {     figma.currentPage.loadAsync().then(() =>     {         const connKeys = figma.currentPage.getPluginDataKeys().filter(k => c1056(k));         connKeys.forEach(k => h1550(k));     }); }    function n1576(nodeId) {     figma.currentPage.loadAsync().then(() =>     {         const connKeys = figma.currentPage.getPluginDataKeys().filter(k => c1056(k));          for (const key of connKeys)         {             const parts = key.split(' ');              if (parts[4] == nodeId)                 h1550(key);                 }     }); }    function i1577(nodeId) {     figma.currentPage.loadAsync().then(() =>     {         const connKeys = figma.currentPage.getPluginDataKeys().filter(k => c1056(k));          for (const key of connKeys)         {             const parts = key.split(' ');              if (parts[1] == nodeId)                 h1550(key);                 }     }); }    function e1578() {     figma.getLocalPaintStylesAsync().then(z1582 =>     {         for (const style of z1582)         {             style.setPluginData('type',     '');             style.setPluginData('nodeId',   '');             style.setPluginData('existing', '');         }     }); }    async function figSaveSnapshot(index, objectIds) {     const objects = await figGetObjectsFromIds(objectIds);     const group   = figma.group(objects, figma.currentPage);       const settings: ExportSettingsImage = { format: 'PNG' };      const icon = await group.exportAsync(settings);       figma.ungroup(group);       l1528(     {         cmd:       'uiReturnFigSaveSnapshot',         index:      index,         iconWidth:  group.width,         iconHeight: group.height,         icon:       icon     }); }


var x2720 = null; var k4012 = () => x2720 = null;  var u2721 = 'normal';     function c1594(clientPosition) {                                            l1528({             cmd:           'uiReturnFigGetMousePosition',             position:       {x: 0, y: 0},             clientPosition: clientPosition,             viewportZoom:   figma.viewport.zoom,             viewportRect:   figma.viewport.bounds });           }    function u1595(x, y, width, height) {     return;                                                                                                                                                                     }    function f1596(dock, rect, bounds) {     switch (dock)     {         case 'normal':                                                                    break;                      case 'maximize':             rect.x      = bounds.x;             rect.y      = bounds.y;             rect.width  = bounds.width;             rect.height = bounds.height;                     break;          case 'top':                   rect.x      = bounds.x;             rect.y      = bounds.y;             rect.width  = bounds.width;             break;          case 'left':                  rect.x      = bounds.x;             rect.y      = bounds.y;             rect.height = bounds.height;                     break;          case 'right':                 rect.x      = bounds.x + bounds.width - rect.width;             rect.y      = bounds.y;             rect.height = bounds.height;                     break;          case 'bottom':                rect.x      = bounds.x;             rect.y      = bounds.y + bounds.height - rect.height;             rect.width  = bounds.width;             break;     } }                function m1597(width, height) {     (async function()     {                                         width  = Math.floor(Math.max(0, width ));         height = Math.floor(Math.max(0, height));                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             figma.ui.resize(width, height);           await figma.currentPage.loadAsync();          figma.currentPage.setPluginData(figma.currentUser.id + ',windowWidth',  width .toString());         figma.currentPage.setPluginData(figma.currentUser.id + ',windowHeight', height.toString());                                                                    l1528(         {             cmd:   'uiReturnFigResizeWindow',             width:  width,             height: height         });     })(); }    async function o2722(dock)  {     if (   dock       != 'normal'         && u2721 == 'normal')     {         figma.clientStorage.setAsync('normalWindowX',      await figma.clientStorage.getAsync('normalWindowX'     ));         figma.clientStorage.setAsync('normalWindowY',      await figma.clientStorage.getAsync('normalWindowY'     ));         figma.clientStorage.setAsync('normalWindowWidth',  await figma.clientStorage.getAsync('normalWindowWidth' ));         figma.clientStorage.setAsync('normalWindowHeight', await figma.clientStorage.getAsync('normalWindowHeight'));     }       u2721 = dock;      figma.clientStorage.setAsync('windowDock', dock);      m1597(         await figma.clientStorage.getAsync('windowWidth' ),         await figma.clientStorage.getAsync('windowHeight')); }    function k1598(msg) {     c1599(         msg.text,          msg.prefix,          msg.delay,          msg.error,          msg.t1600,         msg.k1601); }    function c1599(text, prefix = 'Generator ', delay = 400, error = false, t1600 = '', k1601 = NULL) {     const options = {         timeout:   delay,         error:     error,         onDequeue: k4012     };       if (t1600 != '')     {         options['button'] = {text: t1600};          if (k1601.substring(0, 'removeConnection'.length) == 'removeConnection')         {             options['button']['action'] = () => y1574(k1601.split(',')[1]);         }         else         {             switch (k1601)             {                 case 'hideClearUndoWarning':                     options['button']['action'] = () => l1528({ cmd: 'uiHideClearUndoWarning' });                     break;             }         }     }       if (x2720)         x2720.cancel();       x2720 = figma.notify(prefix + text, options); }    async function p2723(key, params = null)  {     return await q2724(key, params); }    async function q2724(key, params = null)  {     return new Promise((resolve, reject) =>      {         const timeout = 60000;           l1528(         {             cmd: 'uiGetValueForFigma',             key:  key,             ...(params || {})         });          const z2725 = setTimeout(() =>              reject(new Error('Timeout: Result not received by Figma within the specified time')),             timeout);          function q4013(msg)          {             msg = JSON.parse(msg);              if (msg.cmd === 'returnUiGetValueForFigma')              {                 clearTimeout(z2725);                  resolve(                 {                      key:   msg.key,                      value: msg.value                 });                  figma.ui.off('message', q4013);             }         }          figma.ui.on('message', q4013);     }); }


var h2726   = []; var i2727   = [];  var  a2728 = 0; var  c2729  = 0;   function w1529(k111) {     return (k111[FO_RETAIN] === 2 ? '' : f873)          + (l2783 ? k111[FO_OBJECT_ID] : k111[FO_OBJECT_NAME]); }    async function o1530(m1514, addObject = null, addProps = true, transform = true) {     if (!g1532(m1514))         return null;       let p1515;      switch (m1514[FO_TYPE])     {         case p1220:      p1515 =       q2697         (m1514, addProps, transform);  break;         case l1223:           p1515 =       j2776         (m1514, addProps, transform);  break;         case v1226:        p1515 =       c2772      (m1514, addProps, transform);  break;         case h1238:        p1515 =       c2693      (m1514, addProps, transform);  break;         case h1241:           p1515 =       k2700         (m1514, addProps, transform);  break;         case v1244:     p1515 =       e2703         (m1514, addProps, transform);  break;         case n1247:          p1515 =       m2679        (m1514);                       break;         case v1251:    p1515 =       c2731   (m1514, addProps, transform);  break;         case y1263: p1515 =       s2732(m1514, addProps, transform);  break;         case d1286:  p1515 = await g2733 (m1514, addProps, transform);  break;         case h1266:    p1515 = await b2734   (m1514);                       break;         case y1269:          p1515 = await t2735        (m1514, addProps, transform);  break;     }        if (    addObject         &&  p1515 != undefined         &&  p1515 != null         && !p1515.removed)     {         p1515.name = w1529(m1514);          w955(                m1514[FO_TYPE] == h1266              || !!p1515,              'no Figma object created');           if (   p1515 != undefined             && p1515 != null)         {             p1515.setPluginData('retain', m1514[FO_RETAIN].toString());              if (m1514[FO_RETAIN] < 2)             {                 p1515.setPluginData('userId',    figma.currentUser.id);                 p1515.setPluginData('sessionId', figma.currentUser.sessionId.toString());                 p1515.setPluginData('type',      m1514[FO_TYPE     ]);                 p1515.setPluginData('nodeId',    m1514[FO_NODE_ID  ]);                 p1515.setPluginData('objectId',  m1514[FO_OBJECT_ID]);                 p1515.setPluginData('isCenter',  a940(m1514[FO_IS_CENTER]));                                   if (m1514[FO_TYPE] == n1247)                     o2749.push(p1515);                              if (m1514[FO_DECO])                     i1545(p1515);             }              addObject(p1515);         }     }           if (!m1514.counted)     {         c2729++;         m1514.counted = true;     }      return p1515; }    async function r1531(p1515, m1514, addProps, transform) {     if (  !g1532(m1514)         || p1515 == undefined         || p1515 == null         || p1515.removed)         return;               p1515.name = w1529(m1514);          p1515.setPluginData('retain', m1514[FO_RETAIN].toString());       switch (m1514[FO_TYPE])     {         case p1220:      n2698         (p1515, m1514, addProps, transform);  break;         case l1223:           r2777         (p1515, m1514, addProps, transform);  break;         case v1226:        k2773      (p1515, m1514, addProps, transform);  break;         case h1238:        t2694      (p1515, m1514, addProps, transform);  break;         case h1241:           a2701         (p1515, m1514, addProps, transform);  break;         case v1244:     v2704         (p1515, m1514, addProps, transform);  break;         case n1247:          y2736        (p1515, m1514);                       break;         case v1251:    p2737   (p1515, m1514, addProps, transform);  break;         case y1263: a2738(p1515, m1514, addProps, transform);  break;         case d1286:  n2739      (p1515, m1514, addProps, transform);  break;         case h1266:    m2740   (p1515, m1514);                       break;         case y1269:          q2741        (p1515, m1514, addProps, transform);  break;     }       if (    p1515 != undefined         &&  p1515 != null         && !p1515.removed)     {         if (p1515.parent == figma.currentPage)             await figma.currentPage.loadAsync();          p1515.parent.appendChild(p1515);          if (m1514[FO_DECO])             i1545(p1515);     }       if (!m1514.counted)     {         c2729++;         m1514.counted = true;     } }    async function w2716(l2742, w2743, b2744, j2051 = -1, nodeIds = [], q2745 = false, b2746 = false, x270 = false, addProps = true, transform = true) {     let o2747           = NULL;     let m2748          = null;              let abort               = false;      const d3626     = [];     let   v2730 = 0;       h2726.push(...nodeIds);       if (j2051 > -1)         a2728 = j2051;       for (const m1514 of w2743)     {         i2727.push(m1514);           if (m1514[FO_NODE_ID] != o2747)         {             o2747  = m1514[FO_NODE_ID];                          m2748 = t2713.find(a => a.nodeId == m1514[FO_NODE_ID]);              if (!m2748)             {                 t2713.push(m2748 =                  {                     nodeId:  m1514[FO_NODE_ID],                      objects: []                 });             }         }           const addObject = p1515 =>         {             if (    l2742 != undefined                 &&  l2742 != null                 && !l2742.removed)                  l2742.appendChild(p1515);             else                 m2748.objects.push(p1515);         };           let objects =                 l2742 != undefined             &&  l2742 != null             && !l2742.removed             ? l2742.children             : m2748.objects;          let p1515 = objects.find(o =>                 o.removed             ||    o.getPluginData('userId'  ) == figma.currentUser.id                && o.getPluginData('objectId') == m1514[FO_OBJECT_ID]);           if (   p1515 != undefined             && p1515 != null             && p1515.removed)         {             s941(objects, p1515);                      if (o2749.includes(p1515))                 m946(o2749, p1515);              if (d2765.includes(p1515))                 m946(d2765, p1515);         }           if (   p1515 == undefined             || p1515 == null             || p1515.removed)          {             const newObj = await o1530(m1514, addObject, addProps, transform);             d3626.push(newObj);         }          else if (  p1515 != undefined                &&  p1515 != null                && !p1515.removed                &&  p1515.getPluginData('type') == m1514[FO_TYPE].toString())          {             await r1531(p1515, m1514, addProps, transform);             if (    p1515 != undefined                 &&  p1515 != null                 && !p1515.removed)                  d3626.push(p1515);         }              else          {             p1515.remove();              if (o2749.includes(p1515))                 m946(o2749, p1515);              if (d2765.includes(p1515))                 m946(d2765, p1515);              await o1530(m1514, addObject, addProps, transform);         }           v2730++;                   if (v2730 >= b2744)         {             const result = await p2723(                 'returnObjectUpdate',                  {                      a2728: a2728,                     c2729:  c2729                  }                 ) as { key: string, value: boolean };              abort = result.value;              v2730 = 0;              if (abort) break;         }     }                 if (    l2742 != undefined         &&  l2742 != null         && !l2742.removed)     {         for (const p1515 of l2742.children)         {             if (      p1515 != undefined                    && p1515 != null                    && p1515.removed                 || !w2743.find(o =>                             o[FO_OBJECT_ID] == p1515.getPluginData('objectId')                         && p1515.getPluginData('userId') == figma.currentUser.id))                                          p1515.remove();         }     }                 for (const point of o2749)     {         if (point.parent == figma.currentPage)             await figma.currentPage.loadAsync();                  if (    point != undefined             &&  point != null             && !point.removed             && !point.parent.removed)             point.parent.appendChild(point);     }       if (    b2746         && !abort)     {                   v1511(             h2726,              i2727);          h2726 = [];         i2727 = [];                   if (   x270             && d3626.length > 0)         {             figma.viewport.scrollAndZoomIntoView(d3626);              const bounds = u1535(d3626);                              figma.viewport.zoom = Math.min(                 figma.viewport.bounds.width  * figma.viewport.zoom / bounds.width  - 0.05,                 figma.viewport.bounds.height * figma.viewport.zoom / bounds.height - 0.05);         }     }       await p2723(         'returnObjectUpdate',          {              a2728: a2728,             c2729:  c2729          }); }    function g1532(m1514) {     switch (m1514[FO_TYPE])     {         case p1220:      return s2696         (m1514);         case l1223:           return n2758         (m1514);         case v1226:        return w2759      (m1514);         case h1238:        return m4009      (m1514);         case h1241:           return w2699         (m1514);         case v1244:     return y2702         (m1514);         case n1247:          return i4008        (m1514);         case v1251:    return i2760   (m1514);         case y1263: return c2761(m1514);         case d1286:  return t2762      (m1514);         case h1266:    return g2763   (m1514);         case y1269:          return c2764        (m1514);     } }    async function v1533(m1514) {     (async () =>     {         const p1515 = await o1530(m1514);                  const width  = p1515.width;         const height = p1515.height;          p1515.remove();           l1528(         {             cmd: 'uiForwardToGenerator',             msg:              {                 cmd:     'returnFigGetObjectSize',                 objectId: m1514[FO_OBJECT_ID],                 width:    width,                 height:   height             }         });     })(); }    function k1534(p1515) {     p1515.setPluginData('type',      '');     p1515.setPluginData('nodeId',    '');     p1515.setPluginData('userId',    '');     p1515.setPluginData('sessionId', '');     p1515.setPluginData('objectId',  '');     p1515.setPluginData('isCenter',  '');     p1515.setPluginData('retain',    ''); }    function u1535(objects) {     const bounds =      {          left:   0,          top:    0,          right:  0,          bottom: 0      };      for (const k111 of objects)     {         if (k111.x < bounds.left                || bounds.left == bounds.right ) bounds.left   = k111.x;         if (k111.y < bounds.top                 || bounds.top  == bounds.bottom) bounds.top    = k111.y;         if (k111.x + k111.width  > bounds.right  || bounds.left == bounds.right ) bounds.right  = k111.x + k111.width;         if (k111.y + k111.height > bounds.bottom || bounds.top  == bounds.bottom) bounds.bottom = k111.y + k111.height;     }      return {         x:      bounds.left,         y:      bounds.top,         width:  bounds.right  - bounds.left,         height: bounds.bottom - bounds.top }; }    async function figExport(objectIds, scale, format, suffix) {     await figma.currentPage.loadAsync();           for (const objId of objectIds)     {         let p1515 = figma.currentPage.children.find(o =>                !o.removed             && o.getPluginData('userId'  ) == figma.currentUser.id             && o.getPluginData('objectId') == objId);              if (!p1515) continue;           const settings: ExportSettingsImage =          {             constraint:              {                 type: 'SCALE',                 value: scale             },             format: format == 0 ? 'PNG' : 'JPG',             suffix: suffix         };           await p1515.exportAsync(settings);     } }


const d2765 = []; const n2766  = [];    function e1536(z1537, c1538) {     const effects = [];       for (const effect of z1537)     {         const type = effect[0];          switch (type)         {             case 'DROP_SHADOW':             {                 const color = {                     r: Math.min(Math.max(0, effect[1]), 1),                      g: Math.min(Math.max(0, effect[2]), 1),                      b: Math.min(Math.max(0, effect[3]), 1),                     a: Math.min(Math.max(0, effect[4]), 1) };                  const offset = {                     x: effect[5],                     y: effect[6] };                  const radius  = effect[ 7];                 const spread  = effect[ 8];                 const blend   = effect[ 9];                 const behind  = effect[10];                 const visible = effect[11];                     if (   !isNaN(color.r)                     && !isNaN(color.g)                     && !isNaN(color.b)                     && !isNaN(color.a)                     && !isNaN(offset.x)                     && !isNaN(offset.y)                     && !isNaN(radius))                 {                     effects.push(                     {                         type:                 type,                          color:                color,                         offset:               offset,                         radius:               radius,                         visible:              visible,                         blendMode:            blend,                         showShadowBehindNode: behind,                         boundVariables:       {}                     });                      if (    c1538                         && !isNaN(spread))                         effects[effects.length-1]['spread'] = spread;                 }                  break;             }              case 'INNER_SHADOW':             {                 const color = {                     r: Math.min(Math.max(0, effect[1]), 1),                      g: Math.min(Math.max(0, effect[2]), 1),                      b: Math.min(Math.max(0, effect[3]), 1),                     a: Math.min(Math.max(0, effect[4]), 1) };                  const offset = {                     x: effect[5],                     y: effect[6] };                  const radius  = effect[ 7];                 const spread  = effect[ 8];                 const blend   = effect[ 9];                 const visible = effect[10];                     if (   !isNaN(color.r)                     && !isNaN(color.g)                     && !isNaN(color.b)                     && !isNaN(color.a)                     && !isNaN(offset.x)                     && !isNaN(offset.y)                     && !isNaN(radius)                     && !isNaN(spread))                 {                     effects.push(                     {                         type:           type,                          color:          color,                         offset:         offset,                         radius:         radius,                         spread:         spread,                         visible:        visible,                         blendMode:      blend,                         boundVariables: {}                     });                 }                  break;             }              case 'LAYER_BLUR':             {                 const radius  = effect[1];                 const visible = effect[2];                  if (!isNaN(radius))                 {                     effects.push(                     {                         type:           type,                          visible:        visible,                         radius:         Math.max(0, radius),                         boundVariables: {}                     });                 }                  break;             }              case 'BACKGROUND_BLUR':             {                 const radius  = effect[1];                 const visible = effect[2];                  if (!isNaN(radius))                 {                     effects.push(                     {                         type:           type,                          visible:        visible,                         radius:         Math.max(0, radius),                         boundVariables: {}                     });                 }                  break;             }         }     }       return effects; }    function j2686(p1515, m1514, phantom = true) {                        k1541(p1515, m1514);     u2687(p1515, m1514, phantom);     v2688  (p1515, m1514);           p1515.opacity   = m1514[FO_OPACITY];     p1515.blendMode = m1514[FO_BLEND  ];       const maskType = m1514[FO_MASK];      p1515.isMask = maskType > 0;      if (p1515.isMask)     {         switch (maskType)         {             case 1: p1515.maskType = 'ALPHA';     break;             case 2: p1515.maskType = 'VECTOR';    break;             case 3: p1515.maskType = 'LUMINANCE'; break;         }     }       if (   p1515.isMask         && p1515.fills  .length == 0         && p1515.strokes.length == 0)         p1515.fills =              [{                 type:      'SOLID',                  color:     {r:0, g:0, b:0},                 opacity:   1,                  blendMode: 'NORMAL'             }]; }    function v2688(p1515, m1514) {     if (   !!m1514[FO_FILLS]         &&  !isEmpty(m1514[FO_FILLS]))     {         p1515.fills = g959(m1514[FO_FILLS]);          if (d2765.includes(p1515))             m946(d2765, p1515);     }     else         p1515.fills = []; }    function u2687(p1515, m1514, phantom = true) {     if (    m1514[FO_STROKES] != null         && !isEmpty(m1514[FO_STROKES]))     {         d1540(             p1515,             g959(m1514[FO_STROKES]),             m1514[FO_STROKE_WEIGHT],             m1514[FO_STROKE_ALIGN ],             m1514[FO_STROKE_JOIN  ],             m1514[FO_STROKE_MITER ],             m1514[FO_STROKE_CAP   ],             h2689(m1514[FO_STROKE_DASHES]));          if (m1514[FO_DECO])             p1515.setPluginData('dashes', m1514[FO_STROKE_DASHES]);           if (d2765.includes(p1515))             m946(d2765, p1515);          if (m1514[FO_DECO])             e952(n2766, p1515);     }      else if ( isEmpty(m1514[FO_FILLS  ])           &&  isEmpty(m1514[FO_STROKES])           && !m1514[FO_MASK]           &&  phantom)     {         y1543(p1515);         e952(d2765, p1515);     }          else         p1515.strokes = []; }    function h2689(f1539) {     f1539 = <string><unknown>f1539;          f1539 = m957(f1539, ',');     f1539 = y958  (f1539, ',');     f1539 = f1539.trim();      return f1539 == ''           ? []           : f1539.split(',').map(s => Math.max(0, parseFloat(s))); }    function w2690(f1539) {     f1539 = <string><unknown>f1539;          f1539 = m957(f1539, ',');     f1539 = y958  (f1539, ',');     f1539 = f1539.trim();      return f1539 == ''           ? []           : f1539.split(',').map(s => Math.max(0, parseFloat(s) / h2692)); }    function d1540(p1515, fills, weight, align, join, miterLimit, cap, dashes = []) {     p1515.strokes          = fills;          p1515.strokeWeight     = Math.max(0, weight);     p1515.strokeAlign      = align;     p1515.strokeJoin       = join;           const  miterAngle       = miterLimit/360*Tau;     const n2767       = 1 / Math.sin(miterAngle/2);          p1515.strokeMiterLimit = Math.min(Math.max(0, n2767), 16);      p1515.strokeCap        = cap;      p1515.dashPattern      = dashes; }    function k1541(p1515, m1514) {     if (  !!m1514[FO_EFFECTS]         && !isEmpty(m1514[FO_EFFECTS]))     {         const c1538 =                m1514[FO_TYPE] == p1220             || m1514[FO_TYPE] == v1226             || m1514[FO_TYPE] == y1269;          p1515.effects = e1536(m1514[FO_EFFECTS], c1538);     }     else         p1515.effects = []; }    function q1542() {     for (const k111 of d2765)     {         if (k111.removed)             m946(d2765, k111);         else             y1543(k111);     } }    function y1543(k111) {     figma.currentPage.loadAsync().then(() =>     {         const back = figma.currentPage.backgrounds.find(b => b.type == 'SOLID') as SolidPaint;                   let phantomColor;          if (back)         {             const l =                   back.color.r * 0.2126                 + back.color.g * 0.7152                  + back.color.b * 0.0722;                               phantomColor =                 l > 0.5                 ? {r: 0, g: 0, b: 0}                 : {r: 1, g: 1, b: 1};         }         else             phantomColor = {r: 1, g: 0, b: 1};           d1540(             k111,             [{ type:  'SOLID',                color:   phantomColor,               opacity: 0.5 }],             1 / h2692,             'CENTER',             'MITER',             1,             'NONE',             [ 1 / h2692,                2 / h2692 ]);     }); }    function c1544() {     for (const p1515 of n2766)     {         if (p1515.removed)             m946(n2766, p1515);         else             i1545(p1515);     } }    function i1545(p1515) {     p1515.strokeWeight = Math.max(0, 1.5 / h2692);       if (t926(p1515.getPluginData('isCenter')))     {         const path  = p1515.vectorPaths[0];         const parts = path.data.split(' ');                  let t = { x: parseFloat(parts[1]), y: parseFloat(parts[2]) };         let c = { x: parseFloat(parts[4]), y: parseFloat(parts[5]) };         let r = { x: parseFloat(parts[7]), y: parseFloat(parts[8]) };          const a = 2;         const b = 0.05;         const f = 1 - Math.pow(1 - Math.min(h2692, 1), a) / Math.pow(a, b);              t = m898(c, d900(d885(r903(t, c)), objectCenterSize/f));         r = m898(c, d900(d885(r903(r, c)), objectCenterSize/f));           parts[1] = t.x; parts[2] = t.y;         parts[4] = c.x; parts[5] = c.y;         parts[7] = r.x; parts[8] = r.y;          const r2768 =          {             windingRule: path.windingRule,             data:        parts.join(' ')         };          p1515.vectorPaths = [r2768];     }       const dashes = p1515.getPluginData('dashes');      if (dashes != '')         p1515.dashPattern = w2690(dashes);         }


function b1579(nodeId, px, py) {     figma.getLocalPaintStylesAsync().then(_styles =>     {         const styles = new Array();          for (const y168 of _styles)         {             const _nodeId   = y168.getPluginData('nodeId');             const _existing = y168.getPluginData('existing');              const existing = !!_existing;              const style = {                  id:       y168.id,                 nodeId:   _nodeId,                 name:     y168.name,                 existing: existing,                 paints:   new Array()             };                           let onlyPaint = true;              for (const g2770 of y168.paints)             {                 if (g2770.type == 'SOLID')                 {                     style.paints.push([                         g2770.color.r,                         g2770.color.g,                         g2770.color.b,                         g2770.opacity]);                 }                 else                 {                     onlyPaint = false;                     break;                 }             }               if (onlyPaint)                 styles.push(style);         }           l1528({             cmd:   'uiReturnFigGetAllLocalColorStyles',             nodeId: nodeId,             px:     px,             py:     py,             styles: JSON.stringify(styles)});     }); }    function o1580(nodeId, styleId) {     figma.getLocalPaintStylesAsync().then(z1582 =>     {         if (styleId != NULL) i1581(z1582, nodeId, styleId);         else                 j1583(z1582, nodeId);     }); }    function i1581(z1582, nodeId, styleId, clearExisting = true) {     const x2769 = e2715.find(a => a.nodeId == nodeId);          if (   x2769          && clearExisting)          j1583(z1582, nodeId);       const s1587 = z1582.find(s => s.id == styleId);     w955(!!s1587, 'figStyle should be found here');       s1587.setPluginData('type',     k1217);     s1587.setPluginData('nodeId',   nodeId);     s1587.setPluginData('existing', a940(true));       e2715.push({         nodeId:   nodeId,          existing: true,          styles:   [s1587]});       return s1587; }    function j1583(z1582, nodeId) {     const s1587 = z1582.find(s => s.getPluginData('nodeId') == nodeId);     w955(!!s1587, 'figStyle should be found here');      if (s1587)      {         s1587.setPluginData('type',     NULL);         s1587.setPluginData('nodeId',   NULL);         s1587.setPluginData('existing', NULL);          g948(e2715, a => a.nodeId == nodeId);     }      return s1587; }    function p1584(styles, n1588) {     const s1587 = figma.createPaintStyle();       s1587.setPluginData('type',     n1588[FO_TYPE   ]);     s1587.setPluginData('nodeId',   n1588[FO_NODE_ID]);           s1587.name = n1588[FO_STYLE_NAME];       setStylePaints(s1587, n1588);       styles.push(s1587);       l1528({         cmd:    'uiSetStyleId',         nodeId:  n1588[FO_NODE_ID],         styleId: s1587.id });           return s1587; }    function n1585(msg) {     let o2747 = NULL;     let x2769;       for (const n1588 of msg.styles)     {         if (n1588[FO_NODE_ID] != o2747)         {             o2747 = n1588[FO_NODE_ID];                          x2769 = e2715.find(a => a.nodeId == n1588[FO_NODE_ID]);              if (!x2769)              {                 x2769 = {                     nodeId:   n1588[FO_NODE_ID],                                           styles:   [] };                  e2715.push(x2769);             }         }         else             x2769 = null;           const s1587 = x2769.styles[0];                           figma.getLocalPaintStylesAsync().then(z1582 =>         {             const localStyle  = z1582.find(s => s.getPluginData('nodeId') == n1588[FO_NODE_ID]);               if (    isValid(s1587)                 && !isValid(localStyle))              {                 s941(x2769.styles, s1587);             }               const existing =                  isValid(s1587  )                 && isValid(localStyle)                 && s1587.getPluginData('existing');               if (   !isValid(s1587  )                 || !isValid(localStyle))              {                 if (!existing)                 {                     x1518 = true;                      o1580(                         n1588[FO_NODE_ID ],                         n1588[FO_STYLE_ID]);                                      }             }             else if (isValid(s1587)                  && s1587.getPluginData('type') == n1588[FO_TYPE])              {                 x1518 = true;                 b1586(localStyle, n1588);             }                                                                                                                              });     } }    function b1586(s1587, n1588) {     setStylePaints(s1587, n1588);      s1587.name = n1588[FO_STYLE_NAME]; }    function getStylePaints(stylePaints) {     const paints = new Array();      for (const g2770 of stylePaints)     {         const fill = g2770[1].split(' ');          switch (g2770[0])         {             case 'SOLID':                 paints.push(                 {                     type:  'SOLID',                      color: { r: Math.min(Math.max(0, parseFloat(fill[0]) / 0xff), 1),                               g: Math.min(Math.max(0, parseFloat(fill[1]) / 0xff), 1),                               b: Math.min(Math.max(0, parseFloat(fill[2]) / 0xff), 1) },                     opacity: Math.min(Math.max(0, parseFloat(fill[3]) / 100), 1)                 });                  break;         }     }      return paints; }    function setStylePaints(s1587, n1588) {     if (!isEmpty(n1588[FO_STYLE_PAINTS]))         s1587.paints = getStylePaints(n1588[FO_STYLE_PAINTS]);     else         s1587.paints = []; } 


async function a1602(nodeId, px, py) {     figma.variables.getLocalVariablesAsync().then(async h2771 =>     {         const variables = new Array();          for (const _var of h2771)         {             const collection = await figma.variables.getVariableCollectionByIdAsync(_var.variableCollectionId);              const variable =              {                  id:             _var.id,                 resolvedType:   _var.resolvedType,                 name:           _var.name,                 collectionName: collection.name             };              variables.push(variable);         }           figma.variables.getLocalVariableCollectionsAsync().then(async collections =>         {             l1528(             {                 cmd:         'uiReturnFigGetAllLocalVariables',                 nodeId:       nodeId,                 px:           px,                 py:           py,                 variables:    JSON.stringify(variables),                 nCollections: collections.length             });         });     }); }    async function l1603(varIds) {     const h2771 = await figma.variables.getLocalVariablesAsync();      const variables = varIds.map(id => h2771.find(v => v.id == id));     let   values    = [];       for (let i = 0; i < varIds.length; i++)     {         const variable = variables[i];                  const collection =              variable != undefined              ? (await figma.variables.getVariableCollectionByIdAsync(variable.variableCollectionId))             : null;                               if (collection)         {             const vals = [];               for (const mode of collection.modes)             {                 let _var  = variable;                 let value = _var.valuesByMode[mode.modeId];                                  while (value && value.type === 'VARIABLE_ALIAS')                 {                     _var  = await figma.variables.getVariableByIdAsync(value.id);                     value = _var.valuesByMode[mode.modeId];                 }                  vals.push(value);             }               values.push(             {                 id:           varIds[i],                 name:         variable.name,                  resolvedType: variable.resolvedType,                  value:        vals[0]             });         }         else         {             values.push(             {                 id:           varIds[i],                  resolvedType: NULL,                  value:        null             });         }     }       return values; }    function q1604(nodeId, varId) {     figma.variables.getLocalVariablesAsync().then(h2771 =>     {         figLinkVariableAsync(h2771, nodeId, varId);     }); }    async function figUpdateVariableAsync(varId, value) {     figma.variables.getLocalVariablesAsync().then(async h2771 =>     {         let variable = h2771.find(v => v.id == varId);         if (!variable) return;           let collection = await figma.variables.getVariableCollectionByIdAsync(variable.variableCollectionId);         let mode       = collection.modes[0];                             let curValue = variable.valuesByMode[mode.modeId];                  while (curValue             && curValue.hasOwnProperty('type')             && curValue['type'] === 'VARIABLE_ALIAS')         {             variable = await figma.variables.getVariableByIdAsync(curValue['id']);             curValue = variable.valuesByMode[mode.modeId];                          collection = await figma.variables.getVariableCollectionByIdAsync(variable.variableCollectionId);             mode       = collection.modes[0];         }           if (value !== null)         {             if (variable.resolvedType == 'BOOLEAN')                 value = value != 0;             else                 variable.setValueForMode(mode.modeId, value);         }     }); }    async function figLinkVariableAsync(h2771, nodeId, varId) {     let variable = h2771.find(v => v.id == varId);     if (!variable) return null;       const [resolvedVar, values] = await figGetResolvedVariableValuesAsync(variable);       l1528(     {         cmd:         'uiReturnFigLinkNodeToVariable',         nodeId:       nodeId,         variableId:   resolvedVar ? resolvedVar.id           : NULL,         variableName: resolvedVar ? resolvedVar.name         : '',         resolvedType: resolvedVar ? resolvedVar.resolvedType : NULL,         values:       values     });       return resolvedVar; }    async function figGetResolvedVariableValuesAsync(variable) {     const values = [];           if (!variable)         return values;       const collection = await figma.variables.getVariableCollectionByIdAsync(variable.variableCollectionId);                  for (const mode of collection.modes)     {         let value = variable.valuesByMode[mode.modeId];                  while (   value                && value['type'] === 'VARIABLE_ALIAS')         {             variable = await figma.variables.getVariableByIdAsync(value.id);             value    = variable.valuesByMode[mode.modeId];         }                  values.push(value);     }       return [variable, values]; }


function c1589(tl, tr, bl) {     let vr = point(tr.x - tl.x, tr.y - tl.y);     let vb = point(bl.x - tl.x, bl.y - tl.y);       let sx = vr.x;     let sy = vb.y;      let kx = -vr.y;     let ky = -vb.x;          let dx = -tl.x;     let dy = -tl.y;       const _sx = kx/nozero(sx);     const _sy = ky/nozero(sy);      let j4190 = g888(         [[ 1, _sy, 0],          [_sx, 1,  0],          [ 0,  0,  1]],         l892(dx, dy));       j4190 = s890(j4190);       const a = p882(vr);      if (   a > Tau/4           && a < Tau*3/4)         j4190 = g888(j4190, l892(0, 0, 1, 1, Tau/2));              if (determinant(j4190) < 0)         j4190 = g888(j4190, l892(0, 0, -1, 1, 0));       return j4190; }    function g1590(p1515, tl, tr, bl)  {     const j4190 = c1589(tl, tr, bl);      p1515.relativeTransform =      [         j4190[0],         j4190[1]     ]; }    function g1591(p1515, m1514, setSize = true, noHeight = 0.01) {     if (   !m1514[FO_XP0]         || !m1514[FO_XP1]         || !m1514[FO_XP2])         return;       const xp0 = m1514[FO_XP0];     const xp1 = m1514[FO_XP1];     const xp2 = m1514[FO_XP2];           g1590(p1515, xp0, xp1, xp2);           if (setSize)     {         const k893 = distv(xp0, xp1);         const m894 = distv(xp0, xp2);              const height =             m1514[FO_TYPE] == v1244             ? m1514[FO_FIG_HEIGHT]             : m1514[FO_HEIGHT];              if (!p1515.removed)         {             p1515.resizeWithoutConstraints(                          Math.max(0.01, k893),                 height ? Math.max(0.01, m894) : noHeight);         }     } }     function h1592(d2684, y2685) {     if (d2684.removed)         return;       d2684.resizeWithoutConstraints(0.01, 0.01);       d2684.setPluginData('actualX', y2685[FO_X].toString());     d2684.setPluginData('actualY', y2685[FO_Y].toString());       d2684.x        = y2685[FO_X];     d2684.y        = y2685[FO_Y];      d2684.rotation = y2685[FO_IS_CENTER] ? 45 : 0; }    function k1593(d2684) {     if (!d2684.removed)         d2684.resizeWithoutConstraints(0.01, 0.01); }


function t2762(genBool) {     return true; }    async function g2733(genBool, addProps, transform) {     let objects = [];      for (const k111 of genBool[FO_BOOLEAN_CHILDREN])         await o1530(k111, o => objects = [...objects, o], false);       await figma.currentPage.loadAsync();           let figBool = null;      if (!isEmpty(objects))     {         switch (genBool[FO_BOOLEAN_OPERATION])         {             case 0: figBool = figma.union    (objects, figma.currentPage); break;             case 1: figBool = figma.subtract (objects, figma.currentPage); break;             case 2: figBool = figma.intersect(objects, figma.currentPage); break;             case 3: figBool = figma.exclude  (objects, figma.currentPage); break;         }     }       if (figBool)     {         figBool.expanded = false;         n2739(figBool, genBool, addProps, transform);     }       return figBool; }    async function n2739(figBool, genBool, addProps, transform)  {     if (genBool[FO_BOOLEAN_CHILDREN].length == 0)     {         figBool.remove();         return;     }           await w2716(         figBool,          genBool[FO_BOOLEAN_CHILDREN],          genBool[FO_BOOLEAN_CHILDREN].length,         -1,         [],          false,         false,         false,         false,         true);                       const hasProps =            genBool[FO_FILLS  ].length > 0         || genBool[FO_STROKES].length > 0         || genBool[FO_EFFECTS].length > 0;      j2686(figBool, genBool, !hasProps && addProps); }


function w2759(g2750) {     return g2750[FO_X            ] != null && !isNaN(g2750[FO_X            ])         && g2750[FO_Y            ] != null && !isNaN(g2750[FO_Y            ])         && g2750[FO_WIDTH        ] != null && !isNaN(g2750[FO_WIDTH        ])         && g2750[FO_HEIGHT       ] != null && !isNaN(g2750[FO_HEIGHT       ])         && g2750[FO_ELLIPSE_ROUND] != null && !isNaN(g2750[FO_ELLIPSE_ROUND])         && g2750[FO_ELLIPSE_START] != null && !isNaN(g2750[FO_ELLIPSE_START])         && g2750[FO_ELLIPSE_SWEEP] != null && !isNaN(g2750[FO_ELLIPSE_SWEEP])         && g2750[FO_ELLIPSE_INNER] != null && !isNaN(g2750[FO_ELLIPSE_INNER]); }    function c2772(g2750, addProps, transform) {     if (!w2759(g2750))         return null;               const p2751 = figma.createEllipse();      k2773(p2751, g2750, addProps, transform, true);           return p2751; }    function k2773(p2751, g2750, addProps, transform, isValid = false) {     if (   !isValid         && !w2759(g2750))         return;       x2774(p2751, g2750, transform);       if (o2749.includes(p2751))         w2681(p2751);     else          j2686(p2751, g2750, addProps); }    function x2774(p2751, g2750, transform) {     p2751.cornerRadius = g2750[FO_ELLIPSE_ROUND];      const start = g2750[FO_ELLIPSE_START] /360*(Math.PI*2);     const sweep = g2750[FO_ELLIPSE_SWEEP] /100*(Math.PI*2);      p2751.arcData =     {         startingAngle: start,         endingAngle:   start + sweep,         innerRadius:   Math.min(Math.max(0, g2750[FO_ELLIPSE_INNER]/100), 1)     };      if (transform)         g1591(p2751, g2750); }


function c2764(s2752) {     return s2752[FO_X          ] != null && !isNaN(s2752[FO_X          ])         && s2752[FO_Y          ] != null && !isNaN(s2752[FO_Y          ])         && s2752[FO_WIDTH      ] != null && !isNaN(s2752[FO_WIDTH      ])         && s2752[FO_HEIGHT     ] != null && !isNaN(s2752[FO_HEIGHT     ])         && s2752[FO_FRAME_ROUND] != null && !isNaN(s2752[FO_FRAME_ROUND]); }    async function t2735(s2752, addProps, transform) {     if (!c2764(s2752))         return null;                       const d2753 = figma.createFrame();      d2753.expanded = false;           if (d2753)     {         h2775(d2753, s2752, addProps, transform);           let objects = [];          for (const k111 of s2752[FO_FRAME_CHILDREN])             await o1530(k111, o => objects = [...objects, o]);          for (const k111 of objects)             d2753.appendChild(k111);     }       return d2753; }    function q2741(d2753, s2752, addProps, transform) {     h2775(d2753, s2752, addProps, transform);      w2716(         d2753,          s2752[FO_FRAME_CHILDREN],          s2752[FO_FRAME_CHILDREN].length); }    function h2775(d2753, s2752, addProps, transform) {     d2753.cornerRadius = s2752[FO_FRAME_ROUND];      if (transform)         g1591(d2753, s2752);          j2686(d2753, s2752, addProps && s2752[FO_FRAME_CHILDREN].length == 0); }


function g2763(y2754) {     return true; }    async function b2734(y2754) {     let objects = [];      for (const k111 of y2754[FO_GROUP_CHILDREN])         await o1530(k111, o => objects = [...objects, o]);       await figma.currentPage.loadAsync();          const p2755 =          !isEmpty(objects)         ? figma.group(objects, figma.currentPage)         : null;       if (p2755)     {         p2755.expanded = false;         m2740(p2755, y2754);     }       return p2755; }    function m2740(p2755, y2754) {     if (y2754[FO_GROUP_CHILDREN].length == 0)     {         p2755.remove();         return;     }       w2716(         p2755,          y2754[FO_GROUP_CHILDREN],         y2754[FO_GROUP_CHILDREN].length);               k1541(p2755, y2754); } 


function n2758(l2756) {     return l2756[FO_X    ] != null && !isNaN(l2756[FO_X    ])         && l2756[FO_Y    ] != null && !isNaN(l2756[FO_Y    ])         && l2756[FO_WIDTH] != null && !isNaN(l2756[FO_WIDTH]); }    function j2776(l2756, addProps, transform) {     if (!n2758(l2756))         return null;           const i2757 = figma.createLine();      r2777(i2757, l2756, addProps, transform, true);          return i2757; }    function r2777(i2757, l2756, addProps, transform, isValid = false) {     if (   !isValid         && !n2758(l2756))         return;      if (transform)         g1591(i2757, l2756, true, 0);          j2686(i2757, l2756, addProps); } 


var o2749 = [];    function i4008(y2685) {     return y2685[FO_X] != null && !isNaN(y2685[FO_X])         && y2685[FO_Y] != null && !isNaN(y2685[FO_Y]); }    function m2679(y2685) {         const d2684 =          y2685[FO_IS_CENTER]         ? figma.createRectangle()         : figma.createEllipse();              if (!i4008(y2685))         return d2684;                  if (o2749.includes(d2684))         v2683(d2684, y2685);     else         y2736(d2684, y2685);           return d2684; }    function y2736(d2684, y2685) {     h1592(d2684, y2685);     t2682(d2684); }    function t2680() {     l1528(     {         cmd: 'uiUpdateZoom',          zoom: figma.viewport.zoom      });          for (const point of o2749)         w2681(point); }    function w2681(d2684) {     k1593(d2684);     t2682(d2684); }    function v2683(d2684, y2685) {     h1592(d2684, y2685);     t2682(d2684); }    function t2682(d2684) {     if (d2684.removed)          return;      figma.currentPage.loadAsync().then(() =>     {         const isCenter   = t926(d2684.getPluginData('isCenter'));         const u2691 = figma.currentPage.selection.includes(d2684);          const color =             isCenter             ? [0xf2, 0x48, 0x22]             : u2691             ? [ 12, 140, 233]             : [255, 255, 255];          const border =             isCenter             ? [255, 255, 255]             : u2691             ? [255, 255, 255]             : [ 12, 140, 233];           d2684.fills = g959([['SOLID', color[0], color[1], color[2], 100]]);           const effects = [];                  effects.push(...e1536([['DROP_SHADOW', border[0]/255, border[1]/255, border[2]/255,  1, 0, 0, 0, (isCenter ? 3 : u2691 ? 5 : 3.6)/h2692, 'NORMAL', true, true]], true));         effects.push(...e1536([['DROP_SHADOW', color[0]/255, color[1]/255, color[2]/255, 1, 0, 0, 0, (u2691 ? 4 : 2.4)/h2692, 'NORMAL', true, true]], true));           d2684.effects = effects;     }); } 


function m4009(genPoly) {     return genPoly[FO_X           ] != null && !isNaN(genPoly[FO_X           ])         && genPoly[FO_Y           ] != null && !isNaN(genPoly[FO_Y           ])         && genPoly[FO_WIDTH       ] != null && !isNaN(genPoly[FO_WIDTH       ])         && genPoly[FO_HEIGHT      ] != null && !isNaN(genPoly[FO_HEIGHT      ])         && genPoly[FO_POLY_ROUND  ] != null && !isNaN(genPoly[FO_POLY_ROUND  ])         && genPoly[FO_POLY_CORNERS] != null && !isNaN(genPoly[FO_POLY_CORNERS]); }    function c2693(genPoly, addProps, transform) {     if (!m4009(genPoly))         return null;               const figPoly = figma.createPolygon();      t2694(figPoly, genPoly, addProps, transform, true);      return figPoly; }    function t2694(figPoly, genPoly, addProps, transform, isValid = false) {     if (   !isValid         && !m4009(genPoly))         return;               figPoly.cornerRadius = genPoly[FO_POLY_ROUND];     figPoly.pointCount   = Math.max(3, genPoly[FO_POLY_CORNERS]);       if (transform)         g1591(figPoly, genPoly);          j2686(figPoly, genPoly, addProps); } 


function s2696(c2695) {     return c2695[FO_X         ] != null && !isNaN(c2695[FO_X         ])         && c2695[FO_Y         ] != null && !isNaN(c2695[FO_Y         ])         && c2695[FO_WIDTH     ] != null && !isNaN(c2695[FO_WIDTH     ])         && c2695[FO_HEIGHT    ] != null && !isNaN(c2695[FO_HEIGHT    ])         && c2695[FO_RECT_ROUND] != null && !isNaN(c2695[FO_RECT_ROUND]); }    function q2697(c2695, addProps, transform) {     if (!s2696(c2695))         return null;       const figRect = figma.createRectangle();      n2698(figRect, c2695, addProps, transform, true);      return figRect; }    function n2698(figRect, c2695, addProps, transform, isValid = false) {     if (   !isValid         && !s2696(c2695))         return;       const found = c2695[FO_EFFECTS].findIndex(e => e[0] == 'ROUND_CORNERS');      if (found > -1)     {         const corners = c2695[FO_EFFECTS][found];          figRect.topLeftRadius     = corners[1];         figRect.topRightRadius    = corners[2];         figRect.bottomLeftRadius  = corners[3];         figRect.bottomRightRadius = corners[4];     }     else         figRect.cornerRadius = c2695[FO_RECT_ROUND];       if (transform)         g1591(figRect, c2695);          j2686(figRect, c2695, addProps); } 


function w2699(y2709) {     return y2709[FO_X          ] != null && !isNaN(y2709[FO_X          ])         && y2709[FO_Y          ] != null && !isNaN(y2709[FO_Y          ])         && y2709[FO_WIDTH      ] != null && !isNaN(y2709[FO_WIDTH      ])         && y2709[FO_HEIGHT     ] != null && !isNaN(y2709[FO_HEIGHT     ])         && y2709[FO_STAR_ROUND ] != null && !isNaN(y2709[FO_STAR_ROUND ])         && y2709[FO_STAR_POINTS] != null && !isNaN(y2709[FO_STAR_POINTS])         && y2709[FO_STAR_CONVEX] != null && !isNaN(y2709[FO_STAR_CONVEX]); }    function k2700(y2709, addProps, transform) {     if (!w2699(y2709))         return null;               const g2710 = figma.createStar();      a2701(g2710, y2709, addProps, transform, true);      return g2710; }    function a2701(g2710, y2709, addProps, transform, isValid = false) {     if (   !isValid         && !w2699(y2709))         return;       g2710.cornerRadius = y2709[FO_STAR_ROUND ];     g2710.pointCount   = y2709[FO_STAR_POINTS];     g2710.innerRadius  = Math.min(Math.max(0, y2709[FO_STAR_CONVEX] / 100), 1);       if (transform)         g1591(g2710, y2709);          j2686(g2710, y2709, addProps); } 


const y4252 = [];    function y2702(l2706) {     return l2706[FO_TEXT     ] != null         && l2706[FO_X        ] != null && !isNaN(l2706[FO_X     ])         && l2706[FO_Y        ] != null && !isNaN(l2706[FO_Y     ])         && l2706[FO_WIDTH    ] != null && !isNaN(l2706[FO_WIDTH ])         && l2706[FO_HEIGHT   ] != null && !isNaN(l2706[FO_HEIGHT])         && l2706[FO_FONT     ] != null && l2706[FO_FONT] != NULL         && l2706[FO_FONT_SIZE] != null && !isNaN(l2706[FO_FONT_SIZE]); }    function e2703(l2706, addProps, transform) {     if (!y2702(l2706))         return null;           const o2778 = figma.createText();      v2704(o2778, l2706, addProps, transform, true);           return o2778; }    function v2704(o2778, l2706, addProps, transform, isValid = false) {     if (   !isValid         && !y2702(l2706))         return null;       const fontName =      {          family: l2706[FO_FONT      ],          style:  l2706[FO_FONT_STYLE]     };      try     {         if (!y4252.includes(fontName))         {             figma.loadFontAsync(fontName).then(() =>             {                 y4252.push(fontName);                 p2705(o2778, l2706, fontName, addProps, transform);             });         }         else         {             p2705(o2778, l2706, fontName, addProps, transform);         }     }     catch (e)      {         z956(e);     } }    function p2705(o2778, l2706, fontName, addProps, transform) {     o2778.fontName      = fontName;      o2778.fontSize      = Math.max(1, l2706[FO_FONT_SIZE]);      o2778.characters    = l2706[FO_TEXT];      o2778.lineHeight    = {unit: 'PERCENT', value: l2706[FO_LINE_HEIGHT   ]};     o2778.letterSpacing = {unit: 'PERCENT', value: l2706[FO_LETTER_SPACING]};            if (l2706[FO_ALIGN_H] == 0) o2778.textAlignHorizontal = 'LEFT';     else if (l2706[FO_ALIGN_H] == 1) o2778.textAlignHorizontal = 'CENTER';     else if (l2706[FO_ALIGN_H] == 2) o2778.textAlignHorizontal = 'RIGHT';     else if (l2706[FO_ALIGN_H] == 3) o2778.textAlignHorizontal = 'JUSTIFIED';           if (l2706[FO_ALIGN_V] == 0) o2778.textAlignVertical   = 'TOP';     else if (l2706[FO_ALIGN_V] == 1) o2778.textAlignVertical   = 'CENTER';     else if (l2706[FO_ALIGN_V] == 2) o2778.textAlignVertical   = 'BOTTOM';       if (transform)         g1591(o2778, l2706);          j2686(o2778, l2706, addProps);                                                       if (     l2706[FO_FIG_WIDTH ] == 0           && l2706[FO_FIG_HEIGHT] == 0) o2778.textAutoResize = 'WIDTH_AND_HEIGHT';     else if (l2706[FO_FIG_WIDTH ] == 0) o2778.textAutoResize = 'HEIGHT';     else                                  o2778.textAutoResize = 'NONE'; }


 function c2761(f2711) {     return true; }    function s2732(f2711, addProps, transform) {     if (!c2761(f2711))         return null;               const t2712 = figma.createVector();      a2738(t2712, f2711, addProps, transform, true);           return t2712; }    function a2738(t2712, f2711, addProps, transform, isValid = false) {     if (   !isValid         && !c2761(f2711))         return;       t2712.setVectorNetworkAsync(f2711[FO_VECTOR_NETWORK_DATA]);           if (transform)         g1591(t2712, f2711, false);          j2686(t2712, f2711, addProps); }


 function i2760(t2707) {     return t2707[FO_VECTOR_PATH_WINDING] != null && !isNaN(t2707[FO_VECTOR_PATH_WINDING])         && t2707[FO_VECTOR_PATH_ROUND  ] != null && !isNaN(t2707[FO_VECTOR_PATH_ROUND  ]); }    function c2731(t2707, addProps, transform) {     const j2708 = figma.createVector();      p2737(j2708, t2707, addProps, transform, true);      return j2708; }    function p2737(j2708, t2707, addProps, transform, isValid = false) {     if (   !isValid         && !i2760(t2707))         return;       j2708.vectorPaths = [{         windingRule: t2707[FO_VECTOR_PATH_WINDING] == 1 ? 'NONZERO' : 'EVENODD',         data:        t2707[FO_VECTOR_PATH_DATA   ]     }];       j2708.cornerRadius = t2707[FO_VECTOR_PATH_ROUND];           if (transform)         g1591(j2708, t2707, false);          j2686(j2708, t2707, addProps); }