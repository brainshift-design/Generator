const figEmptyObjects = [];
const figDecoObjects  = [];



function getObjectEffects(genObjEffects, canSpread)
{
    const effects = [];


    for (const effect of genObjEffects)
    {
        const type = effect[0];

        switch (type)
        {
            case 'DROP_SHADOW':
            {
                const color = {
                    r: Math.min(Math.max(0, effect[1]), 1), 
                    g: Math.min(Math.max(0, effect[2]), 1), 
                    b: Math.min(Math.max(0, effect[3]), 1),
                    a: Math.min(Math.max(0, effect[4]), 1) };

                const offset = {
                    x: effect[5],
                    y: effect[6] };

                const radius  = effect[ 7];
                const spread  = effect[ 8];
                const blend   = effect[ 9];
                const behind  = effect[10];
                const visible = effect[11];
  

                if (   !isNaN(color.r)
                    && !isNaN(color.g)
                    && !isNaN(color.b)
                    && !isNaN(color.a)
                    && !isNaN(offset.x)
                    && !isNaN(offset.y)
                    && !isNaN(radius))
                {
                    effects.push(
                    {
                        type:                 type, 
                        color:                color,
                        offset:               offset,
                        radius:               radius,
                        visible:              visible,
                        blendMode:            blend,
                        showShadowBehindNode: behind,
                        boundVariables:       {}
                    });

                    if (    canSpread
                        && !isNaN(spread))
                        effects[effects.length-1]['spread'] = spread;
                }

                break;
            }

            case 'INNER_SHADOW':
            {
                const color = {
                    r: Math.min(Math.max(0, effect[1]), 1), 
                    g: Math.min(Math.max(0, effect[2]), 1), 
                    b: Math.min(Math.max(0, effect[3]), 1),
                    a: Math.min(Math.max(0, effect[4]), 1) };

                const offset = {
                    x: effect[5],
                    y: effect[6] };

                const radius  = effect[ 7];
                const spread  = effect[ 8];
                const blend   = effect[ 9];
                const visible = effect[10];
  

                if (   !isNaN(color.r)
                    && !isNaN(color.g)
                    && !isNaN(color.b)
                    && !isNaN(color.a)
                    && !isNaN(offset.x)
                    && !isNaN(offset.y)
                    && !isNaN(radius)
                    && !isNaN(spread))
                {
                    effects.push(
                    {
                        type:           type, 
                        color:          color,
                        offset:         offset,
                        radius:         radius,
                        spread:         spread,
                        visible:        visible,
                        blendMode:      blend,
                        boundVariables: {}
                    });
                }

                break;
            }

            case 'LAYER_BLUR':
            {
                const radius  = effect[1];
                const visible = effect[2];

                if (!isNaN(radius))
                {
                    effects.push(
                    {
                        type:           type, 
                        visible:        visible,
                        radius:         Math.max(0, radius),
                        boundVariables: {}
                    });
                }

                break;
            }

            case 'BACKGROUND_BLUR':
            {
                const radius  = effect[1];
                const visible = effect[2];

                if (!isNaN(radius))
                {
                    effects.push(
                    {
                        type:           type, 
                        visible:        visible,
                        radius:         Math.max(0, radius),
                        boundVariables: {}
                    });
                }

                break;
            }
        }
    }


    return effects;
}



function setObjectProps(figObj, genObj, phantom = true)
{
    // if (genObj.badTransform)
    //     return;
        
    setObjectEffects(figObj, genObj);
    setObjectStrokes(figObj, genObj, phantom);
    setObjectFills  (figObj, genObj);

    
    figObj.opacity   = genObj[FO_OPACITY];
    figObj.blendMode = genObj[FO_BLEND  ];


    const maskType = genObj[FO_MASK];

    figObj.isMask = maskType > 0;

    if (figObj.isMask)
    {
        switch (maskType)
        {
            case 1: figObj.maskType = 'ALPHA';     break;
            case 2: figObj.maskType = 'VECTOR';    break;
            case 3: figObj.maskType = 'LUMINANCE'; break;
        }
    }


    if (   figObj.isMask
        && figObj.fills  .length == 0
        && figObj.strokes.length == 0)
        figObj.fills = 
            [{
                type:      'SOLID', 
                color:     {r:0, g:0, b:0},
                opacity:   1, 
                blendMode: 'NORMAL'
            }];
}



function setObjectFills(figObj, genObj)
{
    if (   !!genObj[FO_FILLS]
        &&  !isEmpty(genObj[FO_FILLS]))
    {
        figObj.fills = getObjectFills(genObj[FO_FILLS]);

        if (figEmptyObjects.includes(figObj))
            removeFromArray(figEmptyObjects, figObj);
    }
    else
        figObj.fills = [];
}



function setObjectStrokes(figObj, genObj, phantom = true)
{
    if (    genObj[FO_STROKES] != null
        && !isEmpty(genObj[FO_STROKES]))
    {
        setObjectStroke_(
            figObj,
            getObjectFills(genObj[FO_STROKES]),
            genObj[FO_STROKE_WEIGHT],
            genObj[FO_STROKE_ALIGN ],
            genObj[FO_STROKE_JOIN  ],
            genObj[FO_STROKE_MITER ],
            genObj[FO_STROKE_CAP   ],
            parseStrokeDashes(genObj[FO_STROKE_DASHES]));

        if (genObj[FO_DECO])
            figObj.setPluginData('dashes', genObj[FO_STROKE_DASHES]); // for updating deco polys

        if (figEmptyObjects.includes(figObj))
            removeFromArray(figEmptyObjects, figObj);

        if (genObj[FO_DECO])
            pushUnique(figDecoObjects, figObj);
    }

    else if ( isEmpty(genObj[FO_FILLS  ])
          &&  isEmpty(genObj[FO_STROKES])
          && !genObj[FO_MASK]
          &&  phantom)
    {
        setEmptyObjectStroke(figObj);
        pushUnique(figEmptyObjects, figObj);
    }
    
    else
        figObj.strokes = [];
}



function parseStrokeDashes(_dashes)
{
    _dashes = <string><unknown>_dashes;
    
    _dashes = trimCharFromStart(_dashes, ',');
    _dashes = trimCharFromEnd  (_dashes, ',');
    _dashes = _dashes.trim();

    return _dashes == '' 
         ? [] 
         : _dashes.split(',').map(s => Math.max(0, parseFloat(s)));
}



function parseDecoStrokeDashes(_dashes)
{
    _dashes = <string><unknown>_dashes;
    
    _dashes = trimCharFromStart(_dashes, ',');
    _dashes = trimCharFromEnd  (_dashes, ',');
    _dashes = _dashes.trim();

    return _dashes == '' 
         ? [] 
         : _dashes.split(',').map(s => Math.max(0, parseFloat(s) / curZoom));
}



function setObjectStroke_(figObj, fills, weight, align, join, miterLimit, cap, dashes = [])
{
    figObj.strokes          = fills;
    
    figObj.strokeWeight     = Math.max(0, weight);
    figObj.strokeAlign      = align;
    figObj.strokeJoin       = join;
    

    const  miterAngle       = miterLimit/360*Tau;
    const _miterLimit       = 1 / Math.sin(miterAngle/2);
    
    figObj.strokeMiterLimit = Math.min(Math.max(0, _miterLimit), 16);

    figObj.strokeCap        = cap;

    figObj.dashPattern      = dashes;
}



function setObjectEffects(figObj, genObj)
{
    if (  !!genObj[FO_EFFECTS]
        && !isEmpty(genObj[FO_EFFECTS]))
    {
        const canSpread =
               genObj[FO_TYPE] == RECTANGLE
            || genObj[FO_TYPE] == ELLIPSE
            || genObj[FO_TYPE] == FRAME;

        figObj.effects = getObjectEffects(genObj[FO_EFFECTS], canSpread);
    }
    else
        figObj.effects = [];
}



function updateEmptyObjects()
{
    for (const obj of figEmptyObjects)
    {
        if (obj.removed)
            removeFromArray(figEmptyObjects, obj);
        else
            setEmptyObjectStroke(obj);
    }
}



function setEmptyObjectStroke(obj)
{
    figCurrentPage.loadAsync().then(() =>
    {
        const back = figCurrentPage.backgrounds.find(b => b.type == 'SOLID') as SolidPaint;
        

        let phantomColor;

        if (back)
        {
            const l =
                  back.color.r * 0.2126
                + back.color.g * 0.7152 
                + back.color.b * 0.0722; 
                
            phantomColor =
                l > 0.5
                ? {r: 0, g: 0, b: 0}
                : {r: 1, g: 1, b: 1};
        }
        else
            phantomColor = {r: 1, g: 0, b: 1};


        setObjectStroke_(
            obj,
            [{ type:  'SOLID', 
              color:   phantomColor,
              opacity: 0.5 }],
            1 / curZoom,
            'CENTER',
            'MITER',
            1,
            'NONE',
            [ 1 / curZoom, 
              2 / curZoom ]);
    });
}



function updateDecoObjects()
{
    for (const figObj of figDecoObjects)
    {
        if (figObj.removed)
            removeFromArray(figDecoObjects, figObj);
        else
            updateDecoObject(figObj);
    }
}



function updateDecoObject(figObj)
{
    figObj.strokeWeight = Math.max(0, 1.5 / curZoom);


    if (parseBool(figObj.getPluginData('isCenter')))
    {
        const path  = figObj.vectorPaths[0];
        const parts = path.data.split(' ');
        
        let t = { x: parseFloat(parts[1]), y: parseFloat(parts[2]) };
        let c = { x: parseFloat(parts[4]), y: parseFloat(parts[5]) };
        let r = { x: parseFloat(parts[7]), y: parseFloat(parts[8]) };

        const a = 2;
        const b = 0.05;
        const f = 1 - Math.pow(1 - Math.min(curZoom, 1), a) / Math.pow(a, b);
    
        t = addv(c, mulvs(unitv(subv(t, c)), objectCenterSize/f));
        r = addv(c, mulvs(unitv(subv(r, c)), objectCenterSize/f));
 
        parts[1] = t.x; parts[2] = t.y;
        parts[4] = c.x; parts[5] = c.y;
        parts[7] = r.x; parts[8] = r.y;

        const newPath = 
        {
            windingRule: path.windingRule,
            data:        parts.join(' ')
        };

        figObj.vectorPaths = [newPath];
    }


    const dashes = figObj.getPluginData('dashes');

    if (dashes != '')
        figObj.dashPattern = parseDecoStrokeDashes(dashes);        
}