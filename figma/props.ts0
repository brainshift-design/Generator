const figEmptyObjects = [];



function getObjectFills(genObjFills)
{
    const fills = [];


    for (const fill of genObjFills)
    {
        switch (fill[0])
        {
            case 'SOLID':
            {
                const color = {
                    r: Math.min(Math.max(0, fill[1] / 0xff), 1), 
                    g: Math.min(Math.max(0, fill[2] / 0xff), 1), 
                    b: Math.min(Math.max(0, fill[3] / 0xff), 1) };

                const opacity = Math.min(Math.max(0, fill[4] / 100), 1);


                if (   !isNaN(color.r)
                    && !isNaN(color.g)
                    && !isNaN(color.b)
                    && !isNaN(opacity))
                    fills.push(
                    {
                        type:      fill[0], 
                        color:     color,
                        opacity:   opacity,
                        blendMode: fill[5]
                    });


                break;
            }

            case 'GRADIENT_LINEAR':
            case 'GRADIENT_RADIAL':
            case 'GRADIENT_ANGULAR':
            case 'GRADIENT_DIAMOND':
            {
                const xform = fill[1];


                const stops = [];

                for (const stop of fill[2])
                {
                    stops.push({
                        color: 
                        {
                            r: Math.min(Math.max(0, stop[0]), 1),
                            g: Math.min(Math.max(0, stop[1]), 1),
                            b: Math.min(Math.max(0, stop[2]), 1),
                            a: Math.min(Math.max(0, stop[3]), 1)
                        },
                        position: stop[4]
                    })    
                }


                fills.push(
                {
                    type:              fill[0],
                    gradientTransform: xform,
                    gradientStops:     stops,
                    blendMode:         fill[3]
                });


                break;
            }
        }
    }


    return fills;
}



function getObjectEffects(genObjEffects)
{
    const effects = [];


    for (const effect of genObjEffects)
    {
        const type = effect[0];

        switch (type)
        {
            case 'DROP_SHADOW':
            {
                const color = {
                    r: Math.min(Math.max(0, effect[1]), 1), 
                    g: Math.min(Math.max(0, effect[2]), 1), 
                    b: Math.min(Math.max(0, effect[3]), 1),
                    a: Math.min(Math.max(0, effect[4]), 1) };

                const offset = {
                    x: effect[5],
                    y: effect[6] };

                const radius  = effect[ 7];
                const spread  = effect[ 8];
                const blend   = effect[ 9];
                const behind  = effect[10];
                const visible = effect[11];
  

                if (   !isNaN(color.r)
                    && !isNaN(color.g)
                    && !isNaN(color.b)
                    && !isNaN(color.a)
                    && !isNaN(offset.x)
                    && !isNaN(offset.y)
                    && !isNaN(radius)
                    && !isNaN(spread))
                    effects.push(
                    {
                        type:                 type, 
                        color:                color,
                        offset:               offset,
                        radius:               radius,
                        spread:               spread,
                        visible:              visible,
                        blendMode:            blend,
                        showShadowBehindNode: behind
                    });

                break;
            }

            case 'INNER_SHADOW':
            {
                const color = {
                    r: Math.min(Math.max(0, effect[1]), 1), 
                    g: Math.min(Math.max(0, effect[2]), 1), 
                    b: Math.min(Math.max(0, effect[3]), 1),
                    a: Math.min(Math.max(0, effect[4]), 1) };

                const offset = {
                    x: effect[5],
                    y: effect[6] };

                const radius  = effect[ 7];
                const spread  = effect[ 8];
                const blend   = effect[ 9];
                const visible = effect[10];
  

                if (   !isNaN(color.r)
                    && !isNaN(color.g)
                    && !isNaN(color.b)
                    && !isNaN(color.a)
                    && !isNaN(offset.x)
                    && !isNaN(offset.y)
                    && !isNaN(radius)
                    && !isNaN(spread))
                    effects.push(
                    {
                        type:       type, 
                        color:      color,
                        offset:     offset,
                        radius:     radius,
                        spread:     spread,
                        visible:    visible,
                        blendMode:  blend
                    });

                break;
            }

            case 'LAYER_BLUR':
            {
                const radius  = effect[1];
                const visible = effect[2];

                if (!isNaN(radius))
                    effects.push(
                    {
                        type:    type, 
                        visible: visible,
                        radius:  radius
                    });

                break;
            }

            case 'BACKGROUND_BLUR':
            {
                const radius  = effect[1];
                const visible = effect[2];

                if (!isNaN(radius))
                    effects.push(
                    {
                        type:    type, 
                        visible: visible,
                        radius:  radius
                    });

                break;
            }
        }
    }


    return effects;
}



function setObjectProps(figObj, genObj, phantom = true)
{
    setObjectFills  (figObj, genObj);
    setObjectStrokes(figObj, genObj, phantom);
    setObjectEffects(figObj, genObj);

    figObj.isMask = genObj[FO_MASK];
}



function setObjectFills(figObj, genObj)
{
    if (   !!genObj[FO_FILLS]
        &&  !isEmpty(genObj[FO_FILLS]))
    {
        figObj.fills = getObjectFills(genObj[FO_FILLS]);

        if (figEmptyObjects.includes(figObj))
            removeFromArray(figEmptyObjects, figObj);
    }
    else
        figObj.fills = [];
}



function setObjectStrokes(figObj, genObj, phantom = true)
{
    if (    genObj[FO_STROKES] != null
        && !isEmpty(genObj[FO_STROKES]))
    {
        setObjectStroke_(
            figObj,
            getObjectFills(genObj[FO_STROKES]),
            genObj[FO_STROKE_WEIGHT],
            genObj[FO_STROKE_ALIGN ],
            genObj[FO_STROKE_JOIN  ],
            genObj[FO_STROKE_MITER ]);

        if (figEmptyObjects.includes(figObj))
            removeFromArray(figEmptyObjects, figObj);
    }
    else if (isEmpty(genObj[FO_FILLS  ])
          && isEmpty(genObj[FO_STROKES])
          && phantom)
    {
        setEmptyObjectStroke(figObj);
        pushUnique(figEmptyObjects, figObj);
    }
    else
        figObj.strokes = [];
}



function setObjectStroke_(figObj, fills, weight, align, join, miterLimit, dashes = [])
{
    figObj.strokes          = fills
    
    figObj.strokeWeight     = Math.max(0, weight);
    figObj.strokeAlign      = align;
    figObj.strokeJoin       = join;
    

    const  miterAngle       = miterLimit/360*Tau;
    const _miterLimit       = 1 / Math.sin(miterAngle/2);
    
    figObj.strokeMiterLimit = Math.min(Math.max(0, _miterLimit), 16);

    figObj.dashPattern      = dashes;
}



function setObjectEffects(figObj, genObj)
{
    if (  !!genObj[FO_EFFECTS]
        && !isEmpty(genObj[FO_EFFECTS]))
        figObj.effects = getObjectEffects(genObj[FO_EFFECTS]);
    else
        figObj.effects = [];
}



function updateEmptyObjects()
{
    for (const obj of figEmptyObjects)
    {
        if (obj.removed)
            removeFromArray(figEmptyObjects, obj);
        else
            setEmptyObjectStroke(obj);
    }
}



function setEmptyObjectStroke(obj)
{
    const back = figma.currentPage.backgrounds.find(b => b.type == 'SOLID') as SolidPaint;
    

    let phantomColor;

    if (back)
    {
        const l =
              back.color.r * 0.2126
            + back.color.g * 0.7152 
            + back.color.b * 0.0722; 
            
        phantomColor =
            l > 0.5
            ? {r: 0, g: 0, b: 0}
            : {r: 1, g: 1, b: 1};
    }
    else
        phantomColor = {r: 1, g: 0, b: 1};



    setObjectStroke_(
        obj,
        [{ type:   'SOLID', 
           color:   phantomColor,
           opacity: 0.5 }],
        1 / curZoom,
        'CENTER',
        'MITER',
        1,
        [ 1 / curZoom, 
          2 / curZoom]);
}