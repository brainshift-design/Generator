const figEmptyObjects = [];
const figDecoObjects  = [];



function getObjectEffects(genObjEffects)
{
    const effects = [];


    for (const effect of genObjEffects)
    {
        const type = effect[0];

        switch (type)
        {
            case 'DROP_SHADOW':
            {
                const color = {
                    r: Math.min(Math.max(0, effect[1]), 1), 
                    g: Math.min(Math.max(0, effect[2]), 1), 
                    b: Math.min(Math.max(0, effect[3]), 1),
                    a: Math.min(Math.max(0, effect[4]), 1) };

                const offset = {
                    x: effect[5],
                    y: effect[6] };

                const radius  = effect[ 7];
                const spread  = effect[ 8];
                const blend   = effect[ 9];
                const behind  = effect[10];
                const visible = effect[11];
  

                if (   !isNaN(color.r)
                    && !isNaN(color.g)
                    && !isNaN(color.b)
                    && !isNaN(color.a)
                    && !isNaN(offset.x)
                    && !isNaN(offset.y)
                    && !isNaN(radius)
                    && !isNaN(spread))
                    effects.push(
                    {
                        type:                 type, 
                        color:                color,
                        offset:               offset,
                        radius:               radius,
                        spread:               spread,
                        visible:              visible,
                        blendMode:            blend,
                        showShadowBehindNode: behind
                    });

                break;
            }

            case 'INNER_SHADOW':
            {
                const color = {
                    r: Math.min(Math.max(0, effect[1]), 1), 
                    g: Math.min(Math.max(0, effect[2]), 1), 
                    b: Math.min(Math.max(0, effect[3]), 1),
                    a: Math.min(Math.max(0, effect[4]), 1) };

                const offset = {
                    x: effect[5],
                    y: effect[6] };

                const radius  = effect[ 7];
                const spread  = effect[ 8];
                const blend   = effect[ 9];
                const visible = effect[10];
  

                if (   !isNaN(color.r)
                    && !isNaN(color.g)
                    && !isNaN(color.b)
                    && !isNaN(color.a)
                    && !isNaN(offset.x)
                    && !isNaN(offset.y)
                    && !isNaN(radius)
                    && !isNaN(spread))
                    effects.push(
                    {
                        type:       type, 
                        color:      color,
                        offset:     offset,
                        radius:     radius,
                        spread:     spread,
                        visible:    visible,
                        blendMode:  blend
                    });

                break;
            }

            case 'LAYER_BLUR':
            {
                const radius  = effect[1];
                const visible = effect[2];

                if (!isNaN(radius))
                    effects.push(
                    {
                        type:    type, 
                        visible: visible,
                        radius:  radius
                    });

                break;
            }

            case 'BACKGROUND_BLUR':
            {
                const radius  = effect[1];
                const visible = effect[2];

                if (!isNaN(radius))
                    effects.push(
                    {
                        type:    type, 
                        visible: visible,
                        radius:  radius
                    });

                break;
            }
        }
    }


    return effects;
}



function setObjectProps(figObj, genObj, phantom = true)
{
    setObjectFills  (figObj, genObj);
    setObjectStrokes(figObj, genObj, phantom);
    setObjectEffects(figObj, genObj);

    figObj.isMask = genObj[FO_MASK];
}



function setObjectFills(figObj, genObj)
{
    if (   !!genObj[FO_FILLS]
        &&  !isEmpty(genObj[FO_FILLS]))
    {
        figObj.fills = getObjectFills(genObj[FO_FILLS]);

        if (figEmptyObjects.includes(figObj))
            removeFromArray(figEmptyObjects, figObj);
    }
    else
        figObj.fills = [];
}



function setObjectStrokes(figObj, genObj, phantom = true)
{
    if (    genObj[FO_STROKES] != null
        && !isEmpty(genObj[FO_STROKES]))
    {
        setObjectStroke_(
            figObj,
            getObjectFills(genObj[FO_STROKES]),
            genObj[FO_STROKE_WEIGHT],
            genObj[FO_STROKE_ALIGN ],
            genObj[FO_STROKE_JOIN  ],
            genObj[FO_STROKE_MITER ],
            genObj[FO_STROKE_CAP   ],
            parseStrokeDashes(genObj[FO_STROKE_DASHES]));

        if (figEmptyObjects.includes(figObj))
            removeFromArray(figEmptyObjects, figObj);

        if (genObj[FO_DECO])
            pushUnique(figDecoObjects, figObj);
    }
    else if (isEmpty(genObj[FO_FILLS  ])
          && isEmpty(genObj[FO_STROKES])
          && phantom)
    {
        setEmptyObjectStroke(figObj);
        pushUnique(figEmptyObjects, figObj);
    }
    else
        figObj.strokes = [];
}



function parseStrokeDashes(_dashes)
{
    _dashes = <string><unknown>_dashes;
    
    _dashes = trimCharFromStart(_dashes, ',');
    _dashes = trimCharFromEnd  (_dashes, ',');
    _dashes = _dashes.trim();

    return _dashes == '' 
         ? [] 
         : _dashes.split(',').map(s => Math.max(0, parseInt(s)));
}



function setObjectStroke_(figObj, fills, weight, align, join, miterLimit, cap, dashes = [])
{
    figObj.strokes          = fills
    
    figObj.strokeWeight     = Math.max(0, weight);
    figObj.strokeAlign      = align;
    figObj.strokeJoin       = join;
    

    const  miterAngle       = miterLimit/360*Tau;
    const _miterLimit       = 1 / Math.sin(miterAngle/2);
    
    figObj.strokeMiterLimit = Math.min(Math.max(0, _miterLimit), 16);

    figObj.strokeCap        = cap;

    figObj.dashPattern      = dashes;
}



function setObjectEffects(figObj, genObj)
{
    if (  !!genObj[FO_EFFECTS]
        && !isEmpty(genObj[FO_EFFECTS]))
        figObj.effects = getObjectEffects(genObj[FO_EFFECTS]);
    else
        figObj.effects = [];
}



function updateEmptyObjects()
{
    for (const obj of figEmptyObjects)
    {
        if (obj.removed)
            removeFromArray(figEmptyObjects, obj);
        else
            setEmptyObjectStroke(obj);
    }
}



function setEmptyObjectStroke(obj)
{
    const back = figma.currentPage.backgrounds.find(b => b.type == 'SOLID') as SolidPaint;
    

    let phantomColor;

    if (back)
    {
        const l =
              back.color.r * 0.2126
            + back.color.g * 0.7152 
            + back.color.b * 0.0722; 
            
        phantomColor =
            l > 0.5
            ? {r: 0, g: 0, b: 0}
            : {r: 1, g: 1, b: 1};
    }
    else
        phantomColor = {r: 1, g: 0, b: 1};



    setObjectStroke_(
        obj,
        [{ type:   'SOLID', 
           color:   phantomColor,
           opacity: 0.5 }],
        1 / curZoom,
        'CENTER',
        'MITER',
        1,
        'NONE',
        [ 1 / curZoom, 
          2 / curZoom ]);
}



function updateDecoObjects()
{
    for (const obj of figDecoObjects)
    {
        if (obj.removed)
            removeFromArray(figDecoObjects, obj);
        else
            updateDecoObject(obj);
    }
}



function updateDecoObject(obj)
{
    obj.strokeWeight = Math.max(0, 1 / curZoom);
}