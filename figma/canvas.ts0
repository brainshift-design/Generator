const MAX_OBJECTS = 0x10000;
const genObjects  = new Array(MAX_OBJECTS);


const OBJ_RECT = 1;



function figUpdateObjects(objects)
{
    // // prepare the buffers

    // let nodeId = -1;
    // let prevId = -1;
    // let count  =  0;


    // here the ID acts as the index into the object table

    for (const obj of objects)
    {
        const genObj = genObjects[obj.id];

        if (  !genObj 
            || genObj.removed) // no existing object, create new object
        {
            figCreateObject(obj);
        }
        else if (genObj.getPluginData('type') == obj.type.toString()) // update existing object
        {
            figUpdateObject(obj);
        }
        else // delete existing object, create new object
        {
            genObj.remove();
            figCreateObject(obj);
        }

    //     count++;

    //     if (obj.nodeId != nodeId)
    //     {
    //         nodeId = obj.nodeId;

    //         if (prevId > -1)
    //         {
    //             if (  !objNodes[prevId]
    //                 || objNodes[prevId].length != count)
    //             {
    //                 figDeleteNodeObjects([prevId]);
    //                 objNodes[prevId] = new Array(count).fill(null);
    //             }

    //             count = 0;
    //         }

    //         prevId = nodeId;
    //     }
    // }


    // if (   count > 0
    //     && (  !objNodes[nodeId]
    //         || objNodes[nodeId].length != count))
    // {
    //     figDeleteNodeObjects([nodeId]);
    //     objNodes[nodeId] = new Array(count).fill(null);
    }


    // // fill the buffers

    // for (const obj of objects)
    // {
    //     switch (obj.type)
    //     {
    //         case OBJ_RECT:
    //         {
    //             if (!objNodes[obj.nodeId][obj.id])
    //             {
    //                 figCreateRect(obj);
    //             }
    //             else 
    //             {
    //                 const cur = objNodes[obj.nodeId][obj.id];

    //                 if (   cur.type == objTypeString(obj.type)
    //                     && cur.getPluginData('id')     == obj.id
    //                     && cur.getPluginData('nodeId') == obj.nodeId)
    //                     figUpdateRect(obj);

    //                 else
    //                     figNotify('Error: Object ID mismatch', '', 400, true);
    //             }

    //             break;
    //         }
    //     }
    // }
}



function figCreateObject(obj)
{
    let genObj;
    
    switch (obj.type)
    {
        case OBJ_RECT: genObj = figCreateRect(obj); break;
    }


    genObj.name = obj.nodeId.toString() + ':' + obj.id.toString();

    //genObj.setPluginData('id',     obj.id    .toString());
    genObj.setPluginData('type',   obj.type  .toString());
    genObj.setPluginData('nodeId', obj.nodeId.toString());
    //genObj.setPluginData('name',   rect.name);
    

    genObjects[obj.id] = genObj;
    figma.currentPage.appendChild(genObj);
}



function figCreateFrame()
{
    let frame = figma.createFrame();

    frame.name = 'Generator';

    let tx : Paint = {type: 'SOLID', color: {r: 0, g: 0, b: 0}, opacity: 0};
    frame.fills = [tx];

    //frame.resize(
    //    (nCols*rectSize + (nCols-1)*hgap),
    //    (nRows*rectSize + (nRows-1)*hgap));

    return frame;
}



function figCreateRect(obj)
{
    //console.log(obj);

    const rect = figma.createRectangle();

    rect.x = obj.x;
    rect.y = obj.y;
    
    rect.fills = [{type: 'SOLID', color: {r: 0, g: 0, b: 0}}];
    
    rect.resize(
        Math.max(0.01, obj.width), 
        Math.max(0.01, obj.height));
        
    rect.rotation     = obj.angle;
    rect.cornerRadius = obj.round;

    return rect;
}



function figUpdateObject(obj)
{
    switch (obj.type)
    {
        case OBJ_RECT:
        {
            figUpdateRect(obj);
            break;
        }
    }
}



function figUpdateRect(obj)
{
    const rect = genObjects[obj.id];

    rect.x = obj.x;
    rect.y = obj.y;

    if (   rect.width  != obj.width
        || rect.height != obj.height)
    {
        rect.resize(
            Math.max(0.01, obj.width), 
            Math.max(0.01, obj.height));
    }

    rect.rotation     = obj.angle;
    rect.cornerRadius = obj.round;
}



function figDeleteNodeObjects(nodeIds)
{
    // for (const nodeId of nodeIds)
    // {
    //     if (!objNodes[nodeId]) continue;
        
    //     for (const obj of objNodes[nodeId])
    //         obj.remove();

    //     objNodes[nodeId] = null;
    // }
}



function figDeleteAllObjects()
{
    for (const obj of figma.currentPage.children)
        if (!!obj.getPluginData('id')) obj.remove();
}