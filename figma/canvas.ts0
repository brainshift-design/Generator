function figCreateFrame()
{
    let frame = figma.createFrame();

    frame.name = 'Generator';

    let tx : Paint = {type: 'SOLID', color: {r: 0, g: 0, b: 0}, opacity: 0};
    frame.fills = [tx];

    //frame.resize(
    //    (nCols*rectSize + (nCols-1)*hgap),
    //    (nRows*rectSize + (nRows-1)*hgap));
}



function figCreateRect(obj)
{
    const rect = figma.createRectangle();

    rect.name = obj.nodeId.toString() + ':' + obj.id.toString();

    rect.setPluginData('id',     obj.id    .toString());
    rect.setPluginData('nodeId', obj.nodeId.toString());
    rect.setPluginData('name',   rect.name);
    
    rect.x = obj.x
    rect.y = obj.y;
    
    rect.fills = [{type: 'SOLID', color: {r: 0, g: 0, b: 0}}];

    rect.resize(
        Math.max(0.01, obj.width), 
        Math.max(0.01, obj.height));

    rect.cornerRadius = obj.round;

    objNodes[obj.nodeId][obj.id] = rect;
    figma.currentPage.appendChild(rect);
}



function figUpdateRect(obj)
{
    const rect = objNodes[obj.nodeId][obj.id];

    rect.x = obj.x;
    rect.y = obj.y;

    if (   rect.width  != obj.width
        || rect.height != obj.height)
    {
        rect.resize(
            Math.max(0.01, obj.width), 
            Math.max(0.01, obj.height));
    }

    rect.cornerRadius = obj.round;
}



function figUpdateObjects(objects)
{
    // prepare the buffers

    let nodeId = -1;
    let prevId = -1;
    let count  =  0;

    
    for (const obj of objects)
    {
        count++;

        if (obj.nodeId != nodeId)
        {
            nodeId = obj.nodeId;

            if (prevId > -1)
            {
                if (  !objNodes[prevId]
                    || objNodes[prevId].length != count)
                {
                    figDeleteNodeObjects([prevId]);
                    objNodes[prevId] = new Array(count).fill(null);
                }

                count = 0;
            }

            prevId = nodeId;
        }
    }


    if (   count > 0
        && (  !objNodes[nodeId]
            || objNodes[nodeId].length != count))
    {
        figDeleteNodeObjects([nodeId]);
        objNodes[nodeId] = new Array(count).fill(null);
    }


    // fill the buffers

    for (const obj of objects)
    {
        switch (obj.type)
        {
            case OBJ_RECT:
            {
                if (!objNodes[obj.nodeId][obj.id])
                {
                    figCreateRect(obj);
                }
                else 
                {
                    const cur = objNodes[obj.nodeId][obj.id];

                    if (   cur.type == objTypeString(obj.type)
                        && cur.getPluginData('id')     == obj.id
                        && cur.getPluginData('nodeId') == obj.nodeId)
                        figUpdateRect(obj);

                    else
                        figNotify('Error: Object ID mismatch', '', 400, true);
                }

                break;
            }
        }
    }
}



function figDeleteNodeObjects(nodeIds)
{
    for (const nodeId of nodeIds)
    {
        if (!objNodes[nodeId]) continue;
        
        for (const obj of objNodes[nodeId])
            obj.remove();

        objNodes[nodeId] = null;
    }
}



function figDeleteAllObjects()
{
    for (const obj of figma.currentPage.children)
        if (!!obj.getPluginData('id')) obj.remove();
}