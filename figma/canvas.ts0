var figObjectArrays = new Array(); // [ {nodeId, [objects]} ]
var figStyleArrays  = new Array(); // [ {nodeId, [styles]}  ]



function figDeleteObjectsFromNodeIds(nodeIds)
{
    for (let i = figPoints.length-1; i >= 0; i--)
        if (nodeIds.includes(figPoints[i].getPluginData('nodeId')))
            figPoints.splice(i, 1);

    for (let i = figEmptyObjects.length-1; i >= 0; i--)
        if (   figEmptyObjects[i].removed
            || nodeIds.includes(figEmptyObjects[i].getPluginData('nodeId')))
            figEmptyObjects.splice(i, 1);

    figma.currentPage
        .findAll(o => nodeIds.includes(o.getPluginData('nodeId')))
        .forEach(o => { if (!o.removed) o.remove(); });

    figObjectArrays = figObjectArrays.filter(a => !nodeIds.includes(a.nodeId));
}



function figDeleteObjectsExcept(nodeIds, ignoreObjects)
{
    for (let i = figObjectArrays.length-1; i >= 0; i--)
    {
        const figObjArray = figObjectArrays[i];

        if (!nodeIds.includes(figObjArray.nodeId))
            continue;


        for (let j = figObjArray.objects.length-1; j >= 0; j--)
        {
            const obj = figObjArray.objects[j];
            
            
            if (    obj.removed
                || !findObject(obj, ignoreObjects))//ignoreObjects.find(o => obj.name == makeObjectName(o)))
            {
                if (!obj.removed)
                    obj.remove();

                removeFromArray(figObjArray.objects, obj);

                if (figPoints.includes(obj))
                    removeFromArray(figPoints, obj);

                if (figEmptyObjects.includes(obj))
                    removeFromArray(figEmptyObjects, obj);
            }
        }
        

        if (isEmpty(figObjArray.objects))
            removeFromArray(figObjectArrays, figObjArray);
    }
}



function findObject(obj, ignoreObjects)
{
    if (   obj.type == SHAPE_GROUP
        || obj.type == FRAME)
    {
        for (const child of obj.children)
        {
            const found = findObject(child, ignoreObjects);
            if (found) return found;
        }
    }
    else
    {
        const found = ignoreObjects.find(o => o[FO_OBJECT_ID] == obj.getPluginData('objectId'));
        if (found) return found;
    }

    
    return null;
}



function figDeleteAllObjects()
{
    for (const obj of figma.currentPage.children)
    {
        if (    obj.getPluginData('objectId') != ''
            && !obj.removed) 
            obj.remove();
    }
}



function figDeleteStylesFromNodeIds(nodeIds, mustDelete)
{
    // styles are deleted first
    
    const paintStyles = figma.getLocalPaintStyles();

    paintStyles
        .filter(s => 
                nodeIds.includes(s.getPluginData('nodeId')))
//            && !parseBool(s.getPluginData('existing')))
        .forEach(s => 
        {
            const nodeId   = s.getPluginData('nodeId');
            const existing = parseBool(s.getPluginData('existing'));
            
            if (!existing) 
            {
                s.remove();
            }
            else if (mustDelete)
            {
                removeFromArrayWhere(figStyleArrays, a => a.nodeId == nodeId);

                s.setPluginData('type',     NULL);
                s.setPluginData('nodeId',   NULL);
                s.setPluginData('existing', NULL);
            }
        });


    if (mustDelete)
        figStyleArrays = figStyleArrays.filter(a => !nodeIds.includes(a.nodeId));
}