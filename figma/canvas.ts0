const figObjectArrays = []; // {nodeId, [objects]}



function figUpdate(msg)
{
    if (   settings.logObjectUpdates
        && msg.objects.length > 0)
        logObjectUpdates(msg.objects);

        
    for (let i = 0; i < msg.nodeIds.length; i++)
    {
        figSetPageData(
            nodeNameForStorage(msg.nodeIds[i]),
            msg.nodeJson[i]);        
    }


    let curNodeId  = '';
    let figObjects = null;

    for (const genObj of msg.objects)
    {
        if (genObj.nodeId != curNodeId)
        {
            curNodeId  = genObj.nodeId;
            
            figObjects = figObjectArrays.find(a => a.nodeId == genObj.nodeId);
            if (!figObjects) figObjectArrays.push(figObjects = {nodeId: genObj.nodeId, objects: []});
        }

        const figObj = figObjects[genObj.id];


        if (  !figObj 
            || figObj.removed) // no existing object, create new object
            figCreateObject(figObjects, genObj);

        else if (figObj.getPluginData('type') == genObj.type.toString()) // update existing object
            figUpdateObject(figObj, genObj);

        else // delete existing object, create new object
        {
            figObj.remove();
            figCreateObject(figObjects, genObj);
        }
    }


    figPostMessageToUI
}



function figCreateObject(objects, genObj)
{
    let figObj;
    
    switch (genObj.type)
    {
        case RECTANGLE: figObj = figCreateRect   (genObj); break;
        case LINE:      figObj = figCreateLine   (genObj); break;
        case ELLIPSE:   figObj = figCreateEllipse(genObj); break;
        case POLYGON:   figObj = figCreatePolygon(genObj); break;
        case STAR:      figObj = figCreateStar   (genObj); break;
    }


    figObj.name = '◦G•   ' + genObj.nodeId.toString() + ' : ' + genObj.id.toString();

    figObj.setPluginData('id',     genObj.id    .toString());
    figObj.setPluginData('type',   genObj.type  .toString());
    figObj.setPluginData('nodeId', genObj.nodeId.toString());
    

    objects[genObj.id] = figObj;
    figma.currentPage.appendChild(figObj);
}



function figUpdateObject(figObj, genObj)
{
    switch (genObj.type)
    {
        case RECTANGLE: figUpdateRect   (figObj, genObj); break;
        case LINE:      figUpdateLine   (figObj, genObj); break;
        case ELLIPSE:   figUpdateEllipse(figObj, genObj); break;
        case POLYGON:   figUpdatePolygon(figObj, genObj); break;
        case STAR:      figUpdateStar   (figObj, genObj); break;
    }
}



function figDeleteObjectsFromNodeIds(nodeIds)
{
    figma.currentPage
        .findAll(o => nodeIds.includes(o.getPluginData('nodeId')))
        .forEach(o => o.remove());
}



function figDeleteAllObjects()
{
    for (const obj of figma.currentPage.children)
        if (!!obj.getPluginData('id')) obj.remove();
}