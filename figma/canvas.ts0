var figObjectArrays = new Array(); // [ {nodeId, [objects]} ]
var figStyleArrays  = new Array(); // [ {nodeId, [styles]}  ]



function figDeleteObjectsAndStylesFromNodeIds(nodeIds, force)
{
    // styles are deleted first
    
    const paintStyles = figma.getLocalPaintStyles();

    figma.currentPage
        .findAll(o => nodeIds.includes(o.getPluginData('nodeId')))
        .forEach(o => o.remove());

    paintStyles
        .filter(s => 
                nodeIds.includes(s.getPluginData('nodeId')) 
            && (  !parseBool(s.getPluginData('existing'))
                || force))
        .forEach(s => 
        {
            const nodeId   = s.getPluginData('nodeId');
            const existing = parseBool(s.getPluginData('existing'));
            
            if (!existing) 
                s.remove();
            else
            {
                removeFromArrayWhere(figStyleArrays, a => a.nodeId == nodeId);

                s.setPluginData('type',     NULL);
                s.setPluginData('nodeId',   NULL);
                s.setPluginData('existing', NULL);
            }
        });


    figObjectArrays = figObjectArrays.filter(a => !nodeIds.includes(a['nodeId']));

    figStyleArrays = figStyleArrays.filter(a => 
           !nodeIds.includes(a['nodeId'])
        && (   !parseBool(a['existing'])
            && !force));
}



function figDeleteAllObjects()
{
    for (const obj of figma.currentPage.children)
        if (!!obj.getPluginData('id')) 
            obj.remove();
}