//const MAX_OBJECTS = 0x10000;

const figObjectArrays = []; // {nodeId, [objects]}



function figUpdateObjects(/*updateId,*/ genObjects)
{
    if (settings.logObjectUpdates)
        logObjectUpdates(genObjects);

        
    let curNodeId  = '';
    let figObjects = null;

    for (const genObj of genObjects)
    {
        if (genObj.nodeId != curNodeId)
        {
            curNodeId  = genObj.nodeId;
            
            figObjects = figObjectArrays.find(a => a.nodeId == genObj.nodeId);
            if (!figObjects) figObjectArrays.push(figObjects = {nodeId: genObj.nodeId, objects: []});
        }

        const figObj = figObjects[genObj.id];


        if (  !figObj 
            || figObj.removed) // no existing object, create new object
            figCreateObject(figObjects, genObj);

        else if (figObj.getPluginData('type') == genObj.type.toString()) // update existing object
            figUpdateObject(figObj, genObj);

        else // delete existing object, create new object
        {
            figObj.remove();
            figCreateObject(figObjects, genObj);
        }
    }
}



// function figUpdateObjectArrays(genNodes)
// {
//     for (let i = 0; i < genNodes.length; i++)
//     {
//         let index = figObjectArrays.findIndex(a => a.nodeId = genNodes[i].nodeId);

//         if (index < 0) 
//         {
//             figObjectArrays.push({nodeId: genNodes[i].nodeId, objects: []});
//             index = figObjectArrays.length-1;
//         }
//     }
// }



function figCreateObject(objects, genObj)
{
    let figObj;
    
    switch (genObj.type)
    {
        case RECTANGLE: figObj = figCreateRect(genObj); break;
    }


    figObj.name = '◦G•   ' + genObj.nodeId.toString() + ' : ' + genObj.id.toString();

    figObj.setPluginData('id',     genObj.id    .toString());
    figObj.setPluginData('type',   genObj.type  .toString());
    figObj.setPluginData('nodeId', genObj.nodeId.toString());
    //genObj.setPluginData('name',   rect.name);
    

    objects[genObj.id] = figObj;
    figma.currentPage.appendChild(figObj);
}



// function figCreateFrame()
// {
//     let frame = figma.createFrame();

//     frame.name = 'Generator';

//     let tx : Paint = {type: 'SOLID', color: {r: 0, g: 0, b: 0}, opacity: 0};
//     frame.fills = [tx];

//     //frame.resize(
//     //    (nCols*rectSize + (nCols-1)*hgap),
//     //    (nRows*rectSize + (nRows-1)*hgap));

//     return frame;
// }



function figCreateRect(obj)
{
    //console.log(obj);

    const rect = figma.createRectangle();

    rect.x = obj.x;
    rect.y = obj.y;
    
    rect.fills = [{type: 'SOLID', color: {r: 0, g: 0, b: 0}}];
    
    rect.resize(
        Math.max(0.01, obj.width), 
        Math.max(0.01, obj.height));
        
    rect.rotation     = obj.angle;
    rect.cornerRadius = obj.round;

    return rect;
}



function figUpdateObject(figObj, genObj)
{
    switch (genObj.type)
    {
        case RECTANGLE:
        {
            figUpdateRect(figObj, genObj);
            break;
        }
    }
}



function figUpdateRect(figRect, genRect)
{
    figRect.x = genRect.x;
    figRect.y = genRect.y;

    if (   figRect.width  != genRect.width
        || figRect.height != genRect.height)
    {
        figRect.resize(
            Math.max(0.01, genRect.width), 
            Math.max(0.01, genRect.height));
    }

    figRect.rotation     = genRect.angle;
    figRect.cornerRadius = genRect.round;
}



function figDeleteObjectsFromNodeIds(nodeIds)
{
    figma.currentPage
        .findAll(o => nodeIds.includes(o.getPluginData('nodeId')))
        .forEach(o => o.remove());
}



function figDeleteAllObjects()
{
    for (const obj of figma.currentPage.children)
        if (!!obj.getPluginData('id')) obj.remove();
}