function figGetAllLocalColorStyles(nodeId, px, py)
{
    const _styles = figma.getLocalPaintStyles();


    const styles = [];

    for (const _style of _styles)
    {
        console.log('_style =', _style);
        const _existing = _style.getPluginData('existing');

        const existing = !!_existing;

        const style = { 
            id:       _style.id,
            name:     _style.name,
            existing: existing,
            paints:   []
        };

        
        for (const _paint of _style.paints)
        {
            if (_paint.type == 'SOLID')
            {
                style.paints.push([
                    _paint.color.r,
                    _paint.color.g,
                    _paint.color.b]);
            }
        }


        styles.push(style);
    }


    figPostMessageToUI({
        cmd:   'uiReturnFigGetAllLocalColorStyles',
        nodeId: nodeId,
        px:     px,
        py:     py,
        styles: JSON.stringify(styles)});
}



function figLinkNodeToExistingColorStyle(nodeId, styleName)
{
    let figStyles = figStyleArrays.find(a => a.nodeId == genStyle.nodeId);
    console.assert(!figStyles, 'figStyles should not be found here');

    const _styles  = figma.getLocalPaintStyles();
    const figStyle = _styles.find(s => s.name == styleName);
    console.assert(!!figStyle, 'figStyle should be found here');

    figStyle.setPluginData('type',     'COLOR_STYLE');
    figStyle.setPluginData('nodeId',   nodeId);
    figStyle.setPluginData('existing', boolToString(true));

    figStyleArrays.push({nodeId: nodeId, styles: [figStyle]});
}



function figCreateColorStyle(styles, genStyle)
{
    const figStyle = figma.createPaintStyle();


    figStyle.setPluginData('type',     genStyle.type);
    figStyle.setPluginData('nodeId',   genStyle.nodeId);
    figStyle.setPluginData('existing', boolToString(genStyle.existing));

    figStyle.name = genStyle.styleName;


    setStylePaints(figStyle, genStyle);


    styles.push(figStyle);


    return figStyle;
}



function figUpdateStyles(msg)
{
    let curNodeId = NULL;
    let figStyles;

    for (const genStyle of msg.styles)
    {
        if (genStyle.nodeId != curNodeId)
        {
            curNodeId = genStyle.nodeId;
            
            figStyles = figStyleArrays.find(a => a.nodeId == genStyle.nodeId);

            if (!figStyles) 
                figStyleArrays.push(figStyles = {nodeId: genStyle.nodeId, styles: []});
        }
        else
            figStyles = null;

        console.assert(figStyles, 'figStyles should not be null here');
        

        const figStyle = figStyles.styles[0];
        console.log('figStyle =', figStyle);
        const existing = figStyle.getPluginData('existing');
        // const existing = false;

        
        const paintStyles = figma.getLocalPaintStyles();

        const removed = !paintStyles.find(s => genStyle.nodeId == s.getPluginData('nodeId'));

        
        if (   isValid(figStyle)
            && removed)
            removeFrom(figStyles.styles, figStyle);


        if (   !existing
            && (  !isValid(figStyle)
                || removed)) // no existing style, create new style
            figCreateColorStyle(figStyles.styles, genStyle);

        else if (figStyle.getPluginData('type') == genStyle.type) // update existing style
            figUpdateColorStyle(figStyle, genStyle);

        else if (!existing) // delete existing style, create new style
        {
            figStyle.remove();
            figCreateColorStyle(figStyles.styles, genStyle);
        }
    }
}



function figUpdateColorStyle(figStyle, genStyle)
{
    setStylePaints(figStyle, genStyle);

    figStyle.name = genStyle.nodeName;
}



///////////////////////////////////////////////////////////////////////////////////////////////////



function getStylePaints(stylePaints)
{
    const paints = [];

    for (const _paint of stylePaints)
    {
        const fill = _paint[1].split(' ');

        switch (_paint[0])
        {
            case 'SOLID':
                paints.push(
                {
                    type: 'SOLID', 
                    color: {
                        r: Math.min(Math.max(0, parseFloat(fill[0]) / 0xff), 1), 
                        g: Math.min(Math.max(0, parseFloat(fill[1]) / 0xff), 1), 
                        b: Math.min(Math.max(0, parseFloat(fill[2]) / 0xff), 1) },
                    opacity: Math.min(Math.max(0, parseFloat(fill[3]) / 100), 1)
                });

                break;
        }
    }

    return paints;
}



function setStylePaints(style, src)
{
    if (   !!src.paints
        &&   src.paints.length > 0)
        style.paints = getStylePaints(src.paints);
    else
        style.paints = [];
}
