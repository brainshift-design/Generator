function figCreateColorStyle(styles, genStyle)
{
    const figStyle = figma.createPaintStyle();

    figStyle.name = genStyle.nodeName;//makeObjectName(stl);

    setStylePaints(figStyle, genStyle);


    figStyle.setPluginData('id',     genStyle.styleId.toString());
    figStyle.setPluginData('type',   genStyle.type   .toString());
    figStyle.setPluginData('nodeId', genStyle.nodeId .toString());


    styles.push(figStyle);


    return figStyle;
}



function figUpdateStyles(msg)
{
    //console.log('figUpdateStyles()');
    //console.log('msg.styles =', msg.styles);

    let curNodeId = NULL;
    let figStyles = null;

    for (const genStyle of msg.styles)
    {
        if (genStyle.nodeId != curNodeId)
        {
            curNodeId  = genStyle.nodeId;
            
            figStyles = figStyleArrays.find(a => a.nodeId == genStyle.nodeId);

            if (!figStyles) 
                figStyleArrays.push(figStyles = {nodeId: genStyle.nodeId, styles: []});
        }

        // console.log('figStyles =', figStyles);
        // console.log('genStyle.styleId =', genStyle.styleId);
        const figStyle = figStyles.styles[genStyle.styleId];


        if (  !isValid(figStyle)
            || figStyle.removed) // no existing object, create new object
        {
            console.log('create');
            figCreateColorStyle(figStyles.styles, genStyle);
        }

        else if (figStyle.getPluginData('type') == genStyle.type.toString()) // update existing object
        {
            console.log('update');
            figUpdateColorStyle(figStyle, genStyle);
        }

        else // delete existing object, create new object
        {
            console.log('RE-create');
            figStyle.remove();
            figCreateColorStyle(figStyles.styles, genStyle);
        }
    }
}



function figUpdateColorStyle(figStyle, genStyle)
{
    setStylePaints(figStyle, genStyle);
}



///////////////////////////////////////////////////////////////////////////////////////////////////



function getStylePaints(stylePaints)
{
    const paints = [];

    for (const _paint of stylePaints)
    {
        const fill = _paint[1].split(' ');

        switch (_paint[0])
        {
            case 'SOLID':
                paints.push(
                {
                    type: 'SOLID', 
                    color: {
                        r: Math.min(Math.max(0, parseFloat(fill[0]) / 0xff), 1), 
                        g: Math.min(Math.max(0, parseFloat(fill[1]) / 0xff), 1), 
                        b: Math.min(Math.max(0, parseFloat(fill[2]) / 0xff), 1) },
                    opacity: Math.min(Math.max(0, parseFloat(fill[3]) / 100), 1)
                });

                break;
        }
    }

    return paints;
}



function setStylePaints(style, src)
{
    if (   !!src.paints
        &&   src.paints.length > 0)
        style.paints = getStylePaints(src.paints);
    else
        style.paints = [];
}
