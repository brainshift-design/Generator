var _genIgnoreNodeIds = [];
var _genIgnoreObjects = [];

var  curObjectCount   = 0;
var  objUpdateCount   = 0;


function makeObjectName(obj)
{
    return (obj[FO_RETAIN] === 2 ? '' : OBJECT_PREFIX)
         + (showIds ? obj[FO_OBJECT_ID] : obj[FO_OBJECT_NAME]);
}



function figCreateObject(genObj, addObject = null)
{
    if (!genObjectIsValid(genObj))
        return null;


    let figObj;

    switch (genObj[FO_TYPE])
    {
        case RECTANGLE:      figObj = figCreateRect         (genObj);  break;
        case LINE:           figObj = figCreateLine         (genObj);  break;
        case ELLIPSE:        figObj = figCreateEllipse      (genObj);  break;
        case POLYGON:        figObj = figCreatePolygon      (genObj);  break;
        case STAR:           figObj = figCreateStar         (genObj);  break;
        case TEXT_SHAPE:     figObj = figCreateText         (genObj);  break;
        case POINT:          figObj = figCreatePoint        (genObj);  break;
        case VECTOR_PATH:    figObj = figCreateVectorPath   (genObj);  break;
        case VECTOR_NETWORK: figObj = figCreateVectorNetwork(genObj);  break;
        case BOOLEAN:        figObj = figCreateBoolean      (genObj);  break;
        case SHAPE_GROUP:    figObj = figCreateShapeGroup   (genObj);  break;
        case FRAME:          figObj = figCreateFrame        (genObj);  break;
    }


    if (    addObject
        && !figObj.removed)
    {
        figObj.name = makeObjectName(genObj);

        consoleAssert(
               genObj[FO_TYPE] == SHAPE_GROUP // cannot exist without children
            || !!figObj, 
            'no Figma object created');


        if (figObj)
        {
            figObj.setPluginData('retain', genObj[FO_RETAIN].toString());

            if (genObj[FO_RETAIN] < 2)
            {
                figObj.setPluginData('userId',    figma.currentUser.id);
                figObj.setPluginData('sessionId', figma.currentUser.sessionId.toString());
                figObj.setPluginData('type',      genObj[FO_TYPE     ]);
                figObj.setPluginData('nodeId',    genObj[FO_NODE_ID  ]);
                figObj.setPluginData('objectId',  genObj[FO_OBJECT_ID]);
                figObj.setPluginData('isCenter',  boolToString(genObj[FO_IS_CENTER]));
                

                if (genObj[FO_TYPE] == POINT)
                    figPoints.push(figObj);
            
                if (genObj[FO_DECO])
                    updateDecoObject(figObj);
            }

            addObject(figObj);

            curObjectCount++;
            objUpdateCount++;
        }
    }
        

    return figObj;
}



function figUpdateObject(figObj, genObj)
{
    if (  !genObjectIsValid(genObj)
        || figObj.removed)
        return;

        
    figObj.name = makeObjectName(genObj);
    
    figObj.setPluginData('retain', genObj[FO_RETAIN].toString());


    switch (genObj[FO_TYPE])
    {
        case RECTANGLE:      figUpdateRect         (figObj, genObj);  break;
        case LINE:           figUpdateLine         (figObj, genObj);  break;
        case ELLIPSE:        figUpdateEllipse      (figObj, genObj);  break;
        case POLYGON:        figUpdatePolygon      (figObj, genObj);  break;
        case STAR:           figUpdateStar         (figObj, genObj);  break;
        case TEXT_SHAPE:     figUpdateText         (figObj, genObj);  break;
        case POINT:          figUpdatePoint        (figObj, genObj);  break;
        case VECTOR_PATH:    figUpdateVectorPath   (figObj, genObj);  break;
        case VECTOR_NETWORK: figUpdateVectorNetwork(figObj, genObj);  break;
        case BOOLEAN:        figUpdateBoolean      (figObj, genObj);  break;
        case SHAPE_GROUP:    figUpdateShapeGroup   (figObj, genObj);  break;
        case FRAME:          figUpdateFrame        (figObj, genObj);  break;
    }


    figObj.parent.appendChild(figObj);


    if (genObj[FO_DECO])
        updateDecoObject(figObj);


    curObjectCount++;
    objUpdateCount++;
}



async function figUpdateObjects(figParent, genObjects, batchSize, nodeIds = [], firstChunk = false, lastChunk = false, zoomToFit = false)
{
    let curNodeId   = NULL;
    let figObjects  = null;

    let abort       = false;

    const updateObjects = [];


    _genIgnoreNodeIds.push(...nodeIds);



    for (const genObj of genObjects)
    {
        _genIgnoreObjects.push(genObj);


        if (genObj[FO_NODE_ID] != curNodeId)
        {
            curNodeId  = genObj[FO_NODE_ID];
            
            figObjects = figObjectArrays.find(a => a.nodeId == genObj[FO_NODE_ID]);

            if (!figObjects)
            {
                figObjectArrays.push(figObjects = 
                {
                    nodeId:  genObj[FO_NODE_ID], 
                    objects: []
                });
            }
        }


        const addObject = figObj =>
        {
            if (    figParent
                && !figParent.removed) 
                figParent.appendChild(figObj);
            else
                figObjects.objects.push(figObj);
        };


        let objects =
                figParent
            && !figParent.removed
            ? figParent.children
            : figObjects.objects;

        let figObj = objects.find(o => 
               o.removed
            ||    o.getPluginData('userId'   ) == figma.currentUser.id
               //&& o.getPluginData('sessionId') == figma.currentUser.sessionId.toString()
               && o.getPluginData('objectId' ) == genObj[FO_OBJECT_ID]);


        if (   figObj != undefined
            && figObj != null
            && figObj.removed)
        {
            removeFrom(objects, figObj);
        
            if (figPoints.includes(figObj))
                removeFromArray(figPoints, figObj);

            if (figEmptyObjects.includes(figObj))
                removeFromArray(figEmptyObjects, figObj);
        }


        if (   figObj == undefined
            || figObj == null
            || figObj.removed) // no existing object, create new one
        {
            const newObj = figCreateObject(genObj, addObject);
            updateObjects.push(newObj);
        }

        else if (!figObj.removed
               && figObj.getPluginData('type') == genObj[FO_TYPE].toString()) // update existing object
        {
            figUpdateObject(figObj, genObj);

            if (    figObj
                && !figObj.removed) 
                updateObjects.push(figObj);
        }
    
        else // delete existing object, create new one
        {
            figObj.remove();

            if (figPoints.includes(figObj))
                removeFromArray(figPoints, figObj);

            if (figEmptyObjects.includes(figObj))
                removeFromArray(figEmptyObjects, figObj);

            figCreateObject(genObj, addObject);
        }


        if (objUpdateCount >= batchSize)
        {
            const result = await figGetValueFromUiSync('returnObjectUpdate', { objectCount: curObjectCount }) as { key: string, value: boolean };
            abort = result.value;

            objUpdateCount = 0;

            if (abort) break;
        }
    }


    // delete removed objects from parent
    
    if (    figParent
        && !figParent.removed)
    {
        for (const figObj of figParent.children)
        {
            if (    figObj.removed
                || !genObjects.find(o => 
                           o[FO_OBJECT_ID] == figObj.getPluginData('objectId')
                        && figObj.getPluginData('userId') == figma.currentUser.id))
                        //&& figObj.getPluginData('sessionId') == figma.currentUser.sessionId.toString()))
                figObj.remove();
        }
    }


    // put points on top
    
    for (const point of figPoints)
        if (   !point.removed
            && !point.parent.removed)
            point.parent.appendChild(point);


    if (    lastChunk
        && !abort)
    {
        // delete old content

        figDeleteObjectsExcept(
            _genIgnoreNodeIds, 
            _genIgnoreObjects);

        _genIgnoreNodeIds = [];
        _genIgnoreObjects = [];

        
        if (   zoomToFit
            && updateObjects.length > 0)
        {
            figma.viewport.scrollAndZoomIntoView(updateObjects);

            const bounds = figGetObjectBounds(updateObjects);
                
            figma.viewport.zoom = Math.min(
                figma.viewport.bounds.width  * figma.viewport.zoom / bounds.width  - 0.05,
                figma.viewport.bounds.height * figma.viewport.zoom / bounds.height - 0.05);
        }
    }


    await figGetValueFromUiSync('returnObjectUpdate', { objectCount: curObjectCount })
}



function genObjectIsValid(genObj)
{
    switch (genObj[FO_TYPE])
    {
        case RECTANGLE:      return genRectIsValid         (genObj);
        case LINE:           return genLineIsValid         (genObj);
        case ELLIPSE:        return genEllipseIsValid      (genObj);
        case POLYGON:        return genPolygonIsValid      (genObj);
        case STAR:           return genStarIsValid         (genObj);
        case TEXT_SHAPE:     return genTextIsValid         (genObj);
        case POINT:          return genPointIsValid        (genObj);
        case VECTOR_PATH:    return genVectorPathIsValid   (genObj);
        case VECTOR_NETWORK: return genVectorNetworkIsValid(genObj);
        case BOOLEAN:        return genBooleanIsValid      (genObj);
        case SHAPE_GROUP:    return genShapeGroupIsValid   (genObj);
        case FRAME:          return genFrameIsValid        (genObj);
    }
}



function figGetObjectSize(genObj)
{
    (async () =>
    {
        const figObj = figCreateObject(genObj);
        
        const width  = figObj.width;
        const height = figObj.height;

        figObj.remove();


        figPostMessageToUi(
        {
            cmd: 'uiForwardToGenerator',
            msg: 
            {
                cmd:     'returnFigGetObjectSize',
                objectId: genObj[FO_OBJECT_ID],
                width:    width,
                height:   height
            }
        });
    })();
}



function clearObjectData(figObj)
{
    figObj.setPluginData('type',      '');
    figObj.setPluginData('nodeId',    '');
    figObj.setPluginData('userId',    '');
    figObj.setPluginData('sessionId', '');
    figObj.setPluginData('objectId',  '');
    figObj.setPluginData('isCenter',  '');
    figObj.setPluginData('retain',    '');
}



function figGetObjectBounds(objects)
{
    const bounds = 
    { 
        left:   0, 
        top:    0, 
        right:  0, 
        bottom: 0 
    };

    for (const obj of objects)
    {
        if (obj.x < bounds.left                || bounds.left == bounds.right ) bounds.left   = obj.x;
        if (obj.y < bounds.top                 || bounds.top  == bounds.bottom) bounds.top    = obj.y;
        if (obj.x + obj.width  > bounds.right  || bounds.left == bounds.right ) bounds.right  = obj.x + obj.width;
        if (obj.y + obj.height > bounds.bottom || bounds.top  == bounds.bottom) bounds.bottom = obj.y + obj.height;
    }

    return {
        x:      bounds.left,
        y:      bounds.top,
        width:  bounds.right  - bounds.left,
        height: bounds.bottom - bounds.top };
}