function figCreateRect(obj)
{
    console.log(obj);

    const rect = figma.createRectangle();

    rect.x = obj.x;
    rect.y = obj.y;
    
    console.log('obj.fills =', obj.fills);

    if (   obj.fills !== null
        && obj.fills.filter(f => f[0] === COLOR_FILL).length > 0)
        rect.fills = getObjectFills(obj.fills);
    else
        rect.fills = [{type: 'SOLID', color: {r: 0, g: 0, b: 0}}];
    

    rect.resize(
        Math.max(0.01, obj.width), 
        Math.max(0.01, obj.height));
        
    rect.rotation     = obj.angle;
    rect.cornerRadius = obj.round;

    return rect;
}



function figUpdateRect(figRect, genRect)
{
    figRect.x = genRect.x;
    figRect.y = genRect.y;

    if (   figRect.width  != genRect.width
        || figRect.height != genRect.height)
    {
        figRect.resize(
            Math.max(0.01, genRect.width), 
            Math.max(0.01, genRect.height));
    }

    figRect.rotation     = genRect.angle;
    figRect.cornerRadius = genRect.round;

    figRect.fills        = getObjectFills(genRect.fills);
}



///////////////////////////////////////////////////////////////////////////////////////////////////



function figCreateLine(obj)
{
    //console.log(obj);

    const line = figma.createLine();

    line.x = obj.x;
    line.y = obj.y;
    
    line.fills = [{type: 'SOLID', color: {r: 0, g: 0, b: 0}}];
    
    line.resize(Math.max(0.01, obj.width), 0);
        
    line.rotation = obj.angle;

    return line;
}



function figUpdateLine(figLine, genLine)
{
    figLine.x = genLine.x;
    figLine.y = genLine.y;

    if (figLine.width != genLine.width)
        figLine.resize(Math.max(0.01, genLine.width), 0);

    figLine.rotation = genLine.angle;
}



///////////////////////////////////////////////////////////////////////////////////////////////////



function figCreateEllipse(obj)
{
    //console.log(obj);

    const ellipse = figma.createEllipse();

    ellipse.x = obj.x;
    ellipse.y = obj.y;
    
    ellipse.fills = [{type: 'SOLID', color: {r: 0, g: 0, b: 0}}];
    
    ellipse.resize(
        Math.max(0.01, obj.width), 
        Math.max(0.01, obj.height));
        
    ellipse.rotation = obj.angle;

    return ellipse;
}



function figUpdateEllipse(figEllipse, genEllipse)
{
    figEllipse.x = genEllipse.x;
    figEllipse.y = genEllipse.y;

    if (   figEllipse.width  != genEllipse.width
        || figEllipse.height != genEllipse.height)
    {
        figEllipse.resize(
            Math.max(0.01, genEllipse.width), 
            Math.max(0.01, genEllipse.height));
    }

    figEllipse.rotation = genEllipse.angle;
}



///////////////////////////////////////////////////////////////////////////////////////////////////



function figCreatePolygon(obj)
{
    //console.log(obj);

    const poly = figma.createPolygon();

    poly.x = obj.x;
    poly.y = obj.y;
    
    poly.fills = [{type: 'SOLID', color: {r: 0, g: 0, b: 0}}];
    
    poly.resize(
        Math.max(0.01, obj.width), 
        Math.max(0.01, obj.height));
        
    poly.rotation     = obj.angle;
    poly.cornerRadius = obj.round;
    poly.pointCount   = obj.corners;

    return poly;
}



function figUpdatePolygon(figPoly, genPoly)
{
    figPoly.x = genPoly.x;
    figPoly.y = genPoly.y;

    if (   figPoly.width  != genPoly.width
        || figPoly.height != genPoly.height)
    {
        figPoly.resize(
            Math.max(0.01, genPoly.width), 
            Math.max(0.01, genPoly.height));
    }

    figPoly.rotation     = genPoly.angle;
    figPoly.cornerRadius = genPoly.round;
    figPoly.pointCount   = genPoly.corners;
}



///////////////////////////////////////////////////////////////////////////////////////////////////



function figCreateStar(obj)
{
    //console.log(obj);

    const star = figma.createStar();

    star.x = obj.x;
    star.y = obj.y;
    
    star.fills = [{type: 'SOLID', color: {r: 0, g: 0, b: 0}}];
    
    star.resize(
        Math.max(0.01, obj.width), 
        Math.max(0.01, obj.height));
        
    star.rotation     = obj.angle;
    star.cornerRadius = obj.round;
    star.pointCount   = obj.points;
    star.innerRadius  = obj.convex / 100;

    return star;
}



function figUpdateStar(figStar, genStar)
{
    figStar.x = genStar.x;
    figStar.y = genStar.y;

    if (   figStar.width  != genStar.width
        || figStar.height != genStar.height)
    {
        figStar.resize(
            Math.max(0.01, genStar.width), 
            Math.max(0.01, genStar.height));
    }

    figStar.rotation     = genStar.angle;
    figStar.cornerRadius = genStar.round;
    figStar.pointCount   = genStar.points;
    figStar.innerRadius  = genStar.convex / 100;
}



///////////////////////////////////////////////////////////////////////////////////////////////////



// function figCreateFrame()
// {
//     let frame = figma.createFrame();

//     frame.name = 'Generator';

//     let tx : Paint = {type: 'SOLID', color: {r: 0, g: 0, b: 0}, opacity: 0};
//     frame.fills = [tx];

//     //frame.resize(
//     //    (nCols*rectSize + (nCols-1)*hgap),
//     //    (nRows*rectSize + (nRows-1)*hgap));

//     return frame;
// }



///////////////////////////////////////////////////////////////////////////////////////////////////



function getObjectFills(objFills)
{
    const fills = [];

    for (const fill of objFills)
    {
        const c = fill[1].split(' ');

        switch (fill[0])
        {
            case COLOR_FILL:
                fills.push(
                {
                    type: 'SOLID', 
                    color: {
                        r: Math.min(Math.max(0, parseFloat(c[0])), 1), 
                        g: Math.min(Math.max(0, parseFloat(c[1])), 1), 
                        b: Math.min(Math.max(0, parseFloat(c[2])), 1) },
                    opacity: parseFloat(fill[2])
                });

                break;
        }
    }

    return fills;
}



// function setNodeFill(node, fill)
// {
//     switch (node.type)
//     {
//         case 'RECTANGLE':
//         case 'VECTOR':
//         case 'LINE':
//         case 'ELLIPSE':
//         case 'POLYGON':
//         case 'STAR':
//         case 'TEXT':
//         case 'BOOLEAN_OPERATION':
//         {
//             let n = node as typeof node;
//             let f = clone(n.fills);
//             f = fill;
//             n.fills = f;
//         }
//     }
// }



