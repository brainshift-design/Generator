var _genIgnoreNodeIds = [];
var _genIgnoreObjects = [];



function makeObjectName(obj)
{
    return (obj[FO_RETAIN] == 2 ? '' : OBJECT_PREFIX)
         + (showIds ? obj[FO_OBJECT_ID] : obj[FO_OBJECT_NAME]);
}



async function figCreateObject(genObj, addObject = null)
{
    if (!genObjectIsValid(genObj))
        return;


    let figObj;

    switch (genObj[FO_TYPE])
    {
        case RECTANGLE:   figObj =       figCreateRect      (genObj);  break;
        case LINE:        figObj =       figCreateLine      (genObj);  break;
        case ELLIPSE:     figObj =       figCreateEllipse   (genObj);  break;
        case POLYGON:     figObj =       figCreatePolygon   (genObj);  break;
        case STAR:        figObj =       figCreateStar      (genObj);  break;
        case TEXT_SHAPE:  figObj = await figCreateText      (genObj);  break;
        case POINT:       figObj =       figCreatePoint     (genObj);  break;
        case VECTOR_PATH: figObj =       figCreateVectorPath(genObj);  break;
        case BOOLEAN:     figObj =       figCreateBoolean   (genObj);  break;
        case SHAPE_GROUP: figObj =       figCreateShapeGroup(genObj);  break;
        case FRAME:       figObj =       figCreateFrame     (genObj);  break;
    }


    if (addObject)
    {
        figObj.name = makeObjectName(genObj);

        consoleAssert(
               genObj[FO_TYPE] == SHAPE_GROUP // cannot exist without children
            || !!figObj, 
            'no Figma object created');

            
        if (figObj)
        {
            figObj.setPluginData('type',     genObj[FO_TYPE     ]);
            figObj.setPluginData('nodeId',   genObj[FO_NODE_ID  ]);
            figObj.setPluginData('objectId', genObj[FO_OBJECT_ID]);
            figObj.setPluginData('retain',   genObj[FO_RETAIN   ].toString());
            
            if (genObj[FO_TYPE] == POINT)
                figPoints.push(figObj);

            addObject(figObj);
        }
    }
        

    return figObj;
}



async function figUpdateObject(figObj, genObj)
{
    if (!genObjectIsValid(genObj))
        return;

        
    figObj.name = makeObjectName(genObj);
    
    figObj.setPluginData('retain', genObj[FO_RETAIN].toString());


    switch (genObj[FO_TYPE])
    {
        case RECTANGLE:         figUpdateRect      (figObj, genObj);  break;
        case LINE:              figUpdateLine      (figObj, genObj);  break;
        case ELLIPSE:           figUpdateEllipse   (figObj, genObj);  break;
        case POLYGON:           figUpdatePolygon   (figObj, genObj);  break;
        case STAR:              figUpdateStar      (figObj, genObj);  break;
        case TEXT_SHAPE:  await figUpdateText      (figObj, genObj);  break;
        case POINT:             figUpdatePoint     (figObj, genObj);  break;
        case VECTOR_PATH:       figUpdateVectorPath(figObj, genObj);  break;
        case BOOLEAN:           figUpdateBoolean   (figObj, genObj);  break;
        case SHAPE_GROUP:       figUpdateShapeGroup(figObj, genObj);  break;
        case FRAME:             figUpdateFrame     (figObj, genObj);  break;
    }
}



async function figUpdateObjects(figParent, genObjects, nodeIds = [], lastChunk = false)
{
    let curNodeId  = NULL;
    let figObjects = null;


    _genIgnoreNodeIds.push(...nodeIds);


    for (const genObj of genObjects)
    {
        _genIgnoreObjects.push(genObj);


        if (genObj[FO_NODE_ID] != curNodeId) //.nodeId
        {
            curNodeId  = genObj[FO_NODE_ID];
            
            figObjects = figObjectArrays.find(a => a.nodeId == genObj[FO_NODE_ID]);

            if (!figObjects)
            {
                figObjectArrays.push(figObjects = 
                {
                    nodeId:   genObj[FO_NODE_ID], 
                    //existing: genObj.existing,
                    objects:  []
                });
            }
        }


        const addObject = figObj =>
        {
            if (figParent) 
                figParent.appendChild(figObj);
            else
                figObjects.objects.push(figObj);
        };


        let objects =
            figParent
            ? figParent.children
            : figObjects.objects;

        let figObj = objects.find(o => 
               o.removed
            || o.getPluginData('objectId') == genObj[FO_OBJECT_ID])


        if (   figObj != undefined
            && figObj != null
            && figObj.removed)
        {
            removeFrom(objects, figObj);
        
            if (figPoints.includes(figObj))
                removeFromArray(figPoints, figObj);

            if (figEmptyObjects.includes(figObj))
                removeFromArray(figEmptyObjects, figObj);
        }


        if (   figObj == undefined
            || figObj == null
            || figObj.removed) // no existing object, create new one
            await figCreateObject(genObj, addObject);

        else if (figObj.getPluginData('type') == genObj[FO_TYPE].toString()) // update existing object
            await figUpdateObject(figObj, genObj);
    
        else // delete existing object, create new one
        {
            figObj.remove();

            if (figPoints.includes(figObj))
                removeFromArray(figPoints, figObj);

            if (figEmptyObjects.includes(figObj))
                removeFromArray(figEmptyObjects, figObj);

            await figCreateObject(genObj, addObject);
        }
    }


    // delete removed objects from parent
    
    if (figParent)
    {
        for (const figObj of figParent.children)
            if (!genObjects.find(o => o[FO_OBJECT_ID] == figObj.getPluginData('objectId')))
                figObj.remove();
    }


    // put points on top
    
    for (const point of figPoints)
        point.parent.appendChild(point);


    // delete old content

    if (lastChunk)
    {
        figDeleteObjectsExcept(_genIgnoreNodeIds, _genIgnoreObjects);

        _genIgnoreNodeIds = [];
        _genIgnoreObjects = [];
    }
}



function genObjectIsValid(genObj)
{
    switch (genObj[FO_TYPE])
    {
        case RECTANGLE:   return genRectIsValid      (genObj);
        case LINE:        return genLineIsValid      (genObj);
        case ELLIPSE:     return genEllipseIsValid   (genObj);
        case POLYGON:     return genPolygonIsValid   (genObj);
        case STAR:        return genStarIsValid      (genObj);
        case TEXT_SHAPE:  return genTextIsValid      (genObj);
        case POINT:       return genPointIsValid     (genObj);
        case VECTOR_PATH: return genVectorPathIsValid(genObj);
        case BOOLEAN:     return genBooleanIsValid   (genObj);
        case SHAPE_GROUP: return genShapeGroupIsValid(genObj);
        case FRAME:       return genFrameIsValid     (genObj);
    }
}



function figGetObjectSize(genObj)
{
    (async () =>
    {
        const figObj = await figCreateObject(genObj);
        
        const width  = figObj.width;
        const height = figObj.height;

        figObj.remove();


        figPostMessageToUi(
        {
            cmd: 'uiForwardToGenerator',
            msg: 
            {
                cmd:     'returnFigGetObjectSize',
                objectId: genObj[FO_OBJECT_ID],
                width:    width,
                height:   height
            }
        });
    })();
}



function clearObjectData(figObj)
{
    figObj.setPluginData('type',     '');
    figObj.setPluginData('nodeId',   '');
    figObj.setPluginData('objectId', '');
    figObj.setPluginData('retain',   '');
}
