var _genIgnoreNodeIds   = [];
var _genIgnoreObjects   = [];

var  nominalObjectCount = 0;
var  actualObjectCount  = 0;


function makeObjectName(obj)
{
    return (obj[FO_RETAIN] === 2 ? '' : OBJECT_PREFIX)
         + (showIds ? obj[FO_OBJECT_ID] : obj[FO_OBJECT_NAME]);
}



async function figCreateObject(genObj, addObject = null)
{
    if (!genObjectIsValid(genObj))
        return null;


    let figObj;

    switch (genObj[FO_TYPE])
    {
        case RECTANGLE:      figObj =       figCreateRect         (genObj);  break;
        case LINE:           figObj =       figCreateLine         (genObj);  break;
        case ELLIPSE:        figObj =       figCreateEllipse      (genObj);  break;
        case POLYGON:        figObj =       figCreatePolygon      (genObj);  break;
        case STAR:           figObj =       figCreateStar         (genObj);  break;
        case TEXT_SHAPE:     figObj =       figCreateText         (genObj);  break;
        case POINT:          figObj =       figCreatePoint        (genObj);  break;
        case VECTOR_PATH:    figObj =       figCreateVectorPath   (genObj);  break;
        case VECTOR_NETWORK: figObj =       figCreateVectorNetwork(genObj);  break;
        case SHAPE_BOOLEAN:  figObj = await figCreateShapeBoolean (genObj);  break;
        case SHAPE_GROUP:    figObj = await figCreateShapeGroup   (genObj);  break;
        case FRAME:          figObj = await figCreateFrame        (genObj);  break;
    }
 

    if (    addObject
        &&  figObj != undefined
        &&  figObj != null
        && !figObj.removed)
    {
        figObj.name = makeObjectName(genObj);

        consoleAssert(
               genObj[FO_TYPE] == SHAPE_GROUP // cannot exist without children
            || !!figObj, 
            'no Figma object created');


        if (   figObj != undefined
            && figObj != null)
        {
            figObj.setPluginData('retain', genObj[FO_RETAIN].toString());

            if (genObj[FO_RETAIN] < 2)
            {
                figObj.setPluginData('userId',    figma.currentUser.id);
                figObj.setPluginData('sessionId', figma.currentUser.sessionId.toString());
                figObj.setPluginData('type',      genObj[FO_TYPE     ]);
                figObj.setPluginData('nodeId',    genObj[FO_NODE_ID  ]);
                figObj.setPluginData('objectId',  genObj[FO_OBJECT_ID]);
                figObj.setPluginData('isCenter',  boolToString(genObj[FO_IS_CENTER]));
                

                if (genObj[FO_TYPE] == POINT)
                    figPoints.push(figObj);
            
                if (genObj[FO_DECO])
                    updateDecoObject(figObj);
            }

            addObject(figObj);
        }
    }

    
    if (!genObj.counted)
    {
        actualObjectCount++;
        genObj.counted = true;
    }

    return figObj;
}



async function figUpdateObjectAsync(figObj, genObj)
{
    if (  !genObjectIsValid(genObj)
        || figObj == undefined
        || figObj == null
        || figObj.removed)
        return;

        
    figObj.name = makeObjectName(genObj);
    
    figObj.setPluginData('retain', genObj[FO_RETAIN].toString());


    switch (genObj[FO_TYPE])
    {
        case RECTANGLE:      figUpdateRect         (figObj, genObj);  break;
        case LINE:           figUpdateLine         (figObj, genObj);  break;
        case ELLIPSE:        figUpdateEllipse      (figObj, genObj);  break;
        case POLYGON:        figUpdatePolygon      (figObj, genObj);  break;
        case STAR:           figUpdateStar         (figObj, genObj);  break;
        case TEXT_SHAPE:     figUpdateText         (figObj, genObj);  break;
        case POINT:          figUpdatePoint        (figObj, genObj);  break;
        case VECTOR_PATH:    figUpdateVectorPath   (figObj, genObj);  break;
        case VECTOR_NETWORK: figUpdateVectorNetwork(figObj, genObj);  break;
        case SHAPE_BOOLEAN:  figUpdateBoolean      (figObj, genObj);  break;
        case SHAPE_GROUP:    figUpdateShapeGroup   (figObj, genObj);  break;
        case FRAME:          figUpdateFrame        (figObj, genObj);  break;
    }


    if (    figObj != undefined
        &&  figObj != null
        && !figObj.removed)
    {
        if (figObj.parent == figma.currentPage)
            await figma.currentPage.loadAsync();

        figObj.parent.appendChild(figObj);

        if (genObj[FO_DECO])
            updateDecoObject(figObj);
    }


    if (!genObj.counted)
    {
        actualObjectCount++;
        genObj.counted = true;
    }
}



async function figUpdateObjects(figParent, genObjects, batchSize, totalObjects = -1, nodeIds = [], firstChunk = false, lastChunk = false, zoomToFit = false)
{
    let curNodeId           = NULL;
    let figObjects          = null;
        
    let abort               = false;

    const updateObjects     = [];
    let   updateObjectCount = 0;


    _genIgnoreNodeIds.push(...nodeIds);


    if (totalObjects > -1)
        nominalObjectCount = totalObjects;


    for (const genObj of genObjects)
    {
        _genIgnoreObjects.push(genObj);


        if (genObj[FO_NODE_ID] != curNodeId)
        {
            curNodeId  = genObj[FO_NODE_ID];
            
            figObjects = figObjectArrays.find(a => a.nodeId == genObj[FO_NODE_ID]);

            if (!figObjects)
            {
                figObjectArrays.push(figObjects = 
                {
                    nodeId:  genObj[FO_NODE_ID], 
                    objects: []
                });
            }
        }


        const addObject = figObj =>
        {
            if (    figParent != undefined
                &&  figParent != null
                && !figParent.removed) 
                figParent.appendChild(figObj);
            else
                figObjects.objects.push(figObj);
        };


        let objects =
                figParent != undefined
            &&  figParent != null
            && !figParent.removed
            ? figParent.children
            : figObjects.objects;

        let figObj = objects.find(o => 
               o.removed
            ||    o.getPluginData('userId'   ) == figma.currentUser.id
             //&& o.getPluginData('sessionId') == figma.currentUser.sessionId.toString()
               && o.getPluginData('objectId' ) == genObj[FO_OBJECT_ID]);


        if (   figObj != undefined
            && figObj != null
            && figObj.removed)
        {
            removeFrom(objects, figObj);
        
            if (figPoints.includes(figObj))
                removeFromArray(figPoints, figObj);

            if (figEmptyObjects.includes(figObj))
                removeFromArray(figEmptyObjects, figObj);
        }


        if (   figObj == undefined
            || figObj == null
            || figObj.removed) // no existing object, create new one
        {
            const newObj = await figCreateObject(genObj, addObject);
            updateObjects.push(newObj);
        }

        else if (  figObj != undefined
               &&  figObj != null
               && !figObj.removed
               &&  figObj.getPluginData('type') == genObj[FO_TYPE].toString()) // update existing object
        {
            await figUpdateObjectAsync(figObj, genObj);

            if (    figObj != undefined
                &&  figObj != null
                && !figObj.removed) 
                updateObjects.push(figObj);
        }
    
        else // delete existing object, create new one
        {
            figObj.remove();

            if (figPoints.includes(figObj))
                removeFromArray(figPoints, figObj);

            if (figEmptyObjects.includes(figObj))
                removeFromArray(figEmptyObjects, figObj);

            await figCreateObject(genObj, addObject);
        }


        updateObjectCount++;
        

        if (updateObjectCount >= batchSize)
        {
            const result = await figGetValueFromUiSync(
                'returnObjectUpdate', 
                { 
                    nominalObjectCount: nominalObjectCount,
                    actualObjectCount:  actualObjectCount 
                }
                ) as { key: string, value: boolean };

            abort = result.value;

            updateObjectCount = 0;

            if (abort) break;
        }
    }


    // delete removed objects from parent
    
    if (    figParent != undefined
        &&  figParent != null
        && !figParent.removed)
    {
        for (const figObj of figParent.children)
        {
            if (      figObj != undefined
                   && figObj != null
                   && figObj.removed
                || !genObjects.find(o => 
                           o[FO_OBJECT_ID] == figObj.getPluginData('objectId')
                        && figObj.getPluginData('userId') == figma.currentUser.id))
                        //&& figObj.getPluginData('sessionId') == figma.currentUser.sessionId.toString()))
                figObj.remove();
        }
    }


    // put points on top
    
    for (const point of figPoints)
    {
        if (point.parent == figma.currentPage)
            await figma.currentPage.loadAsync();
        
        if (    point != undefined
            &&  point != null
            && !point.removed
            && !point.parent.removed)
            point.parent.appendChild(point);
    }


    if (    lastChunk
        && !abort)
    {
        // delete old content

        figDeleteObjectsExcept(
            _genIgnoreNodeIds, 
            _genIgnoreObjects);

        _genIgnoreNodeIds = [];
        _genIgnoreObjects = [];

        
        if (   zoomToFit
            && updateObjects.length > 0)
        {
            figma.viewport.scrollAndZoomIntoView(updateObjects);

            const bounds = figGetObjectBounds(updateObjects);
                
            figma.viewport.zoom = Math.min(
                figma.viewport.bounds.width  * figma.viewport.zoom / bounds.width  - 0.05,
                figma.viewport.bounds.height * figma.viewport.zoom / bounds.height - 0.05);
        }
    }


    await figGetValueFromUiSync(
        'returnObjectUpdate', 
        { 
            nominalObjectCount: nominalObjectCount,
            actualObjectCount:  actualObjectCount 
        });
}



function genObjectIsValid(genObj)
{
    switch (genObj[FO_TYPE])
    {
        case RECTANGLE:      return genRectIsValid         (genObj);
        case LINE:           return genLineIsValid         (genObj);
        case ELLIPSE:        return genEllipseIsValid      (genObj);
        case POLYGON:        return genPolygonIsValid      (genObj);
        case STAR:           return genStarIsValid         (genObj);
        case TEXT_SHAPE:     return genTextIsValid         (genObj);
        case POINT:          return genPointIsValid        (genObj);
        case VECTOR_PATH:    return genVectorPathIsValid   (genObj);
        case VECTOR_NETWORK: return genVectorNetworkIsValid(genObj);
        case SHAPE_BOOLEAN:  return genBooleanIsValid      (genObj);
        case SHAPE_GROUP:    return genShapeGroupIsValid   (genObj);
        case FRAME:          return genFrameIsValid        (genObj);
    }
}



async function figGetObjectSize(genObj)
{
    (async () =>
    {
        const figObj = await figCreateObject(genObj);
        
        const width  = figObj.width;
        const height = figObj.height;

        figObj.remove();


        figPostMessageToUi(
        {
            cmd: 'uiForwardToGenerator',
            msg: 
            {
                cmd:     'returnFigGetObjectSize',
                objectId: genObj[FO_OBJECT_ID],
                width:    width,
                height:   height
            }
        });
    })();
}



function clearObjectData(figObj)
{
    figObj.setPluginData('type',      '');
    figObj.setPluginData('nodeId',    '');
    figObj.setPluginData('userId',    '');
    figObj.setPluginData('sessionId', '');
    figObj.setPluginData('objectId',  '');
    figObj.setPluginData('isCenter',  '');
    figObj.setPluginData('retain',    '');
}



function figGetObjectBounds(objects)
{
    const bounds = 
    { 
        left:   0, 
        top:    0, 
        right:  0, 
        bottom: 0 
    };

    for (const obj of objects)
    {
        if (obj.x < bounds.left                || bounds.left == bounds.right ) bounds.left   = obj.x;
        if (obj.y < bounds.top                 || bounds.top  == bounds.bottom) bounds.top    = obj.y;
        if (obj.x + obj.width  > bounds.right  || bounds.left == bounds.right ) bounds.right  = obj.x + obj.width;
        if (obj.y + obj.height > bounds.bottom || bounds.top  == bounds.bottom) bounds.bottom = obj.y + obj.height;
    }

    return {
        x:      bounds.left,
        y:      bounds.top,
        width:  bounds.right  - bounds.left,
        height: bounds.bottom - bounds.top };
}



async function figExport(objectIds, scale, format, suffix)
{
    await figma.currentPage.loadAsync();
    

    for (const objId of objectIds)
    {
        let figObj = figma.currentPage.children.find(o => 
              !o.removed
            && o.getPluginData('userId'  ) == figma.currentUser.id
            && o.getPluginData('objectId') == objId);
    
        if (!figObj) continue;


        const settings: ExportSettingsImage = 
        {
            constraint: 
            {
                type: 'SCALE',
                value: scale
            },
            format: format == 0 ? 'PNG' : 'JPG',
            suffix: suffix
        };


        await figObj.exportAsync(settings);
    }
}