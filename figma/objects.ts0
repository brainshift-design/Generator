var figPoints = [];



function updatePointSizes()
{
    if (figma.viewport.zoom != curZoom)
    {
        figPostMessageToUi({
            cmd: 'uiUpdateZoom', 
            zoom: figma.viewport.zoom});


        curZoom = figma.viewport.zoom;

        for (const point of figPoints)
            updatePointSize(point);
    }
}



function updatePointSize(point)
{
    const _x = point.x + point.width /2;
    const _y = point.y + point.height/2;

    const size = 8 / curZoom;
    console.log('size =', size);
    point.resizeWithoutConstraints(size, size);

    point.x = _x - point.width /2;
    point.y = _y - point.height/2;

    point.strokeWeight = 1.25 / curZoom;
}



function figCreateObject(objects, genObj)
{
    let figObj;

    switch (genObj.type)
    {
        case RECTANGLE:  figObj = figCreateRect   (genObj);  break;
        case LINE:       figObj = figCreateLine   (genObj);  break;
        case ELLIPSE:    figObj = figCreateEllipse(genObj);  break;
        case POLYGON:    figObj = figCreatePolygon(genObj);  break;
        case STAR:       figObj = figCreateStar   (genObj);  break;
        case TEXTSHAPE:  figObj = figCreateText   (genObj);  break;
    }

    console.assert(!!figObj, 'no Figma object created');

    figObj.setPluginData('id',       genObj.objectId);
    figObj.setPluginData('type',     genObj.type);
    figObj.setPluginData('nodeId',   genObj.nodeId);
    
    if (genObj.data == 'point')
        figPoints.push(figObj);
    

    objects.push(figObj);


    figma.currentPage.appendChild(figObj);
}



function figUpdateObjects(msg)
{
    let curNodeId  = NULL;
    let figObjects = null;


    for (const genObj of msg.objects)
    {
        if (genObj.nodeId != curNodeId)
        {
            curNodeId  = genObj.nodeId;
            
            figObjects = figObjectArrays.find(a => a.nodeId == genObj.nodeId);

            if (!figObjects)
            {
                figObjectArrays.push(figObjects = 
                {
                    nodeId:   genObj.nodeId, 
                    existing: genObj.existing,
                    objects:  []
                });
            }
        }


        const figObj = figObjects.objects.find(o => 
               o.removed
            || o.name == makeObjectName(genObj));

        
        if (   isValid(figObj)
            && figObj.removed)
        {
            removeFrom(figObjects.objects, figObj);
        
            if (figPoints.includes(figObj))
                removeFromArray(figPoints, figObj);
        }


        if (  !isValid(figObj)
            || figObj.removed) // no existing object, create new object
            figCreateObject(figObjects.objects, genObj);

        else if (figObj.getPluginData('type') == genObj.type.toString()) // update existing object
            figUpdateObject(figObj, genObj);

        else // delete existing object, create new object
        {
            figObj.remove();

            if (figPoints.includes(figObj))
                removeFromArray(figPoints, figObj);

            figCreateObject(figObjects.objects, genObj);
        }
    }
}



function figUpdateObject(figObj, genObj)
{
    switch (genObj.type)
    {
        case RECTANGLE:  figUpdateRect   (figObj, genObj);  break;
        case LINE:       figUpdateLine   (figObj, genObj);  break;
        case ELLIPSE:    figUpdateEllipse(figObj, genObj);  break;
        case POLYGON:    figUpdatePolygon(figObj, genObj);  break;
        case STAR:       figUpdateStar   (figObj, genObj);  break;
        case TEXTSHAPE:  figUpdateText   (figObj, genObj);  break;
    }
}



function makeObjectName(obj)
{
    return OBJECT_PREFIX + obj.nodeId
         + (obj.objectId != '' ? 'â€ƒ' + obj.objectId : '');
}



///////////////////////////////////////////////////////////////////////////////////////////////////



function genRectIsValid(genRect)
{
    return genRect.x      != null && !isNaN(genRect.x     )
        && genRect.y      != null && !isNaN(genRect.y     )
        && genRect.width  != null && !isNaN(genRect.width )
        && genRect.height != null && !isNaN(genRect.height)
        && genRect.angle  != null && !isNaN(genRect.angle )
        && genRect.round  != null && !isNaN(genRect.round );
}



function figCreateRect(obj)
{
    //console.log(obj);

    const rect = figma.createRectangle();

    rect.name = makeObjectName(obj);

    if (!genRectIsValid(obj))
        return rect;


    rect.x = obj.x;
    rect.y = obj.y;

    rect.resize(
        Math.max(0.01, obj.width), 
        Math.max(0.01, obj.height));
        
    rect.rotation     = obj.angle;
    rect.cornerRadius = obj.round;


    setObjectFills  (rect, obj);
    setObjectStrokes(rect, obj);


    return rect;
}



function figUpdateRect(figRect, genRect)
{
    if (!genRectIsValid(genRect))
        return;


    figRect.x = genRect.x;
    figRect.y = genRect.y;

    if (   figRect.width  != genRect.width
        || figRect.height != genRect.height)
    {
        figRect.resize(
            Math.max(0.01, genRect.width), 
            Math.max(0.01, genRect.height));
    }

    figRect.rotation     = genRect.angle;
    figRect.cornerRadius = genRect.round;


    setObjectFills  (figRect, genRect);
    setObjectStrokes(figRect, genRect);
}



///////////////////////////////////////////////////////////////////////////////////////////////////



function genLineIsValid(genLine)
{
    return genLine.x     != null && !isNaN(genLine.x    )
        && genLine.y     != null && !isNaN(genLine.y    )
        && genLine.width != null && !isNaN(genLine.width)
        && genLine.angle != null && !isNaN(genLine.angle);
}



function figCreateLine(obj)
{
    //console.log(obj);

    const line = figma.createLine();

    line.name = makeObjectName(obj);


    if (!genLineIsValid(obj))
        return line;


    line.x = obj.x;
    line.y = obj.y;
    
    line.resize(Math.max(0.01, obj.width), 0);
        
    line.rotation = obj.angle;


    setObjectFills  (line, obj);
    setObjectStrokes(line, obj);

    
    return line;
}



function figUpdateLine(figLine, genLine)
{
    if (!genLineIsValid(genLine))
        return;


    figLine.x = genLine.x;
    figLine.y = genLine.y;

    if (figLine.width != genLine.width)
        figLine.resize(Math.max(0.01, genLine.width), 0);

    figLine.rotation = genLine.angle;


    setObjectFills  (figLine, genLine);
    setObjectStrokes(figLine, genLine);
}



///////////////////////////////////////////////////////////////////////////////////////////////////



function genEllipseIsValid(genEllipse)
{
    return genEllipse.x      != null && !isNaN(genEllipse.x     )
        && genEllipse.y      != null && !isNaN(genEllipse.y     )
        && genEllipse.width  != null && !isNaN(genEllipse.width )
        && genEllipse.height != null && !isNaN(genEllipse.height)
        && genEllipse.angle  != null && !isNaN(genEllipse.angle );
}



function figCreateEllipse(obj)
{
    //console.log(obj);

    const ellipse = figma.createEllipse();

    ellipse.name = makeObjectName(obj);

    if (!genEllipseIsValid(obj))
        return ellipse;


    ellipse.x = obj.x;
    ellipse.y = obj.y;

    ellipse.rotation = obj.angle;

    
    if (figPoints.includes(ellipse))
        updatePointSize(ellipse);
        
    else
    {
        ellipse.resize(
            Math.max(0.01, obj.width), 
            Math.max(0.01, obj.height));

        setObjectFills  (ellipse, obj);
        setObjectStrokes(ellipse, obj);
    }

    
    return ellipse;
}



function figUpdateEllipse(figEllipse, genEllipse)
{
    if (!genEllipseIsValid(genEllipse))
        return;


    figEllipse.x = genEllipse.x;
    figEllipse.y = genEllipse.y;

    if (   figEllipse.width  != genEllipse.width
        || figEllipse.height != genEllipse.height)
    {
        figEllipse.resize(
            Math.max(0.01, genEllipse.width), 
            Math.max(0.01, genEllipse.height));
    }

    figEllipse.rotation = genEllipse.angle;


    setObjectFills  (figEllipse, genEllipse);
    setObjectStrokes(figEllipse, genEllipse);
}



///////////////////////////////////////////////////////////////////////////////////////////////////



function genPolyIsValid(genPoly)
{
    return genPoly.x       != null && !isNaN(genPoly.x      )
        && genPoly.y       != null && !isNaN(genPoly.y      )
        && genPoly.width   != null && !isNaN(genPoly.width  )
        && genPoly.height  != null && !isNaN(genPoly.height )
        && genPoly.angle   != null && !isNaN(genPoly.angle  )
        && genPoly.round   != null && !isNaN(genPoly.round  )
        && genPoly.corners != null && !isNaN(genPoly.corners);
}



function figCreatePolygon(obj)
{
    //console.log(obj);

    const poly = figma.createPolygon();

    poly.name = makeObjectName(obj);

    if (!genPolyIsValid(obj))
        return poly;


    poly.x = obj.x;
    poly.y = obj.y;
    
    poly.resize(
        Math.max(0.01, obj.width), 
        Math.max(0.01, obj.height));
        
    poly.rotation     = obj.angle;
    poly.cornerRadius = obj.round;
    poly.pointCount   = obj.corners;


    setObjectFills  (poly, obj);
    setObjectStrokes(poly, obj);


    return poly;
}



function figUpdatePolygon(figPoly, genPoly)
{
    if (!genPolyIsValid(genPoly))
        return;


    figPoly.x = genPoly.x;
    figPoly.y = genPoly.y;

    if (   figPoly.width  != genPoly.width
        || figPoly.height != genPoly.height)
    {
        figPoly.resize(
            Math.max(0.01, genPoly.width), 
            Math.max(0.01, genPoly.height));
    }

    figPoly.rotation     = genPoly.angle;
    figPoly.cornerRadius = genPoly.round;
    figPoly.pointCount   = genPoly.corners;


    setObjectFills  (figPoly, genPoly);
    setObjectStrokes(figPoly, genPoly);
}



///////////////////////////////////////////////////////////////////////////////////////////////////



function genStarIsValid(genStar)
{
    return genStar.x      != null && !isNaN(genStar.x     )
        && genStar.y      != null && !isNaN(genStar.y     )
        && genStar.width  != null && !isNaN(genStar.width )
        && genStar.height != null && !isNaN(genStar.height)
        && genStar.angle  != null && !isNaN(genStar.angle )
        && genStar.round  != null && !isNaN(genStar.round )
        && genStar.points != null && !isNaN(genStar.points)
        && genStar.convex != null && !isNaN(genStar.convex);
}



function figCreateStar(obj)
{
    //console.log(obj);

    const star = figma.createStar();

    star.name = makeObjectName(obj);

    if (!genStarIsValid(obj))
        return star;


    star.x = obj.x;
    star.y = obj.y;
    
    star.resize(
        Math.max(0.01, obj.width), 
        Math.max(0.01, obj.height));
        
    star.rotation     = obj.angle;
    star.cornerRadius = obj.round;
    star.pointCount   = obj.points;
    star.innerRadius  = obj.convex / 100;


    setObjectFills  (star, obj);
    setObjectStrokes(star, obj);


    return star;
}



function figUpdateStar(figStar, genStar)
{
    if (!genStarIsValid(genStar))
        return;


    figStar.x = genStar.x;
    figStar.y = genStar.y;

    if (   figStar.width  != genStar.width
        || figStar.height != genStar.height)
    {
        figStar.resize(
            Math.max(0.01, genStar.width), 
            Math.max(0.01, genStar.height));
    }

    figStar.rotation     = genStar.angle;
    figStar.cornerRadius = genStar.round;
    figStar.pointCount   = genStar.points;
    figStar.innerRadius  = genStar.convex / 100;


    setObjectFills  (figStar, genStar);
    setObjectStrokes(figStar, genStar);
}



///////////////////////////////////////////////////////////////////////////////////////////////////



function genTextIsValid(genText)
{
    return genText.text   != null
        && genText.x      != null && !isNaN(genText.x     )
        && genText.y      != null && !isNaN(genText.y     )
        && genText.width  != null && !isNaN(genText.width )
        && genText.height != null && !isNaN(genText.height)
        && genText.angle  != null && !isNaN(genText.angle )
        && genText.font   != null && genText.font != NULL
        && genText.size   != null && !isNaN(genText.size  );
}



function figCreateText(obj)
{
    const text = figma.createText();
    
    text.name = makeObjectName(obj);

    if (!genTextIsValid(obj))
        return text;


    const fontName = 
    { 
        family: obj.font, 
        style: 'Regular' 
    };

    (async function() 
    {
        await figma.loadFontAsync(fontName); 

        text.fontName   = fontName;
        text.fontSize   = Math.max(1, obj.size);
        
        text.characters = obj.text;

        //setTextStyle(text, obj);
    })();


    text.x = obj.x;
    text.y = obj.y;


    text.resize(
        Math.max(0.01, obj.width), 
        Math.max(0.01, obj.height));
        
    text.rotation   = obj.angle;
    

    setObjectFills  (text, obj);
    setObjectStrokes(text, obj);


    return text;
}



function figUpdateText(figText, genText)
{
    if (!genTextIsValid(genText))
        return;


    const fontName = 
    { 
        family: genText.font, 
        style: 'Regular' 
    };

    (async function() 
    { 
        await figma.loadFontAsync(fontName); 

        figText.fontName   = fontName;
        figText.fontSize   = Math.max(1, genText.size);

        figText.characters = genText.text;

        //setTextStyle(figText, genText);
    })();


    figText.x = genText.x;
    figText.y = genText.y;


    if (   figText.width  != genText.width
        || figText.height != genText.height)
    {
        figText.resize(
            Math.max(0.01, genText.width), 
            Math.max(0.01, genText.height));
    }

    figText.rotation     = genText.angle;


    setObjectFills  (figText, genText);
    setObjectStrokes(figText, genText);
}



function setTextStyle(figText, genText)
{
    //switch (genText.style)
    //{

    //}
}



///////////////////////////////////////////////////////////////////////////////////////////////////



// function figCreateFrame()
// {
//     let frame = figma.createFrame();

//     frame.name = 'Generator';

//     let tx : Paint = {type: 'SOLID', color: {r: 0, g: 0, b: 0}, opacity: 0};
//     frame.fills = [tx];

//     //frame.resize(
//     //    (nCols*rectSize + (nCols-1)*hgap),
//     //    (nRows*rectSize + (nRows-1)*hgap));

//     return frame;
// }



///////////////////////////////////////////////////////////////////////////////////////////////////



function getObjectFills(objFills)
{
    const fills = [];

    for (const _fill of objFills)
    {
        const fill = _fill[1].split(' ');

        switch (_fill[0])
        {
            case 'SOLID':
            {
                const color = {
                    r: Math.min(Math.max(0, parseFloat(fill[0]) / 0xff), 1), 
                    g: Math.min(Math.max(0, parseFloat(fill[1]) / 0xff), 1), 
                    b: Math.min(Math.max(0, parseFloat(fill[2]) / 0xff), 1) };

                const opacity = Math.min(Math.max(0, parseFloat(fill[3]) / 100), 1);

                if (   !isNaN(color.r)
                    && !isNaN(color.g)
                    && !isNaN(color.b)
                    && !isNaN(opacity))
                    fills.push(
                    {
                        type:   'SOLID', 
                        color:   color,
                        opacity: opacity
                    });


                break;
            }
        }
    }

    return fills;
}



function setObjectFills(obj, src)
{
    if (   !!src.fills
        &&  !isEmpty(src.fills))
        obj.fills = getObjectFills(src.fills);
    else
        obj.fills = [];
}



function setObjectStrokes(obj, src)
{
    if (    src.strokes != null
        && !isEmpty(src.strokes))
    {
        obj.strokes = getObjectFills(src.strokes);

        obj.strokeWeight     = Math.max(0, src.strokeWeight);
        obj.strokeAlign      = src.strokeAlign;
        obj.strokeJoin       = src.strokeJoin;
        obj.strokeMiterLimit = Math.min(Math.max(0, src.strokeMiterLimit), 16);
    }
    else
        obj.strokes = [];
}