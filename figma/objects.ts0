var figPoints = [];



function updatePointSizes()
{
    if (figma.viewport.zoom != curZoom)
    {
        figPostMessageToUi(
        {
            cmd: 'uiUpdateZoom', 
            zoom: figma.viewport.zoom 
        });
        
        
        curZoom = figma.viewport.zoom;

        for (const point of figPoints)
            updatePointSize(point);
    }
}



function updatePointSize(figPoint)
{
    figPoint.strokeWeight = 1.25 / curZoom;

    const size = 8 / curZoom;
    figPoint.resizeWithoutConstraints(size, size);

    convertExistingPointTransform(figPoint);
}




function updatePointSize_(figPoint, genPoint)
{
    figPoint.strokeWeight = 1.25 / curZoom;
    
    const size = 8 / curZoom;
    figPoint.resizeWithoutConstraints(size, size);

    convertPointTransform(figPoint, genPoint);
}



///////////////////////////////////////////////////////////////////////////////////////////////////



function figCreateObject(genObj, addObject)
{
    let figObj;

    switch (genObj.type)
    {
        case RECTANGLE:   figObj = figCreateRect      (genObj);  break;
        case LINE:        figObj = figCreateLine      (genObj);  break;
        case ELLIPSE:     figObj = figCreateEllipse   (genObj);  break;
        case POLYGON:     figObj = figCreatePolygon   (genObj);  break;
        case STAR:        figObj = figCreateStar      (genObj);  break;
        case TEXTSHAPE:   figObj = figCreateText      (genObj);  break;
        case POINT:       figObj = figCreatePoint     (genObj);  break;
        case VECTOR_PATH: figObj = figCreateVectorPath(genObj);  break;
        case SHAPE_GROUP: figObj = figCreateShapeGroup(genObj);  break;
        case FRAME:       figObj = figCreateFrame     (genObj);  break;
    }

    
    console.assert(
           genObj.type == SHAPE_GROUP // cannot exist without children
        || !!figObj, 
        'no Figma object created');

    if (figObj)
    {
        figObj.setPluginData('id',       genObj.objectId);
        figObj.setPluginData('type',     genObj.type    );
        figObj.setPluginData('nodeId',   genObj.nodeId  );
        figObj.setPluginData('objectId', genObj.objectId);

        
        if (genObj.type == POINT)
            figPoints.push(figObj);


        addObject(figObj);
    }
}



function figUpdateObjects(figParent, genObjects)
{
    let curNodeId  = NULL;
    let figObjects = null;



    for (const genObj of genObjects)
    {
        if (genObj.nodeId != curNodeId)
        {
            curNodeId  = genObj.nodeId;
            
            figObjects = figObjectArrays.find(a => a.nodeId == genObj.nodeId);

            if (!figObjects)
            {
                figObjectArrays.push(figObjects = 
                {
                    nodeId:   genObj.nodeId, 
                    existing: genObj.existing,
                    objects:  []
                });
            }
        }


        let objects =
            figParent
            ? figParent.children
            : figObjects.objects;

        const addObject = obj =>
        {
            if (figParent) figParent.appendChild(obj);
            else           figObjects.objects.push(obj);
        };


        let figObj;

        
        figObj = objects.find(o => 
               o.removed
            || o.getPluginData('objectId') == genObj.objectId)

        
        if (   figObj != undefined
            && figObj != null
            && figObj.removed)
        {
            removeFrom(objects, figObj);
        
            if (figPoints.includes(figObj))
                removeFromArray(figPoints, figObj);
        }


        if (   figObj == undefined
            || figObj == null
            || figObj.removed) // no existing object, create new object
        {
            figCreateObject(genObj, addObject);
        }

        else if (figObj.getPluginData('type') == genObj.type.toString()) // update existing object
        {
            figUpdateObject(figObj, genObj);
        }
    
        else // delete existing object, create new object
        {
            figObj.remove();

            if (figPoints.includes(figObj))
                removeFromArray(figPoints, figObj);

            figCreateObject(genObj, addObject);
        }
    }


    // delete removed objects from parent
    
    if (figParent)
    {
        for (const figObj of figParent.children)
            if (!genObjects.find(o => o.objectId == figObj.getPluginData('objectId')))
                figObj.remove();
    }


    // put points on top
    
    for (const point of figPoints)
        point.parent.appendChild(point);
}



function figUpdateObject(figObj, genObj)
{
    switch (genObj.type)
    {
        case RECTANGLE:   figUpdateRect      (figObj, genObj);  break;
        case LINE:        figUpdateLine      (figObj, genObj);  break;
        case ELLIPSE:     figUpdateEllipse   (figObj, genObj);  break;
        case POLYGON:     figUpdatePolygon   (figObj, genObj);  break;
        case STAR:        figUpdateStar      (figObj, genObj);  break;
        case TEXTSHAPE:   figUpdateText      (figObj, genObj);  break;
        case POINT:       figUpdatePoint     (figObj, genObj);  break;
        case VECTOR_PATH: figUpdateVectorPath(figObj, genObj);  break;
        case SHAPE_GROUP: figUpdateShapeGroup(figObj, genObj);  break;
        case FRAME:       figUpdateFrame     (figObj, genObj);  break;
    }
}



function makeObjectName(obj)
{
    return OBJECT_PREFIX + obj.objectName;
}



///////////////////////////////////////////////////////////////////////////////////////////////////



function genRectIsValid(genRect)
{
    return genRect.x      != null && !isNaN(genRect.x     )
        && genRect.y      != null && !isNaN(genRect.y     )
        && genRect.width  != null && !isNaN(genRect.width )
        && genRect.height != null && !isNaN(genRect.height)
        && genRect.angle  != null && !isNaN(genRect.angle )
        && genRect.round  != null && !isNaN(genRect.round );
}



function figCreateRect(genRect)
{
    const figRect = figma.createRectangle();

    figRect.name = makeObjectName(genRect);

    if (!genRectIsValid(genRect))
        return figRect;


    figRect.cornerRadius = genRect.round;


    setObjectTransform(figRect, genRect);
    setObjectProps    (figRect, genRect);


    return figRect;
}



function figUpdateRect(figRect, genRect)
{
    if (!genRectIsValid(genRect))
        return;


    figRect.name = makeObjectName(genRect);


    figRect.cornerRadius = genRect.round;

    setObjectTransform(figRect, genRect);
    setObjectProps    (figRect, genRect);
}



///////////////////////////////////////////////////////////////////////////////////////////////////



function genLineIsValid(genLine)
{
    return genLine.x     != null && !isNaN(genLine.x    )
        && genLine.y     != null && !isNaN(genLine.y    )
        && genLine.width != null && !isNaN(genLine.width)
        && genLine.angle != null && !isNaN(genLine.angle);
}



function figCreateLine(genLine)
{
    const figLine = figma.createLine();

    figLine.name = makeObjectName(genLine);


    if (!genLineIsValid(genLine))
        return figLine;


    setObjectTransform(figLine, genLine);
    setObjectProps    (figLine, genLine);

    
    return figLine;
}



function figUpdateLine(figLine, genLine)
{
    if (!genLineIsValid(genLine))
        return;


    figLine.name = makeObjectName(genLine);


    setObjectTransform(figLine, genLine);
    setObjectProps    (figLine, genLine);
}



///////////////////////////////////////////////////////////////////////////////////////////////////



function genEllipseIsValid(genEllipse)
{
    return genEllipse.x      != null && !isNaN(genEllipse.x     )
        && genEllipse.y      != null && !isNaN(genEllipse.y     )
        && genEllipse.width  != null && !isNaN(genEllipse.width )
        && genEllipse.height != null && !isNaN(genEllipse.height)
        && genEllipse.angle  != null && !isNaN(genEllipse.angle );
}



function figCreateEllipse(genEllipse)
{
    const figEllipse = figma.createEllipse();


    figEllipse.name = makeObjectName(genEllipse);

    if (!genEllipseIsValid(genEllipse))
        return figEllipse;


    setObjectTransform(figEllipse, genEllipse);

    
    if (figPoints.includes(figEllipse))
        updatePointSize(figEllipse);
        
    else
        setObjectProps(figEllipse, genEllipse);

    
    return figEllipse;
}



function figUpdateEllipse(figEllipse, genEllipse)
{
    if (!genEllipseIsValid(genEllipse))
        return;


    figEllipse.name = makeObjectName(genEllipse);


    setObjectTransform(figEllipse, genEllipse);
    setObjectProps    (figEllipse, genEllipse);
}



///////////////////////////////////////////////////////////////////////////////////////////////////



function genPolyIsValid(genPoly)
{
    return genPoly.x       != null && !isNaN(genPoly.x      )
        && genPoly.y       != null && !isNaN(genPoly.y      )
        && genPoly.width   != null && !isNaN(genPoly.width  )
        && genPoly.height  != null && !isNaN(genPoly.height )
        && genPoly.angle   != null && !isNaN(genPoly.angle  )
        && genPoly.round   != null && !isNaN(genPoly.round  )
        && genPoly.corners != null && !isNaN(genPoly.corners);
}



function figCreatePolygon(genPoly)
{
    const figPoly = figma.createPolygon();

    figPoly.name = makeObjectName(genPoly);

    if (!genPolyIsValid(genPoly))
        return figPoly;


    figPoly.cornerRadius = genPoly.round;
    figPoly.pointCount   = genPoly.corners;


    setObjectTransform(figPoly, genPoly);
    setObjectProps    (figPoly, genPoly);


    return figPoly;
}



function figUpdatePolygon(figPoly, genPoly)
{
    if (!genPolyIsValid(genPoly))
        return;


    figPoly.name = makeObjectName(genPoly);


    figPoly.cornerRadius = genPoly.round;
    figPoly.pointCount   = genPoly.corners;


    setObjectTransform(figPoly, genPoly);
    setObjectProps    (figPoly, genPoly);
}



///////////////////////////////////////////////////////////////////////////////////////////////////



function genStarIsValid(genStar)
{
    return genStar.x      != null && !isNaN(genStar.x     )
        && genStar.y      != null && !isNaN(genStar.y     )
        && genStar.width  != null && !isNaN(genStar.width )
        && genStar.height != null && !isNaN(genStar.height)
        && genStar.angle  != null && !isNaN(genStar.angle )
        && genStar.round  != null && !isNaN(genStar.round )
        && genStar.points != null && !isNaN(genStar.points)
        && genStar.convex != null && !isNaN(genStar.convex);
}



function figCreateStar(genStar)
{
    const figStar = figma.createStar();

    figStar.name = makeObjectName(genStar);

    if (!genStarIsValid(genStar))
        return figStar;


    figStar.cornerRadius = genStar.round;
    figStar.pointCount   = genStar.points;
    figStar.innerRadius  = genStar.convex / 100;


    setObjectTransform(figStar, genStar);
    setObjectProps    (figStar, genStar);


    return figStar;
}



function figUpdateStar(figStar, genStar)
{
    if (!genStarIsValid(genStar))
        return;


    figStar.name = makeObjectName(genStar);


    figStar.cornerRadius = genStar.round;
    figStar.pointCount   = genStar.points;
    figStar.innerRadius  = genStar.convex / 100;


    setObjectTransform(figStar, genStar);
    setObjectProps    (figStar, genStar);
}



///////////////////////////////////////////////////////////////////////////////////////////////////



function genTextIsValid(genText)
{
    return genText.text   != null
        && genText.x      != null && !isNaN(genText.x     )
        && genText.y      != null && !isNaN(genText.y     )
        && genText.width  != null && !isNaN(genText.width )
        && genText.height != null && !isNaN(genText.height)
        && genText.angle  != null && !isNaN(genText.angle )
        && genText.font   != null && genText.font != NULL
        && genText.size   != null && !isNaN(genText.size  );
}



function figCreateText(genText)
{
    const figText = figma.createText();
    
    figText.name = makeObjectName(genText);

    if (!genTextIsValid(genText))
        return figText;


    const fontName = 
    { 
        family: genText.font, 
        style: 'Regular' 
    };

    (async function() 
    {
        await figma.loadFontAsync(fontName); 

        figText.fontName   = fontName;
        figText.fontSize   = Math.max(1, genText.size);
        
        figText.characters = genText.text;
    })();


    setObjectTransform(figText, genText);
    setObjectProps    (figText, genText);


    return figText;
}



function figUpdateText(figText, genText)
{
    if (!genTextIsValid(genText))
        return;


    const fontName = 
    { 
        family: genText.font, 
        style: 'Regular' 
    };

    (async function() 
    { 
        await figma.loadFontAsync(fontName); 

        figText.fontName   = fontName;
        figText.fontSize   = Math.max(1, genText.size);

        figText.characters = genText.text;
    })();


    figText.name = makeObjectName(genText);


    setObjectTransform(figText, genText);
    setObjectProps    (figText, genText);
}



function setTextStyle(figText, genText)
{
    //switch (genText.style)
    //{

    //}
}



///////////////////////////////////////////////////////////////////////////////////////////////////



function genPointIsValid(genPoint)
{
    return genPoint.x != null && !isNaN(genPoint.x)
        && genPoint.y != null && !isNaN(genPoint.y);
}



function figCreatePoint(genPoint)
{    
    const figPoint = figma.createEllipse();

    figPoint.name = makeObjectName(genPoint);

    if (!genPointIsValid(genPoint))
        return figPoint;


    figPoint.rotation = 0;

    
    if (figPoints.includes(figPoint))
        updatePointSize_(figPoint, genPoint);

    else
    {
        figPoint.x = genPoint.x;
        figPoint.y = genPoint.y;


        const size = 8 / curZoom;

        figPoint.resizeWithoutConstraints(size, size);


        figPoint.setPluginData('actualX', genPoint.relativeTransform[0][2].toString());
        figPoint.setPluginData('actualY', genPoint.relativeTransform[1][2].toString());


        convertPointTransform(figPoint, genPoint);

       
        figPoint.fills            =  getObjectFills([['SOLID', '255 255 255 100']]);
        figPoint.strokes          =  getObjectFills([['SOLID',  '12 140 233 100']]);

        figPoint.strokeWeight     =  1.25 / curZoom;
        figPoint.strokeAlign      = 'INSIDE';
        figPoint.strokeJoin       = 'MITER';
        figPoint.strokeMiterLimit =  2;
    }

    
    return figPoint;
}



function figUpdatePoint(figPoint, genPoint)
{
    if (!genPointIsValid(genPoint))
        return;


    figPoint.name = makeObjectName(genPoint);


    figPoint.x = genPoint.x;
    figPoint.y = genPoint.y;


    const size = 8 / curZoom;

    figPoint.resizeWithoutConstraints(size, size);


    figPoint.setPluginData('actualX', genPoint.relativeTransform[0][2].toString());
    figPoint.setPluginData('actualY', genPoint.relativeTransform[1][2].toString());


    convertPointTransform(figPoint, genPoint);


    figPoint.strokeWeight = 1.25 / curZoom;
}



///////////////////////////////////////////////////////////////////////////////////////////////////



function genVectorPathIsValid(genPath)
{
    return genPath.winding != null && !isNaN(genPath.winding)
        && genPath.round   != null && !isNaN(genPath.round  );
}



function figCreateVectorPath(genPath)
{
    const figPath = figma.createVector();

    figPath.name = makeObjectName(genPath);

    if (!genVectorPathIsValid(genPath))
        return figPath;

    
    figPath.vectorPaths = [{
        windingRule: genPath.winding == 1 ? 'NONZERO' : 'EVENODD',
        data:        genPath.pathData
    }];


    figPath.cornerRadius = genPath.round;


    setObjectTransform(figPath, genPath);
    setObjectProps    (figPath, genPath);


    return figPath;
}



function figUpdateVectorPath(figPath, genPath)
{
    if (!genVectorPathIsValid(genPath))
        return;


    figPath.name = makeObjectName(genPath);

    
    figPath.vectorPaths = [{
        windingRule: genPath.winding == 1 ? 'NONZERO' : 'EVENODD',
        data:        genPath.pathData
    }];


    figPath.cornerRadius = genPath.round;
    

    setObjectTransform(figPath, genPath);
    setObjectProps    (figPath, genPath);
}



///////////////////////////////////////////////////////////////////////////////////////////////////



function genShapeGroupIsValid(genGroup)
{
    return genGroup.children.length > 0;
}



function figCreateShapeGroup(genGroup)
{
    let objects = [];

    for (const obj of genGroup.children)
        figCreateObject(obj, o => objects = [...objects, o]);


    const figGroup = 
        !isEmpty(objects)
        ? figma.group(objects, figma.currentPage)
        : null;

    if (figGroup)
    {
        figGroup.name = makeObjectName(genGroup);

        if (!genShapeGroupIsValid(genGroup))
            return figGroup;
    }


    setObjectTransform(figGroup, genGroup);


    return figGroup;
}



function figUpdateShapeGroup(figGroup, genGroup)
{
    if (!genShapeGroupIsValid(genGroup))
    {
        figGroup.remove();
        return;
    }


    figGroup.name = makeObjectName(genGroup);


    setObjectTransform(figGroup, genGroup);


    figUpdateObjects(figGroup, genGroup.children);


    figPostMessageToUi({
        cmd:   'uiUpdateGroupBounds',
        nodeId: genGroup.nodeId,
        x:      figGroup.x,
        y:      figGroup.y,
        width:  figGroup.width,
        height: figGroup.height
    });
}



///////////////////////////////////////////////////////////////////////////////////////////////////



function genFrameIsValid(genGroup)
{
    return genGroup.x      != null && !isNaN(genGroup.x     )
        && genGroup.y      != null && !isNaN(genGroup.y     )
        && genGroup.width  != null && !isNaN(genGroup.width )
        && genGroup.height != null && !isNaN(genGroup.height)
        && genGroup.round  != null && !isNaN(genGroup.round )
        && genGroup.angle  != null && !isNaN(genGroup.angle );
}



function figCreateFrame(genFrame)
{
    const figFrame = figma.createFrame();

    figFrame.name = makeObjectName(genFrame);

    if (!genFrameIsValid(genFrame))
        return figFrame;


    if (figFrame)
    {
        if (!genFrameIsValid(genFrame))
            return figFrame;
        
        
        figFrame.cornerRadius = genFrame.round;

        
        setObjectTransform(figFrame, genFrame);
        setObjectProps    (figFrame, genFrame);


        let objects = [];

        for (const obj of genFrame.children)
            figCreateObject(obj, o => objects = [...objects, o]);

        for (const obj of objects)
            figFrame.appendChild(obj);
    }


    return figFrame;
}



function figUpdateFrame(figFrame, genFrame)
{
    if (!genFrameIsValid(genFrame))
        return;


    figFrame.name = makeObjectName(genFrame);


    figFrame.cornerRadius = genFrame.round;


    setObjectTransform(figFrame, genFrame);
    setObjectProps    (figFrame, genFrame);
        

    figUpdateObjects(figFrame, genFrame.children);
}



///////////////////////////////////////////////////////////////////////////////////////////////////



function setObjectTransform(figObj, genObj)
{
    if (   figObj.width  != genObj.width
        || figObj.height != genObj.height)
    {
        figObj.resize(
            Math.max(0.01, genObj.width), 
            Math.max(0.01, genObj.height));
    }

    
    convertObjectTransform(figObj, genObj);
}



function convertObjectTransform(figObj, genObj)
{
    figObj.relativeTransform = 
    [
        genObj.relativeTransform[0],
        genObj.relativeTransform[1]
    ];
}



function convertPointTransform(figObj, genObj)
{
    const m0 = genObj.relativeTransform[0];
    const m1 = genObj.relativeTransform[1];
    

    //const size = 8 / curZoom;

    figObj.relativeTransform = 
    [
        [m0[0], m0[1], m0[2]],// - size/2],
        [m1[0], m1[1], m1[2]]//,// - size/2],
    ];
}



function convertExistingPointTransform(figPoint)
{
    const m0 = figPoint.relativeTransform[0];
    const m1 = figPoint.relativeTransform[1];
    

    //const size = 8 / curZoom;

    figPoint.relativeTransform = 
    [
        [m0[0], m0[1], parseFloat(figPoint.getPluginData('actualX'))],// - size/2],
        [m1[0], m1[1], parseFloat(figPoint.getPluginData('actualY'))]// - size/2]
    ];
}



function getObjectFills(genObjFills)
{
    const fills = [];


    for (const fill of genObjFills)
    {
        switch (fill[0])
        {
            case 'SOLID':
            {
                const color = {
                    r: Math.min(Math.max(0, fill[1] / 0xff), 1), 
                    g: Math.min(Math.max(0, fill[2] / 0xff), 1), 
                    b: Math.min(Math.max(0, fill[3] / 0xff), 1) };

                const opacity = Math.min(Math.max(0, fill[4] / 100), 1);

                if (   !isNaN(color.r)
                    && !isNaN(color.g)
                    && !isNaN(color.b)
                    && !isNaN(opacity))
                    fills.push(
                    {
                        type:   'SOLID', 
                        color:   color,
                        opacity: opacity
                    });


                break;
            }
        }
    }


    return fills;
}



function getObjectEffects(genObjEffects)
{
    const effects = [];


    for (const effect of genObjEffects)
    {
        // const effect = _effect[1].split(' ');

        const type = effect[0];

        switch (type)
        {
            case 'DROP_SHADOW':
            {
                const color = {
                    r: Math.min(Math.max(0, effect[1]), 1), 
                    g: Math.min(Math.max(0, effect[2]), 1), 
                    b: Math.min(Math.max(0, effect[3]), 1),
                    a: Math.min(Math.max(0, effect[4]), 1) };

                const offset = {
                    x: effect[5],
                    y: effect[6] };

                const radius = effect[ 7];
                const spread = effect[ 8];
                const blend  = effect[ 9];
                const behind = effect[10];
  

                if (   !isNaN(color.r)
                    && !isNaN(color.g)
                    && !isNaN(color.b)
                    && !isNaN(color.a)
                    && !isNaN(offset.x)
                    && !isNaN(offset.y)
                    && !isNaN(radius)
                    && !isNaN(spread))
                    effects.push(
                    {
                        type:                 type, 
                        color:                color,
                        offset:               offset,
                        radius:               radius,
                        spread:               spread,
                        visible:              true,
                        blendMode:            blend,
                        showShadowBehindNode: behind
                    });

                break;
            }

            case 'INNER_SHADOW':
            {
                const color = {
                    r: Math.min(Math.max(0, effect[1]), 1), 
                    g: Math.min(Math.max(0, effect[2]), 1), 
                    b: Math.min(Math.max(0, effect[3]), 1),
                    a: Math.min(Math.max(0, effect[4]), 1) };

                const offset = {
                    x: effect[5],
                    y: effect[6] };

                const radius = effect[ 7];
                const spread = effect[ 8];
                const blend  = effect[ 9];
  

                if (   !isNaN(color.r)
                    && !isNaN(color.g)
                    && !isNaN(color.b)
                    && !isNaN(color.a)
                    && !isNaN(offset.x)
                    && !isNaN(offset.y)
                    && !isNaN(radius)
                    && !isNaN(spread))
                    effects.push(
                    {
                        type:       type, 
                        color:      color,
                        offset:     offset,
                        radius:     radius,
                        spread:     spread,
                        visible:    true,
                        blendMode:  blend
                    });

                break;
            }
        }
    }


    return effects;
}



function setObjectProps(figObj, genObj)
{
    setObjectFills  (figObj, genObj);
    setObjectStrokes(figObj, genObj);
    setObjectEffects(figObj, genObj);
}



function setObjectFills(figObj, genObj)
{
    if (   !!genObj.fills
        &&  !isEmpty(genObj.fills))
        figObj.fills = getObjectFills(genObj.fills);
    else
        figObj.fills = [];
}



function setObjectStrokes(figObj, genObj)
{
    if (    genObj.strokes != null
        && !isEmpty(genObj.strokes))
    {
        figObj.strokes      = getObjectFills(genObj.strokes);

        figObj.strokeWeight = Math.max(0, genObj.strokeWeight);
        figObj.strokeAlign  = genObj.strokeAlign;
        figObj.strokeJoin   = genObj.strokeJoin;
        
        const miterAngle = genObj.strokeMiterLimit / 360 * Math.PI*2;
        const miterLimit = 1 / Math.sin(miterAngle/2);
        
        figObj.strokeMiterLimit = Math.min(Math.max(0, miterLimit), 16);
    }
    else
        figObj.strokes = [];
}



function setObjectEffects(figObj, genObj)
{
    if (   !!genObj.effects
        &&  !isEmpty(genObj.effects))
        figObj.effects = getObjectEffects(genObj.effects);
    else
        figObj.effects = [];
}