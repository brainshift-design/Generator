function makeObjectName(obj)
{
    return (obj.final ? ''           : OBJECT_PREFIX )
         + (showIds   ? obj.objectId : obj.objectName);
}



async function figCreateObject(genObj, addObject = null)
{
    if (!genObjectIsValid(genObj))
        return;


    let figObj;

    switch (genObj.type)
    {
        case RECTANGLE:   figObj =       figCreateRect      (genObj);  break;
        case LINE:        figObj =       figCreateLine      (genObj);  break;
        case ELLIPSE:     figObj =       figCreateEllipse   (genObj);  break;
        case POLYGON:     figObj =       figCreatePolygon   (genObj);  break;
        case STAR:        figObj =       figCreateStar      (genObj);  break;
        case TEXT_SHAPE:  figObj = await figCreateText      (genObj);  break;
        case POINT:       figObj =       figCreatePoint     (genObj);  break;
        case VECTOR_PATH: figObj =       figCreateVectorPath(genObj);  break;
        case BOOLEAN:     figObj =       figCreateBoolean   (genObj);  break;
        case SHAPE_GROUP: figObj =       figCreateShapeGroup(genObj);  break;
        case FRAME:       figObj =       figCreateFrame     (genObj);  break;
    }


    if (addObject)
    {
        figObj.name = makeObjectName(genObj);


        consoleAssert(
               genObj.type == SHAPE_GROUP // cannot exist without children
            || !!figObj, 
            'no Figma object created');

        if (  !genObj.final
            && figObj)
        {
            figObj.setPluginData('type',     genObj.type    );
            figObj.setPluginData('nodeId',   genObj.nodeId  );
            figObj.setPluginData('objectId', genObj.objectId);
            figObj.setPluginData('final',    boolToString(genObj.final));

            
            if (genObj.type == POINT)
                figPoints.push(figObj);


            addObject(figObj);
        }
    }
        

    return figObj;
}



async function figUpdateObject(figObj, genObj)
{
    if (!genObjectIsValid(genObj))
        return;

        
    figObj.name = makeObjectName(genObj);

    
    switch (genObj.type)
    {
        case RECTANGLE:         figUpdateRect      (figObj, genObj);  break;
        case LINE:              figUpdateLine      (figObj, genObj);  break;
        case ELLIPSE:           figUpdateEllipse   (figObj, genObj);  break;
        case POLYGON:           figUpdatePolygon   (figObj, genObj);  break;
        case STAR:              figUpdateStar      (figObj, genObj);  break;
        case TEXT_SHAPE:  await figUpdateText      (figObj, genObj);  break;
        case POINT:             figUpdatePoint     (figObj, genObj);  break;
        case VECTOR_PATH:       figUpdateVectorPath(figObj, genObj);  break;
        case BOOLEAN:           figUpdateBoolean   (figObj, genObj);  break;
        case SHAPE_GROUP:       figUpdateShapeGroup(figObj, genObj);  break;
        case FRAME:             figUpdateFrame     (figObj, genObj);  break;
    }
}



async function figUpdateObjects(figParent, genObjects)
{
    let curNodeId  = NULL;
    let figObjects = null;



    for (const genObj of genObjects)
    {
        if (genObj.nodeId != curNodeId)
        {
            curNodeId  = genObj.nodeId;
            
            figObjects = figObjectArrays.find(a => a.nodeId == genObj.nodeId);

            if (!figObjects)
            {
                figObjectArrays.push(figObjects = 
                {
                    nodeId:   genObj.nodeId, 
                    existing: genObj.existing,
                    objects:  []
                });
            }
        }


        const addObject = obj =>
        {
            if (figParent) figParent.appendChild(obj);
            else           figObjects.objects.push(obj);
        };


        let objects =
            figParent
            ? figParent.children
            : figObjects.objects;

        let figObj = objects.find(o => 
               o.removed
            || o.getPluginData('objectId') == genObj.objectId)


        if (   figObj != undefined
            && figObj != null
            && figObj.removed)
        {
            removeFrom(objects, figObj);
        
            if (figPoints.includes(figObj))
                removeFromArray(figPoints, figObj);

            if (figEmptyObjects.includes(figObj))
                removeFromArray(figEmptyObjects, figObj);
        }


        if (   figObj == undefined
            || figObj == null
            || figObj.removed) // no existing object, create new object
            await figCreateObject(genObj, addObject);

        else if (figObj.getPluginData('type') == genObj.type.toString()) // update existing object
            await figUpdateObject(figObj, genObj);
    
        else // delete existing object, create new object
        {
            figObj.remove();

            if (figPoints.includes(figObj))
                removeFromArray(figPoints, figObj);

            if (figEmptyObjects.includes(figObj))
                removeFromArray(figEmptyObjects, figObj);

            await figCreateObject(genObj, addObject);
        }
    }


    // delete removed objects from parent
    
    if (figParent)
    {
        for (const figObj of figParent.children)
            if (!genObjects.find(o => o.objectId == figObj.getPluginData('objectId')))
                figObj.remove();
    }


    // put points on top
    
    for (const point of figPoints)
        point.parent.appendChild(point);
}



function genObjectIsValid(genObj)
{
    switch (genObj.type)
    {
        case RECTANGLE:   return genRectIsValid      (genObj);
        case LINE:        return genLineIsValid      (genObj);
        case ELLIPSE:     return genEllipseIsValid   (genObj);
        case POLYGON:     return genPolygonIsValid   (genObj);
        case STAR:        return genStarIsValid      (genObj);
        case TEXT_SHAPE:  return genTextIsValid      (genObj);
        case POINT:       return genPointIsValid     (genObj);
        case VECTOR_PATH: return genVectorPathIsValid(genObj);
        case BOOLEAN:     return genBooleanIsValid   (genObj);
        case SHAPE_GROUP: return genShapeGroupIsValid(genObj);
        case FRAME:       return genFrameIsValid     (genObj);
    }
}



function figGetObjectSize(genObj)
{
    (async () =>
    {
        const figObj = await figCreateObject(genObj);
        
        const width  = figObj.width;
        const height = figObj.height;

        figObj.remove();


        figPostMessageToUi(
        {
            cmd: 'uiForwardToGenerator',
            msg: 
            {
                cmd:     'returnFigGetObjectSize',
                objectId: genObj.objectId,
                width:    width,
                height:   height
            }
        });
    })();
}