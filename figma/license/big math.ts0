// // constants because b0 b1 b2 literals aren't allowed for some reason
// const b0  = BigInt(0);
// const b1  = BigInt(1);
// const b2  = BigInt(2);
// const b3  = BigInt(3);
// const b8  = BigInt(8);
// const bFF = BigInt(0xff);


// var bigBuffer = new Uint8Array(2048);



// function bigRandom(max: bigint = b0)
// {
//     const size = 
//         max > 0
//         ? Math.max(1, Math.floor(bigBitCount(max)/8))
//         : bigBuffer.length;
    
//     if (size > bigBuffer.length)
//         bigBuffer = new Uint8Array(nextPow2(size));
        
//     for (let i = 0; i < size; i++)
//         bigBuffer[i] = toInt(Math.random() * 0x100);

//     let rnd = bigFromBufferAt(bigBuffer, 0, size);

//     if (max > 0)
//         rnd = rnd % BigInt(max);
        
//     return rnd;
// }



// function bigPowMod(n: bigint, e: bigint, m: bigint) // n^e % mod
// {
//     let c = b1;

//     while (e > b0)
//     {
//         if ((e & b1) != b0)
//         {
//             c *= n;
//             c %= m;
//         }

//         e >>= b1;
        
//         n *= n;
//         n %= m;
//     }
    
//     return c;
// }



// function bigNextPrime(n: bigint) 
// {
//     while (!bigIsPrime(++n));
//     return n;
// }



// function bigIsPrime(x: bigint, k = millerRabinIterations) // Miller-Rabin
// {
//     if (x <= b1) return false; 
//     if (x <= b3) return true;
    
//     if (x % b2 == b0) 
//         return false;
        
        
//     let d = x - b1;
//     let s = b0; 
                
//     while (d % b2 == b0) 
//     {
//         d /= b2;
//         s++;
//     }
        

//     for (let i = 0; i < k; i++)    
//     {
//         const a = b2 + bigRandom(x - b1);

//         if (!bigIsWitness(a, s, d, x))
//             return false;        
//     }
        

//     return true; 
// }    

    

// function bigIsWitness(a: bigint, s: bigint, d: bigint, n: bigint)
// {
//     let x = bigPowMod(a, d, n);
        
//     if (x == b1)
//         return true;

//     for (let j = b0; j < s-b1; j++)
//     {
//         if (x == n-b1)
//             return true;
        
//         x = bigPowMod(x, b2, n);
//     }

//     return x == n-b1;
// }



// function bigFromBuffer(buffer)
// {
//     return bigFromBufferAt(buffer, 0, buffer.length);
// }



// function bigFromBufferAt(buffer, start, size)
// {
//     size = Math.min(size, buffer.length - start);
    
//     let val = b0;
//     let mul = b1;

//     for (let i = start+size-1; i >= start; i--) // little-endian
//     {
//         val += mul * BigInt(buffer[i]);
//         mul <<= b8;
//     }

//     return val;
// }



// function bigToBuffer(n: bigint, buffer, bufferSize)
// {
//     bigToBufferAt(n, buffer, 0, bufferSize);
// }



// function bigToBufferAt(n: bigint, buffer, start, bufferSize)
// {
//     let size = Math.ceil(bigBitCount(n) / 8);
    
//     size = Math.min(size, buffer.length - start);

//     start += bufferSize - size;

//     for (let i = start+size-1; i >= start; i--) // little-endian
//     {
//         buffer[i] = Number(n & bFF); 
//         n >>= b8;
//     }
// }



// function bigBitCount(n: bigint)
// {
//     return n.toString(2).length;
// }



// function bigModInvert(n: bigint, m: bigint)
// {
//     const gcd = bigGcdExtended(n, m);

//     if (gcd[0] != b1) return undefined; // inverse doesn't exist
//     else              return (gcd[1] % m + m) % m;
// }



// function bigGcdExtended(n: bigint, m: bigint)
// {
//     if (n == b0)
//         return [m, b0, b1];

//     const gcd = bigGcdExtended(m % n, n);

//     const x   = gcd[1];
//     const y   = gcd[2];

//     return [
//         gcd[0], 
//         y - (m/n)*x,
//         x ];
// }