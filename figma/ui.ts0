var notifyNotificationHandler = null;
var notifyDequeueHandler = () => notifyNotificationHandler = null;

var windowDock = 'normal'; // '', 'maximize', 'top', 'left', 'right', 'bottom'



function figSetWindowRect(x, y, width, height)
{
    (async function()
    {
        let position = true;

        const rect = {
            x:      x,
            y:      y,
            width:  Math.floor(Math.max(0, width )),
            height: Math.floor(Math.max(0, height))    
        };

        
        // if (windowDock != 'normal')
        //     position = true;

        if (isNaN(rect.x)) rect.x = await figma.clientStorage.getAsync('windowX');
        if (isNaN(rect.y)) rect.y = await figma.clientStorage.getAsync('windowY');


        dockWindow(
            windowDock,
            rect, 
            figma.viewport.bounds);


        rect.x      = Math.round(rect.x     );
        rect.y      = Math.round(rect.y     );
        rect.width  = Math.round(rect.width );
        rect.height = Math.round(rect.height);


        // console.log('_ x =',      rect.x);
        // console.log('_ y =',      rect.y);
        // console.log('_ width =',  rect.width);
        // console.log('_ height =', rect.height);


        figma.ui.resize(rect.width, rect.height);

        figma.clientStorage.setAsync('windowWidth',  rect.width);
        figma.clientStorage.setAsync('windowHeight', rect.height);


        if (position)
        {
            //figma.ui.reposition(rect.x, rect.y);

            figma.clientStorage.setAsync('windowX', rect.x);
            figma.clientStorage.setAsync('windowY', rect.y);
        }


        figPostMessageToUi({cmd: 'uiReturnFigSetWindowRect'});
    })();
}



function dockWindow(dock, rect, bounds)
{
    switch (dock)
    {
        case 'normal':   
            // x      = windowX;
            // y      = windowY;
            // width  = windowWidth;
            // height = windowHeight;
            break;
            
        case 'maximize':
            rect.x      = bounds.x;
            rect.y      = bounds.y;
            rect.width  = bounds.width;
            rect.height = bounds.height;        
            break;

        case 'top':      
            rect.x      = bounds.x;
            rect.y      = bounds.y;
            rect.width  = bounds.width;
            break;

        case 'left':     
            rect.x      = bounds.x;
            rect.y      = bounds.y;
            rect.height = bounds.height;        
            break;

        case 'right':    
            rect.x      = bounds.x + bounds.width - rect.width;
            rect.y      = bounds.y;
            rect.height = bounds.height;        
            break;

        case 'bottom':   
            rect.x      = bounds.x;
            rect.y      = bounds.y + bounds.height - rect.height;
            rect.width  = bounds.width;
            break;
    }
}



// function figRepositionWindow(x, y)
// {
//     figma.ui.reposition(x, y);

//     figma.clientStorage.setAsync('windowX', x);
//     figma.clientStorage.setAsync('windowY', y);

//     figPostMessageToUi({cmd: 'uiReturnFigRepositionWindow'});
// }



function figResizeWindow(width, height)
{
    (async function()
    {
        let x, y;

        let position = false;


        const bounds = figma.viewport.bounds;


        width  = Math.floor(Math.max(0, width ));
        height = Math.floor(Math.max(0, height));

        
        if (windowDock != 'normal')
        {
            figma.clientStorage.setAsync('normalWindowX',      await figma.clientStorage.getAsync('normalWindowX'     ));
            figma.clientStorage.setAsync('normalWindowY',      await figma.clientStorage.getAsync('normalWindowY'     ));
            figma.clientStorage.setAsync('normalWindowWidth',  await figma.clientStorage.getAsync('normalWindowWidth' ));
            figma.clientStorage.setAsync('normalWindowHeight', await figma.clientStorage.getAsync('normalWindowHeight'));

            position = true;
        }


        // const windowX = figma.clientStorage.getAsync('windowX');
        // const windowY = figma.clientStorage.getAsync('windowY');


        // switch (windowDock)
        // {
        //     case 'normal':   
        //         // x      = windowX;
        //         // y      = windowY;
        //         // width  = windowWidth;
        //         // height = windowHeight;
        //         break;
                
        //     case 'maximize':
        //         x      = bounds.x;
        //         y      = bounds.y;
        //         width  = bounds.width;
        //         height = bounds.height;        
        //         break;

        //     case 'top':      
        //         x      = bounds.x;
        //         y      = bounds.y;
        //         width  = bounds.width;
        //         break;

        //     case 'left':     
        //         x      = bounds.x;
        //         y      = bounds.y;
        //         height = bounds.height;        
        //         break;

        //     case 'right':    
        //         x      = bounds.x + bounds.width - width;
        //         y      = bounds.y;
        //         height = bounds.height;        
        //         break;

        //     case 'bottom':   
        //         x      = bounds.x;
        //         y      = bounds.y + bounds.height - height;
        //         width  = bounds.width;
        //         break;
        // }


        // x      = Math.round(x     );
        // y      = Math.round(y     );
        width  = Math.round(width );
        height = Math.round(height);


        // console.log('width =',  width);
        // console.log('height =', height);

        figma.ui.resize(width, height);

        figma.currentPage.setPluginData(figma.currentUser.id+',windowWidth',  width .toString());
        figma.currentPage.setPluginData(figma.currentUser.id+',windowHeight', height.toString());


        // if (position)
        // {
        //     figma.ui.reposition(x, y);

        //     figma.clientStorage.setAsync('windowX', x);
        //     figma.clientStorage.setAsync('windowY', y);
        // }


        figPostMessageToUi({cmd: 'uiReturnFigResizeWindow'});
    })();
}



async function figDockWindow(dock) 
{
    if (   dock       != 'normal'
        && windowDock == 'normal')
    {
        figma.clientStorage.setAsync('normalWindowX',      await figma.clientStorage.getAsync('normalWindowX'     ));
        figma.clientStorage.setAsync('normalWindowY',      await figma.clientStorage.getAsync('normalWindowY'     ));
        figma.clientStorage.setAsync('normalWindowWidth',  await figma.clientStorage.getAsync('normalWindowWidth' ));
        figma.clientStorage.setAsync('normalWindowHeight', await figma.clientStorage.getAsync('normalWindowHeight'));
    }


    windowDock = dock;

    figma.clientStorage.setAsync('windowDock', dock);

    figResizeWindow(
        await figma.clientStorage.getAsync('windowWidth' ),
        await figma.clientStorage.getAsync('windowHeight'));
}



function figNotifyMsg(msg)
{
    figNotify(
        msg.text, 
        msg.prefix, 
        msg.delay, 
        msg.error, 
        msg.buttonText,
        msg.buttonAction);
}



function figNotify(text, prefix = 'Generator ', delay = 400, error = false, buttonText = '', buttonAction = NULL)
{
    const options = {
        timeout:   delay,
        error:     error,
        onDequeue: notifyDequeueHandler
    };


    if (buttonText != '')
    {
        options['button'] = {text: buttonText};

        switch (buttonAction)
        {
            case 'hideClearUndoWarning':
                options['button']['action'] = () => figPostMessageToUi({ cmd: 'uiHideClearUndoWarning' });
                break;
        }
    }


    if (notifyNotificationHandler)
        notifyNotificationHandler.cancel();


    notifyNotificationHandler = figma.notify(prefix + text, options);
}