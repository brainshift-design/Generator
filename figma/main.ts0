//figma.on('selectionchange', figOnSelectionChange);

figma.on('documentchange',  figOnDocumentChange);
figma.on('selectionchange', figOnSelectionChange);
figma.on('close',           figOnPluginClose);


figDeleteAllObjects(true);



figma.showUI(
    __html__,
    {
        visible:     false,
        themeColors: true
    });
    


var curZoom = figma.viewport.zoom;
setInterval(figOnZoomInterval, 100);


const clockMarker   = 'clock_';
const clockInterval = 1000;


var showIds = false;


// figma.currentPage
//     .getPluginDataKeys()
//     .forEach(k => figma.currentPage.setPluginData(k, figma.currentPage.getPluginData(k).replace('\\', '\\\\')));



function figStartGenerator()
{
    (async function()
    {
        let _wndWidth  = await figma.currentPage.getPluginData(figma.currentUser.id+',windowWidth');
        let _wndHeight = await figma.currentPage.getPluginData(figma.currentUser.id+',windowHeight');

        let wndWidth;
        let wndHeight;

        if (_wndWidth  === NULL) { wndWidth  = 800; figma.currentPage.setPluginData(figma.currentUser.id+',windowWidth',  _wndWidth .toString()); } else wndWidth  = parseInt(_wndWidth );
        if (_wndHeight === NULL) { wndHeight = 600; figma.currentPage.setPluginData(figma.currentUser.id+',windowHeight', _wndHeight.toString()); } else wndHeight = parseInt(_wndHeight);

        
        figma.ui.resize(
            Math.max(0, wndWidth),
            Math.max(0, wndHeight));

        figma.ui.show();

        
        const fonts = await figma.listAvailableFontsAsync();
        // console.log('figma fonts =', fonts);
 
        const eulaRead = (await figma.clientStorage.getAsync('eulaRead')) === 'true';
        const isLocked = figPageIsLocked();

        
        figPostMessageToUi({
            cmd:         'uiReturnFigStartGenerator',
            currentUser:  figma.currentUser,
            viewportRect: figma.viewport.bounds,
            viewportZoom: figma.viewport.zoom,
            fonts:        fonts,
            eulaRead:     eulaRead,
            isLocked:     isLocked });
    })();
}



function figRestartGenerator()
{
    figDeleteAllObjects();

    figma.showUI(
        __html__,
        {
            visible:     false,
            themeColors: true
        });
}



function figFinishStart()
{
    setInterval(figOnIdInterval, 5000);
}



function figOnZoomInterval()
{
    if (figma.viewport.zoom == curZoom)
        return;

    curZoom = figma.viewport.zoom;

    updatePointObjects();
    updateEmptyObjects();
    updateDecoObjects();
}



function figOnIdInterval()
{
    figSetPageData(clockMarker + figma.currentUser.id, Date.now().toString())
}



function figPageIsLocked()
{
    const clocks = figma.currentPage.getPluginDataKeys()
        .filter(k => 
               k.length > clockMarker.length
            && k.substring(0, clockMarker.length) == clockMarker)
        .map(k => parseInt(figGetPageData(k)));


    clocks.sort();
    console.log('clocks =', clocks);

    
    return clocks.length > 0
        && Date.now() - clocks.at(-1) < clockInterval*2;
}



function figOnSelectionChange()
{
    updatePointObjects();
}