//const MAX_NODES   = 0x10000;

//const objNodes    = new Array(MAX_NODES).fill(null);

//var   minNodeId   = Number.MAX_SAFE_INTEGER;
//var   maxNodeId   = Number.MIN_SAFE_INTEGER;


//figma.on('selectionchange', figOnSelectionChange);

figma.on('documentchange', figOnDocumentChange);
figma.on('close',          figOnPluginClose);



figma.showUI(
    __html__,
    {
        visible:     false,
        themeColors: true
    });


    
// figma.currentPage
//     .getPluginDataKeys()
//     .forEach(k => figma.currentPage.setPluginData(k, ''));



function figStartGenerator()
{
    (async function()
    {
        let productKey = await figLoadLocal('productKey');
        if (productKey == null) productKey = '';

        
        let _wndWidth  = await figma.currentPage.getPluginData(figma.currentUser.id+',windowWidth');
        let _wndHeight = await figma.currentPage.getPluginData(figma.currentUser.id+',windowHeight');

        let wndWidth;
        let wndHeight;

        if (_wndWidth  === NULL) { wndWidth  = 800; figma.currentPage.setPluginData(figma.currentUser.id+',windowWidth',  _wndWidth .toString()); } else wndWidth  = parseInt(_wndWidth );
        if (_wndHeight === NULL) { wndHeight = 600; figma.currentPage.setPluginData(figma.currentUser.id+',windowHeight', _wndHeight.toString()); } else wndHeight = parseInt(_wndHeight);

        
        figma.ui.resize(
            Math.max(0, wndWidth),
            Math.max(0, wndHeight));

        figma.ui.show();

        
        figPostMessageToUi({
            cmd:         'uiReturnFigStartGenerator',
            currentUser:  figma.currentUser,
            productKey:   productKey,
            viewportRect: figma.viewport.bounds });
    })();
}



function figRestartGenerator()
{
    figma.showUI(
        __html__,
        {
            visible:     false,
            themeColors: true
        });
}