const OBJ_RECT = 1;

const MAX_OBJECTS = 0x10000;
const MAX_NODES   = 0x10000;

const objNodes = new Array(MAX_NODES).fill(null);

var minNodeId = Number.MAX_SAFE_INTEGER;
var maxNodeId = Number.MIN_SAFE_INTEGER;


// const objects  = new Array(MAX_OBJECTS);
// var   maxObjId = -1;


figma.showUI(__html__);


figma.ui.onmessage = msg => 
{
    switch (msg.cmd)
    {
        case 'saveLocal':         saveLocal    (msg.key, msg.value); break;
        case 'setPluginData':     setPluginData(msg.key, msg.value); break;
        case 'loadState':         loadState(msg);                    break;
        case 'resizeWindow':      resizeWindow(msg);                 break; 
        case 'deleteNodeObjects': deleteNodeObjects(msg.nodeIds);    break; 
        case 'updateObjects':     updateObjects(msg);                break;
        case 'notify':            notify(msg.text);                  break;
    }
};



figma.on('selectionchange', onSelectionChange);
figma.on('close',           onPluginClose);



function loadState(msg)
{
    (async function()
    {
        // load state
        var state = await figma.clientStorage.getAsync('state');
        if (state == null) state = {};
        // ...

        // resize window
        var wndWidth  = await figma.clientStorage.getAsync('windowWidth');
        var wndHeight = await figma.clientStorage.getAsync('windowHeight');

        if (wndWidth  == null) wndWidth  = 400;
        if (wndHeight == null) wndHeight = 300;

        figma.ui.resize(
            Math.max(0, wndWidth),
            Math.max(0, wndHeight));

        figma.ui.postMessage({
            cmd:        'loadState',
            currentUser: figma.currentUser });
    })();
}



function saveLocal(key, value)
{
    figma.clientStorage.setAsync(key, value); 
}



function setPluginData(key, value)
{
    figma.currentPage.setPluginData(key, value);
}



function resizeWindow(msg)
{
    var width  = Math.floor(Math.max(0, msg.width ));
    var height = Math.floor(Math.max(0, msg.height));

    figma.ui.resize(width, height);

    figma.clientStorage.setAsync('windowWidth',  width);
    figma.clientStorage.setAsync('windowHeight', height);

    //figma.ui.postMessage({cmd: 'updatePanAndZoom'});
}



function objTypeString(type)
{
    switch (type)
    {
        case OBJ_RECT: return 'RECTANGLE';
        // case 'VECTOR':
        // case 'LINE':
        // case 'ELLIPSE':
        // case 'POLYGON':
        // case 'STAR':
        // case 'TEXT':
        // case 'BOOLEAN_OPERATION':
    }

    return 'ERROR_TYPE';
}



function onSelectionChange()
{
    /*  Every time a selection changes, check that all objects in the object table
        still exist in the canvas. If not, remove the pointer from the object table.  
        
        NOTE: at this point I don't know if objects are deleted by the API, but then again,
        only one plugin runs at a time right now, so maybe it's not an issue.  */


    for (let i = 0; i < objNodes.length; i++)
    {
        for (let j = 0; j < objNodes[i].length; j++)
        {
            if (!objNodes[i][j]) continue;

            const exists = figma.currentPage.children.findIndex(obj => parseInt(obj.getPluginData('id')) == i);
            if (!exists) objNodes[i][j] = null;
        }
    }
}



function onPluginClose()
{
    deleteAllObjects();
}



function postToGenerator(msg)
{
    figma.ui.postMessage({
        cmd: 'forwardToGen',
        msg:  msg
    });
}



function notify(text)
{
    figma.notify('Generator: ' + text);
}