async function figLoadLocal(key)
{
    return await figma.clientStorage.getAsync(key); 
}



function figGetLocalData(key)
{
    figma.clientStorage.getAsync(key).then(data =>
    {
        //console.log('getAsync', data);
        figPostMessageToUI({
            cmd:  'uiGetLocalDataReturn',
            key:   key,
            value: data
        });
    });
}



function figSetLocalData(key, value)
{
    figma.clientStorage.setAsync(key, value); 
}



function figGetPageData(key, postToUi = true)
{
    const data = figma.currentPage.getPluginData(key);

    if (postToUi)
    {
        figPostMessageToUI({
            cmd:  'uiGetPageDataReturn',
            key:   key,
            value: data
        });
    }

    return data;
}



function figSetPageData(key, value)
{
    figClearPageData(key); // remove possible existing values first
    figma.currentPage.setPluginData(key, value);
}



function figClearPageData(key)
{
    figma.currentPage.setPluginData(key, ''); 
}



function figLoadNodesAndConns()
{
    const nodeKeys  = figma.currentPage.getPluginDataKeys().filter(k => isNodeKey(k));
    const connKeys  = figma.currentPage.getPluginDataKeys().filter(k => isConnKey(k));
    
    const nodes     = nodeKeys.map(k => figma.currentPage.getPluginData(k));
    const conns     = connKeys.map(k => figma.currentPage.getPluginData(k));

    const nodesJson = JSON.stringify(nodes);
    const connsJson = JSON.stringify(conns);

    figPostMessageToUI({
        cmd:       'uiLoadNodesAndConns',
        nodesJson:  nodesJson,
        connsJson:  connsJson
    });
}



function figSaveNodes(nodeIds, nodeJson)
{
    for (let i = 0; i < nodeIds.length; i++)
    {
        figSetPageData(
            nodeNameForStorage(nodeIds[i]),
            nodeJson[i]);        
    }
}



function figRemoveConnsToNodes(nodeIds)
{
    const connKeys = figma.currentPage.getPluginDataKeys().filter(k => isConnKey(k));

    for (const key of connKeys)
    {
        const parts = noConnTag(key).split(' ');

        if (   nodeIds.includes(parts[0])
            || nodeIds.includes(parts[2]))
            figClearPageData(key);
    }
}



function figRemoveSavedNodesAndConns(nodeIds)
{
    const nodeKeys = figma.currentPage.getPluginDataKeys().filter(
           k => isNodeKey(k)
        && nodeIds.includes(noNodeTag(k)));

    nodeKeys.forEach(k => figClearPageData(k));

    figRemoveConnsToNodes(nodeIds);
}



function figRemoveAllSavedNodesAndConns()
{
    const nodeKeys = figma.currentPage.getPluginDataKeys().filter(k => isNodeKey(k));
    const connKeys = figma.currentPage.getPluginDataKeys().filter(k => isConnKey(k));

    for (const key of nodeKeys) figClearPageData(key);
    for (const key of connKeys) figClearPageData(key);
}



function figLogAllSavedNodesAndConns(settings)
{
    figLogAllSavedNodes(settings);
    figLogAllSavedConns(settings);
}



function figLogAllSavedNodes(settings)
{
    if (!settings.logLoading)
        return;

    figma.currentPage.getPluginDataKeys()
        .filter (k => isNodeKey(k))
        .forEach(k => logSavedNode(k));
}



function figLogAllSavedConns(settings)
{
    if (!settings.logLoading)
        return;

    const connKeys = figma.currentPage.getPluginDataKeys()
        .filter(k => isConnKey(k));
        
    connKeys.sort((key1, key2) => 
    {
        const p1 = noConnTag(key1).split(' ');
        const p2 = noConnTag(key2).split(' ');

        if (p1[2] != p2[2]) return p1[2] < p2[2] ? -1 : 1;
        if (p1[3] != p2[3]) return parseInt(p1[3]) - parseInt(p2[3]);
        
        if (p1[2] == p2[0]) return -1;
        if (p2[2] == p1[0]) return  1;

        return 0;
    });
    
    connKeys.forEach(k => logSavedConn(k));
}



function figSaveConnection(name, json)
{
    // console.log('key', connNameForStorage(name));
    // console.log('connection', json);
    
    figSetPageData(connNameForStorage(name), json);        
}



function figRemoveSavedConnection(name)
{
    //console.log('figRemoveSavedConnection('+name+')');
    figClearPageData(connNameForStorage(name));        
}



function figRemoveSavedConnectionsToNode(nodeId)
{
    const connKeys = figma.currentPage.getPluginDataKeys().filter(k => isConnKey(k));

    for (const key of connKeys)
    {
        const parts = key.split(' ');

        if (parts[3] == nodeId)
            figClearPageData(key);        
    }
}



function nodeNameForStorage(nodeId) { return nodeTag+' '+nodeId; }
function connNameForStorage(name)   { return connTag+' '+name;   }