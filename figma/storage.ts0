async function figLoadLocal(key)
{
    return await figma.clientStorage.getAsync(key); 
}



function figGetLocalData(key)
{
    figma.clientStorage.getAsync(key).then(data =>
    {
        //console.log('getAsync', data);
        figPostMessageToUi({
            cmd:  'uiGetLocalDataReturn',
            key:   key,
            value: data
        });
    });
}



function figSetLocalData(key, value)
{
    figma.clientStorage.setAsync(key, value); 
}



function figGetPageData(key, postToUi = true)
{
    const data = figma.currentPage.getPluginData(key);

    if (postToUi)
    {
        figPostMessageToUi({
            cmd:  'uiGetPageDataReturn',
            key:   key,
            value: data
        });
    }

    return data;
}



function figSetPageData(key, value)
{
    figClearPageData(key); // remove possible existing values first
    figma.currentPage.setPluginData(key, value);
}



function figClearPageData(key)
{
    figma.currentPage.setPluginData(key, ''); 
}



function figLoadNodesAndConns()
{
    const nodeKeys  = figma.currentPage.getPluginDataKeys().filter(k => k.substring(0,   nodeTag.length+1) ==   nodeTag + ' ');
    const connKeys  = figma.currentPage.getPluginDataKeys().filter(k => k.substring(0,   connTag.length+1) ==   connTag + ' ');
    
    const nodes     =   nodeKeys.map(k => figma.currentPage.getPluginData(k));
    const conns     =   connKeys.map(k => figma.currentPage.getPluginData(k));

    const nodesJson = JSON.stringify(nodes);
    const connsJson = JSON.stringify(conns);

    figPostMessageToUi({
        cmd:       'uiLoadNodesAndConns',
        nodesJson:  nodesJson,
        connsJson:  connsJson
    });
}



function figSaveNodes(nodeIds, nodeJson)
{
    for (let i = 0; i < nodeIds.length; i++)
    {
        // console.log('key', nodeNameForStorage(nodeIds[i]));
        // console.log('value', nodeJson[i]);
        
        figSetPageData(
            nodeNameForStorage(nodeIds[i]),
            nodeJson[i]
        );        
    }
}



function figRemoveSavedNodesAndConns(nodeIds)
{
    for (let i = 0; i < nodeIds.length; i++)
        figClearPageData(nodeNameForStorage(nodeIds[i]));        
}



function figRemoveAllSavedNodesAndConns()
{
    const nodeKeys = figma.currentPage.getPluginDataKeys().filter(k => k.substring(0, nodeTag.length+1) == nodeTag+' ');
    const connKeys = figma.currentPage.getPluginDataKeys().filter(k => k.substring(0, connTag.length+1) == connTag+' ');

    for (const key of nodeKeys) figClearPageData(key);
    for (const key of connKeys) figClearPageData(key);
}



function figLogAllSavedNodesAndConns()
{
    const nodeKeys = figma.currentPage.getPluginDataKeys().filter(k => k.substring(0, nodeTag.length+1) == nodeTag+' ');
    const connKeys = figma.currentPage.getPluginDataKeys().filter(k => k.substring(0, connTag.length+1) == connTag+' ');


    for (const key of nodeKeys)
    {
        console.log(
            '%c%s\n%c%s', 
            'background: #fdb', 
            key.substring(nodeTag.length+1), 
            'background: #fed;',    
            figGetPageData(key, false)
                .replace('{\n', '')
                .replace('\n}', '')
                .replace('[\n', '')
                .replace('\n  ]', ''));
    } 


    for (const key of connKeys) 
    {
        let conn = '';

        const parts = key.substring(connTag.length+1).split(' ');

        for (let i = 0; i < parts.length; i++)
        {
            conn += parts[i];

                 if (i == 1)             conn += ' -> ';
            else if (i < parts.length-1) conn += ' ';
        }
        
        console.log(
            '%c%s', 
            'background: #cfc', 
            conn); 
    } 
}



function figSaveConnection(name, json)
{
    // console.log('key', connNameForStorage(name));
    // console.log('connection', json);
    
    figSetPageData(connNameForStorage(name), json);        
}



function figRemoveSavedConnection(name)
{
    figClearPageData(connNameForStorage(name));        
}



function figRemoveSavedConnectionsToNode(nodeId)
{
    const connKeys = figma.currentPage.getPluginDataKeys().filter(k => k.substring(0, 3) == connTag + ' ');

    for (const key of connKeys)
    {
        const parts = key.split(' ');

        if (parts[3] == nodeId)
            figClearPageData(key);        
    }
}



function nodeNameForStorage(nodeId) { return nodeTag   + ' ' + nodeId; }
function connNameForStorage(name)   { return connTag   + ' ' + name;   }