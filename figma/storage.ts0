async function figLoadLocal(key)
{
    return await figma.clientStorage.getAsync(key); 
}



function figGetLocalData(key)
{
    figma.clientStorage.getAsync(key).then(data =>
    {
        figPostMessageToUi({
            cmd:  'uiReturnFigGetLocalData',
            key:   key,
            value: data
        });
    });
}



function figSetLocalData(key, value)
{
    figma.clientStorage.setAsync(key, value); 
}



async function figClearAllLocalData()
{
    const keys = await figma.clientStorage.keysAsync(); 

    for (const key of keys)
        figma.clientStorage.deleteAsync(key);
}



function figGetPageData(key, postToUi = true)
{
    const data = figma.currentPage.getPluginData(key);

    if (postToUi)
    {
        figPostMessageToUi({
            cmd:  'uiReturnFigGetPageData',
            key:   key,
            value: data
        });
    }

    return data;
}



function figSetPageData(key, value)
{
    figClearPageData(key); // remove possible existing values first
    figma.currentPage.setPluginData(key, value);
}



function figClearPageData(key)
{
    figma.currentPage.setPluginData(key, ''); 
}



function figLoadNodesAndConns(dataMode)
{
    // const pageIds  = figma.currentPage.getPluginData('pages');


    const pageKeys  = figma.currentPage.getPluginDataKeys().filter(k => isPageKey(k));
    const nodeKeys  = figma.currentPage.getPluginDataKeys().filter(k => isNodeKey(k));
    const connKeys  = figma.currentPage.getPluginDataKeys().filter(k => isConnKey(k));


    if (!dataMode)
        figMarkForLoading(nodeKeys, connKeys);

    const pages     = pageKeys.map(k => figma.currentPage.getPluginData(k));
    const nodes     = nodeKeys.map(k => figma.currentPage.getPluginData(k));
    const conns     = connKeys.map(k => figma.currentPage.getPluginData(k));


    const pageOrder     = figma.currentPage.getPluginData('pageOrder').split(',');
    const currentPageId = figma.currentPage.getPluginData('currentPageId');
    

    initPageStyles(nodes);


    const showAllColorSpaces = figma.currentPage.getPluginData('showAllColorSpaces');


    figPostMessageToUi({
        cmd:               'uiReturnFigLoadNodesAndConns',
        showAllColorSpaces: showAllColorSpaces,
        pageKeys:           pageKeys,
        pageJson:           pages,
        pageOrder:          pageOrder,
        currentPageId:      currentPageId,
        nodeKeys:           nodeKeys,
        nodeJson:           nodes,
        connKeys:           connKeys,
        connJson:           conns
    });
}



function initPageStyles(nodes)
{
    figStyleArrays = [];

    
    const paintStyles = figma.getLocalPaintStyles();


    for (const _node of nodes)
    {
        console.log('_node =', _node);
        const node = JSON.parse(_node);

        if (node.type == COLOR_STYLE)
        {
            const style = paintStyles.find(s =>
            {
                const nodeId = s.getPluginData('nodeId');
                return nodeId == node.id;
            });

            if (style)
            {
                figStyleArrays.push({
                    nodeId:   node.id, 
                    existing: parseBool(node.existing), 
                    styles:   [style]});
            }
        }
    }
}



function figMarkForLoading(nodeKeys, connKeys)
{
    const loadingFlag = '"loading": "true"';
    const not         = '{\n';
    const set         = '{\n' + HTAB + loadingFlag + ',\n';

    nodeKeys.forEach(k => figma.currentPage.setPluginData(k, 
        figma.currentPage.getPluginData(k)
            .replace(set, not)
            .replace(not, set)));
    
    connKeys.forEach(k => figma.currentPage.setPluginData(k, 
        figma.currentPage.getPluginData(k)
            .replace(set, not)
            .replace(not, set)));
}



function figSavePages(pageIds, pageJson, currentPageId)
{
    for (let i = 0; i < pageIds.length; i++)
    {
        figSetPageData(
            pageNameForStorage(pageIds[i]), 
            pageJson[i]);
    }

    figSetPageData('pageOrder',     pageIds.join(','));
    figSetPageData('currentPageId', currentPageId);
}



function figSaveNodes(nodeIds, nodeJson)
{
    for (let i = 0; i < nodeIds.length; i++)
    {
        figSetPageData(
            nodeNameForStorage(nodeIds[i]),
            nodeJson[i]);        
    }
}



function figRemoveConnsToNodes(nodeIds)
{
    const connKeys = figma.currentPage.getPluginDataKeys().filter(k => isConnKey(k));

    for (const key of connKeys)
    {
        const parts = noConnTag(key).split(' ');

        if (   nodeIds.includes(parts[0])
            || nodeIds.includes(parts[2]))
            figClearPageData(key);
    }
}



function figRemoveSavedNodesAndConns(nodeIds)
{
    figRemoveConnsToNodes(nodeIds);

    const nodeKeys = figma.currentPage.getPluginDataKeys().filter(
           k => isNodeKey(k)
        && nodeIds.includes(noNodeTag(k)));

    nodeKeys.forEach(k => figClearPageData(k));
}



function figRemoveAllSavedNodesAndConns()
{
    const nodeKeys = figma.currentPage.getPluginDataKeys().filter(k => isNodeKey(k));
    const connKeys = figma.currentPage.getPluginDataKeys().filter(k => isConnKey(k));

    for (const key of nodeKeys) figClearPageData(key);
    for (const key of connKeys) figClearPageData(key);
}



function figLogAllSavedNodesAndConns(darkMode)
{
    figLogAllSavedNodes(darkMode);
    figLogAllSavedConns(darkMode);
}



function figLogAllSavedNodes(darkMode)
{
    figma.currentPage.getPluginDataKeys()
        .filter (k => isNodeKey(k))
        .forEach(k => logSavedNode(k, darkMode));
}



function figLogAllSavedConns(darkMode)
{
    const connKeys = figma.currentPage.getPluginDataKeys()
        .filter(k => isConnKey(k));
        
    connKeys.sort((key1, key2) => 
    {
        const p1 = noConnTag(key1).split(' ');
        const p2 = noConnTag(key2).split(' ');

        if (p1[2] != p2[2]) return p1[2] < p2[2] ? -1 : 1;
        if (p1[3] != p2[3]) return parseInt(p1[3]) - parseInt(p2[3]);
        
        if (p1[2] == p2[0]) return -1;
        if (p2[2] == p1[0]) return  1;

        return 0;
    });

    connKeys.forEach(k => logSavedConn(JSON.parse(figma.currentPage.getPluginData(k)), darkMode));
}



function figLogAllSavedPageKeys(darkMode)
{
    const connKeys = figma.currentPage.getPluginDataKeys()
        .filter(k => isPageKey(k));
        
    connKeys.forEach(k => 
        console.log(
            '%c'+k, 
            'background: #fff; color: ' + (darkMode ? 'black' : 'white')));

    const pageOrder = figma.currentPage.getPluginData('pageOrder');
        
    console.log(
        '%c'+pageOrder, 
        'background: #fff; color: ' + (darkMode ? 'black' : 'white'));
}



function figLogAllSavedConnKeys(darkMode)
{
    const connKeys = figma.currentPage.getPluginDataKeys()
        .filter(k => isConnKey(k));
        
    connKeys.forEach(k => 
        console.log(
            '%c'+k, 
            'background: #dff; color: ' + (darkMode ? 'black' : 'white')));
}



function figLogAllLocalData(darkMode)
{
    figma.clientStorage.keysAsync().then(keys =>
        keys.forEach(k => 
            figma.clientStorage.getAsync(k).then(val => console.log(k + ': ' + val))));
}



function figRemoveSavedPage(pageId)
{
    figClearPageData(getPageKey(pageId));

    const pageOrder = figGetPageData('pageOrder').split(',');
    removeFromArrayWhere(pageOrder, id => id == pageId);
    figSetPageData('pageOrder', pageOrder.join(','));
}



function figRemoveAllSavedPages()
{
    const pageKeys = figma.currentPage.getPluginDataKeys().filter(k => isPageKey(k));
    pageKeys.forEach(k => figClearPageData(k));

    figClearPageData('pageOrder');
}



function figSaveConnection(key, json)
{
    figSetPageData(key, json);        
}



function figSaveConnections(_keys, _json)
{
    const keys = JSON.parse(_keys);
    const json = JSON.parse(_json);

    for (let i = 0; i < keys.length; i++)
        figSetPageData(keys[i], json[i]);
}



function figUpdateSavedConnections(_curKeys, _newKeys, _json)
{
    const curKeys = JSON.parse(_curKeys);
    const newKeys = JSON.parse(_newKeys);
    const json    = JSON.parse(_json);

    for (let i = 0; i < curKeys.length; i++)
    {
        figClearPageData(curKeys[i]);
        figSetPageData(newKeys[i], json[i]);
    }
}



function figDeleteSavedConnection(key)
{
    figClearPageData(key);        
}



function figRemoveAllSavedConnections()
{
    const connKeys = figma.currentPage.getPluginDataKeys().filter(k => isConnKey(k));
    connKeys.forEach(k => figClearPageData(k));
}



function figDeleteSavedConnectionsToNode(nodeId)
{
    const connKeys = figma.currentPage.getPluginDataKeys().filter(k => isConnKey(k));

    for (const key of connKeys)
    {
        const parts = key.split(' ');

        if (parts[4] == nodeId)
            figClearPageData(key);        
    }
}



function figDeleteSavedConnectionsFromNode(nodeId)
{
    const connKeys = figma.currentPage.getPluginDataKeys().filter(k => isConnKey(k));

    for (const key of connKeys)
    {
        const parts = key.split(' ');

        if (parts[1] == nodeId)
            figClearPageData(key);        
    }
}



function figRemovePluginDataFromAllLocalStyles()
{
    const localStyles = figma.getLocalPaintStyles();

    for (const style of localStyles)
    {
        style.setPluginData('type',     '');
        style.setPluginData('nodeId',   '');
        style.setPluginData('existing', '');
    }
}