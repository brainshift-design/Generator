function genBooleanIsValid(genBool)
{
    return genBool[FO_BOOLEAN_CHILDREN].length > 0;
}



async function figCreateShapeBoolean(genBool)
{
    console.log('genBool =', genBool);
    let objects = [];

    for (const obj of genBool[FO_BOOLEAN_CHILDREN])
        await figCreateObject(obj, o => objects = [...objects, o]);


    await figma.currentPage.loadAsync();

    
    let figBool = null;

    if (!isEmpty(objects))
    {
        switch (genBool[FO_BOOLEAN_OPERATION])
        {
            case 0: figBool = figma.union    (objects, figma.currentPage); break;
            case 1: figBool = figma.subtract (objects, figma.currentPage); break;
            case 2: figBool = figma.intersect(objects, figma.currentPage); break;
            case 3: figBool = figma.exclude  (objects, figma.currentPage); break;
        }
    }


    if (figBool)
    {
        setObjectTransform(figBool, genBool);

        if (!genBooleanIsValid(genBool))
            return figBool;
    }


    return figBool;
}



function figUpdateBoolean(figBool, genBool, isValid = false)
{
    if (   !isValid
        && !genBooleanIsValid(genBool))
    {
        figBool.remove();
        return;
    }


    setObjectTransform(figBool, genBool);

    figUpdateObjects(
        figBool, 
        genBool[FO_BOOLEAN_CHILDREN], 
        genBool[FO_BOOLEAN_CHILDREN].length);
}