function genBooleanIsValid(genBool)
{
    return genBool.children.length > 0;
}



function figCreateBoolean(genBool)
{
    let objects = [];

    for (const obj of genBool.children)
        figCreateObject(obj, o => objects = [...objects, o]);


    let figBool = null;

    if (!isEmpty(objects))
    {
        switch (genBool.operation)
        {
            case 0: figBool = figma.union    (objects, figma.currentPage); break;
            case 1: figBool = figma.subtract (objects, figma.currentPage); break;
            case 2: figBool = figma.intersect(objects, figma.currentPage); break;
            case 3: figBool = figma.exclude  (objects, figma.currentPage); break;
        }
    }


    if (figBool)
    {
        setObjectTransform(figBool, genBool);

        if (!genBooleanIsValid(genBool))
            return figBool;
    }


    return figBool;
}



function figUpdateBoolean(figBool, genBool, isValid = false)
{
    if (   !isValid
        && !genBooleanIsValid(genBool))
    {
        figBool.remove();
        return;
    }


    setObjectTransform(figBool, genBool);

    figUpdateObjects(
        figBool, 
        genBool.children, 
        genBool.children.length);


    actualObjectCount++;
}