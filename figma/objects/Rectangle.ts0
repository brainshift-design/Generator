function genRectIsValid(genRect)
{
    return genRect[FO_X         ] != null && !isNaN(genRect[FO_X         ])
        && genRect[FO_Y         ] != null && !isNaN(genRect[FO_Y         ])
        && genRect[FO_WIDTH     ] != null && !isNaN(genRect[FO_WIDTH     ])
        && genRect[FO_HEIGHT    ] != null && !isNaN(genRect[FO_HEIGHT    ])
        && genRect[FO_RECT_ROUND] != null && !isNaN(genRect[FO_RECT_ROUND]);
}



function figCreateRect(genRect, addProps, transform)
{
    if (!genRectIsValid(genRect))
        return null;


    const figRect = figma.createRectangle();

    figUpdateRect(figRect, genRect, addProps, transform, true);

    return figRect;
}



function figUpdateRect(figRect, genRect, addProps, transform, isValid = false)
{
    if (   !isValid
        && !genRectIsValid(genRect))
        return;


    const foundCorners = genRect[FO_EFFECTS].findIndex(e => e[0] == 'ROUND_CORNERS');

    if (foundCorners > -1)
    {
        const corners = genRect[FO_EFFECTS][foundCorners];

        figRect.topLeftRadius     = corners[1];
        figRect.topRightRadius    = corners[2];
        figRect.bottomLeftRadius  = corners[3];
        figRect.bottomRightRadius = corners[4];
    }
    else
        figRect.cornerRadius = genRect[FO_RECT_ROUND];


    if (transform)
        setObjectTransform(figRect, genRect);
    
    setObjectProps(figRect, genRect, addProps);


    const foundSides = genRect[FO_EFFECTS].findIndex(e => e[0] == 'STROKE_SIDES');

    if (foundSides > -1)
    {
        const sides = genRect[FO_EFFECTS][foundSides];

        figRect.strokeWeight       = 0;
        figRect.strokeTopWeight    = sides[1];
        figRect.strokeLeftWeight   = sides[2];
        figRect.strokeRightWeight  = sides[3];
        figRect.strokeBottomWeight = sides[4];
    }
}
