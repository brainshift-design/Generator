var figPoints = [];



function genPointIsValid(genPoint)
{
    return genPoint[FO_X] != null && !isNaN(genPoint[FO_X])
        && genPoint[FO_Y] != null && !isNaN(genPoint[FO_Y]);
}



function figCreatePoint(genPoint)
{    
    const figPoint = 
        genPoint[FO_POINT_IS_CENTER]
        ? figma.createRectangle()
        : figma.createEllipse();


    figPoint.setPluginData('isCenter', boolToString(genPoint[FO_POINT_IS_CENTER]));


    if (!genPointIsValid(genPoint))
        return figPoint;


    //figPoint.rotation = 0;

    
    if (figPoints.includes(figPoint))
        updatePointSize_(figPoint, genPoint);
    else
        figUpdatePoint(figPoint, genPoint);

    
    return figPoint;
}



function figUpdatePoint(figPoint, genPoint)
{
    setPointTransform(figPoint, genPoint);
    updatePointStyles(figPoint);
}



function updatePointSizes()
{
    figPostMessageToUi(
    {
        cmd: 'uiUpdateZoom', 
        zoom: figma.viewport.zoom 
    });
    
    for (const point of figPoints)
        updatePointSize(point);
}



function updatePointSize(figPoint)
{
    updateExistingPointTransform(figPoint);
    updatePointStyles(figPoint);
}



function updatePointSize_(figPoint, genPoint)
{
    setPointTransform(figPoint, genPoint);
    updatePointStyles(figPoint);
}



function updatePointStyles(figPoint)
{
    const isCenter = parseBool(figPoint.getPluginData('isCenter'));

    const color =
        isCenter
        ? [0xf2, 0x48, 0x22]
        : [0xff, 0xff, 0xff];

    const border =
        isCenter
        ? [255, 255, 255]
        : [ 12, 140, 233];


    figPoint.fills = getObjectFills([['SOLID', color[0], color[1], color[2], 100]]);


    const effects = [];
    
    effects.push(...getObjectEffects(
        [['DROP_SHADOW', border[0]/255, border[1]/255, border[2]/255,  1, 0, 0, 0, (isCenter ? 3 : 3.6)/curZoom, 'NORMAL', true, true]]));
    
    effects.push(...getObjectEffects(
        [['DROP_SHADOW', color[0]/255, color[1]/255, color[2]/255, 1, 0, 0, 0, 2.4/curZoom, 'NORMAL', true, true]]));


    figPoint.effects = effects;
}
