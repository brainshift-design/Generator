function genEllipseIsValid(genEllipse)
{
    return genEllipse[FO_X            ] != null && !isNaN(genEllipse[FO_X            ])
        && genEllipse[FO_Y            ] != null && !isNaN(genEllipse[FO_Y            ])
        && genEllipse[FO_WIDTH        ] != null && !isNaN(genEllipse[FO_WIDTH        ])
        && genEllipse[FO_HEIGHT       ] != null && !isNaN(genEllipse[FO_HEIGHT       ])
        && genEllipse[FO_ELLIPSE_FROM ] != null && !isNaN(genEllipse[FO_ELLIPSE_FROM ])
        && genEllipse[FO_ELLIPSE_TO   ] != null && !isNaN(genEllipse[FO_ELLIPSE_TO   ])
        && genEllipse[FO_ELLIPSE_INNER] != null && !isNaN(genEllipse[FO_ELLIPSE_INNER]);
}



async function figCreateEllipse(genEllipse)
{
    if (!genEllipseIsValid(genEllipse))
        return null;
    
    
    const figEllipse = figma.createEllipse();


    figUpdateEllipseData(figEllipse, genEllipse);

    
    if (figPoints.includes(figEllipse))
        updatePointObject(figEllipse);
        
    else
        setObjectProps(figEllipse, genEllipse);

    
    return figEllipse;
}



async function figUpdateEllipse(figEllipse, genEllipse)
{
    figUpdateEllipseData(figEllipse, genEllipse);

    setObjectProps(figEllipse, genEllipse);
}



function figUpdateEllipseData(figEllipse, genEllipse)
{
    figEllipse.arcData =
    {
        startingAngle: genEllipse[FO_ELLIPSE_FROM] /360*(Math.PI*2),
        endingAngle:   genEllipse[FO_ELLIPSE_TO  ] /360*(Math.PI*2),
        innerRadius:   Math.min(Math.max(0, genEllipse[FO_ELLIPSE_INNER]/100), 1)
    };

    setObjectTransform(figEllipse, genEllipse);
}